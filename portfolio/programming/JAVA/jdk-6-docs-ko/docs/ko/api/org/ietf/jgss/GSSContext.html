<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:45:05 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
GSSContext (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="GSSContext (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GSSContext.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/ietf/jgss/ChannelBinding.html" title="org.ietf.jgss 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../org/ietf/jgss/GSSCredential.html" title="org.ietf.jgss 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/ietf/jgss/GSSContext.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="GSSContext.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.ietf.jgss</FONT>
<BR>
인터페이스 GSSContext</H2>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public interface <B>GSSContext</B></DL>
</PRE>

<P>
이 인터페이스는, GSS-API 의 시큐리티 문맥을 캡슐화해, 그 문맥으로 이용할 수 있는 시큐리티 서비스를 제공합니다. 시큐리티 문맥은, 로컬에 취득한 자격을 사용해 피어간에 확립됩니다. 1 조의 피어간에는, 같은 자격 또는 다른 자격을 사용하는 복수의 문맥이 동시에 존재하는 경우가 있습니다. GSS-API 는, 피어간의 시큐리티 문맥에 의해 생성되는 토큰을 전송 할 경우에, 부하의 전송 프로토콜에는 의존하지 않고, 그 호출측 어플리케이션에 의존합니다. <p>

호출측이 디폴트의 <code>GSSManager</code> 인스턴스를 사용해 문맥을 인스턴스화하는 경우는, Kerberos v5 GSS-API 기구를 사용해 문맥이 확립됩니다. Kerberos v5 기구는, OID 「1.2. 840.113554. 1.2. 2」(으)로서 식별되어 RFC 1964 에 정의되고 있습니다. <p>

문맥의 확립 처리가 개시되기 전에, 확립되는 문맥의 특성을 기동측이 요구하는 경우가 있습니다. 호출측이 요구한 특성이, 부하의 기구에 의해 지원되어 있지 않은 것이 있습니다. 문맥이 확립하면(자), 호출측은 다양한 쿼리메소드를 사용해, 그 문맥으로부터 제공된 실제의 특성이나 서비스를 확인할 수 있습니다. 디폴트의 <code>GSSManager</code> 인스턴스로부터 제공되는 Kerberos v5 GSS-API 기구를 사용하고 있을 때는, 모든 옵션 서비스를 로컬에 이용할 수 있습니다. 예를 들어, 상호 인증, 자격의 위양, 기밀성과 무결성의 보호, 메세지마다의 리플레이 검출이나 순서부등을 이용할 수 있습니다. GSS-API 에서는, 메세지의 기밀성을 보호하려면 , 메세지의 무결성을 보호할 필요가 있습니다. <p>

문맥이 확립할 때까지, 기동 측에 의한 <A HREF="../../../org/ietf/jgss/GSSContext.html#initSecContext(byte[], int, int)"><CODE>initSecContext</CODE></A>  호출과 받아 들이는 쪽에 의한 <A HREF="../../../org/ietf/jgss/GSSContext.html#acceptSecContext(byte[], int, int)"><CODE>acceptSecContext</CODE></A>  호출이 반복해집니다.  이 루프는, 문맥이 확립하면(자) 종료합니다. 이 루프의 처리중에,<code>initSecContext</code> 및 <code>acceptSecContext</code> 메소드가 토큰을 생성해, 어플리케이션은 그 토큰을 피어에 송신합니다. 피어는,<code>acceptSecContext</code> 또는 <code>initSecContext</code> 에 대해서 적절한 토큰을 입력으로서 건네줍니다. <p>

문맥이 완전하게 확립하기 전에서도,<A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A>  메소드를 호출해,<A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>wrap</CODE></A>  및 <A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>getMIC</CODE></A>  에 의한 메세지마다의 조작에 문맥을 사용할 수 있을지 어떨지를 확인할 수 있습니다. 이 방법을 사용하면, 완전하게 확립되기 전의 문맥에 대해서 메세지마다의 조작을 사용할 수 있습니다. <p>

문맥의 확립이 완료한 뒤, 즉 <code>isProtReady</code> 메소드로부터 <code>true</code> 가 반환된 뒤에는, 확립된 문맥의 실제의 특성이나 서비스를 확인하기 위해서 쿼리루틴을 호출할 수 있습니다. 또,<A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>wrap</CODE></A>  및 <A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>getMIC</CODE></A>  의 메세지마다의 메소드를 사용해, 어플리케이션이 제공하는 데이터에 대해서 암호화 조작을 실시할 수도 있습니다. <p>

문맥이 불필요하게 되면(자),<A HREF="../../../org/ietf/jgss/GSSContext.html#dispose()"><CODE>dispose</CODE></A>  를 호출해, 그 문맥이 사용하고 있는 시스템 자원을 모두 해제할 필요가 있습니다. <p>

시큐리티 문맥은 일반적으로, 처리하는 토큰에 관한 순서부와 리플레이 검출 정보를 보관 유지하고 있습니다. 이 때문에, 토큰이 이 문맥에게 건네져 처리되는 순서가 중요하게 됩니다. 또, 이 인터페이스내의 메소드는 동기화 되지 않습니다. 복수의 thread간에 <code>GSSContext</code> 를 공유할 때는, 하등의 어플리케이션 레벨의 동기화를 실시할 필요가 있습니다. <p>

GSS-API 문맥을 사용할 때의 시큐리티 제한은, GSS-API 기구 프로바이더에 따라서 다릅니다. 이러한 제한에 대해서는, 각 기구 프로바이더의 문서를 참조해 주세요. 이러한 시큐리티 제한을 기구층에서 검사하는 경우는, 어플리케이션에 적절한 권한이 부여되고 있을 필요가 있습니다. <p>

다음에 나타내는 코드예는, 기동측 피어의 <code>GSSContext</code> 인터페이스의 사용법을 나타내고 있습니다. <code>GSSContext</code> 객체에 대해서, 객체의 인스턴스화, 지정하는 플래그의 설정, 문맥의 확립, 실제의 문맥 플래그의 조회, 어플리케이션 데이터에 대한 메세지마다의 조작, 문맥의 최종 검출등을 실시하고 있습니다. <p>

 <pre>
    // Create a context using default credentials- 
    // and the implementation specific default mechanism
    GSSManager manager ...
    GSSName targetName ...
    GSSContext context = manager.createContext(targetName, null, null,
                                           GSSContext.INDEFINITE_LIFETIME);
 
    // set desired context options prior to context establishment
    context.requestConf(true);
    context.requestMutualAuth(true);
    context.requestReplayDet(true);
    context.requestSequenceDet(true);
    
    // establish a context between peers

    byte []inToken = new byte[0];

    // Loop while there still is a token to be processed

    while (! context.isEstablished()) {

        byte[] outToken- 
            = context.initSecContext(inToken, 0, inToken.length);
        
        // send the output token if generated
        if (outToken ! = null)
            sendToken(outToken);
  
        if (! context.isEstablished()) {
            inToken = readToken();
    }
    
     // display context information
     System.out.println("Remaining lifetime in seconds = " 
                                          + context.getLifetime());
     System.out.println("Context mechanism = " + context.getMech());
     System.out.println("Initiator = " + context.getSrcName());
     System.out.println("Acceptor = " + context.getTargName());
  
     if (context.getConfState())
             System.out.println("Confidentiality (i.e., privacy) is available");
  
     if (context.getIntegState())
             System.out.println("Integrity is available");
  
     // perform wrap on an application supplied message, appMsg,
     // using QOP = 0, and requesting privacy service
     byte [] appMsg ...
  
     MessageProp mProp = new MessageProp(0, true);
  
     byte []tok = context.wrap(appMsg, 0, appMsg.length, mProp);
  
     sendToken(tok);
  
     // release the local-end of the context
     context.dispose();

 </pre>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#DEFAULT_LIFETIME">DEFAULT_LIFETIME</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥의 디폴트의 수명을 나타내는 수명 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#INDEFINITE_LIFETIME">INDEFINITE_LIFETIME</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥의 수명이 무기한인 것을 나타내는 수명 정수입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#acceptSecContext(byte[], int, int)">acceptSecContext</A> </B>(byte[]&nbsp;inToken,
                 int&nbsp;offset,
                 int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;피어로부터 토큰이 착신했을 때에, 문맥의 받아 들이는 쪽에 의해 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#acceptSecContext(java.io.InputStream, java.io.OutputStream)">acceptSecContext</A> </B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
                 <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥의 받아 들이는 쪽에 의해 불려 가는 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#dispose()">dispose</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥 객체에 포함되고 있는 시스템 자원과 암호화 정보를 모두 해제해, 그 문맥을 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#export()">export</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 문맥을 export 해, 다른 프로세스를 임포트 할 수 있도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getAnonymityState()">getAnonymityState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥의 기동측이 문맥의 받아 들이는 쪽에 익명으로서 인증되고 있는지 어떤지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getConfState()">getConfState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 문맥으로 데이터의 기밀성을 이용할 수 있을지 어떨지를 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getCredDelegState()">getCredDelegState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 문맥으로 자격의 위양이 유효하게 되어 있는지 어떤지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/ietf/jgss/GSSCredential.html" title="org.ietf.jgss 내의 인터페이스">GSSCredential</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getDelegCred()">getDelegCred</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥의 기동측으로부터 문맥의 받아 들이는 쪽에 위양 된 자격을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()">getIntegState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 문맥으로 데이터의 무결성을 이용할 수 있을지 어떨지를 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getLifetime()">getLifetime</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 문맥의 나머지의 수명을 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/ietf/jgss/Oid.html" title="org.ietf.jgss 내의 클래스">Oid</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getMech()">getMech</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 문맥에 사용되고 있는 기구를 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(byte[], int, int, org.ietf.jgss.MessageProp)">getMIC</A> </B>(byte[]&nbsp;inMsg,
       int&nbsp;offset,
       int&nbsp;len,
       <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 메세지의 암호화 MIC (메세지 무결성 코드)를 포함한 토큰을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)">getMIC</A> </B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
       <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream,
       <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림을 사용해, 지정된 메세지의 암호화 MIC 를 포함한 토큰을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getMutualAuthState()">getMutualAuthState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 문맥으로 상호 인증이 유효하게 되어 있는지 어떤지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getReplayDetState()">getReplayDetState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 문맥의 메세지마다의 시큐리티 서비스로 리플레이 검출이 유효하게 되어 있는지 어떤지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getSequenceDetState()">getSequenceDetState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 문맥의 메세지마다의 시큐리티 서비스로 sequence check가 유효하게 되어 있는지 어떤지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/ietf/jgss/GSSName.html" title="org.ietf.jgss 내의 인터페이스">GSSName</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getSrcName()">getSrcName</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥의 기동측의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/ietf/jgss/GSSName.html" title="org.ietf.jgss 내의 인터페이스">GSSName</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getTargName()">getTargName</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥의 받아 들이는 쪽의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getWrapSizeLimit(int, boolean, int)">getWrapSizeLimit</A> </B>(int&nbsp;qop,
                 boolean&nbsp;confReq,
                 int&nbsp;maxTokenSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>wrap</code> 에 건네줄 수가 있는 메세지 사이즈의 제한을 결정할 때 사용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#initSecContext(byte[], int, int)">initSecContext</A> </B>(byte[]&nbsp;inputBuf,
               int&nbsp;offset,
               int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥의 기동 측에야는 불려 가는 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#initSecContext(java.io.InputStream, java.io.OutputStream)">initSecContext</A> </B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
               <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥의 기동 측에야는 불려 가는 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()">isEstablished</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥을 확립하기 전에, 문맥 상태를 확인할 경우에 사용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#isInitiator()">isInitiator</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 피어가 문맥의 기동측일지 어떨지를 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()">isProtReady</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 문맥으로 메세지마다의 조작을 곧바로 개시할 수 있을지 어떨지를 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#isTransferable()">isTransferable</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../org/ietf/jgss/GSSContext.html#export()"><CODE>export</CODE></A>  메소드를 사용해, 이 문맥을 다른 프로세스에 전송 할 수 있을지 어떨지를 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestAnonymity(boolean)">requestAnonymity</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기동측의 자격을 받아 들이는 쪽에 공개하지 않게 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestConf(boolean)">requestConf</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>wrap</code> 메소드로 데이터의 기밀성을 유효하게 하도록(듯이) 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestCredDeleg(boolean)">requestCredDeleg</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥의 확립 시에 기동측의 자격을 받아 들이는 쪽에 위양 하도록(듯이) 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestInteg(boolean)">requestInteg</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>wrap</code> 메소드와 <code>getMIC</code> 메소드로 데이터의 무결성을 유효하게 하도록(듯이) 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestLifetime(int)">requestLifetime</A> </B>(int&nbsp;lifetime)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥의 수명을 초단위로 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestMutualAuth(boolean)">requestMutualAuth</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥이 확립해 있을 때, 상호 인증을 하도록(듯이) 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestReplayDet(boolean)">requestReplayDet</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥이 확립한 후에, 메세지마다의 시큐리티 서비스의 리플레이 검출이 유효하게 되도록(듯이) 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestSequenceDet(boolean)">requestSequenceDet</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥이 확립한 후에, 메세지마다의 시큐리티 서비스의 sequence check가 유효하게 되도록(듯이) 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#setChannelBinding(org.ietf.jgss.ChannelBinding)">setChannelBinding</A> </B>(<A HREF="../../../org/ietf/jgss/ChannelBinding.html" title="org.ietf.jgss 안의 클래스">ChannelBinding</A> &nbsp;cb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥이 확립해 있을 때 채널 바인딩이 사용되도록(듯이) 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#unwrap(byte[], int, int, org.ietf.jgss.MessageProp)">unwrap</A> </B>(byte[]&nbsp;inBuf,
       int&nbsp;offset,
       int&nbsp;len,
       <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;문맥의 상대측의 피어로 <code>wrap</code> 메소드에 의해 생성된 토큰을 처리하기 위해서 사용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#unwrap(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)">unwrap</A> </B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
       <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream,
       <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림을 사용해, 문맥의 상대측의 피어로 <code>wrap</code> 메소드에 의해 생성된 토큰을 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#verifyMIC(byte[], int, int, byte[], int, int, org.ietf.jgss.MessageProp)">verifyMIC</A> </B>(byte[]&nbsp;inToken,
          int&nbsp;tokOffset,
          int&nbsp;tokLen,
          byte[]&nbsp;inMsg,
          int&nbsp;msgOffset,
          int&nbsp;msgLen,
          <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;토큰 파라미터에 포함되는 암호화 MIC 를, 지정된 메세지에 대해서 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#verifyMIC(java.io.InputStream, java.io.InputStream, org.ietf.jgss.MessageProp)">verifyMIC</A> </B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;tokStream,
          <A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;msgStream,
          <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림을 사용해, 토큰 파라미터에 포함되는 지정된 메세지의 암호화 MIC 를 검증합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(byte[], int, int, org.ietf.jgss.MessageProp)">wrap</A> </B>(byte[]&nbsp;inBuf,
     int&nbsp;offset,
     int&nbsp;len,
     <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;확립된 시큐리티 문맥에 대해서 메세지마다의 시큐리티 서비스를 적용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)">wrap</A> </B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
     <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream,
     <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림을 사용해, 확립된 시큐리티 문맥에 메세지마다의 시큐리티 서비스를 적용합니다. </TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DEFAULT_LIFETIME"><!-- --></A> <H3>
DEFAULT_LIFETIME</H3>
<PRE>
static final int <B>DEFAULT_LIFETIME</B></PRE>
<DL>
<DD>문맥의 디폴트의 수명을 나타내는 수명 정수입니다. 이 값은 0 으로 설정됩니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#org.ietf.jgss.GSSContext.DEFAULT_LIFETIME">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="INDEFINITE_LIFETIME"><!-- --></A> <H3>
INDEFINITE_LIFETIME</H3>
<PRE>
static final int <B>INDEFINITE_LIFETIME</B></PRE>
<DL>
<DD>문맥의 수명이 무기한인 것을 나타내는 수명 정수입니다. 이 값은, Java 의 최대 정수치 <A HREF="../../../java/lang/Integer.html#MAX_VALUE"><CODE>Integer.MAX_VALUE</CODE></A>  로 설정할 필요가 있습니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#org.ietf.jgss.GSSContext.INDEFINITE_LIFETIME">정수 필드치</A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="initSecContext(byte[], int, int)"><!-- --></A> <H3>
initSecContext</H3>
<PRE>
byte[] <B>initSecContext</B>(byte[]&nbsp;inputBuf,
                      int&nbsp;offset,
                      int&nbsp;len)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥의 기동 측에야는 불려 가는 메소드입니다.  문맥의 작성 처리를 개시해, 피어의 <code>acceptSecContext</code> 메소드에 의해 생성된 토큰을 처리합니다. 이 메소드로부터 반환되는 출력 토큰은, 피어의 <code>acceptSecContext</code> 메소드로 처리받기 위해서(때문에) 어플리케이션으로부터 피어에 송신할 필요가 있습니다. 문맥의 이 편에 문맥의 확립 처리가 완료했는지 어떠했는지는,<A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  를 호출해 확인할 수 있습니다. <code>isEstablished</code> 로부터 반환값 <code>false</code> 가 돌려주어졌을 경우는,<code>initSecContext</code> 에 한층 더 토큰을 제공할 필요가 있는 것을 나타내 있습니다. 문맥의 확립이 완료하면(자), 이용 가능한 문맥 옵션을 get 메소드를 사용해 조회할 수 있습니다. <p>

<code>initSecContext</code> 메소드로부터 피어의 토큰이 돌려주어져<code>isEstablished</code> 로부터도 <code>true</code> 가 반환되는 일이 있습니다. 이 경우, 토큰은 피어에 송신할 필요가 있습니다만, 문맥의 상대측은 그 시점에서 완전하게 확립되어 있습니다. <p>

일부의 기구 프로바이더에서는, 시큐리티 문맥을 기동하는 액세스권이 호출해 측에 부여되고 있을 필요가 있습니다. 액세스권의 확인에 실패했을 경우, 이 메소드로부터 <A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스"><CODE>SecurityException</CODE></A>  가 throw 됩니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inputBuf</CODE> - 피어에 의해 생성된 토큰 최초의 호출에서는,
 피어로부터 토큰을 수신하지 않기 때문에, 이 파라미터는 무시되는<DD><CODE>offset</CODE> - inputBuf 내의 오프셋(offset). 이 정도치로부터 토큰이 개시하는<DD><CODE>len</CODE> - 토큰의 길이
<DT><B>반환값:</B><DD>피어에 송신되는 토큰을 포함한다 
 byte[]
<code>null</code> 의 경우는, 토큰이 생성되지 않는 것을 나타낸다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#NO_CRED"><CODE>GSSException.NO_CRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CREDENTIALS_EXPIRED"><CODE>GSSException.CREDENTIALS_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_BINDINGS"><CODE>GSSException.BAD_BINDINGS</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#OLD_TOKEN"><CODE>GSSException.OLD_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#DUPLICATE_TOKEN"><CODE>GSSException.DUPLICATE_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_NAMETYPE"><CODE>GSSException.BAD_NAMETYPE</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MECH"><CODE>GSSException.BAD_MECH</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="initSecContext(java.io.InputStream, java.io.OutputStream)"><!-- --></A> <H3>
initSecContext</H3>
<PRE>
int <B>initSecContext</B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
                   <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream)
                   throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥의 기동 측에야는 불려 가는 메소드입니다.  문맥의 작성 처리를 개시해, 피어의 <code>acceptSecContext</code> 메소드에 의해 생성된 토큰을 스트림을 사용해 처리합니다. 이 메소드로부터 <code>OutpuStream</code> 에 써내진 출력 토큰은, 피어의 <code>acceptSecContext</code> 호출로 처리받기 위해서(때문에) 어플리케이션으로부터 피어에 송신할 필요가 있습니다. 일반적으로은, 이 처리를 확실히 실시하기 위해서(때문에),<code>OutputStream</code> 에 대해서 <A HREF="../../../java/io/OutputStream.html#flush()"><CODE>flush</CODE></A>  메소드를 호출해 2 개의 피어간의 접속을 캡슐화합니다. 토큰이 OutputStream 에 써내졌는지 어떠했는지는, 이 메소드의 반환값으로부터 판단할 수 있습니다. 반환값 <code>0</code> 은, 토큰이 써내지지 않았던 것을 나타냅니다. 문맥의 이 편에 문맥의 확립 처리가 완료했는지 어떠했는지는,<A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  를 호출해 확인할 수 있습니다. <code>isEstablished</code> 로부터 반환값 <code>false</code> 가 돌려주어졌을 경우는,<code>initSecContext</code> 에 한층 더 토큰을 제공할 필요가 있는 것을 나타내 있습니다. 문맥의 확립이 완료하면(자), 이용 가능한 문맥 옵션을 get 메소드를 사용해 조회할 수 있습니다. <p>

<code>initSecContext</code> 메소드로부터 피어의 토큰이 돌려주어져<code>isEstablished</code> 로부터도 <code>true</code> 가 반환되는 일이 있습니다. 이 경우, 토큰은 피어에 송신할 필요가 있습니다만, 문맥의 상대측은 그 시점에서 완전하게 확립되어 있습니다. <p>

GSS-API 의 인증 토큰에는, 개시 토큰과 종료 토큰이 정의되고 있습니다. 이 메소드가 불려 갈 때마다, 이러한 토큰이 1 개씩 읽힙니다.  토큰의 일부가 읽히지 않았던 경우, 그 스트림은 블록 됩니다. 다른 모든 점에서는, 이 메소드는 byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#initSecContext(byte[], int, int)"><CODE>initSecContext</CODE></A>  와 등가입니다. <p>

일부의 기구 프로바이더에서는, 시큐리티 문맥을 기동하는 액세스권이 호출해 측에 부여되고 있을 필요가 있습니다. 액세스권의 확인에 실패했을 경우, 이 메소드로부터 <A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스"><CODE>SecurityException</CODE></A>  가 throw 됩니다. <p>

다음의 코드예는, 이 메소드의 사용 방법을 나타내고 있습니다. <p>
 <pre>
     InputStream is ...
     OutputStream os ...
     GSSContext context ...

     // Loop while there is still a token to be processed

     while (! context.isEstablished()) {

         context.initSecContext(is, os);

         // send output token if generated
         os.flush();
     }
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inStream</CODE> - 피어에 의해 생성된 토큰을 포함한다 
 InputStream. 최초의 호출에서는, 피어로부터 토큰을 수신하지 않기 때문에,
 이 파라미터는 무시되는지, 또는 그 시점의 피어로부터 수신하는<DD><CODE>outStream</CODE> - 출력 토큰이 써내진다 
 OutputStream. 문맥 확립의 최종 단계에서는,
 써내지는 바이트가 없는 것도 있다
<DT><B>반환값:</B><DD>피어에 송신하는 토큰의 일부로서
 OutputStream 에 써내지는 바이트수. 값 0 은,
 토큰을 송신할 필요가 없는 것을 나타낸다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#NO_CRED"><CODE>GSSException.NO_CRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CREDENTIALS_EXPIRED"><CODE>GSSException.CREDENTIALS_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_BINDINGS"><CODE>GSSException.BAD_BINDINGS</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#OLD_TOKEN"><CODE>GSSException.OLD_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#DUPLICATE_TOKEN"><CODE>GSSException.DUPLICATE_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_NAMETYPE"><CODE>GSSException.BAD_NAMETYPE</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MECH"><CODE>GSSException.BAD_MECH</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="acceptSecContext(byte[], int, int)"><!-- --></A> <H3>
acceptSecContext</H3>
<PRE>
byte[] <B>acceptSecContext</B>(byte[]&nbsp;inToken,
                        int&nbsp;offset,
                        int&nbsp;len)
                        throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>피어로부터 토큰이 착신했을 때에, 문맥의 받아 들이는 쪽에 의해 불려 갑니다. 어플리케이션은, 이 메소드로부터 반환된 출력 토큰을 처리하기 위해서, 피어의 <code>initSecContext</code> 메소드에 송신할 필요가 있습니다. <p>

어플리케이션은,<A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  를 호출하는 것으로, 이 피어로 문맥의 확립 처리가 완료했는지의 여부를 확인할 수 있습니다. <code>isEstablished</code> 로부터 반환값 <code>false</code> 가 돌려주어졌을 경우는, 이 메소드에 한층 더 토큰을 제공할 필요가 있는 것을 나타내고 있습니다. 문맥의 확립이 완료하면(자), 이용 가능한 문맥 옵션을 get 메소드를 사용해 조회할 수 있습니다. <p>

<code>acceptSecContext</code> 메소드로부터 피어의 토큰이 돌려주어져<code>isEstablished</code> 로부터도 <code>true</code> 가 반환되는 일이 있습니다. 이 경우, 토큰은 피어에 송신할 필요가 있습니다만, 문맥의 상대측은 그 시점에서 완전하게 확립되어 있습니다. <p>

일부의 기구 프로바이더에서는, 시큐리티 문맥을 받아들이는 액세스권이 호출해 측에 부여되고 있을 필요가 있습니다. 액세스권의 확인에 실패했을 경우, 이 메소드로부터 <A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스"><CODE>SecurityException</CODE></A>  가 throw 됩니다. <p>

다음의 코드예는, 이 메소드의 사용 방법을 나타내고 있습니다. <p>
 <pre>
     byte[] inToken;
     byte[] outToken;
     GSSContext context ...

     // Loop while there is still a token to be processed

     while (! context.isEstablished()) {
         inToken = readToken();
         outToken = context.acceptSecContext(inToken, 0,
                                             inToken.length);
         // send output token if generated
         if (outToken ! = null)
             sendToken(outToken);
     }
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inToken</CODE> - 피어에 의해 생성된 토큰<DD><CODE>offset</CODE> - inMsg 내의 오프셋(offset). 이 정도치로부터 토큰이 개시하는<DD><CODE>len</CODE> - 토큰의 길이
<DT><B>반환값:</B><DD>피어에 송신되는 토큰을 포함한다 
 byte[]
<code>null</code> 의 경우는, 토큰이 생성되지 않는 것을 나타낸다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#NO_CRED"><CODE>GSSException.NO_CRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CREDENTIALS_EXPIRED"><CODE>GSSException.CREDENTIALS_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_BINDINGS"><CODE>GSSException.BAD_BINDINGS</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#OLD_TOKEN"><CODE>GSSException.OLD_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#DUPLICATE_TOKEN"><CODE>GSSException.DUPLICATE_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MECH"><CODE>GSSException.BAD_MECH</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="acceptSecContext(java.io.InputStream, java.io.OutputStream)"><!-- --></A> <H3>
acceptSecContext</H3>
<PRE>
void <B>acceptSecContext</B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
                      <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥의 받아 들이는 쪽에 의해 불려 가는 메소드입니다. 스트림을 사용해 피어로부터 수신한 토큰을 처리합니다.  이 메소드로부터 <code>OutpuStream</code> 에 써내진 출력 토큰은, 피어의 <code>initSecContext</code> 메소드로 처리받기 위해서(때문에) 어플리케이션으로부터 피어에 송신할 필요가 있습니다. 일반적으로은, 이 처리를 확실히 실시하기 위해서(때문에),<code>OutputStream</code> 에 대해서 <A HREF="../../../java/io/OutputStream.html#flush()"><CODE>flush</CODE></A>  메소드를 호출해 2 개의 피어간의 접속을 캡슐화합니다. 문맥의 이 편에 문맥의 확립 처리가 완료했는지 어떠했는지는,<A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  를 호출해 확인할 수 있습니다. <code>isEstablished</code> 로부터 반환값 <code>false</code> 가 돌려주어졌을 경우는,<code>acceptSecContext</code> 에 한층 더 토큰을 제공할 필요가 있는 것을 나타내고 있습니다. 문맥의 확립이 완료하면(자), 이용 가능한 문맥 옵션을 get 메소드를 사용해 조회할 수 있습니다. <p>

<code>acceptSecContext</code> 메소드로부터 피어의 토큰이 돌려주어져<code>isEstablished</code> 로부터도 <code>true</code> 가 반환되는 일이 있습니다. 이 경우, 토큰은 피어에 송신할 필요가 있습니다만, 문맥의 상대측은 그 시점에서 완전하게 확립되어 있습니다. <p>

GSS-API 의 인증 토큰에는, 개시 토큰과 종료 토큰이 정의되고 있습니다. 이 메소드가 불려 갈 때마다, 이러한 토큰이 1 개씩 읽힙니다.  토큰의 일부가 읽히지 않았던 경우, 그 스트림은 블록 됩니다. 다른 모든 점에서는, 이 메소드는 byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#acceptSecContext(byte[], int, int)"><CODE>acceptSecContext</CODE></A>  와 등가입니다. <p>

일부의 기구 프로바이더에서는, 시큐리티 문맥을 받아들이는 액세스권이 호출해 측에 부여되고 있을 필요가 있습니다. 액세스권의 확인에 실패했을 경우, 이 메소드로부터 <A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스"><CODE>SecurityException</CODE></A>  가 throw 됩니다. <p>

다음의 코드예는, 이 메소드의 사용 방법을 나타내고 있습니다. <p>
 <pre>
     InputStream is ...
     OutputStream os ...
     GSSContext context ...

     // Loop while there is still a token to be processed

     while (! context.isEstablished()) {

         context.acceptSecContext(is, os);

         // send output token if generated
         os.flush();
     }
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inStream</CODE> - 피어에 의해 생성된 토큰을 포함한다 
 InputStream. <DD><CODE>outStream</CODE> - 출력 토큰이 써내진다 
 OutputStream. 문맥 확립의 최종 단계에서는,
 써내지는 바이트가 없는 것도 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#NO_CRED"><CODE>GSSException.NO_CRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CREDENTIALS_EXPIRED"><CODE>GSSException.CREDENTIALS_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_BINDINGS"><CODE>GSSException.BAD_BINDINGS</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#OLD_TOKEN"><CODE>GSSException.OLD_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#DUPLICATE_TOKEN"><CODE>GSSException.DUPLICATE_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MECH"><CODE>GSSException.BAD_MECH</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isEstablished()"><!-- --></A> <H3>
isEstablished</H3>
<PRE>
boolean <B>isEstablished</B>()</PRE>
<DL>
<DD>문맥을 확립하기 전에, 문맥 상태를 확인할 경우에 사용합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 문맥이 호출해 옆에서 완전하게 확립되어
 피어로부터 토큰을 수신할 필요가 없는 경우는,<code>true</code>. </DL>
</DD>
</DL>
<HR>

<A NAME="dispose()"><!-- --></A> <H3>
dispose</H3>
<PRE>
void <B>dispose</B>()
             throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥 객체에 포함되고 있는 시스템 자원과 암호화 정보를 모두 해제해, 그 문맥을 무효로 합니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getWrapSizeLimit(int, boolean, int)"><!-- --></A> <H3>
getWrapSizeLimit</H3>
<PRE>
int <B>getWrapSizeLimit</B>(int&nbsp;qop,
                     boolean&nbsp;confReq,
                     int&nbsp;maxTokenSize)
                     throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD><code>wrap</code> 에 건네줄 수가 있는 메세지 사이즈의 제한을 결정할 때 사용합니다. 이 메소드는, 최대 메세지 사이즈를 돌려줍니다. <code> confReq</code> 및 <code>qop</code> 파라미터가 같은 <code>wrap</code> 메소드에 이 사이즈의 메세지를 건네주면(자),<code>maxTokenSize</code> 바이트 이하의 출력 토큰이 생성됩니다. <p>

어플리케이션으로 이 메소드를 사용하는 경우는, 최대 메세지 사이즈를 사용하는 프로토콜을 개입시켜 통신하는 것을 전제로 하고 있습니다. 이 메소드를 사용하면, 메세지를 단편화하고 나서 보호를 적용할 수 있습니다. <p>

GSS-API 구현에서는,<code>getWrapSizeLimit</code> 를 호출했을 때에, QOP 치가 유효한가 어떤가를 검출하도록(듯이) 추천 하고 있습니다.  다만, 필수가 아닙니다. 이 루틴에서는, 최대 메세지 사이즈만이 보증되어 메세지 보호로 지정한 QOP 치를 이용할 수 있을지 어떨지에 대해서는 보증되지 않습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>qop</CODE> - 랩에 요구하는 보호 레벨<DD><CODE>confReq</CODE> - 랩에 프라이버시를 요구하는 경우는,
 <code>true</code>. 요구하지 않는 경우는,<code>false</code><DD><CODE>maxTokenSize</CODE> - 랩에 의해 생성되는 토큰의 최대 사이즈 
 (목표)
<DT><B>반환값:</B><DD>지정된 출력 토큰 사이즈에 대한, 입력 토큰의
 최대 사이즈
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="wrap(byte[], int, int, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
wrap</H3>
<PRE>
byte[] <B>wrap</B>(byte[]&nbsp;inBuf,
            int&nbsp;offset,
            int&nbsp;len,
            <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
            throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>확립된 시큐리티 문맥에 대해서 메세지마다의 시큐리티 서비스를 적용합니다. 이 메소드는, 어플리케이션이 제공하는 데이터와 그에 대한 암호화 MIC 를 포함한 토큰을 돌려줍니다. 이 데이터는, 기밀성 (프라이버시)이 요구되었을 경우에 암호화됩니다. <p>

MessageProp 객체는, 어플리케이션에 의해 인스턴스화 됩니다.  이 객체를 사용해, 암호화 알고리즘을 선택하기 위한 QOP 치나, 임의 지정으로 메세지를 암호화하기 위한 프라이버시 서비스를 지정합니다. 이 호출에 사용되는 부하의 기구에서는, 이 프라이버시 서비스를 제공할 수 없는 경우가 있습니다. 그 경우는, 부하의 기구가 제공하는 실제의 프라이버시 서비스가, 이 MessageProp 객체로 설정됩니다.  호출측은, 복귀하자 마자 프라이버시 서비스를 조회할 필요가 있습니다. 부하의 기구가 요구된 QOP 를 제공할 수 없는 경우는, BAD_QOP 코드가 설정된 GSSException 가 throw 됩니다. <p>

어플리케이션 레벨의 프로토콜에는, 랩에 의해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 (위해)때문에, 구현에서는 길이 0 의 메세지의 랩을 지원할 필요가 있습니다. <p>

어플리케이션은, 이 토큰을 피어에 송신합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inBuf</CODE> - 보호되는 어플리케이션 데이터<DD><CODE>offset</CODE> - inBuf 내의 오프셋(offset). 이 정도치로부터 데이터가 개시하는<DD><CODE>len</CODE> - 데이터의 길이<DD><CODE>msgProp</CODE> - MessageProp 의 인스턴스. 필요한 QOP 
 (와)과 프라이버시 상태를 설정하기 위해서 어플리케이션이 사용한다. 디폴트의
 QOP 를 요구하는 경우는, 지정하는 QOP 로서 0 을 설정한다. 이 메소드로부터 복귀하면(자),
 이 객체에는 부하의 기구에 의해 메세지에 적용되었다
 실제의 프라이버시 상태가 포함된다
<DT><B>반환값:</B><DD>피어에 송신되는 토큰을 포함한 byte[]
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="wrap(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
wrap</H3>
<PRE>
void <B>wrap</B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
          <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream,
          <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
          throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>스트림을 사용해, 확립된 시큐리티 문맥에 메세지마다의 시큐리티 서비스를 적용합니다. 이 메소드는, 어플리케이션이 제공하는 데이터와 그에 대한 암호화 MIC 를 포함한 토큰을 돌려줍니다. 이 데이터는, 기밀성 (프라이버시)이 요구되었을 경우에 암호화됩니다. 이 메소드는, byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>wrap</CODE></A>  메소드와 등가입니다. <p>

어플리케이션은, 이 토큰을 피어에 송신합니다. 일반적으로은, 이 처리를 확실히 실시하기 위해서(때문에),<code>OutputStream</code> 에 대해서 <A HREF="../../../java/io/OutputStream.html#flush()"><CODE>flush</CODE></A>  메소드를 호출해 2 개의 피어간의 접속을 캡슐화합니다. <p>

MessageProp 객체는, 어플리케이션에 의해 인스턴스화 됩니다.  이 객체를 사용해, 암호화 알고리즘을 선택하기 위한 QOP 치나, 임의 지정으로 메세지를 암호화하기 위한 프라이버시 서비스를 지정합니다. 이 호출에 사용되는 부하의 기구에서는, 이 프라이버시 서비스를 제공할 수 없는 경우가 있습니다. 그 경우는, 부하의 기구가 제공하는 실제의 프라이버시 서비스가, 이 MessageProp 객체로 설정됩니다.  호출측은, 복귀하자 마자 프라이버시 서비스를 조회할 필요가 있습니다. 부하의 기구가 요구된 QOP 를 제공할 수 없는 경우는, BAD_QOP 코드가 설정된 GSSException 가 throw 됩니다. <p>

어플리케이션 레벨의 프로토콜에는, 랩에 의해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 (위해)때문에, 구현에서는 길이 0 의 메세지의 랩을 지원할 필요가 있습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inStream</CODE> - 보호되는 어플리케이션 데이터를 포함한다 
 InputStream. InStream 내에서 이용할 수 있는 데이터가
 모두 사용되는<DD><CODE>outStream</CODE> - 보호된 메세지를 써낸다 
 OutputStream<DD><CODE>msgProp</CODE> - MessageProp 의 인스턴스.  필요한 QOP 
 (와)과 프라이버시 상태를 설정하기 위해서 어플리케이션이 사용한다. 디폴트의
 QOP 를 요구하는 경우는, 지정하는 QOP 로서 0 을 설정한다. 이 메소드로부터 복귀하면(자),
 이 객체에는 부하의 기구에 의해 메세지에 적용되었다
 실제의 프라이버시 상태가 포함된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(byte[], int, int, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
unwrap</H3>
<PRE>
byte[] <B>unwrap</B>(byte[]&nbsp;inBuf,
              int&nbsp;offset,
              int&nbsp;len,
              <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
              throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥의 상대측의 피어로 <code>wrap</code> 메소드에 의해 생성된 토큰을 처리하기 위해서 사용합니다. 이 메소드는, 피어 어플리케이션으로부터 그 랩 호출에게 건네진 메세지를 돌려주어, 동시에 그 메세지에 파묻힌 MIC 를 검사합니다. <p>

MessageProp 객체는, 어플리케이션에 의해 인스턴스화 됩니다. 이 객체는, QOP, 메세지에 기밀성이 적용되고 있는지 어떤지, 및 메세지 상태에 관한 그 외의 추가 정보를 호출해 측에 돌려주기 위해서(때문에), 부하의 기구에 의해 사용됩니다. <p>

어플리케이션 레벨의 프로토콜에는, 랩에 의해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 (위해)때문에, 구현에서는 길이 0 의 메세지의 랩 및 랩 해제를 지원할 필요가 있습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inBuf</CODE> - 피어로부터 수신한 랩 토큰을 포함한 byte 
 배열<DD><CODE>offset</CODE> - 토큰이 개시하는 오프셋(offset)<DD><CODE>len</CODE> - 토큰의 길이<DD><CODE>msgProp</CODE> - 이 메소드로부터 복귀하면(자), 이 객체에는, 적용되었다 
 QOP, 메세지의 프라이버시 상태, 및 토큰의 추가 정보 
 (중복 하고 있는, 낡은, 순서가 올바르지 않은, 갭의 후에 착신했는지 어떠했는지) 
 하지만 포함된다
<DT><B>반환값:</B><DD>입력 토큰으로부터 랩 해제된 메세지를 포함한다 
 byte[]
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
unwrap</H3>
<PRE>
void <B>unwrap</B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
            <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream,
            <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
            throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>스트림을 사용해, 문맥의 상대측의 피어로 <code>wrap</code> 메소드에 의해 생성된 토큰을 처리합니다. 이 메소드는, 피어 어플리케이션으로부터 그 랩 호출에게 건네진 메세지를 돌려주어, 동시에 그 메세지에 파묻힌 MIC 를 검사합니다. <p>
 
MessageProp 객체는, 어플리케이션에 의해 인스턴스화 됩니다. 이 객체는, QOP, 메세지에 기밀성이 적용되고 있는지 어떤지, 및 메세지 상태에 관한 그 외의 추가 정보를 호출해 측에 돌려주기 위해서(때문에), 부하의 기구에 의해 사용됩니다. <p>

어플리케이션 레벨의 프로토콜에는, 랩에 의해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 (위해)때문에, 구현에서는 길이 0 의 메세지의 랩 및 랩 해제를 지원할 필요가 있습니다. <p>

이 메소드가 읽어내는 입력 토큰의 형식은, 사용하는 부하의 기구의 스펙에 정의되고 있습니다. 이 메소드가 불려 갈 때마다, 이러한 토큰이 1 개씩 읽힙니다. 이 기구의 토큰에 개시 토큰과 종료 토큰이 정의되고 있는 경우, 일부의 토큰이 읽히지 않았을 때는,<code>InputStream</code> 는 블록 됩니다. 개시 토큰과 종료 토큰이 정의되어 있지 않은 경우는, 사용할 수 있는 모든 바이트가 그 토큰의 일부라고 보여집니다. <p>

입력 스트림의 블록이 발생하는 일이 있는 점을 제외하면, 이 메소드는 byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#unwrap(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>unwrap</CODE></A>  메소드와 등가입니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inStream</CODE> - 피어에 의해 생성된 랩 토큰을 포함한다 
 InputStream. <DD><CODE>outStream</CODE> - 어플리케이션 메세지를 써낸다 
 OutputStream<DD><CODE>msgProp</CODE> - 이 메소드로부터 복귀하면(자), 이 객체에는, 적용되었다 
 QOP, 메세지의 프라이버시 상태, 및 토큰의 추가 정보 
 (중복 하고 있는, 낡은, 순서가 올바르지 않은, 갭의 후에 착신했는지 어떠했는지) 
 하지만 포함된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMIC(byte[], int, int, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
getMIC</H3>
<PRE>
byte[] <B>getMIC</B>(byte[]&nbsp;inMsg,
              int&nbsp;offset,
              int&nbsp;len,
              <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
              throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>지정된 메세지의 암호화 MIC (메세지 무결성 코드)를 포함한 토큰을 돌려줍니다. 이 토큰은, 피어 어플리케이션에 전송 됩니다. 랩을 사용했을 경우는, 사용자 메세지를 캡슐화한 토큰이 돌려주어집니다만, 이 메소드에서는, 메세지의 MIC 만을 포함한 출력 토큰이 돌려주어집니다. <p> 

프라이버시는, 랩을 호출했을 때에만 적용됩니다. <p>

어플리케이션 레벨의 프로토콜에는, getMIC 에 의해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 (위해)때문에, 구현에서는 길이 0 의 메세지로부터 파생한 MIC 를 지원할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inMsg</CODE> - MIC 의 생성의 대상이 되는 메세지<DD><CODE>offset</CODE> - inMsg 내의 오프셋(offset). 이 정도치로부터 메세지가 개시하는<DD><CODE>len</CODE> - 메세지의 길이<DD><CODE>msgProp</CODE> - <code>MessageProp</code> 의 인스턴스.
 목표 QOP 를 설정하기 위해서 어플리케이션이 사용한다. 디폴트의 QOP 를 요구하는 경우는,
 <code>msgProp</code> 의 목표 QOP를 <code>0</code> 에
 설정하는지,<code>msgProp</code> 에 <code>null</code> 
 (을)를 건네준다
<DT><B>반환값:</B><DD>피어에 송신되는 토큰을 포함한 byte[]
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMIC(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
getMIC</H3>
<PRE>
void <B>getMIC</B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
            <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream,
            <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
            throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>스트림을 사용해, 지정된 메세지의 암호화 MIC 를 포함한 토큰을 돌려줍니다.  이 토큰은, 피어 어플리케이션에 전송 됩니다. 랩을 사용했을 경우는 사용자 메세지를 캡슐화한 토큰이 돌려주어집니다만, 이 메소드에서는 메세지의 MIC 만을 포함한 출력 토큰이 돌려주어집니다. 이 메소드는, byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>getMIC</CODE></A>  메소드와 등가입니다.

프라이버시는, 랩을 호출했을 때에만 적용됩니다. <p>

어플리케이션 레벨의 프로토콜에는, getMIC 에 의해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 (위해)때문에, 구현에서는 길이 0 의 메세지로부터 파생한 MIC 를 지원할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inStream</CODE> - MIC 의 생성의 대상이 되는 메세지를 포함한다 
 InputStream. InStream 내에서 이용할 수 있는 데이터가
 모두 사용되는<DD><CODE>outStream</CODE> - 출력 토큰을 써내는 OutputStream<DD><CODE>msgProp</CODE> - <code>MessageProp</code> 의 인스턴스.
 목표 QOP 를 설정하기 위해서 어플리케이션이 사용한다. 디폴트의 QOP 를 요구하는 경우는,
 <code>msgProp</code> 의 목표 QOP를 <code>0</code> 에
 설정하는지,<code>msgProp</code> 에 <code>null</code> 
 (을)를 건네준다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="verifyMIC(byte[], int, int, byte[], int, int, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
verifyMIC</H3>
<PRE>
void <B>verifyMIC</B>(byte[]&nbsp;inToken,
               int&nbsp;tokOffset,
               int&nbsp;tokLen,
               byte[]&nbsp;inMsg,
               int&nbsp;msgOffset,
               int&nbsp;msgLen,
               <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
               throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>토큰 파라미터에 포함되는 암호화 MIC 를, 지정된 메세지에 대해서 검사합니다. <p>

MessageProp 객체는, 어플리케이션에 의해 인스턴스화 됩니다. 이 객체는, 메세지에 적용된 보호의 강함을 나타내는 QOP, 및 메세지 상태에 관한 그 외의 추가 정보를 호출해 측에 돌려주기 위해서(때문에), 부하의 기구에 의해 사용됩니다. <p>

어플리케이션 레벨의 프로토콜에는, getMIC 에 의해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 (위해)때문에, 구현에서는 길이 0 의 메세지에 대한 MIC 를 계산 및 검사할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inToken</CODE> - 피어의 getMIC 메소드에 의해 생성된 토큰<DD><CODE>tokOffset</CODE> - inMsg 내의 오프셋(offset). 이 정도치로부터 토큰이
 개시하는<DD><CODE>tokLen</CODE> - 토큰의 길이<DD><CODE>inMsg</CODE> - 암호화 MIC 의 검사의 대상이 되는 어플리케이션
 메세지<DD><CODE>msgOffset</CODE> - inMsg 내의 오프셋(offset). 이 정도치로부터 메세지가 개시하는<DD><CODE>msgLen</CODE> - 메세지의 길이<DD><CODE>msgProp</CODE> - 이 메소드로부터 복귀하면(자), 이 객체에는, 적용되었다 
 QOP, 및 토큰의 추가 정보 (중복 하고 있는, 낡은,
 순서가 올바르지 않은, 갭의 후에 착신했는지 어떠했는지)가 포함된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="verifyMIC(java.io.InputStream, java.io.InputStream, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
verifyMIC</H3>
<PRE>
void <B>verifyMIC</B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;tokStream,
               <A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;msgStream,
               <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
               throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>스트림을 사용해, 토큰 파라미터에 포함되는 지정된 메세지의 암호화 MIC 를 검증합니다. 이 메소드는 byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#verifyMIC(byte[], int, int, byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>verifyMIC</CODE></A>  메소드와 등가입니다.

MessageProp 객체는, 어플리케이션에 의해 인스턴스화 됩니다. 이 객체는, 메세지에 적용된 보호의 강함을 나타내는 QOP, 및 메세지 상태에 관한 그 외의 추가 정보를 호출해 측에 돌려주기 위해서(때문에), 부하의 기구에 의해 사용됩니다. <p>

어플리케이션 레벨의 프로토콜에는, getMIC 에 의해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 (위해)때문에, 구현에서는 길이 0 의 메세지에 대한 MIC 를 계산 및 검사할 필요가 있습니다. <p>

이 메소드가 읽어내는 입력 토큰의 형식은, 사용하는 부하의 기구의 스펙에 정의되고 있습니다. 이 메소드가 불려 갈 때마다, 이러한 토큰이 1 개씩 읽힙니다. 이 기구의 토큰에 개시 토큰과 종료 토큰이 정의되고 있는 경우, 일부의 토큰이 읽히지 않았을 때는,<code>InputStream</code> 는 블록 됩니다. 개시 토큰과 종료 토큰이 정의되어 있지 않은 경우는, 사용할 수 있는 모든 바이트가 그 토큰의 일부라고 보여집니다. <p>

입력 스트림의 블록이 발생하는 일이 있는 점을 제외하면, 이 메소드는 byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#verifyMIC(byte[], int, int, byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>verifyMIC</CODE></A>  메소드와 등가입니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tokStream</CODE> - 피어의 getMIC 메소드에 의해 생성된 토큰을 포함한다 
 InputStream<DD><CODE>msgStream</CODE> - 암호화 MIC 의 검사의 대상이 되는 어플리케이션
 메세지를 포함한 InputStream. msgStream 내에서
 이용할 수 있는 데이터가 모두 사용되는<DD><CODE>msgProp</CODE> - 이 메소드로부터 복귀하면(자), 이 객체에는, 적용되었다 
 QOP, 및 토큰의 추가 정보 (중복 하고 있는, 낡은,
 순서가 올바르지 않은, 갭의 후에 착신했는지 어떠했는지)가 포함된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="export()"><!-- --></A> <H3>
export</H3>
<PRE>
byte[] <B>export</B>()
              throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>이 문맥을 export 해, 다른 프로세스를 임포트 할 수 있도록(듯이) 합니다. 이 메소드를 사용하면, 복수의 프로세스간에 문맥을 공유할 수 있습니다. 이 루틴은 일반적으로, 문맥의 받아 들이는 쪽으로 사용됩니다.  단일 프로세스가 착신 접속 요구를 수신해, 그러한 요구에 대한 시큐리티 문맥을 받아들입니다.  다음에, 확립된 문맥을 다른 몇개의 프로세스에 건네주어, 메세지를 교환합니다. <p>

이 메소드는, 시큐리티 문맥을 종료해, 프로세스간 토큰을 작성합니다.  이 프로세스간토큰을 다른 프로세스의 <A HREF="../../../org/ietf/jgss/GSSManager.html#createContext(byte[])"><CODE>GSSManager.createContext</CODE></A>  에 건네주면(자), 그 프로세스로 그 문맥이 재차 기동됩니다. 특정의 문맥의 인스턴스는, 1 번에 1 개 밖에 기동할 수 없습니다.  이 때문에, export 한 시큐리티 문맥을 문맥의 export측에서 액세스 하려고 하면(자), 실패합니다. <p>

이 구현에서는, 프로세스간 토큰을 임포트 하는 프로세스가, 로컬 시큐리티 정책 또는 구현의 설정에 의해 제한되는 일이 있습니다. 예를 들어, 같은 어카운트로 동작하는 프로세스간에만 문맥이 건네받거나 같은 프로세스 그룹의 프로세스간에만 건네받거나 합니다. <p>

프로세스간 토큰에는, 기밀 정보 (암호화열쇠등)가 포함되어 있는 일이 있습니다. 이러한 기밀 정보는, 가능한 한 프로세스간 토큰에 포함하지 않게 하는지, 토큰을 암호화하고 나서 어플리케이션에 돌려주세요.  다만, 표준적인 GSS-API 의 구현에서는, 이러한 대응을 적용할 수 없는 것이 있습니다. 이 때문에, 어플리케이션으로 프로세스간 토큰을 사용하는 경우는, 시큐리티에 충분히 배려해, 신뢰할 수 있는 프로세스에 전송 해 주세요.  <p>

시큐리티 문맥의 프로세스간 전송을 구현이 지원하는 것은 필수가 아닙니다. <A HREF="../../../org/ietf/jgss/GSSContext.html#isTransferable()"><CODE>isTransferable</CODE></A>  메소드를 호출하면, 문맥 객체를 전송 할 수 있을지 어떨지를 확인할 수 있습니다. <p>

export 할 수 없는 문맥에 대해서 이 메소드를 호출하면(자), 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#UNAVAILABLE"><CODE>GSSException.UNAVAILABLE</CODE></A>  를 포함한 예외가 throw 됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>export 된 문맥을 포함한 byte[]
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#UNAVAILABLE"><CODE>GSSException.UNAVAILABLE</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#NO_CONTEXT"><CODE>GSSException.NO_CONTEXT</CODE></A> ,
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> <DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSManager.html#createContext(byte[])"><CODE>GSSManager.createContext(byte[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestMutualAuth(boolean)"><!-- --></A> <H3>
requestMutualAuth</H3>
<PRE>
void <B>requestMutualAuth</B>(boolean&nbsp;state)
                       throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥이 확립해 있을 때, 상호 인증을 하도록(듯이) 요구합니다. 이 요구는, 문맥의 기동 측에서의 보고 실시할 수가 있어<code>initSecContext</code> 를 최초로 호출하기 전에 실시할 필요가 있습니다. <p>

인증 기구에 따라서는 상호 인증이 지원되어 있지 않은 것이 있습니다.  또, 어플리케이션은 상호 인증을 필요로 하지 않아도, 인증 기구가 상호 인증을 필요로 하고 있는 경우도 있습니다.  그 때문에, 이 요구를 받아들일 수 있었는지의 여부를 확인하기 위해(때문에), 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getMutualAuthState()"><CODE>getMutualAuthState</CODE></A>  메소드를 사용할 필요가 있습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 상호 인증을 사용할까
 제발을 나타내는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> <DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getMutualAuthState()"><CODE>getMutualAuthState()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestReplayDet(boolean)"><!-- --></A> <H3>
requestReplayDet</H3>
<PRE>
void <B>requestReplayDet</B>(boolean&nbsp;state)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥이 확립한 후에, 메세지마다의 시큐리티 서비스의 리플레이 검출이 유효하게 되도록(듯이) 요구합니다. 이 요구는, 문맥의 기동 측에서의 보고 실시할 수가 있어<code>initSecContext</code> 를 최초로 호출하기 전에 실시할 필요가 있습니다. 문맥이 확립해 있는 동안은, 리플레이 검출은 옵션은 아니고, 부하의 기구의 기능이 됩니다. <p>

인증 기구에 따라서는 리플레이 검출이 지원되어 있지 않은 것이 있습니다.  또, 어플리케이션은 리플레이 검출을 필요로 하지 않아도, 인증 기구가 리플레이 검출을 필요로 하고 있는 경우도 있습니다.  그 때문에, 이 요구를 받아들일 수 있었는지의 여부를 확인하기 위해(때문에), 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getReplayDetState()"><CODE>getReplayDetState</CODE></A>  메소드를 사용할 필요가 있습니다. 리플레이 검출이 유효하게 되어 있는 경우,<A HREF="../../../org/ietf/jgss/MessageProp.html#isDuplicateToken()"><CODE>MessageProp.isDuplicateToken</CODE></A>  메소드와 <A HREF="../../../org/ietf/jgss/MessageProp.html#isOldToken()"><CODE>MessageProp.isOldToken</CODE></A>  메소드는,<code>unwrap</code> 메소드 또는 <code>verifyMIC</code> 메소드에게 건네지는 <code>MessageProp</code> 객체에 대해서 유효한 결과를 돌려줍니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 확립한 문맥에 대해서 리플레이 검출을
 유효하게 할지 어떨지를 나타내는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> <DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getReplayDetState()"><CODE>getReplayDetState()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestSequenceDet(boolean)"><!-- --></A> <H3>
requestSequenceDet</H3>
<PRE>
void <B>requestSequenceDet</B>(boolean&nbsp;state)
                        throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥이 확립한 후에, 메세지마다의 시큐리티 서비스의 sequence check가 유효하게 되도록(듯이) 요구합니다. 이 요구는, 문맥의 기동 측에서의 보고 실시할 수가 있어<code>initSecContext</code> 를 최초로 호출하기 전에 실시할 필요가 있습니다. 문맥이 확립해 있는 동안은, sequence check는 옵션은 아니고, 부하의 기구의 기능이 됩니다.  인증 기구에 따라서는 sequence check가 지원되어 있지 않은 것이 있습니다. <p>

또, 어플리케이션은 sequence check를 필요로 하지 않아도, 인증 기구가 sequence check를 필요로 하고 있는 경우도 있습니다.  그 때문에, 이 요구를 받아들일 수 있었는지의 여부를 확인하기 위해(때문에), 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getSequenceDetState()"><CODE>getSequenceDetState</CODE></A>  메소드를 사용할 필요가 있습니다. sequence check가 유효하게 되어 있는 경우,<A HREF="../../../org/ietf/jgss/MessageProp.html#isDuplicateToken()"><CODE>MessageProp.isDuplicateToken</CODE></A> ,<A HREF="../../../org/ietf/jgss/MessageProp.html#isOldToken()"><CODE>MessageProp.isOldToken</CODE></A> ,<A HREF="../../../org/ietf/jgss/MessageProp.html#isUnseqToken()"><CODE>MessageProp.isUnseqToken</CODE></A> ,<A HREF="../../../org/ietf/jgss/MessageProp.html#isGapToken()"><CODE>MessageProp.isGapToken</CODE></A>  의 각 메소드는,<code>unwrap</code> 메소드 또는 <code>verifyMIC</code> 메소드에게 건네지는 <code>MessageProp</code> 객체에 대해서 유효한 결과를 돌려줍니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 확립된 문맥에 대해서 sequence check를
 유효하게 할지 어떨지를 나타내는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> <DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getSequenceDetState()"><CODE>getSequenceDetState()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestCredDeleg(boolean)"><!-- --></A> <H3>
requestCredDeleg</H3>
<PRE>
void <B>requestCredDeleg</B>(boolean&nbsp;state)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥의 확립 시에 기동측의 자격을 받아 들이는 쪽에 위양 하도록(듯이) 요구합니다. 이 요구는, 문맥의 기동 측에서의 보고 실시할 수가 있어<code>initSecContext</code> 를 최초로 호출하기 전에 실시할 필요가 있습니다.

인증 기구에 따라서는, 자격의 위양이 지원되어 있지 않은 것이 있습니다. 그 때문에, 위양을 필요로 하는 어플리케이션은, 요구를 받아들일 수 있었는지의 여부를 확인하기 위해서 <A HREF="../../../org/ietf/jgss/GSSContext.html#getCredDelegState()"><CODE>getCredDelegState</CODE></A>  메소드를 사용할 필요가 있습니다. 위양을 사용해서는 안 되면 어플리케이션으로부터 나타났을 경우, 기구는 그 요구를 받아 위양은 행해지지 않습니다. 이것은 일반 규칙에 대한 예외로, 어느 서비스가 요구되지 않아도 기구가 그 서비스를 유효하게 하는 일이 있다고 하는 것입니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 자격을 위양 할지 어떨지를 나타낸다 
 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> <DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getCredDelegState()"><CODE>getCredDelegState()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestAnonymity(boolean)"><!-- --></A> <H3>
requestAnonymity</H3>
<PRE>
void <B>requestAnonymity</B>(boolean&nbsp;state)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>기동측의 자격을 받아 들이는 쪽에 공개하지 않게 요구합니다. 이 요구는, 문맥의 기동 측에서의 보고 실시할 수가 있어<code>initSecContext</code> 를 최초로 호출하기 전에 실시할 필요가 있습니다.

인증 기구에 따라서는, 기동측의 익명이 지원되어 있지 않은 것이 있습니다. 그 때문에, 요구를 받아들일 수 있었는지의 여부를 확인하기 위해(때문에), 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getAnonymityState()"><CODE>getAnonymityState</CODE></A>  메소드를 사용할 필요가 있습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 기동측이 받아 들이는 쪽에 익명 주체로서
 인증될지 어떨지를 나타내는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> <DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getAnonymityState()"><CODE>getAnonymityState()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestConf(boolean)"><!-- --></A> <H3>
requestConf</H3>
<PRE>
void <B>requestConf</B>(boolean&nbsp;state)
                 throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD><code>wrap</code> 메소드로 데이터의 기밀성을 유효하게 하도록(듯이) 요구합니다. 이 요구는, 문맥의 기동 측에서의 보고 실시할 수가 있어<code>initSecContext</code> 를 최초로 호출하기 전에 실시할 필요가 있습니다.

인증 기구에 따라서는, 기밀성을 지원하고 있지 않는 것이나, 어플리케이션으로부터 요구되지 않는 경우에서도 기밀성을 유효하게 하는 것이 있습니다. 요구를 받아들일 수 있었는지의 여부를 확인하려면 , 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getConfState()"><CODE>getConfState</CODE></A>  메소드를 사용합니다. 기밀성이 유효되고 있는 경우에 한정해,<code>wrap</code> 메소드에게 건네진 <A HREF="../../../org/ietf/jgss/MessageProp.html#MessageProp(int, boolean)"><CODE>MessageProp</CODE></A>  객체에 포함되는 프라이버시 요구를 인증 기구가 받아들입니다. <p>

기밀성을 유효하게 하면(자), 무결성도 자동적으로 유효하게 됩니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 기밀성을 유효하게 할지 어떨지를
 가리키는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> <DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getConfState()"><CODE>getConfState()</CODE></A> , 
<A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()"><CODE>getIntegState()</CODE></A> , 
<A HREF="../../../org/ietf/jgss/GSSContext.html#requestInteg(boolean)"><CODE>requestInteg(boolean)</CODE></A> , 
<A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스"><CODE>MessageProp</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestInteg(boolean)"><!-- --></A> <H3>
requestInteg</H3>
<PRE>
void <B>requestInteg</B>(boolean&nbsp;state)
                  throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD><code>wrap</code> 메소드와 <code>getMIC</code> 메소드로 데이터의 무결성을 유효하게 하도록(듯이) 요구합니다. 이 요구는, 문맥의 기동 측에서의 보고 실시할 수가 있어<code>initSecContext</code> 를 최초로 호출하기 전에 실시할 필요가 있습니다.

인증 기구에 따라서는 무결성이 지원되어 있지 않은 것이 있습니다.  또, 어플리케이션이 무결성을 요구하지 않아도, 인증 기구가 무결성을 유효하게 하는 경우도 있습니다. 이 요구를 받아들일 수 있었는지의 여부를 확인하려면 , 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()"><CODE>getIntegState</CODE></A>  메소드를 사용합니다. <p>

무결성을 무효로 하면(자), 기밀성도 자동적으로 무효가 됩니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 무결성을 유효하게 할지 어떨지를
 가리키는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> <DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()"><CODE>getIntegState()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestLifetime(int)"><!-- --></A> <H3>
requestLifetime</H3>
<PRE>
void <B>requestLifetime</B>(int&nbsp;lifetime)
                     throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥의 수명을 초단위로 요구합니다. 이 메소드의 호출은, 문맥의 기동측으로부터,<code>initSecContext</code> 를 최초로 호출하기 전에 실시할 필요가 있습니다. <p>

문맥의 실제의 수명은 부하의 기구의 기능에 따라서 다르기 (위해)때문에, 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getLifetime()"><CODE>getLifetime</CODE></A>  메소드를 호출해 확인할 필요가 있습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>lifetime</CODE> - 문맥으로 지정하는 수명 (초단위). 무기한의
 수명을 요구하는 경우는 <code>INDEFINITE_LIFETIME</code> 를 사용해,
 디폴트의 수명을 요구하는 경우는 <code>DEFAULT_LIFETIME</code> 를 사용한다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> <DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getLifetime()"><CODE>getLifetime()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setChannelBinding(org.ietf.jgss.ChannelBinding)"><!-- --></A> <H3>
setChannelBinding</H3>
<PRE>
void <B>setChannelBinding</B>(<A HREF="../../../org/ietf/jgss/ChannelBinding.html" title="org.ietf.jgss 안의 클래스">ChannelBinding</A> &nbsp;cb)
                       throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥이 확립해 있을 때 채널 바인딩이 사용되도록(듯이) 설정합니다. 이 메소드는, 문맥의 기동측 및 받아 들이는 쪽으로부터 호출할 수가 있습니다.  다만, 문맥의 확립을 개시하기 전에 호출할 필요가 있습니다. 즉, 기동측에서 호출할 때는,<code>initSecContext</code> 를 최초로 호출하기 전에 실시할 필요가 있습니다.  받아 들이는 쪽으로부터 호출할 때는,<code>acceptSecContext</code> 를 최초로 호출하기 전에 실시할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cb</CODE> - 사용하는 채널 바인딩
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getCredDelegState()"><!-- --></A> <H3>
getCredDelegState</H3>
<PRE>
boolean <B>getCredDelegState</B>()</PRE>
<DL>
<DD>이 문맥으로 자격의 위양이 유효하게 되어 있는지 어떤지를 판정합니다. 이 메소드는, 문맥의 기동측 및 호출해 옆으로부터 호출할 수가 있습니다. 다만, 문맥의 확립이 완료하고 나서 호출해 주세요. 기동측이 자격의 위양을 무효로 하도록(듯이) 요구했을 경우,<A HREF="../../../org/ietf/jgss/GSSContext.html#requestCredDeleg(boolean)"><CODE>requestCredDeleg</CODE></A>  메소드는 그 요구를 받아들여 그 시점으로부터 기동 측에 대해 <code>false</code> 를 돌려줍니다.  <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>위양이 유효한 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestCredDeleg(boolean)"><CODE>requestCredDeleg(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMutualAuthState()"><!-- --></A> <H3>
getMutualAuthState</H3>
<PRE>
boolean <B>getMutualAuthState</B>()</PRE>
<DL>
<DD>이 문맥으로 상호 인증이 유효하게 되어 있는지 어떤지를 판정합니다. 이 메소드는, 문맥의 기동측 및 호출해 옆으로부터 호출할 수가 있습니다. 다만, 문맥의 확립이 완료하고 나서 호출해 주세요. 상호 인증을 요구한 기동측은, 문맥의 확립이 완료한 후에 이 메소드를 호출해, 요구를 받아들일 수 없었던 경우는 그 문맥을 파기할 수 있습니다. <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>상호 인증이 유효한 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestMutualAuth(boolean)"><CODE>requestMutualAuth(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getReplayDetState()"><!-- --></A> <H3>
getReplayDetState</H3>
<PRE>
boolean <B>getReplayDetState</B>()</PRE>
<DL>
<DD>이 문맥의 메세지마다의 시큐리티 서비스로 리플레이 검출이 유효하게 되어 있는지 어떤지를 판정합니다. 이 메소드는, 문맥의 기동측 및 호출해 옆으로부터 호출할 수가 있습니다. 다만, 문맥의 확립이 완료하고 나서 호출해 주세요. 리플레이 검출을 요구한 기동측은, 문맥의 확립이 완료한 후에 이 메소드를 호출해, 요구를 받아들일 수 없었던 경우는 그 문맥을 파기할 수 있습니다. <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>리플레이 검출이 유효한 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestReplayDet(boolean)"><CODE>requestReplayDet(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSequenceDetState()"><!-- --></A> <H3>
getSequenceDetState</H3>
<PRE>
boolean <B>getSequenceDetState</B>()</PRE>
<DL>
<DD>이 문맥의 메세지마다의 시큐리티 서비스로 sequence check가 유효하게 되어 있는지 어떤지를 판정합니다. 이 메소드는, 문맥의 기동측 및 호출해 옆으로부터 호출할 수가 있습니다. 다만, 문맥의 확립이 완료하고 나서 호출해 주세요. sequence check를 요구한 기동측은, 문맥의 확립이 완료한 후에 이 메소드를 호출해, 요구를 받아들일 수 없었던 경우는 그 문맥을 파기할 수 있습니다. <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>sequence check가 유효한 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestSequenceDet(boolean)"><CODE>requestSequenceDet(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAnonymityState()"><!-- --></A> <H3>
getAnonymityState</H3>
<PRE>
boolean <B>getAnonymityState</B>()</PRE>
<DL>
<DD>문맥의 기동측이 문맥의 받아 들이는 쪽에 익명으로서 인증되고 있는지 어떤지를 판정합니다. 이 메소드는, 문맥의 기동측 및 호출해 옆으로부터, 임의의 타이밍에 호출할 수가 있습니다. 기동측으로부터 이 메소드를 호출했을 경우는,<code>initSecContext</code> 에 의해 그 시점까지 생성된 문맥 확립 토큰의 어느 쪽인가에, 기동측의 ID 가 공개되고 있는지 어떤지가 검사됩니다. 익명으로서의 인증이 필요한 경우는,<code>initSecContext</code> 를 호출하고 나서 이 메소드를 호출해, 생성된 토큰을 피어에 송신하는지, 그 문맥을 중지할까를 결정할 필요가 있습니다. 받아 들이는 쪽으로부터 이 메소드를 호출했을 경우는,<code>acceptSecContext</code> 에 의해 그 시점까지 처리된 토큰의 어느 쪽인가에, 기동측의 ID 가 공개되고 있는지 어떤지가 검사됩니다. <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>문맥의 기동측이 익명으로서 인증되고 있는 경우는 true, 그렇지 않은 경우는 
 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestAnonymity(boolean)"><CODE>requestAnonymity(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isTransferable()"><!-- --></A> <H3>
isTransferable</H3>
<PRE>
boolean <B>isTransferable</B>()
                       throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD><A HREF="../../../org/ietf/jgss/GSSContext.html#export()"><CODE>export</CODE></A>  메소드를 사용해, 이 문맥을 다른 프로세스에 전송 할 수 있을지 어떨지를 검사합니다. 이 호출은, 완전하게 확립된 문맥으로만 유효합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 문맥을 export 할 수 있는 경우는 true, 그렇지 않은 경우는 false
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isProtReady()"><!-- --></A> <H3>
isProtReady</H3>
<PRE>
boolean <B>isProtReady</B>()</PRE>
<DL>
<DD>이 문맥으로 메세지마다의 조작을 곧바로 개시할 수 있을지 어떨지를 검사합니다. 일부의 기구에서는, 문맥이 완전하게 확립되기 전에, 메세지마다의 조작을 사용할 수 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 문맥 확립 단계에서 <code>wrap</code>,<code>unwrap</code>, 
 <code>getMIC</code>,<code>verifyMIC</code> 등의 메소드를
 사용할 수 있는 경우는 true, 그렇지 않은 경우는 
 false</DL>
</DD>
</DL>
<HR>

<A NAME="getConfState()"><!-- --></A> <H3>
getConfState</H3>
<PRE>
boolean <B>getConfState</B>()</PRE>
<DL>
<DD>이 문맥으로 데이터의 기밀성을 이용할 수 있을지 어떨지를 검사합니다. 이 메소드는, 문맥의 기동측과 받아 들이는 쪽의 어느 쪽으로부터에서도 호출할 수가 있습니다.  다만,<A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A>  또는 <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  로부터 <code>true</code> 가 반환된 후에 없으면 안됩니다. 이 메소드가 <code>true</code> 를 돌려주는 경우는,<A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()"><CODE>getIntegState</CODE></A>  도 <code>true</code> 를 돌려줍니다. <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>기밀성 서비스를 이용할 수 있는 경우는 true, 그렇지 않은 경우는 
 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestConf(boolean)"><CODE>requestConf(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getIntegState()"><!-- --></A> <H3>
getIntegState</H3>
<PRE>
boolean <B>getIntegState</B>()</PRE>
<DL>
<DD>이 문맥으로 데이터의 무결성을 이용할 수 있을지 어떨지를 검사합니다. 이 메소드는, 문맥의 기동측과 받아 들이는 쪽의 어느 쪽으로부터에서도 호출할 수가 있습니다.  다만,<A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A>  또는 <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  로부터 <code>true</code> 가 반환된 후에 없으면 안됩니다. <A HREF="../../../org/ietf/jgss/GSSContext.html#getConfState()"><CODE>getConfState</CODE></A>  가 <code>true</code> 를 돌려주는 경우는, 이 메소드도 <code>true</code> 를 돌려줍니다. <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>무결성 서비스를 이용할 수 있는 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestInteg(boolean)"><CODE>requestInteg(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getLifetime()"><!-- --></A> <H3>
getLifetime</H3>
<PRE>
int <B>getLifetime</B>()</PRE>
<DL>
<DD>이 문맥의 나머지의 수명을 검사합니다. 이 메소드는, 문맥의 기동측과 받아 들이는 쪽의 어느 쪽으로부터에서도 호출할 수가 있습니다.  다만, 올바른 결과를 얻기 위해서(때문에)는,<A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  로부터 true 가 반환된 후에 없으면 안됩니다. <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>나머지의 수명 (초단위)<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestLifetime(int)"><CODE>requestLifetime(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSrcName()"><!-- --></A> <H3>
getSrcName</H3>
<PRE>
<A HREF="../../../org/ietf/jgss/GSSName.html" title="org.ietf.jgss 안의 인터페이스">GSSName</A>  <B>getSrcName</B>()
                   throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥의 기동측의 이름을 돌려줍니다. 이 호출은,<A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A>  또는 <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  로부터 <code>true</code> 가 반환된 후에 마셔 유효합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>GSSName. 문맥의 기동측의 이름을 포함한다 
 MN
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> <DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSName.html" title="org.ietf.jgss 내의 인터페이스"><CODE>GSSName</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTargName()"><!-- --></A> <H3>
getTargName</H3>
<PRE>
<A HREF="../../../org/ietf/jgss/GSSName.html" title="org.ietf.jgss 안의 인터페이스">GSSName</A>  <B>getTargName</B>()
                    throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥의 받아 들이는 쪽의 이름을 돌려줍니다. 이 호출은,<A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A>  또는 <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  로부터 <code>true</code> 가 반환된 후에 마셔 유효합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>GSSName. 문맥의 받아 들이는 쪽의 이름을 포함한다 
 MN
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMech()"><!-- --></A> <H3>
getMech</H3>
<PRE>
<A HREF="../../../org/ietf/jgss/Oid.html" title="org.ietf.jgss 안의 클래스">Oid</A>  <B>getMech</B>()
            throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>이 문맥에 사용되고 있는 기구를 검사합니다. 이 메소드는, 문맥이 완전하게 확립되기 전에 호출할 수가 있습니다.  다만, GSS-API 기구의 협상이 완료한 후에 이 메소드를 호출하면(자), 반환되는 기구가 바뀌는 일이 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>사용되고 있는 기구의 OID
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDelegCred()"><!-- --></A> <H3>
getDelegCred</H3>
<PRE>
<A HREF="../../../org/ietf/jgss/GSSCredential.html" title="org.ietf.jgss 안의 인터페이스">GSSCredential</A>  <B>getDelegCred</B>()
                           throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>문맥의 기동측으로부터 문맥의 받아 들이는 쪽에 위양 된 자격을 가져옵니다. 이 메소드는, 문맥의 받아 들이는 쪽으로부터 마셔, 문맥이 완전하게 확립된 후에 호출할 필요가 있습니다. 위양 된 자격이 있을지 어떨지를 호출측에서 확인하려면 , 메소드 <A HREF="../../../org/ietf/jgss/GSSContext.html#getCredDelegState()"><CODE>getCredDelegState</CODE></A>  를 사용합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>기동측으로부터 위양 된 자격이 포함된다 
 GSSCredential. 위양 된 자격이 없는 경우는 
 <code>null</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isInitiator()"><!-- --></A> <H3>
isInitiator</H3>
<PRE>
boolean <B>isInitiator</B>()
                    throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>이 피어가 문맥의 기동측일지 어떨지를 검사합니다. 이 메소드는, 문맥의 기동측 및 받아 들이는 쪽으로부터 호출할 수가 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>문맥의 기동측인 경우는 true, 문맥의 받아 들이는 쪽인 경우는 
 false
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 다음의 메이저 에러 코드를
 포함한다.  
   <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GSSContext.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/ietf/jgss/ChannelBinding.html" title="org.ietf.jgss 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../org/ietf/jgss/GSSCredential.html" title="org.ietf.jgss 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/ietf/jgss/GSSContext.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="GSSContext.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
