<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:01:02 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
AbstractQueuedLongSynchronizer (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="AbstractQueuedLongSynchronizer (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractQueuedLongSynchronizer.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.html" title="java.util.concurrent.locks 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="AbstractQueuedLongSynchronizer.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent.locks</FONT>
<BR>
클래스 AbstractQueuedLongSynchronizer</H2>
<PRE>
<A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.html" title="java.util.concurrent.locks 내의 클래스">java.util.concurrent.locks.AbstractOwnableSynchronizer</A> 
      <IMG SRC="../../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.concurrent.locks.AbstractQueuedLongSynchronizer</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>AbstractQueuedLongSynchronizer</B><DT>extends <A HREF="../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.html" title="java.util.concurrent.locks 내의 클래스">AbstractOwnableSynchronizer</A> <DT>implements <A HREF="../../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
동기 상태가 <tt>long</tt> 로서 보관 유지되는 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html" title="java.util.concurrent.locks 동안의 클래스"><CODE>AbstractQueuedSynchronizer</CODE></A>  의 버젼입니다. 이 클래스에는 <tt>AbstractQueuedSynchronizer</tt> 와 완전히 같은 구조체, 프로퍼티, 및 메소드가 있습니다만, 상태 관련의 모든 파라미터와 결과는,<tt>int</tt> 는 아니고 <tt>long</tt> 로서 정의되고 있는 점이 다릅니다. 이 클래스는, 복수 레벨의 락이나 배리어라고 하는 16 비트 상태가 필요한 싱크로나이저의 작성시에 유용하다라고 하는 것이 있습니다.

 <p>사용상의 주의나 예에 대해서는,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html" title="java.util.concurrent.locks 안의 클래스"><CODE>AbstractQueuedSynchronizer</CODE></A>  를 참조해 주세요.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../../serialized-form.html#java.util.concurrent.locks.AbstractQueuedLongSynchronizer">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedLongSynchronizer.ConditionObject</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스"><CODE>Lock</CODE></A>  구현의 기반으로서 기능하는 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html" title="java.util.concurrent.locks 동안의 클래스"><CODE>AbstractQueuedLongSynchronizer</CODE></A>  의 Condition 구현입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#AbstractQueuedLongSynchronizer()">AbstractQueuedLongSynchronizer</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;제로의 초기 동기 상태를 사용해, 신규 <tt>AbstractQueuedLongSynchronizer</tt> 인스턴스를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#acquire(long)">acquire</A> </B>(long&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인터럽트를 무시해, 배타 모드로 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#acquireInterruptibly(long)">acquireInterruptibly</A> </B>(long&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드로 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#acquireShared(long)">acquireShared</A> </B>(long&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인터럽트를 무시해, 공유 모드로 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#acquireSharedInterruptibly(long)">acquireSharedInterruptibly</A> </B>(long&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드로 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#compareAndSetState(long, long)">compareAndSetState</A> </B>(long&nbsp;expect,
                   long&nbsp;update)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 상태치가 예상되는 값에 동일한 경우, 동기 상태가 지정된 갱신치에 원자적으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#getExclusiveQueuedThreads()">getExclusiveQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드로 취득하기 위해서 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#getFirstQueuedThread()">getFirstQueuedThread</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;큐내의 최초의 (대기 시간의 가장 길다) thread를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#getQueuedThreads()">getQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;취득을 대기하고 있는 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#getQueueLength()">getQueueLength</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;취득을 대기하고 있는 thread의 추정수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#getSharedQueuedThreads()">getSharedQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드로 취득하기 위해서 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#getState()">getState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;동기 상태의 현재가를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#getWaitingThreads(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject)">getWaitingThreads</A> </B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedLongSynchronizer.ConditionObject</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 싱크로나이저에 관련지을 수 있었던 지정 상태로 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject)">getWaitQueueLength</A> </B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedLongSynchronizer.ConditionObject</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 싱크로나이저에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread의 추정수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#hasContended()">hasContended</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 싱크로나이저의 취득으로 경합 하고 있는 thread가 존재할지 어떨지 (즉, acquire 메소드가 블록 되었는지 어떠했는지)를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#hasQueuedThreads()">hasQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;취득을 대기중의 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#hasWaiters(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject)">hasWaiters</A> </B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedLongSynchronizer.ConditionObject</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 싱크로나이저에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#isHeldExclusively()">isHeldExclusively</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 (호출측의) thread에 관해서, 동기가 배타적으로 행해지는 경우는 <code>true</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#isQueued(java.lang.Thread)">isQueued</A> </B>(<A HREF="../../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;thread)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 thread가, 현재 큐에 들어가 있는 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#owns(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject)">owns</A> </B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedLongSynchronizer.ConditionObject</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 ConditionObject 가 이 싱크로나이저를 락으로서 사용할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#release(long)">release</A> </B>(long&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드로 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#releaseShared(long)">releaseShared</A> </B>(long&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드로 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#setState(long)">setState</A> </B>(long&nbsp;newState)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;동기 상태의 값을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;싱크로나이저 및 그 상태를 식별하는 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquire(long)">tryAcquire</A> </B>(long&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드에서의 취득을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquireNanos(long, long)">tryAcquireNanos</A> </B>(long&nbsp;arg,
                long&nbsp;nanosTimeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드로 취득을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquireShared(long)">tryAcquireShared</A> </B>(long&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드에서의 취득을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquireSharedNanos(long, long)">tryAcquireSharedNanos</A> </B>(long&nbsp;arg,
                      long&nbsp;nanosTimeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드로 취득을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryRelease(long)">tryRelease</A> </B>(long&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드에서의 해제을 반영하도록(듯이), 상태의 설정을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryReleaseShared(long)">tryReleaseShared</A> </B>(long&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드에서의 해제을 반영하도록(듯이), 상태의 설정을 시도합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.concurrent.locks.AbstractOwnableSynchronizer"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.util.concurrent.locks. <A HREF="../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.html" title="java.util.concurrent.locks 안의 클래스">AbstractOwnableSynchronizer</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.html#getExclusiveOwnerThread()">getExclusiveOwnerThread</A> , <A HREF="../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.html#setExclusiveOwnerThread(java.lang.Thread)">setExclusiveOwnerThread</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AbstractQueuedLongSynchronizer()"><!-- --></A> <H3>
AbstractQueuedLongSynchronizer</H3>
<PRE>
protected <B>AbstractQueuedLongSynchronizer</B>()</PRE>
<DL>
<DD>제로의 초기 동기 상태를 사용해, 신규 <tt>AbstractQueuedLongSynchronizer</tt> 인스턴스를 작성합니다.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getState()"><!-- --></A> <H3>
getState</H3>
<PRE>
protected final long <B>getState</B>()</PRE>
<DL>
<DD>동기 상태의 현재가를 돌려줍니다. 이 조작은,<tt>volatile</tt> 읽을 메모리 시멘틱스를 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재 상태치</DL>
</DD>
</DL>
<HR>

<A NAME="setState(long)"><!-- --></A> <H3>
setState</H3>
<PRE>
protected final void <B>setState</B>(long&nbsp;newState)</PRE>
<DL>
<DD>동기 상태의 값을 설정합니다. 이 조작은,<tt>volatile</tt> 기입의 메모리 시멘틱스를 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newState</CODE> - 신규 상태치</DL>
</DD>
</DL>
<HR>

<A NAME="compareAndSetState(long, long)"><!-- --></A> <H3>
compareAndSetState</H3>
<PRE>
protected final boolean <B>compareAndSetState</B>(long&nbsp;expect,
                                           long&nbsp;update)</PRE>
<DL>
<DD>현재 상태치가 예상되는 값에 동일한 경우, 동기 상태가 지정된 갱신치에 원자적으로 설정합니다. 이 조작은,<tt>volatile</tt> read 및 기입의 메모리 시멘틱스를 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>expect</CODE> - 예상되는 값<DD><CODE>update</CODE> - 새로운 값
<DT><B>반환값:</B><DD>성공하는 경우는 true. false 는, 실제의 값이 예상되는 값과 등가가 아닌 것을 나타낸다</DL>
</DD>
</DL>
<HR>

<A NAME="tryAcquire(long)"><!-- --></A> <H3>
tryAcquire</H3>
<PRE>
protected boolean <B>tryAcquire</B>(long&nbsp;arg)</PRE>
<DL>
<DD>배타 모드에서의 취득을 시도합니다. 이 메소드는, 객체가 배타 모드에서의 취득을 허가하는 상태에 있을지 어떨지를 조회해, 허가하는 상태에 있으면 가져옵니다.

 <p>이 메소드는 항상 취득을 실행하는 thread에 의해 불려 갑니다. 이 메소드가 실패를 리포트해, 한편 thread가 큐에 넣어지지 않은 경우, 취득 메소드는, 다른 thread로부터의 해제에 의해 신호가 송신될 때까지 그 thread를 큐에 넣을 수가 있습니다. 이것은,<A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock()"><CODE>Lock.tryLock()</CODE></A>  메소드의 구현에 사용할 수 있습니다.

 <p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A>  를 throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은, 항상 acquire 메소드에게 건네지는 값, 또는 상태 대기에의 엔트리로 보존되는 값이 된다. 그 이외의 경우, 이 값은 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD>성공하는 경우는 <code>true</code>. 성공시에는, 이 객체는 취득이 끝난 상태이다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 취득에 의해, 이 싱크로나이저가 부정한 상태에 놓여지는 경우.
동기가 올바르게 기능하기 위해서는, 이 예외를 일관한 방식에서 throw 할 필요가 있다
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 배타 모드가 지원되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryRelease(long)"><!-- --></A> <H3>
tryRelease</H3>
<PRE>
protected boolean <B>tryRelease</B>(long&nbsp;arg)</PRE>
<DL>
<DD>배타 모드에서의 해제을 반영하도록(듯이), 상태의 설정을 시도합니다.

 <p>이 메소드는, 해제을 실행하는 thread에 의해 항상 불려 갑니다.

 <p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A>  를 throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - release 의 인수. 이 값은, 항상 release 메소드에게 건네지는 값, 또는 상태 대기에의 엔트리에서의 현재 상태치가 된다.
그 이외의 경우, 이 값은 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD>대기중의 임의의 thread가 취득을 시도할 수가 있도록(듯이), 이 객체가 완전하게 해제된 상태에 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 해제에 의해, 이 싱크로나이저가 부정한 상태에 놓여지는 경우.
동기가 올바르게 기능하기 위해서는, 이 예외를 일관한 방식에서 throw 할 필요가 있다
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 배타 모드가 지원되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryAcquireShared(long)"><!-- --></A> <H3>
tryAcquireShared</H3>
<PRE>
protected long <B>tryAcquireShared</B>(long&nbsp;arg)</PRE>
<DL>
<DD>공유 모드에서의 취득을 시도합니다. 이 메소드는, 객체가 공유 모드에서의 취득을 허가하는 상태에 있을지 어떨지를 조회해, 허가하는 상태에 있으면 가져옵니다.

 <p>이 메소드는 항상 취득을 실행하는 thread에 의해 불려 갑니다. 이 메소드가 실패를 리포트해, 한편 thread가 큐에 넣어지지 않은 경우, 취득 메소드는, 다른 thread로부터의 해제에 의해 신호가 송신될 때까지 그 thread를 큐에 넣을 수가 있습니다.

 <p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A>  를 throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은, 항상 acquire 메소드에게 건네지는 값, 또는 상태 대기에의 엔트리로 보존되는 값이 된다.
그 이외의 경우, 이 값은 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD>실패했을 경우는 0 보다 작은 값. 공유 모드에서의 취득에 성공했지만, 이후의 공유 모드에서의 취득에 성공하지 않는 경우는 제로. 공유 모드에서의 취득에 성공해, 이후의 공유 모드에서의 취득에도 성공할 가능성이 있는 경우는 정의 값. 정의 값의 경우, 후속의 대기 thread는 가용성을 체크할 필요가 있다 
(3 개(살)이 다른 반환값의 지원에 의해, 취득만이 때때로 배타적으로 동작하는 문맥내에서 이 메소드를 사용하는 것이 가능하게 된다).
성공시에는, 이 객체는 취득이 끝난 상태이다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 취득에 의해, 이 싱크로나이저가 부정한 상태에 놓여지는 경우.
동기가 올바르게 기능하기 위해서는, 이 예외를 일관한 방식에서 throw 할 필요가 있다
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 공유 모드가 지원되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryReleaseShared(long)"><!-- --></A> <H3>
tryReleaseShared</H3>
<PRE>
protected boolean <B>tryReleaseShared</B>(long&nbsp;arg)</PRE>
<DL>
<DD>공유 모드에서의 해제을 반영하도록(듯이), 상태의 설정을 시도합니다.

 <p>이 메소드는, 해제을 실행하는 thread에 의해 항상 불려 갑니다.

 <p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A>  를 throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - release 의 인수. 이 값은, 항상 release 메소드에게 건네지는 값, 또는 상태 대기에의 엔트리에서의 현재 상태치가 된다.
그 이외의 경우, 이 값은 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD>이 릴리스의 공유 모드로 대기중의 취득 (공유 또는 배타)을 허가할 수 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 해제에 의해, 이 싱크로나이저가 부정한 상태에 놓여지는 경우.
동기가 올바르게 기능하기 위해서는, 이 예외를 일관한 방식에서 throw 할 필요가 있다
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 공유 모드가 지원되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="isHeldExclusively()"><!-- --></A> <H3>
isHeldExclusively</H3>
<PRE>
protected boolean <B>isHeldExclusively</B>()</PRE>
<DL>
<DD>현재의 (호출측의) thread에 관해서, 동기가 배타적으로 행해지는 경우는 <code>true</code> 를 돌려줍니다. 비대기 상태 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 중의 클래스"><CODE>AbstractQueuedLongSynchronizer.ConditionObject</CODE></A>  메소드가 불려 갈 때 마다, 이 메소드가 불려 갑니다 (대기 상태의 메소드에서는 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#release(long)"><CODE>release(long)</CODE></A>  가 불려 간다).

 <p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A>  를 throw 합니다. 이 메소드는,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스"><CODE>AbstractQueuedLongSynchronizer.ConditionObject</CODE></A>  메소드로 내부적에게만 불려 가기 (위해)때문에, 상태가 사용되지 않는 경우는 정의할 필요가 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>동기가 배타적으로 행해지는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 상태가 지원되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="acquire(long)"><!-- --></A> <H3>
acquire</H3>
<PRE>
public final void <B>acquire</B>(long&nbsp;arg)</PRE>
<DL>
<DD>인터럽트를 무시해, 배타 모드로 가져옵니다. 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquire(long)"><CODE>tryAcquire(long)</CODE></A>  를 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 이외의 경우, thread는 큐에 넣어져 대부분의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquire(long)"><CODE>tryAcquire(long)</CODE></A>  를 호출합니다. 이 메소드는,<A HREF="../../../../java/util/concurrent/locks/Lock.html#lock()"><CODE>Lock.lock()</CODE></A>  메소드의 구현에 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquire(long)"><CODE>tryAcquire(long)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다</DL>
</DD>
</DL>
<HR>

<A NAME="acquireInterruptibly(long)"><!-- --></A> <H3>
acquireInterruptibly</H3>
<PRE>
public final void <B>acquireInterruptibly</B>(long&nbsp;arg)
                                throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>배타 모드로 가져옵니다. 인터럽트가 발생했을 경우는, 중지합니다. 최초로 끼어들어 상태를 체크하고 나서 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquire(long)"><CODE>tryAcquire(long)</CODE></A>  를 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 이외의 경우, thread는 큐에 넣어져 대부분의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할까 thread로 인터럽트가 발생할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquire(long)"><CODE>tryAcquire(long)</CODE></A>  를 호출합니다. 이 메소드는,<A HREF="../../../../java/util/concurrent/locks/Lock.html#lockInterruptibly()"><CODE>Lock.lockInterruptibly()</CODE></A>  메소드의 구현에 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquire(long)"><CODE>tryAcquire(long)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryAcquireNanos(long, long)"><!-- --></A> <H3>
tryAcquireNanos</H3>
<PRE>
public final boolean <B>tryAcquireNanos</B>(long&nbsp;arg,
                                     long&nbsp;nanosTimeout)
                              throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>배타 모드로 취득을 시도합니다. 인터럽트가 발생했을 경우는 중지해, 지정된 타임 아웃 시간이 경과했을 경우는 실패합니다. 최초로 끼어들어 상태를 체크하고 나서 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquire(long)"><CODE>tryAcquire(long)</CODE></A>  를 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 이외의 경우, thread는 큐에 넣어져 대부분의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할까 thread로 인터럽트가 발생하는지, 타임 아웃 시간이 경과할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquire(long)"><CODE>tryAcquire(long)</CODE></A>  를 호출합니다. 이 메소드는,<A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock(long, java.util.concurrent.TimeUnit)"><CODE>Lock.tryLock(long, TimeUnit)</CODE></A>  메소드의 구현에 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquire(long)"><CODE>tryAcquire(long)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있는<DD><CODE>nanosTimeout</CODE> - 대기하는 최대 나노초수
<DT><B>반환값:</B><DD>취득했을 경우는 <code>true</code>, 타임 아웃 했을 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="release(long)"><!-- --></A> <H3>
release</H3>
<PRE>
public final boolean <B>release</B>(long&nbsp;arg)</PRE>
<DL>
<DD>배타 모드로 해제합니다. <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryRelease(long)"><CODE>tryRelease(long)</CODE></A>  가 true 를 돌려주는 경우, 1 개(살) 이상의 thread를 블록 해제하는 것으로 구현됩니다. 이 메소드는,<A HREF="../../../../java/util/concurrent/locks/Lock.html#unlock()"><CODE>Lock.unlock()</CODE></A>  메소드의 구현으로 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - release 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryRelease(long)"><CODE>tryRelease(long)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryRelease(long)"><CODE>tryRelease(long)</CODE></A>  로부터 반환되는 값</DL>
</DD>
</DL>
<HR>

<A NAME="acquireShared(long)"><!-- --></A> <H3>
acquireShared</H3>
<PRE>
public final void <B>acquireShared</B>(long&nbsp;arg)</PRE>
<DL>
<DD>인터럽트를 무시해, 공유 모드로 가져옵니다. 최초로 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquireShared(long)"><CODE>tryAcquireShared(long)</CODE></A>  를 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 이외의 경우, thread는 큐에 넣어져 대부분의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquireShared(long)"><CODE>tryAcquireShared(long)</CODE></A>  를 호출합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquireShared(long)"><CODE>tryAcquireShared(long)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다</DL>
</DD>
</DL>
<HR>

<A NAME="acquireSharedInterruptibly(long)"><!-- --></A> <H3>
acquireSharedInterruptibly</H3>
<PRE>
public final void <B>acquireSharedInterruptibly</B>(long&nbsp;arg)
                                      throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>공유 모드로 가져옵니다. 최초로 끼어들어 상태를 체크하고 나서, 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquireShared(long)"><CODE>tryAcquireShared(long)</CODE></A>  를 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 이외의 경우, thread는 큐에 넣어져 대부분의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할까 thread로 인터럽트가 발생할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquireShared(long)"><CODE>tryAcquireShared(long)</CODE></A>  를 호출합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수.
이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquireShared(long)"><CODE>tryAcquireShared(long)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryAcquireSharedNanos(long, long)"><!-- --></A> <H3>
tryAcquireSharedNanos</H3>
<PRE>
public final boolean <B>tryAcquireSharedNanos</B>(long&nbsp;arg,
                                           long&nbsp;nanosTimeout)
                                    throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>공유 모드로 취득을 시도합니다. 인터럽트가 발생했을 경우는 중지해, 지정된 타임 아웃 시간이 경과했을 경우는 실패합니다. 최초로 끼어들어 상태를 체크하고 나서, 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquireShared(long)"><CODE>tryAcquireShared(long)</CODE></A>  를 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 이외의 경우, thread는 큐에 넣어져 대부분의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공하는지, thread로 인터럽트가 발생하는지, 타임 아웃 시간이 경과할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquireShared(long)"><CODE>tryAcquireShared(long)</CODE></A>  를 호출합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryAcquireShared(long)"><CODE>tryAcquireShared(long)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있는<DD><CODE>nanosTimeout</CODE> - 대기하는 최대 나노초수
<DT><B>반환값:</B><DD>취득했을 경우는 <code>true</code>, 타임 아웃 했을 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="releaseShared(long)"><!-- --></A> <H3>
releaseShared</H3>
<PRE>
public final boolean <B>releaseShared</B>(long&nbsp;arg)</PRE>
<DL>
<DD>공유 모드로 해제합니다. <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryReleaseShared(long)"><CODE>tryReleaseShared(long)</CODE></A>  가 true 를 돌려주는 경우, 1 개(살) 이상의 thread를 블록 해제하는 것으로 구현됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - release 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryReleaseShared(long)"><CODE>tryReleaseShared(long)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#tryReleaseShared(long)"><CODE>tryReleaseShared(long)</CODE></A>  로부터 반환되는 값</DL>
</DD>
</DL>
<HR>

<A NAME="hasQueuedThreads()"><!-- --></A> <H3>
hasQueuedThreads</H3>
<PRE>
public final boolean <B>hasQueuedThreads</B>()</PRE>
<DL>
<DD>취득을 대기중의 thread가 존재할지 어떨지를 조회합니다. 언젠가는 끼어들어 및 타임 아웃에 의한 취소가 발생했을 경우,<code>true</code> 가 돌려주어져도 다른 thread가 취득을 실행하는 것은 보증되지 않습니다.

 <p>이 구현에서는, 이 조작은 일정한 시간에 복귀합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>취득을 대기중외의 thread가 존재할 가능성이 있는 경우는 <code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="hasContended()"><!-- --></A> <H3>
hasContended</H3>
<PRE>
public final boolean <B>hasContended</B>()</PRE>
<DL>
<DD>이 싱크로나이저의 취득으로 경합 하고 있는 thread가 존재할지 어떨지 (즉, acquire 메소드가 블록 되었는지 어떠했는지)를 조회합니다.

 <p>이 구현에서는, 이 조작은 일정한 시간에 복귀합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>경합이 존재하는 경우는 <code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="getFirstQueuedThread()"><!-- --></A> <H3>
getFirstQueuedThread</H3>
<PRE>
public final <A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A>  <B>getFirstQueuedThread</B>()</PRE>
<DL>
<DD>큐내의 최초의 (대기 시간의 가장 길다) thread를 돌려줍니다. 현재 큐에 thread가 들어가 있지 않은 경우는 <code>null</code> 를 돌려줍니다.

 <p>일반적으로, 이 구현에서는, 이 조작은 일정시간으로 복귀합니다. 다만, 다른 thread가 큐의 변경을 병행해 실행하고 있는 경우는, 경합에 의해 처리를 반복하는 경우가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>큐내의 최초의 (대기 시간의 가장 길다) thread. 현재 큐에 thread가 들어가 있지 않은 경우는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="isQueued(java.lang.Thread)"><!-- --></A> <H3>
isQueued</H3>
<PRE>
public final boolean <B>isQueued</B>(<A HREF="../../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;thread)</PRE>
<DL>
<DD>지정된 thread가, 현재 큐에 들어가 있는 경우는 true 를 돌려줍니다.

 <p>이 구현은, 큐를 횡단(traverse) 해 지정된 thread의 존재를 판별합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>thread</CODE> - thread
<DT><B>반환값:</B><DD>지정된 thread가 큐에 들어가 있는 경우는 <code>true</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - thread가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getQueueLength()"><!-- --></A> <H3>
getQueueLength</H3>
<PRE>
public final int <B>getQueueLength</B>()</PRE>
<DL>
<DD>취득을 대기하고 있는 thread의 추정수를 돌려줍니다. 이 메소드가 내부의 데이터 구조를 횡단(traverse) 하고 있는 동안에도, thread수가 동적으로 변화하는 경우가 있기 (위해)때문에, 이 값은 추정에 지나지 않습니다. 이 메소드는, 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>취득을 대기하고 있는 thread의 추정수</DL>
</DD>
</DL>
<HR>

<A NAME="getQueuedThreads()"><!-- --></A> <H3>
getQueuedThreads</H3>
<PRE>
public final <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getQueuedThreads</B>()</PRE>
<DL>
<DD>취득을 대기하고 있는 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는, 결과의 구축중에도 동적으로 변화할 가능성이 있기 (위해)때문에, 반환되는 컬렉션은 최선이 노력한 다음의 추정에 지나지 않습니다. 반환되는 컬렉션의 요소에는, 특정의 순서는 존재하지 않습니다. 이 메소드는, 보다 포괄적인 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="getExclusiveQueuedThreads()"><!-- --></A> <H3>
getExclusiveQueuedThreads</H3>
<PRE>
public final <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getExclusiveQueuedThreads</B>()</PRE>
<DL>
<DD>배타 모드로 취득하기 위해서 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 이것은, 배타적 취득을 위해서(때문에) 대기중의 thread만을 돌려주는 것을 제외해서는,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#getQueuedThreads()"><CODE>getQueuedThreads()</CODE></A>  와 같은 프로퍼티을 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="getSharedQueuedThreads()"><!-- --></A> <H3>
getSharedQueuedThreads</H3>
<PRE>
public final <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getSharedQueuedThreads</B>()</PRE>
<DL>
<DD>공유 모드로 취득하기 위해서 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 이것은, 공유적 취득을 위해서(때문에) 대기중의 thread만을 돌려주는 것을 제외해,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#getQueuedThreads()"><CODE>getQueuedThreads()</CODE></A>  와 같은 프로퍼티을 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>싱크로나이저 및 그 상태를 식별하는 캐릭터 라인을 돌려줍니다. 상태는 괄호로 둘러싸여 캐릭터 라인 <code>"State ="</code> 에 이어 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html#getState()"><CODE>getState()</CODE></A>  의 현재가, 및 큐가 빈 상태(empty)인가 어떤가에 응해 <code>"nonempty"</code> 또는 <code>"empty"</code> 가 포함됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 싱크로나이저 및 그 상태를 식별하는 캐릭터 라인</DL>
</DD>
</DL>
<HR>

<A NAME="owns(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject)"><!-- --></A> <H3>
owns</H3>
<PRE>
public final boolean <B>owns</B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedLongSynchronizer.ConditionObject</A> &nbsp;condition)</PRE>
<DL>
<DD>지정된 ConditionObject 가 이 싱크로나이저를 락으로서 사용할지 어떨지를 조회합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>소유되는 경우는 <tt>true</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="hasWaiters(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject)"><!-- --></A> <H3>
hasWaiters</H3>
<PRE>
public final boolean <B>hasWaiters</B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedLongSynchronizer.ConditionObject</A> &nbsp;condition)</PRE>
<DL>
<DD>이 싱크로나이저에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread가 존재할지 어떨지를 조회합니다. 타임 아웃 및 인터럽트는 언제라도 발생할 가능성이 있기 (위해)때문에,<tt>true</tt> 가 돌려주어져도, 장래 <tt>signal</tt> 가 thread를 기동시키는 것은 보증되고 있지 않습니다. 이 메소드는, 주로 시스템 상태의 감시에 사용하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>대기중의 thread가 존재하는 경우는 <tt>true</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 배타적 동기가 보관 유지되지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 싱크로나이저와 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject)"><!-- --></A> <H3>
getWaitQueueLength</H3>
<PRE>
public final int <B>getWaitQueueLength</B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedLongSynchronizer.ConditionObject</A> &nbsp;condition)</PRE>
<DL>
<DD>이 싱크로나이저에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread의 추정수를 돌려줍니다. 타임 아웃 및 인터럽트의 발생할 가능성은 언제라도 존재하기 위해(때문에), 추정수는, 실제의 대기자수에 관한 상한을 나타내는에 지나지 않습니다. 이 메소드는, 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>대기중의 thread의 추정수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 배타적 동기가 보관 유지되지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 싱크로나이저와 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitingThreads(java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject)"><!-- --></A> <H3>
getWaitingThreads</H3>
<PRE>
public final <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getWaitingThreads</B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedLongSynchronizer.ConditionObject</A> &nbsp;condition)</PRE>
<DL>
<DD>이 싱크로나이저에 관련지을 수 있었던 지정 상태로 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는, 결과의 구축중에도 동적으로 변화할 가능성이 있기 (위해)때문에, 반환되는 컬렉션은 최선이 노력한 다음의 추정에 지나지 않습니다. 반환되는 컬렉션의 요소에는, 특정의 순서는 존재하지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>thread의 컬렉션
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 배타적 동기가 보관 유지되지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 싱크로나이저와 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractQueuedLongSynchronizer.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.html" title="java.util.concurrent.locks 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/locks/AbstractQueuedLongSynchronizer.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="AbstractQueuedLongSynchronizer.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
