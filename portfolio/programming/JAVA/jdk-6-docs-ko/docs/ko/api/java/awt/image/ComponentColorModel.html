<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:55:42 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
ComponentColorModel (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ComponentColorModel (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ComponentColorModel.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/awt/image/ComponentSampleModel.html" title="java.awt.image 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/awt/image/ComponentColorModel.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ComponentColorModel.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_java.awt.image.ColorModel">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt.image</FONT>
<BR>
클래스 ComponentColorModel</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">java.awt.image.ColorModel</A> 
      <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.awt.image.ComponentColorModel</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/awt/Transparency.html" title="java.awt 내의 인터페이스">Transparency</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>ComponentColorModel</B><DT>extends <A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </DL>
</PRE>

<P>
이것은 <CODE>ColorModel</CODE> 클래스의 1 개로, 픽셀치를 취급합니다.  이 픽셀치는, 색정보 및 알파 정보를 개별의 샘플로서 표현해, 각 샘플을 개별의 데이터 요소에 포함합니다. 이 클래스는, 임의의 <CODE>ColorSpace</CODE> 와 함께 사용할 수 있습니다. 픽셀치에 포함한 칼라 샘플의 수는,<CODE>ColorSpace</CODE> 에 있는 색성분의 수로 동일하지 않으면 안됩니다. 알파 샘플은, 단일에서도 괜찮습니다.  &nbsp;<p>
<CODE>transferType</CODE> 형의 프리미티브(primitive) 배열 픽셀 표현을 사용하는 메소드의 경우, 배열의 길이는 칼라 샘플 및 알파 샘플의 수로 동일해집니다. 배열에는 칼라 샘플이 최초로 포함되어 알파 샘플이 있으면, 그 후에 포함됩니다. 칼라 샘플의 순서는,<CODE>ColorSpace</CODE> 로 지정합니다. 일반적으로, 이 순서는 칼라 스페이스의 형태의 이름을 반영합니다. 예를 들어,<CODE>TYPE_RGB</CODE> 의 인덱스 0 은 빨강, 인덱스 1 은 초록, 그리고 인덱스 2 는 파랑이 됩니다.  &nbsp;<p>
표시, 혹은 이미지 처리를 위해서(때문에) 픽셀치를 색성분 또는 알파 성분으로 변환하는 처리는, 샘플과 성분의 1 대 1 대응이 됩니다. <code>ComponentColorModel</code> 의 인스턴스의 작성에 사용하는 전송형에 응해, 인스턴스가 부호 첨부나 부호 없음인가, 및 정수형, float, double 의 언젠가 (자세한 것은 이후를 참조)에 의해, 픽셀 샘플치는 표현됩니다. 샘플치를 색성분 또는 알파 성분으로 변환하는 처리는, 특정의 규칙에 따를 필요가 있습니다. float 및 double 의 샘플의 경우는 항등변환으로, 표준화 성분치가 대응하는 샘플치와 동일해집니다. 정수 샘플의 경우는, 단순한 스케일 및 오프셋(offset)만의 변환입니다.  스케일 정수와 오프셋(offset) 정수는 성분 마다 다른 일이 있습니다. 스케일 정수와 오프셋(offset) 정수를 적용한 결과는, 특정의 범위에 확실히 들어가는 색성분 및 알파 성분의 값세트입니다. 일반적으로, 색성분의 범위는 <code>ColorSpace</code> 클래스의 <code>getMinValue</code> 메소드와 <code>getMaxValue</code> 메소드에 의해 정의됩니다. 알파 성분의 범위는 0.0 ~ 1.0 입니다.  &nbsp;<p>
전송형 <CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>, 및 <CODE>DataBuffer.TYPE_INT</CODE> 으로 작성된 <code>ComponentColorModel</code> 의 인스턴스는, 부호 없음 정수치로서 다루어지는 픽셀 샘플치를 가집니다. 픽셀치의 색샘플과 알파 샘플의 비트수는,<code>ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int)</code> 생성자 에게 건네진, 대응하는 칼라 샘플 및 알파 샘플의 비트수와 다른 경우가 있습니다. 이 경우, 이 클래스는, 샘플치의 최하정도 n 비트가 성분의 값을 보관 유지하고 있다고 봅니다.  이 때 n 는, 생성자 에게 건네진 성분의 유효 비트의 수입니다. 또, 보다 상위에 있는 샘플치의 임의의 비트에 대해서는, 모두 0 이다고 보여집니다. 따라서, 샘플치의 범위는 0 ~ 2<sup>n</sup> - 1 이 됩니다.  이 클래스는, 이러한 샘플치를 표준화 된 색성분치에 맵 하므로, 0 은 <code>ColorSpace</code> 클래스의 <code>getMinValue</code> 메소드로부터 취득한 값에 맵 되어 2<sup>n</sup> - 1 은 <code>getMaxValue</code> 메소드로부터 취득한 값에 맵 됩니다. 다른 칼라 샘플의 매핑의 <code>ComponentColorModel</code> 을 작성하려면 , 이 클래스의 서브 클래스화해,<code>getNormalizedComponents(Object, float[], int)</code> 메소드를 오버라이드(override) 할 필요가 있습니다. 알파 샘플의 경우, 항상 0 이 0.0 에, 2<sup>n</sup> - 1 이 1.0 에 맵 됩니다.  &nbsp;<p>
부호 없음 샘플치를 가지는 인스턴스에서는, 다음의 2 개의 조건이 채워지는 경우에게만, 표준화되어 있지 않은 색성분 및 알파 성분 표현이 지원됩니다. 1 개(살)은, 샘플치 0 이 표준화 성분치 0.0 에 맵 되어 샘플치 2<sup>n</sup> - 1 이 1.0 에 맵 되는 것입니다. 이제(벌써) 1 개(살)은,<code>ColorSpace</code> 의 모든 색성분의 최소/최대 범위가 0.0 ~ 1.0 인 것입니다. 이 경우, 성분 표현은 대응하는 샘플의 최하정도 n 비트가 됩니다. 따라서, 각 성분은 0 으로 2<sup>n</sup> - 1 의 사이의 부호 없음 정수치입니다.  이 때 n 는, 특정의 성분의 유효 비트수입니다. 이러한 조건이 채워지지 않은 경우는, 비표준화 성분의 인수를 취하는 임의의 메소드가 <code>IllegalArgumentException</code> 를 throw 합니다.  &nbsp;<p>
전송형 <CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>, 및 <CODE>DataBuffer.TYPE_DOUBLE</CODE> 로 작성된 <code>ComponentColorModel</code> 의 인스턴스는, 부호 첨부 short, float, 또는 double 치로서 다루어지는 픽셀 샘플치를 보관 유지합니다. 이러한 인스턴스는 표준화되어 있지 않은 색성분 및 알파 성분 표현을 지원하지 않기 때문에, 인스턴스를 호출하면(자), 인수에 이러한 표현을 취하는 메소드는 <code>IllegalArgumentException</code> 를 throw 합니다. 이 클래스의 인스턴스의 표준화 성분치는, 다음의 전송형에 대응한 범위를 가집니다. float 샘플은 float 데이터형의 전범위, double 샘플은 float 데이터형의 전범위 (double 를 float 에 캐스트 한 결과), short 샘플은 거의 -maxVal ~ +maxVal 입니다.  maxVal 는 <code>ColorSpace</code> 의 성분 근처의 최대치입니다 (-32767 가 -maxVal 에, 0 이 0.0 에, 32767 이 +maxVal 에 맵 됩니다). 서브 클래스는,<code>getNormalizedComponents(Object, float[], int)</code> 메소드를 오버라이드(override) 하는 것으로써, short 샘플치의 표준화 성분치에의 슬캘링을 오버라이드(override) 하는 일이 있습니다. float 샘플과 double 샘플에 대해서는, 표준화 성분치가 대응하는 샘플치와 동일해져, 서브 클래스는 이러한 전송형의 어느 비항등변환슬캘링도 추가하지 않습니다.  &nbsp;<p>
전송형 <CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>, 및 <CODE>DataBuffer.TYPE_DOUBLE</CODE> 로 작성된 <code>ComponentColorModel</code> 의 인스턴스는, 모든 샘플치의 모든 비트를 사용합니다. 따라서, 모든 색성분 및 알파 성분은,<CODE>DataBuffer.TYPE_SHORT</CODE> 의 경우는 16 비트,<CODE>DataBuffer.TYPE_FLOAT</CODE> 의 경우는 32 비트,<CODE>DataBuffer.TYPE_DOUBLE</CODE> 의 경우는 64 비트를 보관 유지합니다. <code>ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int)</code> 형식의 생성자 이 이러한 전송형으로 사용되는 경우, 비트 배열 인수는 무시됩니다.  &nbsp;<p>
칼라 샘플치와 알파 샘플치가 draw 하는 성분치로서 적절히 해석되지 않는 것도 있습니다. 이것은,<code>ComponentColorModel</code> 이, 부호 없음 샘플치의 표준화 된 색성분치에의 매핑을 오버라이드(override) 하기 위한(해) 서브 클래스화 되고 있는지, 특정의 범위외의 부호 첨부 샘플치가 사용되고 있는 경우에 일어납니다. 예를 들어, 알파 성분을 0 ~ 32767 의 범위에 없는 부호 첨부 short 치, 표준화 범위 0.0 ~ 1.0 으로서 지정하면(자), 예기치 않은 결과가 됩니다. 색성분이 <code>ColorSpace</code> 의 표준화 범위 (<code>ColorSpace</code> 클래스의 <code>getMinValue</code> 메소드와 <code>getMaxValue</code> 메소드를 사용해 취득) 내에 있어, 알파 성분이 0.0 ~ 1.0 이도록(듯이), draw의 전에 어플리케이션측에서 픽셀 데이터를 적절히 슬캘링 할 필요가 있습니다. 색성분치 또는 알파 성분치가 범위외에 있는 경우에는, draw 결과를 확정할 수 없습니다.  &nbsp;<p>
<CODE>ComponentColorModel</CODE> 의 성분수가 1 으로 컴퍼넌트치가 부호 없음 (즉, 전송형 <CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>, 또는 <CODE>DataBuffer.TYPE_INT</CODE> 를 사용하는 단일의 색성분만으로, 알파 성분이 없다) 이외의 경우, 단일의 int 픽셀 표현을 사용하는 메소드는 <CODE>IllegalArgumentException</CODE> 를 throw 합니다.  &nbsp;<p>
<CODE>ComponentColorModel</CODE> 은,<CODE>ComponentSampleModel</CODE>,<CODE>BandedSampleModel</CODE>, 또는 <CODE>PixelInterleavedSampleModel</CODE> 와 조합해,<CODE>BufferedImage</CODE> 의 작성에 사용할 수 있습니다.
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스"><CODE>ColorModel</CODE></A> , 
<A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 안의 클래스"><CODE>ColorSpace</CODE></A> , 
<A HREF="../../../java/awt/image/ComponentSampleModel.html" title="java.awt.image 안의 클래스"><CODE>ComponentSampleModel</CODE></A> , 
<A HREF="../../../java/awt/image/BandedSampleModel.html" title="java.awt.image 안의 클래스"><CODE>BandedSampleModel</CODE></A> , 
<A HREF="../../../java/awt/image/PixelInterleavedSampleModel.html" title="java.awt.image 안의 클래스"><CODE>PixelInterleavedSampleModel</CODE></A> , 
<A HREF="../../../java/awt/image/BufferedImage.html" title="java.awt.image 안의 클래스"><CODE>BufferedImage</CODE></A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.image.ColorModel"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt.image. <A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 안의 클래스">ColorModel</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/awt/image/ColorModel.html#pixel_bits">pixel_bits</A> , <A HREF="../../../java/awt/image/ColorModel.html#transferType">transferType</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.Transparency"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.awt. <A HREF="../../../java/awt/Transparency.html" title="java.awt 안의 인터페이스">Transparency</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/awt/Transparency.html#BITMASK">BITMASK</A> , <A HREF="../../../java/awt/Transparency.html#OPAQUE">OPAQUE</A> , <A HREF="../../../java/awt/Transparency.html#TRANSLUCENT">TRANSLUCENT</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#ComponentColorModel(java.awt.color.ColorSpace, boolean, boolean, int, int)">ComponentColorModel</A> </B>(<A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 안의 클래스">ColorSpace</A> &nbsp;colorSpace,
                    boolean&nbsp;hasAlpha,
                    boolean&nbsp;isAlphaPremultiplied,
                    int&nbsp;transparency,
                    int&nbsp;transferType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 파라미터로부터,<CODE>ComponentColorModel</CODE> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#ComponentColorModel(java.awt.color.ColorSpace, int[], boolean, boolean, int, int)">ComponentColorModel</A> </B>(<A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 안의 클래스">ColorSpace</A> &nbsp;colorSpace,
                    int[]&nbsp;bits,
                    boolean&nbsp;hasAlpha,
                    boolean&nbsp;isAlphaPremultiplied,
                    int&nbsp;transparency,
                    int&nbsp;transferType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 파라미터로부터,<CODE>ComponentColorModel</CODE> 를 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#coerceData(java.awt.image.WritableRaster, boolean)">coerceData</A> </B>(<A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 안의 클래스">WritableRaster</A> &nbsp;raster,
           boolean&nbsp;isAlphaPremultiplied)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;라스터 데이터가 <CODE>isAlphaPremultiplied</CODE> 변수로 지정된 상태와 일치하도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 내의 클래스">SampleModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#createCompatibleSampleModel(int, int)">createCompatibleSampleModel</A> </B>(int&nbsp;w,
                            int&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 폭 및 높이로, 이 <CODE>ColorModel</CODE> 와 호환성이 있는 데이터 레이아웃을 가지는 <CODE>SampleModel</CODE> 를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 내의 클래스">WritableRaster</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#createCompatibleWritableRaster(int, int)">createCompatibleWritableRaster</A> </B>(int&nbsp;w,
                               int&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 폭 및 높이로, 이 <CODE>ColorModel</CODE> 와 호환성이 있는 데이터 레이아웃 (<CODE>SampleModel</CODE>)을 가지는 <CODE>WritableRaster</CODE> 를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#equals(java.lang.Object)">equals</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 칼라 모델과 다른 칼라 모델이 동일한지 어떤지를 비교합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getAlpha(int)">getAlpha</A> </B>(int&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 알파 성분을, 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getAlpha(java.lang.Object)">getAlpha</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 알파 성분을 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 내의 클래스">WritableRaster</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getAlphaRaster(java.awt.image.WritableRaster)">getAlphaRaster</A> </B>(<A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 안의 클래스">WritableRaster</A> &nbsp;raster)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이미지의 알파 채널을 표현하는 <CODE>Raster</CODE> 를, 입력된 <CODE>Raster</CODE> 로부터 추출해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getBlue(int)">getBlue</A> </B>(int&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 파랑의 색성분을, 디폴트의 RGB ColorSpace, 즉 sRGB 의 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getBlue(java.lang.Object)">getBlue</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 청색 성분을 디폴트 RGB <CODE>ColorSpace</CODE> (sRGB)의 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getComponents(int, int[], int)">getComponents</A> </B>(int&nbsp;pixel,
              int[]&nbsp;components,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <CODE>ColorModel</CODE> 로 픽셀을 지정해, 표준화되어 있지 않은 색성분과 알파 성분의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getComponents(java.lang.Object, int[], int)">getComponents</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;pixel,
              int[]&nbsp;components,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <CODE>ColorModel</CODE> 로 픽셀을 지정해, 표준화되어 있지 않은 색성분과 알파 성분의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getDataElement(float[], int)">getDataElement</A> </B>(float[]&nbsp;normComponents,
               int&nbsp;normOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;표준화되어 있지 않은 색성분 및 알파 성분의 배열을 지정해, 이 <code>ColorModel</code> 에 <code>int</code> 로서 나타내지는 픽셀치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getDataElement(int[], int)">getDataElement</A> </B>(int[]&nbsp;components,
               int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;비정규화된 색성분 혹은 알파 성분의 배열을 지정해, 이 <CODE>ColorModel</CODE> 의 int 로서 표현되는 픽셀치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getDataElements(float[], int, java.lang.Object)">getDataElements</A> </B>(float[]&nbsp;normComponents,
                int&nbsp;normOffset,
                <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;표준화색성분 및 알파 성분의 배열을 지정해, 이 <code>ColorModel</code> 의 픽셀의 데이터 요소 배열 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getDataElements(int[], int, java.lang.Object)">getDataElements</A> </B>(int[]&nbsp;components,
                int&nbsp;offset,
                <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;표준화되어 있지 않은 색성분 및 알파 성분의 배열을 지정해, 이 <CODE>ColorModel</CODE> 의 픽셀의 데이터 요소 배열 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getDataElements(int, java.lang.Object)">getDataElements</A> </B>(int&nbsp;rgb,
                <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트 RGB 칼라 모델의 정수형 픽셀 표현을 지정해, 이 <CODE>ColorModel</CODE> 의 픽셀의 데이터 요소 배열 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getGreen(int)">getGreen</A> </B>(int&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 초록의 색성분을, 디폴트의 RGB ColorSpace, 즉 sRGB 의 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getGreen(java.lang.Object)">getGreen</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 녹색 성분을 디폴트 RGB <CODE>ColorSpace</CODE> (sRGB)의 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getNormalizedComponents(int[], int, float[], int)">getNormalizedComponents</A> </B>(int[]&nbsp;components,
                        int&nbsp;offset,
                        float[]&nbsp;normComponents,
                        int&nbsp;normOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;표준화 성분 배열을 지정해, 비표준화 형식에서 모든 색성분 및 알파 성분의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getNormalizedComponents(java.lang.Object, float[], int)">getNormalizedComponents</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;pixel,
                        float[]&nbsp;normComponents,
                        int&nbsp;normOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>ColorModel</code> 의 지정된 픽셀에 대해, 표준화 형식에서 색성분과 알파 성분의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getRed(int)">getRed</A> </B>(int&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 빨강의 색성분을, 디폴트의 RGB ColorSpace, 즉 sRGB 의 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getRed(java.lang.Object)">getRed</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 빨강의 색성분을, 디폴트의 RGB ColorSpace, 즉 sRGB 의 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getRGB(int)">getRGB</A> </B>(int&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;픽셀의 색성분과 알파 성분을, 디폴트의 RGB 칼라 모델 형식에서 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getRGB(java.lang.Object)">getRGB</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 색성분 및 알파 성분을 디폴트 RGB 칼라 모델 형식에서 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getUnnormalizedComponents(float[], int, int[], int)">getUnnormalizedComponents</A> </B>(float[]&nbsp;normComponents,
                          int&nbsp;normOffset,
                          int[]&nbsp;components,
                          int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;표준화 성분 배열을 지정해, 비표준화 형식에서 모든 색성분 및 알파 성분의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#isCompatibleRaster(java.awt.image.Raster)">isCompatibleRaster</A> </B>(<A HREF="../../../java/awt/image/Raster.html" title="java.awt.image 안의 클래스">Raster</A> &nbsp;raster)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<CODE>raster</CODE> 가 이 <CODE>ColorModel</CODE> 와 호환성이 있는 경우에 true 를 돌려주어, 그렇지 않은 경우는 false 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#isCompatibleSampleModel(java.awt.image.SampleModel)">isCompatibleSampleModel</A> </B>(<A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 안의 클래스">SampleModel</A> &nbsp;sm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <CODE>SampleModel</CODE> 가 이 <CODE>ColorModel</CODE> 와 호환성이 있을지 어떨지를 판정합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.image.ColorModel"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt.image. <A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 안의 클래스">ColorModel</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/awt/image/ColorModel.html#finalize()">finalize</A> , <A HREF="../../../java/awt/image/ColorModel.html#getColorSpace()">getColorSpace</A> , <A HREF="../../../java/awt/image/ColorModel.html#getComponentSize()">getComponentSize</A> , <A HREF="../../../java/awt/image/ColorModel.html#getComponentSize(int)">getComponentSize</A> , <A HREF="../../../java/awt/image/ColorModel.html#getNumColorComponents()">getNumColorComponents</A> , <A HREF="../../../java/awt/image/ColorModel.html#getNumComponents()">getNumComponents</A> , <A HREF="../../../java/awt/image/ColorModel.html#getPixelSize()">getPixelSize</A> , <A HREF="../../../java/awt/image/ColorModel.html#getRGBdefault()">getRGBdefault</A> , <A HREF="../../../java/awt/image/ColorModel.html#getTransferType()">getTransferType</A> , <A HREF="../../../java/awt/image/ColorModel.html#getTransparency()">getTransparency</A> , <A HREF="../../../java/awt/image/ColorModel.html#hasAlpha()">hasAlpha</A> , <A HREF="../../../java/awt/image/ColorModel.html#hashCode()">hashCode</A> , <A HREF="../../../java/awt/image/ColorModel.html#isAlphaPremultiplied()">isAlphaPremultiplied</A> , <A HREF="../../../java/awt/image/ColorModel.html#toString()">toString</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ComponentColorModel(java.awt.color.ColorSpace, int[], boolean, boolean, int, int)"><!-- --></A> <H3>
ComponentColorModel</H3>
<PRE>
public <B>ComponentColorModel</B>(<A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 안의 클래스">ColorSpace</A> &nbsp;colorSpace,
                           int[]&nbsp;bits,
                           boolean&nbsp;hasAlpha,
                           boolean&nbsp;isAlphaPremultiplied,
                           int&nbsp;transparency,
                           int&nbsp;transferType)</PRE>
<DL>
<DD>지정된 파라미터로부터,<CODE>ComponentColorModel</CODE> 를 구축합니다. 색성분은, 지정된 <CODE>ColorSpace</CODE> 내가 됩니다. 지원되는 전송형은,<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>,<CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>, 및 <CODE>DataBuffer.TYPE_DOUBLE</CODE> 입니다. null 가 아닌 경우,<CODE>bits</CODE> 배열은, 색성분 및 알파 성분마다의 유효 비트수를 지정합니다.  픽셀치에 알파 정보가 없는 경우, 배열의 길이는 적어도 <CODE>ColorSpace</CODE> 에 있는 성분수가 되어, 알파 정보가 있는 경우는, 성분수보다 1 커집니다. <CODE>transferType</CODE> 가 <CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>, 또는 <CODE>DataBuffer.TYPE_DOUBLE</CODE> 의 경우,<CODE>bits</CODE> 배열 인수는 무시됩니다. <CODE> hasAlpha</CODE> 는, 알파 정보의 유무를 나타냅니다. <CODE>hasAlpha</CODE> 가 true 의 경우, boolean 형의 <CODE>isAlphaPremultiplied</CODE> 는, 픽셀치에 있는 칼라 샘플 및 알파 샘플을 평가하는 방법을 지정합니다. boolean 가 true 의 경우는, 칼라 샘플은 알파 샘플과 곱셈되었다고 보여집니다. <CODE>transparency</CODE> 는, 이 칼라 모델로 표현할 수 있는 알파치를 지정합니다. 허용 되는 <code>transparency</code> 치는,<CODE>OPAQUE</CODE>,<CODE>BITMASK</CODE>, 또는 <CODE>TRANSLUCENT</CODE> 입니다. <CODE>transferType</CODE> 는, 픽셀치의 표현에 사용하는 프리미티브(primitive) 배열의 형태입니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>colorSpace</CODE> - 이 칼라 모델에 관련했다  
                         <CODE>ColorSpace</CODE><DD><CODE>bits</CODE> - 1 성분 당의 유효 비트수.
                         null 의 경우, 모든 성분 샘플의
                         모든 비트가 유효하게 된다.
                         transferType 가
                         <CODE>DataBuffer.TYPE_SHORT</CODE>,
                         <CODE>DataBuffer.TYPE_FLOAT</CODE>, 또는
                         <CODE>DataBuffer.TYPE_DOUBLE</CODE> 의 경우는
                         무시되어 모든 성분 샘플의
                         모든 비트가 유효하게 되는<DD><CODE>hasAlpha</CODE> - true 의 경우, 이 칼라 모델은 알파를 지원하는<DD><CODE>isAlphaPremultiplied</CODE> - true 의 경우, 알파는 미리 곱셈되고 있는<DD><CODE>transparency</CODE> - 이 칼라 모델로 표현 가능한
                         알파치를 지정하는<DD><CODE>transferType</CODE> - 픽셀치를 표현하기 위해서 사용하는 프리미티브(primitive) 배열의 형태를
                         지정한다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <CODE>bits</CODE> 배열 인수가 
         null 가 아닌 경우, 그 길이가 색성분 및
         알파 성분의 수보다 작은 경우, transferType 가 
         <CODE>DataBuffer.TYPE_BYTE</CODE>,
         <CODE>DataBuffer.TYPE_USHORT</CODE>,
         <CODE>DataBuffer.TYPE_INT</CODE> 의 언젠가인 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - transferType 가
         <CODE>DataBuffer.TYPE_BYTE</CODE>,
         <CODE>DataBuffer.TYPE_USHORT</CODE>,
         <CODE>DataBuffer.TYPE_INT</CODE>,
         <CODE>DataBuffer.TYPE_SHORT</CODE>,
         <CODE>DataBuffer.TYPE_FLOAT</CODE>,
         <CODE>DataBuffer.TYPE_DOUBLE</CODE> 의 머지않아도 아닌 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 내의 클래스"><CODE>ColorSpace</CODE></A> , 
<A HREF="../../../java/awt/Transparency.html" title="java.awt 안의 인터페이스"><CODE>Transparency</CODE></A> </DL>
</DL>
<HR>

<A NAME="ComponentColorModel(java.awt.color.ColorSpace, boolean, boolean, int, int)"><!-- --></A> <H3>
ComponentColorModel</H3>
<PRE>
public <B>ComponentColorModel</B>(<A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 안의 클래스">ColorSpace</A> &nbsp;colorSpace,
                           boolean&nbsp;hasAlpha,
                           boolean&nbsp;isAlphaPremultiplied,
                           int&nbsp;transparency,
                           int&nbsp;transferType)</PRE>
<DL>
<DD>지정된 파라미터로부터,<CODE>ComponentColorModel</CODE> 를 구축합니다. 색성분은, 지정된 <CODE>ColorSpace</CODE> 내가 됩니다. 지원되는 전송형은,<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>,<CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>, 및 <CODE>DataBuffer.TYPE_DOUBLE</CODE> 입니다. 색성분 및 알파 성분마다의 유효 비트수는, 각각 8, 16, 32, 16, 32, 64 입니다. 색성분수는 <CODE>ColorSpace</CODE> 에 있는 성분수가 됩니다. <CODE>hasAlpha</CODE> 가 <CODE>true</CODE> 의 경우, 알파 성분이 있습니다. <CODE>hasAlpha</CODE> 가 true 의 경우, boolean 형의 <CODE>isAlphaPremultiplied</CODE> 는, 픽셀치에 있는 칼라 샘플 및 알파 샘플을 평가하는 방법을 지정합니다. boolean 가 true 의 경우는, 칼라 샘플은 알파 샘플과 곱셈되었다고 보여집니다. <CODE>transparency</CODE> 는, 이 칼라 모델로 표현할 수 있는 알파치를 지정합니다. 허용 되는 <code>transparency</code> 치는,<CODE>OPAQUE</CODE>,<CODE>BITMASK</CODE>, 또는 <CODE>TRANSLUCENT</CODE> 입니다. <CODE>transferType</CODE> 는, 픽셀치의 표현에 사용하는 프리미티브(primitive) 배열의 형태입니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>colorSpace</CODE> - 이 칼라 모델에 관련했다  
                         <CODE>ColorSpace</CODE><DD><CODE>hasAlpha</CODE> - true 의 경우, 이 칼라 모델은 알파를 지원하는<DD><CODE>isAlphaPremultiplied</CODE> - true 의 경우, 알파는 미리 곱셈되고 있는<DD><CODE>transparency</CODE> - 이 칼라 모델로 표현 가능한
                         알파치를 지정하는<DD><CODE>transferType</CODE> - 픽셀치를 표현하기 위해서 사용하는 프리미티브(primitive) 배열의 형태를
                         지정한다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - transferType 가
         <CODE>DataBuffer.TYPE_BYTE</CODE>,
         <CODE>DataBuffer.TYPE_USHORT</CODE>,
         <CODE>DataBuffer.TYPE_INT</CODE>,
         <CODE>DataBuffer.TYPE_SHORT</CODE>,
         <CODE>DataBuffer.TYPE_FLOAT</CODE>,
         <CODE>DataBuffer.TYPE_DOUBLE</CODE> 의 머지않아도 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 내의 클래스"><CODE>ColorSpace</CODE></A> , 
<A HREF="../../../java/awt/Transparency.html" title="java.awt 안의 인터페이스"><CODE>Transparency</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getRed(int)"><!-- --></A> <H3>
getRed</H3>
<PRE>
public int <B>getRed</B>(int&nbsp;pixel)</PRE>
<DL>
<DD>지정된 픽셀의 빨강의 색성분을, 디폴트의 RGB ColorSpace, 즉 sRGB 의 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. 필요한 경우, 색변환을 합니다. 픽셀치는 int 로서 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 값입니다. 알파가 미리 곱셈되고 있는 경우, 이 메소드는 값을 돌려주기 전에 알파를 제산합니다.  알파치가 0 의 경우, 빨강의 값은 0 이 됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getRed(int)">getRed</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 적색 성분을 취득하는 픽셀
<DT><B>반환값:</B><DD>지정된 픽셀의 적색 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 에 
 2 개(살) 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 의 성분치가
 부호 첨부의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getGreen(int)"><!-- --></A> <H3>
getGreen</H3>
<PRE>
public int <B>getGreen</B>(int&nbsp;pixel)</PRE>
<DL>
<DD>지정된 픽셀의 초록의 색성분을, 디폴트의 RGB ColorSpace, 즉 sRGB 의 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. 필요한 경우, 색변환을 합니다. 픽셀치는 int 로서 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 값입니다. 알파가 미리 곱셈되고 있는 경우, 이 메소드는 값을 돌려주기 전에 알파를 제산합니다.  알파치가 0 의 경우, 초록의 값은 0 이 됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getGreen(int)">getGreen</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 녹색 성분을 취득하는 픽셀
<DT><B>반환값:</B><DD>지정된 픽셀의 녹색 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 에 
 2 개(살) 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 의 성분치가
 부호 첨부의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getBlue(int)"><!-- --></A> <H3>
getBlue</H3>
<PRE>
public int <B>getBlue</B>(int&nbsp;pixel)</PRE>
<DL>
<DD>지정된 픽셀의 파랑의 색성분을, 디폴트의 RGB ColorSpace, 즉 sRGB 의 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. 필요한 경우, 색변환을 합니다. 픽셀치는 int 로서 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 값입니다. 알파가 미리 곱셈되고 있는 경우, 이 메소드는 값을 돌려주기 전에 알파를 제산합니다.  알파치가 0 의 경우, 파랑의 값은 0 이 됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getBlue(int)">getBlue</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 청색 성분을 취득하는 픽셀
<DT><B>반환값:</B><DD>지정된 픽셀의 청색 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 에 
 2 개(살) 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 의 성분치가
 부호 첨부의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getAlpha(int)"><!-- --></A> <H3>
getAlpha</H3>
<PRE>
public int <B>getAlpha</B>(int&nbsp;pixel)</PRE>
<DL>
<DD>지정된 픽셀의 알파 성분을, 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. 픽셀치는 int 로서 지정됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getAlpha(int)">getAlpha</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 알파 성분을 취득하는 픽셀
<DT><B>반환값:</B><DD>지정된 픽셀의 알파 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 에 
 2 개(살) 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 의 성분치가
 부호 첨부의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getRGB(int)"><!-- --></A> <H3>
getRGB</H3>
<PRE>
public int <B>getRGB</B>(int&nbsp;pixel)</PRE>
<DL>
<DD>픽셀의 색성분과 알파 성분을, 디폴트의 RGB 칼라 모델 형식에서 돌려줍니다. 필요한 경우, 색변환을 합니다. 반환값은, 미리 곱셈되어 있지 않은 값입니다. 알파가 미리 곱셈되고 있었을 경우, 이 메소드는 색성분으로 알파를 제산합니다.  알파치가 0 의 경우, 칼라치는 0 이 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getRGB(int)">getRGB</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 색성분 또는 알파 성분을 취득하는 픽셀
<DT><B>반환값:</B><DD>지정된 픽셀의 색성분 또는 알파 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 에 
 2 개(살) 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 의 성분치가
 부호 첨부의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/ColorModel.html#getRGBdefault()"><CODE>ColorModel.getRGBdefault()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRed(java.lang.Object)"><!-- --></A> <H3>
getRed</H3>
<PRE>
public int <B>getRed</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</PRE>
<DL>
<DD>지정된 픽셀의 빨강의 색성분을, 디폴트의 RGB ColorSpace, 즉 sRGB 의 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. 필요한 경우, 색변환을 합니다. <CODE>pixel</CODE> 치는, 객체 참조로서 건네받은 <CODE>transferType</CODE> 형의 데이터 요소로부터 되는 배열에 의해 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 값입니다. 알파가 미리 곱셈되고 있는 경우, 이 메소드는 값을 돌려주기 전에 알파를 제산합니다.  알파치가 0 의 경우, 빨강의 값은 0 이 됩니다. <code>ComponentColorModel</code> 는 서브 클래스화할 수 있기 (위해)때문에, 서브 클래스는 이 메소드의 구현을 상속하지만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code> 를 사용했을 경우, 예외가 throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getRed(java.lang.Object)">getRed</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inData</CODE> - 적색 성분을 취득하는 픽셀.  
 <CODE>transferType</CODE> 형의 데이터 요소의 배열로 지정한다
<DT><B>반환값:</B><DD>지정된 픽셀의 적색 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>inData</CODE> 가 
 <CODE>transferType</CODE> 형의 프리미티브(primitive) 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>inData</CODE> 가  
 이 <CODE>ColorModel</CODE> 의 픽셀치를 보관 유지하는데
 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 의 
 전송형이,
 지원되고 있는 전송형   
 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>, 
 <CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,
 <CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)가 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getGreen(java.lang.Object)"><!-- --></A> <H3>
getGreen</H3>
<PRE>
public int <B>getGreen</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</PRE>
<DL>
<DD>지정된 픽셀의 녹색 성분을 디폴트 RGB <CODE>ColorSpace</CODE> (sRGB)의 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. 필요한 경우, 색변환을 합니다. <CODE>pixel</CODE> 치는, 객체 참조로서 건네받은 <CODE>transferType</CODE> 형의 데이터 요소로부터 되는 배열에 의해 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 값이 됩니다. 알파가 미리 곱셈되고 있는 경우, 이 메소드는 값을 돌려주기 전에 알파를 제산합니다.  알파치가 0 의 경우, 초록의 값은 0 이 됩니다. <code>ComponentColorModel</code> 는 서브 클래스화할 수 있기 (위해)때문에, 서브 클래스는 이 메소드의 구현을 상속하지만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code> 를 사용했을 경우, 예외가 throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getGreen(java.lang.Object)">getGreen</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inData</CODE> - 녹색 성분을 취득하는 픽셀.  
 <CODE>transferType</CODE> 형의 데이터 요소의 배열로 지정한다
<DT><B>반환값:</B><DD>지정된 픽셀의 녹색 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>inData</CODE> 가 
 <CODE>transferType</CODE> 형의 프리미티브(primitive) 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>inData</CODE> 가  
 이 <CODE>ColorModel</CODE> 의 픽셀치를 보관 유지하는데
 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 의 
 전송형이,
 지원되고 있는 전송형   
 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>, 
 <CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,
 <CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)가 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getBlue(java.lang.Object)"><!-- --></A> <H3>
getBlue</H3>
<PRE>
public int <B>getBlue</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</PRE>
<DL>
<DD>지정된 픽셀의 청색 성분을 디폴트 RGB <CODE>ColorSpace</CODE> (sRGB)의 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다. 필요한 경우, 색변환을 합니다. <CODE>pixel</CODE> 치는, 객체 참조로서 건네받은 <CODE>transferType</CODE> 형의 데이터 요소로부터 되는 배열에 의해 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 값이 됩니다. 알파가 미리 곱셈되고 있는 경우, 이 메소드는 값을 돌려주기 전에 알파를 제산합니다.  알파치가 0 의 경우, 파랑의 값은 0 이 됩니다. <code>ComponentColorModel</code> 는 서브 클래스화할 수 있기 (위해)때문에, 서브 클래스는 이 메소드의 구현을 상속하지만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code> 를 사용했을 경우, 예외가 throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getBlue(java.lang.Object)">getBlue</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inData</CODE> - 청색 성분을 취득하는 픽셀.  
 <CODE>transferType</CODE> 형의 데이터 요소의 배열로 지정한다
<DT><B>반환값:</B><DD>지정된 픽셀의 청색 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>inData</CODE> 가 
 <CODE>transferType</CODE> 형의 프리미티브(primitive) 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>inData</CODE> 가  
 이 <CODE>ColorModel</CODE> 의 픽셀치를 보관 유지하는데
 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 의 
 전송형이,
 지원되고 있는 전송형   
 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>, 
 <CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,
 <CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)가 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getAlpha(java.lang.Object)"><!-- --></A> <H3>
getAlpha</H3>
<PRE>
public int <B>getAlpha</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</PRE>
<DL>
<DD>지정된 픽셀의 알파 성분을 0 ~ 255 의 범위에서 슬캘링 해 돌려줍니다.  픽셀치는, 객체 참조로서 건네받은 <CODE>transferType</CODE> 형의 데이터 요소의 배열로 지정됩니다. <code>ComponentColorModel</code> 는 서브 클래스화할 수 있기 (위해)때문에, 서브 클래스는 이 메소드의 구현을 상속하지만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code> 를 사용했을 경우, 예외가 throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getAlpha(java.lang.Object)">getAlpha</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inData</CODE> - 알파 성분을 취득하는 픽셀.  
 <CODE>transferType</CODE> 형의 데이터 요소의 배열로 지정한다
<DT><B>반환값:</B><DD>지정된 픽셀의 알파 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>inData</CODE> 가 
 <CODE>transferType</CODE> 형의 프리미티브(primitive) 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>inData</CODE> 가  
 이 <CODE>ColorModel</CODE> 의 픽셀치를 보관 유지하는데
 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 의 
 전송형이,
 지원되고 있는 전송형   
 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>, 
 <CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,
 <CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)가 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getRGB(java.lang.Object)"><!-- --></A> <H3>
getRGB</H3>
<PRE>
public int <B>getRGB</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</PRE>
<DL>
<DD>지정된 픽셀의 색성분 및 알파 성분을 디폴트 RGB 칼라 모델 형식에서 돌려줍니다. 필요한 경우, 색변환을 합니다. 픽셀치는, 객체 참조로서 건네받는 <CODE>transferType</CODE> 형의 데이터 요소의 배열에 의해 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 형식이 됩니다. 알파가 미리 곱셈되고 있었을 경우, 이 메소드는 색성분으로 알파를 제산합니다.  알파치가 0 의 경우, 칼라치는 0 이 됩니다. <code>ComponentColorModel</code> 는 서브 클래스화할 수 있기 (위해)때문에, 서브 클래스는 이 메소드의 구현을 상속하지만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code> 를 사용했을 경우, 예외가 throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getRGB(java.lang.Object)">getRGB</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inData</CODE> - 색성분 또는 알파 성분을 취득하는 픽셀.  
 <CODE>transferType</CODE> 형의 데이터 요소의 배열로 지정한다
<DT><B>반환값:</B><DD>지정된 픽셀의 색성분 또는 알파 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>inData</CODE> 가 
 <CODE>transferType</CODE> 형의 프리미티브(primitive) 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>inData</CODE> 가  
 이 <CODE>ColorModel</CODE> 의 픽셀치를 보관 유지하는데
 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 의 
 전송형이,
 지원되고 있는 전송형   
 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>, 
 <CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,
 <CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)가 아닌 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/ColorModel.html#getRGBdefault()"><CODE>ColorModel.getRGBdefault()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDataElements(int, java.lang.Object)"><!-- --></A> <H3>
getDataElements</H3>
<PRE>
public <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getDataElements</B>(int&nbsp;rgb,
                              <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;pixel)</PRE>
<DL>
<DD>디폴트 RGB 칼라 모델의 정수형 픽셀 표현을 지정해, 이 <CODE>ColorModel</CODE> 의 픽셀의 데이터 요소 배열 표현을 돌려줍니다. 이 배열은,<CODE>WritableRaster</CODE> 객체의 <CODE>setDataElements</CODE> 메소드에 건네줄 수가 있습니다. <CODE>pixel</CODE> 파라미터가 null 인 경우는, 새로운 배열을 할당할 수 있습니다. <code>ComponentColorModel</code> 는 서브 클래스화할 수 있기 (위해)때문에, 서브 클래스는 이 메소드의 구현을 상속하지만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code> 를 사용했을 경우, 예외가 throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getDataElements(int, java.lang.Object)">getDataElements</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rgb</CODE> - RGB 칼라 모델의 정수형
            픽셀 표현<DD><CODE>pixel</CODE> - 지정된 픽셀
<DT><B>반환값:</B><DD>이 <CODE>ColorModel</CODE> 의
 픽셀의 데이터 요소 배열 표현
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>pixel</CODE> 가 null 가 아니고, 
 <CODE>transferType</CODE> 형의 프리미티브(primitive) 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>pixel</CODE> 가 
 이 <CODE>ColorModel</CODE> 의 픽셀치를 보관 유지하는데
 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 의 
 전송형이,
 지원되고 있는 전송형   
 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>, 
 <CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,
 <CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)가 아닌 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/WritableRaster.html#setDataElements(int, int, java.lang.Object)"><CODE>WritableRaster.setDataElements(int, int, java.lang.Object)</CODE></A> , 
<A HREF="../../../java/awt/image/SampleModel.html#setDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer)"><CODE>SampleModel.setDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getComponents(int, int[], int)"><!-- --></A> <H3>
getComponents</H3>
<PRE>
public int[] <B>getComponents</B>(int&nbsp;pixel,
                           int[]&nbsp;components,
                           int&nbsp;offset)</PRE>
<DL>
<DD>이 <CODE>ColorModel</CODE> 로 픽셀을 지정해, 표준화되어 있지 않은 색성분과 알파 성분의 배열을 돌려줍니다. 이 <CODE>ColorModel</CODE> 의 성분치가 비표준화 형식에서 표현할 수 없는 경우는, IllegalArgumentException 가 throw 됩니다. 색성분 및 알파 성분은,<CODE>offset</CODE> 를 기점으로 <CODE>components</CODE> 배열에 포함됩니다.  배열이 이 메소드로 할당할 수 있고 있는 경우도 같습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getComponents(int, int[], int)">getComponents</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 정수로 지정되는 픽셀치<DD><CODE>components</CODE> - 표준화되어 있지 않은 색성분 또는 알파 성분을 포함한다 
 정수형의 배열. <CODE>components</CODE> 배열이 null 의 경우는,
 새로운 배열을 할당할 수 있는<DD><CODE>offset</CODE> - <CODE>components</CODE> 배열내의 오프셋(offset)
<DT><B>반환값:</B><DD>components 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 에
 2 개(살) 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 
 <CODE>ColorModel</CODE> 가 비표준화 형식을 지원하지 않는 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>components</CODE> 배열이  
 null 가 아닌 경우에, 오프셋(offset)를 기점으로 모든 색성분 및 알파 성분을 포함하는데 
 충분한 크기가 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getComponents(java.lang.Object, int[], int)"><!-- --></A> <H3>
getComponents</H3>
<PRE>
public int[] <B>getComponents</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;pixel,
                           int[]&nbsp;components,
                           int&nbsp;offset)</PRE>
<DL>
<DD>이 <CODE>ColorModel</CODE> 로 픽셀을 지정해, 표준화되어 있지 않은 색성분과 알파 성분의 배열을 돌려줍니다. 픽셀치는, 객체 참조로서 건네받는 <CODE>transferType</CODE> 형의 데이터 요소의 배열에 의해 지정됩니다. 이 <CODE>ColorModel</CODE> 의 성분치가 비표준화 형식에서 표현할 수 없는 경우는, IllegalArgumentException 가 throw 됩니다. 색성분 및 알파 성분은,<CODE>offset</CODE> 를 기점으로 <CODE>components</CODE> 배열에 포함됩니다.  배열이 이 메소드로 할당할 수 있고 있는 경우도 같습니다. <CODE>ComponentColorModel</code> 는 서브 클래스화할 수 있기 (위해)때문에, 서브 클래스는 이 메소드의 구현을 상속합니다만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code> 를 사용했을 경우, 이 메소드는 예외를 throw 하는 일이 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getComponents(java.lang.Object, int[], int)">getComponents</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - <CODE>transferType</CODE> 형의 데이터 요소의 배열로 지정된다
 픽셀치<DD><CODE>components</CODE> - 표준화되어 있지 않은 색성분 또는 알파 성분을 포함한다 
 정수형의 배열. <CODE>components</CODE> 배열이 null 의 경우는, 
 새로운 배열을 할당할 수 있는<DD><CODE>offset</CODE> - <CODE>components</CODE> 배열내의 오프셋(offset)
<DT><B>반환값:</B><DD><CODE>components</CODE> 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 
 <CODE>ComponentColorModel</CODE> 가 비표준화 형식을 지원하지 않는 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 의
 전송형이,
 <CODE>DataBuffer.TYPE_BYTE</CODE>,  
 <CODE>DataBuffer.TYPE_USHORT</CODE>, 
 <CODE>DataBuffer.TYPE_INT</CODE> 의 전송형의 머지않아도 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>pixel</CODE> 가 
 <CODE>transferType</CODE> 형의 프리미티브(primitive) 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <CODE>components</CODE> 배열이 null 가 아니고, 
 오프셋(offset)를 기점으로 모든 색성분 및 알파 성분을 포함하는데 
 충분한 크기가 아닌 경우. 또는 <CODE>pixel</CODE> 가 
 이 ColorModel 의 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getUnnormalizedComponents(float[], int, int[], int)"><!-- --></A> <H3>
getUnnormalizedComponents</H3>
<PRE>
public int[] <B>getUnnormalizedComponents</B>(float[]&nbsp;normComponents,
                                       int&nbsp;normOffset,
                                       int[]&nbsp;components,
                                       int&nbsp;offset)</PRE>
<DL>
<DD>표준화 성분 배열을 지정해, 비표준화 형식에서 모든 색성분 및 알파 성분의 배열을 돌려줍니다. 비표준화 성분은, 0 으로 2<sup>n</sup> - 1 의 사이의 부호 없음 정수치입니다.  n 는, 특정의 성분의 비트수입니다. 표준화 성분은, 이 <code>ColorModel</code> 의 <code>ColorSpace</code> 객체에 의해 지정된 성분마다의 최소와 최대의 사이의 float 치입니다. 이 <code>ColorModel</code> 의 색성분치가 비표준화 형식에서 표현할 수 없는 경우는,<code>IllegalArgumentException</code> 가 throw 됩니다. <code>components</code> 배열이 <code>null</code> 의 경우는, 새로운 배열을 할당할 수 있습니다. <code>components</code> 배열이 돌려주어집니다. 색성분 및 알파 성분은,<code>offset</code> 를 기점으로 <code>components</code> 배열에 포함됩니다.  배열이 이 메소드로 할당할 수 있고 있는 경우도 같습니다. <code>components</code> 배열이 <code>null</code> 가 아닌 경우에, (<code>offset</code> 를 기점으로) 모든 색성분 및 알파 성분을 포함하는데 충분한 크기가 아닐 때는,<code>ArrayIndexOutOfBoundsException</code> 가 throw 됩니다. <code>normComponents</code> 배열이 <code>normOffset</code> 를 기점으로 모든 색성분 및 알파 성분을 포함하는데 충분한 크기가 아닌 경우는,<code>IllegalArgumentException</code> 가 throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getUnnormalizedComponents(float[], int, int[], int)">getUnnormalizedComponents</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>normComponents</CODE> - 표준화 성분을 포함하고 있는 배열<DD><CODE>normOffset</CODE> - 표준화 성분의 취득을 개시하는,
 <code>normComponents</code> 배열에의 오프셋(offset)<DD><CODE>components</CODE> - <code>normComponents</code> 로부터 성분을 받는다
 배열<DD><CODE>offset</CODE> - <code>normComponents</code> 로부터
 표준화 성분의 포함을 개시하는,
 <code>components</code> 의 인덱스
<DT><B>반환값:</B><DD>표준화되어 있지 않은 색성분 및 알파 성분이
 포함되고 있는 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 
 <CODE>ComponentColorModel</CODE> 가 비표준화 형식을 지원하지 않는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>normComponents</code> 로부터
          <code>normOffset</code> 를 당긴 길이가
          <code>numComponents</code> 보다 짧은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getNormalizedComponents(int[], int, float[], int)"><!-- --></A> <H3>
getNormalizedComponents</H3>
<PRE>
public float[] <B>getNormalizedComponents</B>(int[]&nbsp;components,
                                       int&nbsp;offset,
                                       float[]&nbsp;normComponents,
                                       int&nbsp;normOffset)</PRE>
<DL>
<DD>표준화 성분 배열을 지정해, 비표준화 형식에서 모든 색성분 및 알파 성분의 배열을 돌려줍니다. 비표준화 성분은, 0 으로 2<sup>n</sup> - 1 의 사이의 부호 없음 정수치입니다.  n 는, 특정의 성분의 비트수입니다. 표준화 성분은, 이 <code>ColorModel</code> 의 <code>ColorSpace</code> 객체에 의해 지정된 성분마다의 최소와 최대의 사이의 float 치입니다. 이 <code>ColorModel</code> 의 색성분치가 비표준화 형식에서 표현할 수 없는 경우는,<code>IllegalArgumentException</code> 가 throw 됩니다. <code>normComponents</code> 배열이 <code>null</code> 의 경우는, 새로운 배열을 할당할 수 있습니다. 그 <code>normComponents</code> 배열이 돌려주어집니다. 색성분과 알파 성분은,<code>normOffset</code> 로부터 시작되는 <code>normComponents</code> 배열에 포함됩니다.  이것은, 배열이 이 메소드로 할당할 수 있고 있는 경우도 같습니다. <code>normComponents</code> 배열이 <code>null</code> 가 아니고, 색성분과 알파 성분 (<code>normOffset</code> 로부터 시작된다)의 모든 것을 포함할 수 있을 만큼 크지 않은 경우는,<code>ArrayIndexOutOfBoundsException</code> 가 throw 됩니다. <code>normComponents</code> 배열이 <code>normOffset</code> 를 기점으로 모든 색성분 및 알파 성분을 포함하는데 충분한 크기가 아닌 경우는,<code>IllegalArgumentException</code> 가 throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getNormalizedComponents(int[], int, float[], int)">getNormalizedComponents</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>components</CODE> - 표준화되어 있지 않은 성분을 포함하고 있는 배열<DD><CODE>offset</CODE> - 표준화되어 있지 않은 성분의 취득을 개시하는,
 <code>components</code> 배열에의 오프셋(offset)<DD><CODE>normComponents</CODE> - 표준화 성분을 받는 배열<DD><CODE>normOffset</CODE> - 표준화 성분의 포함을 개시하는,
 <code>normComponents</code> 의 인덱스
<DT><B>반환값:</B><DD>표준화 된 색성분 및 알파 성분이
 포함되고 있는 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 
 <CODE>ComponentColorModel</CODE> 가 비표준화 형식을 지원하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getDataElement(int[], int)"><!-- --></A> <H3>
getDataElement</H3>
<PRE>
public int <B>getDataElement</B>(int[]&nbsp;components,
                          int&nbsp;offset)</PRE>
<DL>
<DD>비정규화된 색성분 혹은 알파 성분의 배열을 지정해, 이 <CODE>ColorModel</CODE> 의 int 로서 표현되는 픽셀치를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getDataElement(int[], int)">getDataElement</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>components</CODE> - 표준화되어 있지 않은 색성분 또는 알파 성분의 배열<DD><CODE>offset</CODE> - <CODE>components</CODE> 배열내의 오프셋(offset)
<DT><B>반환값:</B><DD>int 로 표현된 픽셀치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 ColorModel 에  
 2 개(살) 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 
 <CODE>ComponentColorModel</CODE> 가 비표준화 형식을 지원하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getDataElements(int[], int, java.lang.Object)"><!-- --></A> <H3>
getDataElements</H3>
<PRE>
public <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getDataElements</B>(int[]&nbsp;components,
                              int&nbsp;offset,
                              <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>표준화되어 있지 않은 색성분 및 알파 성분의 배열을 지정해, 이 <CODE>ColorModel</CODE> 의 픽셀의 데이터 요소 배열 표현을 돌려줍니다. 이 배열은,<CODE>WritableRaster</CODE> 객체의 <CODE>setDataElements</CODE> 메소드에 건네줄 수가 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getDataElements(int[], int, java.lang.Object)">getDataElements</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>components</CODE> - 표준화되어 있지 않은 색성분 또는 알파 성분의 배열<DD><CODE>offset</CODE> - <CODE>components</CODE> 배열내의 int 오프셋(offset)<DD><CODE>obj</CODE> - 픽셀의 데이터 요소 배열 표현을 포함한다 
 객체. <CODE>obj</CODE> 변수가 null 의 경우는, 
 새로운 배열을 할당할 수 있다. <CODE>obj</CODE> 가 null 가 아닌 경우, 
 <CODE>transferType</CODE> 형의 프리미티브(primitive) 배열이 아니면 안된다.  
 <CODE>obj</CODE> 가 이 <CODE>ColorModel</CODE> 의 픽셀치를 
 포함하는데 충분한 크기가 아닌 경우, 
 <CODE>ArrayIndexOutOfBoundsException</CODE> 가 throw 된다.
 <code>ComponentColorModel</code> 는 서브 클래스화할 수 있기 (위해)때문에,
 서브 클래스는 이 메소드의 구현을 상속한다. 서브 클래스가 그 구현을 오버라이드(override) 하지 않는 경우,
 지원되어 있지 않은 <code>transferType</code> 를 사용하고 있으면(자), 
 예외가 throw 된다
<DT><B>반환값:</B><DD>이 <CODE>ColorModel</CODE> 의 
 픽셀의 데이터 요소 배열 표현
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - components 배열이 
 오프셋(offset)를 기점으로 모든 색성분 및 알파 성분을 포함하는데
 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>obj</CODE> 가 null 가 아니고, 한편 
 <CODE>transferType</CODE> 형의 프리미티브(primitive) 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>obj</CODE> 가
 이 <CODE>ColorModel</CODE> 의 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 
 <CODE>ComponentColorModel</CODE> 가 비표준화 형식을 지원하지 않는 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 의 
 전송형이,
 <CODE>DataBuffer.TYPE_BYTE</CODE>,  
 <CODE>DataBuffer.TYPE_USHORT</CODE>, 
 <CODE>DataBuffer.TYPE_INT</CODE> 의 전송형의 머지않아도 아닌 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/WritableRaster.html#setDataElements(int, int, java.lang.Object)"><CODE>WritableRaster.setDataElements(int, int, java.lang.Object)</CODE></A> , 
<A HREF="../../../java/awt/image/SampleModel.html#setDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer)"><CODE>SampleModel.setDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDataElement(float[], int)"><!-- --></A> <H3>
getDataElement</H3>
<PRE>
public int <B>getDataElement</B>(float[]&nbsp;normComponents,
                          int&nbsp;normOffset)</PRE>
<DL>
<DD>표준화되어 있지 않은 색성분 및 알파 성분의 배열을 지정해, 이 <code>ColorModel</code> 에 <code>int</code> 로서 나타내지는 픽셀치를 돌려줍니다. 이 <code>ColorModel</code> 의 픽셀치가 단일의 <code>int</code> 로서 표현할 수 없는 경우, 이 메소드는 <code>IllegalArgumentException</code> 를 throw 합니다. <code>normComponents</code> 배열이 (<code>normOffset</code> 를 기점으로) 모든 색성분 및 알파 성분을 포함하는데 충분한 크기가 아닌 경우는,<code>ArrayIndexOutOfBoundsException</code> 가 throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getDataElement(float[], int)">getDataElement</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>normComponents</CODE> - 표준화 된 색성분 및 알파 성분의
 배열<DD><CODE>normOffset</CODE> - 색성분 및 알파 성분의 취득을 개시하는,
 <code>normComponents</code> 의 인덱스
<DT><B>반환값:</B><DD>지정된 성분에 대응하는,
 이 <code>ColorModel</code> 내의 <code>int</code> 픽셀치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <code>ColorModel</code> 의 픽셀치가
  단일의 <code>int</code> 로서 표현할 수 없는 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>normComponents</code> 배열이,
  <code>normOffset</code> 를 기점으로 모든 색성분 및 알파 성분을 포함하는데 
  충분한 크기가 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDataElements(float[], int, java.lang.Object)"><!-- --></A> <H3>
getDataElements</H3>
<PRE>
public <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getDataElements</B>(float[]&nbsp;normComponents,
                              int&nbsp;normOffset,
                              <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>표준화색성분 및 알파 성분의 배열을 지정해, 이 <code>ColorModel</code> 의 픽셀의 데이터 요소 배열 표현을 돌려줍니다. 이 배열은,<code>WritableRaster</code> 객체의 <code>setDataElements</code> 메소드에 건네줄 수가 있습니다. <code>normComponents</code> 배열이 (<code>normOffset</code> 를 기점으로) 모든 색성분 및 알파 성분을 포함하는데 충분한 크기가 아닌 경우는,<code>ArrayIndexOutOfBoundsException</code> 가 throw 됩니다. <code>obj</code> 변수가 <code>null</code> 의 경우는, 새로운 배열을 할당할 수 있습니다. <code>obj</code> 가 <code>null</code> 가 아닌 경우는, transferType 형의 프리미티브(primitive) 배열일 필요가 있습니다.  그렇지 않은 경우는,<code>ClassCastException</code> 가 throw 됩니다. <code>obj</code> 가 이 <code>ColorModel</code> 의 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우는,<code>ArrayIndexOutOfBoundsException</code> 가 throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getDataElements(float[], int, java.lang.Object)">getDataElements</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>normComponents</CODE> - 표준화 된 색성분 및 알파 성분의
 배열<DD><CODE>normOffset</CODE> - 색성분 및 알파 성분의 취득을 개시하는,
 <code>normComponents</code> 의 인덱스<DD><CODE>obj</CODE> - 반환된 픽셀을 보관 유지하는 프리미티브(primitive) 데이터 배열
<DT><B>반환값:</B><DD>픽셀의 프리미티브(primitive) 데이터 배열 표현의 
 <code>Object</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <code>obj</code> 가
  <code>transferType</code> 형의 프리미티브(primitive) 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>obj</code> 가 이 <code>ColorModel</code> 의 픽셀치를
  포함하는데 충분한 크기가 아닌 경우, 또는 <code>normComponents</code> 배열이 
  <code>offset</code> 를 기점으로 모든 색성분 및 알파 성분을 포함하는데
  충분한 크기가 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/WritableRaster.html#setDataElements(int, int, java.lang.Object)"><CODE>WritableRaster.setDataElements(int, int, java.lang.Object)</CODE></A> , 
<A HREF="../../../java/awt/image/SampleModel.html#setDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer)"><CODE>SampleModel.setDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getNormalizedComponents(java.lang.Object, float[], int)"><!-- --></A> <H3>
getNormalizedComponents</H3>
<PRE>
public float[] <B>getNormalizedComponents</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;pixel,
                                       float[]&nbsp;normComponents,
                                       int&nbsp;normOffset)</PRE>
<DL>
<DD>이 <code>ColorModel</code> 의 지정된 픽셀에 대해, 표준화 형식에서 색성분과 알파 성분의 배열을 돌려줍니다. 픽셀치는, 객체 참조로서 건네받는 transferType 형의 데이터 요소의 배열에 의해 지정됩니다. pixel 가 transferType 형의 프리미티브(primitive) 배열이 아닌 경우는,<code>ClassCastException</code> 가 throw 됩니다. <code>pixel</code> 가 이 <code>ColorModel</code> 의 픽셀치를 포함할 수 있을 만큼 크지 않은 경우는,<code>ArrayIndexOutOfBoundsException</code> 가 throw 됩니다. 표준화 성분은, 이 <code>ColorModel</code> 의 <code>ColorSpace</code> 객체에 의해 지정된 성분마다의 최소와 최대의 사이의 float 치입니다. <code>normComponents</code> 배열이 <code>null</code> 의 경우는, 새로운 배열을 할당할 수 있습니다. 그 <code>normComponents</code> 배열이 돌려주어집니다. 색성분과 알파 성분은,<code>normOffset</code> 로부터 시작되는 <code>normComponents</code> 배열에 포함됩니다.  이것은, 배열이 이 메소드로 할당할 수 있고 있는 경우도 같습니다. <code>normComponents</code> 배열이 <code>null</code> 가 아니고, 색성분과 알파 성분 (<code>normOffset</code> 로부터 시작된다)의 모든 것을 포함할 수 있을 만큼 크지 않은 경우는,<code>ArrayIndexOutOfBoundsException</code> 가 throw 됩니다.  &nbsp;<p>
서브 클래스가 디폴트와는 다른 방법으로 픽셀 샘플치를 색성분치에 변환하도록(듯이) 설계되고 있는 경우는, 이 메소드를 서브 클래스에서 오버라이드(override) 할 필요가 있습니다. 이 클래스에 의해 구현되는 디폴트의 변환은, 클래스의 코멘트에 기술되고 있습니다. 디폴트가 아닌 변환을 구현하는 서브 클래스는, 이 코멘트에 정의된 허용 변환의 제약에 따를 필요가 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getNormalizedComponents(java.lang.Object, float[], int)">getNormalizedComponents</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 지정된 픽셀<DD><CODE>normComponents</CODE> - 표준화 성분을 받는 배열<DD><CODE>normOffset</CODE> - 표준화 성분의 포함을 개시하는,
 <code>normComponents</code> 배열에의 오프셋(offset)
<DT><B>반환값:</B><DD>표준화 된 색성분 및 알파 성분이
 포함되고 있는 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <code>pixel</code> 가
          transferType 형의 프리미티브(primitive) 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>normComponents</code> 가,<code>normOffset</code> 를 기점으로
          모든 색성분 및 알파 성분을 포함하는데 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>pixel</code> 가 이 <code>ColorModel</code> 의 픽셀치를
          보관 유지하는데 충분한 크기가 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="coerceData(java.awt.image.WritableRaster, boolean)"><!-- --></A> <H3>
coerceData</H3>
<PRE>
public <A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A>  <B>coerceData</B>(<A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 안의 클래스">WritableRaster</A> &nbsp;raster,
                             boolean&nbsp;isAlphaPremultiplied)</PRE>
<DL>
<DD>라스터 데이터가 <CODE>isAlphaPremultiplied</CODE> 변수로 지정된 상태와 일치하도록(듯이) 합니다.  이 때, 데이터는 이 <CODE>ColorModel</CODE> 에 의해 현재 올바르게 기술되고 있다고 보여집니다. 이 메소드는, 칼라 라스터 데이터를 알파에서 곱셈 또는 제산합니다.  데이터가 올바른 상태에 있는 경우에는, 처리는 실시하지 않습니다. 데이터가 강제적으로 형태 변환될 필요가 있는 경우, 이 메소드는 <CODE>isAlphaPremultiplied</CODE> 플래그를 올바르게 설정한, 이 <CODE>ColorModel</CODE> 의 인스턴스도 돌려줍니다. <code>ColorModel</code> 는 서브 클래스화할 수 있기 (위해)때문에, 서브 클래스는 이 메소드의 구현을 상속합니다만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code> 를 사용했을 경우, 예외가 throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#coerceData(java.awt.image.WritableRaster, boolean)">coerceData</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>raster</CODE> - <code>WritableRaster</code> 데이터<DD><CODE>isAlphaPremultiplied</CODE> - 알파가 미리 곱셈되고 있는 경우는 <code>true</code>,
 그렇지 않은 경우는 <code>false</code>
<DT><B>반환값:</B><DD>강제적으로 형태 변환된 데이터를 나타낸다 
 <code>ColorModel</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>raster</code> 가  
 <code>null</code> 로, 강제 변환이 필요한 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 의 
 전송형이,
 지원되고 있는 전송형   
 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>, 
 <CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,
 <CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)가 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="isCompatibleRaster(java.awt.image.Raster)"><!-- --></A> <H3>
isCompatibleRaster</H3>
<PRE>
public boolean <B>isCompatibleRaster</B>(<A HREF="../../../java/awt/image/Raster.html" title="java.awt.image 안의 클래스">Raster</A> &nbsp;raster)</PRE>
<DL>
<DD><CODE>raster</CODE> 가 이 <CODE>ColorModel</CODE> 와 호환성이 있는 경우에 true 를 돌려주어, 그렇지 않은 경우는 false 를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#isCompatibleRaster(java.awt.image.Raster)">isCompatibleRaster</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>raster</CODE> - 호환성을 판정하는 <CODE>Raster</CODE> 객체
<DT><B>반환값:</B><DD><CODE>raster</CODE> 가 이 <CODE>ColorModel</CODE> 와 호환성이 있는 경우는  
 <CODE>true</CODE>, 그렇지 않은 경우는 <CODE>false</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="createCompatibleWritableRaster(int, int)"><!-- --></A> <H3>
createCompatibleWritableRaster</H3>
<PRE>
public <A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 내의 클래스">WritableRaster</A>  <B>createCompatibleWritableRaster</B>(int&nbsp;w,
                                                     int&nbsp;h)</PRE>
<DL>
<DD>지정된 폭 및 높이로, 이 <CODE>ColorModel</CODE> 와 호환성이 있는 데이터 레이아웃 (<CODE>SampleModel</CODE>)을 가지는 <CODE>WritableRaster</CODE> 를 작성합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#createCompatibleWritableRaster(int, int)">createCompatibleWritableRaster</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>w</CODE> - 생성하는 <CODE>WritableRaster</CODE> 의 폭<DD><CODE>h</CODE> - 생성하는 <CODE>WritableRaster</CODE> 의 높이
<DT><B>반환값:</B><DD>이 <CODE>ColorModel</CODE> 와 호환성이 있다  
 <CODE>WritableRaster</CODE><DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 내의 클래스"><CODE>WritableRaster</CODE></A> , 
<A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 안의 클래스"><CODE>SampleModel</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createCompatibleSampleModel(int, int)"><!-- --></A> <H3>
createCompatibleSampleModel</H3>
<PRE>
public <A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 내의 클래스">SampleModel</A>  <B>createCompatibleSampleModel</B>(int&nbsp;w,
                                               int&nbsp;h)</PRE>
<DL>
<DD>지정된 폭 및 높이로, 이 <CODE>ColorModel</CODE> 와 호환성이 있는 데이터 레이아웃을 가지는 <CODE>SampleModel</CODE> 를 작성합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#createCompatibleSampleModel(int, int)">createCompatibleSampleModel</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>w</CODE> - 생성하는 <CODE>SampleModel</CODE> 의 폭<DD><CODE>h</CODE> - 생성하는 <CODE>SampleModel</CODE> 의 높이
<DT><B>반환값:</B><DD>이 <CODE>ColorModel</CODE> 와 호환성이 있다 
 <CODE>SampleModel</CODE><DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 내의 클래스"><CODE>SampleModel</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isCompatibleSampleModel(java.awt.image.SampleModel)"><!-- --></A> <H3>
isCompatibleSampleModel</H3>
<PRE>
public boolean <B>isCompatibleSampleModel</B>(<A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 안의 클래스">SampleModel</A> &nbsp;sm)</PRE>
<DL>
<DD>지정된 <CODE>SampleModel</CODE> 가 이 <CODE>ColorModel</CODE> 와 호환성이 있을지 어떨지를 판정합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#isCompatibleSampleModel(java.awt.image.SampleModel)">isCompatibleSampleModel</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>sm</CODE> - 호환성을 판정하는 <CODE>SampleModel</CODE>
<DT><B>반환값:</B><DD><CODE>SampleModel</CODE> 가 이 <CODE>ColorModel</CODE> 와 
 호환성이 있는 경우는 <CODE>true</CODE>, 그렇지 않은 경우는  
 <CODE>false</CODE><DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 내의 클래스"><CODE>SampleModel</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAlphaRaster(java.awt.image.WritableRaster)"><!-- --></A> <H3>
getAlphaRaster</H3>
<PRE>
public <A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 내의 클래스">WritableRaster</A>  <B>getAlphaRaster</B>(<A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 안의 클래스">WritableRaster</A> &nbsp;raster)</PRE>
<DL>
<DD>이미지의 알파 채널을 표현하는 <CODE>Raster</CODE> 를, 입력된 <CODE>Raster</CODE> 로부터 추출해 돌려줍니다. 이 메소드는, 이 <CODE>ColorModel</CODE> 에 관련한 <CODE>Raster</CODE> 객체에 알파 밴드가 있으면, 그 알파 밴드를 이미지 데이터의 최종 밴드로서 포함하고 있다고 봅니다. 이 <CODE>ColorModel</CODE> 에 관련한 공간 알파 채널이 그 밖에 없는 경우는, null 를 돌려줍니다. 이 메소드는 새로운 <CODE>Raster</CODE> 를 작성합니다만, 데이터 배열은 공유하게 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getAlphaRaster(java.awt.image.WritableRaster)">getAlphaRaster</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>raster</CODE> - 알파 채널을 추출한다  
 <CODE>WritableRaster</CODE>
<DT><B>반환값:</B><DD>이미지의 알파 채널이 포함되고 있는 <CODE>WritableRaster</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>이 칼라 모델과 다른 칼라 모델이 동일한지 어떤지를 비교합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#equals(java.lang.Object)">equals</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 이 칼라 모델과 비교하는 객체
<DT><B>반환값:</B><DD>이러한 칼라 모델 객체가 동등한 경우는 <CODE>true</CODE>, 
 그렇지 않은 경우는 <CODE>false</CODE><DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A> , 
<A HREF="../../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ComponentColorModel.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/awt/image/ComponentSampleModel.html" title="java.awt.image 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/awt/image/ComponentColorModel.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ComponentColorModel.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_java.awt.image.ColorModel">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
