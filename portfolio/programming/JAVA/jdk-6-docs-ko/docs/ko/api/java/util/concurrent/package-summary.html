<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:47:08 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
java.util.concurrent (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="java.util.concurrent (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/atomic/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/concurrent/package-summary.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
패키지 java.util.concurrent
</H2>
 병행 프로그래밍으로 자주(잘) 사용되는 유틸리티 클래스입니다.
<P>
<B>참조처:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>설명</B></A> 
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>인터페이스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/BlockingDeque.html" title="java.util.concurrent 안의 인터페이스">BlockingDeque&lt;E&gt;</A> </B></TD>
<TD>요소의 취득시에 양단 큐가 빈 상태(empty)이 아니게 될 때까지 대기하거나 요소의 포함시에 양단 큐내에 빈 곳이 생길 때까지 대기하는 블록 조작을 추가로 지원하거나 하는 <A HREF="../../../java/util/Deque.html" title="java.util 동안의 인터페이스"><CODE>Deque</CODE></A>  입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue&lt;E&gt;</A> </B></TD>
<TD>요소의 취득시에 큐가 빈 상태(empty)이 아니게 될 때까지 대기하거나 요소의 포함시에 큐내에 빈 곳이 생길 때까지 대기하는 조작을 추가로 지원하는 <A HREF="../../../java/util/Queue.html" title="java.util 동안의 인터페이스"><CODE>Queue</CODE></A>  입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Callable.html" title="java.util.concurrent 안의 인터페이스">Callable&lt;V&gt;</A> </B></TD>
<TD>결과를 돌려주어, 예외를 throw 하는 일이 있는 태스크입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CompletionService.html" title="java.util.concurrent 안의 인터페이스">CompletionService&lt;V&gt;</A> </B></TD>
<TD>새로운 비동기 태스크의 생성을, 완료필 태스크의 결과의 소비로부터 분리하는 서비스입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentMap.html" title="java.util.concurrent 안의 인터페이스">ConcurrentMap&lt;K, V&gt;</A> </B></TD>
<TD>추가의 원자적 <tt>putIfAbsent</tt>,<tt>remove</tt>, 및 <tt>replace</tt> 메소드를 제공하는 <A HREF="../../../java/util/Map.html" title="java.util 동안의 인터페이스"><CODE>Map</CODE></A>  입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentNavigableMap.html" title="java.util.concurrent 안의 인터페이스">ConcurrentNavigableMap&lt;K, V&gt;</A> </B></TD>
<TD><A HREF="../../../java/util/NavigableMap.html" title="java.util 안의 인터페이스"><CODE>NavigableMap</CODE></A>  오퍼레이션을 지원하는 <A HREF="../../../java/util/concurrent/ConcurrentMap.html" title="java.util.concurrent 동안의 인터페이스"><CODE>ConcurrentMap</CODE></A>  입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Delayed.html" title="java.util.concurrent 안의 인터페이스">Delayed</A> </B></TD>
<TD>일정한 지연의 후에 영향을 받는 객체에 마크부하기 위한 , 혼합 스타일의 인터페이스입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 안의 인터페이스">Executor</A> </B></TD>
<TD>송신된 <A HREF="../../../java/lang/Runnable.html" title="java.lang 동안의 인터페이스"><CODE>Runnable</CODE></A>  태스크를 실행하는 객체입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 안의 인터페이스">ExecutorService</A> </B></TD>
<TD>종료를 관리하는 메소드, 및 1 개(살) 이상의 비동기 태스크의 진행 상황을 추적하는 <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 동안의 인터페이스"><CODE>Future</CODE></A>  를 생성할 수 있는 메소드를 제공하는 <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 동안의 인터페이스"><CODE>Executor</CODE></A>  입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 안의 인터페이스">Future&lt;V&gt;</A> </B></TD>
<TD><tt>Future</tt> 는, 비동기 계산의 결과를 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> </B></TD>
<TD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 안의 클래스"><CODE>ThreadPoolExecutor</CODE></A>  로 실행할 수 없는 태스크의 핸들러입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/RunnableFuture.html" title="java.util.concurrent 안의 인터페이스">RunnableFuture&lt;V&gt;</A> </B></TD>
<TD><A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스"><CODE>Runnable</CODE></A>  인 <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 동안의 인터페이스"><CODE>Future</CODE></A>  입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/RunnableScheduledFuture.html" title="java.util.concurrent 안의 인터페이스">RunnableScheduledFuture&lt;V&gt;</A> </B></TD>
<TD><A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스"><CODE>Runnable</CODE></A>  인 <A HREF="../../../java/util/concurrent/ScheduledFuture.html" title="java.util.concurrent 동안의 인터페이스"><CODE>ScheduledFuture</CODE></A>  입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent 안의 인터페이스">ScheduledExecutorService</A> </B></TD>
<TD>지정된 지연 시간 후 또는 정기적으로 커멘드를 실행하도록(듯이) 스케줄 할 수 있는 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 동안의 인터페이스"><CODE>ExecutorService</CODE></A>  입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ScheduledFuture.html" title="java.util.concurrent 안의 인터페이스">ScheduledFuture&lt;V&gt;</A> </B></TD>
<TD>취소해 가능한, 지연 된 결과 생성 액션입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> </B></TD>
<TD>요구에 응해 새로운 thread를 작성하는 객체입니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="java.util.concurrent 안의 클래스">AbstractExecutorService</A> </B></TD>
<TD><A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 안의 인터페이스"><CODE>ExecutorService</CODE></A>  실행 메소드의 디폴트 구현을 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent 안의 클래스">ArrayBlockingQueue&lt;E&gt;</A> </B></TD>
<TD>배열에 연동하는 바운드 형식<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 중의 인터페이스">블로킹 큐</a>입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent 안의 클래스">ConcurrentHashMap&lt;K, V&gt;</A> </B></TD>
<TD>취득의 완전한 동시성 및 예상되는 조정 가능한 갱신 병행성을 지원하는 해시 테이블입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentLinkedQueue.html" title="java.util.concurrent 안의 클래스">ConcurrentLinkedQueue&lt;E&gt;</A> </B></TD>
<TD>링크 노드에 근거하는, 안 바운드 형식의 thread 세이프인<A HREF="../../../java/util/Queue.html" title="java.util 안의 인터페이스">큐</a>입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentSkipListMap.html" title="java.util.concurrent 안의 클래스">ConcurrentSkipListMap&lt;K, V&gt;</A> </B></TD>
<TD>측정할 수 있는 병행 <A HREF="../../../java/util/concurrent/ConcurrentNavigableMap.html" title="java.util.concurrent 내의 인터페이스"><CODE>ConcurrentNavigableMap</CODE></A>  구현입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentSkipListSet.html" title="java.util.concurrent 안의 클래스">ConcurrentSkipListSet&lt;E&gt;</A> </B></TD>
<TD><A HREF="../../../java/util/concurrent/ConcurrentSkipListMap.html" title="java.util.concurrent 안의 클래스"><CODE>ConcurrentSkipListMap</CODE></A>  에 근거하는 측정할 수 있는 병행 <A HREF="../../../java/util/NavigableSet.html" title="java.util 내의 인터페이스"><CODE>NavigableSet</CODE></A>  구현입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent 안의 클래스">CopyOnWriteArrayList&lt;E&gt;</A> </B></TD>
<TD>기본으로 되는 배열의 새로운 카피를 작성하는 것으로써, 모든 추이적 조작 (<tt>add</tt>,<tt>set</tt> 등)이 구현되는 <A HREF="../../../java/util/ArrayList.html" title="java.util 동안의 클래스"><CODE>ArrayList</CODE></A>  의 thread 세이프인 변수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CopyOnWriteArraySet.html" title="java.util.concurrent 안의 클래스">CopyOnWriteArraySet&lt;E&gt;</A> </B></TD>
<TD>모든 조작으로 내부 <A HREF="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent 내의 클래스"><CODE>CopyOnWriteArrayList</CODE></A>  를 사용하는 <A HREF="../../../java/util/Set.html" title="java.util 동안의 인터페이스"><CODE>Set</CODE></A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent 안의 클래스">CountDownLatch</A> </B></TD>
<TD>다른 thread로 실행중의 조작 세트가 완료할 때까지, 1 개(살) 이상의 thread를 대기 가능하게 하는 동기화 지원 기능입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CyclicBarrier.html" title="java.util.concurrent 안의 클래스">CyclicBarrier</A> </B></TD>
<TD>thread 세트의 각각이 공통의 배리어 포인트에 이를 때까지 대기하는 것을 가능하게 하는 동기화 지원 기능입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/DelayQueue.html" title="java.util.concurrent 안의 클래스">DelayQueue&lt;E extends Delayed&gt;</A> </B></TD>
<TD><tt>Delayed</tt> 요소의 안 바운드 형식<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 중의 인터페이스">블로킹 큐</a>로, 지연 시간이 경과후에게만, 요소를 취득할 수 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Exchanger.html" title="java.util.concurrent 안의 클래스">Exchanger&lt;V&gt;</A> </B></TD>
<TD>thread를 페어로 해, 페어내의 요소를 교환할 수 있는 동기 포인트. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ExecutorCompletionService.html" title="java.util.concurrent 안의 클래스">ExecutorCompletionService&lt;V&gt;</A> </B></TD>
<TD>태스크의 실행에, 지정된 <A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 동안의 클래스"><CODE>Executors</CODE></A>  를 사용하는 <A HREF="../../../java/util/concurrent/CompletionService.html" title="java.util.concurrent 동안의 인터페이스"><CODE>CompletionService</CODE></A>  입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 안의 클래스">Executors</A> </B></TD>
<TD>이 패키지로 정의된 <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 동안의 인터페이스"><CODE>Executor</CODE></A> ,<A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 안의 인터페이스"><CODE>ExecutorService</CODE></A> ,<A HREF="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent 안의 인터페이스"><CODE>ScheduledExecutorService</CODE></A> ,<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스"><CODE>ThreadFactory</CODE></A> , 및 <A HREF="../../../java/util/concurrent/Callable.html" title="java.util.concurrent 안의 인터페이스"><CODE>Callable</CODE></A>  클래스용의 팩토리 및 유틸리티 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 안의 클래스">FutureTask&lt;V&gt;</A> </B></TD>
<TD>취소해 가능한 비동기 계산입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/LinkedBlockingDeque.html" title="java.util.concurrent 안의 클래스">LinkedBlockingDeque&lt;E&gt;</A> </B></TD>
<TD>링크 노드에 근거하는, 임의의 바운드 형식<A HREF="../../../java/util/concurrent/BlockingDeque.html" title="java.util.concurrent 중의 인터페이스">블로킹 양단 큐</a>입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/LinkedBlockingQueue.html" title="java.util.concurrent 안의 클래스">LinkedBlockingQueue&lt;E&gt;</A> </B></TD>
<TD>링크 노드에 근거하는, 임의의 바운드 형식<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 중의 인터페이스">블로킹 큐</a>입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/PriorityBlockingQueue.html" title="java.util.concurrent 안의 클래스">PriorityBlockingQueue&lt;E&gt;</A> </B></TD>
<TD><A HREF="../../../java/util/PriorityQueue.html" title="java.util 안의 클래스"><CODE>PriorityQueue</CODE></A>  클래스와 같은 순서부 룰을 사용해, 블록 하는 취득 오퍼레이션을 제공하는, 안 바운드 형식<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 중의 인터페이스">블로킹 큐</a>입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent 안의 클래스">ScheduledThreadPoolExecutor</A> </B></TD>
<TD>지정된 지연 시간 후 또는 정기적으로 커멘드를 실행하도록(듯이) 추가로 스케줄 할 수 있는 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 동안의 클래스"><CODE>ThreadPoolExecutor</CODE></A>  입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Semaphore.html" title="java.util.concurrent 안의 클래스">Semaphore</A> </B></TD>
<TD>계수 세마포어-입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent 안의 클래스">SynchronousQueue&lt;E&gt;</A> </B></TD>
<TD>각 삽입 오퍼레이션이 다른 thread에 의한 대응하는 삭제 오퍼레이션을 대기할 필요가 있는 ( 및 그 역의) <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 동안의 인터페이스">블로킹 큐</A>  입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor</A> </B></TD>
<TD>풀 된 복수의 thread의 1 개를 사용해 송신된 각 태스크를 실행하는 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 동안의 인터페이스"><CODE>ExecutorService</CODE></A>  입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.AbortPolicy</A> </B></TD>
<TD><tt>RejectedExecutionException</tt> 를 throw 하는 거부된 태스크의 핸들러입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.CallerRunsPolicy</A> </B></TD>
<TD>executor 가 종료 하고 있지 않는 경우에,<tt>execute</tt> 메소드의 호출로 거부된 태스크를 직접 실행한다, 거부된 태스크의 핸들러입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.DiscardOldestPolicy</A> </B></TD>
<TD>executor 가 종료 하고 있지 않는 경우에, 가장 낡은 미처리의 요구를 파기해 <tt>execute</tt> 를 재시행한다, 거부된 태스크의 핸들러입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.DiscardPolicy</A> </B></TD>
<TD>거부된 태스크를 통지없이 파기하는 거부된 태스크의 핸들러입니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>열거형의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> </B></TD>
<TD><tt>TimeUnit</tt> 는, 지정된 입도 단위로 시간을 나타내, 단위를 변환하거나 그러한 단위로 타이밍 및 지연 조작을 실행하거나 하는 유틸리티 메소드를 제공합니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>예외의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/BrokenBarrierException.html" title="java.util.concurrent 안의 클래스">BrokenBarrierException</A> </B></TD>
<TD>thread가 고장 상태에 있는 배리어를 대기하려고 하고 있을 때, 또는 대기중에 배리어가 고장 상태가 되었을 때에, 예외를 throw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CancellationException.html" title="java.util.concurrent 안의 클래스">CancellationException</A> </B></TD>
<TD><A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 안의 클래스"><CODE>FutureTask</CODE></A>  등의 값을 생성하는 태스크의 결과를, 그 태스크가 삭제되었기 때문에 취득할 수 없는 것을 나타내는 예외입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ExecutionException.html" title="java.util.concurrent 안의 클래스">ExecutionException</A> </B></TD>
<TD>예외를 throw 하는 것에 의해 중단한 태스크의 결과를 취득하려고 했을 때에 throw 되는 예외입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/RejectedExecutionException.html" title="java.util.concurrent 안의 클래스">RejectedExecutionException</A> </B></TD>
<TD>태스크의 실행을 받아들일 수가 없을 때에 <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 동안의 인터페이스"><CODE>Executor</CODE></A>  에 의해 throw 되는 예외입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/TimeoutException.html" title="java.util.concurrent 안의 클래스">TimeoutException</A> </B></TD>
<TD>블록 조작이 타임 아웃 했을 때에 throw 되는 예외입니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A> <H2>
패키지 java.util.concurrent 의 설명
</H2>

<P>
<p> 병행 프로그래밍으로 자주(잘) 사용되는 유틸리티 클래스입니다. 이 패키지에는, 표준화 된 소규모의 확장 가능 시스템와 이용하지 않으면 구현이 귀찮음 또는 곤란하다 유용한 기능을 제공하는 클래스가 포함됩니다. 여기에서는, 주요한 컴퍼넌트에 대해 간단하게 설명합니다. <tt>locks</tt> 패키지와 <tt>atomic</tt> 패키지도 참조해 주세요.

<h2>executor</h2>

<b>인터페이스. </b> <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 안의 인터페이스"><CODE>Executor</CODE></A>  는, thread를 닮은 커스텀 하부조직 (thread 풀, 비동기 입출력, 경량 태스크 시스템등)을 정의하기 위한 , 표준화 된 단순한 인터페이스입니다. 사용하고 있는 구상 executor 클래스에 응해, 태스크는 새롭게 작성된 thread, 기존의 태스크 실행 thread, 또는 <tt>execute()</tt> 를 호출하는 thread로, 차례차례 또는 병행해 실행됩니다. <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 안의 인터페이스"><CODE>ExecutorService</CODE></A>  에서는, 보다 완전한 비동기 태스크 실행 시스템가 준비되어 있습니다. ExecutorService 는, 태스크의 큐잉과 스케줄 설정을 관리해, 제어된 종료을 가능하게 합니다. <A HREF="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent 안의 인터페이스"><CODE>ScheduledExecutorService</CODE></A>  서브 인터페이스 및 관련 인터페이스에서는, 지연 된 또는 정기적인 태스크 실행의 지원가 추가되고 있습니다. ExecutorService 에는,<A HREF="../../../java/util/concurrent/Callable.html" title="java.util.concurrent 안의 인터페이스"><CODE>Callable</CODE></A>  (<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스"><CODE>Runnable</CODE></A>  에 유사해, 결과를 생성)로서 표현되는 임의의 함수의 비동기 실행을 조정하는 메소드가 준비되어 있습니다. <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 안의 인터페이스"><CODE>Future</CODE></A>  는, 함수의 결과를 돌려주거나 실행이 완료했는지 어떠했는지의 판단을 가능하게 하거나 하는 것 외에 실행을 취소하는 방법을 제공합니다. <A HREF="../../../java/util/concurrent/RunnableFuture.html" title="java.util.concurrent 안의 인터페이스"><CODE>RunnableFuture</CODE></A>  는,<tt>run</tt> 메소드를 소유하는 Future 로, 실행시에 그 결과를 설정합니다.

<p>

<b>구현. </b> <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 안의 클래스"><CODE>ThreadPoolExecutor</CODE></A>  클래스 및 <A HREF="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent 안의 클래스"><CODE>ScheduledThreadPoolExecutor</CODE></A>  클래스는, 조정 가능해 유연성의 높은 thread 풀을 제공합니다. <A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 안의 클래스"><CODE>Executors</CODE></A>  클래스에는, 가장 일반적인 executor 의 종류와 설정을 위한 팩토리 메소드와 그러한 executor 를 사용하기 위한 유틸리티 메소드가 몇개인가 있습니다. executor 를 기본으로 한 그 외의 유틸리티에는, Future 의 일반적인 확장 가능 구현인 구상 클래스 <A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 내의 클래스"><CODE>FutureTask</CODE></A>  나, 비동기 태스크의 그룹 처리의 조정을 지원하는 <A HREF="../../../java/util/concurrent/ExecutorCompletionService.html" title="java.util.concurrent 동안의 클래스"><CODE>ExecutorCompletionService</CODE></A>  등이 있습니다.

<h2>큐</h2>

java.util.concurrent <A HREF="../../../java/util/concurrent/ConcurrentLinkedQueue.html" title="java.util.concurrent 내의 클래스"><CODE>ConcurrentLinkedQueue</CODE></A>  클래스는, 효율적으로 측정할 수 있는 thread 세이프의 비블록 FIFO 큐를 제공합니다. java.util.concurrent 로 확장 <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 내의 인터페이스"><CODE>BlockingQueue</CODE></A>  인터페이스를 지원하는 구현은 <A HREF="../../../java/util/concurrent/LinkedBlockingQueue.html" title="java.util.concurrent 안의 클래스"><CODE>LinkedBlockingQueue</CODE></A> ,<A HREF="../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent 안의 클래스"><CODE>ArrayBlockingQueue</CODE></A> ,<A HREF="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent 안의 클래스"><CODE>SynchronousQueue</CODE></A> ,<A HREF="../../../java/util/concurrent/PriorityBlockingQueue.html" title="java.util.concurrent 안의 클래스"><CODE>PriorityBlockingQueue</CODE></A> , 및 <A HREF="../../../java/util/concurrent/DelayQueue.html" title="java.util.concurrent 안의 클래스"><CODE>DelayQueue</CODE></A>  의 5 개가 있어, 이 인터페이스는 put 와 take 의 블록 버젼을 정의합니다. 다양한 클래스에서, 프로듀서 - 컨슈머(consumer), 메시징, 병렬 태스크 실행, 관련하는 병행 설계 등에 대하는 가장 일반적인 사용 문맥을 망라합니다. <A HREF="../../../java/util/concurrent/BlockingDeque.html" title="java.util.concurrent 안의 인터페이스"><CODE>BlockingDeque</CODE></A>  인터페이스는 <tt>BlockingQueue</tt> 를 확장해, FIFO 와 LIFO (스택 베이스)의 양쪽 모두의 오퍼레이션을 지원합니다. <A HREF="../../../java/util/concurrent/LinkedBlockingDeque.html" title="java.util.concurrent 안의 클래스"><CODE>LinkedBlockingDeque</CODE></A>  클래스에서는 구현을 제공합니다.


<h2>타이밍</h2>

<A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형"><CODE>TimeUnit</CODE></A>  클래스에서는, 타임 아웃 베이스의 오퍼레이션의 지정 및 제어에 대해서, 복수의 입도 (나노초단위까지)를 제공합니다. 패키지의 대부분의 클래스에는, 무기한으로 대기하는 오퍼레이션 뿐만이 아니라, 타임 아웃 베이스의 오퍼레이션이 포함되어 있습니다. 타임 아웃을 사용하는 모든 경우로, 타임 아웃치는, 메소드가 타임 아웃 한 것을 나타낼 때까지 대기하는 최소 시간을 지정합니다. 타임 아웃의 발생 다음에 올 뿐(만큼) 빨리 그것을 검출하기 위해서, 구현에서는 「최선의 노력」을 지불합니다. 다만, 검출된 타임 아웃으로부터 그 타임 아웃 후에 thread가 실제로 재실행 될 때까지는, 무기한으로 시간이 경과하는 일도 있습니다. 타임 아웃 파라미터를 받아들이는 모든 메소드로, 제로 이하의 값을 전혀 대기하지 않는 것으로서 취급합니다. 「영원히」대기하는 경우는, 값 <tt>Long.MAX_VALUE</tt> 를 사용할 수 있습니다.

<h2>싱크로나이저</h2>

자주(잘) 이용되는 특화된 동기 방법을 지원하기 위해서 4 개의 클래스가 있습니다. <A HREF="../../../java/util/concurrent/Semaphore.html" title="java.util.concurrent 안의 클래스"><CODE>Semaphore</CODE></A>  는, 종래의 동시성 처리 툴입니다. <A HREF="../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent 안의 클래스"><CODE>CountDownLatch</CODE></A>  는, 매우 단순합니다만 자주(잘) 사용되는 유틸리티로, 지정된 수의 시그널, 이벤트, 또는 조건을 보관 유지할 때까지 블록 합니다. <A HREF="../../../java/util/concurrent/CyclicBarrier.html" title="java.util.concurrent 안의 클래스"><CODE>CyclicBarrier</CODE></A>  는, 리셋 가능한 다용도의 동기 포인트이며, 일부의 형식의 병행 프로그래밍으로 유용합니다. <A HREF="../../../java/util/concurrent/Exchanger.html" title="java.util.concurrent 안의 클래스"><CODE>Exchanger</CODE></A>  에서는, 2 개의 thread가 랑데뷰 포인트로 객체를 교환하도록 할 수 있습니다. 이것은, 몇개의 파이프라인 설계로 유용합니다.

<h2>동시성 처리 컬렉션</h2>

이 패키지에서는, Queue 외에도, multi-thread 문맥으로 사용하기 위해서 설계된 Collection 구현인 <A HREF="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent 동안의 클래스"><CODE>ConcurrentHashMap</CODE></A> ,<A HREF="../../../java/util/concurrent/ConcurrentSkipListMap.html" title="java.util.concurrent 안의 클래스"><CODE>ConcurrentSkipListMap</CODE></A> ,<A HREF="../../../java/util/concurrent/ConcurrentSkipListSet.html" title="java.util.concurrent 안의 클래스"><CODE>ConcurrentSkipListSet</CODE></A> ,<A HREF="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent 안의 클래스"><CODE>CopyOnWriteArrayList</CODE></A> , 및 <A HREF="../../../java/util/concurrent/CopyOnWriteArraySet.html" title="java.util.concurrent 안의 클래스"><CODE>CopyOnWriteArraySet</CODE></A>  가 제공됩니다. 많은 thread가 특정의 컬렉션에 액세스 하는 것이 상정되는 경우는, 일반적으로, 동기 된 <tt>HashMap</tt> 보다 <tt>ConcurrentHashMap</tt>, 동기 된 <tt>TreeMap</tt> 보다 <tt>ConcurrentSkipListMap</tt> 을 사용하는 것을 추천합니다. read와 traversal의 예상수가 리스트의 갱신수보다 훨씬 많은 경우는,<tt>ArrayList</tt> 보다 <tt>CopyOnWriteArrayList</tt> 를 사용하는 것을 추천합니다.

<p>이 패키지의 일부의 클래스에 사용되는 「Concurrent」접두사는, 유사한 「synchronized」클래스와는 다른 점이 몇개인가 있는 것을 간결하게 나타내기 위한 것입니다. 예를 들어,<tt>java.util.Hashtable</tt> 와 <tt>Collections.synchronizedMap(new HashMap())</tt> 는 동기 됩니다. 그러나,<A HREF="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent 안의 클래스"><CODE>ConcurrentHashMap</CODE></A>  는, 「병행」 (concurrent)입니다. 동시성 처리 컬렉션은 thread 세이프입니다만, 단일의 배타 락에 의한 제어를 받지 않습니다. ConcurrentHashMap 의 경우는, 임의의 수의 병행 read라고 조정 가능한 수의 병행 기입을 안전하게 허가합니다. 「synchronized」클래스는, 컬렉션에의 모든 액세스를 단일 락으로 막을 필요가 있는 경우에 도움이 됩니다. 다만, 스케이라비리티는 저하합니다. 한편, 복수의 thread가 공통의 컬렉션에 액세스 하는 것이 예상되는 경우, 일반적으로은 「concurrent」버젼이 적절합니다. 컬렉션이 공유되어 있지 않은 경우, 또는 다른 락을 보관 유지하고 있을 때 마셔 컬렉션에 액세스 가능한 경우는, 동기되어 있지 않은 컬렉션을 사용하는 것을 추천합니다.

<p> 또, 대부분의 동시성 처리 Collection 구현 (대부분의 Queue 를 포함한다)은, Iterator 가 fail-fast의 traversal는 아니고 「약일관성」을 제공하는 일반적으로의 java.util 규칙과도 다릅니다. 약일관성 반복자는 thread 세이프입니다만, 반복 처리시에 컬렉션을 다운 당할 필요는 없기 때문에, 반복자의 작성 후의 갱신 내용이 모두 반영되는 일도 있으면 반영되지 않는 것도 있습니다.

<a name="MemoryVisibility">
<h2> 메모리 무결성 특성 </h2>

<a href="http://java.sun.com/docs/books/jls/third_edition/html/memory.html">Java 언어 스펙의 제 17 장</a>에서는, 공유 변수의 읽고 쓰기등의 메모리 조작에 관한 <i>happens-before</i> 관계에 대해 정의되고 있습니다. 어느 thread에 의한 기입의 결과가, 다른 thread에 의한 read로 인식되는 것이 보증되는 것은, 기입 조작이 읽어들여 조작의 「전에 발생」 (<i>happens-before</i>) 했을 경우에 한정됩니다. <code>synchronized</code> 구문과 <code>volatile</code> 구문, 및 <code>Thread.start()</code> 메소드와 <code>Thread.join()</code> 메소드는,<i>happens-before</i> 관계를 형성할 수가 있습니다. 특히 다음의 점이 중요합니다.

<ul>
<li>같은 thread의 각 액션은, 프로그램 배열로 그것보다 나중에 출현하는 액션보다 「전에 발생」합니다.

<li>모니터의 락 해제 (<code>synchronized</code> 블록 또는 메소드의 종료)는, 같은 모니터에서의 이후의 각 락 (<code>synchronized</code> 블록 또는 메소드의 엔트리)보다 「전에 발생」합니다. 또,<i>happens-before</i> 관계는 추이적이기 때문에, 락 해제전의 thread의 모든 액션은, 그 모니터를 잠그는 모든 thread에 계속되는 모든 액션보다 「전에 발생」합니다.

<li><code>volatile</code> 필드에 대한 기입은, 이후의 같은 필드에 대한 각 read보다 「전에 발생」합니다. <code>volatile</code> 필드에 대한 읽고 쓰기에도, 모니터의 엔트리/종료와 같은 메모리 무결성 효과가 있습니다만, 상호 배타 락은 수반하지 않습니다. <em></em>

<li>thread에서의 <code>start</code> 의 호출은, 개시된 thread의 모든 액션보다 「전에 발생」합니다.

<li>thread의 모든 액션은, 그 thread의 <code>join</code> 로부터 다른 thread가 정상적으로 돌아오는 것보다도 「전에 발생」합니다.

</ul>


<code>java.util.concurrent</code> 및 그 서브 패키지내에 있는 모든 클래스의 메소드는, 이러한 보증을 보다 고레벨의 동기에게까지 확장합니다. 특히 다음의 점이 중요합니다.

<ul>

<li>동시성 처리 컬렉션에 객체를 배치하기 전의 thread내의 액션은, 다른 thread에서의 그 요소에의 액세스 또는 컬렉션으로부터의 삭제에 계속되는 액션보다 「전에 발생」합니다.

<li><code>Runnable</code> 를 <code>Executor</code> 에 송신하기 전의 thread내의 액션은, 송신의 실행보다 「전에 발생」합니다. <code>ExecutorService</code> 에 송신되는 <code>Callables</code> 에 대해서도 같습니다.

<li><code>Future</code> 로 나타내지는 비동기 계산으로 발생하는 액션은, 다른 thread의 <code>Future.get()</code> 에 의한 결과의 취득에 계속되는 액션의 「전에 발생」합니다.

<li><code>Lock.unlock</code>,<code>Semaphore.release</code>,<code>CountDownLatch.countDown</code> 등의 싱크로나이저 「해제」메소드보다 전의 액션은, 다른 thread에서의 같은 싱크로나이저객체에 대한 <code>Lock.lock</code>,<code>Semaphore.acquire</code>,<code>Condition.await</code>,<code>CountDownLatch.await</code> 등의 정상 종료한 「취득」메소드에 계속되는 액션의 「전에 발생」합니다.

<li><code>Exchanger</code> 를 개입시켜 객체를 정상적으로 교환하는 thread의 각 페어에서는, 각 thread내의 <code>exchange()</code> 보다 전의 액션은, 다른 thread내의 대응하는 <code>exchange()</code> 에 계속되는 액션의 「전에 발생」합니다.

<li><code>CyclicBarrier.await</code> 를 호출하기 전의 액션은, 배리어 액션으로 실행되는 액션의 「전에 발생」해, 배리어 액션으로 실행되는 액션은, 다른 thread내의 대응하는 <code>await</code> 로부터 정상적으로 돌아온 뒤의 액션의 「전에 발생」합니다.

</ul>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/atomic/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/concurrent/package-summary.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
