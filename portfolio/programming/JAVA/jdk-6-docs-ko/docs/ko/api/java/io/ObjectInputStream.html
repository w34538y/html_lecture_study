<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:56:25 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
ObjectInputStream (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ObjectInputStream (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ObjectInputStream.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/io/ObjectInputStream.GetField.html" title="java.io 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/io/ObjectInputStream.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ObjectInputStream.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.io</FONT>
<BR>
클래스 ObjectInputStream</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">java.io.InputStream</A> 
      <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.io.ObjectInputStream</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/io/Closeable.html" title="java.io 내의 인터페이스">Closeable</A> , <A HREF="../../java/io/DataInput.html" title="java.io 안의 인터페이스">DataInput</A> , <A HREF="../../java/io/ObjectInput.html" title="java.io 안의 인터페이스">ObjectInput</A> , <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 안의 인터페이스">ObjectStreamConstants</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>ObjectInputStream</B><DT>extends <A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> <DT>implements <A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스">ObjectInput</A> , <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 안의 인터페이스">ObjectStreamConstants</A> </DL>
</PRE>

<P>
사전에 ObjectOutputStream 를 사용해 작성된 프리미티브(primitive) 데이터와 프리미티브(primitive) 객체를 직렬화 복원합니다.
 
 <p>ObjectOutputStream 와 ObjectInputStream 는, FileOutputStream 또는 FileInputStream 와 함께 사용하면, 어플리케이션에, 객체의 그래프를 위한 지속적인 스토리지를 제공할 수가 있습니다. ObjectInputStream 는, 사전에 직렬화 된 객체를 바탕으로 되돌리기 위해서(때문에) 사용합니다. 다른 사용 방법으로서는, 소켓 스트림의 사용에 의한, 호스트 사이에서의 객체의 수수나, 원격 통신 시스템에서의 속성이나 파라미터의 정렬이나 정렬 해제가 있습니다.

 <p>ObjectInputStream 는, 스트림로부터 작성된 객체 그래프에서의 모든 형태의 객체가, Java Virual Machine 에 존재하는 클래스에 확실히 매치 하도록(듯이) 합니다. 클래스는, 표준의 기구를 사용해 필요에 따라서 로드 됩니다.

 <p>스트림로부터 읽어들일 수가 있는 것은, java.io.Serializable 인터페이스나 java.io.Externalizable 인터페이스를 지원하는 객체만입니다.

 <p>객체를 스트림로부터 읽어들이려면 <code>readObject</code> 메소드를 사용합니다. 희망의 형태를 가져오려면 , Java 의 안전한 캐스트를 사용할 필요가 있습니다. Java 에서는, 캐릭터 라인과 배열은 객체로, 직렬화의 사이는 객체로서 다루어집니다. 그것들을 읽어들이려면 , 희망의 형태에 캐스트 되고 있을 필요가 있습니다.

 <p>기본 데이터형을 스트림로부터 읽어들이려면 , DataInput 의 적절한 메소드를 사용합니다.
 
 <p>객체의 디폴트의 직렬화 복원 기구는, 각 필드의 내용을, 기입해졌을 때 상태에 되돌립니다. transient 또는 static 라고 선언된 필드는, 직렬화 복원 처리에서는 무시됩니다. 다른 객체를 참조하면(자), 그러한 객체는, 필요에 따라서 스트림로부터 읽힙니다. 객체의 그래프는, 참조 공유 기구를 사용해 올바르게 복원됩니다. 직렬화 복원을 할 때는, 항상 새로운 객체를 할당할 수 있어 거기에 따라 기존의 객체에의 덧쓰기가 방지됩니다.

 <p>객체의 read는, 새로운 객체의 생성자 의 실행을 닮아 있습니다. 메모리를 객체에 할당할 수 있어 제로 (NULL)에 초기화됩니다. 직렬화 가능하지 않은 클래스에 대해서, 인수 없음의 생성자 이 불려 간 뒤, 직렬화 가능 클래스의 필드가, java.lang.Object 에 가장 가까운 클래스로부터 시작되어, 가장 객체에 고유의 클래스에서 끝나는 스트림로부터 복원됩니다.

 <p>예를 들어, ObjectOutputStream 의 예로 기입해진 스트림로부터의 read는, 다음과 같이 실시합니다.  <br>
 <pre>
        FileInputStream fis = new FileInputStream("t.tmp");
        ObjectInputStream ois = new ObjectInputStream(fis);

        int i = ois.readInt();
        String today = (String) ois.readObject();
        Date date = (Date) ois.readObject();

        ois.close();
 </pre>

 <p>클래스는, 인터페이스 java.io.Serializable 또는 java.io.Externalizable 를 구현하는 것에 의해, 클래스가 어떻게 직렬화 되는지를 제어합니다.

 <p>Serializable 인터페이스를 구현하는 것에 의해, 객체의 직렬화가, 객체 상태 전체의 보존과 복원을 실시하는 것이 가능하게 되어, 또 클래스가, 스트림의 기입시와 스트림의 read시의 사이에 전개하는 것이 가능하게 됩니다. 객체의 직렬화는, 객체간의 참조를 자동적으로 횡단(traverse) 해, 객체 그래프의 전체를 보존 및 복원합니다.

 <p>직렬화 처리와 직렬화 복원 처리 때에 특별한 조작을 필요로 하는 Serializable 클래스는, 다음의 메소드를 구현할 필요가 있습니다. <p>
 
 <pre>
private void writeObject(java.io.ObjectOutputStream stream)
throws IOException;
private void readObject(java.io.ObjectInputStream stream)
throws IOException, ClassNotFoundException; 
private void readObjectNoData() 
throws ObjectStreamException;
 </pre>

 <p>readObject 메소드는, 대응하는 writeObject 메소드에 의해 스트림에 기입해진 데이터를 사용하는 특정의 클래스에 도착해, 객체 상태를 read 및 복원할 책임을 가집니다. 이 메소드는, 그 슈퍼 클래스나 서브 클래스에 속하는 상태에 관여할 필요는 없습니다. 상태를 복원하려면 , 개개의 필드에 도착해 ObjectInputStream 로부터 데이터를 읽어들여, 객체의 적절한 필드에의 할당을 실시합니다. 기본 데이터형의 read는, DataInput 에 의해 지원됩니다.

 <p>객체 데이터를 읽어들이려고 할 경우에, 그 위치가 대응하는 writeObject 메소드에 의해 기입해진 커스텀 데이터의 경계를 넘고 있는 경우는, eof 필드의 값이 true 상태로 OptionalDataException 가 throw 됩니다. 객체를 직렬화해 읽어들이려고 할 경우에, 그 위치가 할당하고가 끝난 데이터의 마지막을 넘고 있는 경우는, 스트림의 경우와 같게, 데이터의 마지막을 나타내는 예외가 돌려주어집니다. 즉, 바이트 단위의 read에서는, 바이트가 읽혔을 때에 -1 가 돌려주어집니다. 프리미티브(primitive) read에서는, EOFException 가 throw 됩니다. 대응하는 writeObject 메소드가 없는 경우는, 디폴트의 직렬화 데이터의 마지막이 할당하고가 끝난 데이터가 끝나게 됩니다.

 <p>프리미티브(primitive) read와 객체 read가 readExternal 메소드로부터 불려 갔을 경우는, 양쪽 모두 똑같이 동작합니다. 스트림의 위치가 대응하는 writeExternal 메소드에 의해 기입해진 데이터의 마지막에 있는 경우, 객체 read에서는 eof 가 true 로 설정된 상태로 OptionalDataException 가 throw 되어 프리미티브(primitive) read에서는 EOFException 가 throw 됩니다. 다만, 낡은 <code>ObjectStreamConstants.PROTOCOL_VERSION_1</code> 프로토콜을 사용해 기입해진 스트림에서는, 이 동작은 적용되지 않습니다. writeExternal 메소드와 달리, 데이터의 마지막이 기입해지지 않기 때문에, 데이터의 마지막을 검출할 수 없기 때문입니다.

 <p>readObjectNoData 메소드는, 어느 클래스가 직렬화 복원되는 객체의 슈퍼 클래스로서 직렬화 스트림로 지정되어 있지 않을 때에, 그 클래스에 도착해 그 객체 상태를 초기화합니다. 이것은, 수취하는 측이, 보내 옆과는 다른 버젼의 직렬화 복원된 인스턴스의 클래스를 사용해, 수취하는 측의 버젼이 보내 옆의 버젼에 의해 상속되지 않는 클래스를 상속하는 경우에 발생할 가능성이 있습니다. 또, 직렬화 스트림이 개편되었을 경우에도 발생하는 일이 있습니다. 따라서, readObjectNoData 는, 「악의가 있다」또는 부정한 소스 스트림이어도, 직렬화 복원된 객체를 올바르게 초기화하는데 도움이 됩니다.
 
 <p>직렬화는, java.io.Serializable 인터페이스를 구현하지 않는 객체의 필드의 read나, 그러한 필드에의 값의 할당은 실시하지 않습니다. 직렬화 가능하지 않은 객체의 서브 클래스를 직렬화 가능하게 하는 것은 가능합니다. 이 경우, 직렬화 가능하지 않은 클래스는, 그 필드를 초기화할 수 있도록(듯이) 하기 위한(해), 인수 없음의 생성자 을 가질 필요가 있습니다. 이 경우, 직렬화 가능하지 않은 클래스 상태를 보존 및 복원하는 것은, 서브 클래스의 책임이 됩니다. 그 클래스의 필드가 액세스 가능한 (public, package, 또는 protected) 경우, 혹은 상태의 복원에 이용할 수 있는 set 메소드나 get 메소드가 있는 경우가 자주 있습니다.

 <p>객체를 직렬화 복원하는 동안에 발생한 모든 예외는, ObjectInputStream 에 캐치 되어 read 처리를 이상종료(ABEND) 시킵니다.

 <p>Externalizable 인터페이스를 구현하면(자), 객체의 직렬화 된 형식의 내용 및 형식을 객체측이 완전하게 제어하는 것이 가능하게 됩니다. Externalizable 인터페이스의 메소드인 writeExternal 와 readExternal 는, 객체 상태를 보존 및 복원하기 위해서(때문에) 불려 갑니다. 이러한 메소드는, 클래스에 의해 구현되었을 경우에는, ObjectOutput 와 ObjectInput 의 모든 메소드를 사용해, 자신 상태의 기입 및 read를 실시할 수가 있습니다. 어떠한 버젼이어도 처리할 수 있도록(듯이) 하는 것은, 객체의 책임입니다.

 <p>enum 정수의 직렬화 복원은, 일반적으로의 직렬화 가능 또는 외부화 가능 객체와는 다릅니다. enum 정수의 직렬화 된 형식을 구성하는 것은, 그 이름 뿐입니다. 정수의 필드치는 전송 되지 않습니다. enum 정수를 직렬화 복원하려면 , ObjectInputStream 로 스트림로부터 정수명을 읽어들입니다. 다음에, enum 정수의 기저형이라고 받은 정수명을 인수로서 static 메소드의 <code>Enum.valueOf(Class, String)</code> 를 호출해, 직렬화 복원된 정수를 가져옵니다. 다른 직렬화 가능 또는 외부화 가능 객체 같이 enum 정수는, 이후 직렬화 스트림에 출현하는 후방 참조의 대상으로 해 기능할 수 있습니다. enum 정수를 직렬화 복원하는 프로세스를 커스터마이즈 할 수 없습니다. enum 형으로 정의된, 클래스 고유의 readObject, readObjectNoData, 및 readResolve 메소드는 모두 직렬화 복원동안은 무시됩니다. 같이 serialPersistentFields 또는 serialVersionUID 필드 선언도 모두 무시됩니다. 모든 enum 형은 0L 로 고정된 serialVersionUID 를 가집니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스"><CODE>DataInput</CODE></A> , 
<A HREF="../../java/io/ObjectOutputStream.html" title="java.io 안의 클래스"><CODE>ObjectOutputStream</CODE></A> , 
<A HREF="../../java/io/Serializable.html" title="java.io 안의 인터페이스"><CODE>Serializable</CODE></A> , 
<a href="../../../platform/serialization/spec/input.html"> 「객체 직렬화 스펙」의 제 3 장 「객체 입력 클래스」</a> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.GetField.html" title="java.io 안의 클래스">ObjectInputStream.GetField</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;입력 스트림로부터 읽힌 지속 필드에의 액세스를 제공합니다. </TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.io.ObjectStreamConstants"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.io. <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 안의 인터페이스">ObjectStreamConstants</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/io/ObjectStreamConstants.html#baseWireHandle">baseWireHandle</A> , <A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_1">PROTOCOL_VERSION_1</A> , <A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_2">PROTOCOL_VERSION_2</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SC_BLOCK_DATA">SC_BLOCK_DATA</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SC_ENUM">SC_ENUM</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SC_EXTERNALIZABLE">SC_EXTERNALIZABLE</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SC_SERIALIZABLE">SC_SERIALIZABLE</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SC_WRITE_METHOD">SC_WRITE_METHOD</A> , <A HREF="../../java/io/ObjectStreamConstants.html#STREAM_MAGIC">STREAM_MAGIC</A> , <A HREF="../../java/io/ObjectStreamConstants.html#STREAM_VERSION">STREAM_VERSION</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SUBCLASS_IMPLEMENTATION_PERMISSION">SUBCLASS_IMPLEMENTATION_PERMISSION</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SUBSTITUTION_PERMISSION">SUBSTITUTION_PERMISSION</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_ARRAY">TC_ARRAY</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_BASE">TC_BASE</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_BLOCKDATA">TC_BLOCKDATA</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_BLOCKDATALONG">TC_BLOCKDATALONG</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_CLASS">TC_CLASS</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_CLASSDESC">TC_CLASSDESC</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_ENDBLOCKDATA">TC_ENDBLOCKDATA</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_ENUM">TC_ENUM</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_EXCEPTION">TC_EXCEPTION</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_LONGSTRING">TC_LONGSTRING</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_MAX">TC_MAX</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_NULL">TC_NULL</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_OBJECT">TC_OBJECT</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_PROXYCLASSDESC">TC_PROXYCLASSDESC</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_REFERENCE">TC_REFERENCE</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_RESET">TC_RESET</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_STRING">TC_STRING</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream()">ObjectInputStream</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectInputStream 를 완전하게 재구현하는 서브 클래스가, ObjectInputStream 의 이 구현에 의해 사용된지 얼마 안된 private 데이터를 할당할 필요가 없게 하는 수단을 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream(java.io.InputStream)">ObjectInputStream</A> </B>(<A HREF="../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 InputStream 로부터 읽어들이는 ObjectInputStream 를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#available()">available</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;블록 하지 않고 읽어들일 수가 있는 바이트수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#close()">close</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;입력 스트림을 닫습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#defaultReadObject()">defaultReadObject</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클래스의 비 static 및 비 transient 필드를, 이 스트림로부터 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#enableResolveObject(boolean)">enableResolveObject</A> </B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림로부터 읽힌 객체를 치환할 수 있도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#read()">read</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터의 바이트를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#read(byte[], int, int)">read</A> </B>(byte[]&nbsp;buf,
     int&nbsp;off,
     int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트 배열에 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readBoolean()">readBoolean</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean 를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readByte()">readByte</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 비트의 바이트를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readChar()">readChar</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 비트의 char 를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/io/ObjectStreamClass.html" title="java.io 내의 클래스">ObjectStreamClass</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readClassDescriptor()">readClassDescriptor</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;직렬화 스트림로부터 클래스 기술자를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readDouble()">readDouble</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;64 비트의 double 를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/ObjectInputStream.GetField.html" title="java.io 내의 클래스">ObjectInputStream.GetField</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readFields()">readFields</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림로부터 지속 필드를 읽어들여, 그것들을 이름을 지정해 액세스 할 수 있도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readFloat()">readFloat</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 비트의 float 를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readFully(byte[])">readFully</A> </B>(byte[]&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readFully(byte[], int, int)">readFully</A> </B>(byte[]&nbsp;buf,
          int&nbsp;off,
          int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readInt()">readInt</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 비트의 int 를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readLine()">readLine</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 메소드에서는, 바이트로부터 문자에의 변환이 올바르게 행해지지 않습니다.
                상세 및 대체 메소드에 대해서는 DataInputStream 를 참조해 주세요. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readLong()">readLong</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;64 비트의 long 를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readObject()">readObject</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectInputStream 로부터 객체를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readObjectOverride()">readObjectOverride</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메소드는, 인수 없음의 protected 생성자 을 사용해, ObjectOutputStream 를 구축한 ObjectOutputStream 의 신뢰할 수 있는 서브 클래스에 의해 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;short</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readShort()">readShort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 비트의 short 를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readStreamHeader()">readStreamHeader</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스가 자신의 스트림 헤더의 read와 검증을 실시할 수 있도록(듯이) 하기 위해서 제공되고 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readUnshared()">readUnshared</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectInputStream 로부터 「공유되지 않는다」객체를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readUnsignedByte()">readUnsignedByte</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;부호 없음 8 비트 바이트를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readUnsignedShort()">readUnsignedShort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;부호 없음 16 비트의 short 를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readUTF()">readUTF</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="DataInput.html#modified-utf-8">수정 UTF-8</a>  형식의 캐릭터 라인을 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#registerValidation(java.io.ObjectInputValidation, int)">registerValidation</A> </B>(<A HREF="../../java/io/ObjectInputValidation.html" title="java.io 안의 인터페이스">ObjectInputValidation</A> &nbsp;obj,
                   int&nbsp;prio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;객체 그래프가 돌려주어지기 전에 검증되어야 할 객체를 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#resolveClass(java.io.ObjectStreamClass)">resolveClass</A> </B>(<A HREF="../../java/io/ObjectStreamClass.html" title="java.io 안의 클래스">ObjectStreamClass</A> &nbsp;desc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 스트림 클래스의 기술에 대응하는 로컬 클래스를 로드합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#resolveObject(java.lang.Object)">resolveObject</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메소드는, 직렬화 복원 시에, ObjectInputStream 의 신뢰할 수 있는 서브 클래스가, 어느 객체를 다른 객체에 치환할 수 있도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#resolveProxyClass(java.lang.String[])">resolveProxyClass</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;interfaces)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;프록시 클래스 기술자로 지정된 인터페이스를 구현하는 프록시 클래스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#skipBytes(int)">skipBytes</A> </B>(int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트를 스킵 합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.io.InputStream"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.io. <A HREF="../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/io/InputStream.html#mark(int)">mark</A> , <A HREF="../../java/io/InputStream.html#markSupported()">markSupported</A> , <A HREF="../../java/io/InputStream.html#read(byte[])">read</A> , <A HREF="../../java/io/InputStream.html#reset()">reset</A> , <A HREF="../../java/io/InputStream.html#skip(long)">skip</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.io.ObjectInput"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.io. <A HREF="../../java/io/ObjectInput.html" title="java.io 안의 인터페이스">ObjectInput</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/io/ObjectInput.html#read(byte[])">read</A> , <A HREF="../../java/io/ObjectInput.html#skip(long)">skip</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ObjectInputStream(java.io.InputStream)"><!-- --></A> <H3>
ObjectInputStream</H3>
<PRE>
public <B>ObjectInputStream</B>(<A HREF="../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;in)
                  throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>지정된 InputStream 로부터 읽어들이는 ObjectInputStream 를 작성합니다. 직렬화 스트림 헤더는, 스트림로부터 읽힌 뒤, 검증됩니다. 이 생성자 은, 대응하는 ObjectOutputStream 가 헤더를 기입해 플래시 할 때까지 블록 합니다.

 <p>시큐리티 매니저가 인스톨 되고 있는 경우, ObjectInputStream.readFields 메소드 또는 ObjectInputStream.readUnshared 메소드를 오버라이드(override) 하는 서브 클래스의 생성자 에 의해 SerializablePermission("enableSubclassImplementation")가 직접 또는 간접에 불려 갔을 때에, 이 생성자 은 이 액세스권을 확인합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>in</CODE> - read원의 입력 스트림
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/StreamCorruptedException.html" title="java.io 안의 클래스">StreamCorruptedException</A> </CODE> - 스트림 헤더가 부정한 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 스트림 헤더의 read중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 신뢰되어 있지 않은 서브 클래스가, 시큐리티상 중요한 메소드를 부정하게 오버라이드(override) 했을 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>in</code> 가 <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream()"><CODE>ObjectInputStream()</CODE></A> , 
<A HREF="../../java/io/ObjectInputStream.html#readFields()"><CODE>readFields()</CODE></A> , 
<A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream(java.io.OutputStream)"><CODE>ObjectOutputStream.ObjectOutputStream(OutputStream)</CODE></A> </DL>
</DL>
<HR>

<A NAME="ObjectInputStream()"><!-- --></A> <H3>
ObjectInputStream</H3>
<PRE>
protected <B>ObjectInputStream</B>()
                     throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                            <A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </PRE>
<DL>
<DD>ObjectInputStream 를 완전하게 재구현하는 서브 클래스가, ObjectInputStream 의 이 구현에 의해 사용된지 얼마 안된 private 데이터를 할당할 필요가 없게 하는 수단을 제공합니다.

 <p>시큐리티 매니저가 인스톨 되고 있는 경우, 이 메소드는 우선 시큐리티 매니저의 <code>checkPermission</code> 메소드를 액세스권 <code>SerializablePermission("enableSubclassImplementation")</code> 로 호출해, 서브 클래스화를 유효하게 할 수 있도록(듯이) 합니다.
<P>
<DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <code>checkPermission</code> 메소드가 서브 클래스화를 유효하게 하는 것을 거부했을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> , 
<A HREF="../../java/io/SerializablePermission.html" title="java.io 안의 클래스"><CODE>SerializablePermission</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="readObject()"><!-- --></A> <H3>
readObject</H3>
<PRE>
public final <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>readObject</B>()
                        throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                               <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>ObjectInputStream 로부터 객체를 읽어들입니다. 객체의 클래스, 클래스의 시그니챠, 클래스의 비 transient 필드 및 비 static 필드의 값과 그 모든 슈퍼타입이 읽힙니다. 어느 클래스에 대한 디폴트의 직렬화 복원은, writeObject 메소드와 readObject 메소드를 사용해 오버라이드(override) 할 수가 있습니다. 이 객체에 의해 참조되는 객체는 중간적으로 읽혀 거기에 따라, 완전하게 동등한 객체 그래프가 readObject 에 의해 재구축 됩니다.

 <p>루트 객체는, 참조하는 필드와 객체의 모든 것이 복원되었을 때, 완전하게 복원됩니다. 이 시점에서, 그러한 등록된 우선 순위에 근거해, 객체 검증 콜백이 실행됩니다. 이 콜백은, (특별한 readObject 메소드의) 객체에 의해, 그것들이 개별적으로 복원될 때 등록됩니다.

 <p>예외는, InputStream 에 관한 문제나, 직렬화 복원해서는 안되는 클래스에 도착해 throw 됩니다. 모든 예외는, InputStream 에 있어 치명적이어, InputStream 를 불확정 상태로 합니다. 스트림 상태를 무시할까 회복 처리할까를 결정하는 것은 호출측입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스">ObjectInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectInput.html#readObject()">readObject</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>스트림로부터 읽힌 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 직렬화 된 객체의 클래스가 발견되지 않았던 경우
<DD><CODE><A HREF="../../java/io/InvalidClassException.html" title="java.io 안의 클래스">InvalidClassException</A> </CODE> - 직렬화로 사용되는 클래스에 하등의 불편이 있었을 경우
<DD><CODE><A HREF="../../java/io/StreamCorruptedException.html" title="java.io 안의 클래스">StreamCorruptedException</A> </CODE> - 스트림의 제어 정보에 일관성이 없는 경우
<DD><CODE><A HREF="../../java/io/OptionalDataException.html" title="java.io 안의 클래스">OptionalDataException</A> </CODE> - 프리미티브(primitive) 데이터가, 객체는 아니고 스트림에 발견되었을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력에 관련한 예외중 한쪽이 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readObjectOverride()"><!-- --></A> <H3>
readObjectOverride</H3>
<PRE>
protected <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>readObjectOverride</B>()
                             throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                                    <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>이 메소드는, 인수 없음의 protected 생성자 을 사용해, ObjectOutputStream 를 구축한 ObjectOutputStream 의 신뢰할 수 있는 서브 클래스에 의해 불려 갑니다. 서브 클래스는, 수식자가 final 의 오버라이드(override) 메소드를 제공한다고 보입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>스트림로부터 읽힌 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 직렬화 된 객체의 클래스가 발견되지 않았던 경우
<DD><CODE><A HREF="../../java/io/OptionalDataException.html" title="java.io 안의 클래스">OptionalDataException</A> </CODE> - 프리미티브(primitive) 데이터가, 객체는 아니고 스트림에 발견되었을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 read중에 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream()"><CODE>ObjectInputStream()</CODE></A> , 
<A HREF="../../java/io/ObjectInputStream.html#readObject()"><CODE>readObject()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="readUnshared()"><!-- --></A> <H3>
readUnshared</H3>
<PRE>
public <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>readUnshared</B>()
                    throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                           <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>ObjectInputStream 로부터 「공유되지 않는다」객체를 읽어들입니다. 이 메소드는, readObject 와 닮아 있습니다. 다만, 직후에 readObject 및 readUnshared 를 호출해, 이 호출이 취득한 직렬화 복원된 인스턴스에 대한 추가의 참조를 돌려줄 수 없습니다. 구체적으로는, 다음과 같이 됩니다.
 <ul>
<li>readUnshared 를 호출해 역참조 (스트림에 기입해진 객체의 스트림 표현)를 직렬화 복원하려고 하면(자), ObjectStreamException 가 throw 된다

<li>readUnshared 가 정상적으로 복귀한 후에, readUnshared 가 직렬화 복원한 스트림 핸들에의 역참조를 직렬화 복원하려고 하면(자), ObjectStreamException 가 throw 된다
 </ul>
readUnshared 를 호출해 객체를 직렬화 복원하면(자), 반환되는 객체에 관련지을 수 있었던 스트림 핸들이 무효가 됩니다. 다만, readUnshared 로부터 반환되는 참조가 일의이다고는 할 수 없습니다. 직렬화 복원된 객체가 readResolve 메소드를 정의해, 다른 조직이 볼 수가 있는 객체를 돌려주는 일이 있습니다. 또, readUnshared 가 스트림내외의 장소나 외부로부터 취득할 수 있는 Class 객체 또는 enum 정수를 돌려주는 일도 있습니다. 직렬화 복원된 객체가 readResolve 메소드를 정의해, 이 메소드의 호출에 의해 배열이 반환되는 경우, readUnshared 는 그 배열의 샤로 복제를 돌려줍니다. 이것에 의해, 기본이 되는 데이터 스트림이 처리되고 있는 경우에서도, 반환되는 배열 객체가 일의이며, ObjectInputStream 에 대한 readObject 또는 readUnshared 의 호출로부터 2 번째에는 취득할 수 없게 됩니다.

 <p>이 메소드를 오버라이드(override) 하는 ObjectInputStream 서브 클래스는, SerializablePermission("enableSubclassImplementation")를 가지는 시큐리티 문맥내에서만 구축할 수 있습니다. 이 액세스권을 가지지 않는 시큐리티 문맥으로 인스턴스화하려고 하면(자), SecurityException 가 throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>직렬화 복원 객체에의 참조
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 직렬화 복원하는 객체의 클래스가 발견되지 않았던 경우
<DD><CODE><A HREF="../../java/io/StreamCorruptedException.html" title="java.io 안의 클래스">StreamCorruptedException</A> </CODE> - 스트림의 제어 정보에 일관성이 없는 경우
<DD><CODE><A HREF="../../java/io/ObjectStreamException.html" title="java.io 안의 클래스">ObjectStreamException</A> </CODE> - 직렬화 복원하는 객체가 벌써 스트림내에 있었을 경우
<DD><CODE><A HREF="../../java/io/OptionalDataException.html" title="java.io 안의 클래스">OptionalDataException</A> </CODE> - 스트림내의 다음의 데이터가 프리미티브(primitive)의 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 직렬화 복원중에 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="defaultReadObject()"><!-- --></A> <H3>
defaultReadObject</H3>
<PRE>
public void <B>defaultReadObject</B>()
                       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                              <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>현재의 클래스의 비 static 및 비 transient 필드를, 이 스트림로부터 읽어들입니다. 이 메소드를 호출할 수가 있는 것은, 직렬화 복원되고 있는 클래스의 readObject 메소드 뿐입니다. 다른 방법으로 불려 갔을 경우는 NotActiveException 를 throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 직렬화 된 객체의 클래스가 발견되지 않았던 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/io/NotActiveException.html" title="java.io 안의 클래스">NotActiveException</A> </CODE> - 스트림이 현재 객체를 읽어들이지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readFields()"><!-- --></A> <H3>
readFields</H3>
<PRE>
public <A HREF="../../java/io/ObjectInputStream.GetField.html" title="java.io 내의 클래스">ObjectInputStream.GetField</A>  <B>readFields</B>()
                                      throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                                             <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>스트림로부터 지속 필드를 읽어들여, 그것들을 이름을 지정해 액세스 할 수 있도록(듯이) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>직렬화 복원되고 있는 객체의 지속 필드를 나타내는 <code>GetField</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 직렬화 된 객체의 클래스가 발견되지 않았던 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/io/NotActiveException.html" title="java.io 안의 클래스">NotActiveException</A> </CODE> - 스트림이 현재 객체를 읽어들이지 않은 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="registerValidation(java.io.ObjectInputValidation, int)"><!-- --></A> <H3>
registerValidation</H3>
<PRE>
public void <B>registerValidation</B>(<A HREF="../../java/io/ObjectInputValidation.html" title="java.io 안의 인터페이스">ObjectInputValidation</A> &nbsp;obj,
                               int&nbsp;prio)
                        throws <A HREF="../../java/io/NotActiveException.html" title="java.io 내의 클래스">NotActiveException</A> ,
                               <A HREF="../../java/io/InvalidObjectException.html" title="java.io 안의 클래스">InvalidObjectException</A> </PRE>
<DL>
<DD>객체 그래프가 돌려주어지기 전에 검증되어야 할 객체를 등록합니다. resolveObject 를 닮아 있습니다만, 이러한 검증은 객체 그래프 전체가 재구축 된 뒤에 불려 가는 점이 다릅니다. 일반적으로, readObject 메소드는, 스트림과 함께 객체를 등록해, 거기에 따라 객체의 모든 것이 복원되었을 때에 최종적인 검증을 실행할 수 있도록(듯이) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 검증의 콜백을 받는 객체<DD><CODE>prio</CODE> - 콜백의 순서를 제어하는 값. 0 이 적절한 디폴트 값이다.
                빨리 콜백 하는 경우는 큰 번호를, 나중에 콜백 하는 경우는 작은 번호를 사용한다. 같은 우선 순위내에서는, 콜백의 처리에 특별한 순서는 없다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/NotActiveException.html" title="java.io 안의 클래스">NotActiveException</A> </CODE> - 스트림이 현재 객체를 읽어들이지 않기 때문에, 콜백을 등록할 수 없는 경우
<DD><CODE><A HREF="../../java/io/InvalidObjectException.html" title="java.io 안의 클래스">InvalidObjectException</A> </CODE> - 검증 객체가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="resolveClass(java.io.ObjectStreamClass)"><!-- --></A> <H3>
resolveClass</H3>
<PRE>
protected <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>resolveClass</B>(<A HREF="../../java/io/ObjectStreamClass.html" title="java.io 안의 클래스">ObjectStreamClass</A> &nbsp;desc)
                         throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                                <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>지정된 스트림 클래스의 기술에 대응하는 로컬 클래스를 로드합니다. 서브 클래스는, 이 메소드를 구현해, 클래스를 대체 소스로부터 취득할 수 있도록(듯이) 할 수가 있습니다.  

 <p><code>ObjectOutputStream</code> 내에서 대응하는 메소드는 <code>annotateClass</code> 입니다. 이 메소드는, 스트림의 일의의 클래스 각각 붙어 1 회만 불려 갑니다. 이 메소드는, 대체의 로드 기구를 사용하기 위해서 서브 클래스에 의해 구현할 수가 있습니다만,<code>Class</code> 객체를 돌려줄 필요가 있습니다. 클래스 객체가 돌려주어지면(자), 그 클래스가 배열 클래스가 아닌 경우는, 클래스의 serialVersionUID 가, 직렬화 된 클래스의 serialVersionUID 라고 비교됩니다. 불일치가 있으면(자), 직렬화 복원에 불편이 발생해,<A HREF="../../java/io/InvalidClassException.html" title="java.io 안의 클래스"><CODE>InvalidClassException</CODE></A>  가 throw 됩니다.

 <p><code>ObjectInputStream</code> 내의 이 메소드의 디폴트 구현은, 다음의 호출의 결과를 돌려줍니다.
 <pre>
Class.forName(desc.getName(), false, loader)
 </pre>
<code>loader</code> 는, 다음과 같이 결정됩니다. 메소드의 선언 클래스가 사용자 정의의 클래스 로더에 의해 정의되고 있어, 리플렉트에 의한 호출의 구현을 목적으로 생성되어 있지 않은 경우, 그 메소드가 현재의 thread의 스택상에 존재하면(자),<code>loader</code> 는 현재 실행중의 프레임에 가장 가까운 메소드에 대응하는 클래스 로더가 됩니다. 그렇지 않은 경우,<code>loader</code> 는 <code>null</code> 입니다. 이 호출의 결과가 <code>ClassNotFoundException</code> 로, 건네받은 <code>ObjectStreamClass</code> 인스턴스의 이름이 원시형 또는 void 에 대한 Java 언어의 키워드인 경우는, 그 원시형 또는 void 를 나타내는 <code>Class</code> 객체가 돌려주어집니다. 예를 들어,<code>"int"</code> 라는 이름의 <code>ObjectStreamClass</code> 는 <code>Integer.TYPE</code> 에 해결됩니다. 그렇지 않은 경우는, 이 메소드의 호출 측에 <code>ClassNotFoundException</code> 가 throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>desc</CODE> - <code>ObjectStreamClass</code> 클래스의 인스턴스
<DT><B>반환값:</B><DD><code>desc</code> 에 대응하는 <code>Class</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 일반적으로의 입출력 관련의 예외가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 직렬화 된 객체의 클래스가 발견되지 않았던 경우</DL>
</DD>
</DL>
<HR>

<A NAME="resolveProxyClass(java.lang.String[])"><!-- --></A> <H3>
resolveProxyClass</H3>
<PRE>
protected <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>resolveProxyClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;interfaces)
                              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                                     <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>프록시 클래스 기술자로 지정된 인터페이스를 구현하는 프록시 클래스를 돌려줍니다. 서브 클래스는 이 메소드를 구현해 다이나믹 프록시 클래스의 기술자와 함께 스트림로부터 커스텀 데이터를 읽어들여, 인터페이스나 프록시 클래스의 대체의 로드 기구를 사용할 수 있도록(듯이) 합니다.

 <p>이 메소드는 스트림의 일의의 각 프록시 클래스 기술자에 대해 1 회만 불려 갑니다.

 <p><code>ObjectOutputStream</code> 내에서 대응하는 메소드는 <code>annotateProxyClass</code> 입니다. 이 메소드를 오버라이드(override) 하는 <code>ObjectInputStream</code> 의 지정된 서브 클래스에 대해서는,<code>ObjectOutputStream</code> 내의 대응하는 서브 클래스의 <code>annotateProxyClass</code> 메소드가, 이 메소드가 읽어들이는 데이터 또는 객체를 모두 기입할 필요가 있습니다.

 <p><code>ObjectInputStream</code> 내의 이 메소드의 디폴트 구현은,<code>interfaces</code> 파라미터로 지정된 인터페이스에 대한 <code>Class</code> 객체의 리스트를 사용해 <code>Proxy.getProxyClass</code> 를 호출한 결과를 돌려줍니다. 각 인터페이스명 <code>i</code> 에 대한 <code>Class</code> 객체는, 다음의 호출에 의해 반환된 값입니다.
 <pre>
Class.forName(i, false, loader)
 </pre>
<code>loader</code> 는, 실행 스택에 포함되는 <code>null</code> 가 아닌 최초의 클래스 로더입니다. 다만,<code>null</code> 가 아닌 클래스 로더가 스택상에 없는 경우는,<code>null</code> 입니다. 이 클래스 로더의 선택은,<code>resolveClass</code> 메소드로 사용되는 것 것과 같습니다. 해결된 인터페이스의 모든 것이 public 인 경우는, 이 <code>loader</code> 와 같은 값이 <code>Proxy.getProxyClass</code> 에게 건네지는 클래스 로더로도 됩니다. 한편, public 가 아닌 인터페이스가 존재하는 경우는, 대신에 그러한 인터페이스의 클래스 로더가 건네받습니다. public 가 아닌 인터페이스 클래스 로더가 복수 검출되었을 경우는,<code>IllegalAccessError</code> 가 throw 됩니다. <code>Proxy.getProxyClass</code> 가 <code>IllegalArgumentException</code> 를 throw 했을 경우,<code>resolveProxyClass</code> 는 <code>IllegalArgumentException</code> 를 포함한 <code>ClassNotFoundException</code> 를 throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>interfaces</CODE> - 프록시 클래스 기술자에게 직렬화 복원된 인터페이스명의 리스트
<DT><B>반환값:</B><DD>지정된 인터페이스의 프록시 클래스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>InputStream</code> 에 예외가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 프록시 클래스 또는 지정된 인터페이스가 모두 발견되지 않았던 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectOutputStream.html#annotateProxyClass(java.lang.Class)"><CODE>ObjectOutputStream.annotateProxyClass(Class)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="resolveObject(java.lang.Object)"><!-- --></A> <H3>
resolveObject</H3>
<PRE>
protected <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>resolveObject</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)
                        throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 메소드는, 직렬화 복원 시에, ObjectInputStream 의 신뢰할 수 있는 서브 클래스가, 어느 객체를 다른 객체에 치환할 수 있도록(듯이) 합니다. 객체의 치환은, enableResolveObject 가 불려 갈 때까지는 실시할 수 없습니다. enableResolveObject 메소드는, 객체의 해결을 요구하고 있는 스트림을 신뢰할 수 있을지 어떨지를 조사합니다. 직렬화 가능 객체에의 모든 참조는, resolveObject 에게 건네집니다. 객체의 private 상태가 의도하지 않고 공개되는 것이 없게, resolveObject 를 사용하는 것은 신뢰할 수 있는 스트림로 한정됩니다.

 <p>이 메소드는, 객체가 읽힌 뒤, readObject 로부터 복귀하기 전에 불려 갑니다. 디폴트의 resolveObject 메소드는, 같은 객체를 돌려줍니다.

 <p>서브 클래스는, 객체를 치환할 때, 치환된 객체와 참조가 포함되는 각 필드와의 호환성을 유지하도록(듯이) 할 필요가 있습니다. 필드 또는 배열 요소의 형태의 서브 클래스가 아닌 형태의 객체는, 예외를 발생시키는 것에 의해 직렬화를 중단해, 그 결과 객체는 포함되지 않습니다.

 <p>이 메소드는, 각 객체가 최초로 검출되었을 때에 1 회만 불려 갑니다. 이것 이후 검출되는 그 객체에의 참조는, 새로운 객체에 리다이렉트(redirect) 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 치환되는 객체
<DT><B>반환값:</B><DD>치환된 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 일반적으로의 입출력 관련의 예외가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="enableResolveObject(boolean)"><!-- --></A> <H3>
enableResolveObject</H3>
<PRE>
protected boolean <B>enableResolveObject</B>(boolean&nbsp;enable)
                               throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 내의 클래스">SecurityException</A> </PRE>
<DL>
<DD>스트림로부터 읽힌 객체를 치환할 수 있도록(듯이) 합니다. 치환이 가능하게 되면(자), resolveObject 메소드가, 직렬화 복원되는 각 객체에 대해 불려 갑니다.

 <p><i>enable</i> 가 true 로, 시큐리티 매니저가 인스톨 되고 있는 경우, 이 메소드는 우선 시큐리티 매니저의 <code>checkPermission</code> 메소드를 액세스권 <code>SerializablePermission("enableSubstitution")</code> 로 호출해, 스트림로부터 읽힌 객체의 치환을 스트림을 허가할 수 있도록(듯이) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>enable</CODE> - 직렬화 복원되는 각 객체에 대해 <code>resolveObject</code> 의 사용을 유효하게 하는 경우는 true
<DT><B>반환값:</B><DD>이 메소드가 불려 가기 전의 설정
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <code>checkPermission</code> 메소드가, 스트림로부터 읽힌 객체의 치환을 스트림을 허가할 수 있도록(듯이) 하는 것을 거부하는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> , 
<A HREF="../../java/io/SerializablePermission.html" title="java.io 안의 클래스"><CODE>SerializablePermission</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="readStreamHeader()"><!-- --></A> <H3>
readStreamHeader</H3>
<PRE>
protected void <B>readStreamHeader</B>()
                         throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                                <A HREF="../../java/io/StreamCorruptedException.html" title="java.io 안의 클래스">StreamCorruptedException</A> </PRE>
<DL>
<DD>서브 클래스가 자신의 스트림 헤더의 read와 검증을 실시할 수 있도록(듯이) 하기 위해서 제공되고 있습니다. 이 메소드는, 매직 번호와 버젼 번호를 읽어들입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>InputStream</code> 의 read중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/io/StreamCorruptedException.html" title="java.io 안의 클래스">StreamCorruptedException</A> </CODE> - 스트림의 제어 정보에 일관성이 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readClassDescriptor()"><!-- --></A> <H3>
readClassDescriptor</H3>
<PRE>
protected <A HREF="../../java/io/ObjectStreamClass.html" title="java.io 내의 클래스">ObjectStreamClass</A>  <B>readClassDescriptor</B>()
                                         throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                                                <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>직렬화 스트림로부터 클래스 기술자를 읽어들입니다. 이 메소드는, ObjectInputStream 가 직렬화 스트림의 다음의 아이템으로서 클래스 기술자를 요구하면(자) 불려 갑니다. <code>writeClassDescriptor</code> 메소드를 오버라이드(override) 한 ObjectOutputStream 의 서브 클래스에 의해 표준이 아닌 형식에서 기입해진 클래스 기술자에게 읽어들이기 위해서(때문에), ObjectInputStream 의 서브 클래스가 이 메소드를 오버라이드(override) 합니다. 디폴트에서는, 이 메소드는 클래스 기술자를 객체 직렬화 스펙에 정의된 형식에서 읽어들입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽힌 클래스 기술자
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스 기술자 표현에 사용한 직렬화 된 객체의 클래스가 발견되지 않았던 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectOutputStream.html#writeClassDescriptor(java.io.ObjectStreamClass)"><CODE>ObjectOutputStream.writeClassDescriptor(java.io.ObjectStreamClass)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="read()"><!-- --></A> <H3>
read</H3>
<PRE>
public int <B>read</B>()
         throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>데이터의 바이트를 읽어들입니다. 이 메소드는, 유효한 입력이 없는 경우는 블록 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스">ObjectInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectInput.html#read()">read</A> </CODE><DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/InputStream.html#read()">read</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽힌 바이트. 스트림의 마지막에 이르렀을 경우는 -1
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="read(byte[], int, int)"><!-- --></A> <H3>
read</H3>
<PRE>
public int <B>read</B>(byte[]&nbsp;buf,
                int&nbsp;off,
                int&nbsp;len)
         throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>바이트 배열에 읽어들입니다. 이 메소드는, 입력의 일부를 이용할 수 있게 될 때까지 블록 합니다. 바이트의 길이를 정확하게 읽어들이려면 , java.io.DataInputStream.readFully 를 사용해 주세요.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스">ObjectInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectInput.html#read(byte[], int, int)">read</A> </CODE><DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/InputStream.html#read(byte[], int, int)">read</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>buf</CODE> - 데이터의 읽기처의 버퍼<DD><CODE>off</CODE> - 데이터의 개시 오프셋(offset)<DD><CODE>len</CODE> - 읽히는 최대 바이트수
<DT><B>반환값:</B><DD>읽히는 바이트의 실제의 수. 스트림의 마지막에 이르렀을 경우는 -1
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/io/DataInputStream.html#readFully(byte[], int, int)"><CODE>DataInputStream.readFully(byte[], int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="available()"><!-- --></A> <H3>
available</H3>
<PRE>
public int <B>available</B>()
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>블록 하지 않고 읽어들일 수가 있는 바이트수를 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스">ObjectInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectInput.html#available()">available</A> </CODE><DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/InputStream.html#available()">available</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽어들여 가능한 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>InputStream</code> 의 read중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A> <H3>
close</H3>
<PRE>
public void <B>close</B>()
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>입력 스트림을 닫습니다. 스트림에 관련하는 모든 자원을 해제하기 위해서 호출할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/Closeable.html" title="java.io 내의 인터페이스">Closeable</A> </CODE> 내의 <CODE><A HREF="../../java/io/Closeable.html#close()">close</A> </CODE><DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스">ObjectInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectInput.html#close()">close</A> </CODE><DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/InputStream.html#close()">close</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readBoolean()"><!-- --></A> <H3>
readBoolean</H3>
<PRE>
public boolean <B>readBoolean</B>()
                    throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>boolean 를 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readBoolean()">readBoolean</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readByte()"><!-- --></A> <H3>
readByte</H3>
<PRE>
public byte <B>readByte</B>()
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>8 비트의 바이트를 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readByte()">readByte</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 8 비트의 바이트치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readUnsignedByte()"><!-- --></A> <H3>
readUnsignedByte</H3>
<PRE>
public int <B>readUnsignedByte</B>()
                     throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>부호 없음 8 비트 바이트를 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readUnsignedByte()">readUnsignedByte</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 8 비트의 바이트치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readChar()"><!-- --></A> <H3>
readChar</H3>
<PRE>
public char <B>readChar</B>()
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>16 비트의 char 를 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readChar()">readChar</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 16 비트의 char 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readShort()"><!-- --></A> <H3>
readShort</H3>
<PRE>
public short <B>readShort</B>()
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>16 비트의 short 를 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readShort()">readShort</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 16 비트의 short 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readUnsignedShort()"><!-- --></A> <H3>
readUnsignedShort</H3>
<PRE>
public int <B>readUnsignedShort</B>()
                      throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>부호 없음 16 비트의 short 를 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readUnsignedShort()">readUnsignedShort</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 16 비트의 short 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readInt()"><!-- --></A> <H3>
readInt</H3>
<PRE>
public int <B>readInt</B>()
            throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>32 비트의 int 를 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readInt()">readInt</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 32 비트의 int 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readLong()"><!-- --></A> <H3>
readLong</H3>
<PRE>
public long <B>readLong</B>()
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>64 비트의 long 를 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readLong()">readLong</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 64 비트의 long 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readFloat()"><!-- --></A> <H3>
readFloat</H3>
<PRE>
public float <B>readFloat</B>()
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>32 비트의 float 를 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readFloat()">readFloat</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 32 비트의 float 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readDouble()"><!-- --></A> <H3>
readDouble</H3>
<PRE>
public double <B>readDouble</B>()
                  throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>64 비트의 double 를 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readDouble()">readDouble</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 64 비트의 double 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readFully(byte[])"><!-- --></A> <H3>
readFully</H3>
<PRE>
public void <B>readFully</B>(byte[]&nbsp;buf)
               throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>바이트를 읽어들입니다. 모든 바이트가 읽힐 때까지 블록 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readFully(byte[])">readFully</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>buf</CODE> - 데이터의 읽기처의 버퍼
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readFully(byte[], int, int)"><!-- --></A> <H3>
readFully</H3>
<PRE>
public void <B>readFully</B>(byte[]&nbsp;buf,
                      int&nbsp;off,
                      int&nbsp;len)
               throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>바이트를 읽어들입니다. 모든 바이트가 읽힐 때까지 블록 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readFully(byte[], int, int)">readFully</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>buf</CODE> - 데이터의 읽기처의 버퍼<DD><CODE>off</CODE> - 데이터의 개시 오프셋(offset)<DD><CODE>len</CODE> - 읽어들이는 최대 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="skipBytes(int)"><!-- --></A> <H3>
skipBytes</H3>
<PRE>
public int <B>skipBytes</B>(int&nbsp;len)
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>바이트를 스킵 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#skipBytes(int)">skipBytes</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>len</CODE> - 스킵 하는 바이트수
<DT><B>반환값:</B><DD>스킵 된 실제의 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readLine()"><!-- --></A> <H3>
readLine</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>readLine</B>()
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 메소드에서는, 바이트로부터 문자에의 변환이 올바르게 행해지지 않습니다.
                상세 및 대체 메소드에 대해서는 DataInputStream 를 참조해 주세요. </I>
<P>
<DD>\n, \r, \r\n, 또는 EOF 로 종료하는 행을 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readLine()">readLine</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행의 캐릭터 라인의 카피
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>InputStream</code> 의 read중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readUTF()"><!-- --></A> <H3>
readUTF</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>readUTF</B>()
               throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><a href="DataInput.html#modified-utf-8">수정 UTF-8</a>  형식의 캐릭터 라인을 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readUTF()">readUTF</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>캐릭터 라인
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>InputStream</code> 의 read중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/io/UTFDataFormatException.html" title="java.io 안의 클래스">UTFDataFormatException</A> </CODE> - read 바이트가, 유효한 수정 UTF-8 형식에서 encode 된 캐릭터 라인 이외에서 만났을 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ObjectInputStream.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/io/ObjectInputStream.GetField.html" title="java.io 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/io/ObjectInputStream.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ObjectInputStream.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
