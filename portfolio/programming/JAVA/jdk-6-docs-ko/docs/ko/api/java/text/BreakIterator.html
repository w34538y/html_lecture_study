<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:59:05 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
BreakIterator (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="BreakIterator (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BreakIterator.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/text/Bidi.html" title="java.text 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/text/CharacterIterator.html" title="java.text 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/text/BreakIterator.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="BreakIterator.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.text</FONT>
<BR>
클래스 BreakIterator</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.text.BreakIterator</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스">Cloneable</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>BreakIterator</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스">Cloneable</A> </DL>
</PRE>

<P>
<code>BreakIterator</code> 클래스는, 텍스트내의 경계의 위치를 찾아내는 메소드를 구현합니다. <code>BreakIterator</code> 의 인스턴스는 현재의 위치를 유지해, 텍스트를 스캔 해 경계가 발생하는 문자의 인덱스를 돌려줍니다. 내부적으로는,<code>BreakIterator</code> 는 <code>CharacterIterator</code> 를 사용해 텍스트를 스캔 하기 위한(해), 이 프로토콜을 구현하는 임의의 객체에 의해 보관 유지되는 텍스트를 스캔 할 수 있습니다. <code>StringCharacterIterator</code> 는,<code>setText</code> 에게 건네진 <code>String</code> 객체의 스캔에 사용됩니다.

 <p>
이 클래스에 의해 제공되는 팩토리 메소드를 사용해, 다양한 형태의 분할 반복자의 인스턴스를 생성합니다. 특히, 단어, 행, 문, 및 문자의 경계 해석을 실행하는 <code>BreakIterator</code> 를 생성하려면 , 각각 <code>getWordIterator</code>,<code>getLineIterator</code>,<code>getSentenceIterator</code>, 및 <code>getCharacterIterator</code> 를 사용합니다. 단일의 <code>BreakIterator</code> 는, 1 개의 유니트 (단어, 행, 문장등)만을 처리하기 위해(때문에), 실행하는 유니트 경계 해석 마다 다른 반복자를 사용할 필요가 있습니다.

 <p><a name="line"></a> 행의 경계 해석에서는, 텍스트 캐릭터 라인을 행 즉시 로 분할하는 위치를 판정합니다. 구두점 및 하이픈 자동 삽입 된 단어도, 기구에 의해 올바르게 처리됩니다. 실제의 행 분할은, 사용 가능한 행폭도 고려할 필요가 있기 (위해)때문에, 보다 높은 레벨의 소프트웨어에 의해 처리됩니다.

 <p><a name="sentence"></a> 문장의 경계 해석에서는, 숫자와 약어안의 피리어드, 한층 더 인용부호나 괄호등의 종료 문자의 올바른 해석에 대해 선택이 가능합니다.

 <p><a name="word"></a> 단어의 경계 해석은, 검색 치환 기능으로 사용됩니다. 또, 텍스트 편집 어플리케이션내에서, 더블 클릭에 의해 단어가 선택 가능하게 됩니다. 단어 선택에서는, 구두점과 함께, 기호나 구두점등과 같이 단어가 일부에서 없는 문자, 전후에 분할이 있는 문자도 올바르게 해석됩니다.

 <p><a name="character"></a> 문자의 경계 해석에서는, 예를 들어 커서를 텍스트 캐릭터 라인에 따라 움직이는 것 같은 경우에, 사용자가 예측하는 대로의 조작을 하도록(듯이) 합니다. 문자의 경계 해석에 의해, 문자의 포함 방법으로 의존하지 않고, 캐릭터 라인의 올바른 네비게이션이 가능하게 됩니다. 반환되는 경계는, 보조 문자, 결합 문자 순서, 또는 합자 클러스터의 경계가 되는 경우가 있습니다. 예를 들어, 엑센트 첨부의 문자는, 기준 문자와 발음 구별 부호로서 포함되고 있는 경우가 있습니다. 사용자의 문자에 대한 인식은 언어간에 다릅니다.

 <p>
이 클래스의 팩토리 메소드로부터 반환되는 <code>BreakIterator</code> 인스턴스는, 자연 언어에서의 사용만을 상정하고 있어, 프로그램 언어의 텍스트에는 사용할 수 없습니다. 다만, 프로그램 언어를 토큰화하는 서브 클래스를 정의할 수 있습니다.

 <P>
<strong>례</strong>:<P>
텍스트 경계를 작성해 사용합니다.
 <blockquote>
 <pre>
 public static void main(String args[]) {
      if (args.length == 1) {
          String stringToExamine = args[0];
          //print each word in order
          BreakIterator boundary = BreakIterator.getWordInstance();
          boundary.setText(stringToExamine);
          printEachForward(boundary, stringToExamine);
          //print each sentence in reverse order
          boundary = BreakIterator.getSentenceInstance(Locale.US);
          boundary.setText(stringToExamine);
          printEachBackward(boundary, stringToExamine);
          printFirst(boundary, stringToExamine);
          printLast(boundary, stringToExamine);
      }
 }
 </pre>
 </blockquote>

각 요소를 순서에 출력합니다.
 <blockquote>
 <pre>
 public static void printEachForward(BreakIterator boundary, String source) {
     int start = boundary.first();
     for (int end = boundary.next();
          end ! = BreakIterator.DONE;
          start = end, end = boundary.next()) {
          System.out.println(source.substring(start, end));
     }
 }
 </pre>
 </blockquote>

각 요소를 역순서에 출력합니다.
 <blockquote>
 <pre>
 public static void printEachBackward(BreakIterator boundary, String source) {
     int end = boundary.last();
     for (int start = boundary.previous();
          start ! = BreakIterator.DONE;
          end = start, start = boundary.previous()) {
         System.out.println(source.substring(start, end));
     }
 }
 </pre>
 </blockquote>

최초의 요소를 출력합니다.
 <blockquote>
 <pre>
 public static void printFirst(BreakIterator boundary, String source) {
     int start = boundary.first();
     int end = boundary.next();
     System.out.println(source.substring(start, end));
 }
 </pre>
 </blockquote>

마지막 요소를 출력합니다.
 <blockquote>
 <pre>
 public static void printLast(BreakIterator boundary, String source) {
     int end = boundary.last();
     int start = boundary.previous();
     System.out.println(source.substring(start, end));
 }
 </pre>
 </blockquote>

지정된 위치에 있는 요소를 출력합니다.
 <blockquote>
 <pre>
 public static void printAt(BreakIterator boundary, int pos, String source) {
     int end = boundary.following(pos);
     int start = boundary.previous();
     System.out.println(source.substring(start, end));
 }
 </pre>
 </blockquote>

다음의 단어를 검색합니다.
 <blockquote>
 <pre>
 public static int nextWordStartAfter(int pos, String text) {
     BreakIterator wb = BreakIterator.getWordInstance();
     wb.setText(text);
     int last = wb.following(pos);
     int current = wb.next();
     while (current ! = BreakIterator.DONE) {
         for (int p = last; p < current; p++) {
             if (Character.isLetter(text.codePointAt(p)))
                 return last;
         }
         last = current;
         current = wb.next();
     }
     return BreakIterator.DONE;
 }
 </pre>
(BreakIterator.getWordInstance()에 의해 반환되는 반복자는 일의이기 (위해)때문에, 반환되는 분할 위치는 반복의 개시와 종료의 양쪽 모두를 나타내는 것은 아니다. 즉, 문장을 분할하는 반복자는, 각각이 1 개의 문장의 종료와 다음의 문장의 개시를 나타내는 분할을 돌려준다. 단어를 분할하는 반복자에서는, 2 개의 경계간의 문자가 단어, 구두점, 또는 2 개의 단어간의 공백 문자의 경우가 있다. 상기의 코드에서는, 단순한 휴리스틱을 사용해, 단어의 개시의 경계를 판정하고 있다. 어느 경계와 다음의 경계의 사이의 문자가, 적어도 1 개의 문자 (알파벳, CJK 통합 한자, 한글 문자, 가명등)를 포함한 경우는, 이 경계와 다음의 경계의 사이의 텍스트를 단어로 해, 그렇지 않은 경우는, 단어간의 데이터라고 본다)
 </blockquote>
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/text/CharacterIterator.html" title="java.text 내의 인터페이스"><CODE>CharacterIterator</CODE></A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#DONE">DONE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DONE 는, 최초 또는 마지막 텍스트 경계에 도달했을 때에, previous(), next(), next(int), preceding(int), 및 following(int)에 의해 돌려주어집니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#BreakIterator()">BreakIterator</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;생성자 입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#clone()">clone</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;반복자의 카피를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#current()">current</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next(), next(int), previous(), first(), last(), following(int), 또는 preceding(int)에 의해 마지막에 반환된 텍스트 경계의 문자 인덱스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#first()">first</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;최초의 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#following(int)">following</A> </B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 문자 오프셋(offset)에 계속되는 최초의 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/util/Locale.html" title="java.util 내의 클래스">Locale</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getAvailableLocales()">getAvailableLocales</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 클래스의 <code>get*Instance</code> 메소드가 지역 대응의 인스턴스를 돌려줄 수 있는 로케일 모든 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getCharacterInstance()">getCharacterInstance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../java/util/Locale.html#getDefault()">디폴트 로케일</a>의<a href="#character">문자 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getCharacterInstance(java.util.Locale)">getCharacterInstance</A> </B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;locale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 로케일의<a href="#character">문자 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getLineInstance()">getLineInstance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../java/util/Locale.html#getDefault()">디폴트 로케일</a>의<a href="#line">행 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getLineInstance(java.util.Locale)">getLineInstance</A> </B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;locale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 로케일의<a href="#line">행 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getSentenceInstance()">getSentenceInstance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../java/util/Locale.html#getDefault()">디폴트 로케일</a>의<a href="#sentence">문장 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getSentenceInstance(java.util.Locale)">getSentenceInstance</A> </B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;locale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 로케일의<a href="#sentence">문장 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/text/CharacterIterator.html" title="java.text 내의 인터페이스">CharacterIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getText()">getText</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스캔 되는 텍스트를 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getWordInstance()">getWordInstance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../java/util/Locale.html#getDefault()">디폴트 로케일</a>의<a href="#word">단어 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getWordInstance(java.util.Locale)">getWordInstance</A> </B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;locale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 로케일의<a href="#word">단어 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#isBoundary(int)">isBoundary</A> </B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 문자 오프셋(offset)가 텍스트 경계인 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#last()">last</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;마지막 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#next()">next</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 경계에 계속되는 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#next(int)">next</A> </B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 경계로부터 n 번째의 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#preceding(int)">preceding</A> </B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 문자 오프셋(offset)보다 전방에 있는 마지막 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#previous()">previous</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 경계에 선행하는 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#setText(java.text.CharacterIterator)">setText</A> </B>(<A HREF="../../java/text/CharacterIterator.html" title="java.text 안의 인터페이스">CharacterIterator</A> &nbsp;newText)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스캔 되는 새로운 텍스트를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#setText(java.lang.String)">setText</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;newText)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스캔 되는 새로운 텍스트 캐릭터 라인을 설정합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DONE"><!-- --></A> <H3>
DONE</H3>
<PRE>
public static final int <B>DONE</B></PRE>
<DL>
<DD>DONE 는, 최초 또는 마지막 텍스트 경계에 도달했을 때에, previous(), next(), next(int), preceding(int), 및 following(int)에 의해 돌려주어집니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#java.text.BreakIterator.DONE">정수 필드치</A> </DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="BreakIterator()"><!-- --></A> <H3>
BreakIterator</H3>
<PRE>
protected <B>BreakIterator</B>()</PRE>
<DL>
<DD>생성자 입니다. BreakIterator 에는 상태가 없고, 디폴트의 동작이 없습니다.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="clone()"><!-- --></A> <H3>
clone</H3>
<PRE>
public <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>clone</B>()</PRE>
<DL>
<DD>반복자의 카피를 작성합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 반복자의 카피<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스"><CODE>Cloneable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="first()"><!-- --></A> <H3>
first</H3>
<PRE>
public abstract int <B>first</B>()</PRE>
<DL>
<DD>최초의 경계를 돌려줍니다. 반복자의 현재 위치는 최초의 텍스트 경계로 설정됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>최초의 텍스트 경계의 문자 인덱스</DL>
</DD>
</DL>
<HR>

<A NAME="last()"><!-- --></A> <H3>
last</H3>
<PRE>
public abstract int <B>last</B>()</PRE>
<DL>
<DD>마지막 경계를 돌려줍니다. 반복자의 현재 위치는 마지막 텍스트 경계로 설정됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>마지막 텍스트 경계의 문자 인덱스</DL>
</DD>
</DL>
<HR>

<A NAME="next(int)"><!-- --></A> <H3>
next</H3>
<PRE>
public abstract int <B>next</B>(int&nbsp;n)</PRE>
<DL>
<DD>현재의 경계로부터 n 번째의 경계를 돌려줍니다. 최초 또는 마지막 텍스트 경계에 도달했을 경우,<code>BreakIterator.DONE</code> 가 돌려주어져 현재 위치는 도달한 최초 또는 마지막 텍스트 경계로 설정됩니다. 그 이외의 경우, 반복자의 현재 위치는 새로운 경계로 설정됩니다. 예를 들어, 반복자의 현재 위치가 m 번째의 텍스트 경계에 있어, 현재의 경계로부터 마지막 텍스트 경계까지 3 개의 경계가 존재하고 있는 경우, next(2)를 호출하면(자) m + 2 가 돌려주어져 새로운 텍스트 위치는 (m + 2) 번째의 텍스트 경계로 설정됩니다. next(4)를 호출하면(자) <code>BreakIterator.DONE</code> 가 돌려주어져 마지막 텍스트 경계가 새로운 텍스트 위치가 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>n</CODE> - 반환되는 경계. 값이 0 의 경우,
 아무것도 하지 않는다. 0 보다 작은 값은 전방의 경계에 이동해,
 정의 값은 후방의 경계에 이동한다
<DT><B>반환값:</B><DD>현재 위치로부터 n 번째의 경계의 문자 인덱스.
 혹은, 최초 또는 마지막 텍스트 경계에 도달했을 경우는, 
 <code>BreakIterator.DONE</code></DL>
</DD>
</DL>
<HR>

<A NAME="next()"><!-- --></A> <H3>
next</H3>
<PRE>
public abstract int <B>next</B>()</PRE>
<DL>
<DD>현재의 경계에 계속되는 경계를 돌려줍니다. 현재의 경계가 마지막 텍스트 경계의 경우,<code>BreakIterator.DONE</code> 가 돌려주어져 반복자의 현재 위치는 변경되지 않습니다. 그 이외의 경우, 반복자의 현재 위치는, 현재의 경계에 계속되는 경계로 설정됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>다음의 텍스트 경계의 문자 인덱스.
 혹은, 현재의 경계가 마지막 텍스트 경계의 경우는, 
 <code>BreakIterator.DONE</code>  
 next(1)에 동일한<DT><B>관련 항목:</B><DD><A HREF="../../java/text/BreakIterator.html#next(int)"><CODE>next(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="previous()"><!-- --></A> <H3>
previous</H3>
<PRE>
public abstract int <B>previous</B>()</PRE>
<DL>
<DD>현재의 경계에 선행하는 경계를 돌려줍니다. 현재의 경계가 최초의 텍스트 경계의 경우,<code>BreakIterator.DONE</code> 가 돌려주어져 반복자의 현재 위치는 변경되지 않습니다. 그 이외의 경우, 반복자의 현재 위치는, 현재의 경계에 선행하는 경계로 설정됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>전의 텍스트 경계의 문자 인덱스.
 혹은, 현재의 경계가 최초의 텍스트 경계의 경우는, 
 <code>BreakIterator.DONE</code></DL>
</DD>
</DL>
<HR>

<A NAME="following(int)"><!-- --></A> <H3>
following</H3>
<PRE>
public abstract int <B>following</B>(int&nbsp;offset)</PRE>
<DL>
<DD>지정된 문자 오프셋(offset)에 계속되는 최초의 경계를 돌려줍니다. 지정된 오프셋(offset)가 마지막 텍스트 경계에 상당하는 경우,<code>BreakIterator.DONE</code> 가 돌려주어져 반복자의 현재 위치는 변경되지 않습니다. 그 이외의 경우, 반복자의 현재 위치는 반환된 경계로 설정됩니다. 반환되는 값은 항상 오프셋(offset)보다 큰지, 또는 값 <code>BreakIterator.DONE</code> 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 스캔 개시 위치를 나타내는 문자 오프셋(offset).
<DT><B>반환값:</B><DD>지정된 오프셋(offset)의 뒤의 최초의 경계.
 혹은, 오프셋(offset)로서 마지막 텍스트 경계가 지정되었을 경우는, 
 <code>BreakIterator.DONE</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 오프셋(offset)가 최초의 텍스트 경계보다 작은지,
 마지막 텍스트 경계보다 큰 경우</DL>
</DD>
</DL>
<HR>

<A NAME="preceding(int)"><!-- --></A> <H3>
preceding</H3>
<PRE>
public int <B>preceding</B>(int&nbsp;offset)</PRE>
<DL>
<DD>지정된 문자 오프셋(offset)보다 전방에 있는 마지막 경계를 돌려줍니다. 지정된 오프셋(offset)가 최초의 텍스트 경계에 상당하는 경우,<code>BreakIterator.DONE</code> 가 돌려주어져 반복자의 현재 위치는 변경되지 않습니다. 그 이외의 경우, 반복자의 현재 위치는 반환된 경계로 설정됩니다. 반환되는 값은 항상 오프셋(offset)보다 작은지, 또는 값 <code>BreakIterator.DONE</code> 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 스캔 개시 위치를 나타내는 문자 오프셋(offset).
<DT><B>반환값:</B><DD>지정된 오프셋(offset)의 전의 마지막 경계.
 혹은, 오프셋(offset)로서 최초의 텍스트 경계가 지정되었을 경우는, 
 <code>BreakIterator.DONE</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 오프셋(offset)가 최초의 텍스트 경계보다 작은지,
 마지막 텍스트 경계보다 큰 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isBoundary(int)"><!-- --></A> <H3>
isBoundary</H3>
<PRE>
public boolean <B>isBoundary</B>(int&nbsp;offset)</PRE>
<DL>
<DD>지정된 문자 오프셋(offset)가 텍스트 경계인 경우는 true 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 체크 대상의 문자 오프셋(offset)
<DT><B>반환값:</B><DD>오프셋(offset)가 경계 위치의 경우는 <code>true</code>, 
 그렇지 않은 경우는 <code>false</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="current()"><!-- --></A> <H3>
current</H3>
<PRE>
public abstract int <B>current</B>()</PRE>
<DL>
<DD>next(), next(int), previous(), first(), last(), following(int), 또는 preceding(int)에 의해 마지막에 반환된 텍스트 경계의 문자 인덱스를 돌려줍니다. 최초 또는 마지막 텍스트 경계에 도달했기 때문에 이러한 메소드로부터 <code>BreakIterator.DONE</code> 가 돌려주어졌을 경우는, 도달한 최초 또는 마지막 텍스트 경계를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>상기의 메소드로부터 반환된 텍스트 경계,
 혹은 최초 또는 마지막 텍스트 경계<DT><B>관련 항목:</B><DD><A HREF="../../java/text/BreakIterator.html#next()"><CODE>next()</CODE></A> , 
<A HREF="../../java/text/BreakIterator.html#next(int)"><CODE>next(int)</CODE></A> , 
<A HREF="../../java/text/BreakIterator.html#previous()"><CODE>previous()</CODE></A> , 
<A HREF="../../java/text/BreakIterator.html#first()"><CODE>first()</CODE></A> , 
<A HREF="../../java/text/BreakIterator.html#last()"><CODE>last()</CODE></A> , 
<A HREF="../../java/text/BreakIterator.html#following(int)"><CODE>following(int)</CODE></A> , 
<A HREF="../../java/text/BreakIterator.html#preceding(int)"><CODE>preceding(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getText()"><!-- --></A> <H3>
getText</H3>
<PRE>
public abstract <A HREF="../../java/text/CharacterIterator.html" title="java.text 내의 인터페이스">CharacterIterator</A>  <B>getText</B>()</PRE>
<DL>
<DD>스캔 되는 텍스트를 가져옵니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>스캔 되는 텍스트</DL>
</DD>
</DL>
<HR>

<A NAME="setText(java.lang.String)"><!-- --></A> <H3>
setText</H3>
<PRE>
public void <B>setText</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;newText)</PRE>
<DL>
<DD>스캔 되는 새로운 텍스트 캐릭터 라인을 설정합니다. 현재의 스캔 위치는 first()에 리셋 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newText</CODE> - 스캔 대상의 새로운 텍스트</DL>
</DD>
</DL>
<HR>

<A NAME="setText(java.text.CharacterIterator)"><!-- --></A> <H3>
setText</H3>
<PRE>
public abstract void <B>setText</B>(<A HREF="../../java/text/CharacterIterator.html" title="java.text 안의 인터페이스">CharacterIterator</A> &nbsp;newText)</PRE>
<DL>
<DD>스캔 되는 새로운 텍스트를 설정합니다. 현재의 스캔 위치는 first()에 리셋 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newText</CODE> - 스캔 대상의 새로운 텍스트</DL>
</DD>
</DL>
<HR>

<A NAME="getWordInstance()"><!-- --></A> <H3>
getWordInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getWordInstance</B>()</PRE>
<DL>
<DD><A HREF="../../java/util/Locale.html#getDefault()">디폴트 로케일</a>의<a href="#word">단어 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>단어 분할을 위한 분할 반복자</DL>
</DD>
</DL>
<HR>

<A NAME="getWordInstance(java.util.Locale)"><!-- --></A> <H3>
getWordInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getWordInstance</B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;locale)</PRE>
<DL>
<DD>지정된 로케일의<a href="#word">단어 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>locale</CODE> - 목적의 로케일
<DT><B>반환값:</B><DD>단어 분할을 위한 분할 반복자
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>locale</code> 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getLineInstance()"><!-- --></A> <H3>
getLineInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getLineInstance</B>()</PRE>
<DL>
<DD><A HREF="../../java/util/Locale.html#getDefault()">디폴트 로케일</a>의<a href="#line">행 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행 분할을 위한 분할 반복자</DL>
</DD>
</DL>
<HR>

<A NAME="getLineInstance(java.util.Locale)"><!-- --></A> <H3>
getLineInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getLineInstance</B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;locale)</PRE>
<DL>
<DD>지정된 로케일의<a href="#line">행 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>locale</CODE> - 목적의 로케일
<DT><B>반환값:</B><DD>행 분할을 위한 분할 반복자
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>locale</code> 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getCharacterInstance()"><!-- --></A> <H3>
getCharacterInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getCharacterInstance</B>()</PRE>
<DL>
<DD><A HREF="../../java/util/Locale.html#getDefault()">디폴트 로케일</a>의<a href="#character">문자 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>문자 분할을 위한 분할 반복자</DL>
</DD>
</DL>
<HR>

<A NAME="getCharacterInstance(java.util.Locale)"><!-- --></A> <H3>
getCharacterInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getCharacterInstance</B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;locale)</PRE>
<DL>
<DD>지정된 로케일의<a href="#character">문자 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>locale</CODE> - 목적의 로케일
<DT><B>반환값:</B><DD>문자 분할을 위한 분할 반복자
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>locale</code> 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getSentenceInstance()"><!-- --></A> <H3>
getSentenceInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getSentenceInstance</B>()</PRE>
<DL>
<DD><A HREF="../../java/util/Locale.html#getDefault()">디폴트 로케일</a>의<a href="#sentence">문장 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>문 분할을 위한 분할 반복자</DL>
</DD>
</DL>
<HR>

<A NAME="getSentenceInstance(java.util.Locale)"><!-- --></A> <H3>
getSentenceInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getSentenceInstance</B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;locale)</PRE>
<DL>
<DD>지정된 로케일의<a href="#sentence">문장 분할</a>용의 새로운 <code>BreakIterator</code> 인스턴스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>locale</CODE> - 목적의 로케일
<DT><B>반환값:</B><DD>문 분할을 위한 분할 반복자
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>locale</code> 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getAvailableLocales()"><!-- --></A> <H3>
getAvailableLocales</H3>
<PRE>
public static <A HREF="../../java/util/Locale.html" title="java.util 내의 클래스">Locale</A> [] <B>getAvailableLocales</B>()</PRE>
<DL>
<DD>이 클래스의 <code>get*Instance</code> 메소드가 지역 대응의 인스턴스를 돌려줄 수 있는 로케일 모든 배열을 돌려줍니다. 반환되는 배열은, Java 런타임 및 인스톨 되고 있는 <A HREF="../../java/text/spi/BreakIteratorProvider.html" title="java.text.spi 동안의 클래스"><CODE>BreakIteratorProvider</CODE></A>  구현에 의해 지원되고 있는 로케일의 화집합을 나타냅니다. 이것에는,<A HREF="../../java/util/Locale.html#US"><CODE>Locale.US</CODE></A>  와 등가인 <code>Locale</code> 인스턴스가 적어도 1 개(살) 포함되어 있을 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>로컬라이즈 된 <code>BreakIterator</code> 인스턴스를
         사용 가능한 로케일의 배열</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BreakIterator.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/text/Bidi.html" title="java.text 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/text/CharacterIterator.html" title="java.text 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/text/BreakIterator.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="BreakIterator.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
