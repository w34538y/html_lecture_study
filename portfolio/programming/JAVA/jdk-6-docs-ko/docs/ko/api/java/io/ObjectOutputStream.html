<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:56:27 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
ObjectOutputStream (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ObjectOutputStream (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ObjectOutputStream.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/io/ObjectOutputStream.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ObjectOutputStream.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.io</FONT>
<BR>
클래스 ObjectOutputStream</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">java.io.OutputStream</A> 
      <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.io.ObjectOutputStream</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/io/Closeable.html" title="java.io 내의 인터페이스">Closeable</A> , <A HREF="../../java/io/DataOutput.html" title="java.io 안의 인터페이스">DataOutput</A> , <A HREF="../../java/io/Flushable.html" title="java.io 안의 인터페이스">Flushable</A> , <A HREF="../../java/io/ObjectOutput.html" title="java.io 안의 인터페이스">ObjectOutput</A> , <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 안의 인터페이스">ObjectStreamConstants</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>ObjectOutputStream</B><DT>extends <A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> <DT>implements <A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A> , <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 안의 인터페이스">ObjectStreamConstants</A> </DL>
</PRE>

<P>
ObjectOutputStream 는, 기본 데이터형과 Java 객체의 그래프를 OutputStream 에 기입합니다. 이러한 객체를 읽어들이려면 (재구축 하기) ObjectInputStream 를 사용합니다. 객체의 지속적 기억은, 그 스트림을 위한 파일을 사용하면 가능합니다. 스트림이 네트워크 소켓 스트림의 경우는, 다른 호스트나 다른 프로세스상에서 객체를 재구축 할 수도 있습니다.

 <p>스트림에 기입할 수 있는 것은 java.io.Serializable 인터페이스를 지원하는 객체만입니다. 각 직렬화 가능 객체의 클래스는, 클래스의 이름과 시그니챠, 객체의 필드와 배열, 및 초기 객체로부터 참조되는 것 외의 모든 객체의 크로 전기밥통을 포함해 코드화 됩니다.

 <p>객체를 스트림에 기입하려면 writeObject 메소드를 사용합니다. String 나 배열을 포함한 임의의 객체가 writeObject 에 의해 기입해집니다. 복수의 객체 또는 프리미티브(primitive)도, 스트림에의 기입이 가능합니다. 객체를 읽어들일 때는, 대응하는 ObjectInputstream 로부터 같은 형태로서 한편 기입해졌을 때와 같은 순서로 읽어들이지 않으면 안됩니다.

 <p>기본 데이터형을 스트림에 기입하려면 , DataOutput 의 적절한 메소드를 사용합니다. String 를 기입하는 경우는 writeUTF 메소드를 사용합니다.

 <p>객체의 디폴트의 직렬화 기구는, 객체의 클래스, 클래스의 시그니챠, 및 모든 비 transient 및 비 static 필드의 값을 기입합니다. 다른 객체에의 참조 (transient 및 static 필드는 제외하다)가 있으면, 이러한 객체도 기입해집니다. 단일 객체에의 다중 참조는 참조 공유 기구에 의해 encode 되어 객체의 그래프를, 오리지날이 기입해졌을 때의 형상에 복원할 수가 있습니다.

 <p>예를 들어, ObjectInputStream 의 예로 읽어들일 수 있도록(듯이) 객체를 기입하려면 , 다음과 같이 합니다.  <br>
 <pre>
        FileOutputStream fos = new FileOutputStream("t.tmp");
        ObjectOutputStream oos = new ObjectOutputStream(fos);

        oos.writeInt(12345);
        oos.writeObject("Today");
        oos.writeObject(new Date());

        oos.close();
 </pre>

 <p>직렬화와 직렬화 복원 시에 특수한 취급이 필요한 클래스에서는, 정확하게 다음과 같은 시그니챠를 가지는 특수한 메소드를 구현할 필요가 있습니다.  <br>
 <pre>
private void readObject(java.io.ObjectInputStream stream)
throws IOException, ClassNotFoundException;
private void writeObject(java.io.ObjectOutputStream stream)
throws IOException
private void readObjectNoData() 
throws ObjectStreamException;
 </pre>
 
 <p>writeObject 메소드는, 그 특정의 클래스의 객체 상태를 기입해, 대응하는 readObject 메소드가 객체 상태를 복원할 수 있도록(듯이) 하는 역할을 담당합니다. 이 메소드는, 객체의 슈퍼 클래스나 서브 클래스에 속하는 상태에 관여할 필요는 없습니다. 상태를 보존하려면 , writeObject 메소드를 사용해 개개의 필드를 ObjectOutputStream 에 기입하는지, 또는 DataOutput 가 지원하는 기본 데이터형용의 메소드를 사용합니다.

 <p>직렬화에서는, java.io.Serializable 인터페이스를 구현하지 않는 객체의 필드는 기입하지 않습니다. 직렬화 가능하지 않은 객체의 서브 클래스를 직렬화 가능하게 하는 것은 가능합니다. 이 경우, 직렬화 가능하지 않은 클래스는, 그 필드를 초기화할 수 있도록(듯이) 하기 위한(해), 인수 없음의 생성자 을 가질 필요가 있습니다. 이 경우, 직렬화 가능하지 않은 클래스 상태를 보존 및 복원하는 것은, 서브 클래스의 책임이 됩니다. 그 클래스의 필드가 액세스 가능한 (public, package, 또는 protected) 경우, 혹은 상태의 복원에 이용할 수 있는 set 메소드나 get 메소드가 있는 경우가 자주 있습니다.

 <p>writeObject 및 readObject 메소드로 NotSerializableException 를 throw 하도록(듯이) 구현해 두면(자), 객체의 직렬화를 방지할 수 있습니다. 예외가 ObjectOutputStream 에 캐치 되어 직렬화 처리가 이상종료(ABEND) 합니다.

 <p>Externalizable 인터페이스를 구현하면(자), 객체의 직렬화 된 형식의 내용 및 형식을 객체측이 완전하게 제어하는 것이 가능하게 됩니다. Externalizable 인터페이스의 메소드인 writeExternal 와 readExternal 는, 객체 상태를 보존 및 복원하기 위해서(때문에) 불려 갑니다. 이러한 메소드는, 클래스에 의해 구현되었을 경우에는, ObjectOutput 와 ObjectInput 의 모든 메소드를 사용해, 자신 상태의 기입 및 read를 실시할 수가 있습니다. 어떠한 버젼이어도 처리할 수 있도록(듯이) 하는 것은, 객체의 책임입니다.

 <p>enum 정수의 직렬화는, 일반적으로의 직렬화 가능 또는 외부화 가능 객체와는 다릅니다. enum 정수의 직렬화 된 형식을 구성하는 것은, 그 이름 뿐입니다. 정수의 필드치는 전송 되지 않습니다. enum 정수를 직렬화하려면 , 그 정수의 name 메소드에 의해 반환되는 캐릭터 라인을 ObjectOutputStream 로 기입합니다. 다른 직렬화 가능 또는 외부화 가능 객체 같이 enum 정수는, 이후 직렬화 스트림에 출현하는 후방 참조의 대상으로 해 기능할 수 있습니다. enum 정수를 직렬화하는 프로세스를 커스터마이즈 할 수 없습니다. enum 형으로 정의된, 클래스 고유의 writeObject 메소드 및 writeReplace 메소드는, 직렬화 복원동안은 무시됩니다. 같이 serialPersistentFields 또는 serialVersionUID 의 필드 선언도 모두 무시됩니다. 모든 enum 형은 0L 로 고정된 serialVersionUID 를 가집니다.

 <p>직렬화 가능 필드 및 외부화 가능 데이터를 제외한 프리미티브(primitive) 데이터는, 블록 데이터 레코드로서 ObjectOutputStream 에 기입해집니다. 블록 데이터 레코드는, 헤더와 데이터로 구성됩니다. 블록 데이터의 헤더는, 마커 및 헤더에 계속되는 바이트수로 구성됩니다. 연속하는 프리미티브(primitive) 데이터의 기입은, 1 개의 블록 데이터 레코드에 머지 됩니다 블록 데이터 레코드에 사용되는 블록 계수는 1024 바이트입니다. 각 블록 데이터 레코드는, 1024 바이트까지 파묻히는지, 블록 데이터 모드의 종료까지 기입해집니다. ObjectOutputStream 의 메소드 writeObject, defaultWriteObject, 및 writeFields 를 호출하면(자), 최초로 기존의 블록 데이터 레코드가 종료됩니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스"><CODE>DataOutput</CODE></A> , 
<A HREF="../../java/io/ObjectInputStream.html" title="java.io 안의 클래스"><CODE>ObjectInputStream</CODE></A> , 
<A HREF="../../java/io/Serializable.html" title="java.io 안의 인터페이스"><CODE>Serializable</CODE></A> , 
<A HREF="../../java/io/Externalizable.html" title="java.io 안의 인터페이스"><CODE>Externalizable</CODE></A> , 
<a href="../../../platform/serialization/spec/output.html">「객체 직렬화 스펙」의 제 2 장 「객체 출력 클래스」</a> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 안의 클래스">ObjectOutputStream.PutField</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutput 에 기입해지는 지속 필드에의 프로그램에 의한 액세스를 제공합니다. </TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.io.ObjectStreamConstants"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.io. <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 안의 인터페이스">ObjectStreamConstants</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/io/ObjectStreamConstants.html#baseWireHandle">baseWireHandle</A> , <A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_1">PROTOCOL_VERSION_1</A> , <A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_2">PROTOCOL_VERSION_2</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SC_BLOCK_DATA">SC_BLOCK_DATA</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SC_ENUM">SC_ENUM</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SC_EXTERNALIZABLE">SC_EXTERNALIZABLE</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SC_SERIALIZABLE">SC_SERIALIZABLE</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SC_WRITE_METHOD">SC_WRITE_METHOD</A> , <A HREF="../../java/io/ObjectStreamConstants.html#STREAM_MAGIC">STREAM_MAGIC</A> , <A HREF="../../java/io/ObjectStreamConstants.html#STREAM_VERSION">STREAM_VERSION</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SUBCLASS_IMPLEMENTATION_PERMISSION">SUBCLASS_IMPLEMENTATION_PERMISSION</A> , <A HREF="../../java/io/ObjectStreamConstants.html#SUBSTITUTION_PERMISSION">SUBSTITUTION_PERMISSION</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_ARRAY">TC_ARRAY</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_BASE">TC_BASE</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_BLOCKDATA">TC_BLOCKDATA</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_BLOCKDATALONG">TC_BLOCKDATALONG</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_CLASS">TC_CLASS</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_CLASSDESC">TC_CLASSDESC</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_ENDBLOCKDATA">TC_ENDBLOCKDATA</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_ENUM">TC_ENUM</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_EXCEPTION">TC_EXCEPTION</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_LONGSTRING">TC_LONGSTRING</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_MAX">TC_MAX</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_NULL">TC_NULL</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_OBJECT">TC_OBJECT</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_PROXYCLASSDESC">TC_PROXYCLASSDESC</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_REFERENCE">TC_REFERENCE</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_RESET">TC_RESET</A> , <A HREF="../../java/io/ObjectStreamConstants.html#TC_STRING">TC_STRING</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream()">ObjectOutputStream</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutputStream 를 완전하게 다시 구현하는 서브 클래스가, ObjectOutputStream 의 이 구현에 의해 사용된지 얼마 안된 private 데이터를 할당할 필요가 없게 하는 수단을 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream(java.io.OutputStream)">ObjectOutputStream</A> </B>(<A HREF="../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 OutputStream 에 기입하는 ObjectOutputStream 를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#annotateClass(java.lang.Class)">annotateClass</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스는, 이 메소드를 구현해, 클래스의 데이터를 스트림에 보존할 수 있도록(듯이) 할 수가 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#annotateProxyClass(java.lang.Class)">annotateProxyClass</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스는 이 메소드를 구현해, 다이나믹 프록시 클래스에 대한 기술자와 함께 커스텀 데이터를 스트림에 포함합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#close()">close</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림을 닫습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#defaultWriteObject()">defaultWriteObject</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클래스의 비 static 및 비 transient 의 필드를, 이 스트림에 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#drain()">drain</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutputStream 내의 버퍼링 되고 있는 데이터를 모두 배출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#enableReplaceObject(boolean)">enableReplaceObject</A> </B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림의 객체를 치환할 수 있도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#flush()">flush</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림을 플래시 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 내의 클래스">ObjectOutputStream.PutField</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#putFields()">putFields</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림에 기입해지는 지속 필드를 버퍼에 포함하기 위해서 사용되는 객체를 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#replaceObject(java.lang.Object)">replaceObject</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메소드는, 직렬화 시에, ObjectOutputStream 의 신뢰할 수 있는 서브 클래스가, 어느 객체를 다른 객체에 치환할 수 있도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#reset()">reset</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reset 는, 스트림에 벌써 기입해지고 있는 객체 상태를 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#useProtocolVersion(int)">useProtocolVersion</A> </B>(int&nbsp;version)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림의 기입시에 사용하는 스트림 프로토콜의 버젼을 지정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#write(byte[])">write</A> </B>(byte[]&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트 배열을 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#write(byte[], int, int)">write</A> </B>(byte[]&nbsp;buf,
      int&nbsp;off,
      int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트 배열의 일부를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#write(int)">write</A> </B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeBoolean(boolean)">writeBoolean</A> </B>(boolean&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean 를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeByte(int)">writeByte</A> </B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 비트의 바이트를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeBytes(java.lang.String)">writeBytes</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String 를 바이트의 열로서 기입합니다</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeChar(int)">writeChar</A> </B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 비트의 char 를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeChars(java.lang.String)">writeChars</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String 를 char 의 열로서 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeClassDescriptor(java.io.ObjectStreamClass)">writeClassDescriptor</A> </B>(<A HREF="../../java/io/ObjectStreamClass.html" title="java.io 안의 클래스">ObjectStreamClass</A> &nbsp;desc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 클래스 기술자를 ObjectOutputStream 에 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeDouble(double)">writeDouble</A> </B>(double&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;64 비트의 double 를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeFields()">writeFields</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;버퍼에 포함된 필드를 스트림에 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeFloat(float)">writeFloat</A> </B>(float&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 비트의 float 를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeInt(int)">writeInt</A> </B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 비트의 int 를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeLong(long)">writeLong</A> </B>(long&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;64 비트의 long 를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeObject(java.lang.Object)">writeObject</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 객체를 ObjectOutputStream 에 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeObjectOverride(java.lang.Object)">writeObjectOverride</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스가 디폴트의 writeObject 메소드를 오버라이드(override) 하기 위해서 사용하는 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeShort(int)">writeShort</A> </B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 비트의 short 를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeStreamHeader()">writeStreamHeader</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스가 자신의 헤더를 스트림의 전 또는 뒤로 추가할 수 있도록(듯이) 제공되고 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeUnshared(java.lang.Object)">writeUnshared</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutputStream 에 「공유되지 않는다」객체를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeUTF(java.lang.String)">writeUTF</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 String 의 프리미티브(primitive) 데이터를<a href="DataInput.html#modified-utf-8">수정 UTF-8</a>  형식에서 기입합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ObjectOutputStream(java.io.OutputStream)"><!-- --></A> <H3>
ObjectOutputStream</H3>
<PRE>
public <B>ObjectOutputStream</B>(<A HREF="../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;out)
                   throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>지정된 OutputStream 에 기입하는 ObjectOutputStream 를 작성합니다. 이 생성자 은, 직렬화 스트림 헤더를 기본이 되는 스트림에 기입합니다. 이 스트림은 호출해 옆에서 즉시 플래시 해 주세요. ObjectInputStreams 를 받은 생성자 은, 헤더-를 읽어들일 때 블록 하기 (위해)때문에입니다.

 <p>시큐리티 매니저가 인스톨 되고 있는 경우, ObjectOutputStream.putFields 메소드 또는 ObjectOutputStream.writeUnshared 메소드를 오버라이드(override) 하는 서브 클래스의 생성자 에 의해 SerializablePermission("enableSubclassImplementation")가 직접 또는 간접에 불려 갔을 때에, 이 생성자 은 이 액세스권을 확인합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>out</CODE> - 기입처의 출력 스트림
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 스트림 헤더의 기입중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 신뢰되어 있지 않은 서브 클래스가, 시큐리티상 중요한 메소드를 부정하게 오버라이드(override) 했을 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>out</code> 가 <code>null</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream()"><CODE>ObjectOutputStream()</CODE></A> , 
<A HREF="../../java/io/ObjectOutputStream.html#putFields()"><CODE>putFields()</CODE></A> , 
<A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream(java.io.InputStream)"><CODE>ObjectInputStream.ObjectInputStream(InputStream)</CODE></A> </DL>
</DL>
<HR>

<A NAME="ObjectOutputStream()"><!-- --></A> <H3>
ObjectOutputStream</H3>
<PRE>
protected <B>ObjectOutputStream</B>()
                      throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                             <A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </PRE>
<DL>
<DD>ObjectOutputStream 를 완전하게 다시 구현하는 서브 클래스가, ObjectOutputStream 의 이 구현에 의해 사용된지 얼마 안된 private 데이터를 할당할 필요가 없게 하는 수단을 제공합니다.

 <p>시큐리티 매니저가 인스톨 되고 있는 경우, 이 메소드는 우선 시큐리티 매니저의 <code>checkPermission</code> 메소드를 액세스권 <code>SerializablePermission("enableSubclassImplementation")</code> 로 호출해, 서브 클래스화를 유효하게 할 수 있도록(듯이) 합니다.
<P>
<DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <code>checkPermission</code> 메소드가 서브 클래스화를 유효하게 하는 것을 거부했을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> , 
<A HREF="../../java/io/SerializablePermission.html" title="java.io 안의 클래스"><CODE>SerializablePermission</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="useProtocolVersion(int)"><!-- --></A> <H3>
useProtocolVersion</H3>
<PRE>
public void <B>useProtocolVersion</B>(int&nbsp;version)
                        throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>스트림의 기입시에 사용하는 스트림 프로토콜의 버젼을 지정합니다.

 <p>이 루틴은, 현재의 버젼의 직렬화가, 전의 버젼의 스트림 형식과 하위 호환성이 있는 형식에서 기입할 수 있도록(듯이) 하는 훅을 제공합니다.

 <p>하위 호환성이 없는 형식이 한층 더 도입되는 것을 막기 위해서(때문에) 모든 노력을 합니다만, 선택의 여지가 없는 경우도 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>version</CODE> - java.io.ObjectStreamConstants 로부터 ProtocolVersion 를 사용
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 객체가 직렬화 된 뒤에 불려 갔을 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 건네받은 버젼이 무효인 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_1"><CODE>ObjectStreamConstants.PROTOCOL_VERSION_1</CODE></A> , 
<A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_2"><CODE>ObjectStreamConstants.PROTOCOL_VERSION_2</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="writeObject(java.lang.Object)"><!-- --></A> <H3>
writeObject</H3>
<PRE>
public final void <B>writeObject</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)
                       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>지정된 객체를 ObjectOutputStream 에 기입합니다. 객체의 클래스, 클래스의 시그니챠, 클래스의 비 transient 필드 및 비 static 필드의 값과 그 모든 슈퍼타입이 기입해집니다. 어느 클래스에 도착해 디폴트의 직렬화는, writeObject 메소드와 readObject 메소드를 사용해 오버라이드(override) 할 수가 있습니다. 이 객체에 의해 참조되는 객체는 중간적으로 기입해져 거기에 따라, 완전하게 동등한 객체 그래프가 ObjectInputStream 에 의해 재구축 됩니다.

 <p>예외는, OutputStream 에 관한 문제나, 직렬화 해서는 안되는 클래스에 도착해 throw 됩니다. 모든 예외는, OutputStream 에 있어 치명적이어, OutputStream 를 불확정인 상태로 합니다. 스트림 상태를 무시할까 회복 처리할까를 결정하는 것은 호출측입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectOutput.html#writeObject(java.lang.Object)">writeObject</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 기입해지는 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/InvalidClassException.html" title="java.io 안의 클래스">InvalidClassException</A> </CODE> - 직렬화로 사용되는 클래스에 하등의 불편이 있었을 경우
<DD><CODE><A HREF="../../java/io/NotSerializableException.html" title="java.io 안의 클래스">NotSerializableException</A> </CODE> - 직렬화의 대상 객체가 java.io.Serializable 인터페이스를 구현하고 있지 않는 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 OutputStream 가 예외를 throw 했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeObjectOverride(java.lang.Object)"><!-- --></A> <H3>
writeObjectOverride</H3>
<PRE>
protected void <B>writeObjectOverride</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)
                            throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>서브 클래스가 디폴트의 writeObject 메소드를 오버라이드(override) 하기 위해서 사용하는 메소드입니다. 이 메소드는, 인수 없음의 protected 생성자 을 사용해, ObjectInputStream 를 구축한 ObjectInputStream 의 신뢰할 수 있는 서브 클래스에 의해 불려 갑니다. 서브 클래스는, 수식자가 final 의 오버라이드(override) 메소드를 제공한다고 보입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 기본이 되는 스트림에 기입해지는 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream()"><CODE>ObjectOutputStream()</CODE></A> , 
<A HREF="../../java/io/ObjectOutputStream.html#writeObject(java.lang.Object)"><CODE>writeObject(Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="writeUnshared(java.lang.Object)"><!-- --></A> <H3>
writeUnshared</H3>
<PRE>
public void <B>writeUnshared</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)
                   throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>ObjectOutputStream 에 「공유되지 않는다」객체를 기입합니다. 이 메소드는, writeObject 와 닮아 있습니다. 다만, 직렬화 된 인스턴스를 가리키는 역참조로서가 아니고, 스트림내에서 일의의 새로운 객체로서 기입합니다. 구체적으로는, 다음과 같이 됩니다.
 <ul>
<li>writeUnshared 를 사용해 기입해진 객체는, 그 객체가 스트림에 기입해지고 있는지 어떤지에 관계없이, 새롭게 기입해진 객체 (스트림에 기입해지지 않은 객체)로서 직렬화 됩니다.

<li>writeUnshared 에 의해 이전에 기입해진 객체를 기입할 때에 writeObject 를 사용하면(자), 이전의 writeUnshared 조작은, 다른 객체의 기입으로서 다루어집니다. 즉, ObjectOutputStream 는, writeUnshared 의 호출에 의해 기입해진 객체 데이터에의 후방 참조를 생성하지 않습니다.
 </ul>
writeUnshared 를 개입시켜 객체를 기입하는 것 자체는, 객체가 직렬화 복원되었을 때에 그 객체에의 일의 참조를 보증하는 것이 아닙니다만, 1 개의 객체가 스트림내에서 여러 차례 정의되는 것은 가능하게 됩니다. 그 때문에, 수취하는 측이 readUnshared 를 여러 차례 호출해도 충돌이 생기지 않습니다. 여기서 설명한 규칙은, writeUnshared 에 의해 기입해진 기본 레벨의 객체인 만큼 적용되어 직렬화 되는 객체의 그래프내에서 일시적으로 참조되는 서브 객체에는 일절 적용되지 않습니다.

 <p>이 메소드를 오버라이드(override) 하는 ObjectOutputStream 서브 클래스는, SerializablePermission("enableSubclassImplementation")를 가지는 시큐리티 문맥내에서만 구축할 수 있습니다. 이 액세스권을 가지지 않는 시큐리티 문맥으로 인스턴스화하려고 하면(자), SecurityException 가 throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 스트림에 기입하는 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/NotSerializableException.html" title="java.io 안의 클래스">NotSerializableException</A> </CODE> - 직렬화하는 그래프내의 객체가 Serializable 인터페이스를 구현하지 않는 경우
<DD><CODE><A HREF="../../java/io/InvalidClassException.html" title="java.io 안의 클래스">InvalidClassException</A> </CODE> - 직렬화하는 객체의 클래스에 문제가 있는 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 직렬화중에 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="defaultWriteObject()"><!-- --></A> <H3>
defaultWriteObject</H3>
<PRE>
public void <B>defaultWriteObject</B>()
                        throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>현재의 클래스의 비 static 및 비 transient 의 필드를, 이 스트림에 기입합니다. 이 메소드를 호출할 수가 있는 것은, 직렬화를 하고 있는 클래스의 writeObject 메소드 뿐입니다. 다른 방법으로 불려 갔을 경우는 NotActiveException 를 throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>OutputStream</code> 의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="putFields()"><!-- --></A> <H3>
putFields</H3>
<PRE>
public <A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 내의 클래스">ObjectOutputStream.PutField</A>  <B>putFields</B>()
                                      throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>스트림에 기입해지는 지속 필드를 버퍼에 포함하기 위해서 사용되는 객체를 가져옵니다. 필드는, writeFields 메소드가 불려 갔을 때에 스트림에 기입해집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>직렬화 가능 필드를 보관 유지하고 있는 Putfield 클래스의 인스턴스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="writeFields()"><!-- --></A> <H3>
writeFields</H3>
<PRE>
public void <B>writeFields</B>()
                 throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>버퍼에 포함된 필드를 스트림에 기입합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/io/NotActiveException.html" title="java.io 안의 클래스">NotActiveException</A> </CODE> - 객체 상태를 기입하기 위해서(때문에) 클래스의 writeObject 메소드가 불려 가지 않았을 때에 불려 갔을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="reset()"><!-- --></A> <H3>
reset</H3>
<PRE>
public void <B>reset</B>()
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>Reset 는, 스트림에 벌써 기입해지고 있는 객체 상태를 무효로 합니다. 새로운 ObjectOutputStream 와 같은 상태에 리셋 됩니다. 스트림의 현재 위치에 마크가 설정되어 대응하는 ObjectInputStream 도 같은 위치에 리셋 됩니다. 그 이전에 스트림에 기입해지고 있던 객체는, 스트림상에 있다고는 보이지 않습니다. 이러한 객체는, 스트림에 재차 기입해집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 객체를 직렬화중에 reset()가 불려 갔을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="annotateClass(java.lang.Class)"><!-- --></A> <H3>
annotateClass</H3>
<PRE>
protected void <B>annotateClass</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)
                      throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>서브 클래스는, 이 메소드를 구현해, 클래스의 데이터를 스트림에 보존할 수 있도록(듯이) 할 수가 있습니다. 디폴트에서는 이 메소드는 아무것도 실시하지 않습니다. ObjectInputStream 내에서 대응하는 메소드는 resolveClass 입니다. 이 메소드는, 스트림의 일의의 클래스 각각 붙어 1 회만 불려 갑니다. 그 시점에서 클래스명과 시그니챠는 벌써 스트림에 기입해지고 있습니다. 이 메소드는, ObjectOutputStream 를 자유롭게 사용해, 적절이라고 판단한 클래스의 임의의 표현 (클래스 파일의 바이트등)을 보존할 수 있습니다. ObjectInputStream 의 대응하는 서브 클래스의 resolveClass 메소드는, annotateClass 에 의해 기입해진 데이터나 객체를 읽어들여, 사용하지 않으면 안됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cl</CODE> - 커스텀 데이터에 주석을 붙이는 클래스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 OutputStream 가 예외를 throw 했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="annotateProxyClass(java.lang.Class)"><!-- --></A> <H3>
annotateProxyClass</H3>
<PRE>
protected void <B>annotateProxyClass</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)
                           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>서브 클래스는 이 메소드를 구현해, 다이나믹 프록시 클래스에 대한 기술자와 함께 커스텀 데이터를 스트림에 포함합니다.

 <p>이 메소드는 스트림의 일의의 각 프록시 클래스 기술자에 대해 1 회만 불려 갑니다. <code>ObjectOutputStream</code> 내의 이 메소드의 디폴트 구현은, 아무것도 실행하지 않습니다.

 <p><code>ObjectInputStream</code> 내에서 대응하는 메소드는 <code>resolveProxyClass</code> 입니다. 이 메소드를 오버라이드(override) 하는 <code>ObjectOutputStream</code> 의 지정된 서브 클래스에 대해서는,<code>ObjectInputStream</code> 내의 대응하는 서브 클래스의 <code>resolveProxyClass</code> 메소드가,<code>annotateProxyClass</code> 가 기입하는 데이터 또는 객체를 모두 읽어낼 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cl</CODE> - 커스텀 데이터에 주석을 붙이는 프록시 클래스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>OutputStream</code> 가 예외를 throw 했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectInputStream.html#resolveProxyClass(java.lang.String[])"><CODE>ObjectInputStream.resolveProxyClass(String[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="replaceObject(java.lang.Object)"><!-- --></A> <H3>
replaceObject</H3>
<PRE>
protected <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>replaceObject</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)
                        throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 메소드는, 직렬화 시에, ObjectOutputStream 의 신뢰할 수 있는 서브 클래스가, 어느 객체를 다른 객체에 치환할 수 있도록(듯이) 합니다. 객체의 치환은, enableReplaceObject 가 불려 갈 때까지는 실시할 수 없습니다. enableReplaceObject 메소드는, 객체의 치환을 요구하고 있는 스트림을 신뢰할 수 있을지 어떨지를 조사합니다. 직렬화 스트림에 기입해지는 각 객체의 쳐 최초로 출현한 것은, replaceObject 에게 건네집니다. 그 이후의 객체에의 참조는, replaceObject 의 원의 호출에 의해 반환된 객체에 의해 치환됩니다. 객체의 private 상태가 의도하지 않고 공개되는 것이 없게, replaceObject 를 사용하는 것은 신뢰할 수 있는 스트림로 한정됩니다.
 
 <p>ObjectOutputStream.writeObject 메소드는 Object 형의 파라미터 (Serializable 형과는 다르다)를 취해, 직렬화 가능하지 않은 객체가 직렬화 가능 객체로 옮겨지도록(듯이) 합니다.
 
 <p>서브 클래스는, 객체를 치환할 때, 직렬화 복원 실행시에 상보적인 치환을 하도록(듯이) 하는지, 또는 치환된 객체와 참조가 포함되는 각 필드와의 호환성을 유지하도록(듯이) 할 필요가 있습니다. 필드 또는 배열 요소의 형태의 서브 클래스가 아닌 형태의 객체는, 예외를 발생시키는 것에 의해 직렬화를 중단해, 그 결과 객체는 포함되지 않습니다.

 <p>이 메소드는, 각 객체가 최초로 검출되었을 때에 1 회만 불려 갑니다. 이것 이후 검출되는 그 객체에의 참조는, 새로운 객체에 리다이렉트(redirect) 됩니다. 이 메소드는, 치환되는 객체 또는 원의 객체를 돌려주게 됩니다.

 <p>치환되는 객체로서 null 를 돌려줄 수도 있습니다만, 오리지날 객체에의 참조를 포함한 클래스에서는, null 는 아니고 객체가 반환되는 것을 가정하고 있는 것이 있어, 이 경우는 NullReferenceException 가 throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 옮겨놓을 수 있는 객체
<DT><B>반환값:</B><DD>지정된 객체와 옮겨놓을 수 있었던 대체 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 OutputStream 가 예외를 throw 했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="enableReplaceObject(boolean)"><!-- --></A> <H3>
enableReplaceObject</H3>
<PRE>
protected boolean <B>enableReplaceObject</B>(boolean&nbsp;enable)
                               throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 내의 클래스">SecurityException</A> </PRE>
<DL>
<DD>스트림의 객체를 치환할 수 있도록(듯이) 합니다. 치환이 가능하게 되면(자), replaceObject 메소드가, 직렬화 되는 각 객체에 대해 불려 갑니다.

 <p><code>enable</code> 가 true 로, 시큐리티 매니저가 인스톨 되고 있는 경우, 이 메소드는 우선 시큐리티 매니저의 <code>checkPermission</code> 메소드를 액세스권 <code>SerializablePermission("enableSubstitution")</code> 로 호출해, 스트림의 객체를 스트림을 치환할 수 있도록(듯이) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>enable</CODE> - 객체의 치환을 가능하게 하는 boolean 파라미터
<DT><B>반환값:</B><DD>이 메소드가 불려 가기 전의 설정
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <code>checkPermission</code> 메소드가, 스트림의 객체의 스트림에 의한 치환을 허가하지 않았던 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> , 
<A HREF="../../java/io/SerializablePermission.html" title="java.io 안의 클래스"><CODE>SerializablePermission</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="writeStreamHeader()"><!-- --></A> <H3>
writeStreamHeader</H3>
<PRE>
protected void <B>writeStreamHeader</B>()
                          throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>서브 클래스가 자신의 헤더를 스트림의 전 또는 뒤로 추가할 수 있도록(듯이) 제공되고 있습니다. 이 메소드는, 매직 번호와 버젼 정보를 스트림에 기입합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeClassDescriptor(java.io.ObjectStreamClass)"><!-- --></A> <H3>
writeClassDescriptor</H3>
<PRE>
protected void <B>writeClassDescriptor</B>(<A HREF="../../java/io/ObjectStreamClass.html" title="java.io 안의 클래스">ObjectStreamClass</A> &nbsp;desc)
                             throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>지정된 클래스 기술자를 ObjectOutputStream 에 기입합니다. 클래스 기술자는 스트림에 기입해진 객체의 클래스를 식별할 때에 사용합니다. ObjectOutputStream 의 서브 클래스에서 이 메소드를 오버라이드(override) 하는 것으로써, 직렬화 스트림에 클래스 기술자를 기입하는 방법을 커스터마이즈 할 수 있습니다. 그 후, ObjectInputStream 내의 대응하는 메소드 <code>readClassDescriptor</code> 을 오버라이드(override) 해, 커스텀의 스트림 표현으로부터 클래스 기술자를 재구축 하도록 해 주세요. 디폴트에서는, 이 메소드는 클래스 기술자를 객체 직렬화 스펙에 정의된 형식에서 기입합니다.
 
 <p>이 메소드를 호출할 수가 있는 것은, ObjectOutputStream 의 <code>useProtocolVersion</code> 메소드를 호출하는 것에 의해 설정되는 낡은 직렬화 스트림 형식을 ObjectOutputStream 가 사용하고 있지 않는 경우뿐인 점에 주의해 주세요. 이 직렬화 스트림이 낡은 형식 (<code>PROTOCOL_VERSION_1</code>)을 사용하고 있는 경우, 클래스 기술자는 오버라이드(override) 또는 커스터마이즈가 불가능한 방법으로 내부적으로 기입해집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>desc</CODE> - 스트림에 기입하는 클래스 기술자
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectInputStream.html#readClassDescriptor()"><CODE>ObjectInputStream.readClassDescriptor()</CODE></A> , 
<A HREF="../../java/io/ObjectOutputStream.html#useProtocolVersion(int)"><CODE>useProtocolVersion(int)</CODE></A> , 
<A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_1"><CODE>ObjectStreamConstants.PROTOCOL_VERSION_1</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="write(int)"><!-- --></A> <H3>
write</H3>
<PRE>
public void <B>write</B>(int&nbsp;val)
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>바이트를 기입합니다. 이 메소드는 바이트가 실제로 기입해질 때까지 블록 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#write(int)">write</A> </CODE><DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectOutput.html#write(int)">write</A> </CODE><DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/OutputStream.html#write(int)">write</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 스트림에 기입해지는 바이트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="write(byte[])"><!-- --></A> <H3>
write</H3>
<PRE>
public void <B>write</B>(byte[]&nbsp;buf)
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>바이트 배열을 기입합니다. 이 메소드는 바이트가 실제로 기입해질 때까지 블록 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#write(byte[])">write</A> </CODE><DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectOutput.html#write(byte[])">write</A> </CODE><DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/OutputStream.html#write(byte[])">write</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>buf</CODE> - 기입해지는 데이터
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/io/OutputStream.html#write(byte[], int, int)"><CODE>OutputStream.write(byte[], int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="write(byte[], int, int)"><!-- --></A> <H3>
write</H3>
<PRE>
public void <B>write</B>(byte[]&nbsp;buf,
                  int&nbsp;off,
                  int&nbsp;len)
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>바이트 배열의 일부를 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#write(byte[], int, int)">write</A> </CODE><DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectOutput.html#write(byte[], int, int)">write</A> </CODE><DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/OutputStream.html#write(byte[], int, int)">write</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>buf</CODE> - 기입해지는 데이터<DD><CODE>off</CODE> - 데이터의 개시 오프셋(offset)<DD><CODE>len</CODE> - 기입해지는 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="flush()"><!-- --></A> <H3>
flush</H3>
<PRE>
public void <B>flush</B>()
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>스트림을 플래시 합니다. 이 메소드는, 버퍼링 떠날 수 있어 모든 출력 바이트를 기입해, 기본이 되는 스트림을 통해 플래시 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/Flushable.html" title="java.io 내의 인터페이스">Flushable</A> </CODE> 내의 <CODE><A HREF="../../java/io/Flushable.html#flush()">flush</A> </CODE><DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectOutput.html#flush()">flush</A> </CODE><DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/OutputStream.html#flush()">flush</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="drain()"><!-- --></A> <H3>
drain</H3>
<PRE>
protected void <B>drain</B>()
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>ObjectOutputStream 내의 버퍼링 되고 있는 데이터를 모두 배출합니다. 플래시와 닮아 있습니다만, 기본이 되는 스트림에 플래시를 전파 하지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A> <H3>
close</H3>
<PRE>
public void <B>close</B>()
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>스트림을 닫습니다. 스트림에 관련하는 모든 자원을 해제하기 위해서, 이 메소드를 호출할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/Closeable.html" title="java.io 내의 인터페이스">Closeable</A> </CODE> 내의 <CODE><A HREF="../../java/io/Closeable.html#close()">close</A> </CODE><DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectOutput.html#close()">close</A> </CODE><DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/OutputStream.html#close()">close</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeBoolean(boolean)"><!-- --></A> <H3>
writeBoolean</H3>
<PRE>
public void <B>writeBoolean</B>(boolean&nbsp;val)
                  throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>boolean 를 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeBoolean(boolean)">writeBoolean</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeByte(int)"><!-- --></A> <H3>
writeByte</H3>
<PRE>
public void <B>writeByte</B>(int&nbsp;val)
               throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>8 비트의 바이트를 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeByte(int)">writeByte</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 바이트치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeShort(int)"><!-- --></A> <H3>
writeShort</H3>
<PRE>
public void <B>writeShort</B>(int&nbsp;val)
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>16 비트의 short 를 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeShort(int)">writeShort</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 short 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeChar(int)"><!-- --></A> <H3>
writeChar</H3>
<PRE>
public void <B>writeChar</B>(int&nbsp;val)
               throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>16 비트의 char 를 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeChar(int)">writeChar</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 char 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeInt(int)"><!-- --></A> <H3>
writeInt</H3>
<PRE>
public void <B>writeInt</B>(int&nbsp;val)
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>32 비트의 int 를 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeInt(int)">writeInt</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 int 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeLong(long)"><!-- --></A> <H3>
writeLong</H3>
<PRE>
public void <B>writeLong</B>(long&nbsp;val)
               throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>64 비트의 long 를 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeLong(long)">writeLong</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 long 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeFloat(float)"><!-- --></A> <H3>
writeFloat</H3>
<PRE>
public void <B>writeFloat</B>(float&nbsp;val)
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>32 비트의 float 를 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeFloat(float)">writeFloat</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 float 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeDouble(double)"><!-- --></A> <H3>
writeDouble</H3>
<PRE>
public void <B>writeDouble</B>(double&nbsp;val)
                 throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>64 비트의 double 를 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeDouble(double)">writeDouble</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 double 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeBytes(java.lang.String)"><!-- --></A> <H3>
writeBytes</H3>
<PRE>
public void <B>writeBytes</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>String 를 바이트의 열로서 기입합니다
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeBytes(java.lang.String)">writeBytes</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - 기입해지는 바이트의 캐릭터 라인
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeChars(java.lang.String)"><!-- --></A> <H3>
writeChars</H3>
<PRE>
public void <B>writeChars</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>String 를 char 의 열로서 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeChars(java.lang.String)">writeChars</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - 기입해지는 char 의 캐릭터 라인
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeUTF(java.lang.String)"><!-- --></A> <H3>
writeUTF</H3>
<PRE>
public void <B>writeUTF</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 String 의 프리미티브(primitive) 데이터를<a href="DataInput.html#modified-utf-8">수정 UTF-8</a>  형식에서 기입합니다. 스트림에 String 를 프리미티브(primitive) 데이터로서 기입하는 것으로, Object 로서 기입하는 것에는 큰 차이가 있습니다. writeObject 에 의해 기입해지는 String 의 인스턴스는, 처음은 String 로서 스트림에 기입해집니다. 그 이후의 writeObject()의 호출은, 캐릭터 라인에의 참조를 스트림에 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeUTF(java.lang.String)">writeUTF</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - 기입해지는 캐릭터 라인
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ObjectOutputStream.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/io/ObjectOutputStream.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ObjectOutputStream.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
