<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:58:03 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
RMIClassLoader (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="RMIClassLoader (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/RMIClassLoader.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/rmi/server/RemoteStub.html" title="java.rmi.server 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/rmi/server/RMIClassLoader.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="RMIClassLoader.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.rmi.server</FONT>
<BR>
클래스 RMIClassLoader</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.rmi.server.RMIClassLoader</B>
</PRE>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>RMIClassLoader</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
<code>RMIClassLoader</code> 는, RMI 를 사용해 동적으로 클래스를 로드하기 위한 static 메소드로부터 구성됩니다. 이 클래스 로더에는, 네트워크의 장소 (1 개(살) 이상의 URL)에서 클래스를 로드하는 메소드나, 기존의 클래스가 포함되고 있는 장소를 취득하는 메소드가 짜넣어지고 있습니다. 이러한 메소드는, 원격 메소드 호출의 인수나 반환값에 포함되는 클래스를 정렬화 및 비정렬화할 때, RMI 런타임에 의해 사용됩니다.  또, 이러한 메소드를 어플리케이션으로부터 직접 호출해, 클래스를 동적으로 로드할 수도 있습니다.

 <p>다음의 static 메소드의 구현은, 이러한 서비스 프로바이더 인터페이스 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스"><CODE>RMIClassLoaderSpi</CODE></A>  의 인스턴스에 의해 제공됩니다.

 <ul>

<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.net.URL, java.lang.String)"><CODE>loadClass(URL, String)</CODE></A> 
<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A> 
<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>loadClass(String, String, ClassLoader)</CODE></A> 
<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadProxyClass(java.lang.String, java.lang.String[], java.lang.ClassLoader)"><CODE>loadProxyClass(String, String[], ClassLoader)</CODE></A> 
<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#getClassLoader(java.lang.String)"><CODE>getClassLoader(String)</CODE></A> 
<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#getClassAnnotation(java.lang.Class)"><CODE>getClassAnnotation(Class)</CODE></A> 

 </ul>

이 메소드중 한쪽이 불려 가면(자), 그 동작이 서비스 프로바이더 인스턴스의 대응하는 메소드에 위양 됩니다. 각 메소드가 프로바이더 인스턴스에 위양 하는 방법의 자세한 것은, 각 메소드의 메뉴얼을 참조해 주세요.

 <p>서비스 프로바이더 인스턴스는 다음과 같이 선택됩니다.

 <ul>

<li>시스템 프로퍼티 <code>java.rmi.server.RMIClassLoaderSpi</code> 가 정의되고 있는 경우, 그 값이 <code>"default"</code> 때는,<A HREF="../../../java/rmi/server/RMIClassLoader.html#getDefaultProviderInstance()"><CODE>getDefaultProviderInstance()</CODE></A>  메소드 호출의 반환값으로 지정되고 있는 프로바이더 인스턴스가 선택된다.  이 시스템 프로퍼티이 <code>"default"</code> 이외의 값 때는, 시스템 클래스 로더 (<A HREF="../../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>ClassLoader.getSystemClassLoader()</CODE></A>  를 참조)가 시스템 프로퍼티으로 지정되고 있는 클래스를 로드 할 수 있어 그 클래스를 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 안의 클래스"><CODE>RMIClassLoaderSpi</CODE></A>  에 할당할 수가 있어 인수가 없는 public 생성자 을 가지는 경우, 프로바이더 인스턴스 작성시에 그 생성자 이 불려 간다. 이 시스템 프로퍼티이 정의되고 있는 경우에서도, 이러한 조건이 채워지지 않은 경우는,<code>RMIClassLoader</code> 를 사용을 시도하는 코드에 대해서, 프로바이더 인스턴스의 취득에 실패한 것을 나타내는, 지정되어 있지 않은 <code>Error</code> 가 throw 된다

<li>시스템 클래스 로더에 <code>META-INF/services/java.rmi.server.RMIClassLoaderSpi</code> 라고 하는 자원이 짜넣어지고 있는 경우, 이 자원의 내용은 프로바이더의 구성 파일로서 해석되어 이 파일의 최초로 지정되고 있는 클래스명이 프로바이더의 클래스명으로서 사용된다. 시스템 클래스 로더가 그 이름을 가지는 클래스를 로드 할 수 있어 그 클래스를 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 안의 클래스"><CODE>RMIClassLoaderSpi</CODE></A>  에 할당할 수가 있어 인수가 없는 public 생성자 을 가지는 경우는, 프로바이더 인스턴스 작성시에 그 생성자 이 불려 간다. 이 자원이 짜넣어지고 있어도, 프로바이더를 인스턴스화할 수 없는 경우는,<code>RMIClassLoader</code> 를 사용을 시도하는 코드에 대해서, 프로바이더 인스턴스의 취득에 실패한 것을 나타내는, 지정되어 있지 않은 <code>Error</code> 가 throw 된다

<li>상기 이외의 경우는,<A HREF="../../../java/rmi/server/RMIClassLoader.html#getDefaultProviderInstance()"><CODE>getDefaultProviderInstance()</CODE></A>  메소드 호출의 반환값으로 지정되고 있는 프로바이더 인스턴스가 선택된다

 </ul>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스"><CODE>RMIClassLoaderSpi</CODE></A> </DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#getClassAnnotation(java.lang.Class)">getClassAnnotation</A> </B>(<A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클래스 정의의 위치를 나타내는 주석 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 내의 클래스">ClassLoader</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#getClassLoader(java.lang.String)">getClassLoader</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 코드 베이스 URL 패스로부터 클래스를 로드하는 클래스 로더를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스">RMIClassLoaderSpi</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#getDefaultProviderInstance()">getDefaultProviderInstance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서비스 프로바이더 인터페이스 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스"><CODE>RMIClassLoaderSpi</CODE></A>  의 디폴트 프로바이더의 정규 인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#getSecurityContext(java.lang.ClassLoader)">getSecurityContext</A> </B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>대체는 없습니다. Java 2 플랫폼 1.2 이후의 RMI 에서는, 클래스 로더의 시큐리티 문맥을 취득하기 위해서 이 메소드를 사용하지 않습니다</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String)">loadClass</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I><code>loadClass(String, String)</code> 메소드로 옮겨졌습니다</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)">loadClass</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase,
          <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 코드 베이스 URL 패스로부터 클래스를 로드합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)">loadClass</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase,
          <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
          <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;defaultLoader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 로더를 사용할 수도 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.net.URL, java.lang.String)">loadClass</A> </B>(<A HREF="../../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;codebase,
          <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 코드 베이스 URL 로부터 클래스를 로드합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadProxyClass(java.lang.String, java.lang.String[], java.lang.ClassLoader)">loadProxyClass</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase,
               <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;interfaces,
               <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;defaultLoader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이름을 가지는 인터페이스군을 구현한 동적 프록시 클래스 (<A HREF="../../../java/lang/reflect/Proxy.html" title="java.lang.reflect 안의 클래스"><CODE>Proxy</CODE></A>  를 참조)를, 지정된 코드 베이스 URL 패스로부터 로드합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="loadClass(java.lang.String)"><!-- --></A> <H3>
loadClass</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public static <A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>loadClass</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                          throws <A HREF="../../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A> ,
                                 <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I><code>loadClass(String, String)</code> 메소드로 옮겨졌습니다</I>
<P>
<DD>지정된 <code>name</code> 를 이름에 가지는 클래스를 로드합니다.

 <p>이 메소드는 처리를 <A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A>  메소드에 위양 합니다.  1 개째의 인수에는 <code>null</code> 가, 2 개째의 인수에는 <code>name</code> 가 건네받습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 로드 대상 클래스의 이름
<DT><B>반환값:</B><DD>로드 된 클래스를 나타내는 <code>Class</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - 클래스의 로드시에 사용된 프로바이더 고유 URL 가 무효인 경우
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스의 정의가 코드 베이스의 위치에 없었던 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="loadClass(java.net.URL, java.lang.String)"><!-- --></A> <H3>
loadClass</H3>
<PRE>
public static <A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>loadClass</B>(<A HREF="../../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;codebase,
                                 <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                          throws <A HREF="../../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A> ,
                                 <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>지정된 코드 베이스 URL 로부터 클래스를 로드합니다.

<code>codebase</code> 가 <code>null</code> 인 경우, 이 메소드의 동작은,<A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A>  메소드의 인수에 <code>null</code> <code>codebase</code> 와 동일 클래스명을 지정했을 경우와 같게 됩니다.

 <p>이 메소드는, 프로바이더 인스턴스의 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>RMIClassLoaderSpi.loadClass(String, String, ClassLoader)</CODE></A>  메소드에 처리를 위양 합니다.  이 때, 지정한 URL 로 <A HREF="../../../java/net/URL.html#toString()"><CODE>URL.toString()</CODE></A>  를 호출한 결과 (<code>codebase</code> 가 null 의 경우는 <code>null</code>)가 최초의 인수로서<code>name</code> 가 2 개째의 인수로서<code>null</code> 가 3 개째의 인수로서 건네받습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>codebase</CODE> - 클래스의 로드원의 URL, 또는 <code>null</code><DD><CODE>name</CODE> - 로드 대상 클래스의 이름
<DT><B>반환값:</B><DD>로드 된 클래스를 나타내는 <code>Class</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - <code>codebase</code> 가 <code>null</code> 로, 한편 클래스의 로드시에 사용된 프로바이더 고유 URL 가 무효인 경우
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스의 정의가 지정된 URL 에 없었던 경우</DL>
</DD>
</DL>
<HR>

<A NAME="loadClass(java.lang.String, java.lang.String)"><!-- --></A> <H3>
loadClass</H3>
<PRE>
public static <A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>loadClass</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase,
                                 <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                          throws <A HREF="../../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A> ,
                                 <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>지정된 코드 베이스 URL 패스로부터 클래스를 로드합니다.

 <p>이 메소드는, 프로바이더 인스턴스의 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>RMIClassLoaderSpi.loadClass(String, String, ClassLoader)</CODE></A>  메소드에 처리를 위양 합니다.  이 때,<code>codebase</code> 가 최초의 인수로서<code>name</code> 가 2 개째의 인수로서<code>null</code> 가 3 개째의 인수로서 건네받습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>codebase</CODE> - 클래스의 로드원의 URL 의 리스트 (단락 문자는 스페이스), 또는 <code>null</code><DD><CODE>name</CODE> - 로드 대상 클래스의 이름
<DT><B>반환값:</B><DD>로드 된 클래스를 나타내는 <code>Class</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - <code>codebase</code> 가 <code>null</code> 이외로 한편 무효인 URL 를 포함하고 있는 경우, 또는 <code>codebase</code> 가 <code>null</code> 로 한편 클래스의 로드시에 사용된 프로바이더 고유 URL 가 무효인 경우
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스의 정의가 지정된 장소에 없었던 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><!-- --></A> <H3>
loadClass</H3>
<PRE>
public static <A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>loadClass</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase,
                                 <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
                                 <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;defaultLoader)
                          throws <A HREF="../../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A> ,
                                 <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>지정된 로더를 사용할 수도 있습니다.

프로바이더 구현의 호출원이, 상황에 따라 사용해야 할 추가 클래스 로더 (호출원의 스택상의 로더등)를 프로바이더 구현에 제공하는 경우에, 이 메소드를 사용합니다. 일반적으로, 프로바이더 구현은, 지정된 <code>defaultLoader</code> 를 사용해 지정된 클래스의 해결을 시도한 후에, 코드 베이스 URL 패스로부터의 클래스의 해결을 시도합니다.

 <p>이 메소드는, 프로바이더 인스턴스의 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>RMIClassLoaderSpi.loadClass(String, String, ClassLoader)</CODE></A>  메소드에 처리를 위양 합니다.  이 때,<code>codebase</code> 가 최초의 인수로서<code>name</code> 가 2 개째의 인수로서<code>defaultLoader</code> 가 3 개째의 인수로서 건네받습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>codebase</CODE> - 클래스의 로드원의 URL 의 리스트 (단락 문자는 스페이스), 또는 <code>null</code><DD><CODE>name</CODE> - 로드 대상 클래스의 이름<DD><CODE>defaultLoader</CODE> - 상황에 따라 사용하는 추가 클래스 로더, 또는 <code>null</code>
<DT><B>반환값:</B><DD>로드 된 클래스를 나타내는 <code>Class</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - <code>codebase</code> 가 <code>null</code> 이외로 한편 무효인 URL 를 포함하고 있는 경우, 또는 <code>codebase</code> 가 <code>null</code> 로 한편 클래스의 로드시에 사용된 프로바이더 고유 URL 가 무효인 경우
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스의 정의가 지정된 장소에 없었던 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="loadProxyClass(java.lang.String, java.lang.String[], java.lang.ClassLoader)"><!-- --></A> <H3>
loadProxyClass</H3>
<PRE>
public static <A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>loadProxyClass</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase,
                                      <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;interfaces,
                                      <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;defaultLoader)
                               throws <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 내의 클래스">ClassNotFoundException</A> ,
                                      <A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </PRE>
<DL>
<DD>지정된 이름을 가지는 인터페이스군을 구현한 동적 프록시 클래스 (<A HREF="../../../java/lang/reflect/Proxy.html" title="java.lang.reflect 안의 클래스"><CODE>Proxy</CODE></A>  를 참조)를, 지정된 코드 베이스 URL 패스로부터 로드합니다.

 <p>이러한 인터페이스의 해결은, 지정된 <code>codebase</code> 를 사용해 <A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A>  메소드 경유로 로드 된 클래스와 같은 방법으로 행해집니다.

 <p>이 메소드는, 프로바이더 인스턴스의 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#loadProxyClass(java.lang.String, java.lang.String[], java.lang.ClassLoader)"><CODE>RMIClassLoaderSpi.loadProxyClass(String, String[], ClassLoader)</CODE></A>  메소드에 처리를 위양 합니다.  이 때,<code>codebase</code> 가 최초의 인수로서<code>interfaces</code> 가 2 개째의 인수로서<code>defaultLoader</code> 가 3 개째의 인수로서 건네받습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>codebase</CODE> - 클래스의 로드원의 URL 의 리스트 (단락 문자는 스페이스), 또는 <code>null</code><DD><CODE>interfaces</CODE> - 프록시 클래스가 구현하는 인터페이스의 이름<DD><CODE>defaultLoader</CODE> - 상황에 따라 사용하는 추가 클래스 로더, 또는 <code>null</code>
<DT><B>반환값:</B><DD>지정된 인터페이스를 구현하는 동적 프록시 클래스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - <code>codebase</code> 가 <code>null</code> 이외로 한편 무효인 URL 를 포함하고 있는 경우, 또는 <code>codebase</code> 가 <code>null</code> 로 한편 클래스의 로드시에 사용된 프로바이더 고유 URL 가 무효인 경우
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 지정된 인터페이스의 정의중 한쪽이 지정된 장소에 발견되지 않는 경우, 또는 동적 프록시 클래스의 작성에 실패했을 경우 (<A HREF="../../../java/lang/reflect/Proxy.html#getProxyClass(java.lang.ClassLoader, java.lang.Class...)"><CODE>Proxy.getProxyClass(ClassLoader, Class[])</CODE></A>  가, 지정된 인터페이스 리스트에 대해서 <code>IllegalArgumentException</code> 를 throw 했을 때 등)<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getClassLoader(java.lang.String)"><!-- --></A> <H3>
getClassLoader</H3>
<PRE>
public static <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 내의 클래스">ClassLoader</A>  <B>getClassLoader</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase)
                                  throws <A HREF="../../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A> ,
                                         <A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </PRE>
<DL>
<DD>지정된 코드 베이스 URL 패스로부터 클래스를 로드하는 클래스 로더를 돌려줍니다.

 <p>반환되는 클래스 로더는,<A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A>  메소드가 같은 <code>codebase</code> 인수를 지정해 클래스를 로드할 때 사용하는 클래스 로더와 같습니다.
 
 <p>이 메소드는, 프로바이더 인스턴스의 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#getClassLoader(java.lang.String)"><CODE>RMIClassLoaderSpi.getClassLoader(String)</CODE></A>  메소드에 처리를 위양 합니다.  이 때,<code>codebase</code> 가 인수로서 건네받습니다.

 <p>시큐리티 매니저가 존재하는 경우는,<code>RuntimePermission("getClassLoader")</code> 액세스권을 사용해 <code>checkPermission</code> 메소드가 불려 가<code>SecurityException</code> 가 체크됩니다. 이 메소드의 프로바이더 구현은, 호출측 문맥이 코드 베이스 URL 패스내의 모든 URL 에 대한 액세스권을 가지고 있을지 어떨지에 임해서, 시큐리티 체크를 실시하는 일도 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>codebase</CODE> - 반환되는 클래스 로더가 로드하는 클래스가 포함되고 있는 URL 의 리스트 (단락 문자는 스페이스), 또는 <code>null</code>
<DT><B>반환값:</B><DD>지정된 코드 베이스 URL 패스로부터 클래스를 로드하는 클래스 로더
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - <code>codebase</code> 가 <code>null</code> 이외로 한편 무효인 URL 를 포함하고 있는 경우, 또는 <code>codebase</code> 가 <code>null</code> 로 한편 클래스 로더의 식별시에 사용된 프로바이더 고유 URL 가 무효인 경우
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재할 경우에, 그 <code>checkPermission</code> 메소드가 실패했을 경우. 또는, 호출측이 코드 베이스 URL 패스내의 모든 URL 에 대한 액세스권을 가지고 있지 않은 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getClassAnnotation(java.lang.Class)"><!-- --></A> <H3>
getClassAnnotation</H3>
<PRE>
public static <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getClassAnnotation</B>(<A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)</PRE>
<DL>
<DD>클래스 정의의 위치를 나타내는 주석 캐릭터 라인을 돌려줍니다. RMI 는 이것을 사용해, 지정된 클래스의 객체의 정렬화를 실시할 때에, 클래스 기술자에게 주석을 더합니다.
 
 <p>이 메소드는, 프로바이더 인스턴스의 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#getClassAnnotation(java.lang.Class)"><CODE>RMIClassLoaderSpi.getClassAnnotation(Class)</CODE></A>  메소드에 처리를 위양 합니다.  이 때,<code>cl</code> 가 인수로서 건네받습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cl</CODE> - 주석을 취득하는 대상의 클래스
<DT><B>반환값:</B><DD>정렬화시로 지정된 클래스에 주석을 더하기 위해서(때문에) 사용되는 캐릭터 라인, 또는 <code>null</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>cl</code> 가 <code>null</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultProviderInstance()"><!-- --></A> <H3>
getDefaultProviderInstance</H3>
<PRE>
public static <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스">RMIClassLoaderSpi</A>  <B>getDefaultProviderInstance</B>()</PRE>
<DL>
<DD>서비스 프로바이더 인터페이스 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스"><CODE>RMIClassLoaderSpi</CODE></A>  의 디폴트 프로바이더의 정규 인스턴스를 돌려줍니다. 시스템 프로퍼티 <code>java.rmi.server.RMIClassLoaderSpi</code> 가 정의되어 있지 않은 경우, 다음에 나타내는 <code>RMIClassLoader</code> 의 static 메소드는, 서비스 프로바이더 인스턴스로서 디폴트 프로바이더의 정규 인스턴스를 사용합니다.

 <ul>

<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.net.URL, java.lang.String)"><CODE>loadClass(URL, String)</CODE></A> 
<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A> 
<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>loadClass(String, String, ClassLoader)</CODE></A> 
<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadProxyClass(java.lang.String, java.lang.String[], java.lang.ClassLoader)"><CODE>loadProxyClass(String, String[], ClassLoader)</CODE></A> 
<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#getClassLoader(java.lang.String)"><CODE>getClassLoader(String)</CODE></A> 
<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#getClassAnnotation(java.lang.Class)"><CODE>getClassAnnotation(Class)</CODE></A> 

 </ul>



 <p>시큐리티 매니저가 존재하는 경우,<code>RuntimePermission("setFactory")</code> 액세스권을 사용해 <code>checkPermission</code> 메소드가 불려 가<code>SecurityException</code> 가 체크됩니다.

 <p>디폴트의 서비스 프로바이더 인스턴스는,<A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 안의 클래스"><CODE>RMIClassLoaderSpi</CODE></A>  를 다음과 같이 구현합니다.

 <blockquote>

 <p><b><A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#getClassAnnotation(java.lang.Class)"><CODE>getClassAnnotation</CODE></A> </b> 메소드는, 지정된 클래스 정의의 다운로드에 원격측이 사용하는 코드 베이스 URL 패스를 나타내는 <code>String</code> 를 돌려줍니다. 반환되는 캐릭터 라인의 형식은, 공백에서 단락지어진 URL 의 패스입니다.

반환되는 코드 베이스의 캐릭터 라인은, 다음에 나타내도록(듯이), 지정된 클래스에 정의되고 있는 클래스 로더에 따라서 다릅니다.

 <ul>

 <p><li>정의되고 있는 클래스 로더가 시스템 클래스 로더 (<A HREF="../../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>ClassLoader.getSystemClassLoader()</CODE></A>  를 참조), 시스템 클래스 로더의 부모 (인스톨 끝난 확장 클래스에 사용되는 로더 등), 또는 bootstrap 클래스 로더 (<code>null</code> 로 나타내진다)의 경우,<code>java.rmi.server.codebase</code> 프로퍼티의 값 (또는 이전에 캐쉬된 값)이 반환된다.  이 프로퍼티의 값이 설정되어 있지 않은 경우는,<code>null</code> 가 반환된다

 <p><li>정의되고 있는 클래스 로더가 <code>URLClassLoader</code> 의 인스턴스의 경우는, 로더의 <code>getURLs</code> 메소드 호출로부터 반환되는, 외부 형식의 URL 의 리스트 (단락 문자는 스페이스)가 반환된다. <code>URLClassLoader</code> 가 이 프로바이더에 의해 작성되어 그 <code>loadClass</code> 또는 <code>loadProxyClass</code> 메소드가 사용되는 경우, 관련하는 코드 베이스 캐릭터 라인을 취득하기 위한 액세스권은 필요없다. <code>URLClassLoader</code> 인스턴스가 이 프로바이더 이외에 작성되어 시큐리티 매니저가 존재하는 경우는,<code>getURLs</code> 메소드로부터 URL 가 돌려주어질 때마다,<code>openConnection(). getPermission()</code> 호출에 의해 반환된 액세스권을 사용해 시큐리티 매니저의 <code>checkPermission</code> 메소드가 불려 간다.  이러한 호출의 어느쪽이든으로 <code>SecurityException</code> 또는 <code>IOException</code> 가 throw 되었을 경우,<code>java.rmi.server.codebase</code> 프로퍼티의 값이 반환된다.  이 프로퍼티이 설정되어 있지 않은 경우는,<code>null</code> 가 반환된다

 <p><li>정의되고 있는 클래스 로더가 <code>URLClassLoader</code> 의 인스턴스가 아닌 경우,<code>java.rmi.server.codebase</code> 프로퍼티의 값 (또는 이전에 캐쉬된 값)이 반환된다.  이 프로퍼티이 설정되어 있지 않은 경우는,<code>null</code> 가 반환된다

 </ul>

 <p><code>codebase</code> 라는 이름의 <code>String</code> 파라미터 (공백에서 단락지어진 URL 의 리스트)를 취하는, 다음에 설명하는 각 메소드 구현에 대해, 메소드가 불려 갈 때마다 특정의 「코드 베이스 로더」를 관련지을 수 있습니다.  코드 베이스 로더는,<code>codebase</code> 인수와 현재의 thread의 문맥 클래스 로더 (<A HREF="../../../java/lang/Thread.html#getContextClassLoader()"><CODE>Thread.getContextClassLoader()</CODE></A>  를 참조)를 조합해 검색됩니다. 시큐리티 매니저가 존재하는 경우, 이 프로바이더는, 클래스 로더 인스턴스의 내부 테이블 (적어도 <A HREF="../../../java/net/URLClassLoader.html" title="java.net 안의 클래스"><CODE>URLClassLoader</CODE></A>  의 인스턴스를 포함한다)을 보관 유지합니다.  이 테이블의 키는, 부모의 클래스 로더와 코드 베이스 URL 패스 (URL 의 순서 첨부 리스트)의 페어입니다. <code>codebase</code> 인수가 <code>null</code> 의 경우, 코드 베이스 URL 패스는, 시스템 프로퍼티 <code>java.rmi.server.codebase</code> 의 값, 이전의 캐쉬된 값의 어느 쪽인가에 됩니다. 어느 코드 베이스 URL 패스가 있는 특정의 문맥내에서 이하의 몇개의 메소드의 호출의 <code>codebase</code> 인수로서 건네받았을 경우, 테이블내의 로더 가운데, 패스가 지정된 코드 베이스 URL 패스, 부모가 현재 thread의 문맥 클래스 로더인 것 같은 로더가, 코드 베이스 로더가 됩니다. 그러한 로더가 존재하지 않는 경우는, 작성되어 테이블에 추가됩니다. 다만, 이 테이블은, 도달 불가능한 로더와 그 로더에 정의되고 있는 클래스가 가베지 컬렉트되도록(듯이), 로더에의 강참조를 보관 유지하지 않습니다. 시큐리티 매니저가 존재하지 않을 때에 신뢰되지 않는 코드가 가상 머신에 암묵적으로 로드 되지 않게 하기 위해서, 시큐리티 매니저가 설정되어 있지 않은 경우는, 코드 베이스 로더는 현재의 thread의 문맥 클래스 로더가 됩니다 (지정된 코드 베이스 URL 패스는 무시되어 원격 클래스를 로드할 수 없게 된다).

 <p><b><A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#getClassLoader(java.lang.String)"><CODE>getClassLoader</CODE></A> </b> 메소드는, 지정된 코드 베이스 URL 패스의 코드 베이스 로더를 돌려줍니다. 시큐리티 매니저가 존재하는 경우, 호출측 문맥에 코드 베이스 URL 패스내의 모든 URL 에 대한 액세스권이 없을 때는,<code>SecurityException</code> 가 throw 됩니다.

 <p><b><A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>loadClass</CODE></A> </b> 메소드는, 지정된 이름의 클래스를 다음의 방법으로 로드를 시도합니다.

 <blockquote>

<code>defaultLoader</code> 인수가 <code>null</code> 가 아닌 경우는, 우선 <code>defaultLoader</code> 를 사용해, 지정된 <code>name</code> 의 클래스를 로드하려고 합니다. 예를 들어, 다음과 같이 평가합니다.

 <pre>
Class.forName(name, false, defaultLoader)
 </pre>

클래스를 <code>defaultLoader</code> 로부터 로드할 수 있었을 경우, 그 클래스가 돌려주어집니다. <code>ClassNotFoundException</code> 이외의 예외가 throw 되었을 경우는, 그 예외가 호출해 측에 throw 됩니다.

 <p>다음에,<code>loadClass</code> 메소드가, 지정된 코드 베이스 URL 패스의 코드 베이스 로더를 사용해, 지정된 <code>name</code> 의 클래스의 로드를 시도합니다. 시큐리티 매니저가 존재하는 경우, 호출측 문맥에는 코드 베이스 URL 패스내의 모든 URL 에 대한 액세스권이 필요합니다.  액세스권이 없는 경우는, 코드 베이스 로더 대신에, 현재의 thread의 문맥 클래스 로더가 사용됩니다.

 </blockquote>

 <p><b><A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#loadProxyClass(java.lang.String, java.lang.String[], java.lang.ClassLoader)"><CODE>loadProxyClass</CODE></A> </b> 메소드는, 다음의 방법으로, 지정된 인터페이스의 동적 프록시 클래스를 돌려줍니다.

 <blockquote>

 <p><code>defaultLoader</code> 인수가 <code>null</code> 이외로, 그 로더를 사용해 지정된 인터페이스를 모두 해결할 수 있는 경우

 <ul>

<li>해결된 인터페이스가 모두 <code>public</code> 의 경우는, 우선 <A HREF="../../../java/lang/reflect/Proxy.html#getProxyClass(java.lang.ClassLoader, java.lang.Class...)"><CODE>Proxy.getProxyClass</CODE></A>  를 사용해, 코드 베이스 로더로부터 그 인터페이스의 동적 프록시 클래스를 취득하려고 한다. <code> IllegalArgumentException</code> 가 throw 되었을 경우는,<code>defaultLoader</code> 로부터 그 인터페이스의 동적 프록시 클래스를 취득하려고 한다. 어느 쪽의 경우도 <code>IllegalArgumentException</code> 가 throw 되었을 때는,<code>ClassNotFoundException</code> 가 throw 된다. 다른 예외가 throw 되었을 경우, 그 예외는 호출해 측에 throw 된다

<li>해결된 인터페이스가 <code>public</code> 이외의 경우, 그것들이 모두 같은 클래스 로더에 정의되고 있을 때는, 그 로더로부터 그 인터페이스의 동적 프록시 클래스를 취득하려고 한다

<li>상기 이외의 경우는,<code>LinkageError</code> 가 throw 된다 (지정된 인터페이스를 모두 구현하는 클래스는 어느 로더에도 정의할 수 없기 때문에)

 </ul>

 <p>지정된 모든 인터페이스를 코드 베이스 로더를 사용해 해결할 수 있는 경우

 <ul>

<li>해결된 인터페이스가 모두 <code>public</code> 의 경우는, 그 인터페이스의 동적 프록시 클래스를 코드 베이스 로더로부터 취득하려고 한다. <code>IllegalArgumentException</code> 가 throw 되었을 경우는,<code>ClassNotFoundException</code> 가 throw 된다

<li>해결된 인터페이스가 <code>public</code> 이외의 경우, 그것들이 모두 같은 클래스 로더에 정의되고 있을 때는, 그 로더로부터 그 인터페이스의 동적 프록시 클래스를 취득하려고 한다

<li>상기 이외의 경우는,<code>LinkageError</code> 가 throw 된다 (지정된 인터페이스를 모두 구현하는 클래스는 어느 로더에도 정의할 수 없기 때문에)

 </ul>

 <p>상기 이외의 경우, 해결할 수 없었던 지정 인터페이스에 대해,<code>ClassNotFoundException</code> 가 throw 됩니다.

 </blockquote>

 </blockquote>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>디폴트의 서비스 프로바이더의 정규의 인스턴스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재하는 경우에, 그 <code>checkPermission</code> 메소드 호출해에 실패했을 때<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSecurityContext(java.lang.ClassLoader)"><!-- --></A> <H3>
getSecurityContext</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public static <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getSecurityContext</B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader)</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>대체는 없습니다. Java 2 플랫폼 1.2 이후의 RMI 에서는, 클래스 로더의 시큐리티 문맥을 취득하기 위해서 이 메소드를 사용하지 않습니다</I>
<P>
<DD>지정된 클래스 로더의 시큐리티 문맥을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>loader</CODE> - 시큐리티 문맥의 취득원의 클래스 로더
<DT><B>반환값:</B><DD>시큐리티 문맥<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/SecurityManager.html#getSecurityContext()"><CODE>SecurityManager.getSecurityContext()</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/RMIClassLoader.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/rmi/server/RemoteStub.html" title="java.rmi.server 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/rmi/server/RMIClassLoader.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="RMIClassLoader.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
