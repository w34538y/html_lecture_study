<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:57:32 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
URL (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="URL (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/URL.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/net/URISyntaxException.html" title="java.net 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/net/URLClassLoader.html" title="java.net 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/net/URL.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="URL.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.net</FONT>
<BR>
클래스 URL</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.net.URL</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public final class <B>URL</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
<code>URL</code> 클래스는, Uniform Resource Locator (유니폼 자원 locator), 즉 World Wide Web 상의 「자원」에의 포인터를 나타냅니다. 자원은, 파일이나 디렉토리와 같이 단순한 것임도, 데이타베이스나 검색 엔진에 대한 쿼리 등, 보다 복잡한 객체에의 참조인 일도 있습니다. URL 의 종류나 형식의 상세한 것에 대하여는, 다음을 참조해 주세요.
 <blockquote>
<a href="http://www.socs.uts.edu.au/MosaicDocs-old/url-primer.html"><i>http://www.socs.uts.edu.au/MosaicDocs-old/url-primer.html</i></a> 
 </blockquote>
 <p>
일반적으로, URL 는 몇개의 부분 으로 분해할 수 있습니다. 앞의 예의 URL 는, 사용해야 할 프로토콜이 <code>http</code> (HyperText Transfer Protocol)인 것으로,<code>www.socs.uts.edu.au</code> 라는 이름의 호스트 머신상에 정보가 존재하고 있는 것을 나타내고 있습니다. 그 호스트 머신상의 정보에는,<code>/MosaicDocs-old/url-primer.html</code> 라는 이름이 붙일 수 있고 있습니다. 호스트 머신상에 있어서의 이 이름의 정확한 의미는, 프로토콜과 호스트의 양쪽 모두에 의존합니다. 일반적으로는 정보는 파일내에 보존되고 있습니다만, 동적으로 생성되는 경우도 있습니다. URL 의 이러한 부분은 패스 컴포넌트로 불립니다. <i></i> &nbsp;<p>
URL 에는 옵션으로 「포트」를 지정할 수 있습니다. 이것은, TCP 접속의 확립처가 되는, 원격 호스트 머신상의 포트 번호입니다. 포트를 지정하지 않았던 경우는, 대신에 프로토콜의 디폴트 포트가 사용됩니다. 예를 들어,<code>http</code> 의 디폴트 포트는 <code>80</code> 입니다. 다음과 같이 다른 포트를 지정할 수도 있습니다.
 <blockquote><pre>
     http://www.socs.uts.edu.au:80/MosaicDocs-old/url-primer.html
 </pre></blockquote>
 <p>
<code>URL</code> 의 구문은,<a  href="http://www.ietf.org/rfc/rfc2396.txt">「RFC&nbsp;2396: Uniform Resource Identifiers (URI): Generic Syntax」</a>  로 정의되어<a  href="http://www.ietf.org/rfc/rfc2732.txt">「RFC&nbsp;2732: Format for Literal IPv6 Addresses in URLs」</a>  로 수정되고 있습니다. 리터럴 IPv6 주소 형식에서는 스코프 ID 도 지원됩니다. 스코프 ID 의 구문이나 사용 방법에 대해서는,<a href="Inet6Address.html#scoped">여기</a>를 참조해 주세요.  &nbsp;<p>
URL 에는 「fragment」( 「ref」또는 「참조 (reference)」라고도 부른다)를 추가할 수 있습니다. fragment는, 샤프 기호 문자 「#」이라고 거기에 계속되는 몇개의 문자에 의해 나타납니다. 다음에 예를 나타냅니다.
 <blockquote><pre>
     http://java.sun.com/index.html#chapter1
 </pre></blockquote>
 <p>
본래는, 이 fragment는 URL 의 일부에서는 없습니다. 예를 들어, 위에 나타낸 fragment는, 지정된 자원을 취득한 뒤, 그 문서 중(안)에서 <code>chapter1</code> 라고 하는 태그가 붙어 있는 부분을 어플리케이션에 의한 처리의 대상으로 하는 것을 나타냅니다. 태그의 의미는 자원에 따라서 다릅니다.  &nbsp;<p>
어플리케이션은 「상대 URL」를 지정할 수도 있습니다. 이 URL 에는, 다른 URL 를 기준으로서 자원을 검색하는데 필요한 정보 밖에 포함되어 있지 않습니다. 상대 URL 는 HTML 페이지내에서 자주(잘) 사용됩니다. 예를 들어, 다음의 URL 가 있다고 합니다.
 <blockquote><pre>
     http://java.sun.com/index.html
 </pre></blockquote>
이 HTML 페이지안에 다음의 상대 URL 가 포함되어 있다고 합니다.
 <blockquote><pre>
     FAQ.html
 </pre></blockquote>
이것은 다음의 URL 의 단축형이라고 보여집니다.
 <blockquote><pre>
     http://java.sun.com/FAQ.html
 </pre></blockquote>
 <p>
상대 URL 에서는, URL 의 모든 컴퍼넌트를 지정할 필요는 없습니다. 프로토콜이나 호스트명, 포트 번호를 생략 했을 경우에는, 모든 컴퍼넌트가 지정되고 있는 URL 로부터 값이 상속됩니다. 파일 컴퍼넌트는 지정하지 않으면 안됩니다. 옵션지정의 fragment는 상속되지 않습니다.  &nbsp;<p>
URL 클래스 자체가 RFC2396 에 정의된 이스케이프 기구에 따라 URL 컴퍼넌트의 encode나 디코드를 실시할 것은 없습니다. URL 의 호출전에 이스케이프의 필요한 모든 필드를 encode 해 두는 것은, 호출원의 책임입니다. URL 로부터 반환된 모든 이스케이프가 끝난 필드를 디코드하는 일도, 같습니다. 게다가 URL 는, URL 이스케이프의 지식을 가지지 않기 때문에, 같은 URL 의 encode 된 형식과 디코드된 형식의 등가성을 판단할 수 없습니다. 예를 들어, 다음의 2 개의 URL 가 있다고 합니다. <br>
<pre>    http://foo.com/hello world/ 와 http://foo.com/hello%20world</pre>
이것들은, 서로 동일하지 않다고 보입니다.  &nbsp;<p>
<A HREF="../../java/net/URI.html" title="java.net 안의 클래스"><CODE>URI</CODE></A>  클래스는 특정의 상황에 있어, 그 컴퍼넌트 필드에 대해서 이스케이프 처리를 실행하는 것에 주의해 주세요.. URL 의 encode와 디코드를 관리할 때의 추천의 방법은,<A HREF="../../java/net/URI.html" title="java.net 안의 클래스"><CODE>URI</CODE></A>  를 사용해, 이것들 2 개의 클래스간의 변환을 <A HREF="../../java/net/URL.html#toURI()"><CODE>toURI()</CODE></A>  와 <A HREF="../../java/net/URI.html#toURL()"><CODE>URI.toURL()</CODE></A>  를 사용해 실시하는 것입니다.  &nbsp;<p>
<A HREF="../../java/net/URLEncoder.html" title="java.net 안의 클래스"><CODE>URLEncoder</CODE></A>  클래스와 <A HREF="../../java/net/URLDecoder.html" title="java.net 안의 클래스"><CODE>URLDecoder</CODE></A>  클래스를 사용할 수도 있습니다만, 이것들은 HTML 형식의 인코딩 전용입니다. 또, 이 인코딩은, RFC2396 로 정의되고 있는 인코딩 방식과 같은 것이 아닙니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../serialized-form.html#java.net.URL">직렬화 된 형식</A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/net/URL.html#URL(java.lang.String)">URL</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;spec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>String</code> 표현으로부터 <code>URL</code> 객체를 생성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/net/URL.html#URL(java.lang.String, java.lang.String, int, java.lang.String)">URL</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;protocol,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
    int&nbsp;port,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;file)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>protocol</code>,<code>host</code>,<code>port</code> 번호, 및 <code>file</code> 로부터 <code>URL</code> 객체를 생성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/net/URL.html#URL(java.lang.String, java.lang.String, int, java.lang.String, java.net.URLStreamHandler)">URL</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;protocol,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
    int&nbsp;port,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;file,
    <A HREF="../../java/net/URLStreamHandler.html" title="java.net 안의 클래스">URLStreamHandler</A> &nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>protocol</code>,<code>host</code>,<code>port</code> 번호,<code>file</code>, 및 <code>handler</code> 로부터 <code>URL</code> 객체를 생성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/net/URL.html#URL(java.lang.String, java.lang.String, java.lang.String)">URL</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;protocol,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;file)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>protocol</code> 명,<code>host</code> 명, 및 <code>file</code> 명으로부터 URL 를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/net/URL.html#URL(java.net.URL, java.lang.String)">URL</A> </B>(<A HREF="../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;context,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;spec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 문맥내의 지정된 스펙으로 구문 분석 하는 것에 의해, URL 를 생성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/net/URL.html#URL(java.net.URL, java.lang.String, java.net.URLStreamHandler)">URL</A> </B>(<A HREF="../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;context,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;spec,
    <A HREF="../../java/net/URLStreamHandler.html" title="java.net 안의 클래스">URLStreamHandler</A> &nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 문맥내의 지정된 핸들러로, 지정된 스펙을 구문 분석 해 URL 를 생성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#equals(java.lang.Object)">equals</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URL 와 다른 객체가 동일한지 어떤지를 비교합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#getAuthority()">getAuthority</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>URL</code> 의 기관 부분을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#getContent()">getContent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URL 의 컨텐츠를 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#getContent(java.lang.Class[])">getContent</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> []&nbsp;classes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URL 의 컨텐츠를 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#getDefaultPort()">getDefaultPort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>URL</code> 에 관련하는 프로토콜의 디폴트의 포트 번호를 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#getFile()">getFile</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>URL</code> 의 파일명을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#getHost()">getHost</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;해당하는 경우, 이 <code>URL</code> 의 호스트명을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#getPath()">getPath</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>URL</code> 의 패스 부분을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#getPort()">getPort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>URL</code> 의 포트 번호를 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#getProtocol()">getProtocol</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>URL</code> 의 프로토콜명을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#getQuery()">getQuery</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>URL</code> 의 쿼리부분을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#getRef()">getRef</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>URL</code> 의 엥커 ( 「참조」라고도 불린다)를 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#getUserInfo()">getUserInfo</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>URL</code> 의 사용자 정보부분을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#hashCode()">hashCode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;해시 테이블의 인덱스부에 적절한 int 치를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URLConnection.html" title="java.net 내의 클래스">URLConnection</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#openConnection()">openConnection</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>URL</code> 가 참조하는 원격 객체에의 접속을 나타내는 <code>URLConnection</code> 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URLConnection.html" title="java.net 내의 클래스">URLConnection</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#openConnection(java.net.Proxy)">openConnection</A> </B>(<A HREF="../../java/net/Proxy.html" title="java.net 안의 클래스">Proxy</A> &nbsp;proxy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;openConnection()와 거의 같습니다만, 접속의 확립이 지정된 프록시 경유로 행해지는 점이 다릅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#openStream()">openStream</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>URL</code> 에의 접속을 오픈해, 그 접속으로부터 read를 행하기 위한 <code>InputStream</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#sameFile(java.net.URL)">sameFile</A> </B>(<A HREF="../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fragment 컴퍼넌트 이외의 2 개의 URL 를 비교합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#set(java.lang.String, java.lang.String, int, java.lang.String, java.lang.String)">set</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;protocol,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
    int&nbsp;port,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;file,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL 의 필드를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#set(java.lang.String, java.lang.String, int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)">set</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;protocol,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
    int&nbsp;port,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;authority,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;userInfo,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;path,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;query,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL 의, 지정된  8 필드를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#setURLStreamHandlerFactory(java.net.URLStreamHandlerFactory)">setURLStreamHandlerFactory</A> </B>(<A HREF="../../java/net/URLStreamHandlerFactory.html" title="java.net 안의 인터페이스">URLStreamHandlerFactory</A> &nbsp;fac)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;어플리케이션의 <code>URLStreamHandlerFactory</code> 를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#toExternalForm()">toExternalForm</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>URL</code> 의 캐릭터 라인 표현을 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>URL</code> 의 캐릭터 라인 표현을 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URL.html#toURI()">toURI</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URL 와 등가인 <A HREF="../../java/net/URI.html" title="java.net 안의 클래스"><CODE>URI</CODE></A>  를 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="URL(java.lang.String, java.lang.String, int, java.lang.String)"><!-- --></A> <H3>
URL</H3>
<PRE>
public <B>URL</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;protocol,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
           int&nbsp;port,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;file)
    throws <A HREF="../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A> </PRE>
<DL>
<DD>지정된 <code>protocol</code>,<code>host</code>,<code>port</code> 번호, 및 <code>file</code> 로부터 <code>URL</code> 객체를 생성합니다. <p>

<code>host</code> 는, 호스트명, 리터럴 IP 주소의 어느쪽이든으로서 표현할 수 있습니다. IPv6 리터럴 주소를 사용하는 경우는,<a  href="http://www.ietf.org/rfc/rfc2732.txt">「RFC&nbsp;2732」</a>로 지정되고 있도록(듯이), 주소를 꺽쇄묶음 (<tt>「[」</tt>과<tt>「]」</tt>)으로 둘러쌀 필요가 있습니다. 다만,<a  href="http://www.ietf.org/rfc/rfc2373.txt">「RFC&nbsp;2373: IP Version 6 Addressing Architecture」</a>로 정의되고 있는 리터럴 IPv6 주소 형식도, 사용 가능합니다. <p>

<code>port</code> 번호 <code>-1</code> 의 지정은, URL 가 프로토콜의 디폴트의 포트를 사용하는 것을 나타냅니다. <p>

지정된 프로토콜로 최초로 URL 객체를 생성할 경우에는, 그 프로토콜을 위한 스트림 프로토콜 핸들러 객체가 생성됩니다. 이 스트림 프로토콜 핸들러 객체는,<code>URLStreamHandler</code> 클래스의 인스턴스입니다.
 <ol>
<li>이전에 어플리케이션이 <code>URLStreamHandlerFactory</code> 의 인스턴스를 스트림 핸들러 팩토리로서 설정해 있는 경우는, 그 인스턴스의 <code>createURLStreamHandler</code> 메소드가 프로토콜 캐릭터 라인을 인수로서 불려 가, 스트림 프로토콜 핸들러를 작성한다
<li>아직 <code>URLStreamHandlerFactory</code> 가 설정되어 있지 않은 경우, 혹은 팩토리의 <code>createURLStreamHandler</code> 메소드가 <code>null</code> 를 돌려주었을 경우는, 생성자 이 다음의 시스템 프로퍼티의 값을 찾는다
     <blockquote><pre>
         java.protocol.handler.pkgs
     </pre></blockquote>
이 시스템 프로퍼티의 값이 <code>null</code> 가 아니면, 값은, 수직 slash 문자 「<code>|</code>」으로 단락지어진, 패키지의 리스트로서 해석된다. 생성자 은 다음의 이름을 가지는 클래스를 로드하려고 한다.
     <blockquote><pre>
         &lt;<i>package</i>&gt;. &lt;<i>protocol</i>&gt;.Handler
     </pre></blockquote>
여기서, &lt;<i>package</i>&gt; 에는 패키지의 이름이 들어가, &lt;<i>protocol</i>&gt; 에는 프로토콜의 이름이 들어간다. 이 클래스가 존재하지 않는 경우, 혹은 클래스는 존재해도 그것이 <code>URLStreamHandler</code> 의 서브 클래스가 아닌 경우에는, 리스트에 있는 다음의 패키지를 시험하게 된다.
<li>이상의 순서에서도 프로토콜 핸들러가 발견되지 않았던 경우, 생성자 은 시스템의 디폴트 패키지로부터 로드하려고 한다.
     <blockquote><pre>
         &lt;<i>system default package</i>&gt;. &lt;<i>protocol</i>&gt;.Handler
     </pre></blockquote>
이 클래스가 존재하지 않는 경우, 혹은 클래스는 존재해도 그것이 <code>URLStreamHandler</code> 의 서브 클래스가 아닌 경우에는,<code>MalformedURLException</code> 가 throw 된다.
 </ol>

 <p>다음의 프로토콜의 프로토콜 핸들러는, 검색 패스상에 존재하는 것이 보증되고 있습니다.
 <blockquote><pre>
     http, https, ftp, file, and jar
 </pre></blockquote>
그 외의 프로토콜의 프로토콜 핸들러도 사용 가능하게 되어 있을 가능성이 있습니다.

 <p>이 생성자 에 의한 입력의 검증은 실행되지 않습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>protocol</CODE> - 사용하는 프로토콜명<DD><CODE>host</CODE> - 호스트명<DD><CODE>port</CODE> - 호스트상에서의 포트 번호<DD><CODE>file</CODE> - 호스트상의 파일
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - 미지의 프로토콜로서 지정되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/System.html#getProperty(java.lang.String)"><CODE>System.getProperty(java.lang.String)</CODE></A> , 
<CODE>java.net.URL#setURLStreamHandlerFactory(</CODE>, 
<A HREF="../../java/net/URLStreamHandler.html" title="java.net 안의 클래스"><CODE>URLStreamHandler</CODE></A> , 
<CODE>java.net.URLStreamHandlerFactory#createURLStreamHandler(</CODE></DL>
</DL>
<HR>

<A NAME="URL(java.lang.String, java.lang.String, java.lang.String)"><!-- --></A> <H3>
URL</H3>
<PRE>
public <B>URL</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;protocol,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;file)
    throws <A HREF="../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A> </PRE>
<DL>
<DD>지정된 <code>protocol</code> 명,<code>host</code> 명, 및 <code>file</code> 명으로부터 URL 를 작성합니다. 지정된 프로토콜의 디폴트 포트가 사용됩니다.  &nbsp;<p>
이 메소드의 기능은, 인수에 <code>protocol</code>,<code>host</code>,<code>-1</code>,<code>file</code> 를 지정해 4 개의 인수를 받는 생성자 을 호출하는 것과 같습니다.

이 생성자 에 의한 입력의 검증은 실행되지 않습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>protocol</CODE> - 사용하는 프로토콜명<DD><CODE>host</CODE> - 호스트명<DD><CODE>file</CODE> - 호스트상의 파일
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - 미지의 프로토콜로서 지정되었을 경우<DT><B>관련 항목:</B><DD><CODE>java.net.URL#URL(java.lang.String, java.lang.String,</CODE></DL>
</DL>
<HR>

<A NAME="URL(java.lang.String, java.lang.String, int, java.lang.String, java.net.URLStreamHandler)"><!-- --></A> <H3>
URL</H3>
<PRE>
public <B>URL</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;protocol,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
           int&nbsp;port,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;file,
           <A HREF="../../java/net/URLStreamHandler.html" title="java.net 안의 클래스">URLStreamHandler</A> &nbsp;handler)
    throws <A HREF="../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A> </PRE>
<DL>
<DD>지정된 <code>protocol</code>,<code>host</code>,<code>port</code> 번호,<code>file</code>, 및 <code>handler</code> 로부터 <code>URL</code> 객체를 생성합니다. <code>port</code> 번호 <code>-1</code> 의 지정은, URL 가 프로토콜의 디폴트의 포트를 사용하는 것을 나타냅니다. <code>handler</code> 에 <code>null</code> 를 지정했을 경우, 그것은, java.net.URL#URL(java.lang.String, java.lang.String, int, java.lang.String)로 개설한 프로토콜의 디폴트 스트림 핸들러를, URL 가 사용해야 하는 것을 나타냅니다.

 <p>핸들러가 null 는 아니고, 시큐리티 매니저가 존재하는 경우,<code>NetPermission("specifyStreamHandler")</code> 액세스권을 지정해 시큐리티 매니저의 <code>checkPermission</code> 메소드가 불려 갑니다. 그 결과, SecurityException 가 발생하는 일이 있습니다.

이 생성자 에 의한 입력의 검증은 실행되지 않습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>protocol</CODE> - 사용하는 프로토콜명<DD><CODE>host</CODE> - 호스트명<DD><CODE>port</CODE> - 호스트상에서의 포트 번호<DD><CODE>file</CODE> - 호스트상의 파일<DD><CODE>handler</CODE> - URL 의 스트림 핸들러
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - 미지의 프로토콜로서 지정되었을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 시큐리티 매니저의 <code>checkPermission</code> 메소드가 스트림 핸들러의 명시적인 지정을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/System.html#getProperty(java.lang.String)"><CODE>System.getProperty(java.lang.String)</CODE></A> , 
<CODE>java.net.URL#setURLStreamHandlerFactory(</CODE>, 
<A HREF="../../java/net/URLStreamHandler.html" title="java.net 안의 클래스"><CODE>URLStreamHandler</CODE></A> , 
<CODE>java.net.URLStreamHandlerFactory#createURLStreamHandler(</CODE>, 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> , 
<A HREF="../../java/net/NetPermission.html" title="java.net 안의 클래스"><CODE>NetPermission</CODE></A> </DL>
</DL>
<HR>

<A NAME="URL(java.lang.String)"><!-- --></A> <H3>
URL</H3>
<PRE>
public <B>URL</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;spec)
    throws <A HREF="../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A> </PRE>
<DL>
<DD><code>String</code> 표현으로부터 <code>URL</code> 객체를 생성합니다.  &nbsp;<p>
이 생성자 은, 1 번째의 인수에 <code>null</code> 를 지정해, 인수가 2 개의 생성자 을 호출하는 것과 같습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>spec</CODE> - URL 로서 구문 분석 되는 <code>String</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - 캐릭터 라인으로 지정된 프로토콜이 미지인 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/URL.html#URL(java.net.URL, java.lang.String)"><CODE>URL(java.net.URL, java.lang.String)</CODE></A> </DL>
</DL>
<HR>

<A NAME="URL(java.net.URL, java.lang.String)"><!-- --></A> <H3>
URL</H3>
<PRE>
public <B>URL</B>(<A HREF="../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;context,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;spec)
    throws <A HREF="../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A> </PRE>
<DL>
<DD>지정된 문맥내의 지정된 스펙으로 구문 분석 하는 것에 의해, URL 를 생성합니다.

새로운 URL 는, RFC2396 의 「Uniform Resource Identifiers : Generic * Syntax」의 설명에 따라, 지정된 문맥 URL 와 spec 인수로부터 작성됩니다.
 <blockquote><pre>
          &lt;scheme&gt;://&lt;authority&gt;&lt;path&gt;? &lt;query&gt;#&lt;fragment&gt;
 </pre></blockquote>
참조는 schema, 기관, 패스, 쿼리, 및 fragment의 각 부분에 구문 분석 됩니다. 패스 컴포넌트가 빈 상태(empty)에서 schema, 기관, 및 쿼리의 각 컴퍼넌트가 미정도리의 경우, 새로운 URL 가 현재의 문서에의 참조가 됩니다. 그 이외의 경우는, 스펙의 fragment 부분과 쿼리부분이 새로운 URL 에 사용됩니다.  &nbsp;<p>
지정된 스펙으로 schema 컴퍼넌트가 정의되어 그 schema 컴퍼넌트가 문맥의 schema와 일치하지 않는 경우, 스펙인 만큼 기초를 두는 절대 URL 로서 새로운 URL 가 생성됩니다. 그렇지 않은 경우는, schema 컴퍼넌트는 문맥 URL 를 상속합니다.  &nbsp;<p>
기관 컴퍼넌트가 스펙에 있는 경우에는, 스펙은 절대적인 것으로 해 다루어져 스펙의 기관과 패스는 문맥의 기관과 패스를 치환합니다. 스펙에 기관 컴퍼넌트가 없는 경우, 새로운 URL 의 기관은 문맥을 상속합니다.  &nbsp;<p>
스펙의 패스 컴포넌트가 slash 문자 &quot;/&quot; 로 시작되는 경우, 패스는 절대적인 것으로 해 다루어져 스펙의 패스가 문맥의 패스를 치환합니다.  &nbsp;<p>
그 이외의 경우, RFC2396 로 설명되고 있도록(듯이), 패스는 상대 패스로 해서 다루어져 문맥 패스에 추가됩니다. 또, 이 경우, 「..」 및 「.」에 의해 행해진 디렉토리 변경을 삭제하는 것으로, 패스는 정규화됩니다.  &nbsp;<p>
URL 구문 분석의 상세한 설명에 대해서는, RFC2396 를 참조해 주세요.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>context</CODE> - 스펙을 구문 분석 하는 문맥<DD><CODE>spec</CODE> - URL 로서 구문 분석 되는 <code>String</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - 프로토콜이 지정되어 있지 않은지, 미지의 프로토콜이 발견되었을 경우<DT><B>관련 항목:</B><DD><CODE>java.net.URL#URL(java.lang.String, java.lang.String,</CODE>, 
<A HREF="../../java/net/URLStreamHandler.html" title="java.net 안의 클래스"><CODE>URLStreamHandler</CODE></A> , 
<CODE>java.net.URLStreamHandler#parseURL(java.net.URL,</CODE></DL>
</DL>
<HR>

<A NAME="URL(java.net.URL, java.lang.String, java.net.URLStreamHandler)"><!-- --></A> <H3>
URL</H3>
<PRE>
public <B>URL</B>(<A HREF="../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;context,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;spec,
           <A HREF="../../java/net/URLStreamHandler.html" title="java.net 안의 클래스">URLStreamHandler</A> &nbsp;handler)
    throws <A HREF="../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A> </PRE>
<DL>
<DD>지정된 문맥내의 지정된 핸들러로, 지정된 스펙을 구문 분석 해 URL 를 생성합니다. 핸들러가 null 의 경우, 2 개의 인수를 취하는 생성자 과 같은 해석을 합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>context</CODE> - 스펙을 구문 분석 하는 문맥<DD><CODE>spec</CODE> - URL 로서 구문 분석 되는 <code>String</code><DD><CODE>handler</CODE> - URL 의 스트림 핸들러
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - 프로토콜이 지정되어 있지 않은지, 미지의 프로토콜이 발견되었을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 시큐리티 매니저의 <code>checkPermission</code> 메소드가 스트림 핸들러의 지정을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><CODE>java.net.URL#URL(java.lang.String, java.lang.String,</CODE>, 
<A HREF="../../java/net/URLStreamHandler.html" title="java.net 안의 클래스"><CODE>URLStreamHandler</CODE></A> , 
<CODE>java.net.URLStreamHandler#parseURL(java.net.URL,</CODE></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="set(java.lang.String, java.lang.String, int, java.lang.String, java.lang.String)"><!-- --></A> <H3>
set</H3>
<PRE>
protected void <B>set</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;protocol,
                   <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
                   int&nbsp;port,
                   <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;file,
                   <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;ref)</PRE>
<DL>
<DD>URL 의 필드를 설정합니다. 이것은 public 메소드는 아니기 때문에, URL 필드를 수정할 수 있는 것은 URLStreamHandlers 만입니다. 그 이외의 URL 는 정수입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>protocol</CODE> - 사용하는 프로토콜명<DD><CODE>host</CODE> - 호스트명<DD><CODE>port</CODE> - 호스트상에서의 포트 번호<DD><CODE>file</CODE> - 호스트상의 파일<DD><CODE>ref</CODE> - URL 의 내부 참조</DL>
</DD>
</DL>
<HR>

<A NAME="set(java.lang.String, java.lang.String, int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)"><!-- --></A> <H3>
set</H3>
<PRE>
protected void <B>set</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;protocol,
                   <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
                   int&nbsp;port,
                   <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;authority,
                   <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;userInfo,
                   <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;path,
                   <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;query,
                   <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;ref)</PRE>
<DL>
<DD>URL 의, 지정된  8 필드를 설정합니다. 이것은 public 메소드는 아니기 때문에, URL 필드를 수정할 수 있는 것은 URLStreamHandlers 만입니다. 그 이외의 URL 는 정수입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>protocol</CODE> - 사용하는 프로토콜명<DD><CODE>host</CODE> - 호스트명<DD><CODE>port</CODE> - 호스트상에서의 포트 번호<DD><CODE>authority</CODE> - URL 의 기관 부분<DD><CODE>userInfo</CODE> - 사용자명 및 패스워드<DD><CODE>path</CODE> - 호스트상의 파일<DD><CODE>ref</CODE> - URL 의 내부 참조<DD><CODE>query</CODE> - 이 URL 의 쿼리부분<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getQuery()"><!-- --></A> <H3>
getQuery</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getQuery</B>()</PRE>
<DL>
<DD>이 <code>URL</code> 의 쿼리부분을 가져옵니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>URL</code> 의 쿼리부분. 존재하지 않는 경우는 <CODE>null</CODE><DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPath()"><!-- --></A> <H3>
getPath</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getPath</B>()</PRE>
<DL>
<DD>이 <code>URL</code> 의 패스 부분을 가져옵니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>URL</code> 의 패스 부분. 존재하지 않는 경우는 빈 상태(empty)의 캐릭터 라인<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUserInfo()"><!-- --></A> <H3>
getUserInfo</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getUserInfo</B>()</PRE>
<DL>
<DD>이 <code>URL</code> 의 사용자 정보부분을 가져옵니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>URL</code> 의 사용자 정보부분. 존재하지 않는 경우는 <CODE>null</CODE><DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAuthority()"><!-- --></A> <H3>
getAuthority</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getAuthority</B>()</PRE>
<DL>
<DD>이 <code>URL</code> 의 기관 부분을 가져옵니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>URL</code> 의 기관 부분<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPort()"><!-- --></A> <H3>
getPort</H3>
<PRE>
public int <B>getPort</B>()</PRE>
<DL>
<DD>이 <code>URL</code> 의 포트 번호를 가져옵니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>포트 번호. 포트가 설정되어 있지 않은 경우는 -1</DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultPort()"><!-- --></A> <H3>
getDefaultPort</H3>
<PRE>
public int <B>getDefaultPort</B>()</PRE>
<DL>
<DD>이 <code>URL</code> 에 관련하는 프로토콜의 디폴트의 포트 번호를 가져옵니다. URL schema 또는 URL 의 URLStreamHandler 가 디폴트의 포트 번호를 정의하지 않는 경우는,-1 이 돌려주어집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>포트 번호<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getProtocol()"><!-- --></A> <H3>
getProtocol</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getProtocol</B>()</PRE>
<DL>
<DD>이 <code>URL</code> 의 프로토콜명을 가져옵니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>URL</code> 의 프로토콜</DL>
</DD>
</DL>
<HR>

<A NAME="getHost()"><!-- --></A> <H3>
getHost</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getHost</B>()</PRE>
<DL>
<DD>해당하는 경우, 이 <code>URL</code> 의 호스트명을 가져옵니다. 호스트명의 형식은 RFC 2732 에 준거합니다. 즉, 리터럴 IPv6 주소의 경우, 이 메소드는 꺽쇄묶음 (<tt>[</tt> 및 <tt>]</tt>)으로 둘러싸인 IPv6 주소를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>URL</code> 의 호스트명</DL>
</DD>
</DL>
<HR>

<A NAME="getFile()"><!-- --></A> <H3>
getFile</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getFile</B>()</PRE>
<DL>
<DD>이 <code>URL</code> 의 파일명을 가져옵니다. 반환되는 파일 부분은,<CODE>getQuery()</CODE> 의 값이 존재하는 경우에는, 그 값과 <CODE>getPath()</CODE> 의 값을 연결한 것 것과 같게 됩니다. 쿼리부분이 존재하지 않는 경우, 이 메소드와 <CODE>getPath()</CODE> 는 같은 결과를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>URL</code> 의 파일명. 존재하지 않는 경우는 빈 상태(empty)의 캐릭터 라인</DL>
</DD>
</DL>
<HR>

<A NAME="getRef()"><!-- --></A> <H3>
getRef</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getRef</B>()</PRE>
<DL>
<DD>이 <code>URL</code> 의 엥커 ( 「참조」라고도 불린다)를 가져옵니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>URL</code> 의 엥커 ( 「참조」라고도 불린다). 존재하지 않는 경우는 <CODE>null</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>이 URL 와 다른 객체가 동일한지 어떤지를 비교합니다. <p>

지정된 객체가 URL 가 아닌 경우, 이 메소드는 즉시 <code>false</code> 를 돌려줍니다. <p>

2 개의 URL 객체가 동일한 것은, 같은 프로토콜을 가져, 같은 호스트를 참조해, 호스트상의 포트 번호가 같아, 파일과 파일의 fragment가 같은 경우입니다. <p>

2 살의 호스트가 등가라고 보여지는 것은, 양쪽 모두의 호스트명이 같은 IP 주소에 해결되는지, 어느 쪽인가의 호스트명을 해결할 수 없는 경우는, 대문자 소문자에 관계없이 호스트명이 동일한지, 양쪽 모두의 호스트명이 null 에 동일한 경우입니다. <p>

호스트 비교에는 이름 해석이 필요해서, 이 조작은 블록 조작입니다.  <p>

주:<code>equals</code> 의 정의된 동작은, HTTP 의 가상 호스트와 일치하지 않는 것이 알려져 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 비교 대상의 URL
<DT><B>반환값:</B><DD>객체가 같은 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A> , 
<A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>해시 테이블의 인덱스부에 적절한 int 치를 작성합니다. <p>
 
해시 코드는 URL 비교에 관련하는 모든 URL 컴퍼넌트에 근거하고 있습니다. 따라서, 이 조작은 블록 조작입니다. <p>
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>URL</code> 에 사용하는 해시 코드<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#equals(java.lang.Object)"><CODE>Object.equals(java.lang.Object)</CODE></A> , 
<A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sameFile(java.net.URL)"><!-- --></A> <H3>
sameFile</H3>
<PRE>
public boolean <B>sameFile</B>(<A HREF="../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;other)</PRE>
<DL>
<DD>fragment 컴퍼넌트 이외의 2 개의 URL 를 비교합니다. <p>

fragment 컴퍼넌트를 고려하지 않고, 이 <code>URL</code> 와 <code>other</code> 인수가 동일한 경우는,<code>true</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>other</CODE> - 비교 대상의 <code>URL</code>
<DT><B>반환값:</B><DD>2 개의 URL 가 참조하는 원격 객체가 같은 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 <code>URL</code> 의 캐릭터 라인 표현을 구축합니다. 이 객체의 스트림 프로토콜 핸들러의 <code>toExternalForm</code>메소드를 호출하는 것에 의해 캐릭터 라인이 작성됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 객체의 캐릭터 라인 표현<DT><B>관련 항목:</B><DD><CODE>java.net.URL#URL(java.lang.String, java.lang.String, int,</CODE>, 
<A HREF="../../java/net/URLStreamHandler.html#toExternalForm(java.net.URL)"><CODE>URLStreamHandler.toExternalForm(java.net.URL)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toExternalForm()"><!-- --></A> <H3>
toExternalForm</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toExternalForm</B>()</PRE>
<DL>
<DD>이 <code>URL</code> 의 캐릭터 라인 표현을 구축합니다. 이 객체의 스트림 프로토콜 핸들러의 <code>toExternalForm</code>메소드를 호출하는 것에 의해 캐릭터 라인이 작성됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 객체의 캐릭터 라인 표현<DT><B>관련 항목:</B><DD><CODE>java.net.URL#URL(java.lang.String, java.lang.String,</CODE>, 
<A HREF="../../java/net/URLStreamHandler.html#toExternalForm(java.net.URL)"><CODE>URLStreamHandler.toExternalForm(java.net.URL)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toURI()"><!-- --></A> <H3>
toURI</H3>
<PRE>
public <A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A>  <B>toURI</B>()
          throws <A HREF="../../java/net/URISyntaxException.html" title="java.net 내의 클래스">URISyntaxException</A> </PRE>
<DL>
<DD>이 URL 와 등가인 <A HREF="../../java/net/URI.html" title="java.net 안의 클래스"><CODE>URI</CODE></A>  를 돌려줍니다. 이 메소드는,<code>new URI (this.toString())</code> 와 같이 기능합니다. &nbsp;<p>RFC 2396 에 준거한 URL 인스턴스는 반드시 URI 로 변환할 수 있는 것에 주의해 주세요. 다만, 엄밀하게 준거하고 있지 않는 URL 는, URI 로 변환할 수 없을 가능성이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URL 와 등가인 URI 인스턴스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/URISyntaxException.html" title="java.net 안의 클래스">URISyntaxException</A> </CODE> - 이 URL 의 형식이 RFC2396 에 엄밀하게 따르지 않기 때문에, URI 로 변환할 수 없는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="openConnection()"><!-- --></A> <H3>
openConnection</H3>
<PRE>
public <A HREF="../../java/net/URLConnection.html" title="java.net 내의 클래스">URLConnection</A>  <B>openConnection</B>()
                             throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><code>URL</code> 가 참조하는 원격 객체에의 접속을 나타내는 <code>URLConnection</code> 객체를 돌려줍니다.

 <p>이 URL 의 프로토콜 핸들러의 <code>openConnection</code> 메소드를 호출할 때마다, 새로운 접속이 열립니다.

 <p>HTTP 나 JAR 등의, URL 의 프로토콜에 대해서는, java.lang, java.io, java.util, 또는 java.net 의 패키지, 혹은 그 서브 패키지에 속하는 공개된 특수한 URLConnection 서브 클래스가 있습니다. 반환되는 접속은, 그 서브 클래스의 것이 됩니다. 예를 들어, HTTP 프로토콜에 대해서는 HttpURLConnection 가 돌려주어져 JAR 에 대해서는 JarURLConnection 가 돌려주어집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>URL 에의 <code>URLConnection</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 예외가 발생했을 경우<DT><B>관련 항목:</B><DD><CODE>java.net.URL#URL(java.lang.String, java.lang.String,</CODE>, 
<A HREF="../../java/net/URLConnection.html" title="java.net 안의 클래스"><CODE>URLConnection</CODE></A> , 
<A HREF="../../java/net/URLStreamHandler.html#openConnection(java.net.URL)"><CODE>URLStreamHandler.openConnection(java.net.URL)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="openConnection(java.net.Proxy)"><!-- --></A> <H3>
openConnection</H3>
<PRE>
public <A HREF="../../java/net/URLConnection.html" title="java.net 내의 클래스">URLConnection</A>  <B>openConnection</B>(<A HREF="../../java/net/Proxy.html" title="java.net 안의 클래스">Proxy</A> &nbsp;proxy)
                             throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>openConnection()와 거의 같습니다만, 접속의 확립이 지정된 프록시 경유로 행해지는 점이 다릅니다. 프록시 처리를 지원하지 않는 프로토콜 핸들러는, 프록시의 파라미터를 무시해, 일반적으로의 접속을 확립합니다.

이 메소드를 호출하면(자), 시스템의 디폴트의 ProxySelector 설정이 횡령됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>proxy</CODE> - 이 접속의 확립에 사용되는 프록시. 직접 접속을 실시하고 싶은 경우는 Proxy.NO_PROXY 를 지정해야 한다
<DT><B>반환값:</B><DD>URL 에의 <code>URLConnection</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 예외가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 프록시에 접속하는 권한을 호출해 원이 가지고 있지 않은 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 프록시가 null 일까 프록시의 형태가 올바르지 않은 경우에 throw 된다
<DD><CODE><A HREF="../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 프로토콜 핸들러를 구현하는 서브 클래스가 이 메소드를 지원하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><CODE>java.net.URL#URL(java.lang.String, java.lang.String,</CODE>, 
<A HREF="../../java/net/URLConnection.html" title="java.net 안의 클래스"><CODE>URLConnection</CODE></A> , 
<CODE>java.net.URLStreamHandler#openConnection(java.net.URL,</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="openStream()"><!-- --></A> <H3>
openStream</H3>
<PRE>
public final <A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A>  <B>openStream</B>()
                             throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 <code>URL</code> 에의 접속을 오픈해, 그 접속으로부터 read를 행하기 위한 <code>InputStream</code> 를 돌려줍니다. 이 메소드는 다음의 메소드의 단축형입니다.
 <blockquote><pre>
     openConnection(). getInputStream()
 </pre></blockquote>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>URL 접속으로부터 입력을 읽어들이기 위한 입력 스트림
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 예외가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/URL.html#openConnection()"><CODE>openConnection()</CODE></A> , 
<A HREF="../../java/net/URLConnection.html#getInputStream()"><CODE>URLConnection.getInputStream()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getContent()"><!-- --></A> <H3>
getContent</H3>
<PRE>
public final <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getContent</B>()
                        throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 URL 의 컨텐츠를 가져옵니다. 이 메소드는 다음의 메소드의 단축형입니다.
 <blockquote><pre>
     openConnection(). getContent()
 </pre></blockquote>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URL 의 컨텐츠
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 예외가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/URLConnection.html#getContent()"><CODE>URLConnection.getContent()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getContent(java.lang.Class[])"><!-- --></A> <H3>
getContent</H3>
<PRE>
public final <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getContent</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> []&nbsp;classes)
                        throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 URL 의 컨텐츠를 가져옵니다. 이 메소드는 다음의 메소드의 단축형입니다.
 <blockquote><pre>
     openConnection(). getContent(Class[])
 </pre></blockquote>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>classes</CODE> - Java 형의 배열
<DT><B>반환값:</B><DD>클래스의 배열로 지정된 형태가 최초로 일치한, 이 URL 의 컨텐츠 객체. 요구된 형태가 지원되어 있지 않은 경우는 null
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 예외가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/URLConnection.html#getContent(java.lang.Class[])"><CODE>URLConnection.getContent(Class[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setURLStreamHandlerFactory(java.net.URLStreamHandlerFactory)"><!-- --></A> <H3>
setURLStreamHandlerFactory</H3>
<PRE>
public static void <B>setURLStreamHandlerFactory</B>(<A HREF="../../java/net/URLStreamHandlerFactory.html" title="java.net 안의 인터페이스">URLStreamHandlerFactory</A> &nbsp;fac)</PRE>
<DL>
<DD>어플리케이션의 <code>URLStreamHandlerFactory</code> 를 설정합니다. 이 메소드는, 사용하는 Java 가상 머신으로 1 회 밖에 호출할 수 없습니다.

<p> <code>URLStreamHandlerFactory</code> 인스턴스는, 프로토콜명으로부터 스트림 프로토콜 핸들러를 구축하는데 사용됩니다.

 <p> 시큐리티 매니저가 존재하는 경우, 이 메소드는 최초로 시큐리티 매니저의 <code>checkSetFactory</code> 메소드를 호출하는 것으로, 이 조작이 허가되고 있는 것을 확인합니다. 이 결과, SecurityException 가 throw 되는 일이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>fac</CODE> - 목적의 팩토리
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/Error.html" title="java.lang 안의 클래스">Error</A> </CODE> - 어플리케이션으로 팩토리가 벌써 설정되어 있는 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <code>checkSetFactory</code> 메소드가 이 조작을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><CODE>java.net.URL#URL(java.lang.String, java.lang.String,</CODE>, 
<A HREF="../../java/net/URLStreamHandlerFactory.html" title="java.net 안의 인터페이스"><CODE>URLStreamHandlerFactory</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkSetFactory()"><CODE>SecurityManager.checkSetFactory()</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/URL.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/net/URISyntaxException.html" title="java.net 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/net/URLClassLoader.html" title="java.net 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/net/URL.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="URL.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
