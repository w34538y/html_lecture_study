<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:53:39 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Polygon (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Polygon (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Polygon.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/awt/PointerInfo.html" title="java.awt 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/awt/PopupMenu.html" title="java.awt 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/awt/Polygon.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Polygon.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt</FONT>
<BR>
클래스 Polygon</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.awt.Polygon</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> , <A HREF="../../java/io/Serializable.html" title="java.io 안의 인터페이스">Serializable</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>Polygon</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> , <A HREF="../../java/io/Serializable.html" title="java.io 안의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
<code>Polygon</code> 클래스는, 좌표 공간을 가지는 닫혀진 2 차원 영역의 기술을 캡슐화합니다. 이 영역은, 다각형의 1 옆을 이루는 선세그먼트(segment)의 임의의 수에 의해 경계를 단락지어집니다. 내부적으로는, 다각형은 <code>(x, y)</code> 좌표 페어의 리스트로부터 구성됩니다.  이 경우, 각 페어는 다각형의 「정점」을 정의해, 연속하는 2 개의 페어는 다각형의 1 옆을 이루는 선의 단 점이 됩니다. <i></i><code>(x, y)</code> 점의 최초와 마지막 페어는, 다각형을 닫는 선세그먼트(segment)에 의해 결합됩니다. 이 <code>Polygon</code> 는 우기굴곡 규칙에 의해 정의됩니다. 우기굴곡 규칙의 정의에 대해서는,<A HREF="../../java/awt/geom/PathIterator.html#WIND_EVEN_ODD"><CODE>WIND_EVEN_ODD</CODE></A>  를 참조해 주세요. <code>contains</code>,<code>intersects</code>, 및 <code>inside</code> 메소드를 포함한 이 클래스의 히트 검사 메소드는,<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스"><CODE>Shape</CODE></A>  클래스의 코멘트에 기술된 「안쪽」의 정의를 사용합니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스"><CODE>Shape</CODE></A> , 
<A HREF="../../serialized-form.html#java.awt.Polygon">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#bounds">bounds</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Polygon</code> 의 경계입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#npoints">npoints</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;점의 총수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#xpoints">xpoints</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X 좌표의 배열입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#ypoints">ypoints</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y 좌표의 배열입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#Polygon()">Polygon</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;빈 상태(empty)의 다각형을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#Polygon(int[], int[], int)">Polygon</A> </B>(int[]&nbsp;xpoints,
        int[]&nbsp;ypoints,
        int&nbsp;npoints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 파라미터로부터 <code>Polygon</code> 를 구축 및 초기화합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#addPoint(int, int)">addPoint</A> </B>(int&nbsp;x,
         int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Polygon</code> 로 지정된 좌표를 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#contains(double, double)">contains</A> </B>(double&nbsp;x,
         double&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 좌표가 <code>Shape</code> 의 경계내에 있을지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#contains(double, double, double, double)">contains</A> </B>(double&nbsp;x,
         double&nbsp;y,
         double&nbsp;w,
         double&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Shape</code> 의 내부 영역이, 지정된 구형 영역을 완전하게 포함 할지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#contains(int, int)">contains</A> </B>(int&nbsp;x,
         int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 좌표가 이 <code>Polygon</code> 의 안쪽에 있을지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#contains(java.awt.Point)">contains</A> </B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <A HREF="../../java/awt/Point.html" title="java.awt 동안의 클래스"><CODE>Point</CODE></A>  가 이 <code>Polygon</code> 의 안쪽에 있을지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#contains(java.awt.geom.Point2D)">contains</A> </B>(<A HREF="../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <A HREF="../../java/awt/geom/Point2D.html" title="java.awt.geom 동안의 클래스"><CODE>Point2D</CODE></A>  가 <code>Shape</code> 의 경계내에 있을지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#contains(java.awt.geom.Rectangle2D)">contains</A> </B>(<A HREF="../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Shape</code> 의 내부가, 지정된 <code>Rectangle2D</code> 를 완전하게 내포 할지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#getBoundingBox()">getBoundingBox</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK version 1.1 이후는,
 <code>getBounds()</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#getBounds()">getBounds</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Polygon</code> 의 바운딩 박스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 내의 클래스">Rectangle2D</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#getBounds2D()">getBounds2D</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;고정밀도로 <code>getBounds</code> 메소드보다 정밀한,<code>Shape</code> 의 바운딩 박스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/geom/PathIterator.html" title="java.awt.geom 내의 인터페이스">PathIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#getPathIterator(java.awt.geom.AffineTransform)">getPathIterator</A> </B>(<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;at)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Polygon</code> 의 경계를 따라 반복 처리를 실시해,<code>Polygon</code> 의 윤곽의 기하학적 도형에의 액세스를 제공하는 반복자 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/geom/PathIterator.html" title="java.awt.geom 내의 인터페이스">PathIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#getPathIterator(java.awt.geom.AffineTransform, double)">getPathIterator</A> </B>(<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;at,
                double&nbsp;flatness)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Shape</code> 의 경계를 따라 반복 처리를 실시해,<code>Shape</code> 의 윤곽의 기하학적 도형에의 액세스를 제공하는 반복자 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#inside(int, int)">inside</A> </B>(int&nbsp;x,
       int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK version 1.1 이후는,
 <code>contains(int, int)</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#intersects(double, double, double, double)">intersects</A> </B>(double&nbsp;x,
           double&nbsp;y,
           double&nbsp;w,
           double&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Shape</code> 의 내부 영역이, 지정된 구형 영역의 내부 영역과 교차할지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#intersects(java.awt.geom.Rectangle2D)">intersects</A> </B>(<A HREF="../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Shape</code> 의 내부가, 지정된 <code>Rectangle2D</code> 의 내부와 교차할지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#invalidate()">invalidate</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Polygon</code> 의 정점의 좌표에 의존하는 내부에 캐쉬된 모든 데이터를 무효로 하는지, 또는 플래시 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#reset()">reset</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Polygon</code> 객체를 빈 상태(empty)의 다각형에 리셋 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Polygon.html#translate(int, int)">translate</A> </B>(int&nbsp;deltaX,
          int&nbsp;deltaY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Polygon</code> 의 정점을 x 축으로 따라 <code>deltaX</code>, 및 y 축으로 따라 <code>deltaY</code> 이동합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="npoints"><!-- --></A> <H3>
npoints</H3>
<PRE>
public int <B>npoints</B></PRE>
<DL>
<DD>점의 총수입니다. <code>npoints</code> 의 값은 이 <code>Polygon</code> 의 유효한 점의 수를 나타내,<A HREF="../../java/awt/Polygon.html#xpoints"><CODE>xpoints</CODE></A>  또는 <A HREF="../../java/awt/Polygon.html#ypoints"><CODE>ypoints</CODE></A>  의 요소의 수보다 작아집니다. 이 값은 null 를 취할 수가 있습니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Polygon.html#addPoint(int, int)"><CODE>addPoint(int, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="xpoints"><!-- --></A> <H3>
xpoints</H3>
<PRE>
public int[] <B>xpoints</B></PRE>
<DL>
<DD>X 좌표의 배열입니다. 이 배열의 요소의 수는, 이 <code>Polygon</code> 의 X 좌표의 수보다 커집니다. 여분의 요소에 의해, 이 배열을 재차 작성하지 않고 , 이 <code>Polygon</code> 에 새로운 점을 추가할 수 있습니다. <A HREF="../../java/awt/Polygon.html#npoints"><CODE>npoints</CODE></A>  의 값은, 이 <code>Polygon</code> 의 유효한 점의 수와 같습니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Polygon.html#addPoint(int, int)"><CODE>addPoint(int, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="ypoints"><!-- --></A> <H3>
ypoints</H3>
<PRE>
public int[] <B>ypoints</B></PRE>
<DL>
<DD>Y 좌표의 배열입니다. 이 배열의 요소의 수는, 이 <code>Polygon</code> 의 Y 좌표의 수보다 커집니다. 여분의 요소에 의해, 이 배열을 재차 작성하지 않고 , 이 <code>Polygon</code> 에 새로운 점을 추가할 수 있습니다. <code>npoints</code> 의 값은, 이 <code>Polygon</code> 의 유효한 점의 수와 같습니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Polygon.html#addPoint(int, int)"><CODE>addPoint(int, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="bounds"><!-- --></A> <H3>
bounds</H3>
<PRE>
protected <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>bounds</B></PRE>
<DL>
<DD>이 <code>Polygon</code> 의 경계입니다. null 도 사용할 수 있습니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Polygon.html#getBoundingBox()"><CODE>getBoundingBox()</CODE></A> , 
<A HREF="../../java/awt/Polygon.html#getBounds()"><CODE>getBounds()</CODE></A> </DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Polygon()"><!-- --></A> <H3>
Polygon</H3>
<PRE>
public <B>Polygon</B>()</PRE>
<DL>
<DD>빈 상태(empty)의 다각형을 작성합니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.0</DD>
</DL>
</DL>
<HR>

<A NAME="Polygon(int[], int[], int)"><!-- --></A> <H3>
Polygon</H3>
<PRE>
public <B>Polygon</B>(int[]&nbsp;xpoints,
               int[]&nbsp;ypoints,
               int&nbsp;npoints)</PRE>
<DL>
<DD>지정된 파라미터로부터 <code>Polygon</code> 를 구축 및 초기화합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>xpoints</CODE> - X 좌표의 배열<DD><CODE>ypoints</CODE> - Y 좌표의 배열<DD><CODE>npoints</CODE> - <code>Polygon</code> 의 점의
                                총수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NegativeArraySizeException.html" title="java.lang 안의 클래스">NegativeArraySizeException</A> </CODE> - <code>npoints</code> 의 값이
                       부의 경우
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - <code>npoints</code> 가
             <code>xpoints</code> 의 길이 또는
             <code>ypoints</code> 의 길이보다 큰 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>xpoints</code> 또는 
             <code>ypoints</code> 가 <code>null</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.0</DD>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="reset()"><!-- --></A> <H3>
reset</H3>
<PRE>
public void <B>reset</B>()</PRE>
<DL>
<DD>이 <code>Polygon</code> 객체를 빈 상태(empty)의 다각형에 리셋 합니다. 그 중에 있는 좌표 배열과 데이터는 그대로 남습니다만, 점의 수는 제로에 리셋 되어 낡은 정점의 데이터를 무효로서 마크 해, 최초부터 새로운 정점의 데이터의 축적을 개시합니다. 내부에 캐쉬된 모든 낡은 정점으로 관한 데이터는 파기됩니다. 리셋 하기 전의 좌표 배열이 재사용되므로, 새로운 다각형의 데이터의 정점의 수가 리셋전의 데이터의 정점의 수보다 꽤 작은 경우는, 새로운 빈 상태(empty)의 <code>Polygon</code> 의 작성이 현재의 다각형을 리셋 하는 것보다도 메모리를 보다 효율적으로 사용할 수 있는 것에 주의해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Polygon.html#invalidate()"><CODE>invalidate()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="invalidate()"><!-- --></A> <H3>
invalidate</H3>
<PRE>
public void <B>invalidate</B>()</PRE>
<DL>
<DD>이 <code>Polygon</code> 의 정점의 좌표에 의존하는 내부에 캐쉬된 모든 데이터를 무효로 하는지, 또는 플래시 합니다. 이 메소드는,<code>xpoints</code> 또는 <code>ypoints</code> 배열의 좌표를 직접 조작한 뒤에 호출할 필요가 있습니다.  이것은, 정점의 좌표에 관련하기 이전의 계산으로부터 데이터를 캐쉬하고 있는 <code>getBounds</code> 또는 <code>contains</code> 등의 메소드로부터 일관한 결과를 얻을 수 있도록(듯이) 하기 (위해)때문에입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Polygon.html#getBounds()"><CODE>getBounds()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="translate(int, int)"><!-- --></A> <H3>
translate</H3>
<PRE>
public void <B>translate</B>(int&nbsp;deltaX,
                      int&nbsp;deltaY)</PRE>
<DL>
<DD><code>Polygon</code> 의 정점을 x 축으로 따라 <code>deltaX</code>, 및 y 축으로 따라 <code>deltaY</code> 이동합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>deltaX</CODE> - X 축으로 따라 이동하는 거리<DD><CODE>deltaY</CODE> - Y 축으로 따라 이동하는 거리<DT><B>도입된 버젼:</B></DT>
  <DD>1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="addPoint(int, int)"><!-- --></A> <H3>
addPoint</H3>
<PRE>
public void <B>addPoint</B>(int&nbsp;x,
                     int&nbsp;y)</PRE>
<DL>
<DD>이 <code>Polygon</code> 로 지정된 좌표를 추가합니다.  &nbsp;<p>
이 <code>Polygon</code> 의 바운딩 박스를 계산하는 <code>getBounds</code> 또는 <code>contains</code> 등의 연산이 벌써 실행되고 있는 경우, 이 메소드는 바운딩 박스를 갱신합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 지정된 X 좌표<DD><CODE>y</CODE> - 지정된 Y 좌표<DT><B>도입된 버젼:</B></DT>
  <DD>1.0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Polygon.html#getBounds()"><CODE>getBounds()</CODE></A> , 
<A HREF="../../java/awt/Polygon.html#contains(java.awt.Point)"><CODE>contains(java.awt.Point)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBounds()"><!-- --></A> <H3>
getBounds</H3>
<PRE>
public <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getBounds</B>()</PRE>
<DL>
<DD>이 <code>Polygon</code> 의 바운딩 박스를 돌려줍니다. 이 바운딩 박스는 옆이 좌표 공간의 x 축 및 y 축으로 평행으로 <code>Polygon</code> 를 완전하게 포함하는 최소 <A HREF="../../java/awt/Rectangle.html" title="java.awt 중의 클래스"><CODE>Rectangle</CODE></A>  입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Shape.html#getBounds()">getBounds</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>Polygon</code> 의 경계를 정의한다  
 <code>Rectangle</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Shape.html#getBounds2D()"><CODE>Shape.getBounds2D()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBoundingBox()"><!-- --></A> <H3>
getBoundingBox</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getBoundingBox</B>()</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK version 1.1 이후는,
 <code>getBounds()</code> 로 옮겨졌습니다. </I>
<P>
<DD>이 <code>Polygon</code> 의 경계를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>Polygon</code> 의 경계<DT><B>도입된 버젼:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="contains(java.awt.Point)"><!-- --></A> <H3>
contains</H3>
<PRE>
public boolean <B>contains</B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;p)</PRE>
<DL>
<DD>지정된 <A HREF="../../java/awt/Point.html" title="java.awt 동안의 클래스"><CODE>Point</CODE></A>  가 이 <code>Polygon</code> 의 안쪽에 있을지 어떨지를 판정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>p</CODE> - 판정 대상의, 지정된 <code>Point</code>
<DT><B>반환값:</B><DD><code>Polygon</code> 에 <code>Point</code> 가 포함되는 경우는 
                        <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Polygon.html#contains(double, double)"><CODE>contains(double, double)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="contains(int, int)"><!-- --></A> <H3>
contains</H3>
<PRE>
public boolean <B>contains</B>(int&nbsp;x,
                        int&nbsp;y)</PRE>
<DL>
<DD>지정된 좌표가 이 <code>Polygon</code> 의 안쪽에 있을지 어떨지를 판정합니다.  &nbsp;<p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 판정 대상의 지정된 X 좌표<DD><CODE>y</CODE> - 판정 대상의 지정된 Y 좌표
<DT><B>반환값:</B><DD>이 <code>Polygon</code> 로 지정된 좌표 <code>(x, y)</code> 가
         포함되는 경우는 <code>true</code>,
         그렇지 않은 경우는 <code>false</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Polygon.html#contains(double, double)"><CODE>contains(double, double)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="inside(int, int)"><!-- --></A> <H3>
inside</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public boolean <B>inside</B>(int&nbsp;x,
                                 int&nbsp;y)</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK version 1.1 이후는,
 <code>contains(int, int)</code> 로 옮겨졌습니다. </I>
<P>
<DD>지정된 좌표가 이 <code>Polygon</code> 에 내포 되고 있는지 어떤지를 판정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 판정 대상의 지정된 X 좌표<DD><CODE>y</CODE> - 판정 대상의 지정된 Y 좌표
<DT><B>반환값:</B><DD>이 <code>Polygon</code> 로 지정된 좌표 <code>(x, y)</code> 가
         포함되는 경우는 <code>true</code>,
         그렇지 않은 경우는 <code>false</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Polygon.html#contains(double, double)"><CODE>contains(double, double)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBounds2D()"><!-- --></A> <H3>
getBounds2D</H3>
<PRE>
public <A HREF="../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 내의 클래스">Rectangle2D</A>  <B>getBounds2D</B>()</PRE>
<DL>
<DD>고정밀도로 <code>getBounds</code> 메소드보다 정밀한,<code>Shape</code> 의 바운딩 박스를 돌려줍니다. 반환된 <A HREF="../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 동안의 클래스"><CODE>Rectangle2D</CODE></A>  가 <code>Shape</code> 를 둘러싸는 최소의 바운딩 박스이다고는 할 수 없습니다.  나타난 <code>Rectangle2D</code> 내에 <code>Shape</code> 가 완전하게 수습된다고 할 뿐입니다. 반환값을, 배정밀도치를 사용해 치수를 포함하는 <code>Rectangle2D</code> 의 인스턴스로 할 수도 있기 (위해)때문에, 이 메소드에 의해 반환되는 바운딩 박스는, 일반적으로,<code>getBounds</code> 메소드에 의해 반환되는 바운딩 박스보다 딱 한 것이 되어, 오버플로우를 위해서(때문에) 실패할 것은 없습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Shape.html#getBounds2D()">getBounds2D</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>Shape</code> 의 고정밀도 바운딩 박스를 나타낸다 
                 <code>Rectangle2D</code> 의 인스턴스<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Shape.html#getBounds()"><CODE>Shape.getBounds()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="contains(double, double)"><!-- --></A> <H3>
contains</H3>
<PRE>
public boolean <B>contains</B>(double&nbsp;x,
                        double&nbsp;y)</PRE>
<DL>
<DD>지정된 좌표가 <code>Shape</code> 의 경계내에 있을지 어떨지를 판정합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Shape.html#contains(double, double)">contains</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 판정 대상의 지정된 X 좌표<DD><CODE>y</CODE> - 판정 대상의 지정된 Y 좌표
<DT><B>반환값:</B><DD>지정된 좌표가 <code>Shape</code> 의 
         경계내에 있는 경우는 <code>true</code>, 그렇지 않은 경우는 
         <code>false</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="contains(java.awt.geom.Point2D)"><!-- --></A> <H3>
contains</H3>
<PRE>
public boolean <B>contains</B>(<A HREF="../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;p)</PRE>
<DL>
<DD>지정된 <A HREF="../../java/awt/geom/Point2D.html" title="java.awt.geom 동안의 클래스"><CODE>Point2D</CODE></A>  가 <code>Shape</code> 의 경계내에 있을지 어떨지를 판정합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Shape.html#contains(java.awt.geom.Point2D)">contains</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>p</CODE> - 판정 대상의, 지정된 <code>Point2D</code>
<DT><B>반환값:</B><DD>지정된 <code>Point2D</code> 가 <code>Shape</code> 의 
          경계내에 있는 경우는 <code>true</code>,
                그렇지 않은 경우는 <code>false</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="intersects(double, double, double, double)"><!-- --></A> <H3>
intersects</H3>
<PRE>
public boolean <B>intersects</B>(double&nbsp;x,
                          double&nbsp;y,
                          double&nbsp;w,
                          double&nbsp;h)</PRE>
<DL>
<DD><code>Shape</code> 의 내부 영역이, 지정된 구형 영역의 내부 영역과 교차할지 어떨지를 판정합니다. <code>Shape</code> 의 내부 영역과 지정된 구형 영역의 양쪽 모두에 포함되는 점이 있는 경우, 구형 영역은 <code>Shape</code> 와 교차하고 있다고 보여집니다.  &nbsp;<p>
<code>Shape.intersects()</code> 메소드를 사용하면(자), 다음과 같은 경우에 <code>Shape</code> 구현은 <code>true</code> 를 돌려주는 일이 있습니다.
 <ul>
 <li>
구형 영역과 <code>Shape</code> 가 서로 겹치고 있을 가능성이 꽤 높지만,
 <li>
이 공통 부분을 정확하게 판단하는 계산의 부하가 꽤 크다
 </ul>
즉,<code>Shape</code> 에 따라서는, 구형 영역이 <code>Shape</code> 와 교차하지 않는 경우에서도 이 메소드가 <code>true</code> 를 돌려주는 일이 있습니다. <A HREF="../../java/awt/geom/Area.html" title="java.awt.geom 안의 클래스"><CODE>Area</CODE></A>  클래스는, 대부분의 <code>Shape</code> 객체의 기하학적인 공통 부분의 것보다 정밀한 계산을 실시하기 (위해)때문에, 보다 정확한 결과가 필요한 경우에 사용할 수 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Shape.html#intersects(double, double, double, double)">intersects</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 지정된 구형 영역의
          좌상구석의 X 좌표<DD><CODE>y</CODE> - 지정된 구형 영역의
          좌상구석의 Y 좌표<DD><CODE>w</CODE> - 지정된 구형 영역의 폭<DD><CODE>h</CODE> - 지정된 구형 영역의 높이
<DT><B>반환값:</B><DD><code>Shape</code> 의 내부 영역과 구형 영역의 내부 영역이 교차하는 경우,
                또는 교차할 가능성이 높지만, 부하가 너무 커
                공통 부분의 계산을 실시할 수 없는 경우도 <code>true</code>, 
                그렇지 않은 경우는 <code>false</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/geom/Area.html" title="java.awt.geom 내의 클래스"><CODE>Area</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="intersects(java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
intersects</H3>
<PRE>
public boolean <B>intersects</B>(<A HREF="../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;r)</PRE>
<DL>
<DD><code>Shape</code> 의 내부가, 지정된 <code>Rectangle2D</code> 의 내부와 교차할지 어떨지를 판정합니다. <code>Shape.intersects()</code> 메소드를 사용하면(자), 다음과 같은 경우에 <code>Shape</code> 구현은 <code>true</code> 를 돌려주는 일이 있습니다.
 <ul>
 <li>
<code>Rectangle2D</code> 와 <code>Shape</code> 가 교차할 가능성이 높지만,
 <li>
이 공통 부분을 정확하게 판단하는 계산의 부하가 꽤 크다
 </ul>
즉,<code>Shape</code> 에 따라서는,<code>Rectangle2D</code> 가 <code>Shape</code> 와 교차하지 않는 경우에서도 이 메소드가 <code>true</code> 를 돌려주는 일이 있습니다. <A HREF="../../java/awt/geom/Area.html" title="java.awt.geom 안의 클래스"><CODE>Area</CODE></A>  클래스는, 대부분의 <code>Shape</code> 객체의 기하학적인 공통 부분의 것보다 정밀한 계산을 실시하기 (위해)때문에, 보다 정확한 결과가 필요한 경우에 사용할 수 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Shape.html#intersects(java.awt.geom.Rectangle2D)">intersects</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>r</CODE> - 지정된 <code>Rectangle2D</code>
<DT><B>반환값:</B><DD><code>Shape</code> 의 내부 영역과  
                지정된 <code>Rectangle2D</code> 의 내부 영역이 교차하는 경우,
                또는 교차할 가능성이 높지만, 부하가 너무 커
                공통 부분의 계산을 실시할 수 없는 경우도 <code>true</code>,
                그렇지 않은 경우는 <code>false</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Shape.html#intersects(double, double, double, double)"><CODE>Shape.intersects(double, double, double, double)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="contains(double, double, double, double)"><!-- --></A> <H3>
contains</H3>
<PRE>
public boolean <B>contains</B>(double&nbsp;x,
                        double&nbsp;y,
                        double&nbsp;w,
                        double&nbsp;h)</PRE>
<DL>
<DD><code>Shape</code> 의 내부 영역이, 지정된 구형 영역을 완전하게 포함 할지 어떨지를 판정합니다. 구형 영역 전체가 <code>Shape</code> 에 포함 되고 있다고 보여지기 위해서(때문에)는, 구형 영역내에 있는 모든 좌표가 <code>Shape</code> 내에 위치하고 있을 필요가 있습니다.  &nbsp;<p>
<code>Shape.contains()</code> 메소드를 사용하면(자), 다음과 같은 경우에 <code>Shape</code> 구현은 <code>false</code> 를 돌려주는 일이 있습니다.
 <ul>
 <li>
<code>intersect</code> 메소드가 <code>true</code> 를 돌려주어,
 <li>
<code>Shape</code> 가 구형 영역을 완전하게 포함 할지 어떨지를 판별하는 계산의 부하가 꽤 크다
 </ul>
즉,<code>Shape</code> 에 따라서는,<code>Shape</code> 가 구형 영역을 포함 하는 경우에서도 이 메소드가 <code>false</code> 를 돌려주는 일이 있습니다. <A HREF="../../java/awt/geom/Area.html" title="java.awt.geom 안의 클래스"><CODE>Area</CODE></A>  클래스는, 대부분의 <code>Shape</code> 객체의 것보다 정밀한 기하학적 계산을 실시하기 (위해)때문에, 보다 정확한 결과가 필요한 경우에 사용할 수 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Shape.html#contains(double, double, double, double)">contains</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 지정된 구형 영역의
          좌상구석의 X 좌표<DD><CODE>y</CODE> - 지정된 구형 영역의
          좌상구석의 Y 좌표<DD><CODE>w</CODE> - 지정된 구형 영역의 폭<DD><CODE>h</CODE> - 지정된 구형 영역의 높이
<DT><B>반환값:</B><DD><code>Shape</code> 의 내부 영역이, 지정된 구형 영역을
                완전하게 포함 하는 경우는 <code>true</code>,
                그렇지 않은 경우는 <code>false</code>.     
                또,<code>Shape</code> 가 구형 영역을 포함 해,   
                <code>intersects</code> 메소드가 <code>true</code> 를 돌려주어, 
                부하가 너무 커 포함의 계산을 실시할 수 없는 경우도 
                <code>false</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/geom/Area.html" title="java.awt.geom 내의 클래스"><CODE>Area</CODE></A> , 
<A HREF="../../java/awt/Shape.html#intersects(double, double, double, double)"><CODE>Shape.intersects(double, double, double, double)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="contains(java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
contains</H3>
<PRE>
public boolean <B>contains</B>(<A HREF="../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;r)</PRE>
<DL>
<DD><code>Shape</code> 의 내부가, 지정된 <code>Rectangle2D</code> 를 완전하게 내포 할지 어떨지를 판정합니다. <code>Shape.contains()</code> 메소드를 사용하면(자), 다음과 같은 경우에 <code>Shape</code> 구현은 <code>false</code> 를 돌려주는 일이 있습니다.
 <ul>
 <li>
<code>intersect</code> 메소드가 <code>true</code> 를 돌려주어,
 <li>
<code>Shape</code> 가 <code>Rectangle2D</code> 를 완전하게 포함 할지 어떨지를 판단하는 계산의 부하가 크다
 </ul>
즉,<code>Shape</code> 에 따라서는,<code>Shape</code> 가 <code>Rectangle2D</code> 를 포함 하는 경우에서도 이 메소드가 <code>false</code> 를 돌려주는 일이 있습니다. <A HREF="../../java/awt/geom/Area.html" title="java.awt.geom 안의 클래스"><CODE>Area</CODE></A>  클래스는, 대부분의 <code>Shape</code> 객체의 것보다 정밀한 기하학적 계산을 실시하기 (위해)때문에, 보다 정확한 결과가 필요한 경우에 사용할 수 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Shape.html#contains(java.awt.geom.Rectangle2D)">contains</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>r</CODE> - 지정된 <code>Rectangle2D</code>
<DT><B>반환값:</B><DD><code>Shape</code> 의 내부 영역이,<code>Rectangle2D</code> 를
          완전하게 포함 하는 경우는 <code>true</code>,
          그렇지 않은 경우는 <code>false</code>.
          또,<code>Shape</code> 가 <code>Rectangle2D</code> 를 포함 해,
          <code>intersects</code> 메소드가 <code>true</code> 를 돌려주어,
          부하가 너무 커 포함의 계산을 실시할 수 없는 경우도 
          <code>false</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Shape.html#contains(double, double, double, double)"><CODE>Shape.contains(double, double, double, double)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPathIterator(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
getPathIterator</H3>
<PRE>
public <A HREF="../../java/awt/geom/PathIterator.html" title="java.awt.geom 내의 인터페이스">PathIterator</A>  <B>getPathIterator</B>(<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;at)</PRE>
<DL>
<DD>이 <code>Polygon</code> 의 경계를 따라 반복 처리를 실시해,<code>Polygon</code> 의 윤곽의 기하학적 도형에의 액세스를 제공하는 반복자 객체를 돌려줍니다. 임의로 <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스"><CODE>AffineTransform</CODE></A>  를 지정할 수 있어 그 경우는 반복 처리로 반환되는 좌표는 거기에 응해 변환됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Shape.html#getPathIterator(java.awt.geom.AffineTransform)">getPathIterator</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>at</CODE> - 반복 처리로 돌려주어질 때 좌표에 적용된다
                옵션의 <code>AffineTransform</code>,
                변환되어 있지 않은 좌표가 필요한 경우는 <code>null</code>
<DT><B>반환값:</B><DD>이 <code>Polygon</code> 의 기하학적 도형에의 액세스를 제공한다 
                <A HREF="../../java/awt/geom/PathIterator.html" title="java.awt.geom 안의 인터페이스"><CODE>PathIterator</CODE></A>  객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPathIterator(java.awt.geom.AffineTransform, double)"><!-- --></A> <H3>
getPathIterator</H3>
<PRE>
public <A HREF="../../java/awt/geom/PathIterator.html" title="java.awt.geom 내의 인터페이스">PathIterator</A>  <B>getPathIterator</B>(<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;at,
                                    double&nbsp;flatness)</PRE>
<DL>
<DD><code>Shape</code> 의 경계를 따라 반복 처리를 실시해,<code>Shape</code> 의 윤곽의 기하학적 도형에의 액세스를 제공하는 반복자 객체를 돌려줍니다. 반복자가 돌려주는 것은, 포인트형 SEG_MOVETO, SEG_LINETO, 및 SEG_CLOSE 뿐입니다. 다각형은 벌써 평탄하기 때문에,<code>flatness</code> 파라미터는 무시됩니다. 옵션의 <code>AffineTransform</code> 는, 반복 처리로 반환되는 좌표가 거기에 응해 변환되는 경우로 지정할 수가 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Shape.html#getPathIterator(java.awt.geom.AffineTransform, double)">getPathIterator</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>at</CODE> - 반복 처리로 돌려주어질 때 좌표에 적용된다
                옵션의 <code>AffineTransform</code>,
                변환되어 있지 않은 좌표가 필요한 경우는 <code>null</code><DD><CODE>flatness</CODE> - 분할된 곡선이 종점을 묶는 직선에 의해
                치환되기 전에, 지정된 곡선의 제어점이
                공선으로부터 빗나갈 수 있다
                최대 거리. 다각형은 벌써 평탄하기 때문에,
                <code>flatness</code> 파라미터는 무시된다
<DT><B>반환값:</B><DD><code>Shape</code> 객체의 기하학적 도형에의
                액세스를 제공하는 <code>PathIterator</code> 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Polygon.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/awt/PointerInfo.html" title="java.awt 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/awt/PopupMenu.html" title="java.awt 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/awt/Polygon.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Polygon.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
