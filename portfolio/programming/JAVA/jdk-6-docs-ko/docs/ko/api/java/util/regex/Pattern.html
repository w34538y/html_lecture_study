<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:01:15 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Pattern (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Pattern (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Pattern.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/regex/MatchResult.html" title="java.util.regex 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/util/regex/PatternSyntaxException.html" title="java.util.regex 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/regex/Pattern.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Pattern.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.regex</FONT>
<BR>
클래스 Pattern</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.regex.Pattern</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public final class <B>Pattern</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
컴파일 된 정규 표현입니다.

 <p> 정규 표현은, 캐릭터 라인으로서 지정해, 이 클래스의 인스턴스에 컴파일 할 필요가 있습니다. 결과적으로 얻을 수 있는 패턴은,<A HREF="../../../java/util/regex/Matcher.html" title="java.util.regex 안의 클래스"><CODE>Matcher</CODE></A>  객체를 작성하기 위해서 사용됩니다.  이 객체는, 임의 <A HREF="../../../java/lang/CharSequence.html" title="java.lang 중의 인터페이스"><CODE><code>문자 순서</code></CODE></A>  곳의 정규 표현을 매치 할 수 있습니다. 매치을 실행했을 때 상태는 모두 정규 표현 엔진에 포함됩니다.  이 때문에, 복수의 정규 표현 엔진이 같은 패턴을 공유할 수 있습니다.

 <p> 표준적인 calling sequence는, 다음과 같이 됩니다.

 <blockquote><pre>
 Pattern p = Pattern. <A HREF="../../../java/util/regex/Pattern.html#compile(java.lang.String)"><CODE>compile</CODE></A> ("a*b");
 Matcher m = p. <A HREF="../../../java/util/regex/Pattern.html#matcher(java.lang.CharSequence)"><CODE>matcher</CODE></A> ("aaaaab");
 boolean b = m. <A HREF="../../../java/util/regex/Matcher.html#matches()"><CODE>matches</CODE></A> ();</pre></blockquote>

 <p> 이 클래스에 정의한 <A HREF="../../../java/util/regex/Pattern.html#matches(java.lang.String, java.lang.CharSequence)"><CODE>matches</CODE></A>  메소드를 사용하면, 정규 표현은 한 번 사용하는 것만으로 끝납니다. 이 메소드를 1 회 호출하는 것만으로, 표현이 컴파일 되어 입력 순서와의 매치을 합니다. 다음의 문장은, 전술의 3 개의 문장과 등가입니다.

 <blockquote><pre>
 boolean b = Pattern.matches("a*b", "aaaaab");</pre></blockquote>

다만, 매치을 반복하는 경우는, 컴파일 된 패턴을 재사용할 수 없기 때문에, 효율이 저하합니다.

 <p> 이 클래스의 인스턴스는 불변이기 (위해)때문에, 복수의 thread로 병행해 사용할 수 있습니다. <A HREF="../../../java/util/regex/Matcher.html" title="java.util.regex 안의 클래스"><CODE>Matcher</CODE></A>  클래스의 인스턴스는, 복수 thread에서의 병행 사용에 대응하고 있습니다.


 <a name="sum">
<h4> 정규 표현 구문의 요약 </h4>

 <table border="0" cellpadding="1" cellspacing="0"
  summary="Regular expression constructs, and what they match">

 <tr align="left">
<th bgcolor="#CCCCFF" align="left" id="construct">구문</th>
<th bgcolor="#CCCCFF" align="left" id="matches">Matches</th>
 </tr>

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="characters">문자</th></tr>

<tr><td valign="top" headers="construct characters"><i>x</i></td>
<td headers="matches">문자 <i>x</i></td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\\</tt></td>
<td headers="matches">backslash 문자</td></tr>
<tr><td valign="top" headers="construct characters"><tt>\0</tt><i>n</i></td>
<td headers="matches">8 진수 <tt>0</tt><i>n</i> 를 가지는 문자 (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
<tr><td valign="top" headers="construct characters"><tt>\0</tt><i>nn</i></td>
<td headers="matches">8 진수 <tt>0</tt><i>nn</i> 를 가지는 문자 (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
<tr><td valign="top" headers="construct characters"><tt>\0</tt><i>mnn</i></td>
<td headers="matches">8 진수 <tt>0</tt><i>mnn</i> 를 가지는 문자 (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>m</i>&nbsp;<tt>&lt;=</tt>&nbsp;3, 0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
<tr><td valign="top" headers="construct characters"><tt>\x</tt><i>hh</i></td>
<td headers="matches">16 진수 <tt>0x</tt><i>hh</i> 를 가지는 문자</td></tr>
<tr><td valign="top" headers="construct characters"><tt>&#92;u</tt><i>hhhh</i></td>
<td headers="matches">16 진수 <tt>0x</tt><i>hhhh</i> 를 가지는 문자</td></tr>
<tr><td valign="top" headers="matches"><tt>\t</tt></td>
<td headers="matches">탭 문자 (<tt>'&#92;u0009'</tt>)</td></tr>
<tr><td valign="top" headers="construct characters"><tt>\n</tt></td>
<td headers="matches">개행 문자 (<tt>'&#92;u000A'</tt>)</td></tr>
<tr><td valign="top" headers="construct characters"><tt>\r</tt></td>
<td headers="matches">왕복대 리턴 문자 (<tt>'&#92;u000D'</tt>)</td></tr>
<tr><td valign="top" headers="construct characters"><tt>\f</tt></td>
<td headers="matches">용지 보내 문자 (<tt>'&#92;u000C'</tt>)</td></tr>
<tr><td valign="top" headers="construct characters"><tt>\a</tt></td>
<td headers="matches">경고 (벨) 문자 (<tt>'&#92;u0007'</tt>)</td></tr>
<tr><td valign="top" headers="construct characters"><tt>\e</tt></td>
<td headers="matches">이스케이프 문자 (<tt>'&#92;u001B'</tt>)</td></tr>
<tr><td valign="top" headers="construct characters"><tt>\c</tt><i>x</i></td>
<td headers="matches"><i>x</i> 에 대응하는 제어 문자</td></tr>

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="classes">문자 클래스</th></tr>

<tr><td valign="top" headers="construct classes"><tt>[abc]</tt></td>
<td headers="matches"><tt>a</tt>,<tt>b</tt>, 또는 <tt>c</tt> (단순 클래스)</td></tr>
<tr><td valign="top" headers="construct classes"><tt>[^abc]</tt></td>
<td headers="matches"><tt>a</tt>,<tt>b</tt>,<tt>c</tt> 이외의 문자 (부정)</td></tr>
<tr><td valign="top" headers="construct classes"><tt>[a-zA-Z]</tt></td>
<td headers="matches"><tt>a</tt> ~ <tt>z</tt> 또는 <tt>A</tt> ~ <tt>Z</tt> (범위)</td></tr>
<tr><td valign="top" headers="construct classes"><tt>[a-d[m-p]]</tt></td>
<td headers="matches"><tt>a</tt> ~ <tt>d</tt>, 또는 <tt>m</tt> ~ <tt>p</tt>:<tt>[a-dm-p]</tt> (결합)</td></tr>
<tr><td valign="top" headers="construct classes"><tt>[a-z&&[def]]</tt></td>
<td headers="matches"><tt>d</tt>,<tt>e</tt>,<tt>f</tt> (교차)</tr>
<tr><td valign="top" headers="construct classes"><tt>[a-z&&[^bc]]</tt></td>
<td headers="matches"><tt>b</tt> 와 <tt>c</tt> 를 제외하는 <tt>a</tt> ~ <tt>z</tt>:<tt>[ad-z]</tt> (감산)</td></tr>
<tr><td valign="top" headers="construct classes"><tt>[a-z&&[^m-p]]</tt></td>
<td headers="matches"><tt>m</tt> ~ <tt>p</tt> 를 제외하는 <tt>a</tt> ~ <tt>z</tt>:<tt>[a-lq-z]</tt> (감산)</td></tr>
 <tr><th>&nbsp;</th></tr>

<tr align="left"><th colspan="2" id="predef">정의 끝난 문자 클래스</th></tr>

 <tr><td valign="top" headers="construct predef"><tt>. </tt></td>
<td headers="matches">임의의 문자 (<a href="#lt">줄 끝 기호</a>와 매치 하는 경우도 있다)</td></tr>
<tr><td valign="top" headers="construct predef"><tt>\d</tt></td>
<td headers="matches">숫자: <tt>[0-9]</tt></td></tr>
<tr><td valign="top" headers="construct predef"><tt>\D</tt></td>
<td headers="matches">숫자 이외: <tt>[^0-9]</tt></td></tr>
<tr><td valign="top" headers="construct predef"><tt>\s</tt></td>
<td headers="matches">공백 문자:<tt>[ \t\n\x0B\f\r]</tt></td></tr>
<tr><td valign="top" headers="construct predef"><tt>\S</tt></td>
<td headers="matches">비공백 문자:<tt>[^\s]</tt></td></tr>
<tr><td valign="top" headers="construct predef"><tt>\w</tt></td>
<td headers="matches">단어 구성 문자:<tt>[a-zA-Z_0-9]</tt></td></tr>
<tr><td valign="top" headers="construct predef"><tt>\W</tt></td>
<td headers="matches">비단어 문자:<tt>[^\w]</tt></td></tr>

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="posix">POSIX 문자 클래스 (US-ASCII 마셔)<b></b></th></tr>

<tr><td valign="top" headers="construct posix"><tt>\p{Lower}</tt></td>
<td headers="matches">소문자의 영문자:<tt>[a-z]</tt></td></tr>
<tr><td valign="top" headers="construct posix"><tt>\p{Upper}</tt></td>
<td headers="matches">대문자의 영문자: <tt>[A-Z]</tt></td></tr>
<tr><td valign="top" headers="construct posix"><tt>\p{ASCII}</tt></td>
<td headers="matches">모든 ASCII 문자: <tt>[\x00-\x7F]</tt></td></tr>
<tr><td valign="top" headers="construct posix"><tt>\p{Alpha}</tt></td>
<td headers="matches">영문자: <tt>[\p{Lower}\p{Upper}]</tt></td></tr>
<tr><td valign="top" headers="construct posix"><tt>\p{Digit}</tt></td>
<td headers="matches">10 진수자: <tt>[0-9]</tt></td></tr>
<tr><td valign="top" headers="construct posix"><tt>\p{Alnum}</tt></td>
<td headers="matches">영숫자: <tt>[\p{Alpha}\p{Digit}]</tt></td></tr>
<tr><td valign="top" headers="construct posix"><tt>\p{Punct}</tt></td>
<td headers="matches">구두점 문자:<tt>! "#$%&'()*+,-. /:;<=>? @[\]^_`{|}~</tt> 의 언젠가</td></tr>
     <!-- <tt>[\! "#\$%&'\(\)\*\+,\-\. /:;\<=\>\? @\[\\\]\^_`\{\|\}~]</tt>           <tt>[\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]</tt> -->
<tr><td valign="top" headers="construct posix"><tt>\p{Graph}</tt></td>
<td headers="matches">표시할 수 있는 문자: <tt>[\p{Alnum}\p{Punct}]</tt></td></tr>
<tr><td valign="top" headers="construct posix"><tt>\p{Print}</tt></td>
<td headers="matches">프린트 가능 문자: <tt>[\p{Graph}\x20]</tt></td></tr>
<tr><td valign="top" headers="construct posix"><tt>\p{Blank}</tt></td>
<td headers="matches">공백 또는 탭:<tt>[ \t]</tt></td></tr>
<tr><td valign="top" headers="construct posix"><tt>\p{Cntrl}</tt></td>
<td headers="matches">제어 문자:<tt>[\x00-\x1F\x7F]</tt></td></tr>
<tr><td valign="top" headers="construct posix"><tt>\p{XDigit}</tt></td>
<td headers="matches">16 진수자:<tt>[0-9a-fA-F]</tt></td></tr>
<tr><td valign="top" headers="construct posix"><tt>\p{Space}</tt></td>
<td headers="matches">공백 문자:<tt>[ \t\n\x0B\f\r]</tt></td></tr>

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2">java.lang.Character 클래스 (단순한 <a href="#jcc">java 문자 타입</a>)</th></tr>

<tr><td valign="top"><tt>\p{javaLowerCase}</tt></td>
<td>java.lang.Character.isLowerCase()와 등가</td></tr>
<tr><td valign="top"><tt>\p{javaUpperCase}</tt></td>
<td>java.lang.Character.isUpperCase()와 등가</td></tr>
<tr><td valign="top"><tt>\p{javaWhitespace}</tt></td>
<td>java.lang.Character.isWhitespace()와 등가</td></tr>
<tr><td valign="top"><tt>\p{javaMirrored}</tt></td>
<td>java.lang.Character.isMirrored()와 등가</td></tr>

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="unicode">Unicode 블록과 카테고리의 클래스</th></tr>

<tr><td valign="top" headers="construct unicode"><tt>\p{InGreek}</tt></td>
<td headers="matches">희랍어 블록의 문자 (단순<a href="#ubc">블록</a>)</td></tr>
<tr><td valign="top" headers="construct unicode"><tt>\p{Lu}</tt></td>
<td headers="matches">대문자 (단순<a href="#ubc">카테고리</a>)</td></tr>
<tr><td valign="top" headers="construct unicode"><tt>\p{Sc}</tt></td>
<td headers="matches">통화 기호</td></tr>
<tr><td valign="top" headers="construct unicode"><tt>\P{InGreek}</tt></td>
<td headers="matches">희랍어 블록 이외의 문자 (부정)</td></tr>
<tr><td valign="top" headers="construct unicode"><tt>[\p{L}&&[^\p{Lu}]]&nbsp;</tt></td>
<td headers="matches">대문자 이외의 문자 (감산)</td></tr>

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="bounds">경계 정규 표현 엔진</th></tr>

 <tr><td valign="top" headers="construct bounds"><tt>^</tt></td>
<td headers="matches">행의 선두</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>$</tt></td>
<td headers="matches">행의 말미</td></tr>
<tr><td valign="top" headers="construct bounds"><tt>\b</tt></td>
<td headers="matches">단어 경계</td></tr>
<tr><td valign="top" headers="construct bounds"><tt>\B</tt></td>
<td headers="matches">비단어 경계</td></tr>
<tr><td valign="top" headers="construct bounds"><tt>\A</tt></td>
<td headers="matches">입력의 선두</td></tr>
<tr><td valign="top" headers="construct bounds"><tt>\G</tt></td>
<td headers="matches">전회의 매치의 말미</td></tr>
<tr><td valign="top" headers="construct bounds"><tt>\Z</tt></td>
<td headers="matches">마지막<a href="#lt">줄 끝 기호</a>가 있는 경우는, 그것을 제외한 입력의 말미</td></tr>
<tr><td valign="top" headers="construct bounds"><tt>\z</tt></td>
<td headers="matches">입력의 말미</td></tr>

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="greedy">최장 일치 수량자</th></tr>

<tr><td valign="top" headers="construct greedy"><i>X</i><tt>? </tt></td>
<td headers="matches"><i>X</i>, 1 또는 0 회</td></tr>
<tr><td valign="top" headers="construct greedy"><i>X</i><tt>*</tt></td>
<td headers="matches"><i>X</i>, 0 회 이상</td></tr>
<tr><td valign="top" headers="construct greedy"><i>X</i><tt>+</tt></td>
<td headers="matches"><i>X</i>, 1 회 이상</td></tr>
<tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>}</tt></td>
<td headers="matches"><i>X</i>,<i>n</i> 회</td></tr>
<tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,}</tt></td>
<td headers="matches"><i>X</i>,<i>n</i> 회이상</td></tr>
<tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}</tt></td>
<td headers="matches"><i>X</i>,<i>n</i> 회이상,<i>m</i> 회이하</td></tr>

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="reluc">최단 일치 수량자</th></tr>

<tr><td valign="top" headers="construct reluc"><i>X</i><tt>??</tt></td>
<td headers="matches"><i>X</i>, 1 또는 0 회</td></tr>
<tr><td valign="top" headers="construct reluc"><i>X</i><tt>*? </tt></td>
<td headers="matches"><i>X</i>, 0 회 이상</td></tr>
<tr><td valign="top" headers="construct reluc"><i>X</i><tt>+? </tt></td>
<td headers="matches"><i>X</i>, 1 회 이상</td></tr>
<tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>}? </tt></td>
<td headers="matches"><i>X</i>,<i>n</i> 회</td></tr>
<tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,}? </tt></td>
<td headers="matches"><i>X</i>,<i>n</i> 회이상</td></tr>
<tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}? </tt></td>
<td headers="matches"><i>X</i>,<i>n</i> 회이상,<i>m</i> 회이하</td></tr>

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="poss">탐욕인 수량자</th></tr>

<tr><td valign="top" headers="construct poss"><i>X</i><tt>? +</tt></td>
<td headers="matches"><i>X</i>, 1 또는 0 회</td></tr>
<tr><td valign="top" headers="construct poss"><i>X</i><tt>*+</tt></td>
<td headers="matches"><i>X</i>, 0 회 이상</td></tr>
<tr><td valign="top" headers="construct poss"><i>X</i><tt>++</tt></td>
<td headers="matches"><i>X</i>, 1 회 이상</td></tr>
<tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>}+</tt></td>
<td headers="matches"><i>X</i>,<i>n</i> 회</td></tr>
<tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,}+</tt></td>
<td headers="matches"><i>X</i>,<i>n</i> 회이상</td></tr>
<tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}+</tt></td>
<td headers="matches"><i>X</i>,<i>n</i> 회이상,<i>m</i> 회이하</td></tr>

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="logical">논리 연산자</th></tr>

<tr><td valign="top" headers="construct logical"><i>XY</i></td>
<td headers="matches"><i>X</i> 의 직후에 <i>Y</i></td></tr>
<tr><td valign="top" headers="construct logical"><i>X</i><tt>|</tt><i>Y</i></td>
<td headers="matches"><i>X</i> 또는 <i>Y</i></td></tr>
<tr><td valign="top" headers="construct logical"><tt>(</tt><i>X</i><tt>)</tt></td>
<td headers="matches">X,<a href="#cg">전방 참조를 실시하는 정규 표현 그룹</a> </td></tr>

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="backref">전방 참조</th></tr>

<tr><td valign="bottom" headers="construct backref"><tt>\</tt><i>n</i></td>
<td valign="bottom" headers="matches">매치 한 <i>n</i> 번째의<a href="#cg">전방 참조를 실시하는 정규 표현 그룹</a> </td></tr>

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="quot">인용</th></tr>

 <tr><td valign="top" headers="construct quot"><tt>\</tt></td>
<td headers="matches">정규 표현은 아니지만, 다음의 문자를 이스케이프 한다</td></tr>
<tr><td valign="top" headers="construct quot"><tt>\Q</tt></td>
<td headers="matches">정규 표현은 아니지만,<tt>\E</tt> 까지의 모든 문자를 이스케이프 한다</td></tr>
<tr><td valign="top" headers="construct quot"><tt>\E</tt></td>
<td headers="matches">정규 표현은 아니지만,<tt>\Q</tt> 로 개시된 인용을 이스케이프 한다</td></tr>
     <!-- Metachars: !$()*+.<>? [\]^{|} -->

 <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="special">특수한 구문 (전방 참조를 실시하지 않는다)</th></tr>

<tr><td valign="top" headers="construct special"><tt>(? :</tt><i>X</i><tt>)</tt></td>
<td headers="matches"><i>X</i>, 전방 참조를 실시하지 않는 정규 표현 그룹</td></tr>
<tr><td valign="top" headers="construct special"><tt>(? idmsux-idmsux) &nbsp;</tt></td>
<td headers="matches">정규 표현은 아니지만, 매치 플래그 <a href="#CASE_INSENSITIVE">i</a> ,<a href="#UNIX_LINES">d</a> ,<a href="#MULTILINE">m</a> ,<a href="#DOTALL">s</a> ,<a href="#UNICODE_CASE">u</a> ,<a href="#COMMENTS">x</a>  의 온/오프를 바꾼다</td></tr>
<tr><td valign="top" headers="construct special"><tt>(? idmsux-idmsux:</tt><i>X</i><tt>)</tt>&nbsp;&nbsp;</td>
<td headers="matches"><i>X</i>,<a href="#cg">전방 참조를 실시하지 않는 그룹</a> . 지정된 플래그 <a href="#CASE_INSENSITIVE">i</a> ,<a href="#UNIX_LINES">d</a> ,<a href="#MULTILINE">m</a> ,<a href="#DOTALL">s</a> ,<a href="#UNICODE_CASE">u</a >,<a href="#COMMENTS">x</a>  의 온/오프를 바꾼다</td></tr>
<tr><td valign="top" headers="construct special"><tt>(? =</tt><i>X</i><tt>)</tt></td>
<td headers="matches"><i>X</i>, 폭제로의 긍정 예측</td></tr>
<tr><td valign="top" headers="construct special"><tt>(?!</tt><i>X</i><tt>)</tt></td>
<td headers="matches"><i>X</i>, 폭제로의 부정 예측</td></tr>
<tr><td valign="top" headers="construct special"><tt>(? &lt;=</tt><i>X</i><tt>)</tt></td>
<td headers="matches"><i>X</i>, 폭제로의 긍정 후 읽기</td></tr>
<tr><td valign="top" headers="construct special"><tt>(? &lt;! </tt><i>X</i><tt>)</tt></td>
<td headers="matches"><i>X</i>, 폭제로의 부정 후 읽기</td></tr>
<tr><td valign="top" headers="construct special"><tt>(? &gt;</tt><i>X</i><tt>)</tt></td>
<td headers="matches"><i>X</i>, 독립한 전방 참조를 실시하지 않는 정규 표현 그룹</td></tr>

 </table>

 <hr>


 <a name="bs">
<h4> backslash, 이스케이프, 및 인용 </h4>

 <p> backslash 문자 (<tt>'\'</tt>)는, 전술의 겉(표)에 정의되고 있는 구문을 이스케이프 합니다.  또, 지정하지 않았던 경우는, 이스케이프되어 있지 않다고 해석되는 캐릭터 라인을 인용합니다. 예를 들어, 정규 표현 <tt>\\</tt> 은 1 개의 backslash와 매치 해,<tt>\{</tt> 는 왼쪽 괄호와 매치 합니다.

 <p> 영문자의 전에 backslash를 사용했을 때에, 그 영문자가 이스케이프 구문이 아닌 경우는, 에러가 됩니다.  이러한 패턴은, 정규 표현 언어의 향후의 확장에 예약되고 있습니다. 영문자 이외의 문자의 경우는, 그 문자가 이스케이프 구문에 포함될지 어떨지에 관계없이, backslash를 지정할 수 있습니다.

 <p> <a  href="http://java.sun.com/docs/books/jls">Java 언어 스펙</a>에서는,Java 원시 코드의 캐릭터 라인 리터럴에 포함되는 backslash는,<a  href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#100850">Unicode 이스케이프</a>등의<a  href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#101089">문자 이스케이프</a>로서 유효하다라고 해석됩니다. 이 때문에, backslash가 Java 바이트 코드 컴파일러에 의해 해석되지 않게 하려면 , 정규 표현을 나타내는 캐릭터 라인 리터럴내에서 backslash를 2 개 계속할 필요가 있습니다. 예를 들어, 캐릭터 라인 리터럴 <tt>"&#92;b"</tt> 는, 정규 표현이라고 해석되면(자), 백 스페이스 1 문자와 매치 됩니다.  그러나,<tt>"&#92;&#92;b"</tt> 는 단어 경계와 매치 됩니다. 또, 캐릭터 라인 리터럴 <tt>"&#92;(hello&#92;)"</tt> 은 부당하게 되어, 컴파일시 에러가 발생합니다.  캐릭터 라인 <tt>(hello)</tt> 과 매치 되려면 , 캐릭터 라인 리터럴 <tt>"&#92;&#92;(hello&#92;&#92;)"</tt> 을 사용할 필요가 있습니다.

 <a name="cc">
<h4> 문자 클래스 </h4>

 <p> 문자 클래스는, 다른 문자 클래스내로 지정하거나 결합 연산자 (암묵적)나 교차 연산자 (<tt>&amp;&amp;</tt>)를 사용해 작성할 수가 있습니다. 결합 연산자는, 1 개(살) 이상의 오퍼랜드 클래스에 포함되는 모든 문자를 포함한 클래스를 나타냅니다. 교차 연산자는, 2 개의 오퍼랜드 클래스에 포함되는 모든 문자를 포함한 클래스를 나타냅니다.

 <p> 문자 클래스 연산자는, 다음의 순서로 우선 순위가 높아집니다.

    <blockquote><table border="0" cellpadding="1" cellspacing="0"
                 summary="Precedence of character class operators.">
      <tr><th>1&nbsp;&nbsp;&nbsp;&nbsp;</th>
          <td>리터럴 이스케이프 &nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td><tt>\x</tt></td></tr>
     <tr><th>2&nbsp;&nbsp;&nbsp;&nbsp;</th>
          <td>그룹화</td>
          <td><tt>[...]</tt></td></tr>
     <tr><th>3&nbsp;&nbsp;&nbsp;&nbsp;</th>
          <td>Range</td>
          <td><tt>a-z</tt></td></tr>
      <tr><th>4&nbsp;&nbsp;&nbsp;&nbsp;</th>
          <td>논리합</td>
          <td><tt>[a-e][i-u]</tt></td></tr>
      <tr><th>5&nbsp;&nbsp;&nbsp;&nbsp;</th>
          <td>논리적</td>
          <td><tt>[a-z&&[aeiou]]</tt></td></tr>
    </table></blockquote>

 <p> 실제로는, 다른 메타캐라크타세트는, 문자 클래스의 외부는 아니고 내부에 존재하는 것에 유의해 주세요. 예를 들어, 정규 표현 <tt>. </tt> (은)는, 문자 클래스 내부에서는 그 특수한 의미를 잃습니다만, 표현 <tt>-</tt> 은 범위를 나타내는 메타캐라크타가 됩니다.

 <a name="lt">
<h4> 줄 끝 기호 </h4>

 <p> 「줄 끝 기호」란, 입력 문자 순서의 행의 말미를 지정할 경우에 사용하는, 1 문자 또는 2 문자의 문자 순서입니다. 다음의 문자가 줄 끝 기호로서 인식됩니다.

 <ul>

<li> 개행 문자 (<tt>'\n'</tt>)

<li> 직후에 개행 문자가 붙은 왕복대 리턴 문자 (<tt>"\r\n"</tt>)

<li> 단독의 왕복대 리턴 문자 (<tt>'\r'</tt>)

<li> 다음 행 문자 (<tt>'&#92;u0085'</tt>)

<li> 행 단락 문자 (<tt>'&#92;u2028'</tt>)

<li> 단락 단락 문자 (<tt>'&#92;u2029</tt>)

 </ul>
 <p><A HREF="../../../java/util/regex/Pattern.html#UNIX_LINES"><CODE>UNIX_LINES</CODE></A>  모드가 유효한 경우는, 개행 문자만이 줄 끝 기호로서 인식됩니다.

 <p> 정규 표현 <tt>. </tt> (은)는,<A HREF="../../../java/util/regex/Pattern.html#DOTALL"><CODE>DOTALL</CODE></A>  플래그가 지정되어 있지 않은 경우, 줄 끝 기호 이외의 모든 문자와 매치 합니다.

 <p> 디폴트에서는, 정규 표현 <tt>^</tt> 및 <tt>$</tt> 하행말 기호를 무시해, 입력 순서 전체의 각각 선두와 말미인 만큼 매치 합니다. <A HREF="../../../java/util/regex/Pattern.html#MULTILINE"><CODE>MULTILINE</CODE></A>  모드가 액티브하게 되면(자),<tt>^</tt> 는 입력의 선두, 및 입력의 말미를 제외한 모든 줄 끝 기호의 뒤에 매치 합니다. <A HREF="../../../java/util/regex/Pattern.html#MULTILINE"><CODE>MULTILINE</CODE></A>  모드의 경우,<tt>$</tt> 하행말 기호의 직전, 또는 입력 순서의 말미에 매치 합니다.

 <a name="cg">
<h4> 정규 표현 그룹과 전방 참조 </h4>

 <p> 전방 참조를 실시하는 정규 표현 그룹에는, 왼쪽에서 우측향에 왼쪽환괄호를 세는 것에 의해, 번호를 붙일 수 있습니다. 예를 들어, 표현 <tt>((A)(B(C)))</tt> 는, 다음의 4 개의 그룹으로 분류됩니다.  </p>

 <blockquote><table cellpadding=1 cellspacing=0 summary="Capturing group numberings">
 <tr><th>1&nbsp;&nbsp;&nbsp;&nbsp;</th>
<td><tt>((A)(B(C)))</tt></td></tr>
 <tr><th>2&nbsp;&nbsp;&nbsp;&nbsp;</th>
<td><tt>(A)</tt></td></tr>
 <tr><th>3&nbsp;&nbsp;&nbsp;&nbsp;</th>
<td><tt>(B(C))</tt></td></tr>
 <tr><th>4&nbsp;&nbsp;&nbsp;&nbsp;</th>
<td><tt>(C)</tt></td></tr>
 </table></blockquote>

 <p> 그룹 0 은, 항상 표현 전체를 나타냅니다.

 <p> 전방 참조를 실시하는 정규 표현 그룹이 이와 같이 분류되고 나서, 입력 순서의 각 부분 순서가 이러한 그룹과 매치 되어 매치 할 때마다 부분 순서가 보존됩니다. 정규 표현 그룹의 부분 순서는, 전방 참조로서 표현내에서 나중에 사용할 수 있겠습니다.  또, 매치 조작이 완료하면(자), 정규 표현 엔진으로부터 꺼낼 수도 있습니다.

 <p> 그룹과 입력 순서가 매치 되면(자), 그 그룹과 마지막에 매치 한 부분 순서가 항상 전방 참조됩니다. 수량자를 지정했을 경우는, 그룹이 한번 더 평가됩니다.  2 번째의 평가가 실패했을 경우에서도, 그 전에 전방 참조된 값이 있는 경우는, 그 값이 보관 유지됩니다. 예를 들어, 캐릭터 라인 <tt>"aba"</tt> 를 표현 <tt>(a(b)? )+</tt> (와)과 매치 했을 경우는, 그룹 2 로 설정된 <tt>"b"</tt> 가 보관 유지됩니다. 전방 참조된 모든 입력은, 각 매치가 시작되기 전에 파기됩니다.

 <p> <tt>(? </tt> 그리고 시작되는 그룹은, 순수한 「전방 참조되지 않는 정규 표현」그룹에서, 텍스트를 전방 참조하지 않고, 그룹 전체에 카운트 되지 않습니다. <i></i>


<h4> Unicode 지원 </h4>

 <p> 이 클래스는,<a href="http://www.unicode.org/reports/tr18/">「Unicode Technical Standard #18: Unicode Regular Expression Guidelines」 (Unicode 테크니컬 스탠다드 No. 18:Unicode 정규 표현 가이드 라인)</a>  및, 릴리스 2.1 「Canonical Equivalents」 (정규 등가)을 참조해 주세요.

 <p> Java 원시 코드에서는,<tt>&#92;u2014</tt> 등의 Unicode escape sequence는, 「Java 언어 스펙」의 <a  href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#100850"> 3.3</a>  에 근거해 처리됩니다. 이러한 escape sequence는, 정규 표현 퍼서에 의해 직접 구현되기 (위해)때문에, 파일 또는 키보드로부터 읽어들인 표현 중(안)에서도 Unicode 이스케이프를 사용할 수 있습니다. 즉, 캐릭터 라인 <tt>"&#92;u2014"</tt> 와 <tt>"\\u2014"</tt> 는 등가가 아닙니다만, 같은 패턴에 컴파일 되어 16 진수 <tt>0x2014</tt> 의 문자와 매치 합니다.

<a name="ubc"> <p>Unicode 블록 및 카테고리는, Perl 와 같게 <tt>\p</tt> 및 <tt>\P</tt> 구문으로 기술합니다. 입력에 프로퍼티 <i>prop</i> 가 포함되는 경우,<tt>\p{</tt><i>prop</i><tt>}</tt> 는 매치 합니다만,<tt>\P{</tt><i>prop</i><tt>}</tt> 는 매치 하지 않습니다. 블록에는,<tt>InMongolian</tt> 와 같이, 접두사 <tt>In</tt> 를 지정합니다. 카테고리에는, 접두사 <tt>Is</tt> 를 지정할 수도 있습니다. <tt>\p{L}</tt> 와 <tt>\p{IsL}</tt> 는, Unicode 문자의 카테고리를 나타냅니다. 블록과 카테고리는, 문자 클래스의 내부 및 외부의 어느 쪽에도 사용할 수 있습니다.

 <p> 지원되고 있는 카테고리는,<A HREF="../../../java/lang/Character.html" title="java.lang 안의 클래스"><CODE>Character</CODE></A>  클래스에서 지정된 버젼의 <a href="http://www.unicode.org/unicode/standard/standard.html"><i>The Unicode Standard</i></a>  에 기재되어 있습니다. 카테고리명에 대해서는, Unicode 표준에 규준과 정보가 정의되고 있습니다. <code>Pattern</code> 의 지원하는 블록명은,<A HREF="../../../java/lang/Character.UnicodeBlock.html#forName(java.lang.String)"><CODE>UnicodeBlock.forName</CODE></A>  에 의해 받아들여져 정의되는 유효한 블록명입니다.

<a name="jcc"> <p><i>methodname</i> 메소드 (비추천의 메소드를 제외하다)인 java.lang.Character boolean 와 같게 기능하는 카테고리는, 지정된 프로퍼티이 이름 <tt>java<i>methodname</i></tt> 를 가지는, 동일한 <tt>\p{</tt><i>prop</i><tt>}</tt> 구문 전체로 사용 가능합니다.

<h4> Perl 5 라는 비교 </h4>

 <p><code>Pattern</code> 엔진은, Perl 5 로 같이, 순서 붙이고 된 대체에 대한 종래의 NFA 베이스의 매칭을 실행합니다.

 <p> 이 클래스에서 지원되어 있지 않은 Perl 구문 </p>

 <ul>

<li><p> 조건부 구문 <tt>(? {</tt><i>X</i><tt>})</tt> 및 <tt>(? (</tt><i>조건</i><tt>)</tt><i>X</i><tt>|</tt><i>Y</i><tt>)</tt>
    </p></li>

<li><p> 매입 코드 구문 <tt>(? {</tt><i>코드</i><tt>})</tt> 및 <tt>(??{</tt><i>코드</i><tt>})</tt></p></li>

<li><p> 매입 코멘트 구문 <tt>(? #코멘트)</tt> </p></li>

<li><p> 프리프로세스 연산 <tt>\l</tt> <tt>&#92;u</tt>,<tt>\L</tt>,<tt>\U</tt>  </p></li>

 </ul>

 <p> 이 클래스에서 지원되고 있지만, Perl 로 지원되어 있지 않은 구문 탐욕인 수량자.  </p>

 <ul>

<li><p> 가능한 한 긴 캐릭터 라인과 매치 한다.  퇴보 (백 트럭) 하면 정규 표현 전체의 매치이 성공할 때에도, 퇴보 하지 않는다  </p></li>

<li><p> 문자 클래스의 결합과 교차 (<a href="#cc">전술</a>)</p></li>

 </ul>

 <p> Perl 와의 큰 차이점 </p>

 <ul>

<li><p> Perl 에서는,<tt>\1</tt> ~ <tt>\9</tt> 는 항상 전방 참조라고 해석된다. <tt> </tt> (을)를 넘는 숫자가 backslash로 이스케이프 되고 있을 때는, 대응하는 수의 부분 패턴이 존재하는 경우, 전방 참조로 간주해진다.  존재하지 않는 경우는, 8 진수의 이스케이프 (가능한 경우)로 간주해진다. 이 클래스에서는, 8 진수의 이스케이프는 항상 제로로 시작된다. <tt>\1</tt> ~ <tt>\9</tt> 는, 항상 전방 참조라고 해석된다. 그것보다 큰 숫자는, 정규 표현의 그 개소에 대응하는 수의 부분 패턴이 존재하는 경우는, 전방 참조로 간주해진다.  존재하지 않는 경우는, 그 숫자가 기존의 그룹 번호 이하가 되는지, 1 자리수의 숫자가 될 때까지, 자리수가 줄여진다
    </p></li>

<li><p> Perl 에서는, 마지막 매치이 종료한 장소로부터 매치의 재개를 요구할 때는,<tt>g</tt> 플래그를 사용한다. 이 기능은,<A HREF="../../../java/util/regex/Matcher.html" title="java.util.regex 안의 클래스"><CODE>Matcher</CODE></A>  클래스에 의해 암묵적으로 제공된다. <A HREF="../../../java/util/regex/Matcher.html#find()"><CODE>find</CODE></A>  메소드를 반복해 호출하면(자), 정규 표현 엔진이 리셋 되지 않는 한, 마지막 매치이 종료한 장소로부터 매치 조작이 재개한다  </p></li>

<li><p> Perl 에서는, 표현의 최상정도에 파묻힌 플래그가 표현 전체에 적용된다. 이 클래스의 매입 플래그는, 파묻힌 장소에 관계없이, 그 개소에서만 유효하게 된다.  플래그가 그룹내에 파묻히고 있는 경우는, Perl 와 같게 그룹의 최후로 복원된다  </p></li>

<li><p> Perl 에서는, 표현 <tt>*a</tt> 등이 부정한 매치 구문이나 표현 <tt>abc]</tt> 등의 매달려 괄호를 허용 하고 있어, 그것들을 리터럴로 간주한다. 이 클래스에서도 매달려 괄호는 받아들이지만,+,? ,* 등의 매달려 메타캐라크타는 허용 하지 않고, 그것들이 발견되었을 경우는 <A HREF="../../../java/util/regex/PatternSyntaxException.html" title="java.util.regex 안의 클래스"><CODE>PatternSyntaxException</CODE></A>  를 throw 한다 </p></li>

 </ul>


 <p> 정규 표현 구문의 동작의 상세한 것에 대하여는,<a href="http://www.oreilly.com/catalog/regex2/">「Mastering Regular Expressions, 2nd Edition」 (Jeffrey E.  F.  Friedl 저, O'Reilly and Associates, 2002 년)</a>  을 참조해 주세요.
 </p>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/String.html#split(java.lang.String, int)"><CODE>String.split(String, int)</CODE></A> , 
<A HREF="../../../java/lang/String.html#split(java.lang.String)"><CODE>String.split(String)</CODE></A> , 
<A HREF="../../../serialized-form.html#java.util.regex.Pattern">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#CANON_EQ">CANON_EQ</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;정규 등가를 유효하게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#CASE_INSENSITIVE">CASE_INSENSITIVE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;대문자와 소문자를 구별하지 않는 매칭을 유효하게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#COMMENTS">COMMENTS</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;패턴내에서 공백과 코멘트를 사용할 수 있도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#DOTALL">DOTALL</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOTALL 모드를 유효하게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#LITERAL">LITERAL</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;패턴의 리터럴 구문 분석을 유효하게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#MULTILINE">MULTILINE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;복수행 모드를 유효하게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#UNICODE_CASE">UNICODE_CASE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unicode 에 준거한 대문자와 소문자를 구별하지 않는 매칭을 유효하게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#UNIX_LINES">UNIX_LINES</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unix 라인 모드를 유효하게 합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/util/regex/Pattern.html" title="java.util.regex 내의 클래스">Pattern</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#compile(java.lang.String)">compile</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;regex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 정규 표현을 패턴에 컴파일 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/util/regex/Pattern.html" title="java.util.regex 내의 클래스">Pattern</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#compile(java.lang.String, int)">compile</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;regex,
        int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 플래그를 사용해, 지정된 정규 표현을 패턴에 컴파일 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#flags()">flags</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 패턴의 매치 플래그를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/regex/Matcher.html" title="java.util.regex 내의 클래스">Matcher</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#matcher(java.lang.CharSequence)">matcher</A> </B>(<A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 입력과 이 패턴을 매치 하는 정규 표현 엔진을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#matches(java.lang.String, java.lang.CharSequence)">matches</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;regex,
        <A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 정규 표현을 컴파일 해, 지정된 입력과 그 정규 표현을 매치 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#pattern()">pattern</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 패턴의 컴파일원의 정규 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#quote(java.lang.String)">quote</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>String</code> 의 리터럴 패턴 <code>String</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#split(java.lang.CharSequence)">split</A> </B>(<A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 패턴의 매치에 근거해, 지정된 입력 순서를 분할합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#split(java.lang.CharSequence, int)">split</A> </B>(<A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input,
      int&nbsp;limit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 패턴의 매치에 근거해, 지정된 입력 순서를 분할합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 패턴의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="UNIX_LINES"><!-- --></A> <H3>
UNIX_LINES</H3>
<PRE>
public static final int <B>UNIX_LINES</B></PRE>
<DL>
<DD>Unix 라인 모드를 유효하게 합니다.

 <p> 이 모드에서는,<tt>'\n'</tt> 줄 끝 기호 이외는,<tt>. </tt>,<tt>^</tt>,<tt>$</tt> 의 동작으로 인식되지 않습니다.

 <p> Unix 라인 모드는, 매입 플래그 표현 &nbsp;<tt>(? d)</tt> 사용해 유효하게 할 수도 있습니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.UNIX_LINES">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="CASE_INSENSITIVE"><!-- --></A> <H3>
CASE_INSENSITIVE</H3>
<PRE>
public static final int <B>CASE_INSENSITIVE</B></PRE>
<DL>
<DD>대문자와 소문자를 구별하지 않는 매칭을 유효하게 합니다.

 <p> 디폴트의 대문자와 소문자를 구별하지 않는 매칭에서는, US-ASCII 캐릭터 세트의 문자만이 매치 합니다. Unicode 에 준거한 대문자와 소문자를 구별하지 않는 매칭을 유효하게 하려면 ,<A HREF="../../../java/util/regex/Pattern.html#UNICODE_CASE"><CODE>UNICODE_CASE</CODE></A>  플래그를 이 플래그와 조합해 지정합니다.

 <p> 대문자와 소문자를 구별하지 않는 매칭은, 매입 플래그 표현 &nbsp;<tt>(? i)</tt> 를 사용해 유효하게 할 수도 있습니다.

 <p> 이 플래그를 지정하면(자), 퍼포먼스가 조금 저하하는 경우가 있습니다.   </p>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.CASE_INSENSITIVE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="COMMENTS"><!-- --></A> <H3>
COMMENTS</H3>
<PRE>
public static final int <B>COMMENTS</B></PRE>
<DL>
<DD>패턴내에서 공백과 코멘트를 사용할 수 있도록(듯이) 합니다.

 <p> 이 모드에서는, 공백은 무시되어<tt>#</tt> 로 시작되는 매입 코멘트는 줄 끝까지 무시됩니다.

 <p> 코멘트 모드는, 매입 플래그 표현 &nbsp;<tt>(? x)</tt> 를 사용해 유효하게 할 수도 있습니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.COMMENTS">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="MULTILINE"><!-- --></A> <H3>
MULTILINE</H3>
<PRE>
public static final int <B>MULTILINE</B></PRE>
<DL>
<DD>복수행 모드를 유효하게 합니다.

 <p> 복수행 모드에서는, 표현 <tt>^</tt> 과 <tt>$</tt> 는, 각각 줄 끝 기호 또는 입력 순서의 말미의 직후 또는 직전에 매치 합니다. 디폴트에서는, 이러한 표현은 입력 순서 전체의 선두와 말미에만 매치 합니다.

 <p> 복수행 모드는, 매입 플래그 표현 &nbsp;<tt>(? m)</tt> 를 사용해 유효하게 할 수도 있습니다.   </p>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.MULTILINE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="LITERAL"><!-- --></A> <H3>
LITERAL</H3>
<PRE>
public static final int <B>LITERAL</B></PRE>
<DL>
<DD>패턴의 리터럴 구문 분석을 유효하게 합니다.

 <p> 이 플래그가 지정되고 있는 경우, 패턴을 지정하는 입력 캐릭터 라인은, 리터럴 문자의 순서로서 처리됩니다. 입력 순서내의 메타캐라크타 또는 escape sequence에, 특별한 의미는 없습니다.

 <p>CASE_INSENSITIVE 및 UNICODE_CASE 플래그를 이 플래그와 함께 사용하면(자), 매칭에 대한 영향이 유지됩니다. 다른 플래그는 불필요하게 됩니다.

 <p> 리터럴 구문 분석을 유효하게하기 위한 매입 플래그 문자는 없습니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.LITERAL">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="DOTALL"><!-- --></A> <H3>
DOTALL</H3>
<PRE>
public static final int <B>DOTALL</B></PRE>
<DL>
<DD>DOTALL 모드를 유효하게 합니다.

 <p> DOTALL 모드에서는, 표현 <tt>. </tt> 하행말 기호를 포함한 임의의 문자에 매치 합니다. 디폴트에서는, 이 표현은 줄 끝 기호에 매치 하지 않습니다.

 <p> DOTALL 모드는, 매입 플래그 표현 &nbsp;<tt>(? s)</tt> 를 사용해 유효하게 할 수도 있습니다. (<tt>s</tt> 는 「single-line (단일행)」모드의 니마닉(mnemonic). Perl 에서는 이렇게 불리고 있다. )  </p>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.DOTALL">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="UNICODE_CASE"><!-- --></A> <H3>
UNICODE_CASE</H3>
<PRE>
public static final int <B>UNICODE_CASE</B></PRE>
<DL>
<DD>Unicode 에 준거한 대문자와 소문자를 구별하지 않는 매칭을 유효하게 합니다.

 <p> 이 플래그와 <A HREF="../../../java/util/regex/Pattern.html#CASE_INSENSITIVE"><CODE>CASE_INSENSITIVE</CODE></A>  플래그를 동시에 지정했을 경우는, Unicode 표준에 준거한 대문자와 소문자를 구별하지 않는 매칭을 합니다. 디폴트의 대문자와 소문자를 구별하지 않는 매칭에서는, US-ASCII 캐릭터 세트의 문자만이 매치 합니다.

 <p> Unicode 에 준거한 대문자와 소문자를 구별하지 않는 매칭은, 매입 플래그 표현 &nbsp;<tt>(? u)</tt> 를 사용해 유효하게 할 수도 있습니다.

 <p> 이 플래그를 지정하면(자), 퍼포먼스가 저하하는 경우가 있습니다.   </p>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.UNICODE_CASE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="CANON_EQ"><!-- --></A> <H3>
CANON_EQ</H3>
<PRE>
public static final int <B>CANON_EQ</B></PRE>
<DL>
<DD>정규 등가를 유효하게 합니다.

 <p> 이 플래그를 지정했을 때는, 2 개의 문자의 완전한 정규 분해가 매치 했을 경우에 한정해, 그러한 문자가 매치 한다고 보입니다. 예를 들어, 이 플래그를 지정하면(자), 표현 <tt>"a&#92;u030A"</tt> 는 캐릭터 라인 <tt>"&#92;u00E5"</tt> 에 매치 합니다. 디폴트의 매칭에서는, 정규 등가가 고려되지 않습니다.

 <p> 정규 등가를 유효하게하기 위한 매입 플래그 문자는 없습니다.

 <p> 이 플래그를 지정하면(자), 퍼포먼스가 저하하는 경우가 있습니다.   </p>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.CANON_EQ">정수 필드치</A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="compile(java.lang.String)"><!-- --></A> <H3>
compile</H3>
<PRE>
public static <A HREF="../../../java/util/regex/Pattern.html" title="java.util.regex 내의 클래스">Pattern</A>  <B>compile</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;regex)</PRE>
<DL>
<DD>지정된 정규 표현을 패턴에 컴파일 합니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>regex</CODE> - 컴파일 되는 표현
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/regex/PatternSyntaxException.html" title="java.util.regex 안의 클래스">PatternSyntaxException</A> </CODE> - 표현의 구문이 무효인 경우</DL>
</DD>
</DL>
<HR>

<A NAME="compile(java.lang.String, int)"><!-- --></A> <H3>
compile</H3>
<PRE>
public static <A HREF="../../../java/util/regex/Pattern.html" title="java.util.regex 내의 클래스">Pattern</A>  <B>compile</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;regex,
                              int&nbsp;flags)</PRE>
<DL>
<DD>지정된 플래그를 사용해, 지정된 정규 표현을 패턴에 컴파일 합니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>regex</CODE> - 컴파일 되는 표현<DD><CODE>flags</CODE> - 매치 플래그. <A HREF="../../../java/util/regex/Pattern.html#CASE_INSENSITIVE"><CODE>CASE_INSENSITIVE</CODE></A> ,<A HREF="../../../java/util/regex/Pattern.html#MULTILINE"><CODE>MULTILINE</CODE></A> ,<A HREF="../../../java/util/regex/Pattern.html#DOTALL"><CODE>DOTALL</CODE></A> ,<A HREF="../../../java/util/regex/Pattern.html#UNICODE_CASE"><CODE>UNICODE_CASE</CODE></A> ,<A HREF="../../../java/util/regex/Pattern.html#CANON_EQ"><CODE>CANON_EQ</CODE></A> ,<A HREF="../../../java/util/regex/Pattern.html#UNIX_LINES"><CODE>UNIX_LINES</CODE></A> ,<A HREF="../../../java/util/regex/Pattern.html#LITERAL"><CODE>LITERAL</CODE></A> , 및 <A HREF="../../../java/util/regex/Pattern.html#COMMENTS"><CODE>COMMENTS</CODE></A>  를 포함할 수 있는 비트 마스크
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 정의가 끝난 매치 플래그에 대응하는 비트치 이외의 값이 <tt>flags</tt> 로 설정되어 있는 경우
<DD><CODE><A HREF="../../../java/util/regex/PatternSyntaxException.html" title="java.util.regex 안의 클래스">PatternSyntaxException</A> </CODE> - 표현의 구문이 무효인 경우</DL>
</DD>
</DL>
<HR>

<A NAME="pattern()"><!-- --></A> <H3>
pattern</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>pattern</B>()</PRE>
<DL>
<DD>이 패턴의 컴파일원의 정규 표현을 돌려줍니다.
 </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 패턴의 컴파일원</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD><p>이 패턴의 캐릭터 라인 표현을 돌려줍니다. 이것은, 이 패턴의 컴파일원의 정규 표현입니다. </p>
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 패턴의 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="matcher(java.lang.CharSequence)"><!-- --></A> <H3>
matcher</H3>
<PRE>
public <A HREF="../../../java/util/regex/Matcher.html" title="java.util.regex 내의 클래스">Matcher</A>  <B>matcher</B>(<A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input)</PRE>
<DL>
<DD>지정된 입력과 이 패턴을 매치 하는 정규 표현 엔진을 작성합니다.
 </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 매치되는 문자 순서
<DT><B>반환값:</B><DD>이 패턴의 새로운 정규 표현 엔진</DL>
</DD>
</DL>
<HR>

<A NAME="flags()"><!-- --></A> <H3>
flags</H3>
<PRE>
public int <B>flags</B>()</PRE>
<DL>
<DD>이 패턴의 매치 플래그를 돌려줍니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 패턴이 컴파일 되었을 때에 지정된 매치 플래그</DL>
</DD>
</DL>
<HR>

<A NAME="matches(java.lang.String, java.lang.CharSequence)"><!-- --></A> <H3>
matches</H3>
<PRE>
public static boolean <B>matches</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;regex,
                              <A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input)</PRE>
<DL>
<DD>지정된 정규 표현을 컴파일 해, 지정된 입력과 그 정규 표현을 매치 합니다.

 <p> 이 메소드를 다음의 형식에서 호출하면(자), 상기의 동작을 합니다.

 <blockquote><pre>
 Pattern.matches(regex, input);</pre></blockquote>

상기의 메소드는, 다음의 표현과 같게 동작합니다.

 <blockquote><pre>
 Pattern.compile(regex). matcher(input). matches()</pre></blockquote>

 <p> 패턴을 반복해 사용하는 경우는, 그 패턴을 컴파일 해 재사용한 (분)편이, 매회 이 메소드를 호출하는 것보다도 효율적입니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>regex</CODE> - 컴파일 되는 표현<DD><CODE>input</CODE> - 매치되는 문자 순서
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/regex/PatternSyntaxException.html" title="java.util.regex 안의 클래스">PatternSyntaxException</A> </CODE> - 표현의 구문이 무효인 경우</DL>
</DD>
</DL>
<HR>

<A NAME="split(java.lang.CharSequence, int)"><!-- --></A> <H3>
split</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>split</B>(<A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input,
                      int&nbsp;limit)</PRE>
<DL>
<DD>이 패턴의 매치에 근거해, 지정된 입력 순서를 분할합니다.

 <p> 이 메소드로부터 반환되는 배열은, 입력 순서의 부분 캐릭터 라인으로 구성됩니다.  이러한 부분 캐릭터 라인은, 이 패턴과 매치 하는 다른 부분 순서에 의해 분할된 캐릭터 라인인가, 입력 순서의 종료에 의해 분할된 캐릭터 라인입니다. 배열내의 부분 캐릭터 라인은, 입력 순서내에서 발생한 차례로 줄지어 있습니다. 이 패턴이 입력 순서의 부분 순서에 매치 하지 않는 경우, 결과적으로 얻을 수 있는 배열은 1 개의 요소, 즉 캐릭터 라인 형식의 입력 순서만으로 구성됩니다.

 <p> <tt>limit</tt> 파라미터는, 이 패턴의 적용 회수, 즉, 결과적으로 얻을 수 있는 배열의 길이를 제어합니다. 제한 <i>n</i> 가 제로보다 큰 경우, 이 패턴은 <i>n</i>&nbsp;-&nbsp;1 회이하의 회수가 적용되어 배열의 길이는 <i>n</i> 이하가 됩니다.  배열의 마지막 엔트리에는, 마지막에 매치 한 단락 문자 이후의 입력 순서가 모두 포함됩니다. n</i> 가 0 보다 작은 값의 경우, 이 패턴의 적용 회수와 배열의 길이는 제한되지 않습니다. <i>n</i> 가 제로의 경우, 이 패턴의 적용 회수와 배열의 길이는 제한됩니다만, 후속의 빈 상태(empty)의 캐릭터 라인은 파기됩니다.

 <p> 예를 들어, 입력 순서 <tt>"boo:and:foo"</tt> 는, 이러한 파라미터에 의해 다음과 같이 분할됩니다.

 <blockquote><table cellpadding=1 cellspacing=0
              summary="Split examples showing regex, limit, and result">
<tr><th><P align="left"><i>정규 표현 &nbsp;&nbsp;&nbsp;&nbsp;</i></th>
<th><P align="left"><i>제한 &nbsp;&nbsp;&nbsp;&nbsp;</i></th>
<th><P align="left"><i>결과 &nbsp;&nbsp;&nbsp;&nbsp;</i></th></tr>
 <tr><td align=center>:</td>
     <td align=center>2</td>
<td><tt>{ "boo", "and:foo" }</tt></td></tr>
 <tr><td align=center>:</td>
     <td align=center>5</td>
<td><tt>{ "boo", "and", "foo" }</tt></td></tr>
 <tr><td align=center>:</td>
     <td align=center>-2</td>
<td><tt>{ "boo", "and", "foo" }</tt></td></tr>
<tr><td align=center>o</td>
     <td align=center>5</td>
<td><tt>{ "b", "", ":and:f", "", "" }</tt></td></tr>
<tr><td align=center>o</td>
     <td align=center>-2</td>
<td><tt>{ "b", "", ":and:f", "", "" }</tt></td></tr>
<tr><td align=center>o</td>
     <td align=center>0</td>
<td><tt>{ "b", "", ":and:f" }</tt></td></tr>
 </table></blockquote>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 분할되는 문자 순서<DD><CODE>limit</CODE> - 결과의 임계치 (상기대로)
<DT><B>반환값:</B><DD>이 패턴의 매치의 양단으로 입력을 분할하는 것에 의해 계산된 캐릭터 라인의 배열</DL>
</DD>
</DL>
<HR>

<A NAME="split(java.lang.CharSequence)"><!-- --></A> <H3>
split</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>split</B>(<A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input)</PRE>
<DL>
<DD>이 패턴의 매치에 근거해, 지정된 입력 순서를 분할합니다.

 <p> 이 메소드는, limit 인수를 제로로 해 <A HREF="../../../java/util/regex/Pattern.html#split(java.lang.CharSequence, int)"><CODE>split</CODE></A>  메소드를 호출했을 경우와 같게 입력 순서를 분할합니다. 즉, 결과적으로 얻을 수 있는 배열에는 후속의 빈 상태(empty)의 캐릭터 라인은 포함되지 않습니다.  </p>

 <p> 예를 들어, 입력 순서 <tt>"boo:and:foo"</tt> 는, 이러한 표현에 의해 다음과 같이 분할됩니다.

 <blockquote><table cellpadding=1 cellspacing=0
              summary="Split examples showing regex and result">
<tr><th><P align="left"><i>정규 표현 &nbsp;&nbsp;&nbsp;&nbsp;</i></th>
<th><P align="left"><i>결과</i></th></tr>
 <tr><td align=center>:</td>
<td><tt>{ "boo", "and", "foo" }</tt></td></tr>
<tr><td align=center>o</td>
<td><tt>{ "b", "", ":and:f" }</tt></td></tr>
 </table></blockquote>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 분할되는 문자 순서
<DT><B>반환값:</B><DD>이 패턴의 매치의 양단으로 입력을 분할하는 것에 의해 계산된 캐릭터 라인의 배열</DL>
</DD>
</DL>
<HR>

<A NAME="quote(java.lang.String)"><!-- --></A> <H3>
quote</H3>
<PRE>
public static <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>quote</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;s)</PRE>
<DL>
<DD>지정된 <code>String</code> 의 리터럴 패턴 <code>String</code> 를 돌려줍니다.

 <p>이 메소드는, 리터럴 패턴인것 같이 캐릭터 라인 <code>s</code> 에 매치 하는 <code>Pattern</code> 의 작성에 사용 가능한 <code>String</code> 를 생성합니다. </p> 입력 순서내의 메타캐라크타 또는 escape sequence에, 특별한 의미는 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 리터럴화하는 캐릭터 라인
<DT><B>반환값:</B><DD>리터럴 캐릭터 라인 치환<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Pattern.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/regex/MatchResult.html" title="java.util.regex 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/util/regex/PatternSyntaxException.html" title="java.util.regex 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/regex/Pattern.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Pattern.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
