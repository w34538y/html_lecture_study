<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:56:52 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Object (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Object (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Object.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/NumberFormatException.html" title="java.lang 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/OutOfMemoryError.html" title="java.lang 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Object.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Object.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang</FONT>
<BR>
클래스 Object</H2>
<PRE>
<B>java.lang.Object</B>
</PRE>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>Object</B></DL>
</PRE>

<P>
<code>Object</code> 클래스는, 클래스 계층 루트입니다. 모든 클래스는, 슈퍼 클래스로서 <code>Object</code> 를 가집니다. 배열을 포함한 모든 객체는, 이 클래스의 메소드를 구현합니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스"><CODE>Class</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Object.html#Object()">Object</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#clone()">clone</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 객체의 카피를 작성해, 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 객체와 「등가」가 되는 객체가 있을지 어떨지를 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#finalize()">finalize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 객체에의 참조는 이제 없으면 가베지 컬렉션에 의해 판단되었을 때에, 가비지 컬렉터에 의해 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#getClass()">getClass</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Object</code> 의 실행시 클래스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;객체의 해시 코드값를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#notify()">notify</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 객체의 모니터로 대기중의 thread를 1 개 재개합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 객체의 모니터로 대기중의 모든 thread를 재개합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;객체의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#wait()">wait</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다른 thread가 이 객체의 <A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>  메소드 또는 <A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A>  메소드를 호출할 때까지, 현재의 thread를 대기시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#wait(long)">wait</A> </B>(long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다른 thread가 이 객체의 <A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>  메소드 또는 <A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A>  메소드를 호출하는지, 지정된 시간이 경과할 때까지, 현재의 thread를 대기시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </B>(long&nbsp;timeout,
     int&nbsp;nanos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다른 thread가 이 객체의 <A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>  메소드 또는 <A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A>  메소드를 호출하는지, 다른 thread가 현재의 thread에 인터럽트를 걸거나 지정된 양의 실시간이 경과할 때까지, 현재의 thread를 대기시킵니다. </TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Object()"><!-- --></A> <H3>
Object</H3>
<PRE>
public <B>Object</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getClass()"><!-- --></A> <H3>
getClass</H3>
<PRE>
public final <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>getClass</B>()</PRE>
<DL>
<DD>이 <code>Object</code> 의 실행시 클래스를 돌려줍니다. 반환되는 <code>Class</code> 객체는, 나타내진 클래스의 <code>static synchronized</code> 메소드에 의해 락 되는 객체입니다.

 <p><b>실제의 결과형은 <code>Class&lt;?  extends |X|&gt;</code> 입니다. 여기서,<code>|X|</code> 는 <code>getClass</code> 가 불려 가는 static 형의 이레이쟈입니다. </b>예를 들어, 이 코드의 발췌에서는 캐스트는 필요 없습니다. </p>

 <p>
<code>Number n = 0;                             </code><br> <code>Class&lt;?  extends Number&gt; c = n.getClass(); </code>
 </p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 객체의 실행시 클래스를 나타내는 <code>Class</code> 객체<DT><B>관련 항목:</B><DD><a href="http://java.sun.com/docs/books/jls/">「Java 언어 스펙, 제 3 판」 (15.8. 2 Class Literals)</a> </DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>객체의 해시 코드값를 돌려줍니다. 이 메소드는,<code>java.util.Hashtable</code> 에 의해 제공되는 것 같은 해시 테이블로 사용하기 위해서 준비되어 있습니다.  &nbsp;<p>
<code>hashCode</code> 메소드의 일반적인 규칙을 다음에 나타냅니다.  
 <ul>
<li>Java 어플리케이션의 실행중에 같은 객체상에서 여러 차례 불려 가는 경우는 반드시, 이 객체에 대한 <tt>equals</tt> 에 의한 비교로 사용된 정보가 변경되어 있지 않으면,<tt>hashCode</tt> 메소드는 같은 정수를 일관해 돌려주지 않으면 안 된다. 다만, 이 정수는 같은 어플리케이션의 실행 마다 같은 필요는 없다 
<li><tt>equals(Object)</tt> 메소드로 2 개의 객체가 등가로 여겨졌을 경우, 어느 쪽의 객체로 <code>hashCode</code> 메소드를 호출해도 결과는 같은 정수치가 되어야 하다 
<li><A HREF="../../java/lang/Object.html#equals(java.lang.Object)"><CODE>equals(java.lang.Object)</CODE></A>  메소드로 2 개의 객체가 등가가 아니다고 여겨졌을 경우는, 이러한 객체에 대해서 <tt>hashCode</tt> 메소드를 호출했을 때에, 결과가 다른 정수치가 되지 않아도 상관없다. 그러나, 동일하지 않은 객체에 대해서는 다른 정수치가 생성되도록 하면, 해시 테이블의 퍼포먼스를 올릴 수가 있다
 </ul>
 <p>
할 수 있는 한,<tt>Object</tt> 클래스에서 정의되는 hashCode 메소드는, 다른 객체에 대해서는 다른 정수치를 돌려줍니다. 일반적으로, 이것은 객체의 내부 주소를 정수치로 변환하는 형태로 구현됩니다만, 그러한 구현 테크닉은 Java<font size="-2"><sup>TM</sup></font> 프로그램 언어에서는 불필요합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 객체의 해시 코드값<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#equals(java.lang.Object)"><CODE>equals(java.lang.Object)</CODE></A> , 
<A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>이 객체와 「등가」가 되는 객체가 있을지 어떨지를 나타냅니다.  &nbsp;<p>
<code>equals</code> 메소드는, null 이외의 객체 참조에서의 동치 관계를 구현합니다.
 <ul>
<li>반사성 (<i>reflexive</i>) :null 이외의 참조치 <code>x</code> 에 대해,<code>x.equals(x)</code> 는 <code>true</code> 를 돌려준다
<li>대칭성 (<i>symmetric</i>) :null 이외의 참조치 <code>x</code> 와 <code>y</code> 에 대해,<code>x.equals(y)</code> 는,<code>y.equals(x)</code> 가 <code>true</code> 를 돌려주는 경우만 <code>true</code> 를 돌려준다
<li>추이성 (<i>transitive</i>) :null 이외의 참조치 <code>x</code>,<code>y</code>,<code>z</code> 에 대해,<code>x.equals(y)</code> 가 <code>true</code> 를 돌려주어, 한편 <code>y.equals(z)</code> 가 <code>true</code> 를 돌려주는 경우에,<code>x.equals(z)</code> 는 <code>true</code> 를 돌려준다
<li>무결성 (<i>consistent</i>) :null 이외의 참조치 <code>x</code> 및 <code>y</code> 에 대해,<tt>x.equals(y)</tt> 를 복수 호출하면(자) 항상 <code>true</code> 를 돌려주는지, 항상 <code>false</code> 를 돌려준다.  이것은, 객체에 대한 <code>equals</code> 에 의한 비교로 사용된 정보가 변경되어 있지 않은 것이 조건이다
<li>null 가 아닌 임의의 참조치 <code>x</code> 에 대해,<code>x.equals(null)</code> 는 <code>false</code> 를 돌려준다
 </ul>
 <p>
<code>Object</code> 클래스의 <tt>equals</tt> 메소드는, 가장 비교하기 쉬운 객체의 동치 관계를 구현합니다.  즉, null 이외의 참조치 <code>x</code> 와 <code>y</code> 에 대해, 이 메소드는 <code>x</code> 와 <code>y</code> 가 같은 객체를 참조하는 (<code>x == y</code> 가 <code>true</code>) 경우에만 <code>true</code> 를 돌려줍니다.  &nbsp;<p>
일반적으로, 이 메소드를 오버라이드(override) 하는 경우는,<tt>hashCode</tt> 메소드를 항상 오버라이드(override) 해, 「등가인 객체는 등가인 해시 코드를 보관 유지할 필요가 있다」라고 하는 <tt>hashCode</tt> 메소드의 범용 규약에 따를 필요가 있는 것에 유의해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 비교 대상의 참조 객체
<DT><B>반환값:</B><DD>obj 인수로 지정된 객체와 이 객체가 동일한 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#hashCode()"><CODE>hashCode()</CODE></A> , 
<A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="clone()"><!-- --></A> <H3>
clone</H3>
<PRE>
protected <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>clone</B>()
                throws <A HREF="../../java/lang/CloneNotSupportedException.html" title="java.lang 내의 클래스">CloneNotSupportedException</A> </PRE>
<DL>
<DD>이 객체의 카피를 작성해, 돌려줍니다. 「카피」의 정확한 이유는, 객체의 클래스에 의해 다릅니다. 일반적으로는, 임의의 객체 <tt>x</tt> 에 대해, 다음의 식
 <blockquote>
 <pre>
 x.clone() ! = x</pre></blockquote>
하지만 true 이며, 다음의 식
 <blockquote>
 <pre>
 x.clone(). getClass() == x.getClass()</pre></blockquote>
도 <tt>true</tt> 인 것입니다만, 이것들도 절대적인 요건이 아닙니다. 또 다음의 식
 <blockquote>
 <pre>
 x.clone(). equals(x)</pre></blockquote>
도 일반적으로 <tt>true</tt> 가 됩니다만, 이것도 절대적인 요건이 아닙니다.  &nbsp;<p>
일반적으로,<tt>super.clone</tt> 를 호출하는 것으로 반환되는 객체를 취득할 수 있습니다. 클래스 및 그 슈퍼 클래스 모든 것 (<tt>Object</tt> 를 제외한다)이 이 규칙에 따르는 경우,<tt>x.clone(). getClass() == x.getClass()</tt> 가 성립합니다.  &nbsp;<p>
일반적으로, 이 메소드에 의해 반환되는 객체는, 이 객체 (복제되고 있다)로부터 독립하고 있을 필요가 있습니다. 이 독립성을 달성하기 위해(때문에),<tt>super.clone</tt> 가 돌려주는 객체의 필드를 1 개 이상 (객체가 돌려주기 전에) 변경하는 것이 필요하게 되는 경우가 있습니다. 이것은, 일반적으로, 복제하는 객체의 내부 「심층 구조」를 구성하는 가변 객체의 카피, 및 이러한 객체에의 참조를 카피에의 참조에 옮겨놓는 것을 의미합니다. 클래스에 프리미티브(primitive) 필드 또는 불변 객체에의 참조만이 포함되는 경우, 일반적으로,<tt>super.clone</tt> 에 의해 반환되는 객체내의 필드를 변경할 필요는 없습니다.  &nbsp;<p>
<tt>Object</tt> 클래스의 <tt>clone</tt> 메소드는, 특정의 복제 처리를 실행합니다. 우선, 이 객체의 클래스가 <tt>Cloneable</tt> 인터페이스를 구현하고 있지 않는 경우는,<tt>CloneNotSupportedException</tt> 가 throw 됩니다. 배열은 모두, 인터페이스 <tt>Cloneable</tt> 를 구현하고 있는 것이라고 보여지는 것에 주의해 주세요. 구현하고 있지 않는 경우, 이 메소드는 이 객체의 클래스의 새로운 인스턴스를 생성해, 그 필드를 모두, 이 객체의 대응하는 각 필드의 내용으로 초기화합니다.  이것은 대입과 같아, 필드의 내용 자신이 복제되는 것은 아닙니다. 즉 이 메소드는, 객체의 「shallow 복사」를 생성합니다만, 「딥 카피」는 생성하지 않습니다.  &nbsp;<p>
<tt>Object</tt> 클래스 자체는,<tt>Cloneable</tt> 인터페이스를 구현하지 않기 때문에, 클래스가 <tt>Object</tt> 인 <tt>clone</tt> 메소드를 호출하면(자), 실행시에 예외가 throw 됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 인스턴스의 복제
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/CloneNotSupportedException.html" title="java.lang 안의 클래스">CloneNotSupportedException</A> </CODE> - 객체의 클래스가 <code>Cloneable</code> 인터페이스를 지원하고 있지 않는 경우. <code>clone</code> 메소드를 오버라이드(override) 한 서브 클래스도, 인스턴스를 복제할 수 없는 것을 나타내기 위해서(때문에) 이 예외를 throw 하는 일이 있는<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스"><CODE>Cloneable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>객체의 캐릭터 라인 표현을 돌려줍니다. 일반적으로,<code>toString</code> 메소드는 이 객체를 「텍스트로 표현한다」캐릭터 라인을 돌려줍니다. 이 결과는, 인간이 읽을 수 있는 간결하고 유익한 정보여야 합니다. 모든 서브 클래스에서, 이 메소드를 오버라이드(override) 하는 것을 추천합니다.  &nbsp;<p>
<code>Object</code> 클래스의 <code>toString</code> 메소드는, 객체의 파생원의 클래스명, @ 부호 (<code>@</code>), 및 객체의 해시 코드의 부호 없음 16 진표현으로부터 구성되는 캐릭터 라인을 돌려줍니다. 즉, 이 메소드는 다음의 값과 동일한 캐릭터 라인을 돌려줍니다.
 <blockquote>
 <pre>
 getClass(). getName() + '@' + Integer.toHexString(hashCode())
 </pre></blockquote>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 객체의 캐릭터 라인 표현</DL>
</DD>
</DL>
<HR>

<A NAME="notify()"><!-- --></A> <H3>
notify</H3>
<PRE>
public final void <B>notify</B>()</PRE>
<DL>
<DD>이 객체의 모니터로 대기중의 thread를 1 개 재개합니다. 이 객체로 복수의 thread가 대기중의 경우는, 그 중의 1 개를 재개합니다. 이 선택은 임의로, 구현에 따라서 다릅니다. thread는,<code>wait</code> 메소드를 호출하면(자), 객체의 모니터로 대기합니다.  &nbsp;<p>
재개된 thread의 처리는, 현재의 thread가 이 객체의 락을 해제할 때까지는 진행될 수가 없습니다. 재개된 thread는, 다른 thread와 같이, 이 객체와 동기 하도록(듯이) 적극적으로 겨룹니다.  예를 들어, 이 객체를 잠그는 다음의 thread가 되려고 하는 경우에서도, 재개된 thread의 취급은 다른 thread보다 우세하지도 열세하지도 않습니다.  &nbsp;<p>
이 메소드를 호출하는 것은, 이 객체의 모니터를 소유하는 thread 뿐만이 아니면 안됩니다. thread가 객체의 모니터의 오너가 되는 방법은, 다음의 3 방법이 있습니다.  
 <ul>
<li>객체의 synchronized 인스턴스 메소드를 실행한다 
<li>객체를 동기화하는 <code>synchronized</code> 문의 본체를 실행한다 
<li><code>Class</code> 형의 객체의 경우는, 그 클래스의 syncronized static 메소드를 실행한다 
 </ul>
 <p>
객체의 모니터를 소유할 수 있는 thread는 1 회에 1 개 뿐입니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 현재의 thread가 이 객체의 모니터를 소유하고 있지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A> , 
<A HREF="../../java/lang/Object.html#wait()"><CODE>wait()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="notifyAll()"><!-- --></A> <H3>
notifyAll</H3>
<PRE>
public final void <B>notifyAll</B>()</PRE>
<DL>
<DD>이 객체의 모니터로 대기중의 모든 thread를 재개합니다. thread는,<code>wait</code> 메소드를 호출하면(자), 객체의 모니터로 대기합니다.  &nbsp;<p>
재개된 thread의 처리는, 현재의 thread가 이 객체의 락을 해제할 때까지는 진행될 수가 없습니다. 재개된 thread는, 다른 thread와 같이, 이 객체와 동기 하도록(듯이) 적극적으로 겨룹니다.  예를 들어, 이 객체를 잠그는 다음의 thread가 되려고 하는 경우에서도, 재개된 thread의 취급은 다른 thread보다 우세하지도 열세하지도 않습니다.  &nbsp;<p>
이 메소드를 호출하는 것은, 이 객체의 모니터를 소유하는 thread 뿐만이 아니면 안됩니다. thread가 객체의 모니터의 오너가 되는 방법에 대해서는,<code>notify</code> 메소드를 참조해 주세요.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 현재의 thread가 이 객체의 모니터를 소유하고 있지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A> , 
<A HREF="../../java/lang/Object.html#wait()"><CODE>wait()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="wait(long)"><!-- --></A> <H3>
wait</H3>
<PRE>
public final void <B>wait</B>(long&nbsp;timeout)
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>다른 thread가 이 객체의 <A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>  메소드 또는 <A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A>  메소드를 호출하는지, 지정된 시간이 경과할 때까지, 현재의 thread를 대기시킵니다.  &nbsp;<p>
현재의 thread는, 이 객체의 모니터의 오너가 아니면 안됩니다.  &nbsp;<p>
이 메소드는, 현재의 thread (여기에서는 <var>T</var> 로 한다)를 이 객체의 대기 세트에 넣고 나서, 이 객체에 대한 동기 요구를 모두 폐기합니다. thread <var>T</var> 는, thread의 스케줄링에 대해서는 무효로 여겨져 이하의 4 개의 어떤 것인가가 발생할 때까지 대기합니다.
 <ul>
<li>다른 thread가 이 객체에 대해서 <tt>notify</tt> 메소드를 호출해, 재개되는 thread로서 thread <var>T</var> 가 선택되었다 
<li>다른 thread가 이 객체에 대해서 <tt>notifyAll</tt> 메소드를 호출했다 
<li>다른 thread가 thread <var>T</var> 에 <A HREF="../../java/lang/Thread.html#interrupt()">끼어든다</A>  
<li>지정된 실시간이 경과했다. <tt>timeout</tt> 가 제로의 경우, 실시간이 고려될 것은 없고, thread는 통지를 받을 때까지 계속 대기한다 
 </ul>
그 후 thread <var>T</var> 는 이 객체의 대기 세트로부터 삭제되어 thread의 스케줄링이 다시 가능하게 됩니다. 이후, 이 thread는 일반적으로대로, 객체와 동기화할 권리를 다른 thread와 경쟁합니다.  객체의 제어를 획득하면, 객체에 대한 이 thread의 동기 요구는, 이전 상태, 즉,<tt>wait</tt> 메소드가 불려 갔을 때 상태에 복원됩니다. 다음에 thread <var>T</var> 는 <tt>wait</tt> 메소드의 호출로부터 복귀합니다. 이렇게 해,<tt>wait</tt> 메소드로부터 복귀한 시점에서, 객체 및 thread <tt>T</tt> 의 동기 상태는,<tt>wait</tt> 메소드가 불려 갔을 때와 완전히 같게 됩니다.  &nbsp;<p>
thread는, 통지, 끼어들어, 타임 아웃없이 재개되는 일이 있습니다.  이것은, 「위조(spurious)된 재개(wake up)들」이라고 불리고 있습니다. 위조(spurious)된 재개(wake up)들은, 실제로는 보기 드물게 밖에 발생합니다만, 어플리케이션에서는, thread가 재개되는 것으로 발생할 가능성이 있는 조건을 테스트해, 조건이 채워지지 않은 경우는 대기를 계속해, 위조(spurious)된 재개(wake up)들으로부터 보호하지 않으면 안됩니다. 즉, 다음과 같이 루프로 항상 대기가 발생하도록(듯이) 할 필요가 있습니다.
 <pre>
synchronized (obj) {
while (&lt;condition does not hold&gt;)
obj.wait(timeout);
... // Perform action appropriate to condition
     }
 </pre>
(이 토픽의 자세한 것은, Doug Lea 저 「Concurrent Programming in Java (Second Edition)」(Addison-Wesley, 2000)의 섹션 3.2. 3 이나 Joshua Bloch 저 「Effective Java Programming Language Guide」(Addison-Wesley, 2001)의 아이템 50 을 참조해 주세요).

 <p>현재의 thread가 대기하기 전이나 대기중에 몇개의 thread에 의해<A HREF="../../java/lang/Thread.html#interrupt()">끼어들어졌을 </a>경우는,<tt>InterruptedException</tt> 가 throw 됩니다. 이 예외는, 이 객체의 락 상태가 전술과 같이 복원될 때까지는 throw 되지 않습니다.

 <p>
현재의 thread를 이 객체의 대기 세트에 넣을 때,<tt>wait</tt> 메소드는 이 객체의 락만을 해제합니다. 현재의 thread가 동기를 잡을 가능성이 있는 그 외의 객체는, 이 thread가 대기하고 있는 동안도 락 된대로 입니다.  &nbsp;<p>
이 메소드를 호출하는 것은, 이 객체의 모니터를 소유하는 thread 뿐만이 아니면 안됩니다. thread가 객체의 모니터의 오너가 되는 방법에 대해서는,<code>notify</code> 메소드를 참조해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>timeout</CODE> - 밀리 세컨드 단위의 대기 시간
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - timeout 의 값이 부인 경우
<DD><CODE><A HREF="../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 현재의 thread가 객체의 모니터를 소유하고 있지 않는 경우
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread가 통지를 대기하기 전 또는 대기중에, 몇개의 thread가 현재의 thread에 끼어들었을 경우. 이 예외가 throw 되면(자), 현재의 thread의 「인터럽트 상태」는 클리어 되는<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A> , 
<A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="wait(long, int)"><!-- --></A> <H3>
wait</H3>
<PRE>
public final void <B>wait</B>(long&nbsp;timeout,
                       int&nbsp;nanos)
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>다른 thread가 이 객체의 <A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>  메소드 또는 <A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A>  메소드를 호출하는지, 다른 thread가 현재의 thread에 인터럽트를 걸거나 지정된 양의 실시간이 경과할 때까지, 현재의 thread를 대기시킵니다.  &nbsp;<p>
이 메소드는, 인수가 1 개의 <code>wait</code> 메소드를 닮아 있습니다만, 타임 아웃까지의 대기 시간의 양을 보다 세세하게 제어할 수가 있습니다. 나노초단위의 실시간은, 다음의 식에서 지정합니다.
 <blockquote>
 <pre>
 1000000*timeout+nanos</pre></blockquote>
 <p>
그 외의 면에서는, 이 메소드의 동작은 인수가 1 개의 <A HREF="../../java/lang/Object.html#wait(long)"><CODE>wait(long)</CODE></A>  메소드와 같습니다. 특히,<tt>wait(0, 0)</tt> 는 <tt>wait(0)</tt> 와 같은 의미가 됩니다.  &nbsp;<p>
현재의 thread는, 이 객체의 모니터의 오너가 아니면 안됩니다. thread는 이 모니터의 소유권을 해제해, 다음의 어떤 것인가 상태가 발생할 때까지 대기합니다.  
 <ul>
<li>다른 thread가 <code>notify</code> 메소드 또는 <code>notifyAll</code> 메소드를 호출하는 것에 의해, 이 객체의 모니터로 대기중의 thread에 통지를 보내, 이 thread를 재개한다 
<li><code>timeout</code> 인수로 지정한 타임 아웃 기간 (밀리 세컨드 단위)과<code>nanos</code> 인수로 지정한 타임 아웃 기간 (나노초단위)을 더한 시간이 경과한다 
 </ul>
 <p>
그 후, thread는 모니터의 소유권을 재차 취득할 때까지 대기하고 나서 실행을 재개합니다.  &nbsp;<p>
인수가 1 개의 버젼에서는, 인터럽트나 위조(spurious)된 재개(wake up)들이 발생할 가능성이 있으므로, 이 메소드는 항상 루프로 사용될 필요가 있습니다.
 <pre>
synchronized (obj) {
while (&lt;condition does not hold&gt;)
obj.wait(timeout, nanos);
... // Perform action appropriate to condition
     }
 </pre>
이 메소드를 호출하는 것은, 이 객체의 모니터를 소유하는 thread 뿐만이 아니면 안됩니다. thread가 객체의 모니터의 오너가 되는 방법에 대해서는,<code>notify</code> 메소드를 참조해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>timeout</CODE> - 밀리 세컨드 단위의 대기 시간<DD><CODE>nanos</CODE> - 추가의 대기 시간 (나노초단위로 0 ~ 999999 의 범위)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 대기 시간의 값이 부의 경우, 또는 nanos 의 값이 0 ~ 999999 의 범위외의 경우
<DD><CODE><A HREF="../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 현재의 thread가 이 객체의 모니터를 소유하고 있지 않는 경우
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread가 통지를 대기하기 전 또는 대기중에, 몇개의 thread가 현재의 thread에 끼어들었을 경우. 이 예외가 throw 되면(자), 현재의 thread의 「인터럽트 상태」는 클리어 된다</DL>
</DD>
</DL>
<HR>

<A NAME="wait()"><!-- --></A> <H3>
wait</H3>
<PRE>
public final void <B>wait</B>()
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>다른 thread가 이 객체의 <A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>  메소드 또는 <A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A>  메소드를 호출할 때까지, 현재의 thread를 대기시킵니다. 즉, 이 메소드의 동작은 <tt>wait(0)</tt> 를 호출했을 경우와 같습니다.  &nbsp;<p>
현재의 thread는, 이 객체의 모니터의 오너가 아니면 안됩니다. thread는 이 모니터의 소유권을 해제해, 다른 thread가 <code>notify</code> 메소드 또는 <code>notifyAll</code> 메소드를 호출해 이 객체의 모니터상에서 대기하는 thread에 통지를 보낼 때까지 대기합니다. 그 후, thread는 모니터의 소유권을 재차 취득할 때까지 대기하고 나서 실행을 재개합니다.  &nbsp;<p>
인수가 1 개의 버젼에서는, 인터럽트나 위조(spurious)된 재개(wake up)들이 발생할 가능성이 있으므로, 이 메소드는 항상 루프로 사용될 필요가 있습니다.
 <pre>
synchronized (obj) {
while (&lt;condition does not hold&gt;)
obj.wait();
... // Perform action appropriate to condition
     }
 </pre>
이 메소드를 호출하는 것은, 이 객체의 모니터를 소유하는 thread 뿐만이 아니면 안됩니다. thread가 객체의 모니터의 오너가 되는 방법에 대해서는,<code>notify</code> 메소드를 참조해 주세요.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 현재의 thread가 객체의 모니터를 소유하고 있지 않는 경우
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread가 통지를 대기하기 전 또는 대기중에, 몇개의 thread가 현재의 thread에 끼어들었을 경우. 이 예외가 throw 되면(자), 현재의 thread의 「인터럽트 상태」는 클리어 되는<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A> , 
<A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="finalize()"><!-- --></A> <H3>
finalize</H3>
<PRE>
protected void <B>finalize</B>()
                 throws <A HREF="../../java/lang/Throwable.html" title="java.lang 내의 클래스">Throwable</A> </PRE>
<DL>
<DD>이 객체에의 참조는 이제 없으면 가베지 컬렉션에 의해 판단되었을 때에, 가비지 컬렉터에 의해 불려 갑니다. 서브 클래스는 <code>finalize</code> 메소드를 오버라이드(override) 해, system resource를 파기하거나 그 외의 클린 업을 실시하거나 할 수가 있습니다.  &nbsp;<p>
<tt>finalize</tt> 의 일반적인 규약에서는, finalize 의 호출은, 아직 생존하고 있는 임의의 thread가 이 객체에 액세스 하는 방법은 없으면 Java<font size="-2"><sup>TM</sup></font> 가상 머신이 판단했을 경우에 행해집니다.  다만, finalize의 준비가 끝난 것 외의 객체 또는 클래스를 finalize하기 위한 처리의 결과 그렇게 되었을 경우를 제외합니다. <tt>finalize</tt> 메소드는, 이 객체를 다른 thread로 다시 이용 가능하게 하는 일도 포함해, 임의의 액션을 실시할 수가 있습니다.  그러나,<tt>finalize</tt> 의 일반적으로의 용도는, 객체를 재생 불가능한 형태로 파기하기 전의 클린 업을 실행하는 것입니다. 예를 들어, 입출력의 접속을 나타내는 객체의 finalize 메소드는, 객체가 영구적으로 파기되기 전에, 접속을 절단하기 위한 명시적인 입출력 처리를 실시합니다.  &nbsp;<p>
<tt>Object</tt> 클래스의 <tt>finalize</tt> 메소드는, 특별한 처리를 실시하지 않습니다.  일반적으로은, 아무것도 하지 않고 복귀합니다. <tt>Object</tt> 의 서브 클래스는, 이 정의를 오버라이드(override) 할 수가 있습니다.  &nbsp;<p>
Java 프로그램 언어는, 임의의 객체에 대해 어느 thread가 <tt>finalize</tt> 메소드를 호출하는지를 보증하지 않습니다. 그러나, finalize 를 호출하는 thread가, 사용자에게 가시인 동기 락을 finalize 호출의 시점에서는 보관 유지하고 있지 않는 것에 붙어 보증됩니다. 캐치 되지 않는 예외를 finalize 메소드가 throw 했을 경우, 예외는 무시되어 객체의 finalize는 종료합니다.  &nbsp;<p>
어느 객체에 대해 <tt>finalize</tt> 메소드가 불려 간 뒤에 다음의 처리가 발생하는 것은, 아직 생존하고 있는 임의의 thread가 이 객체에 액세스 할 수 있는 방법은 없으면 Java 가상 머신이 다시 판단했을 때입니다. 이것에는, finalize의 준비가 되어 있는 것 외의 객체 또는 클래스에 의해 발생한 처리도 포함되어 그 시점에서 이 객체는 파기됩니다.  &nbsp;<p>
임의의 객체에 대해 Java 가상 머신이 <tt>finalize</tt> 메소드를 여러 차례 호출할 것은 없습니다.  &nbsp;<p>
finalize 메소드에 의해 예외가 throw 되면(자),<code>finalize</code> 메소드의 처리는 정지됩니다. 그렇지 않은 경우는 무시됩니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> </CODE> - 이 메소드로 생긴 <code>Exception</code></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Object.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/NumberFormatException.html" title="java.lang 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/OutOfMemoryError.html" title="java.lang 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Object.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Object.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
