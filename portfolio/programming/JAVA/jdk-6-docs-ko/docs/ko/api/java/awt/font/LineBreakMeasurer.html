<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:55:16 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
LineBreakMeasurer (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="LineBreakMeasurer (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LineBreakMeasurer.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/awt/font/LayoutPath.html" title="java.awt.font 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/awt/font/LineMetrics.html" title="java.awt.font 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/awt/font/LineBreakMeasurer.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="LineBreakMeasurer.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt.font</FONT>
<BR>
클래스 LineBreakMeasurer</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.awt.font.LineBreakMeasurer</B>
</PRE>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public final class <B>LineBreakMeasurer</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
<code>LineBreakMeasurer</code> 클래스를 사용하면, 서식 첨부 텍스트를, 특정의 가시 유효폭에 들어가는 행 (또는 세그먼트(segment))으로 나눌 수가 있습니다. 이것은, 고유의 폭 (<b>랩핑폭</b>으로 불린다)에 들어가는 텍스트의 단락을 클라이언트에 표시하는 경우에 편리합니다.  &nbsp;<p>
<code>LineBreakMeasurer</code> 는, 서식 첨부 텍스트에 대한 반복자를 사용해 구축됩니다. 반복자의 범위는 텍스트내의 1 개의 단락입니다. <code>LineBreakMeasurer</code> 는, 다음의 텍스트 세그먼트(segment)를 개시하기 위해서, 텍스트내의 위치를 포함합니다. 처음은, 이 정도치가 텍스트의 시점입니다. 단락의 방향은, 쌍방향 포맷 규칙에 따라, 전방향 (왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽)에 이릅니다. 단락으로부터 취득된 모든 세그먼트(segment)는, 그 단락과 같은 방향이 됩니다.  &nbsp;<p>
텍스트의 세그먼트(segment)는,<code>nextLayout</code> 메소드를 호출하는 것으로 취득됩니다.  이 메소드는, 랩핑폭에 들어가는 텍스트를 나타내는 <A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 동안의 클래스"><CODE>TextLayout</CODE></A>  를 돌려줍니다. <code>nextLayout</code> 메소드는,<code>nextLayout</code> 가 돌려준 레이아웃의 구석에 현재의 위치를 이동합니다.  &nbsp;<p>
<code>LineBreakMeasurer</code> 는, 가장 일반적인 다음의 개행을 구현합니다. 랩핑폭에 들어가는 모든 단어는, 같은 행에 배치됩니다. 최초의 단어가 수습되지 않으면, 랩핑폭에 들어갈 뿐(만큼)의 문자가 그 행에 배치됩니다. 각 행에는 적어도 1 문자가 배치됩니다.  &nbsp;<p>
<code>LineBreakMeasurer</code> 에 의해 반환되는 <code>TextLayout</code> 의 인스턴스는, 탭을 폭 0 의 스페이스와 같게 취급합니다. 위치 결정을 위해서(때문에) 탭 단락의 세그먼트(segment)를 취득하는 클라이언트는, 텍스트에 대한 리밋트 오프셋(offset)를 취하는 <code>nextLayout</code> 의 overload를 사용하도록 해 주세요. 리밋트 오프셋(offset)는, 탭 이후의 최초의 문자입니다. 이 메소드가 돌려주는 <code>TextLayout</code> 객체는, 지정된 리밋트 (현재의 위치와 리밋트와의 사이의 텍스트가 랩핑폭에 들어가지 않는 경우에는, 리밋트의 전)로 끝납니다.  &nbsp;<p>
탭 단락의 텍스트를 레이아웃 하는 클라이언트에는, 최초의 세그먼트(segment)를 행에 배치한 뒤, 약간 다른 개행 정책가 필요합니다. 나머지의 영역에 일부의 단어를 거두는 것이 아니라, 전체를 다음의 행에 배치합니다. 정책의 이 변경은,<code>boolean</code> 파라미터를 취하는 <code>nextLayout</code> 의 overload로 요구할 수 있습니다. 이 파라미터가 <code>true</code> 의 경우,<code>nextLayout</code> 는, 최초의 단어가 지정된 영역에 들어가지 않을 때에 <code>null</code> 를 돌려줍니다. 아래와 같은 탭 샘플을 참조해 주세요.  &nbsp;<p>
일반적으로,<code>LineBreakMeasurer</code> 의 작성에 사용된 텍스트가 변경되었을 경우는, 변경을 반영하기 위해서 새로운 <code>LineBreakMeasurer</code> 를 작성할 필요가 있습니다 (지금까지의 <code>LineBreakMeasurer</code> 는 그대로 정상적으로 동작하지만, 텍스트의 변경에는 대응하지 않는다). 다만, 텍스트의 변경이 1 문자의 삽입 또는 삭제의 경우에는,<code>insertChar</code> 또는 <code>deleteChar</code> 를 호출해, 기존의 <code>LineBreakMeasurer</code> 를 「갱신」해도 괜찮습니다. 기존의 <code>LineBreakMeasurer</code> 를 갱신하는 (분)편이, 새롭게 작성하는 것보다도 처리 시간이 걸리지 않습니다. 사용자의 키 입력에 의해 텍스트를 변경하는 경우는, 이러한 방법을 이용하면(자) 좋을 것입니다.  &nbsp;<p>
<strong>례</strong>:<p>
컴퍼넌트에 단락을 draw 합니다.
 <blockquote>
 <pre>
 public void paint(Graphics graphics) {

     Point2D pen = new Point2D(10, 20);
     Graphics2D g2d = (Graphics2D) graphics;
     FontRenderContext frc = g2d.getFontRenderContext();

     // let styledText be an AttributedCharacterIterator containing at least
     // one character

     LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, frc);
     float wrappingWidth = getSize(). width - 15;

     while (measurer.getPosition() < fStyledText.length()) {

         TextLayout layout = measurer.nextLayout(wrappingWidth);

         pen.y += (layout.getAscent());
         float dx = layout.isLeftToRight() ?
             0 : (wrappingWidth - layout.getAdvance());

         layout.draw(graphics, pen.x + dx, pen.y);
         pen.y += layout.getDescent() + layout.getLeading();
     }
 }
 </pre>
 </blockquote>
 <p>
탭 첨부의 텍스트를 draw 합니다. 알기 쉽게하기 위해(때문에), 텍스트의 방향은 모두 왼쪽에서 오른쪽으로 합니다.
 <blockquote>
 <pre>
 public void paint(Graphics graphics) {

     float leftMargin = 10, rightMargin = 310;
     float[] tabStops = { 100, 250 };

     // assume styledText is an AttributedCharacterIterator, and the number
     // of tabs in styledText is tabCount

     int[] tabLocations = new int[tabCount+1];

     int i = 0;
     for (char c = styledText.first(); c ! = styledText.DONE; c = styledText.next()) {
         if (c == '\t') {
             tabLocations[i++] = styledText.getIndex();
         }
     }
     tabLocations[tabCount] = styledText.getEndIndex() - 1;

     // Now tabLocations has an entry for every tab's offset in
     // the text.   For convenience, the last entry is tabLocations
     // is the offset of the last character in the text.

     LineBreakMeasurer measurer = new LineBreakMeasurer(styledText);
     int currentTab = 0;
     float verticalPos = 20;

     while (measurer.getPosition() < styledText.getEndIndex()) {

         // Lay out and draw each line.   All segments on a line
         // must be computed before any drawing can occur, since
         // we must know the largest ascent on the line.
         // TextLayouts are computed and stored in a Vector;
         // their horizontal positions are stored in a parallel
         // Vector.

         // lineContainsText is true after first segment is drawn
         boolean lineContainsText = false;
         boolean lineComplete = false;
         float maxAscent = 0, maxDescent = 0;
         float horizontalPos = leftMargin;
         Vector layouts = new Vector(1);
         Vector penPositions = new Vector(1);

         while (! lineComplete) {
             float wrappingWidth = rightMargin - horizontalPos;
             TextLayout layout =
                     measurer.nextLayout(wrappingWidth,
                                         tabLocations[currentTab]+1,
                                         lineContainsText);

             // layout can be null if lineContainsText is true
             if (layout ! = null) {
                 layouts.addElement(layout);
                 penPositions.addElement(new Float(horizontalPos));
                 horizontalPos += layout.getAdvance();
                 maxAscent = Math.max(maxAscent, layout.getAscent());
                 maxDescent = Math.max(maxDescent,
                     layout.getDescent() + layout.getLeading());
             } else {
                 lineComplete = true;
             }

             lineContainsText = true;

             if (measurer.getPosition() == tabLocations[currentTab]+1) {
                 currentTab++;
             }

             if (measurer.getPosition() == styledText.getEndIndex())
                 lineComplete = true;
             else if (horizontalPos >= tabStops[tabStops.length-1])
                 lineComplete = true;

             if (! lineComplete) {
                 // move to next tab stop
                 int j;
                 for (j=0; horizontalPos >= tabStops[j]; j++) {}
                 horizontalPos = tabStops[j];
             }
         }

         verticalPos += maxAscent;

         Enumeration layoutEnum = layouts.elements();
         Enumeration positionEnum = penPositions.elements();

         // now iterate through layouts and draw them
         while (layoutEnum.hasMoreElements()) {
             TextLayout nextLayout = (TextLayout) layoutEnum.nextElement();
             Float nextPosition = (Float) positionEnum.nextElement();
             nextLayout.draw(graphics, nextPosition.floatValue(), verticalPos);
         }

         verticalPos += maxDescent;
     }
 }
 </pre>
 </blockquote>
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스"><CODE>TextLayout</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#LineBreakMeasurer(java.text.AttributedCharacterIterator, java.text.BreakIterator, java.awt.font.FontRenderContext)">LineBreakMeasurer</A> </B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;text,
                  <A HREF="../../../java/text/BreakIterator.html" title="java.text 안의 클래스">BreakIterator</A> &nbsp;breakIter,
                  <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 텍스트에 대한 <code>LineBreakMeasurer</code> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#LineBreakMeasurer(java.text.AttributedCharacterIterator, java.awt.font.FontRenderContext)">LineBreakMeasurer</A> </B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;text,
                  <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 텍스트에 대한 <code>LineBreakMeasurer</code> 를 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#deleteChar(java.text.AttributedCharacterIterator, int)">deleteChar</A> </B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;newParagraph,
           int&nbsp;deletePos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;텍스트로부터 문자가 1 개 삭제된 뒤에 <code>LineBreakMeasurer</code> 를 갱신해, 현재의 위치를 그 단락의 선두로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#getPosition()">getPosition</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>LineBreakMeasurer</code> 의 현재의 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#insertChar(java.text.AttributedCharacterIterator, int)">insertChar</A> </B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;newParagraph,
           int&nbsp;insertPos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;텍스트에 문자가 1 개 삽입된 뒤에 <code>LineBreakMeasurer</code> 를 갱신해, 현재의 위치를 그 단락의 선두로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스">TextLayout</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#nextLayout(float)">nextLayout</A> </B>(float&nbsp;wrappingWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다음의 레이아웃을 돌려주어, 현재의 위치를 갱신합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스">TextLayout</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#nextLayout(float, int, boolean)">nextLayout</A> </B>(float&nbsp;wrappingWidth,
           int&nbsp;offsetLimit,
           boolean&nbsp;requireNextWord)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다음의 레이아웃을 돌려주어, 현재의 위치를 갱신합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#nextOffset(float)">nextOffset</A> </B>(float&nbsp;wrappingWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다음의 레이아웃의 마지막 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#nextOffset(float, int, boolean)">nextOffset</A> </B>(float&nbsp;wrappingWidth,
           int&nbsp;offsetLimit,
           boolean&nbsp;requireNextWord)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다음의 레이아웃의 마지막 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#setPosition(int)">setPosition</A> </B>(int&nbsp;newPosition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>LineBreakMeasurer</code> 의 현재의 위치를 설정합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="LineBreakMeasurer(java.text.AttributedCharacterIterator, java.awt.font.FontRenderContext)"><!-- --></A> <H3>
LineBreakMeasurer</H3>
<PRE>
public <B>LineBreakMeasurer</B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;text,
                         <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</PRE>
<DL>
<DD>지정된 텍스트에 대한 <code>LineBreakMeasurer</code> 를 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>text</CODE> - 이 <code>LineBreakMeasurer</code> 가 
       <code>TextLayout</code> 객체의 생성 대상으로 하는 텍스트.  
       이 텍스트에는, 1 개(살) 이상의 문자가 포함되어 있지 않으면 안 된다.
       <code>iter</code> 로 얻을 수 있는 텍스트가 변경되었을 경우, 
       그 후의 이 <code>LineBreakMeasurer</code> 의 인스턴스에의 호출의 결과는 보증되지 않는다 
       (다만, 나중에 <code>insertChar</code> 또는  
       <code>deleteChar</code> 를 호출하는 경우를 제외하다. 관련 항목을 참조)<DD><CODE>frc</CODE> - 텍스트를 정확하게 측정하기 위해서 필요한
       그래픽스 디바이스에 관한 정보를 포함한다.
       텍스트 측정은, 디바이스의 해상도에 의해 조금 달라,
       에일리어징 제거등의 속성에 따라서 다르다.
       이 파라미터는,
       <code>LineBreakMeasurer</code> 와 사용자 공간의 사이의 이동은 지정하지 않는<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html#insertChar(java.text.AttributedCharacterIterator, int)"><CODE>insertChar(java.text.AttributedCharacterIterator, int)</CODE></A> , 
<A HREF="../../../java/awt/font/LineBreakMeasurer.html#deleteChar(java.text.AttributedCharacterIterator, int)"><CODE>deleteChar(java.text.AttributedCharacterIterator, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="LineBreakMeasurer(java.text.AttributedCharacterIterator, java.text.BreakIterator, java.awt.font.FontRenderContext)"><!-- --></A> <H3>
LineBreakMeasurer</H3>
<PRE>
public <B>LineBreakMeasurer</B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;text,
                         <A HREF="../../../java/text/BreakIterator.html" title="java.text 안의 클래스">BreakIterator</A> &nbsp;breakIter,
                         <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</PRE>
<DL>
<DD>지정된 텍스트에 대한 <code>LineBreakMeasurer</code> 를 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>text</CODE> - 이 <code>LineBreakMeasurer</code> 가 
     <code>TextLayout</code> 객체의 생성 대상으로 하는 텍스트.  
     이 텍스트에는, 1 개(살) 이상의 문자가 포함되어 있지 않으면 안 된다.
     <code>iter</code> 로 얻을 수 있는 텍스트가 변경되었을 경우, 
     그 후의 이 <code>LineBreakMeasurer</code> 의 인스턴스에의 호출의 결과는 보증되지 않는다 
     (다만, 나중에 <code>insertChar</code> 또는  
     <code>deleteChar</code> 를 호출하는 경우를 제외하다. 관련 항목을 참조)<DD><CODE>breakIter</CODE> - 개행을 정의한다 
     <A HREF="../../../java/text/BreakIterator.html" title="java.text 안의 클래스"><CODE>BreakIterator</CODE></A> <DD><CODE>frc</CODE> - 텍스트를 정확하게 측정하기 위해서 필요한
       그래픽스 디바이스에 관한 정보를 포함한다.
       텍스트 측정은, 디바이스의 해상도에 의해 조금 달라,
       에일리어징 제거등의 속성에 따라서 다르다.
       이 파라미터는,
       <code>LineBreakMeasurer</code> 와 사용자 공간의 사이의 이동은 지정하지 않는다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 텍스트가 1 문자에 못 미친 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html#insertChar(java.text.AttributedCharacterIterator, int)"><CODE>insertChar(java.text.AttributedCharacterIterator, int)</CODE></A> , 
<A HREF="../../../java/awt/font/LineBreakMeasurer.html#deleteChar(java.text.AttributedCharacterIterator, int)"><CODE>deleteChar(java.text.AttributedCharacterIterator, int)</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="nextOffset(float)"><!-- --></A> <H3>
nextOffset</H3>
<PRE>
public int <B>nextOffset</B>(float&nbsp;wrappingWidth)</PRE>
<DL>
<DD>다음의 레이아웃의 마지막 위치를 돌려줍니다. <code>LineBreakMeasurer</code> 의 현재의 위치를 갱신하지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>wrappingWidth</CODE> - 다음의 레이아웃내의 텍스트에
    허용 되는 최대의 가시 유효폭
<DT><B>반환값:</B><DD>다음의 <code>TextLayout</code> 의
    리밋트를 나타내는 텍스트내의 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="nextOffset(float, int, boolean)"><!-- --></A> <H3>
nextOffset</H3>
<PRE>
public int <B>nextOffset</B>(float&nbsp;wrappingWidth,
                      int&nbsp;offsetLimit,
                      boolean&nbsp;requireNextWord)</PRE>
<DL>
<DD>다음의 레이아웃의 마지막 위치를 돌려줍니다. <code>LineBreakMeasurer</code> 의 현재의 위치를 갱신하지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>wrappingWidth</CODE> - 다음의 레이아웃내의 텍스트에
    허용 되는 최대의 가시 유효폭<DD><CODE>offsetLimit</CODE> - 리밋트 이후의 텍스트가 랩핑폭에 들어가는 경우에서도,
    다음의 레이아웃에 포함되지 않는 최초의 문자.
    <code>offsetLimit</code> 는,
    현재의 위치보다 크지 않으면 안 되는<DD><CODE>requireNextWord</CODE> - <code>true</code> 의 경우,
    다음의 단어 전체가 <code>wrappingWidth</code> 에 들어가지 않을 때는 현재의 위치가 반환된다.
    <code>false</code> 의 경우,
    반환되는 좌표는 현재의 위치보다 적어도 1 크다
<DT><B>반환값:</B><DD>다음의 <code>TextLayout</code> 의
    리밋트를 나타내는 텍스트내의 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="nextLayout(float)"><!-- --></A> <H3>
nextLayout</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스">TextLayout</A>  <B>nextLayout</B>(float&nbsp;wrappingWidth)</PRE>
<DL>
<DD>다음의 레이아웃을 돌려주어, 현재의 위치를 갱신합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>wrappingWidth</CODE> - 다음의 레이아웃내의 텍스트에
     허용 되는 최대의 가시 유효폭
<DT><B>반환값:</B><DD><code>wrappingWidth</code> 에 들어가는 다음의 행을 나타내,
     현재의 위치로부터 시작된다 
     <code>TextLayout</code></DL>
</DD>
</DL>
<HR>

<A NAME="nextLayout(float, int, boolean)"><!-- --></A> <H3>
nextLayout</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스">TextLayout</A>  <B>nextLayout</B>(float&nbsp;wrappingWidth,
                             int&nbsp;offsetLimit,
                             boolean&nbsp;requireNextWord)</PRE>
<DL>
<DD>다음의 레이아웃을 돌려주어, 현재의 위치를 갱신합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>wrappingWidth</CODE> - 다음의 레이아웃내의 텍스트에
    허용 되는 최대의 가시 유효폭<DD><CODE>offsetLimit</CODE> - 리밋트 이후의 텍스트가 랩핑폭에 들어가는 경우에서도,
    다음의 레이아웃에 포함되지 않는 최초의 문자.
    <code>offsetLimit</code> 는, 
    현재의 위치보다 크지 않으면 안 되는<DD><CODE>requireNextWord</CODE> - <code>true</code> 의 경우,
    현재의 위치에 있는 단어 전체가 랩핑폭에 들어가지 않을 때는 
    <code>null</code> 가 반환된다. <code>false</code> 의 경우,
    적어도 현재의 위치에 있는 문자를 포함한,
    유효한 레이아웃이 반환된다
<DT><B>반환값:</B><DD><code>wrappingWidth</code> 에 들어가는 다음의 행을 나타내,
    현재의 위치로부터 시작된다 
    <code>TextLayout</code>. 현재의 위치가,
    <code>LineBreakMeasurer</code> 의 사용하는 텍스트의 끝에 있는 경우,
    <code>null</code> 가 반환된다. </DL>
</DD>
</DL>
<HR>

<A NAME="getPosition()"><!-- --></A> <H3>
getPosition</H3>
<PRE>
public int <B>getPosition</B>()</PRE>
<DL>
<DD><code>LineBreakMeasurer</code> 의 현재의 위치를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD><code>LineBreakMeasurer</code> 의 현재의 위치<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html#setPosition(int)"><CODE>setPosition(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPosition(int)"><!-- --></A> <H3>
setPosition</H3>
<PRE>
public void <B>setPosition</B>(int&nbsp;newPosition)</PRE>
<DL>
<DD><code>LineBreakMeasurer</code> 의 현재의 위치를 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newPosition</CODE> - <code>LineBreakMeasurer</code> 의 현재의 위치.
    이 정도치는,
    <code>LineBreakMeasurer</code> 를 작성하기 위해서 사용되는 텍스트 
    (또는 <code>insertChar</code> 인가 
    <code>deleteChar</code> 에 마지막에 건네받은 텍스트) 안에 있는<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html#getPosition()"><CODE>getPosition()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="insertChar(java.text.AttributedCharacterIterator, int)"><!-- --></A> <H3>
insertChar</H3>
<PRE>
public void <B>insertChar</B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;newParagraph,
                       int&nbsp;insertPos)</PRE>
<DL>
<DD>텍스트에 문자가 1 개 삽입된 뒤에 <code>LineBreakMeasurer</code> 를 갱신해, 현재의 위치를 그 단락의 선두로 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newParagraph</CODE> - 삽입 후의 텍스트<DD><CODE>insertPos</CODE> - 텍스트내의,
    문자가 삽입된 위치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - <code>insertPos</code> 가 
         <code>newParagraph</code> 의 개시 위치보다 전,
         또는 <code>newParagraph</code> 의 종료 위치와 같은가, 그 이후인 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>newParagraph</code> 가    
         <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html#deleteChar(java.text.AttributedCharacterIterator, int)"><CODE>deleteChar(java.text.AttributedCharacterIterator, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="deleteChar(java.text.AttributedCharacterIterator, int)"><!-- --></A> <H3>
deleteChar</H3>
<PRE>
public void <B>deleteChar</B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;newParagraph,
                       int&nbsp;deletePos)</PRE>
<DL>
<DD>텍스트로부터 문자가 1 개 삭제된 뒤에 <code>LineBreakMeasurer</code> 를 갱신해, 현재의 위치를 그 단락의 선두로 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newParagraph</CODE> - 삭제 후의 텍스트<DD><CODE>deletePos</CODE> - 텍스트내의,
    문자가 삭제된 위치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - <code>deletePos</code> 가 
         <code>newParagraph</code> 의 개시 위치보다 전,
         또는 <code>newParagraph</code> 의 종료 위치에서(보다) 뒤인 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>newParagraph</code> 가 
         <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html#insertChar(java.text.AttributedCharacterIterator, int)"><CODE>insertChar(java.text.AttributedCharacterIterator, int)</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LineBreakMeasurer.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/awt/font/LayoutPath.html" title="java.awt.font 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/awt/font/LineMetrics.html" title="java.awt.font 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/awt/font/LineBreakMeasurer.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="LineBreakMeasurer.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
