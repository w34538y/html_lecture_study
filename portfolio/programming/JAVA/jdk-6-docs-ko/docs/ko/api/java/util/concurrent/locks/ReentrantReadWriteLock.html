<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:01:05 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
ReentrantReadWriteLock (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ReentrantReadWriteLock (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ReentrantReadWriteLock.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/locks/ReentrantReadWriteLock.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ReentrantReadWriteLock.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent.locks</FONT>
<BR>
클래스 ReentrantReadWriteLock</H2>
<PRE>
<A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.concurrent.locks.ReentrantReadWriteLock</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> , <A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 안의 인터페이스">ReadWriteLock</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>ReentrantReadWriteLock</B><DT>extends <A HREF="../../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 내의 인터페이스">ReadWriteLock</A> , <A HREF="../../../../java/io/Serializable.html" title="java.io 안의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 안의 클래스"><CODE>ReentrantLock</CODE></A>  와 같은 시멘틱스를 지원하는 <A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 동안의 인터페이스"><CODE>ReadWriteLock</CODE></A>  의 구현입니다. <p>이 클래스에는 다음의 특성이 있습니다.

 <ul>
<li><b>취득 순서</b>

 <p> 이 클래스는, 락 액세스에 대한 리더 또는 라이터의 우선 순서를 규정하지 않습니다. 다만, 이것은 옵션의 「공평성」정책를 지원합니다.

 <dl>
<dt><b><i>불공평 모드 (디폴트)</i></b>
<dd>불공평으로서 구축되었을 경우는 (디폴트), read 및 기입해 락에 들어가는 순서는 지정되지 않고, 재입가능성 제약에 따릅니다. 계속적으로 경합 하는 불공평 락에서는, 1 개(살) 이상의 리더 또는 라이터 thread를 무기한으로 연기하는 일이 있습니다만, 일반적으로은 공평 락보다 throughput가 높아집니다.  &nbsp;<p>

<dt><b><i>공평 모드</i></b>
<dd> 공평으로서 구축되었을 경우, thread는 근사의 도착순서 정책를 사용해 엔트리로 경합 합니다. 현재 보관 유지되고 있는 락이 해제되면(자), 대기 시간의 가장 긴 단일의 라이터 thread에 기입해 락을 할당할 수 있는지, 대기중의 어느 라이터 thread보다 길게 대기하고 있는 리더 thread의 그룹이 존재하는 경우는, 그 그룹에 읽어들여 락을 할당할 수 있습니다.

 <p>기입 락이 보관 유지되고 있는 경우나 대기중의 라이터 thread가 존재하는 경우, 공평 read 락 (재입불가능)을 취득하려고 하는 thread는 블록 됩니다. 그러한 thread는, 현재 대기중의 라이터 thread 가운데 좀 더도 낡은 thread가 기입해 락을 취득해 해제할 때까지, read 락을 취득하지 않습니다. 물론, 대기중의 라이터가 대기를 중지해, 큐내에서 가장 길게 대기하고 있는 1 개(살) 이상의 리더 thread에 기입해 락이 걸리지 않은 경우는, 그러한 리더에게 읽어들여 락을 할당할 수 있습니다.

 <p>read 락도 기입해 락도 걸리지 않은 (즉 대기중의 thread가 없다) 경우를 제외해, 공평 기입 락 (재입불가능)을 취득하려고 하는 thread는 블록 됩니다. 다만, 비블록의 <A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html#tryLock()"><CODE>ReentrantReadWriteLock.ReadLock.tryLock()</CODE></A>  및 <A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#tryLock()"><CODE>ReentrantReadWriteLock.WriteLock.tryLock()</CODE></A>  메소드는, 이 공평 설정에 따르지 않고, 대기중의 thread에 관계없이, 가능하면 락을 가져옵니다.  &nbsp;<p>
 </dl>

<li><b>재입가능성</b>

 <p>이 락은, 리더와 라이터의 양쪽 모두가,<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 안의 클래스"><CODE>ReentrantLock</CODE></A>  의 스타일로 읽어들여 또는 기입해 락을 재취득하는 것을 허가합니다. 기입하는 thread의 보관 유지하는 기입 락이 모두 해제될 때까지, 재입 불가능한 리더는 허가되지 않습니다.

 <p>또, 라이터는 읽어들여 락을 취득할 수 있습니다만, 리더가 기입해 락을 취득할 수 없습니다. 다른 어플리케이션의 사이에서는, read 락하에서 read를 실행하는 메소드에의 호출해 또는 콜백중에 기입해 락이 보관 유지되는 경우, 재입가능성은 유용합니다. 리더가 기입해 락을 취득하려고 해도, 성공하지 않습니다.

<li><b>락의 격하</b> &nbsp;<p>재입가능성을 이용하면(자), 기입 락을 취득하고 나서 read 락을 취득해, 그 후 기입해 락을 해제한다고 하는 방법으로, 기입 락으로부터 읽어들여 락에의 격하가 가능하게 됩니다. 다만, read 락으로부터 기입해 락에의 승격은 할 수 없습니다.

<li><b>락 취득의 인터럽트</b> &nbsp;<p>read 락과 기입해 락의 양쪽 모두가, 락 취득중의 인터럽트를 지원합니다.

<li><b><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A>  의 지원</b> &nbsp;<p>기입 락의 제공하는 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 동안의 인터페이스"><CODE>Condition</CODE></A>  구현은, 기입 락에 관계되어,<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#newCondition()"><CODE>ReentrantLock.newCondition()</CODE></A>  의 제공하는 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 동안의 인터페이스"><CODE>Condition</CODE></A>  구현이 <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 안의 클래스"><CODE>ReentrantLock</CODE></A>  에 대해서 실행하는 것과 같이 동작합니다. 당연합니다만, 이 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A>  는 기입해 락에서만 사용할 수 있습니다.

 <p>read 락은 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A>  를 지원하지 않고,<code>readLock(). newCondition()</code> 가 <code>UnsupportedOperationException</code> 를 throw 합니다.

<li><b>Instrumentation</b> &nbsp;<p>이 클래스는, 락이 보관 유지되는지 경합 하는지를 판별하는 메소드를 지원합니다. 이러한 메소드는, 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
 </ul>

 <p>이 클래스의 직렬화는, 편입 락과 같게 동작합니다. 직렬화 해제된 락은, 직렬화시 상태에 관계없이, 락 해제 상태가 됩니다.

 <p><b>사용례：</b>차의 코드예에서는, 재입가능성을 활용해, 캐쉬의 갱신 후에 락의 격하를 실행하는 방법을 나타냅니다 (간략화하기 위해서 예외 처리는 생략 되고 있다).
 <pre>
 class CachedData {
   Object data;
   volatile boolean cacheValid;
   ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

   void processCachedData() {
     rwl.readLock(). lock();
     if (! cacheValid) {
        // Must release read lock before acquiring write lock
        rwl.readLock(). unlock();
        rwl.writeLock(). lock();
        // Recheck state because another thread might have acquired
        //   write lock and changed state before we did.
        if (! cacheValid) {
          data = ...
          cacheValid = true;
        }
        // Downgrade by acquiring read lock before releasing write lock
        rwl.readLock(). lock();
        rwl.writeLock(). unlock(); // Unlock write, still hold read
     }

     use(data);
     rwl.readLock(). unlock();
   }
 }
 </pre>

ReentrantReadWriteLocks 를 사용해, 어떤 종류의 Collections 의 사용으로 병행성을 개선할 수 있습니다. 일반적으로, 이것이 가치가 있는 것은, 컬렉션이 대규모로 되는 것이 예상되어 라이터 thread보다 다수의 리더 thread에 의해 액세스 되어 동기에 의한 오버헤드를 웃도는 오버헤드를 가지는 조작이 포함되는 경우입니다. 예로서 대규모여, 병행 액세스가 예상되는 TreeMap 를 사용하는 클래스를 다음에 나타냅니다.

 <pre><code>class RWDictionary {
    private final Map&lt;String, Data&gt; m = new TreeMap&lt;String, Data&gt;();
    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    private final Lock r = rwl.readLock();
    private final Lock w = rwl.writeLock();

    public Data get(String key) {
        r.lock();
        try { return m.get(key); }
        finally { r.unlock(); }
    }
    public String[] allKeys() {
        r.lock();
        try { return m.keySet(). toArray(); }
        finally { r.unlock(); }
    }
    public Data put(String key, Data value) {
        w.lock();
        try { return m.put(key, value); }
        finally { w.unlock(); }
    }
    public void clear() {
        w.lock();
        try { m.clear(); }
        finally { w.unlock(); }
    }
 }</code></pre>

<h3>구현상의 주의:</h3>

 <p>이 락은, 최대 65535 의 재귀적 기입 락 및 65535 의 read 락을 지원합니다. 이러한 제한을 넘으려고 하면(자), 잠그는 메소드로부터 <A HREF="../../../../java/lang/Error.html" title="java.lang 안의 클래스"><CODE>Error</CODE></A>  가 throw 됩니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../../serialized-form.html#java.util.concurrent.locks.ReentrantReadWriteLock">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 안의 클래스">ReentrantReadWriteLock.ReadLock</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#readLock()"><CODE>readLock()</CODE></A>  메소드에 의해 반환되는 락입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" title="java.util.concurrent.locks 안의 클래스">ReentrantReadWriteLock.WriteLock</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#writeLock()"><CODE>writeLock()</CODE></A>  메소드에 의해 반환되는 락입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#ReentrantReadWriteLock()">ReentrantReadWriteLock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트 (불공평)의 순서 프로퍼티으로, 신규 <code>ReentrantReadWriteLock</code> 를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#ReentrantReadWriteLock(boolean)">ReentrantReadWriteLock</A> </B>(boolean&nbsp;fair)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 공평성 정책를 사용해, 신규 <code>ReentrantReadWriteLock</code> 를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getOwner()">getOwner</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 기입 락을 소유하고 있는 thread를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueuedReaderThreads()">getQueuedReaderThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read 락의 취득을 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueuedThreads()">getQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read 락 또는 기입해 락의 몇개의 취득을 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueuedWriterThreads()">getQueuedWriterThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기입 락의 취득을 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueueLength()">getQueueLength</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read 락 또는 기입해 락의 취득을 대기중의 thread의 추정수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getReadHoldCount()">getReadHoldCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread에 의한, 이 락상의 재입 가능한 read 보관 유지수를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getReadLockCount()">getReadLockCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락용으로 보관 유지되고 있는 read 락의 수를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getWaitingThreads(java.util.concurrent.locks.Condition)">getWaitingThreads</A> </B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기입 락에 관련지을 수 있었던 지정 상태를 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getWaitQueueLength(java.util.concurrent.locks.Condition)">getWaitQueueLength</A> </B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기입 락에 관련지을 수 있었던 지정 상태로 대기중의 thread의 추정수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getWriteHoldCount()">getWriteHoldCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread에 의한, 이 락상의 재입 가능한 기입 보관 유지수를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#hasQueuedThread(java.lang.Thread)">hasQueuedThread</A> </B>(<A HREF="../../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;thread)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read 락 또는 기입해 락의 취득을 대기중의 지정의 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#hasQueuedThreads()">hasQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read 락 또는 기입해 락의 취득을 대기중의 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#hasWaiters(java.util.concurrent.locks.Condition)">hasWaiters</A> </B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 기입 락에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#isFair()">isFair</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락으로 공평성이 true 로 설정되어 있는 경우는 <code>true</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#isWriteLocked()">isWriteLocked</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기입 락이 thread에 보관 유지되고 있는지 어떤지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#isWriteLockedByCurrentThread()">isWriteLockedByCurrentThread</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread가 이 기입 락을 보관 유지하고 있는 제발을 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 내의 클래스">ReentrantReadWriteLock.ReadLock</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#readLock()">readLock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;읽어들여에 사용하는 락을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락 및 그 상태를 식별하는 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" title="java.util.concurrent.locks 내의 클래스">ReentrantReadWriteLock.WriteLock</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#writeLock()">writeLock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기입해에 사용하는 락을 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ReentrantReadWriteLock()"><!-- --></A> <H3>
ReentrantReadWriteLock</H3>
<PRE>
public <B>ReentrantReadWriteLock</B>()</PRE>
<DL>
<DD>디폴트 (불공평)의 순서 프로퍼티으로, 신규 <code>ReentrantReadWriteLock</code> 를 작성합니다.
<P>
</DL>
<HR>

<A NAME="ReentrantReadWriteLock(boolean)"><!-- --></A> <H3>
ReentrantReadWriteLock</H3>
<PRE>
public <B>ReentrantReadWriteLock</B>(boolean&nbsp;fair)</PRE>
<DL>
<DD>지정된 공평성 정책를 사용해, 신규 <code>ReentrantReadWriteLock</code> 를 작성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>fair</CODE> - 이 락이 공평 순서부 정책를 사용하는 경우는 <code>true</code></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="writeLock()"><!-- --></A> <H3>
writeLock</H3>
<PRE>
public <A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" title="java.util.concurrent.locks 내의 클래스">ReentrantReadWriteLock.WriteLock</A>  <B>writeLock</B>()</PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html#writeLock()">ReadWriteLock</A> </CODE> 의 기술:</B></DD>
<DD>기입해에 사용하는 락을 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 내의 인터페이스">ReadWriteLock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html#writeLock()">writeLock</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>기입해에 사용하는 락</DL>
</DD>
</DL>
<HR>

<A NAME="readLock()"><!-- --></A> <H3>
readLock</H3>
<PRE>
public <A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 내의 클래스">ReentrantReadWriteLock.ReadLock</A>  <B>readLock</B>()</PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html#readLock()">ReadWriteLock</A> </CODE> 의 기술:</B></DD>
<DD>읽어들여에 사용하는 락을 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 내의 인터페이스">ReadWriteLock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html#readLock()">readLock</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽어들여에 사용하는 락</DL>
</DD>
</DL>
<HR>

<A NAME="isFair()"><!-- --></A> <H3>
isFair</H3>
<PRE>
public final boolean <B>isFair</B>()</PRE>
<DL>
<DD>이 락으로 공평성이 true 로 설정되어 있는 경우는 <code>true</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 락으로 공평성이 true 로 설정되어 있는 경우는 <code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="getOwner()"><!-- --></A> <H3>
getOwner</H3>
<PRE>
protected <A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A>  <B>getOwner</B>()</PRE>
<DL>
<DD>현재 기입 락을 소유하고 있는 thread를 돌려줍니다. 락이 소유되어 있지 않은 경우는 <code>null</code> 를 돌려줍니다. 이 메소드가 소유자가 아닌 thread에 의해 불려 가는 경우, 반환값에는 현재의 락 상태의 최대한의 근사치가 반영됩니다. 예를 들어, 락의 취득을 시도하고 있어 아직 취득하고 있지 않는 thread가 존재하는 경우도, 소유자는 일시적으로 <code>null</code> 가 되는 경우가 있습니다. 이 메소드는, 보다 포괄적인 락 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>소유자. 소유되어 있지 않은 경우는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getReadLockCount()"><!-- --></A> <H3>
getReadLockCount</H3>
<PRE>
public int <B>getReadLockCount</B>()</PRE>
<DL>
<DD>이 락용으로 보관 유지되고 있는 read 락의 수를 조회합니다. 이 메소드는, 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>보관 유지하는 read 락의 수</DL>
</DD>
</DL>
<HR>

<A NAME="isWriteLocked()"><!-- --></A> <H3>
isWriteLocked</H3>
<PRE>
public boolean <B>isWriteLocked</B>()</PRE>
<DL>
<DD>기입 락이 thread에 보관 유지되고 있는지 어떤지를 조회합니다. 이 메소드는, 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>임의의 thread가 기입해 락을 보관 유지하는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="isWriteLockedByCurrentThread()"><!-- --></A> <H3>
isWriteLockedByCurrentThread</H3>
<PRE>
public boolean <B>isWriteLockedByCurrentThread</B>()</PRE>
<DL>
<DD>현재의 thread가 이 기입 락을 보관 유지하고 있는 제발을 조회합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 thread가 기입해 락을 보관 유지하는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="getWriteHoldCount()"><!-- --></A> <H3>
getWriteHoldCount</H3>
<PRE>
public int <B>getWriteHoldCount</B>()</PRE>
<DL>
<DD>현재의 thread에 의한, 이 락상의 재입 가능한 기입 보관 유지수를 조회합니다. 라이터 thread는, 락 해제 액션과 일치하지 않는 각 락 액션용의 락을 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 thread의, 기입 락에 대한 보관 유지수. 현재의 thread가 이 락을 보관 유지하고 있지 않는 경우는 제로</DL>
</DD>
</DL>
<HR>

<A NAME="getReadHoldCount()"><!-- --></A> <H3>
getReadHoldCount</H3>
<PRE>
public int <B>getReadHoldCount</B>()</PRE>
<DL>
<DD>현재의 thread에 의한, 이 락상의 재입 가능한 read 보관 유지수를 조회합니다. read thread에는, 락 해제 액션과 일치하지 않는 락 액션 마다, 락 보관 유지가 존재합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 thread의, read 락에 대한 보관 유지수. 현재의 thread가 이 락을 보관 유지하고 있지 않는 경우는 제로<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getQueuedWriterThreads()"><!-- --></A> <H3>
getQueuedWriterThreads</H3>
<PRE>
protected <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getQueuedWriterThreads</B>()</PRE>
<DL>
<DD>기입 락의 취득을 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는, 결과의 구축중에도 동적으로 변화할 가능성이 있기 (위해)때문에, 반환되는 컬렉션은 최선이 노력한 다음의 추정에 지나지 않습니다. 반환되는 컬렉션의 요소에는, 특정의 순서는 존재하지 않습니다. 이 메소드는, 보다 포괄적인 락 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="getQueuedReaderThreads()"><!-- --></A> <H3>
getQueuedReaderThreads</H3>
<PRE>
protected <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getQueuedReaderThreads</B>()</PRE>
<DL>
<DD>read 락의 취득을 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는, 결과의 구축중에도 동적으로 변화할 가능성이 있기 (위해)때문에, 반환되는 컬렉션은 최선이 노력한 다음의 추정에 지나지 않습니다. 반환되는 컬렉션의 요소에는, 특정의 순서는 존재하지 않습니다. 이 메소드는, 보다 포괄적인 락 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="hasQueuedThreads()"><!-- --></A> <H3>
hasQueuedThreads</H3>
<PRE>
public final boolean <B>hasQueuedThreads</B>()</PRE>
<DL>
<DD>read 락 또는 기입해 락의 취득을 대기중의 thread가 존재할지 어떨지를 조회합니다. 취소는 언제라도 발생할 가능성이 있기 (위해)때문에,<code>true</code> 가 돌려주어져도, 다른 몇개의 thread가 락을 취득하는 것은 보증되고 있지 않습니다. 이 메소드는, 주로 시스템 상태의 감시에 사용하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>락의 취득을 대기중외의 thread가 존재할 가능성이 있는 경우는 <code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="hasQueuedThread(java.lang.Thread)"><!-- --></A> <H3>
hasQueuedThread</H3>
<PRE>
public final boolean <B>hasQueuedThread</B>(<A HREF="../../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;thread)</PRE>
<DL>
<DD>read 락 또는 기입해 락의 취득을 대기중의 지정의 thread가 존재할지 어떨지를 조회합니다. 취소는 언제라도 발생할 가능성이 있기 (위해)때문에,<code>true</code> 가 돌려주어져도, 이 thread가 락을 취득하는 것은 보증되고 있지 않습니다. 이 메소드는, 주로 시스템 상태의 감시에 사용하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>thread</CODE> - thread
<DT><B>반환값:</B><DD>지정된 thread가 큐에 넣어지고 있어 이 락을 대기중인 경우는 <code>true</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - thread가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getQueueLength()"><!-- --></A> <H3>
getQueueLength</H3>
<PRE>
public final int <B>getQueueLength</B>()</PRE>
<DL>
<DD>read 락 또는 기입해 락의 취득을 대기중의 thread의 추정수를 돌려줍니다. 이 메소드가 내부의 데이터 구조를 횡단(traverse) 하고 있는 동안에도, thread수가 동적으로 변화하는 경우가 있기 (위해)때문에, 이 값은 추정에 지나지 않습니다. 이 메소드는, 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 락을 대기하고 있는 thread의 추정수</DL>
</DD>
</DL>
<HR>

<A NAME="getQueuedThreads()"><!-- --></A> <H3>
getQueuedThreads</H3>
<PRE>
protected <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getQueuedThreads</B>()</PRE>
<DL>
<DD>read 락 또는 기입해 락의 몇개의 취득을 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는, 결과의 구축중에도 동적으로 변화할 가능성이 있기 (위해)때문에, 반환되는 컬렉션은 최선이 노력한 다음의 추정에 지나지 않습니다. 반환되는 컬렉션의 요소에는, 특정의 순서는 존재하지 않습니다. 이 메소드는, 보다 포괄적인 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="hasWaiters(java.util.concurrent.locks.Condition)"><!-- --></A> <H3>
hasWaiters</H3>
<PRE>
public boolean <B>hasWaiters</B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</PRE>
<DL>
<DD>이 기입 락에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread가 존재할지 어떨지를 조회합니다. 타임 아웃 및 인터럽트는 언제라도 발생할 가능성이 있기 (위해)때문에,<code>true</code> 가 돌려주어져도, 장래 <code>signal</code> 가 thread를 기동시키는 것은 보증되고 있지 않습니다. 이 메소드는, 주로 시스템 상태의 감시에 사용하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>대기중의 thread가 존재하는 경우는 <code>true</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 이 락을 보관 유지하고 있지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 락과 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitQueueLength(java.util.concurrent.locks.Condition)"><!-- --></A> <H3>
getWaitQueueLength</H3>
<PRE>
public int <B>getWaitQueueLength</B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</PRE>
<DL>
<DD>기입 락에 관련지을 수 있었던 지정 상태로 대기중의 thread의 추정수를 돌려줍니다. 타임 아웃 및 인터럽트의 발생할 가능성은 언제라도 존재하기 위해(때문에), 추정수는, 실제의 대기자수에 관한 상한을 나타내는에 지나지 않습니다. 이 메소드는, 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>대기중의 thread의 추정수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 이 락을 보관 유지하고 있지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 락과 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitingThreads(java.util.concurrent.locks.Condition)"><!-- --></A> <H3>
getWaitingThreads</H3>
<PRE>
protected <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getWaitingThreads</B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</PRE>
<DL>
<DD>기입 락에 관련지을 수 있었던 지정 상태를 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는, 결과의 구축중에도 동적으로 변화할 가능성이 있기 (위해)때문에, 반환되는 컬렉션은 최선이 노력한 다음의 추정에 지나지 않습니다. 반환되는 컬렉션의 요소에는, 특정의 순서는 존재하지 않습니다. 이 메소드는, 보다 포괄적인 상태 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>thread의 컬렉션
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 이 락을 보관 유지하고 있지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 락과 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 락 및 그 상태를 식별하는 캐릭터 라인을 돌려줍니다. 상태는 괄호로 둘러싸여 재입가능성을 보관 유지하는 기입 락의 수에 계속되는 캐릭터 라인 <code>"Write locks ="</code>, 및 보관 유지되는 read 락의 수에 계속되는 캐릭터 라인 <code>"Read locks ="</code> 가 포함됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 락 및 그 상태를 식별하는 캐릭터 라인</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ReentrantReadWriteLock.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/locks/ReentrantReadWriteLock.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ReentrantReadWriteLock.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
