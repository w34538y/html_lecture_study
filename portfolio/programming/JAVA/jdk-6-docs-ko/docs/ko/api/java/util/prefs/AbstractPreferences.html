<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:01:11 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
AbstractPreferences (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="AbstractPreferences (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractPreferences.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;전의 클래스 &nbsp;
&nbsp;<A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/prefs/AbstractPreferences.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="AbstractPreferences.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.prefs</FONT>
<BR>
클래스 AbstractPreferences</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">java.util.prefs.Preferences</A> 
      <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.prefs.AbstractPreferences</B>
</PRE>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>AbstractPreferences</B><DT>extends <A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </DL>
</PRE>

<P>
이 클래스는,<A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 안의 클래스"><CODE>Preferences</CODE></A>  클래스의 스켈리턴 구현을 제공합니다.  이 클래스를 사용하면, 간단하게 구현할 수가 있습니다.

 <p><strong>이 클래스는,<tt>Preferences</tt> 를 구현할 경우에만 사용합니다. <tt>Preferences</tt> 의 기능을 사용할 뿐(만큼)의 사용자는, 이 문서를 참조할 필요는 없습니다. <A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 안의 클래스"><CODE>Preferences</CODE></A>  의 문서를 참조해 주세요. </strong>

 <p>Preferences 를 구현할 때는,<A HREF="../../../java/util/prefs/AbstractPreferences.html#getSpi(java.lang.String)"><CODE>getSpi(String)</CODE></A> ,<A HREF="../../../java/util/prefs/AbstractPreferences.html#putSpi(java.lang.String, java.lang.String)"><CODE>putSpi(String, String)</CODE></A> ,<A HREF="../../../java/util/prefs/AbstractPreferences.html#removeSpi(java.lang.String)"><CODE>removeSpi(String)</CODE></A> ,<A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(String)</CODE></A> ,<A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNodeSpi()"><CODE>removeNodeSpi()</CODE></A> ,<A HREF="../../../java/util/prefs/AbstractPreferences.html#keysSpi()"><CODE>keysSpi()</CODE></A> ,<A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNamesSpi()"><CODE>childrenNamesSpi()</CODE></A> ,<A HREF="../../../java/util/prefs/AbstractPreferences.html#syncSpi()"><CODE>syncSpi()</CODE></A> , 및 <A HREF="../../../java/util/prefs/AbstractPreferences.html#flushSpi()"><CODE>flushSpi()</CODE></A>  의 9 개의 abstract 서비스 프로바이더 인터페이스 (SPI) 메소드를 오버라이드(override) 할 필요가 있습니다. 오버라이드(override) 하는 구상 메소드에는, 이러한 SPI 메소드상에 구현하는 방법을 정확하게 지정할 필요가 있습니다. 퍼포먼스등의 이유로써 디폴트의 구현으로 변경을 더하고 싶은 경우는, 임의의 구상 메소드를 오버라이드(override) 합니다.

 <p>SPI 메소드는, 예외 처리에 대해 3 개의 그룹으로 분류됩니다. <tt>getSpi</tt> 메소드는, 예외를 throw 하지 않습니다.  이것은 문제는 아니고, 이 메소드가 throw 하는 예외는 모두 <A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE>get(String, String)</CODE></A>  에 의해 포획 되어 지정된 디폴트 값가 호출해 측에 돌려주어집니다. <tt>removeNodeSpi</tt>,<tt>keysSpi</tt>,<tt>childrenNamesSpi</tt>,<tt>syncSpi</tt>, 및 <tt>flushSpi</tt> 메소드는,<A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스"><CODE>BackingStoreException</CODE></A>  를 throw 하도록(듯이) 지정되고 있습니다. <tt> Preferences</tt> 의 구현은, 조작을 실행할 수 없는 경우에 이 체크가 끝난 예외를 throw 할 필요가 있습니다. throw 된 예외는 외부에 보내져 대응하는 API 메소드가 실패합니다.

 <p>나머지의 SPI 메소드 (<A HREF="../../../java/util/prefs/AbstractPreferences.html#putSpi(java.lang.String, java.lang.String)"><CODE>putSpi(String, String)</CODE></A> ,<A HREF="../../../java/util/prefs/AbstractPreferences.html#removeSpi(java.lang.String)"><CODE>removeSpi(String)</CODE></A> , 및 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(String)</CODE></A> )는, 보다 복잡한 예외 처리를 실시합니다. 이러한 메소드는 일반적으로, 배킹 스토어를 이용할 수 없는 경우에서도 그 규약에 따라 동작할 수 있기 (위해)때문에,<tt>BackingStoreException</tt> 를 throw 하도록(듯이) 지정되고 있지 않습니다. 이러한 메소드는,<A HREF="../../../java/util/prefs/Preferences.html#flush()"><CODE>Preferences.flush()</CODE></A>  또는 <A HREF="../../../java/util/prefs/Preferences.html#sync()"><CODE>Preferences.sync()</CODE></A>  가 다음에 불려 갔을 때에, 정보를 돌려주어, 효과가 적용되기 (위해)때문에입니다. 일반적으로, 이러한 SPI 메소드는 예외를 throw 하지 않습니다. 일부의 구현에서는, 이러한 호출이 요구한 조작을, 나중에 처리하기 위해서 큐에 넣을 수가 없는 경우가 있습니다. 이러한 경우에서도, 일반적으로은 예외를 throw 하지 않고 , 호출이나 반환값을 무시해 주세요. 다만, 후속의 <tt>flush()</tt> 나 <tt>sync</tt> 의 호출에서는 <tt>false</tt> 를 돌려줄 필요가 있습니다. <tt> true</tt> 를 돌려주었을 때에, 지금까지의 모든 조작이 정상적으로 적용되고 있는 것을 나타내기 (위해)때문에입니다.

 <p><tt>putSpi</tt>,<tt>removeSpi</tt>, 및 <tt>childSpi</tt> 가 예외를 throw 할 필요가 있는 경우가 1 개만 있습니다. 기본이 되는  operating system상에서, 요구한 조작의 실행에 필요한 특권을 호출해 옆이 가지고 있지 않은 경우입니다. 예를 들어, 대부분의 시스템에서는, 비특권 사용자가 시스템 설정을 변경하려고 하면(자) 예외가 발생합니다. 필요한 특권은, 구현 마다 다릅니다. 예를 들어, 파일 시스템내의 디렉토리의 내용을 변경하는 권한이 필요한 경우나, 레지스트리내의 키의 내용을 변경하는 권한이 필요한 경우가 있습니다. 이러한 환경의 경우, 프로그램의 실행은 속행하지 말아 주세요.  속행해도, 이러한 조작은 적용되는 것이 없기 때문입니다. 이러한 환경에서는, 가능한 한 예외를 throw 하는 것을 추천합니다. 그 경우,<A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스"><CODE>SecurityException</CODE></A>  를 throw 해 주세요.

 <p>대부분의 SPI 메소드의 구현에서는, 설정 노드로 정보의 읽어들여 또는 기입을 실시할 필요가 있습니다. 설정 노드는, 다른 VM 에 의해 배킹 스토어로부터 병행해 삭제되고 있는 경우가 있습니다. 이 노드가 삭제되고 있는 경우는, 구현하는 사용자가 재작성해 주세요.

 <p>구현상의 주의 :Sun 의 디폴트의 <tt>Preferences</tt> 구현에서는, 사용자 ID 는 기본이 되는  operating system로부터 상속되어 가상 머신의 수명중으로 바뀔 것은 없습니다. 서버측의 <tt>Preferences</tt> 구현에서는, 요구 마다 사용자 ID 가 바뀌어, 정적인 <A HREF="../../../java/lang/ThreadLocal.html" title="java.lang 안의 클래스"><CODE>ThreadLocal</CODE></A>  인스턴스를 사용해 <tt>Preferences</tt> 메소드에 암묵적으로 건네받습니다. 서버측의 구현의 작성자는, 설정에 액세스 할 경우에, 예를 들어 <A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE>get(String, String)</CODE></A>  나 <A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)"><CODE>put(String, String)</CODE></A>  메소드등을 사용해 사용자를 판단하는 것을 강하게 추천합니다.  가능한 한, 사용자와 각 <tt>Preferences</tt> 인스턴스를 영속적으로 관련짓지 말아 주세요. 사용자를 영속적으로 관련지었을 경우,<tt>Preferences</tt> 의 정상적인 사용법에 준거하고 있지 않기 때문에, 큰 혼란을 부르게 됩니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스"><CODE>Preferences</CODE></A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#lock">lock</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 객체에는, 이 노드를 잠그었을 때에 사용되는 모니터가 짜넣어지고 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#newNode">newNode</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 객체를 작성하기 전에 이 노드가 배킹 스토어에 존재하지 않았던 경우, 이 필드는 <tt>true</tt> 로 해 주세요. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.util.prefs.Preferences"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.util.prefs. <A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 안의 클래스">Preferences</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/util/prefs/Preferences.html#MAX_KEY_LENGTH">MAX_KEY_LENGTH</A> , <A HREF="../../../java/util/prefs/Preferences.html#MAX_NAME_LENGTH">MAX_NAME_LENGTH</A> , <A HREF="../../../java/util/prefs/Preferences.html#MAX_VALUE_LENGTH">MAX_VALUE_LENGTH</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#AbstractPreferences(java.util.prefs.AbstractPreferences, java.lang.String)">AbstractPreferences</A> </B>(<A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 안의 클래스">AbstractPreferences</A> &nbsp;parent,
                    <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 부모와 그 부모를 기점으로서 상대명을 사용해, 설정 노드를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#absolutePath()">absolutePath</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#absolutePath()"><CODE>Preferences.absolutePath()</CODE></A>  의 스펙에 따라,<tt>absolutePath</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#addNodeChangeListener(java.util.prefs.NodeChangeListener)">addNodeChangeListener</A> </B>(<A HREF="../../../java/util/prefs/NodeChangeListener.html" title="java.util.prefs 안의 인터페이스">NodeChangeListener</A> &nbsp;ncl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 청취자가 이 노드의 「노드 변경 이벤트」를 수신하도록(듯이) 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)">addPreferenceChangeListener</A> </B>(<A HREF="../../../java/util/prefs/PreferenceChangeListener.html" title="java.util.prefs 안의 인터페이스">PreferenceChangeListener</A> &nbsp;pcl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 청취자가 이 설정 노드에 대한 「설정 변경 이벤트」를 수신하도록(듯이) 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 내의 클래스">AbstractPreferences</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#cachedChildren()">cachedChildren</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 노드의 삭제되어 있지 않은 기존의 아이를 모두 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNames()">childrenNames</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#childrenNames()"><CODE>Preferences.childrenNames()</CODE></A>  의 스펙에 따라,<tt>children</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNamesSpi()">childrenNamesSpi</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 설정 노드의 아이의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;<A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 내의 클래스">AbstractPreferences</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)">childSpi</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 설정 노드의 이름 첨부의 아이를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#clear()">clear</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#clear()"><CODE>Preferences.clear()</CODE></A> , 의 스펙에 따라,<tt>clear</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#exportNode(java.io.OutputStream)">exportNode</A> </B>(<A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;os)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#exportNode(java.io.OutputStream)"><CODE>Preferences.exportNode(OutputStream)</CODE></A>  의 스펙에 따라,<tt>exportNode</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#exportSubtree(java.io.OutputStream)">exportSubtree</A> </B>(<A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;os)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#exportSubtree(java.io.OutputStream)"><CODE>Preferences.exportSubtree(OutputStream)</CODE></A>  의 스펙에 따라,<tt>exportSubtree</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#flush()">flush</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#flush()"><CODE>Preferences.flush()</CODE></A>  의 스펙에 따라,<tt>flush</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#flushSpi()">flushSpi</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메소드가 불려 갈 때는, 이 노드가 락 됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)">get</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
    <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String, String)</CODE></A>  의 스펙에 따라,<tt>get</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getBoolean(java.lang.String, boolean)">getBoolean</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
           boolean&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 구현에서는 <A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE><tt>get(key, null)</tt></CODE></A>  를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getByteArray(java.lang.String, byte[])">getByteArray</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
             byte[]&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#getByteArray(java.lang.String, byte[])"><CODE>Preferences.getByteArray(String, byte[])</CODE></A>  의 스펙에 따라,<tt>getByteArray</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 내의 클래스">AbstractPreferences</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getChild(java.lang.String)">getChild</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;nodeName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이름 첨부의 아이가 존재하는 경우는 그것을 돌려주어, 존재하지 않는 경우는 <tt>null</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getDouble(java.lang.String, double)">getDouble</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
          double&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#getDouble(java.lang.String, double)"><CODE>Preferences.getDouble(String, double)</CODE></A>  의 스펙에 따라,<tt>getDouble</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getFloat(java.lang.String, float)">getFloat</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
         float&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#getFloat(java.lang.String, float)"><CODE>Preferences.getFloat(String, float)</CODE></A>  의 스펙에 따라,<tt>getFloat</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getInt(java.lang.String, int)">getInt</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
       int&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#getInt(java.lang.String, int)"><CODE>Preferences.getInt(String, int)</CODE></A>  의 스펙에 따라,<tt>getInt</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getLong(java.lang.String, long)">getLong</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
        long&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#getLong(java.lang.String, long)"><CODE>Preferences.getLong(String, long)</CODE></A>  의 스펙에 따라,<tt>getLong</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#getSpi(java.lang.String)">getSpi</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 설정 노드의 지정된 키에 관련지을 수 있었던 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#isRemoved()">isRemoved</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우에,<tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#isUserNode()">isUserNode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#isUserNode()"><CODE>Preferences.isUserNode()</CODE></A>  의 스펙에 따라,<tt>isUserNode</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#keys()">keys</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#keys()"><CODE>Preferences.keys()</CODE></A>  의 스펙에 따라,<tt>keys</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#keysSpi()">keysSpi</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 설정 노드내에 관련지을 수 있었던 값을 가지는 키를 모두 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#name()">name</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#name()"><CODE>Preferences.name()</CODE></A>  의 스펙에 따라,<tt>name</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#node(java.lang.String)">node</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#node(java.lang.String)"><CODE>Preferences.node(String)</CODE></A>  의 스펙에 따라,<tt>node</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#nodeExists(java.lang.String)">nodeExists</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#nodeExists(java.lang.String)"><CODE>Preferences.nodeExists(String)</CODE></A>  의 스펙에 따라,<tt>nodeExists</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#parent()">parent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#parent()"><CODE>Preferences.parent()</CODE></A>  의 스펙에 따라,<tt>parent</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)">put</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
    <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#put(java.lang.String, java.lang.String)"><CODE>Preferences.put(String, String)</CODE></A>  의 스펙에 따라,<tt>put</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putBoolean(java.lang.String, boolean)">putBoolean</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
           boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#putBoolean(java.lang.String, boolean)"><CODE>Preferences.putBoolean(String, boolean)</CODE></A>  의 스펙에 따라,<tt>putBoolean</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putByteArray(java.lang.String, byte[])">putByteArray</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
             byte[]&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#putByteArray(java.lang.String, byte[])"><CODE>Preferences.putByteArray(String, byte[])</CODE></A>  의 스펙에 따라,<tt>putByteArray</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putDouble(java.lang.String, double)">putDouble</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
          double&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#putDouble(java.lang.String, double)"><CODE>Preferences.putDouble(String, double)</CODE></A>  의 스펙에 따라,<tt>putDouble</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putFloat(java.lang.String, float)">putFloat</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
         float&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#putFloat(java.lang.String, float)"><CODE>Preferences.putFloat(String, float)</CODE></A>  의 스펙에 따라,<tt>putFloat</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putInt(java.lang.String, int)">putInt</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
       int&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#putInt(java.lang.String, int)"><CODE>Preferences.putInt(String, int)</CODE></A>  의 스펙에 따라,<tt>putInt</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putLong(java.lang.String, long)">putLong</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
        long&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#putLong(java.lang.String, long)"><CODE>Preferences.putLong(String, long)</CODE></A>  의 스펙에 따라,<tt>putLong</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#putSpi(java.lang.String, java.lang.String)">putSpi</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
       <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 키와 값의 페어를 이 설정 노드에 관련짓습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#remove(java.lang.String)">remove</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/AbstractPreferences.html#removeSpi(java.lang.String)"><CODE>removeSpi(String)</CODE></A>  의 스펙에 따라,<tt>remove(String)</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()">removeNode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A>  의 스펙에 따라,<tt>removeNode()</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNodeChangeListener(java.util.prefs.NodeChangeListener)">removeNodeChangeListener</A> </B>(<A HREF="../../../java/util/prefs/NodeChangeListener.html" title="java.util.prefs 안의 인터페이스">NodeChangeListener</A> &nbsp;ncl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <tt>NodeChangeListener</tt> 를 삭제해, 이벤트의 수신을 정지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNodeSpi()">removeNodeSpi</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 호출을 실시하면, 이름 첨부의 아이의 하위 노드가 모두 삭제됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#removePreferenceChangeListener(java.util.prefs.PreferenceChangeListener)">removePreferenceChangeListener</A> </B>(<A HREF="../../../java/util/prefs/PreferenceChangeListener.html" title="java.util.prefs 안의 인터페이스">PreferenceChangeListener</A> &nbsp;pcl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 설정 변경 청취자를 삭제해, 설정 변경 이벤트의 수신을 정지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#removeSpi(java.lang.String)">removeSpi</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 설정 노드의 지정된 키에 관련짓고가 있는 경우는, 그것을 삭제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#sync()">sync</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../java/util/prefs/Preferences.html#sync()"><CODE>Preferences.sync()</CODE></A>  의 스펙에 따라,<tt>sync</tt> 메소드를 구현합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#syncSpi()">syncSpi</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메소드가 불려 갈 때는, 이 노드가 락 됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/prefs/AbstractPreferences.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 설정 노드의 절대 경로명을 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.prefs.Preferences"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.util.prefs. <A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 안의 클래스">Preferences</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/util/prefs/Preferences.html#importPreferences(java.io.InputStream)">importPreferences</A> , <A HREF="../../../java/util/prefs/Preferences.html#systemNodeForPackage(java.lang.Class)">systemNodeForPackage</A> , <A HREF="../../../java/util/prefs/Preferences.html#systemRoot()">systemRoot</A> , <A HREF="../../../java/util/prefs/Preferences.html#userNodeForPackage(java.lang.Class)">userNodeForPackage</A> , <A HREF="../../../java/util/prefs/Preferences.html#userRoot()">userRoot</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="newNode"><!-- --></A> <H3>
newNode</H3>
<PRE>
protected boolean <B>newNode</B></PRE>
<DL>
<DD>이 객체를 작성하기 전에 이 노드가 배킹 스토어에 존재하지 않았던 경우, 이 필드는 <tt>true</tt> 로 해 주세요. 이 필드의 초기치는 false 입니다만, 서브 클래스의 생성자 에 의해 true 로 설정됩니다 (그 이후는 변경하지 말아 주세요). 이 필드에는, 객체의 작성이 완료했을 때에 노드 변경 이벤트를 트리거할 필요가 있을지 어떨지를 지정합니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="lock"><!-- --></A> <H3>
lock</H3>
<PRE>
protected final <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>lock</B></PRE>
<DL>
<DD>이 객체에는, 이 노드를 잠그었을 때에 사용되는 모니터가 짜넣어지고 있습니다. 이 객체는, 그 노드 자체보다 우선되어 노드가 락 되었을 때에 의도적 또는 비의도적으로 서비스가 거부될 가능성을 감소합니다. 데드락을 회피하기 위해서, 하위 노드의 락을 보관 유지하고 있는 thread에 의해 상위 노드가 락 될 것은 없습니다.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AbstractPreferences(java.util.prefs.AbstractPreferences, java.lang.String)"><!-- --></A> <H3>
AbstractPreferences</H3>
<PRE>
protected <B>AbstractPreferences</B>(<A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 안의 클래스">AbstractPreferences</A> &nbsp;parent,
                              <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>지정된 부모와 그 부모를 기점으로서 상대명을 사용해, 설정 노드를 작성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>parent</CODE> - 이 설정 노드의 부모. 이 노드가 루트의 경우는 null<DD><CODE>name</CODE> - 이 설정 노드의 부모에 대한 상대명. 이것이 루트의 경우는<tt>「」</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>name</tt> 에 slash (<tt>「/」</tt>)가 포함되어 있는지,<tt>parent</tt> 가 <tt>null</tt> 로 name 가<tt>「」</tt>이 아닌 경우</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="put(java.lang.String, java.lang.String)"><!-- --></A> <H3>
put</H3>
<PRE>
public void <B>put</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;value)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#put(java.lang.String, java.lang.String)"><CODE>Preferences.put(String, String)</CODE></A>  의 스펙에 따라,<tt>put</tt> 메소드를 구현합니다.

 <p>이 구현에서는, 키와 값이 정당한 것을 확인해, 이 설정 노드의 락을 취득해, 설정 노드가 삭제되어 있지 않은 것을 확인해,<A HREF="../../../java/util/prefs/AbstractPreferences.html#putSpi(java.lang.String, java.lang.String)"><CODE>putSpi(String, String)</CODE></A>  를 호출합니다.  또, 설정 변경 청취자가 있는 경우는, 이벤트발송쓰레드에 건네주기 위해서(때문에) 통지 이벤트를 큐에 넣습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#put(java.lang.String, java.lang.String)">put</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 지정된 값을 관련지을 수 있는 키<DD><CODE>value</CODE> - 지정된 키에 관련지을 수 있는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 키 또는 값이 <tt>null</tt> 의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>key.length()</tt> 가 <tt>MAX_KEY_LENGTH</tt> 를 넘는 경우, 또는 <tt>value.length</tt> 가 <tt>MAX_VALUE_LENGTH</tt> 를 넘는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="get(java.lang.String, java.lang.String)"><!-- --></A> <H3>
get</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>get</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                  <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;def)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String, String)</CODE></A>  의 스펙에 따라,<tt>get</tt> 메소드를 구현합니다.

 <p>이 구현은 우선,<tt>key</tt> 가 <tt>null</tt> 화도인지를 체크해, 그런 경우는 <tt>NullPointerException</tt> 를 throw 합니다. 다음에, 이 설정 노드의 락을 취득해, 그 노드가 삭제되어 있지 않은 것을 확인해,<A HREF="../../../java/util/prefs/AbstractPreferences.html#getSpi(java.lang.String)"><CODE>getSpi(String)</CODE></A>  를 호출합니다. <tt> getSpi</tt> 의 호출이 정상 종료했을 경우는, 그 결과를 돌려줍니다. <tt> null</tt> 가 돌려주어질까 예외가 throw 되었을 경우는,<tt>def</tt> 를 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)">get</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 관련지을 수 있었던 값이 반환되는 키<DD><CODE>def</CODE> - 이 설정 노드를 <tt>key</tt> 에 관련지을 수 있었던 값을 가지지 않는 경우에 돌려주어야 할 값
<DT><B>반환값:</B><DD><tt>key</tt> 에 관련지을 수 있었던 값. <tt>key</tt> 에 관련지을 수 있었던 값이 존재하지 않는 경우는 <tt>def</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - key 가 <tt>null</tt> 의 경우 (<tt>null</tt> 디폴트는 허가된다. )<i></i></DL>
</DD>
</DL>
<HR>

<A NAME="remove(java.lang.String)"><!-- --></A> <H3>
remove</H3>
<PRE>
public void <B>remove</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/AbstractPreferences.html#removeSpi(java.lang.String)"><CODE>removeSpi(String)</CODE></A>  의 스펙에 따라,<tt>remove(String)</tt> 메소드를 구현합니다.

 <p>이 구현에서는, 이 설정 노드의 락을 취득해, 설정 노드가 삭제되어 있지 않은 것을 확인해,<A HREF="../../../java/util/prefs/AbstractPreferences.html#removeSpi(java.lang.String)"><CODE>removeSpi(String)</CODE></A>  를 호출합니다. 또, 설정 변경 청취자가 있는 경우는, 이벤트발송쓰레드에 건네주기 위해서(때문에) 통지 이벤트를 큐에 넣습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#remove(java.lang.String)">remove</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 매핑이 설정 노드로부터 삭제되는 키
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="clear()"><!-- --></A> <H3>
clear</H3>
<PRE>
public void <B>clear</B>()
           throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#clear()"><CODE>Preferences.clear()</CODE></A> , 의 스펙에 따라,<tt>clear</tt> 메소드를 구현합니다.

 <p>이 구현에서는, 이 설정 노드의 락을 취득해,<A HREF="../../../java/util/prefs/AbstractPreferences.html#keys()"><CODE>keys()</CODE></A>  를 호출해 키의 배열을 가져옵니다. 다음에, 각 키에 대해서 반복해 <A HREF="../../../java/util/prefs/AbstractPreferences.html#remove(java.lang.String)"><CODE>remove(String)</CODE></A>  를 호출합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#clear()">clear</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 배킹 스토어에서 장해가 발생했는지 스토어와의 통신을 실시할 수 없기 위해(때문에), 이 오퍼레이션을 완료할 수 없는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="putInt(java.lang.String, int)"><!-- --></A> <H3>
putInt</H3>
<PRE>
public void <B>putInt</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                   int&nbsp;value)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#putInt(java.lang.String, int)"><CODE>Preferences.putInt(String, int)</CODE></A>  의 스펙에 따라,<tt>putInt</tt> 메소드를 구현합니다.

 <p>이 구현에서는,<A HREF="../../../java/lang/Integer.html#toString(int)"><CODE>Integer.toString(int)</CODE></A>  를 사용해 <tt>value</tt> 를 캐릭터 라인으로 변환해, 그 결과에 대해서 <A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)"><CODE>put(String, String)</CODE></A>  를 호출합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#putInt(java.lang.String, int)">putInt</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 캐릭터 라인 형식의 값을 관련지을 수 있는 키<DD><CODE>value</CODE> - 키에 관련지을 수 있는 캐릭터 라인 형식의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 키가 <tt>null</tt> 의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>key.length()</tt> 가 <tt>MAX_KEY_LENGTH</tt> 를 넘는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#getInt(java.lang.String, int)"><CODE>Preferences.getInt(String, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getInt(java.lang.String, int)"><!-- --></A> <H3>
getInt</H3>
<PRE>
public int <B>getInt</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                  int&nbsp;def)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#getInt(java.lang.String, int)"><CODE>Preferences.getInt(String, int)</CODE></A>  의 스펙에 따라,<tt>getInt</tt> 메소드를 구현합니다.

 <p>이 구현은,<A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE><tt>get(key, null)</tt></CODE></A>  를 호출합니다. 반환값이 null 가 아닌 경우는,<A HREF="../../../java/lang/Integer.html#parseInt(java.lang.String)"><CODE>Integer.parseInt(String)</CODE></A>  를 사용해 그 값을 <tt>int</tt> 로 변환하려고 합니다. 정상적으로 변환되었을 경우는, 이 메소드에 의해 반환값이 돌려주어집니다. 정상적으로 변환되지 않았던 경우는,<tt>def</tt> 가 돌려주어집니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#getInt(java.lang.String, int)">getInt</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 관련지을 수 있었던 값이 int 로서 반환되는 키<DD><CODE>def</CODE> - 이 설정 노드를 <tt>key</tt> 에 관련지을 수 있었던 값을 가지지 않는가, 관련지을 수 있었던 값을 int 로서 해석할 수 없는 경우에 돌려주어야 할 값
<DT><B>반환값:</B><DD>이 설정 노드내의 <tt>key</tt> 에 관련지을 수 있었던 캐릭터 라인이 나타내는 int 치. 관련지을 수 있었던 값이 존재하지 않는지, 그 값을 int 로서 해석할 수 없는 경우는 <tt>def</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>key</tt> 가 <tt>null</tt> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#putInt(java.lang.String, int)"><CODE>Preferences.putInt(String, int)</CODE></A> , 
<A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String, String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="putLong(java.lang.String, long)"><!-- --></A> <H3>
putLong</H3>
<PRE>
public void <B>putLong</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                    long&nbsp;value)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#putLong(java.lang.String, long)"><CODE>Preferences.putLong(String, long)</CODE></A>  의 스펙에 따라,<tt>putLong</tt> 메소드를 구현합니다.

 <p>이 구현에서는,<A HREF="../../../java/lang/Long.html#toString(long)"><CODE>Long.toString(long)</CODE></A>  를 사용해 <tt>value</tt> 를 캐릭터 라인으로 변환해, 그 결과에 대해서 <A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)"><CODE>put(String, String)</CODE></A>  를 호출합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#putLong(java.lang.String, long)">putLong</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 캐릭터 라인 형식의 값을 관련지을 수 있는 키<DD><CODE>value</CODE> - 키에 관련지을 수 있는 캐릭터 라인 형식의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 키가 <tt>null</tt> 의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>key.length()</tt> 가 <tt>MAX_KEY_LENGTH</tt> 를 넘는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#getLong(java.lang.String, long)"><CODE>Preferences.getLong(String, long)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getLong(java.lang.String, long)"><!-- --></A> <H3>
getLong</H3>
<PRE>
public long <B>getLong</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                    long&nbsp;def)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#getLong(java.lang.String, long)"><CODE>Preferences.getLong(String, long)</CODE></A>  의 스펙에 따라,<tt>getLong</tt> 메소드를 구현합니다.

 <p>이 구현은,<A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE><tt>get(key, null)</tt></CODE></A>  를 호출합니다. 반환값이 null 가 아닌 경우는,<A HREF="../../../java/lang/Long.html#parseLong(java.lang.String)"><CODE>Long.parseLong(String)</CODE></A>  를 사용해 그 값을 <tt>long</tt> 로 변환하려고 합니다. 정상적으로 변환되었을 경우는, 이 메소드에 의해 반환값이 돌려주어집니다. 정상적으로 변환되지 않았던 경우는,<tt>def</tt> 가 돌려주어집니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#getLong(java.lang.String, long)">getLong</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 관련지을 수 있었던 값이 long 로서 반환되는 키<DD><CODE>def</CODE> - 이 설정 노드를 <tt>key</tt> 에 관련지을 수 있었던 값을 가지지 않는가, 관련지을 수 있었던 값을 long 로서 해석할 수 없는 경우에 돌려주어야 할 값
<DT><B>반환값:</B><DD>이 설정 노드내의 <tt>key</tt> 에 관련지을 수 있었던 캐릭터 라인이 나타내는 long 치. 관련지을 수 있었던 값이 존재하지 않는지, 그 값을 long 로서 해석할 수 없는 경우는 <tt>def</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>key</tt> 가 <tt>null</tt> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#putLong(java.lang.String, long)"><CODE>Preferences.putLong(String, long)</CODE></A> , 
<A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String, String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="putBoolean(java.lang.String, boolean)"><!-- --></A> <H3>
putBoolean</H3>
<PRE>
public void <B>putBoolean</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                       boolean&nbsp;value)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#putBoolean(java.lang.String, boolean)"><CODE>Preferences.putBoolean(String, boolean)</CODE></A>  의 스펙에 따라,<tt>putBoolean</tt> 메소드를 구현합니다.

 <p>이 구현에서는,<A HREF="../../../java/lang/String.html#valueOf(boolean)"><CODE>String.valueOf(boolean)</CODE></A>  를 사용해 <tt>value</tt> 를 캐릭터 라인으로 변환해, 그 결과에 대해서 <A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)"><CODE>put(String, String)</CODE></A>  를 호출합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#putBoolean(java.lang.String, boolean)">putBoolean</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 캐릭터 라인 형식의 값을 관련지을 수 있는 키<DD><CODE>value</CODE> - 키에 관련지을 수 있는 캐릭터 라인 형식의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 키가 <tt>null</tt> 의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>key.length()</tt> 가 <tt>MAX_KEY_LENGTH</tt> 를 넘는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#getBoolean(java.lang.String, boolean)"><CODE>Preferences.getBoolean(String, boolean)</CODE></A> , 
<A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String, String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBoolean(java.lang.String, boolean)"><!-- --></A> <H3>
getBoolean</H3>
<PRE>
public boolean <B>getBoolean</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                          boolean&nbsp;def)</PRE>
<DL>
<DD>이 구현에서는 <A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE><tt>get(key, null)</tt></CODE></A>  를 호출합니다.

 <p>이 구현은,<A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE><tt>get(key, null)</tt></CODE></A>  를 호출합니다. 반환값이 null 이외의 경우, 그 값이 <A HREF="../../../java/lang/String.html#equalsIgnoreCase(java.lang.String)"><CODE>String.equalsIgnoreCase(String)</CODE></A>  를 사용해<tt>「true」</tt>라고 비교됩니다. 이 비교에 의해 <tt>true</tt> 가 돌려주어졌을 경우, 이 호출에 의해 <tt>true</tt> 가 돌려주어집니다. 그렇지 않은 경우는, 재차 <A HREF="../../../java/lang/String.html#equalsIgnoreCase(java.lang.String)"><CODE>String.equalsIgnoreCase(String)</CODE></A>  를 사용해 원의 반환값이 <tt>"false"</tt> 라고 비교됩니다. 이 비교에 의해 <tt>true</tt> 가 돌려주어졌을 경우, 이 호출에 의해 <tt>false</tt> 가 돌려주어집니다. 그렇지 않은 경우는,<tt>def</tt> 가 돌려주어집니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#getBoolean(java.lang.String, boolean)">getBoolean</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 관련지을 수 있었던 값이 boolean 로서 반환되는 키<DD><CODE>def</CODE> - 이 설정 노드를 <tt>key</tt> 에 관련지을 수 있었던 값을 가지지 않는가, 관련지을 수 있었던 값을 boolean 로서 해석할 수 없는 경우에 돌려주어야 할 값
<DT><B>반환값:</B><DD>이 설정 노드내의 <tt>key</tt> 에 관련지을 수 있었던 캐릭터 라인이 나타내는 boolean 치. 관련지을 수 있었던 값이 존재하지 않는지, 그 값을 boolean 로서 해석할 수 없는 경우는 <tt>def</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>key</tt> 가 <tt>null</tt> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String, String)</CODE></A> , 
<A HREF="../../../java/util/prefs/Preferences.html#putBoolean(java.lang.String, boolean)"><CODE>Preferences.putBoolean(String, boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="putFloat(java.lang.String, float)"><!-- --></A> <H3>
putFloat</H3>
<PRE>
public void <B>putFloat</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                     float&nbsp;value)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#putFloat(java.lang.String, float)"><CODE>Preferences.putFloat(String, float)</CODE></A>  의 스펙에 따라,<tt>putFloat</tt> 메소드를 구현합니다.

 <p>이 구현에서는,<A HREF="../../../java/lang/Float.html#toString(float)"><CODE>Float.toString(float)</CODE></A>  를 사용해 <tt>value</tt> 를 캐릭터 라인으로 변환해, 그 결과에 대해서 <A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)"><CODE>put(String, String)</CODE></A>  를 호출합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#putFloat(java.lang.String, float)">putFloat</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 캐릭터 라인 형식의 값을 관련지을 수 있는 키<DD><CODE>value</CODE> - 키에 관련지을 수 있는 캐릭터 라인 형식의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 키가 <tt>null</tt> 의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>key.length()</tt> 가 <tt>MAX_KEY_LENGTH</tt> 를 넘는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#getFloat(java.lang.String, float)"><CODE>Preferences.getFloat(String, float)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getFloat(java.lang.String, float)"><!-- --></A> <H3>
getFloat</H3>
<PRE>
public float <B>getFloat</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                      float&nbsp;def)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#getFloat(java.lang.String, float)"><CODE>Preferences.getFloat(String, float)</CODE></A>  의 스펙에 따라,<tt>getFloat</tt> 메소드를 구현합니다.

 <p>이 구현은,<A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE><tt>get(key, null)</tt></CODE></A>  를 호출합니다. 반환값이 null 가 아닌 경우는,<A HREF="../../../java/lang/Float.html#parseFloat(java.lang.String)"><CODE>Float.parseFloat(String)</CODE></A>  를 사용해 그 값을 <tt>float</tt> 로 변환하려고 합니다. 정상적으로 변환되었을 경우는, 이 메소드에 의해 반환값이 돌려주어집니다. 정상적으로 변환되지 않았던 경우는,<tt>def</tt> 가 돌려주어집니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#getFloat(java.lang.String, float)">getFloat</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 관련지을 수 있었던 값이 float 로서 반환되는 키<DD><CODE>def</CODE> - 이 설정 노드를 <tt>key</tt> 에 관련지을 수 있었던 값을 가지지 않는가, 관련지을 수 있었던 값을 float 로서 해석할 수 없는 경우에 돌려주어야 할 값
<DT><B>반환값:</B><DD>이 설정 노드내의 <tt>key</tt> 에 관련지을 수 있었던 캐릭터 라인이 나타내는 float 치. 관련지을 수 있었던 값이 존재하지 않는지, 그 값을 float 로서 해석할 수 없는 경우는 <tt>def</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>key</tt> 가 <tt>null</tt> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#putFloat(java.lang.String, float)"><CODE>Preferences.putFloat(String, float)</CODE></A> , 
<A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String, String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="putDouble(java.lang.String, double)"><!-- --></A> <H3>
putDouble</H3>
<PRE>
public void <B>putDouble</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                      double&nbsp;value)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#putDouble(java.lang.String, double)"><CODE>Preferences.putDouble(String, double)</CODE></A>  의 스펙에 따라,<tt>putDouble</tt> 메소드를 구현합니다.

 <p>이 구현에서는,<A HREF="../../../java/lang/Double.html#toString(double)"><CODE>Double.toString(double)</CODE></A>  를 사용해 <tt>value</tt> 를 캐릭터 라인으로 변환해, 그 결과에 대해서 <A HREF="../../../java/util/prefs/AbstractPreferences.html#put(java.lang.String, java.lang.String)"><CODE>put(String, String)</CODE></A>  를 호출합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#putDouble(java.lang.String, double)">putDouble</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 캐릭터 라인 형식의 값을 관련지을 수 있는 키<DD><CODE>value</CODE> - 키에 관련지을 수 있는 캐릭터 라인 형식의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 키가 <tt>null</tt> 의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>key.length()</tt> 가 <tt>MAX_KEY_LENGTH</tt> 를 넘는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#getDouble(java.lang.String, double)"><CODE>Preferences.getDouble(String, double)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDouble(java.lang.String, double)"><!-- --></A> <H3>
getDouble</H3>
<PRE>
public double <B>getDouble</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                        double&nbsp;def)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#getDouble(java.lang.String, double)"><CODE>Preferences.getDouble(String, double)</CODE></A>  의 스펙에 따라,<tt>getDouble</tt> 메소드를 구현합니다.

 <p>이 구현은,<A HREF="../../../java/util/prefs/AbstractPreferences.html#get(java.lang.String, java.lang.String)"><CODE><tt>get(key, null)</tt></CODE></A>  를 호출합니다. 반환값이 null 가 아닌 경우는,<A HREF="../../../java/lang/Double.html#parseDouble(java.lang.String)"><CODE>Double.parseDouble(String)</CODE></A>  를 사용해 그 값을 <tt>double</tt> 로 변환하려고 합니다. 정상적으로 변환되었을 경우는, 이 메소드에 의해 반환값이 돌려주어집니다. 정상적으로 변환되지 않았던 경우는,<tt>def</tt> 가 돌려주어집니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#getDouble(java.lang.String, double)">getDouble</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 관련지을 수 있었던 값이 double 로서 반환되는 키<DD><CODE>def</CODE> - 이 설정 노드를 <tt>key</tt> 에 관련지을 수 있었던 값을 가지지 않는가, 관련지을 수 있었던 값을 double 로서 해석할 수 없는 경우에 돌려주어야 할 값
<DT><B>반환값:</B><DD>이 설정 노드내의 <tt>key</tt> 에 관련지을 수 있었던 캐릭터 라인이 나타내는 double 치. 관련지을 수 있었던 값이 존재하지 않는지, 그 값을 double 로서 해석할 수 없는 경우는 <tt>def</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>key</tt> 가 <tt>null</tt> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#putDouble(java.lang.String, double)"><CODE>Preferences.putDouble(String, double)</CODE></A> , 
<A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String, String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="putByteArray(java.lang.String, byte[])"><!-- --></A> <H3>
putByteArray</H3>
<PRE>
public void <B>putByteArray</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                         byte[]&nbsp;value)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#putByteArray(java.lang.String, byte[])"><CODE>Preferences.putByteArray(String, byte[])</CODE></A>  의 스펙에 따라,<tt>putByteArray</tt> 메소드를 구현합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#putByteArray(java.lang.String, byte[])">putByteArray</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 캐릭터 라인 형식의 값을 관련지을 수 있는 키<DD><CODE>value</CODE> - 키에 관련지을 수 있는 캐릭터 라인 형식의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 키 또는 값이 <tt>null</tt> 의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - key.length()가 MAX_KEY_LENGTH 를 넘는 경우, 또는 value.length 가 MAX_VALUE_LENGTH*3/4 를 넘는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#getByteArray(java.lang.String, byte[])"><CODE>Preferences.getByteArray(String, byte[])</CODE></A> , 
<A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String, String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getByteArray(java.lang.String, byte[])"><!-- --></A> <H3>
getByteArray</H3>
<PRE>
public byte[] <B>getByteArray</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                           byte[]&nbsp;def)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#getByteArray(java.lang.String, byte[])"><CODE>Preferences.getByteArray(String, byte[])</CODE></A>  의 스펙에 따라,<tt>getByteArray</tt> 메소드를 구현합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#getByteArray(java.lang.String, byte[])">getByteArray</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 관련지을 수 있었던 값이 바이트 배열로서 반환되는 키<DD><CODE>def</CODE> - 이 설정 노드를 <tt>key</tt> 에 관련지을 수 있었던 값을 가지지 않는가, 관련지을 수 있었던 값을 바이트 배열로서 해석할 수 없는 경우에 돌려주어야 할 값
<DT><B>반환값:</B><DD>이 설정 노드내의 <tt>key</tt> 에 관련지을 수 있었던 캐릭터 라인이 나타내는 바이트 배열치. 관련지을 수 있었던 값이 존재하지 않는지, 그 값을 바이트 배열로서 해석할 수 없는 경우는 <tt>def</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>key</tt> 가 <tt>null</tt> 의 경우 (<tt>def</tt> 에는 <tt>null</tt> 치를 지정할 수 있다<i></i>. )<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#get(java.lang.String, java.lang.String)"><CODE>Preferences.get(String, String)</CODE></A> , 
<A HREF="../../../java/util/prefs/Preferences.html#putByteArray(java.lang.String, byte[])"><CODE>Preferences.putByteArray(String, byte[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="keys()"><!-- --></A> <H3>
keys</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>keys</B>()
              throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#keys()"><CODE>Preferences.keys()</CODE></A>  의 스펙에 따라,<tt>keys</tt> 메소드를 구현합니다.

 <p>이 구현에서는, 이 설정 노드의 락을 취득해, 그 노드가 삭제되어 있지 않은 것을 확인해,<A HREF="../../../java/util/prefs/AbstractPreferences.html#keysSpi()"><CODE>keysSpi()</CODE></A>  를 호출합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#keys()">keys</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 설정 노드내에 관련지을 수 있었던 값을 가지는 키의 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 배킹 스토어에서 장해가 발생했는지 스토어와의 통신을 실시할 수 없기 위해(때문에), 이 오퍼레이션을 완료할 수 없는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="childrenNames()"><!-- --></A> <H3>
childrenNames</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>childrenNames</B>()
                       throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#childrenNames()"><CODE>Preferences.childrenNames()</CODE></A>  의 스펙에 따라,<tt>children</tt> 메소드를 구현합니다.

 <p>이 구현에서는, 이 설정 노드의 락을 취득해, 그 노드가 삭제되어 있지 않은 것을 확인해, 캐쉬 끝난 아이 (이 노드의 「아이 캐쉬」에 포함되고 있는 아이)의 이름에 초기화되고 있는 <tt>TreeSet</tt> 를 구축해,<A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNamesSpi()"><CODE>childrenNamesSpi()</CODE></A>  를 호출해, 반환된 모든 아이의 이름을 그 세트내에 추가합니다. 다음에,<A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNamesSpi()"><CODE>childrenNamesSpi()</CODE></A>  를 호출해, 반환된 아이의 이름을 모두 그 트리 세트에 추가합니다.  트리 세트의 요소는 <tt>toArray</tt> 메소드를 사용해 <tt>String</tt> 배열에 덤프 되어 이 배열이 돌려주어집니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#childrenNames()">childrenNames</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 설정 노드의 아이의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 배킹 스토어에서 장해가 발생했는지 스토어와의 통신을 실시할 수 없기 위해(때문에), 이 오퍼레이션을 완료할 수 없는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/AbstractPreferences.html#cachedChildren()"><CODE>cachedChildren()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="cachedChildren()"><!-- --></A> <H3>
cachedChildren</H3>
<PRE>
protected final <A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 내의 클래스">AbstractPreferences</A> [] <B>cachedChildren</B>()</PRE>
<DL>
<DD>이 노드의 삭제되어 있지 않은 기존의 아이를 모두 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 노드의 삭제되어 있지 않은 기존의 모든 아이</DL>
</DD>
</DL>
<HR>

<A NAME="parent()"><!-- --></A> <H3>
parent</H3>
<PRE>
public <A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A>  <B>parent</B>()</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#parent()"><CODE>Preferences.parent()</CODE></A>  의 스펙에 따라,<tt>parent</tt> 메소드를 구현합니다.

 <p>이 구현에서는, 이 설정 노드의 락을 취득해, 설정 노드가 삭제되어 있지 않은 것을 확인해, 이 노드의 생성자 에게 건네진 부모의 값을 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#parent()">parent</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 설정 노드의 부모
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="node(java.lang.String)"><!-- --></A> <H3>
node</H3>
<PRE>
public <A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A>  <B>node</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;path)</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#node(java.lang.String)"><CODE>Preferences.node(String)</CODE></A>  의 스펙에 따라,<tt>node</tt> 메소드를 구현합니다.

 <p>이 구현은, 이 설정 노드의 락을 취득해, 설정 노드가 삭제되어 있지 않은 것을 확인합니다. <tt>path</tt> 가 <tt>""</tt> 의 경우는, 이 노드가 돌려주어집니다. <tt> path</tt> 가 <tt>"/"</tt> 의 경우는, 이 노드의 루트가 돌려주어집니다. <tt>path</tt> 의 최초의 문자가 <tt>'/'</tt> 가 아닌 경우는,<tt>path</tt> 를 몇개의 토큰에 분할해, 이 노드로부터 이름 첨부 노드까지 패스를 재귀적으로 횡단(traverse) 합니다. <tt>path</tt> 는, 이름과 slash의 단위로 횡단(traverse) 됩니다. 횡단(traverse) 할 때는, 현재의 노드를 잠그어, 그 노드의 아이 캐쉬에 이름 첨부 노드가 있을지 어떨지를 확인합니다. 이름 첨부 노드가 발견되지 않는 경우는, 그 이름의 길이가 <tt>MAX_NAME_LENGTH</tt> 를 넘지 않은지 어떤지를 확인합니다. 다음에 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(String)</CODE></A>  메소드를 호출해, 그 결과를 이 노드의 아이 캐쉬에 포함합니다. 새롭게 작성한 <tt>Preferences</tt> 객체의 <A HREF="../../../java/util/prefs/AbstractPreferences.html#newNode"><CODE>newNode</CODE></A>  필드가 <tt>true</tt> 로, 노드 변경 청취자가 있는 경우는, 이벤트발송쓰레드에 건네주기 위해서(때문에) 통지 이벤트를 큐에 넣습니다.  

 <p>토큰이 없어지면(자), 아이 캐쉬에 마지막에 발견된 값 또는 <tt>childSpi</tt> 로부터 마지막에 반환된 값을 돌려줍니다. 횡단(traverse)시에 2 개의 것 <tt>"/"</tt> 이 연속해 발생했을 경우, 또는 마지막 토큰이 이름은 아니고 <tt>"/"</tt> 의 경우는, 적절한 <tt>IllegalArgumentException</tt> 를 throw 합니다.

 <p> <tt>path</tt> 의 최초의 문자가 <tt>'/'</tt> (절대 경로명을 나타낸다)의 경우는, 이 설정 노드의 락을 해제하고 나서,<tt>path</tt> 를 몇개의 토큰에 분할해, 패스를 루트로부터 (이 노드로부터는 아니게) 재귀적으로 횡단(traverse) 합니다. 최초의 문자가 <tt>'/'</tt> 이외의 경우는, 상대 경로명과 같은 횡단(traverse)을 실시합니다. 루트 노드로 횡단(traverse)을 개시할 때는, 이 노드의 락을 반드시 해제해 주세요.  데드락의 발생을 막기 위해입니다 (<A HREF="../../../java/util/prefs/AbstractPreferences.html#lock"><CODE>locking invariant</CODE></A>  를 참조).
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#node(java.lang.String)">node</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>path</CODE> - 반환되는 설정 노드의 경로명
<DT><B>반환값:</B><DD>지정된 설정 노드
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 경로명이 무효인 경우 (즉, 경로명에 연속한 복수의 slash 문자가 포함되어 있는지, 경로명이 slash 문자로 끝나 있어 그 길이가 2 문자 이상의 경우)
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#flush()"><CODE>Preferences.flush()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="nodeExists(java.lang.String)"><!-- --></A> <H3>
nodeExists</H3>
<PRE>
public boolean <B>nodeExists</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;path)
                   throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#nodeExists(java.lang.String)"><CODE>Preferences.nodeExists(String)</CODE></A>  의 스펙에 따라,<tt>nodeExists</tt> 메소드를 구현합니다.

 <p>이 구현은,<A HREF="../../../java/util/prefs/AbstractPreferences.html#node(java.lang.String)"><CODE>node(String)</CODE></A>  와 닮아 있습니다만,<A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(String)</CODE></A>  는 아니고 <A HREF="../../../java/util/prefs/AbstractPreferences.html#getChild(java.lang.String)"><CODE>getChild(String)</CODE></A>  가 사용됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#nodeExists(java.lang.String)">nodeExists</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>path</CODE> - 존재가 확인되는 노드의 경로명
<DT><B>반환값:</B><DD>지정된 노드가 존재하는 경우에 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 배킹 스토어에서 장해가 발생했는지 스토어와의 통신을 실시할 수 없기 위해(때문에), 이 오퍼레이션을 완료할 수 없는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 경로명이 무효인 경우 (즉, 경로명에 연속한 복수의 slash 문자가 포함되어 있는지, 경로명이 slash 문자로 끝나 있어 그 길이가 2 문자 이상의 경우)
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되고 있어<tt>pathname</tt> 가 빈 상태(empty)의 캐릭터 라인 (<tt>「」</tt>)이 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="removeNode()"><!-- --></A> <H3>
removeNode</H3>
<PRE>
public void <B>removeNode</B>()
                throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A>  의 스펙에 따라,<tt>removeNode()</tt> 메소드를 구현합니다.

 <p>이 구현은, 이 노드가 루트일지 어떨지를 확인합니다. 루트인 경우는, 해당하는 예외를 throw 합니다. 다음에, 이 노드의 부모를 잠그어, 이 노드를 루트로 한 서브 트리를 횡단(traverse) 하는 재귀적 헬퍼 메소드를 호출합니다. 이 재귀적 메소드는, 그 호출원의 노드를 잠그어, 그 노드가 삭제되어 있지 않은 것을 확인한 후에, 그 노드의 아이가 모두 캐쉬되고 있는 것을 확인합니다. 즉,<A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNamesSpi()"><CODE>childrenNamesSpi()</CODE></A>  메소드를 호출해, 반환된 아이의 이름이 아이 캐쉬에 포함되고 있는지 어떤지를 확인합니다. 아이가 캐쉬되어 있지 않은 경우는,<A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(String)</CODE></A>  메소드를 호출해 <tt>Preferences</tt> 인스턴스를 작성해, 아이 캐쉬에 포함합니다. 이 헬퍼 메소드는, 그 아이 캐쉬에 포함되어 있는 노드 마다 자신을 재귀적으로 호출합니다. 다음에,<A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNodeSpi()"><CODE>removeNodeSpi()</CODE></A>  를 호출해, 그 노드 자체를 삭제가 끝난 상태로서 지정해, 그 부모의 아이 캐쉬로부터 삭제합니다. 마지막으로, 노드 변경 청취자가 있는 경우는, 이벤트발송쓰레드에 건네주기 위해서(때문에) 통지 이벤트를 큐에 넣습니다.

 <p>헬퍼 메소드가 불려 갈 때는, 「삭제되어 있지 않은 것도 와도 가까운 상위 노드」까지의 모든 상위 노드가 항상 락 됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#removeNode()">removeNode</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 벌써 삭제되고 있는 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 메소드가 루트 노드상에서 불려 갔을 경우
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 배킹 스토어에서 장해가 발생했는지 스토어와의 통신을 실시할 수 없기 위해(때문에), 이 오퍼레이션을 완료할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#flush()"><CODE>Preferences.flush()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="name()"><!-- --></A> <H3>
name</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>name</B>()</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#name()"><CODE>Preferences.name()</CODE></A>  의 스펙에 따라,<tt>name</tt> 메소드를 구현합니다.

 <p>이 구현은, 노드의 생성자 에게 건네진 이름만을 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#name()">name</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 설정 노드의 이름 (그 부모를 기점으로 한 상대명)</DL>
</DD>
</DL>
<HR>

<A NAME="absolutePath()"><!-- --></A> <H3>
absolutePath</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>absolutePath</B>()</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#absolutePath()"><CODE>Preferences.absolutePath()</CODE></A>  의 스펙에 따라,<tt>absolutePath</tt> 메소드를 구현합니다.

 <p>이 구현은, 이 노드가 구축되었을 때에 산출된 절대 경로명만을 돌려줍니다 (이 노드의 생성자 에게 건네진 이름과 이 노드의 상위 노드의 생성자 에게 건네진 이름에 근거해 산출된다).
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#absolutePath()">absolutePath</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 설정 노드의 절대 경로명</DL>
</DD>
</DL>
<HR>

<A NAME="isUserNode()"><!-- --></A> <H3>
isUserNode</H3>
<PRE>
public boolean <B>isUserNode</B>()</PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#isUserNode()"><CODE>Preferences.isUserNode()</CODE></A>  의 스펙에 따라,<tt>isUserNode</tt> 메소드를 구현합니다.

 <p>이 구현은, 이 노드의 루트 노드 (private 필드에 포함되고 있다)와 <A HREF="../../../java/util/prefs/Preferences.html#userRoot()"><CODE>Preferences.userRoot()</CODE></A>  로부터 반환된 값을 비교합니다. 2 개의 객체 참조가 일치하는 경우는, true 를 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#isUserNode()">isUserNode</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 설정 노드가 사용자 설정 트리에 있는 경우는 <tt>true</tt>, 시스템 설정 트리에 있는 경우는 <tt>false</tt></DL>
</DD>
</DL>
<HR>

<A NAME="addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)"><!-- --></A> <H3>
addPreferenceChangeListener</H3>
<PRE>
public void <B>addPreferenceChangeListener</B>(<A HREF="../../../java/util/prefs/PreferenceChangeListener.html" title="java.util.prefs 안의 인터페이스">PreferenceChangeListener</A> &nbsp;pcl)</PRE>
<DL>
<DD><B>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html#addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)">Preferences</A> </CODE> 의 기술:</B></DD>
<DD>지정된 청취자가 이 설정 노드에 대한 「설정 변경 이벤트」를 수신하도록(듯이) 등록합니다. 설정 변경 이벤트는, 설정이 이 노드에 추가되었을 때, 설정이 이 노드로부터 삭제되었을 때, 또는 설정에 관련지을 수 있었던 값이 변경되었을 때에 생성됩니다. 설정 변경 이벤트는,<A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A>  메소드에서는 생성되지 않습니다.  이 메소드에서는, 「노드 변경 이벤트」가 생성됩니다. 설정 변경 이벤트는 <tt>clear</tt> 메소드에 의해 생성됩니다.

 <p>노드 변경 이벤트는, 등록된 청취자와 같은 JVM 내에서 변경을 했을 때에만, 생성됩니다.  다만, 일부의 구현에서는, 현재의 JVM 의 외부에서 행해진 변경에 대해서, 이벤트가 생성되는 일이 있습니다. 이벤트가 생성된 시점에서, 변경이 지속적으로 되어 있지 않은 것이 있습니다. 현재의 노드의 하위 노드로 설정이 변경되었을 때는, 이벤트는 생성되지 않습니다.  그러한 이벤트가 필요한 경우는, 그 노드를 등록할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)">addPreferenceChangeListener</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pcl</CODE> - 추가하는 설정 변경 청취자<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#removePreferenceChangeListener(java.util.prefs.PreferenceChangeListener)"><CODE>Preferences.removePreferenceChangeListener(PreferenceChangeListener)</CODE></A> , 
<A HREF="../../../java/util/prefs/Preferences.html#addNodeChangeListener(java.util.prefs.NodeChangeListener)"><CODE>Preferences.addNodeChangeListener(NodeChangeListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="removePreferenceChangeListener(java.util.prefs.PreferenceChangeListener)"><!-- --></A> <H3>
removePreferenceChangeListener</H3>
<PRE>
public void <B>removePreferenceChangeListener</B>(<A HREF="../../../java/util/prefs/PreferenceChangeListener.html" title="java.util.prefs 안의 인터페이스">PreferenceChangeListener</A> &nbsp;pcl)</PRE>
<DL>
<DD><B>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html#removePreferenceChangeListener(java.util.prefs.PreferenceChangeListener)">Preferences</A> </CODE> 의 기술:</B></DD>
<DD>지정된 설정 변경 청취자를 삭제해, 설정 변경 이벤트의 수신을 정지합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#removePreferenceChangeListener(java.util.prefs.PreferenceChangeListener)">removePreferenceChangeListener</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pcl</CODE> - 삭제하는 설정 변경 청취자<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)"><CODE>Preferences.addPreferenceChangeListener(PreferenceChangeListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="addNodeChangeListener(java.util.prefs.NodeChangeListener)"><!-- --></A> <H3>
addNodeChangeListener</H3>
<PRE>
public void <B>addNodeChangeListener</B>(<A HREF="../../../java/util/prefs/NodeChangeListener.html" title="java.util.prefs 안의 인터페이스">NodeChangeListener</A> &nbsp;ncl)</PRE>
<DL>
<DD><B>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html#addNodeChangeListener(java.util.prefs.NodeChangeListener)">Preferences</A> </CODE> 의 기술:</B></DD>
<DD>지정된 청취자가 이 노드의 「노드 변경 이벤트」를 수신하도록(듯이) 등록합니다. 노드 변경 이벤트는, 자식(child) 노드가 이 노드에 추가되었을 때, 또는 이 노드로부터 삭제되었을 때에 생성됩니다. 1 회의 <A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A>  호출에 의해, 복수의 「노드 변경 이벤트」가 생성됩니다.  즉, 삭제된 노드를 루트로 하는 서브 트리내의 각 노드에 1 개씩 생성됩니다. <i></i><i></i>

 <p>노드 변경 이벤트는, 등록된 청취자와 같은 JVM 내에서 변경을 했을 때에만, 생성됩니다.  다만, 일부의 구현에서는, 현재의 JVM 의 외부에서 행해진 변경에 대해서, 이벤트가 생성되는 일이 있습니다. 이벤트가 생성된 시점에서, 변경이 지속적으로 되어 있지 않은 것이 있습니다. 현재의 노드의 부하에 없는 하위 노드가 추가 또는 삭제되었을 때는, 이벤트는 생성되지 않습니다.  그러한 이벤트가 필요한 경우는, 그 노드를 등록할 필요가 있습니다.

 <p>작성된 노드는, 즉시 유효하게 되지 않습니다. 이러한 노드는, 액세스 되었을 때에 암묵적으로 작성됩니다.  이 때문에, 액세스 되기 전에, 자식(child) 노드가 배킹 스토어에 존재할지 어떨지를 구현이 판단할 수  없는 경우가 있습니다 (예를 들어, 배킹 스토어가 도달 불능인 경우나, 캐쉬된 정보가 최신이 아닌 경우 등). 이러한 상황에서의 노드 변경 이벤트의 생성은, 특히 정의되고 있지 않습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#addNodeChangeListener(java.util.prefs.NodeChangeListener)">addNodeChangeListener</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ncl</CODE> - 추가하는 <tt>NodeChangeListener</tt><DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#removeNodeChangeListener(java.util.prefs.NodeChangeListener)"><CODE>Preferences.removeNodeChangeListener(NodeChangeListener)</CODE></A> , 
<A HREF="../../../java/util/prefs/Preferences.html#addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)"><CODE>Preferences.addPreferenceChangeListener(PreferenceChangeListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="removeNodeChangeListener(java.util.prefs.NodeChangeListener)"><!-- --></A> <H3>
removeNodeChangeListener</H3>
<PRE>
public void <B>removeNodeChangeListener</B>(<A HREF="../../../java/util/prefs/NodeChangeListener.html" title="java.util.prefs 안의 인터페이스">NodeChangeListener</A> &nbsp;ncl)</PRE>
<DL>
<DD><B>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html#removeNodeChangeListener(java.util.prefs.NodeChangeListener)">Preferences</A> </CODE> 의 기술:</B></DD>
<DD>지정된 <tt>NodeChangeListener</tt> 를 삭제해, 이벤트의 수신을 정지합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#removeNodeChangeListener(java.util.prefs.NodeChangeListener)">removeNodeChangeListener</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ncl</CODE> - 삭제하는 <tt>NodeChangeListener</tt><DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#addNodeChangeListener(java.util.prefs.NodeChangeListener)"><CODE>Preferences.addNodeChangeListener(NodeChangeListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="putSpi(java.lang.String, java.lang.String)"><!-- --></A> <H3>
putSpi</H3>
<PRE>
protected abstract void <B>putSpi</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key,
                               <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;value)</PRE>
<DL>
<DD>지정된 키와 값의 페어를 이 설정 노드에 관련짓습니다. <tt>key</tt> 와 <tt>value</tt> 가 null 이외로, 정당한 길이인 것이 보증되고 있습니다. 또, 이 노드가 삭제되어 있지 않은 것도 보증되고 있습니다. 구현할 경우에, 이러한 것을 확인할 필요는 없습니다.

 <p>이 메소드가 불려 갈 때는, 이 노드가 락 됩니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSpi(java.lang.String)"><!-- --></A> <H3>
getSpi</H3>
<PRE>
protected abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getSpi</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key)</PRE>
<DL>
<DD>이 설정 노드의 지정된 키에 관련지을 수 있었던 값을 돌려줍니다.  이 키에 관련짓고가 없는 경우, 또는 돌려줄 때 관련짓고를 판단할 수  없는 경우는,<tt>null</tt> 를 돌려줍니다. <tt>key</tt> 가 null 이외인 것이 보증되고 있습니다.  또, 이 노드가 삭제되어 있지 않은 것도 보증되고 있습니다. 또, 이 노드가 삭제되어 있지 않은 것도 보증되고 있습니다. 이 메소드가 불려 갈 때는, 이 노드가 락 됩니다.  

 <p> 이 메소드는, 대부분의 상황으로 예외를 throw 하지 않습니다. 예외를 throw 했을 경우에서도, 그 예외는 포획 되어<tt>null</tt> 반환값으로서 다루어집니다.

 <p>이 메소드가 불려 갈 때는, 이 노드가 락 됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 설정 노드의 지정된 키에 관련지을 수 있었던 값. 이 키에 관련짓고가 없는 경우, 또는 돌려줄 때 관련짓고를 판단할 수  없는 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="removeSpi(java.lang.String)"><!-- --></A> <H3>
removeSpi</H3>
<PRE>
protected abstract void <B>removeSpi</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;key)</PRE>
<DL>
<DD>이 설정 노드의 지정된 키에 관련짓고가 있는 경우는, 그것을 삭제합니다. <tt>key</tt> 가 null 이외인 것이 보증되고 있습니다.  또, 이 노드가 삭제되어 있지 않은 것도 보증되고 있습니다. 또, 이 노드가 삭제되어 있지 않은 것도 보증되고 있습니다. 이 메소드가 불려 갈 때는, 이 노드가 락 됩니다.

 <p>이 메소드가 불려 갈 때는, 이 노드가 락 됩니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeNodeSpi()"><!-- --></A> <H3>
removeNodeSpi</H3>
<PRE>
protected abstract void <B>removeNodeSpi</B>()
                               throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD>이 호출을 실시하면, 이름 첨부의 아이의 하위 노드가 모두 삭제됩니다. 즉,<A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A>  메소드는, 노드의 최하정도 노드로부터 상위 노드 방향으로 이 메소드를 반복해 호출해, 하위 노드를 모두 삭제하고 나서, 노드 자체를 삭제합니다.

 <p>이 메소드가 불려 갈 때는, 이 노드와 그 친 ( 및 1 회의 <A HREF="../../../java/util/prefs/Preferences.html#removeNode()"><CODE>Preferences.removeNode()</CODE></A> ) 호출에 의해 삭제되는 모든 상위 노드)가 락 됩니다.

 <p>노드의 삭제는, 이 노드 (또는 상위 노드) 상에서 <tt>flush</tt> 메소드가 불려 갈 때까지, 지속적이 될 필요는 없습니다.

 <p>이 노드가 throw 한 <tt>BackingStoreException</tt> 예외는, 내포 하고 있는 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  의 호출을 넘어 보내집니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 배킹 스토어에서 장해가 발생했는지 스토어와의 통신을 실시할 수 없기 위해(때문에), 이 오퍼레이션을 완료할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="keysSpi()"><!-- --></A> <H3>
keysSpi</H3>
<PRE>
protected abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>keysSpi</B>()
                             throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD>이 설정 노드내에 관련지을 수 있었던 값을 가지는 키를 모두 돌려줍니다. 이 노드로 설정이 없는 경우, 반환되는 배열의 사이즈는 제로가 됩니다. 이 노드가 삭제되어 있지 않은 것이 보증되고 있습니다.

 <p>이 메소드가 불려 갈 때는, 이 노드가 락 됩니다.

 <p>이 노드가 throw 한 <tt>BackingStoreException</tt> 예외는, 내포 하고 있는 <A HREF="../../../java/util/prefs/AbstractPreferences.html#keys()"><CODE>keys()</CODE></A>  의 호출을 넘어 보내집니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 설정 노드내에 관련지을 수 있었던 값을 가지는 키의 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 배킹 스토어에서 장해가 발생했는지 스토어와의 통신을 실시할 수 없기 위해(때문에), 이 오퍼레이션을 완료할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="childrenNamesSpi()"><!-- --></A> <H3>
childrenNamesSpi</H3>
<PRE>
protected abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>childrenNamesSpi</B>()
                                      throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD>이 설정 노드의 아이의 이름을 돌려줍니다. 이 노드에 아이가 없는 경우, 반환되는 배열의 사이즈는 제로가 됩니다. 이 메소드에서는, 캐쉬 끝난 노드의 이름을 돌려줄 필요는 없습니다만, 돌려주어도 괜찮습니다.

 <p>이 메소드가 불려 갈 때는, 이 노드가 락 됩니다.

 <p>이 노드가 throw 한 <tt>BackingStoreException</tt> 예외는, 내포 하고 있는 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNames()"><CODE>childrenNames()</CODE></A>  의 호출을 넘어 보내집니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>설정 노드의 아이의 이름이 포함되어 있는 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 배킹 스토어에서 장해가 발생했는지 스토어와의 통신을 실시할 수 없기 위해(때문에), 이 오퍼레이션을 완료할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getChild(java.lang.String)"><!-- --></A> <H3>
getChild</H3>
<PRE>
protected <A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 내의 클래스">AbstractPreferences</A>  <B>getChild</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;nodeName)
                                throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD>이름 첨부의 아이가 존재하는 경우는 그것을 돌려주어, 존재하지 않는 경우는 <tt>null</tt> 를 돌려줍니다. <tt>nodeName</tt> 가 null 및 빈 상태(empty)이 아니고, slash 문자 ('/')를 포함하지 않고,<A HREF="../../../java/util/prefs/Preferences.html#MAX_NAME_LENGTH"><CODE>Preferences.MAX_NAME_LENGTH</CODE></A>  문자 이하인 것이 보증되고 있습니다. 또, 이 노드가 삭제되어 있지 않은 것도 보증되고 있습니다. 이 메소드를 오버라이드(override) 할 경우에, 이러한 것을 확인할 필요는 없습니다.

 <p>또, 이름 첨부 노드가 마지막에 삭제된 후에, 이 메소드 또는 <A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(java.lang.String)</CODE></A>  가 전회 불려 갔을 때에, 그 노드가 돌려주어지지 않은 것도 보증되고 있습니다. 즉, 이 메소드가 불려 가기 전에, 캐쉬된 값이 항상 우선해 사용됩니다. 이 메소드를 오버라이드(override) 하는 경우, 이전에 반환된 아이의 캐쉬를 보관 유지할 필요는 없습니다.

 <p>이 구현은, 이 설정 노드의 락을 취득해,<A HREF="../../../java/util/prefs/AbstractPreferences.html#childrenNames()"><CODE>childrenNames()</CODE></A>  를 호출해 아이의 이름의 배열을 취득해, 배열내의 자식(child) 노드의 이름과 지정된 노드명을 반복해 비교합니다. 자식(child) 노드의 이름이 올바른 경우는,<A HREF="../../../java/util/prefs/AbstractPreferences.html#childSpi(java.lang.String)"><CODE>childSpi(String)</CODE></A>  메소드를 호출해, 그 노드를 돌려줍니다. 모든 자식(child) 노드를 비교해도 지정된 이름이 발견되지 않았던 경우는,<tt>null</tt> 가 돌려주어집니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>nodeName</CODE> - 검색 대상이 되는 아이의 이름
<DT><B>반환값:</B><DD>존재하는 경우는 이름 첨부의 아이. 존재하지 않는 경우는 null
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 배킹 스토어에서 장해가 발생했는지 스토어와의 통신을 실시할 수 없기 위해(때문에), 이 오퍼레이션을 완료할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="childSpi(java.lang.String)"><!-- --></A> <H3>
childSpi</H3>
<PRE>
protected abstract <A HREF="../../../java/util/prefs/AbstractPreferences.html" title="java.util.prefs 내의 클래스">AbstractPreferences</A>  <B>childSpi</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>이 설정 노드의 이름 첨부의 아이를 돌려줍니다.  존재하지 않는 경우는 작성합니다. <tt>name</tt> 가 null 및 빈 상태(empty)이 아니고, slash 문자 ('/')를 포함하지 않고,<A HREF="../../../java/util/prefs/Preferences.html#MAX_NAME_LENGTH"><CODE>Preferences.MAX_NAME_LENGTH</CODE></A>  문자 이하인 것이 보증되고 있습니다. 또, 이 노드가 삭제되어 있지 않은 것도 보증되고 있습니다. 구현할 경우에, 이러한 것을 확인할 필요는 없습니다.

 <p>또, 이름 첨부 노드가 마지막에 삭제된 후에, 이 메소드 또는 <A HREF="../../../java/util/prefs/AbstractPreferences.html#getChild(java.lang.String)"><CODE>getChild(String)</CODE></A>  가 전회 불려 갔을 때에, 그 노드가 돌려주어지지 않은 것도 보증되고 있습니다. 즉, 이 메소드가 불려 가기 전에, 캐쉬된 값이 항상 우선해 사용됩니다. 서브 클래스는, 이전에 반환된 아이의 캐쉬를 보관 유지할 필요는 없습니다.

 <p>구현할 때는, 반환된 노드가 삭제되어 있지 않은 것을 확인할 필요가 있습니다. 이 노드로부터 같은 이름인 아이가 삭제되고 있는 경우는,<tt>AbstractPreferences</tt> 노드를 새롭게 구축해, 그것을 돌려줄 필요가 있습니다. 한 번 삭제한 <tt>AbstractPreferences</tt> 노드는, 복구할 수 없습니다.
 
 <p>이 메소드에 의해 작성된 노드는, 이 노드 또는 게다가 위노드 (또는 하위 노드)로 <tt>flush</tt> 메소드가 불려 갔을 때에, 지속적이 됩니다.

 <p>이 메소드가 불려 갈 때는, 이 노드가 락 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 돌려주는 자식(child) 노드의 이름 (이 설정 노드를 기점으로서 상대명)
<DT><B>반환값:</B><DD>이름 첨부의 자식(child) 노드</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 설정 노드의 절대 경로명을 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 객체의 캐릭터 라인 표현</DL>
</DD>
</DL>
<HR>

<A NAME="sync()"><!-- --></A> <H3>
sync</H3>
<PRE>
public void <B>sync</B>()
          throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#sync()"><CODE>Preferences.sync()</CODE></A>  의 스펙에 따라,<tt>sync</tt> 메소드를 구현합니다.

 <p>재귀적 헬퍼 메소드는, 이 노드를 잠그어, 이 노드상에서 syncSpi()를 호출합니다.  다음에, 이 노드의 락을 해제해, 「캐쉬된 아이」마다 재귀적으로 이 메소드를 호출합니다. 캐쉬된 아이란, 이 VM 내에서 작성되어 그 후 삭제되어 있지 않은 이 노드의 아이입니다. 즉, 이 메소드는, 이 노드를 루트로 하는 「캐쉬된 서브 트리」의 깊이 우선 횡단(traverse)을 실행해, 서브 트리내의 노드 마다 syncSpi()를 호출합니다.  이 때, 조작하고 있는 노드만이 락 됩니다. syncSpi()는 상위 노드로부터 하위 방향으로 불려 갑니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#sync()">sync</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 배킹 스토어에서 장해가 발생했는지 스토어와의 통신을 실시할 수 없기 위해(때문에), 이 오퍼레이션을 완료할 수 없는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/AbstractPreferences.html#flush()"><CODE>flush()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="syncSpi()"><!-- --></A> <H3>
syncSpi</H3>
<PRE>
protected abstract void <B>syncSpi</B>()
                         throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD>이 메소드가 불려 갈 때는, 이 노드가 락 됩니다. 이 메소드의 규약에서는, 이 노드에 포함되고 있는 캐쉬된 설정이, 배킹 스토어에 포함되고 있는 설정과 동기 됩니다. 이 때, 이 노드가 다른 VM 에 의해 삭제되거나 아직 작성되어 있지 않기 위해(때문에), 배킹 스토어에 존재하지 않을 가능성이 있습니다. 이 메소드에서는, 이 노드의 서브 노드의 설정은 동기 되지 않습니다. 배킹 스토어에 포함되고 있는 서브 트리 전체를 한 번에 동기 시키는 경우는, 이 메소드를 오버라이드(override) 하는 것 만이  아니고, sync()도 오버라이드(override) 하는 것을 추천합니다.

 <p>이 노드가 throw 한 <tt>BackingStoreException</tt> 예외는, 내포 하고 있는 <A HREF="../../../java/util/prefs/AbstractPreferences.html#sync()"><CODE>sync()</CODE></A>  의 호출을 넘어 보내집니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 배킹 스토어에서 장해가 발생했는지 스토어와의 통신을 실시할 수 없기 위해(때문에), 이 오퍼레이션을 완료할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="flush()"><!-- --></A> <H3>
flush</H3>
<PRE>
public void <B>flush</B>()
           throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#flush()"><CODE>Preferences.flush()</CODE></A>  의 스펙에 따라,<tt>flush</tt> 메소드를 구현합니다.

 <p>재귀적 헬퍼 메소드는, 이 노드를 잠그어, 이 노드상에서 flushSpi()를 호출합니다. 캐쉬된 아이란, 이 VM 내에서 작성되어 그 후 삭제되어 있지 않은 이 노드의 아이입니다. 즉, 이 메소드는, 이 노드를 루트로 하는 「캐쉬된 서브 트리」의 깊이 우선 횡단(traverse)을 실행해, 서브 트리내의 노드 마다 flushSpi()를 호출합니다.  이 때, 조작하고 있는 노드만이 락 됩니다. flushSpi()는 상위 노드로부터 하위 방향으로 불려 갑니다.

 <p> 이 메소드를,<A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드를 사용해 삭제된 노드상에서 호출하면(자), flushSpi()가 이 노드상에서 불려 갑니다만, 다른 노드에서는 불려 가지 않습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#flush()">flush</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 배킹 스토어에서 장해가 발생했는지 스토어와의 통신을 실시할 수 없기 위해(때문에), 이 오퍼레이션을 완료할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/AbstractPreferences.html#flush()"><CODE>flush()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="flushSpi()"><!-- --></A> <H3>
flushSpi</H3>
<PRE>
protected abstract void <B>flushSpi</B>()
                          throws <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD>이 메소드가 불려 갈 때는, 이 노드가 락 됩니다. 이 메소드의 규약에서는, 캐쉬된 변경을 이 설정 노드의 내용에 강제적으로 적용하고 나서, 그것들을 배킹 스토어에 플래시 해, 그러한 지속성을 보증합니다. 이 때, 이 노드가 다른 VM 에 의해 삭제되거나 아직 작성되어 있지 않기 위해(때문에), 배킹 스토어에 존재하지 않을 가능성이 있습니다. 이 메소드에서는, 이 노드의 서브 노드의 설정은 플래시 되지 않습니다. 배킹 스토어에 포함되고 있는 서브 트리 전체를 한 번에 플래시 하는 경우는, 이 메소드를 오버라이드(override) 하는 것 만이  아니고, flush()도 오버라이드(override) 하는 것을 추천합니다.

 <p>이 노드가 throw 한 <tt>BackingStoreException</tt> 예외는, 내포 하고 있는 <A HREF="../../../java/util/prefs/AbstractPreferences.html#flush()"><CODE>flush()</CODE></A>  의 호출을 넘어 보내집니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 배킹 스토어에서 장해가 발생했는지 스토어와의 통신을 실시할 수 없기 위해(때문에), 이 오퍼레이션을 완료할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="isRemoved()"><!-- --></A> <H3>
isRemoved</H3>
<PRE>
protected boolean <B>isRemoved</B>()</PRE>
<DL>
<DD>이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우에,<tt>true</tt> 를 돌려줍니다. 이 메소드는, 이 노드를 잠그고 나서, 이 상태의 추적에 사용된 private 필드의 내용을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 노드 (또는 상위 노드)가 <A HREF="../../../java/util/prefs/AbstractPreferences.html#removeNode()"><CODE>removeNode()</CODE></A>  메소드에 의해 삭제되었을 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="exportNode(java.io.OutputStream)"><!-- --></A> <H3>
exportNode</H3>
<PRE>
public void <B>exportNode</B>(<A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;os)
                throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                       <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#exportNode(java.io.OutputStream)"><CODE>Preferences.exportNode(OutputStream)</CODE></A>  의 스펙에 따라,<tt>exportNode</tt> 메소드를 구현합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#exportNode(java.io.OutputStream)">exportNode</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>os</CODE> - XML 문서의 발행처의 출력 스트림
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 지정된 출력 스트림에의 기입해 때에 <tt>IOException</tt> 가 발생했을 경우
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 설정 데이터가 배킹 스토어로부터 읽어낼 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#importPreferences(java.io.InputStream)"><CODE>Preferences.importPreferences(InputStream)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="exportSubtree(java.io.OutputStream)"><!-- --></A> <H3>
exportSubtree</H3>
<PRE>
public void <B>exportSubtree</B>(<A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;os)
                   throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                          <A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </PRE>
<DL>
<DD><A HREF="../../../java/util/prefs/Preferences.html#exportSubtree(java.io.OutputStream)"><CODE>Preferences.exportSubtree(OutputStream)</CODE></A>  의 스펙에 따라,<tt>exportSubtree</tt> 메소드를 구현합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/util/prefs/Preferences.html" title="java.util.prefs 내의 클래스">Preferences</A> </CODE> 내의 <CODE><A HREF="../../../java/util/prefs/Preferences.html#exportSubtree(java.io.OutputStream)">exportSubtree</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>os</CODE> - XML 문서의 발행처의 출력 스트림
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 지정된 출력 스트림에의 기입해 때에 <tt>IOException</tt> 가 발생했을 경우
<DD><CODE><A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 안의 클래스">BackingStoreException</A> </CODE> - 설정 데이터가 배킹 스토어로부터 읽어낼 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/prefs/Preferences.html#importPreferences(java.io.InputStream)"><CODE>Preferences.importPreferences(InputStream)</CODE></A> , 
<A HREF="../../../java/util/prefs/Preferences.html#exportNode(java.io.OutputStream)"><CODE>Preferences.exportNode(OutputStream)</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractPreferences.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;전의 클래스 &nbsp;
&nbsp;<A HREF="../../../java/util/prefs/BackingStoreException.html" title="java.util.prefs 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/prefs/AbstractPreferences.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="AbstractPreferences.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
