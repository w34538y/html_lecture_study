<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:59:34 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Collections (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Collections (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Collections.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/util/Collection.html" title="java.util 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/util/Comparator.html" title="java.util 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/util/Collections.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Collections.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util</FONT>
<BR>
클래스 Collections</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.Collections</B>
</PRE>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>Collections</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
이 클래스는, 컬렉션에 작용한다, 또는 컬렉션을 돌려주는 static 메소드만으로 구성됩니다. 이 클래스에는, 지정된 컬렉션에 연동한 새로운 컬렉션을 돌려주는 「래퍼」 등, 컬렉션에 대해서 작용하는 다양한 알고리즘이 있습니다.

 <p>이 클래스의 메소드에 제공되는 컬렉션 또는 클래스 객체가 null 의 경우, 이 클래스의 메소드는 <tt>NullPointerException</tt> 를 모두 throw 합니다.

 <p>이 클래스에 있는 다양한 알고리즘의 문서에는, 일반적으로, 「구현」의 간단한 설명이 포함되어 있습니다. 이 설명은, 「스펙」의 일부에서는 없고 「구현 정보」라고 생각해 주세요. 구현자는, 스펙에 반하지 않는 한, 다른 알고리즘을 자유롭게 사용할 수 있습니다. 예를 들어,<tt>sort</tt> 가 사용하는 알고리즘은 머지 소트일 필요는 없습니다만, 「고정 (stable)」의 알고리즘이 아니면 안됩니다.

 <p>컬렉션이 <tt>set</tt> 메소드와 같이 적절한 변이 원시형 메소드를 지원하고 있지 않는 경우, 이 클래스 (처리되는 컬렉션을 수정하는 알고리즘)에 포함되어 있던 「파괴적」알고리즘은,<tt>UnsupportedOperationException</tt> 를 throw 하도록(듯이) 지정되고 있습니다. 호출이 컬렉션에 영향을 주지 않는 경우, 이러한 알고리즘은 예외를 throw 하는 경우가 있습니다만, 필수가 아닙니다. 예를 들어, 소트 끝난 변경 불가능한 리스트로,<tt>sort</tt> 메소드를 호출하면(자),<tt>UnsupportedOperationException</tt> 가 throw 되는 경우와 throw 되지 않는 경우가 있습니다.

 <p>이 클래스는,<a href="../../../technotes/guides/collections/index.html">Java Collections Framework</a>  의 멤버입니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Collection.html" title="java.util 내의 인터페이스"><CODE>Collection</CODE></A> , 
<A HREF="../../java/util/Set.html" title="java.util 안의 인터페이스"><CODE>Set</CODE></A> , 
<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스"><CODE>List</CODE></A> , 
<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스"><CODE>Map</CODE></A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#EMPTY_LIST">EMPTY_LIST</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;빈 상태(empty)의 리스트입니다 (불변). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#EMPTY_MAP">EMPTY_MAP</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;빈 상태(empty)의 맵입니다 (불변). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#EMPTY_SET">EMPTY_SET</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;빈 상태(empty)세트입니다 (불변). </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; boolean</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#addAll(java.util.Collection, T...)">addAll</A> </B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;?  super T&gt;&nbsp;c,
       T...&nbsp;elements)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 모든 요소가 지정된 컬렉션에 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/Queue.html" title="java.util 내의 인터페이스">Queue</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#asLifoQueue(java.util.Deque)">asLifoQueue</A> </B>(<A HREF="../../java/util/Deque.html" title="java.util 안의 인터페이스">Deque</A> &lt;T&gt;&nbsp;deque)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../java/util/Deque.html" title="java.util 내의 인터페이스"><CODE>Deque</CODE></A>  의 뷰를 후입선출 (Lifo) <A HREF="../../java/util/Queue.html" title="java.util 내의 인터페이스"><CODE>Queue</CODE></A>  로서 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#binarySearch(java.util.List, T)">binarySearch</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;?  extends <A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스">Comparable</A> &lt;?  super T&gt;&gt;&nbsp;list,
             T&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 리스트로부터 지정된 객체를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#binarySearch(java.util.List, T, java.util.Comparator)">binarySearch</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;?  extends T&gt;&nbsp;list,
             T&nbsp;key,
             <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 리스트로부터 지정된 객체를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;E&gt; <A HREF="../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;E&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#checkedCollection(java.util.Collection, java.lang.Class)">checkedCollection</A> </B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;E&gt;&nbsp;c,
                  <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;E&gt;&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 컬렉션의, 동적으로 형태 보증된 뷰를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;E&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;E&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#checkedList(java.util.List, java.lang.Class)">checkedList</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;E&gt;&nbsp;list,
            <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;E&gt;&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 리스트의 동적으로 형태 보증된 뷰를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K, V&gt; <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;K, V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#checkedMap(java.util.Map, java.lang.Class, java.lang.Class)">checkedMap</A> </B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;K, V&gt;&nbsp;m,
           <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;K&gt;&nbsp;keyType,
           <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;V&gt;&nbsp;valueType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 맵의 동적으로 형태 보증된 뷰를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;E&gt; <A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A> &lt;E&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#checkedSet(java.util.Set, java.lang.Class)">checkedSet</A> </B>(<A HREF="../../java/util/Set.html" title="java.util 안의 인터페이스">Set</A> &lt;E&gt;&nbsp;s,
           <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;E&gt;&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 세트의 동적으로 형태 보증된 뷰를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K, V&gt; <A HREF="../../java/util/SortedMap.html" title="java.util 내의 인터페이스">SortedMap</A> &lt;K, V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#checkedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)">checkedSortedMap</A> </B>(<A HREF="../../java/util/SortedMap.html" title="java.util 안의 인터페이스">SortedMap</A> &lt;K, V&gt;&nbsp;m,
                 <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;K&gt;&nbsp;keyType,
                 <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;V&gt;&nbsp;valueType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 소트 맵의 동적으로 형태 보증된 뷰를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;E&gt; <A HREF="../../java/util/SortedSet.html" title="java.util 내의 인터페이스">SortedSet</A> &lt;E&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#checkedSortedSet(java.util.SortedSet, java.lang.Class)">checkedSortedSet</A> </B>(<A HREF="../../java/util/SortedSet.html" title="java.util 안의 인터페이스">SortedSet</A> &lt;E&gt;&nbsp;s,
                 <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;E&gt;&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 소트 세트의 동적으로 형태 보증된 뷰를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#copy(java.util.List, java.util.List)">copy</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;?  super T&gt;&nbsp;dest,
     <A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;?  extends T&gt;&nbsp;src)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;있는 리스트로부터 다른 리스트에 모든 요소를 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#disjoint(java.util.Collection, java.util.Collection)">disjoint</A> </B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;? &gt;&nbsp;c1,
         <A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;? &gt;&nbsp;c2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 컬렉션에 공통의 요소가 존재하지 않는 경우,<tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#emptyList()">emptyList</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;빈 상태(empty)의 리스트를 돌려줍니다 (불변). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K, V&gt; <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;K, V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#emptyMap()">emptyMap</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;빈 상태(empty)의 맵을 돌려줍니다 (불변). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#emptySet()">emptySet</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;빈 상태(empty)세트 (불변)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/Enumeration.html" title="java.util 내의 인터페이스">Enumeration</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#enumeration(java.util.Collection)">enumeration</A> </B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 컬렉션의 열거를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#fill(java.util.List, T)">fill</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;?  super T&gt;&nbsp;list,
     T&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 리스트의 모든 요소가 지정된 요소로 옮겨놓습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#frequency(java.util.Collection, java.lang.Object)">frequency</A> </B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;? &gt;&nbsp;c,
          <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 컬렉션내에서, 지정된 객체와 등가인 요소의 수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#indexOfSubList(java.util.List, java.util.List)">indexOfSubList</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;source,
               <A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 소스 리스트내에서, 지정된 타겟 리스트가 최초로 출현한 위치의 개시 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#lastIndexOfSubList(java.util.List, java.util.List)">lastIndexOfSubList</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;source,
                   <A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 소스 리스트내에서, 마지막에 출현한 지정 타겟 리스트의 개시 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/ArrayList.html" title="java.util 내의 클래스">ArrayList</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#list(java.util.Enumeration)">list</A> </B>(<A HREF="../../java/util/Enumeration.html" title="java.util 안의 인터페이스">Enumeration</A> &lt;T&gt;&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 열거에 의해 반환된 요소를 포함한 배열 리스트를, 반환된 차례로 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  & <A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스">Comparable</A> &lt;?  super T&gt;&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#max(java.util.Collection)">max</A> </B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;?  extends T&gt;&nbsp;coll)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요소의 「자연 순서 붙이고」에 따라, 지정된 컬렉션의 최대의 요소를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#max(java.util.Collection, java.util.Comparator)">max</A> </B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;?  extends T&gt;&nbsp;coll,
    <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Comparator가 가리키는 순서에 따라, 지정된 컬렉션의 최대의 요소를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  & <A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스">Comparable</A> &lt;?  super T&gt;&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#min(java.util.Collection)">min</A> </B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;?  extends T&gt;&nbsp;coll)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요소의 「자연 순서 붙이고」에 따라, 지정된 컬렉션의 최소의 요소를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#min(java.util.Collection, java.util.Comparator)">min</A> </B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;?  extends T&gt;&nbsp;coll,
    <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Comparator가 가리키는 순서에 따라, 지정된 컬렉션의 최소의 요소를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#nCopies(int, T)">nCopies</A> </B>(int&nbsp;n,
        T&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 객체의 <tt>n</tt> 개의 카피로 구성되는 불변의 리스트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;E&gt; <A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A> &lt;E&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#newSetFromMap(java.util.Map)">newSetFromMap</A> </B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;E,<A HREF="../../java/lang/Boolean.html" title="java.lang 안의 클래스">Boolean</A> &gt;&nbsp;map)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 맵에 연동하는 세트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; boolean</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#replaceAll(java.util.List, T, T)">replaceAll</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;T&gt;&nbsp;list,
           T&nbsp;oldVal,
           T&nbsp;newVal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;리스트내에 출현하는 지정된 값을 모두 다른 값에 옮겨놓습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#reverse(java.util.List)">reverse</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;list)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 리스트의 요소의 순서를 반대로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/Comparator.html" title="java.util 내의 인터페이스">Comparator</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#reverseOrder()">reverseOrder</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>Comparable</tt> 인터페이스를 구현하는 객체의 컬렉션으로 「자연 순서 붙이고」의 역을 의무화 하는 Comparator를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/Comparator.html" title="java.util 내의 인터페이스">Comparator</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#reverseOrder(java.util.Comparator)">reverseOrder</A> </B>(<A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;T&gt;&nbsp;cmp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Comparator의 역순서를 의무화 하는 Comparator를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#rotate(java.util.List, int)">rotate</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;list,
       int&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 리스트의 요소를, 지정된 거리에 의해 회전합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#shuffle(java.util.List)">shuffle</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;list)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트의 random number generation의 원을 사용해, 지정된 리스트의 순서를 무작위로 바꿔 넣습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#shuffle(java.util.List, java.util.Random)">shuffle</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;list,
        <A HREF="../../java/util/Random.html" title="java.util 안의 클래스">Random</A> &nbsp;rnd)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트의 random number generation의 원을 사용해, 지정된 리스트의 순서를 무작위로 바꿔 넣습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#singleton(T)">singleton</A> </B>(T&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 객체만을 포함하고 있는 불변세트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#singletonList(T)">singletonList</A> </B>(T&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 객체만을 포함하고 있는 불변의 리스트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K, V&gt; <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;K, V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#singletonMap(K, V)">singletonMap</A> </B>(K&nbsp;key,
             V&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 값으로 지정된 키만을 매핑 하는 불변의 맵을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스">Comparable</A> &lt;?  super T&gt;&gt; 
<BR>
void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#sort(java.util.List)">sort</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;T&gt;&nbsp;list)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요소의 「자연 순서 붙이고」에 따라, 지정된 리스트를 승순에 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#sort(java.util.List, java.util.Comparator)">sort</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;T&gt;&nbsp;list,
     <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Comparator가 가리키는 순서에 따라, 지정된 리스트를 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#swap(java.util.List, int, int)">swap</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;list,
     int&nbsp;i,
     int&nbsp;j)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 리스트의 지정된 위치에 있는 요소를 스왑 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#synchronizedCollection(java.util.Collection)">synchronizedCollection</A> </B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 컬렉션에 연동하는 동기 (thread 세이프인) 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#synchronizedList(java.util.List)">synchronizedList</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;T&gt;&nbsp;list)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 리스트에 연동하는 동기 (thread 세이프인) 리스트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K, V&gt; <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;K, V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#synchronizedMap(java.util.Map)">synchronizedMap</A> </B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;K, V&gt;&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 맵에 연동하는 동기 (thread 세이프인) 맵을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#synchronizedSet(java.util.Set)">synchronizedSet</A> </B>(<A HREF="../../java/util/Set.html" title="java.util 안의 인터페이스">Set</A> &lt;T&gt;&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 세트에 연동하는 동기 (thread 세이프인) 세트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K, V&gt; <A HREF="../../java/util/SortedMap.html" title="java.util 내의 인터페이스">SortedMap</A> &lt;K, V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#synchronizedSortedMap(java.util.SortedMap)">synchronizedSortedMap</A> </B>(<A HREF="../../java/util/SortedMap.html" title="java.util 안의 인터페이스">SortedMap</A> &lt;K, V&gt;&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 소트 맵에 연동하는 동기 (thread 세이프인) 소트 맵을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/SortedSet.html" title="java.util 내의 인터페이스">SortedSet</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#synchronizedSortedSet(java.util.SortedSet)">synchronizedSortedSet</A> </B>(<A HREF="../../java/util/SortedSet.html" title="java.util 안의 인터페이스">SortedSet</A> &lt;T&gt;&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 소트 세트에 연동하는 동기 (thread 세이프인) 소트 세트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#unmodifiableCollection(java.util.Collection)">unmodifiableCollection</A> </B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;?  extends T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 컬렉션의 변경 불가능한 뷰를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#unmodifiableList(java.util.List)">unmodifiableList</A> </B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;?  extends T&gt;&nbsp;list)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 리스트의 변경 불가능한 뷰를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K, V&gt; <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;K, V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#unmodifiableMap(java.util.Map)">unmodifiableMap</A> </B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?  extends K,?  extends V&gt;&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 맵의 변경 불가능한 뷰를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#unmodifiableSet(java.util.Set)">unmodifiableSet</A> </B>(<A HREF="../../java/util/Set.html" title="java.util 안의 인터페이스">Set</A> &lt;?  extends T&gt;&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 세트의 변경 불가능한 뷰를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;K, V&gt; <A HREF="../../java/util/SortedMap.html" title="java.util 내의 인터페이스">SortedMap</A> &lt;K, V&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#unmodifiableSortedMap(java.util.SortedMap)">unmodifiableSortedMap</A> </B>(<A HREF="../../java/util/SortedMap.html" title="java.util 안의 인터페이스">SortedMap</A> &lt;K,?  extends V&gt;&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 소트 맵의 변경 불가능한 뷰를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/SortedSet.html" title="java.util 내의 인터페이스">SortedSet</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Collections.html#unmodifiableSortedSet(java.util.SortedSet)">unmodifiableSortedSet</A> </B>(<A HREF="../../java/util/SortedSet.html" title="java.util 안의 인터페이스">SortedSet</A> &lt;T&gt;&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 소트 세트의 변경 불가능한 뷰를 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="EMPTY_SET"><!-- --></A> <H3>
EMPTY_SET</H3>
<PRE>
public static final <A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A>  <B>EMPTY_SET</B></PRE>
<DL>
<DD>빈 상태(empty)세트입니다 (불변). 이 세트는 직렬화가 가능합니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Collections.html#emptySet()"><CODE>emptySet()</CODE></A> </DL>
</DL>
<HR>

<A NAME="EMPTY_LIST"><!-- --></A> <H3>
EMPTY_LIST</H3>
<PRE>
public static final <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A>  <B>EMPTY_LIST</B></PRE>
<DL>
<DD>빈 상태(empty)의 리스트입니다 (불변). 이 리스트는 직렬화 가능합니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Collections.html#emptyList()"><CODE>emptyList()</CODE></A> </DL>
</DL>
<HR>

<A NAME="EMPTY_MAP"><!-- --></A> <H3>
EMPTY_MAP</H3>
<PRE>
public static final <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A>  <B>EMPTY_MAP</B></PRE>
<DL>
<DD>빈 상태(empty)의 맵입니다 (불변). 이 맵은 직렬화 가능합니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Collections.html#emptyMap()"><CODE>emptyMap()</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="sort(java.util.List)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static &lt;T extends <A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스">Comparable</A> &lt;?  super T&gt;&gt; void <B>sort</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;T&gt;&nbsp;list)</PRE>
<DL>
<DD>요소의 「자연 순서 붙이고」에 따라, 지정된 리스트를 승순에 소트 합니다. 리스트의 모든 요소는,<tt>Comparable</tt> 인터페이스를 구현하고 있을 필요가 있습니다. 게다가 리스트의 모든 요소는, 「서로 비교 가능」이 아니면 안됩니다. 즉,<tt>e1.compareTo(e2)</tt> 는 리스트의 요소가 <tt>e1</tt> 와 <tt>e2</tt> 의 경우,<tt>ClassCastException</tt> 를 throw 해야 하지는 않습니다. <p>

이 소트는 고정인 것이 보증되고 있습니다. 즉, 소트를 실행해도, 동등의 요소의 순서는 바뀌지 않습니다. <p>

지정된 리스트는 변경 가능하지 않으면 안됩니다, 사이즈 변경은 할 수 없어도 괜찮습니다. <p>

소트 알고리즘은 수정 머지 소트입니다. 이 소트에서는, 하위의 사브리 파업에서의 최고 레벨의 요소가 상위의 사브리 파업에서의 최저 레벨의 요소보다 작은 경우, 머지는 생략 됩니다. 이 알고리즘은, 항상 n log(n)의 퍼포먼스를 제공합니다.

이 구현은, 지정된 리스트의 배열에의 덤프, 배열의 소트, 리스트의 반복 처리를 실시하는 것으로, 배열의 대응하는 위치로부터 각 요소를 재설정합니다. 이것은, 링크된 리스트를 적소에 소트 하려고 했을 경우의 n<sup>2</sup> log(n)의 퍼포먼스가 되는 것을 회피합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 소트 되는 리스트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 리스트에 「서로 비교 가능」이 아닌 요소 (예를 들어, 캐릭터 라인과 정수)가 있는 경우
<DD><CODE><A HREF="../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 지정된 리스트의 리스트 반복자가 <tt>set</tt> 오퍼레이션을 지원하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스"><CODE>Comparable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sort(java.util.List, java.util.Comparator)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static &lt;T&gt; void <B>sort</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;T&gt;&nbsp;list,
                            <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</PRE>
<DL>
<DD>지정된 Comparator가 가리키는 순서에 따라, 지정된 리스트를 소트 합니다. 리스트의 모든 요소는, 지정된 Comparator에 의해 「서로 비교 가능」이 아니면 안됩니다.  즉,<tt>c.compare(e1, e2)</tt> 는 리스트의 요소가 <tt>e1</tt> 와 <tt>e2</tt> 의 경우 <tt>ClassCastException</tt> 를 throw 해야 하지는 않습니다. <p>

이 소트는 고정인 것이 보증되고 있습니다. 즉, 소트를 실행해도, 동등의 요소의 순서는 바뀌지 않습니다. <p>

소트 알고리즘은 수정 머지 소트입니다. 이 소트에서는, 하위의 사브리 파업에서의 최고 레벨의 요소가 상위의 사브리 파업에서의 최저 레벨의 요소보다 작은 경우, 머지는 생략 됩니다. 이 알고리즘은, 항상 n log(n)의 퍼포먼스를 제공합니다.

지정된 리스트는 변경 가능하지 않으면 안됩니다, 사이즈 변경은 할 수 없어도 괜찮습니다. 이 구현은, 지정된 리스트의 배열에의 덤프, 배열의 소트, 리스트의 반복 처리를 실시하는 것으로, 배열의 대응하는 위치로부터 각 요소를 재설정합니다. 이것은, 링크된 리스트를 적소에 소트 하려고 했을 경우의 n<sup>2</sup> log(n)의 퍼포먼스가 되는 것을 회피합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 소트 되는 리스트<DD><CODE>c</CODE> - 리스트의 순서를 결정하는 Comparator. <tt>null</tt> 치는, 요소의 「자연 순서 붙이고」를 사용하는 것을 나타낸다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 리스트로 지정된 Comparator로 「서로 비교」할 수 없는 요소가 있는 경우
<DD><CODE><A HREF="../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 지정된 리스트의 리스트 반복자가 <tt>set</tt> 오퍼레이션을 지원하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Comparator.html" title="java.util 내의 인터페이스"><CODE>Comparator</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(java.util.List,java.lang.Object)"><!-- --></A> <A NAME="binarySearch(java.util.List, T)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static &lt;T&gt; int <B>binarySearch</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;?  extends <A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스">Comparable</A> &lt;?  super T&gt;&gt;&nbsp;list,
                                   T&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 리스트로부터 지정된 객체를 검색합니다. 리스트는, 이 호출전에,<A HREF="../../java/util/Collections.html#sort(java.util.List)"><CODE>sort(List)</CODE></A>  메소드를 사용해 요소<A HREF="../../java/lang/Comparable.html" title="java.lang 중의 인터페이스">자연 순서부</a>에 따라 승순에 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 객체와 동일한 요소가 리스트에 다수 있는 경우, 어떤 것이 발견될까는 보증되지 않습니다.

 <p>「랜덤 억세스」리스트의 경우, 이 메소드는 log(n) 시간에 동작합니다 (위치를 지정한 액세스에 거의 일정한 시간이 필요). 지정된 리스트가 <A HREF="../../java/util/RandomAccess.html" title="java.util 안의 인터페이스"><CODE>RandomAccess</CODE></A>  인터페이스를 구현하지 않고, 큰 리스트인 경우, 이 메소드는 O(n) 링크 traversal와 O(log n) 요소 비교를 실행하는 반복자 베이스의 바이너리 서치를 실시합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 검색되는 리스트<DD><CODE>key</CODE> - 검색되는 키
<DT><B>반환값:</B><DD>리스트에 검색 키가 있는 경우는 검색 키의 인덱스.
               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 리스트로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 리스트의 모든 요소가 지정된 키보다 작은 경우는 <tt>list.size()</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 리스트에 「서로 비교 가능」이 아닌 요소 (예를 들어, 캐릭터 라인과 정수)가 있는 경우, 또는 검색 키가 리스트의 요소로 서로 비교 가능하지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(java.util.List,java.lang.Object,java.util.Comparator)"><!-- --></A> <A NAME="binarySearch(java.util.List, T, java.util.Comparator)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static &lt;T&gt; int <B>binarySearch</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;?  extends T&gt;&nbsp;list,
                                   T&nbsp;key,
                                   <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 리스트로부터 지정된 객체를 검색합니다. 리스트는, 이 호출전에,<A HREF="../../java/util/Collections.html#sort(java.util.List, java.util.Comparator)"><CODE>sort(List, Comparator)</CODE></A>  메소드를 사용해, 지정된 Comparator에 따라 승순에 소트 하지 않으면 안됩니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 객체와 동일한 요소가 리스트에 다수 있는 경우, 어떤 것이 발견될까는 보증되지 않습니다.

 <p>「랜덤 억세스」리스트의 경우, 이 메소드는 log(n) 시간에 동작합니다 (위치를 지정한 액세스에 거의 일정한 시간이 필요). 지정된 리스트가 <A HREF="../../java/util/RandomAccess.html" title="java.util 안의 인터페이스"><CODE>RandomAccess</CODE></A>  인터페이스를 구현하지 않고, 큰 리스트인 경우, 이 메소드는 O(n) 링크 traversal와 O(log n) 요소 비교를 실행하는 반복자 베이스의 바이너리 서치를 실시합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 검색되는 리스트<DD><CODE>key</CODE> - 검색되는 키<DD><CODE>c</CODE> - 리스트가 순서 붙이고 되는 Comparator.
<tt>null</tt> 치는, 요소<A HREF="../../java/lang/Comparable.html" title="java.lang 중의 인터페이스">자연 순서부</a>를 사용하는 것을 나타낸다
<DT><B>반환값:</B><DD>리스트에 검색 키가 있는 경우는 검색 키의 인덱스.
               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 리스트로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 리스트의 모든 요소가 지정된 키보다 작은 경우는 <tt>list.size()</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 리스트로 지정된 Comparator로 「서로 비교 가능」이 아닌 요소가 있는 경우, 또는 검색 키가 이 Comparator를 사용해 리스트의 요소로 서로 비교할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="reverse(java.util.List)"><!-- --></A> <H3>
reverse</H3>
<PRE>
public static void <B>reverse</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;list)</PRE>
<DL>
<DD>지정된 리스트의 요소의 순서를 반대로 합니다. <p>

이 메소드는 1 차 시간에 동작합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 요소의 순서가 반대로 되는 리스트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 지정된 리스트 또는 그 리스트 반복자가 <tt>set</tt> 오퍼레이션을 지원하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="shuffle(java.util.List)"><!-- --></A> <H3>
shuffle</H3>
<PRE>
public static void <B>shuffle</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;list)</PRE>
<DL>
<DD>디폴트의 random number generation의 원을 사용해, 지정된 리스트의 순서를 무작위로 바꿔 넣습니다. 모든 편성이, 거의 균등인 확률로 발생합니다. <p>

상기의 설명으로 「거의」라고 하는 말을 사용하고 있는 것은, random number generation의 원이 되는 디폴트의 소스가, 독립해 선택된 비트의 소스로서 편향이 없는 것은 근사적으로 마셔 성립하기 때문입니다. 랜덤에 선택된 완전한 소스이면, 알고리즘이 편성을 선택하는 확률은, 완전하게 한결같게 됩니다. <p>

이 구현은, 리스트의 마지막 요소로부터 2 번째의 요소까지 역방향으로 횡단(traverse) 해, 무작위로 선택된 요소를 「현재의 위치」에 반복해 바꿔 넣습니다. 요소는, 리스트의 최초의 요소로부터 현재의 위치까지의 범위에서 무작위로 선택됩니다. <p>

이 메소드는 1 차 시간에 동작합니다. 지정된 리스트가 <A HREF="../../java/util/RandomAccess.html" title="java.util 안의 인터페이스"><CODE>RandomAccess</CODE></A>  인터페이스를 구현하지 않는, 큰 리스트인 경우, 리스트의 순서를 바꿔 넣기 전에, 이 구현은 지정된 리스트를 배열에 덤프 해, 다음으로 바꾸어 넣은 배열을 리스트에 덤프 해 되돌립니다. 적절히 「차례차례 액세스」리스트의 순서를 바꿔 넣는 것에 의해 일어나는 2 차 동작을 피하기 (위해)때문에입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 순서를 바꿔 넣을 수 있는 리스트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 지정된 리스트 또는 그 리스트 반복자가 <tt>set</tt> 오퍼레이션을 지원하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="shuffle(java.util.List, java.util.Random)"><!-- --></A> <H3>
shuffle</H3>
<PRE>
public static void <B>shuffle</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;list,
                           <A HREF="../../java/util/Random.html" title="java.util 안의 클래스">Random</A> &nbsp;rnd)</PRE>
<DL>
<DD>디폴트의 random number generation의 원을 사용해, 지정된 리스트의 순서를 무작위로 바꿔 넣습니다. random number generation의 원이 한결같으면, 모든 편성은 공평한 확률로 발생합니다. <p>

이 구현은, 리스트의 마지막 요소로부터 2 번째의 요소까지 역방향으로 횡단(traverse) 해, 무작위로 선택된 요소를 「현재의 위치」에 반복해 바꿔 넣습니다. 요소는, 리스트의 최초의 요소로부터 현재의 위치까지의 범위에서 무작위로 선택됩니다. <p>

이 메소드는 1 차 시간에 동작합니다. 지정된 리스트가 <A HREF="../../java/util/RandomAccess.html" title="java.util 안의 인터페이스"><CODE>RandomAccess</CODE></A>  인터페이스를 구현하지 않는, 큰 리스트인 경우, 리스트의 순서를 바꿔 넣기 전에, 이 구현은 지정된 리스트를 배열에 덤프 해, 다음으로 바꾸어 넣은 배열을 리스트에 덤프 해 되돌립니다. 적절히 「차례차례 액세스」리스트의 순서를 바꿔 넣는 것에 의해 일어나는 2 차 동작을 피하기 (위해)때문에입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 순서를 바꿔 넣을 수 있는 리스트<DD><CODE>rnd</CODE> - 리스트의 순서를 바꿔 넣기 위해서(때문에) 사용하는 random number generation의 원
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 지정된 리스트 또는 그 리스트 반복자가 <tt>set</tt> 오퍼레이션을 지원하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="swap(java.util.List, int, int)"><!-- --></A> <H3>
swap</H3>
<PRE>
public static void <B>swap</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;list,
                        int&nbsp;i,
                        int&nbsp;j)</PRE>
<DL>
<DD>지정된 리스트의 지정된 위치에 있는 요소를 스왑 합니다. 지정된 위치가 같은 경우, 이 메소드를 호출해도, 리스트는 변경되지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 요소를 스왑 하는 리스트<DD><CODE>i</CODE> - 스왑 되는 1 개의 요소의 인덱스<DD><CODE>j</CODE> - 스왑 되는 이제(벌써) 1 개의 요소의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - <tt>i</tt> 또는 <tt>j</tt> 중 한쪽이 범위외의 경우 (i &lt; 0 || i &gt;= list.size() || j &lt; 0 || j &gt;= list.size())<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="fill(java.util.List,java.lang.Object)"><!-- --></A> <A NAME="fill(java.util.List, T)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static &lt;T&gt; void <B>fill</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;?  super T&gt;&nbsp;list,
                            T&nbsp;obj)</PRE>
<DL>
<DD>지정된 리스트의 모든 요소가 지정된 요소로 옮겨놓습니다.  <p>

이 메소드는 1 차 시간에 동작합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 지정된 요소가 삽입되는 리스트<DD><CODE>obj</CODE> - 지정된 리스트에 삽입되는 요소
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 지정된 리스트 또는 그 리스트 반복자가 <tt>set</tt> 오퍼레이션을 지원하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="copy(java.util.List, java.util.List)"><!-- --></A> <H3>
copy</H3>
<PRE>
public static &lt;T&gt; void <B>copy</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;?  super T&gt;&nbsp;dest,
                            <A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;?  extends T&gt;&nbsp;src)</PRE>
<DL>
<DD>어느 리스트로부터 다른 리스트에 모든 요소를 카피합니다. 이 오퍼레이션의 뒤, 카피처의 리스트에 카피된 각 요소의 인덱스는, 카피원의 리스트의 인덱스와 같게 됩니다. 카피처의 리스트는, 적어도 카피원의 리스트와 같은 길이가 아니면 안됩니다. 카피처의 리스트가 긴 경우에서도, 카피처의 리스트의 나머지의 요소는 영향을 받지 않습니다.  <p>

이 메소드는 1 차 시간에 동작합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>dest</CODE> - 카피처의 리스트<DD><CODE>src</CODE> - 카피원의 리스트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - 카피처의 리스트가 카피원의 리스트 전체를 포함하기에는  너무 작은 경우
<DD><CODE><A HREF="../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 카피 리스트의 리스트 반복자가 <tt>set</tt> 오퍼레이션을 지원하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="min(java.util.Collection)"><!-- --></A> <H3>
min</H3>
<PRE>
public static &lt;T extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  & <A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스">Comparable</A> &lt;?  super T&gt;&gt; T <B>min</B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;?  extends T&gt;&nbsp;coll)</PRE>
<DL>
<DD>요소의 「자연 순서 붙이고」에 따라, 지정된 컬렉션의 최소의 요소를 돌려줍니다. 컬렉션의 모든 요소는,<tt>Comparable</tt> 인터페이스를 구현하고 있을 필요가 있습니다. 게다가 컬렉션의 모든 요소는, 「서로 비교 가능」이 아니면 안됩니다.  즉,<tt>e1.compareTo(e2)</tt> 는, 컬렉션의 요소가 <tt>e1</tt> 와 <tt>e2</tt> 의 경우 <tt>ClassCastException</tt> 를 throw 해야 하지는 않습니다. <p>

이 메소드는 컬렉션 전체로 반복 처리를 실시하므로, 컬렉션의 사이즈 에 비례한 시간이 필요합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>coll</CODE> - 최소의 요소를 결정하는 컬렉션
<DT><B>반환값:</B><DD>요소의 「자연 순서 붙이고」에 따른, 지정된 컬렉션의 최소의 요소
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 컬렉션에 「서로 비교 가능」이 아닌 요소 (예를 들어, 캐릭터 라인과 정수)가 있는 경우
<DD><CODE><A HREF="../../java/util/NoSuchElementException.html" title="java.util 안의 클래스">NoSuchElementException</A> </CODE> - 컬렉션이 빈 상태(empty)의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스"><CODE>Comparable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="min(java.util.Collection, java.util.Comparator)"><!-- --></A> <H3>
min</H3>
<PRE>
public static &lt;T&gt; T <B>min</B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;?  extends T&gt;&nbsp;coll,
                        <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;comp)</PRE>
<DL>
<DD>지정된 Comparator가 가리키는 순서에 따라, 지정된 컬렉션의 최소의 요소를 돌려줍니다. 컬렉션의 모든 요소는, 지정된 Comparator로 「서로 비교 가능」이 아니면 안됩니다.  즉,<tt>comp.compare(e1, e2)</tt> 는 컬렉션의 요소가 <tt>e1</tt> 와 <tt>e2</tt> 의 경우 <tt>ClassCastException</tt> 를 throw 해야 하지는 않습니다. <p>

이 메소드는 컬렉션 전체로 반복 처리를 실시하므로, 컬렉션의 사이즈 에 비례한 시간이 필요합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>coll</CODE> - 최소의 요소를 결정하는 컬렉션<DD><CODE>comp</CODE> - 최소의 요소 리스트가 결정되는 Comparator.
<tt>null</tt> 치는, 요소의 「자연 순서 붙이고」를 사용하는 것을 나타낸다
<DT><B>반환값:</B><DD>지정된 Comparator에 따른, 지정된 컬렉션의 최소의 요소
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 컬렉션으로 지정된 Comparator로 「서로 비교」할 수 없는 요소가 있는 경우
<DD><CODE><A HREF="../../java/util/NoSuchElementException.html" title="java.util 안의 클래스">NoSuchElementException</A> </CODE> - 컬렉션이 빈 상태(empty)의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스"><CODE>Comparable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="max(java.util.Collection)"><!-- --></A> <H3>
max</H3>
<PRE>
public static &lt;T extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  & <A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스">Comparable</A> &lt;?  super T&gt;&gt; T <B>max</B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;?  extends T&gt;&nbsp;coll)</PRE>
<DL>
<DD>요소의 「자연 순서 붙이고」에 따라, 지정된 컬렉션의 최대의 요소를 돌려줍니다. 컬렉션의 모든 요소는,<tt>Comparable</tt> 인터페이스를 구현하고 있을 필요가 있습니다. 게다가 컬렉션의 모든 요소는, 「서로 비교 가능」이 아니면 안됩니다.  즉,<tt>e1.compareTo(e2)</tt> 는, 컬렉션의 요소가 <tt>e1</tt> 와 <tt>e2</tt> 의 경우 <tt>ClassCastException</tt> 를 throw 해야 하지는 않습니다. <p>

이 메소드는 컬렉션 전체로 반복 처리를 실시하므로, 컬렉션의 사이즈 에 비례한 시간이 필요합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>coll</CODE> - 최대의 요소를 결정하는 컬렉션
<DT><B>반환값:</B><DD>요소의 「자연 순서 붙이고」에 따른, 지정된 컬렉션의 최대의 요소
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 컬렉션에 「서로 비교 가능」이 아닌 요소 (예를 들어, 캐릭터 라인과 정수)가 있는 경우
<DD><CODE><A HREF="../../java/util/NoSuchElementException.html" title="java.util 안의 클래스">NoSuchElementException</A> </CODE> - 컬렉션이 빈 상태(empty)의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스"><CODE>Comparable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="max(java.util.Collection, java.util.Comparator)"><!-- --></A> <H3>
max</H3>
<PRE>
public static &lt;T&gt; T <B>max</B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;?  extends T&gt;&nbsp;coll,
                        <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;comp)</PRE>
<DL>
<DD>지정된 Comparator가 가리키는 순서에 따라, 지정된 컬렉션의 최대의 요소를 돌려줍니다. 컬렉션의 모든 요소는, 지정된 Comparator로 「서로 비교 가능」이 아니면 안됩니다.  즉,<tt>comp.compare(e1, e2)</tt> 는 컬렉션의 요소가 <tt>e1</tt> 와 <tt>e2</tt> 의 경우 <tt>ClassCastException</tt> 를 throw 해야 하지는 않습니다. <p>

이 메소드는 컬렉션 전체로 반복 처리를 실시하므로, 컬렉션의 사이즈 에 비례한 시간이 필요합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>coll</CODE> - 최대의 요소를 결정하는 컬렉션<DD><CODE>comp</CODE> - 최대의 요소 리스트를 결정하는 Comparator.
<tt>null</tt> 치는, 요소의 「자연 순서 붙이고」를 사용하는 것을 나타낸다
<DT><B>반환값:</B><DD>지정된 Comparator에 따른, 지정된 컬렉션의 최대의 요소
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 컬렉션으로 지정된 Comparator로 「서로 비교」할 수 없는 요소가 있는 경우
<DD><CODE><A HREF="../../java/util/NoSuchElementException.html" title="java.util 안의 클래스">NoSuchElementException</A> </CODE> - 컬렉션이 빈 상태(empty)의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스"><CODE>Comparable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="rotate(java.util.List, int)"><!-- --></A> <H3>
rotate</H3>
<PRE>
public static void <B>rotate</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;list,
                          int&nbsp;distance)</PRE>
<DL>
<DD>지정된 리스트의 요소를, 지정된 거리에 의해 회전합니다. 이 메소드를 호출한 뒤,<tt>0</tt> (이 값을 포함한다)으로부터 <tt>list.size()-1</tt> (이 값을 포함한다)까지의 (<tt>i</tt> 의 모든 값에 대해서는, 인덱스 <tt>i</tt> 의 요소는, 이전, 인덱스 <tt>(i - distance)</tt> mod <tt>list.size()</tt> 에 있던 요소가 됩니다. 이 메소드는 리스트의 사이즈에는 영향을 미치지 않습니다.

 <p>예를 들어,<tt>list</tt> 에는 <tt>[t, a, n, k, s]</tt> 가 포함된다고 합니다. <tt>Collections.rotate(list, 1)</tt> (혹은 <tt>Collections.rotate(list, -4)</tt>)를 호출한 뒤,<tt>list</tt> 에는 <tt>[s, t, a, n, k]</tt> 가 포함됩니다.

 <p>이 메소드를 사브리 파업에 유효하게 적용해, 나머지의 요소의 순서를 보존하면서, 리스트내의 1 개 또는 복수의 요소를 이동할 수가 있습니다. 예를 들어, 다음의 관용법은, 인덱스 <tt>j</tt> 에 있는 요소를 위치 <tt>k</tt> 로 이동합니다 (<tt>k</tt> 는 <tt>j</tt> 는 보다 큰지, 등치일 필요가 있습니다).
 <pre>
     Collections.rotate(list.subList(j, k+1), -1);
 </pre>
이것을 고정하기 위해서,<tt>list</tt> 에 <tt>[a, b, c, d, e]</tt> 가 포함되면(자) 가정합니다. 인덱스 <tt>1</tt> (<tt>b</tt>)에 있는 요소를 2 개의 위치하러 진행하기 위해서(때문에)는, 다음의 호출을 실행합니다.
 <pre>
     Collections.rotate(l.subList(1, 4), -1);
 </pre>
그 결과적으로 얻을 수 있는 리스트는 <tt>[a, c, d, b, e]</tt> 가 됩니다.

 <p>복수의 요소를 진행시키기 위해서(때문에)는, 회전 거리의 절대치를 증가시킵니다. 뒤로 이동시키려면 , 정의 쉬프트 이동량을 사용합니다.

 <p>지정된 값이 작은 리스트인지,<A HREF="../../java/util/RandomAccess.html" title="java.util 안의 인터페이스"><CODE>RandomAccess</CODE></A>  인터페이스를 구현하고 있는 경우, 이 구현은 제 1 의 요소를 이동해야 할 위치로 교환합니다.  다음에, 옮겨놓을 수 있었던 요소가 최초의 요소에 스왑 될 때까지, 옮겨놓을 수 있었던 요소를 이동해야 할 위치에 반복해 교환합니다. 필요에 따라서, 회전이 완료할 때까지, 제 2 요소 및 연속하는 요소에 대해 이 프로세스가 반복해집니다. 지정된 리스트가 크고,<tt>RandomAccess</tt> 인터페이스를 구현하고 있지 않는 경우, 이 구현은, 인덱스 <tt>-distance mod size</tt> 의 2 개의 사브리스트뷰에 리스트를 분할합니다. 다음에,<A HREF="../../java/util/Collections.html#reverse(java.util.List)"><CODE>reverse(List)</CODE></A>  메소드는, 각각의 사브리스트뷰로 불려 가 최종적으로는 리스트 전체로 불려 갑니다. 2 개의 알고리즘의 상세한 것에 대하여는, Jon Bentley 의 「Programming Pearls」(Addison-Wesley, 1986)의 섹션 2.3 을 참조해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 회전되는 리스트<DD><CODE>distance</CODE> - 리스트를 회전하는 거리. 이 값에 제약은 없고, 값은 0 에서도, 부에서도,<tt>list.size()</tt> 보다 커도 상관없다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 지정된 리스트 또는 그 리스트 반복자가 <tt>set</tt> 오퍼레이션을 지원하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="replaceAll(java.util.List,java.lang.Object,java.lang.Object)"><!-- --></A> <A NAME="replaceAll(java.util.List, T, T)"><!-- --></A> <H3>
replaceAll</H3>
<PRE>
public static &lt;T&gt; boolean <B>replaceAll</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;T&gt;&nbsp;list,
                                     T&nbsp;oldVal,
                                     T&nbsp;newVal)</PRE>
<DL>
<DD>리스트내에 출현하는 지정된 값을 모두 다른 값에 옮겨놓습니다. 즉,<tt>list</tt> 내에서 <tt>(oldVal==null ?  e==null : oldVal.equals(e))</tt> 가 되는 각 요소 <tt>e</tt> 를 <tt>newVal</tt> 에 옮겨놓습니다. 이 메소드는 리스트의 사이즈에는 영향을 미치지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 치환이 생기는 리스트<DD><CODE>oldVal</CODE> - 치환전의 값<DD><CODE>newVal</CODE> - <tt>oldVal</tt> 의 치환 후의 값
<DT><B>반환값:</B><DD><tt>list</tt> 가,<tt>(oldVal==null ?   e==null : oldVal.equals(e))</tt> 가 되는 1 개 또는 복수의 요소 <tt>e</tt> 를 포함한 경우는 <tt>true</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 지정된 리스트 또는 그 리스트 반복자가 <tt>set</tt> 오퍼레이션을 지원하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="indexOfSubList(java.util.List, java.util.List)"><!-- --></A> <H3>
indexOfSubList</H3>
<PRE>
public static int <B>indexOfSubList</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;source,
                                 <A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;target)</PRE>
<DL>
<DD>지정된 소스 리스트내에서, 지정된 타겟 리스트가 최초로 출현한 위치의 개시 위치를 돌려줍니다.  이러한 출현이 없는 경우는 -1 을 돌려줍니다. 즉,<tt>source.subList(i, i+target.size()). equals(target)</tt> 가 되는 최소의 인덱스치 <tt>i</tt> 를 돌려주어, 이러한 인덱스치가 없는 경우는 -1 을 돌려주는 (<tt>target.size() > source.size()</tt> 의 경우는 -1 을 돌려준다).

 <p>이 구현은, 소스 리스트를 스캐닝 하는 「강행인」기술을 사용해, 소스 리스트의 여러분치로 타겟과 일치할까 차례로 검색합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>source</CODE> - 최초로 출현하는 <tt>target</tt> 를 검색하는 리스트<DD><CODE>target</CODE> - <tt>source</tt> 의 subList 로서 검색하는 리스트
<DT><B>반환값:</B><DD>지정된 소스 리스트내에서, 최초로 출현한 지정 타겟 리스트의 개시 위치. 이러한 출현이 없는 경우는,-1<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lastIndexOfSubList(java.util.List, java.util.List)"><!-- --></A> <H3>
lastIndexOfSubList</H3>
<PRE>
public static int <B>lastIndexOfSubList</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;source,
                                     <A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;? &gt;&nbsp;target)</PRE>
<DL>
<DD>지정된 소스 리스트내에서, 마지막에 출현한 지정 타겟 리스트의 개시 위치를 돌려줍니다.  이러한 출현이 없는 경우는 -1 을 돌려줍니다. 즉,<tt>source.subList(i, i+target.size()). equals(target)</tt> 가 되는 최대의 인덱스치 <tt>i</tt> 를 돌려주어, 이러한 인덱스치가 없는 경우는 -1 을 돌려주는 (<tt>target.size() > source.size()</tt> 의 경우는 -1 을 돌려준다).

 <p>이 구현에서는, 소스 리스트의 반복 처리를 실시하는 「강행인」기술을 사용해, 여러분치로 타겟과 일치할까 차례로 검색합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>source</CODE> - 마지막에 출현하는 <tt>target</tt> 를 검색하는 리스트<DD><CODE>target</CODE> - <tt>source</tt> 의 subList 로서 검색하는 리스트
<DT><B>반환값:</B><DD>지정된 소스 리스트내에서, 마지막에 출현한 지정 타겟 리스트의 개시 위치. 이러한 출현이 없는 경우는,-1<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="unmodifiableCollection(java.util.Collection)"><!-- --></A> <H3>
unmodifiableCollection</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;T&gt; <B>unmodifiableCollection</B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;?  extends T&gt;&nbsp;c)</PRE>
<DL>
<DD>지정된 컬렉션의 변경 불가능한 뷰를 돌려줍니다. 이 메소드를 사용하면(자), 모듈은 사용자에게 내부 컬렉션에의 「읽기 전용」액세스권을 제공할 수 있습니다. 반환된 컬렉션에서의 쿼리오퍼레이션은, 지정된 컬렉션을 직접 읽어들입니다.  직접인가 그 반복자를 사용할까에 관계없이, 반환된 컬렉션을 변경하려고 하면(자) <tt>UnsupportedOperationException</tt> 가 throw 됩니다. <p>

반환된 컬렉션은, hashCode 오퍼레이션 및 equals 오퍼레이션을 기가 되는 컬렉션에 건네줄 것은 없고,<tt>Object</tt> 의 <tt>equals</tt> 메소드 및 <tt>hashCode</tt> 메소드에 의존합니다. 이것은, 기가 되는 컬렉션이 세트 또는 리스트의 경우에 그러한 오퍼레이션의 규약을 지키기 위해서 필요합니다. <p>

반환된 컬렉션은, 지정된 컬렉션이 직렬화 가능의 경우는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 변경 불가능한 뷰가 반환되는 컬렉션
<DT><B>반환값:</B><DD>지정된 컬렉션의 변경 불가능한 뷰</DL>
</DD>
</DL>
<HR>

<A NAME="unmodifiableSet(java.util.Set)"><!-- --></A> <H3>
unmodifiableSet</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A> &lt;T&gt; <B>unmodifiableSet</B>(<A HREF="../../java/util/Set.html" title="java.util 안의 인터페이스">Set</A> &lt;?  extends T&gt;&nbsp;s)</PRE>
<DL>
<DD>지정된 세트의 변경 불가능한 뷰를 돌려줍니다. 이 메소드를 사용하면(자), 모듈은 사용자에게 내부 세트에의 「읽기 전용」액세스권을 제공할 수 있습니다. 반환된 세트에서의 쿼리오퍼레이션은, 지정된 세트를 직접 읽어들여, 직접인가 그 반복자를 사용할까에 관계없이, 반환된 세트를 변경하려고 하면(자) <tt>UnsupportedOperationException</tt> 가 throw 됩니다. <p>

반환되는 세트는, 지정된 세트가 직렬화 가능의 경우에 직렬화 가능하게 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 변경 불가능한 뷰가 반환되는 세트
<DT><B>반환값:</B><DD>지정된 세트의 변경 불가능한 뷰</DL>
</DD>
</DL>
<HR>

<A NAME="unmodifiableSortedSet(java.util.SortedSet)"><!-- --></A> <H3>
unmodifiableSortedSet</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/SortedSet.html" title="java.util 내의 인터페이스">SortedSet</A> &lt;T&gt; <B>unmodifiableSortedSet</B>(<A HREF="../../java/util/SortedSet.html" title="java.util 안의 인터페이스">SortedSet</A> &lt;T&gt;&nbsp;s)</PRE>
<DL>
<DD>지정된 소트 세트의 변경 불가능한 뷰를 돌려줍니다. 이 메소드를 사용하면(자), 모듈은 사용자에게 내부 소트 세트에의 「읽기 전용」액세스권을 제공할 수 있습니다. 반환된 소트 세트에서의 쿼리오퍼레이션은, 지정된 소트 세트를 직접 읽어들입니다. 직접인가, 그 반복자를 사용하든가, 혹은 뷰의 <tt>subSet</tt>,<tt>headSet</tt>,<tt>tailSet</tt> 를 사용할까에 관계없이, 소트 세트를 변경하려고 하면(자) <tt>UnsupportedOperationException</tt> 가 throw 됩니다. <p>

반환된 소트 세트는, 지정된 소트 세트가 직렬화 가능의 경우는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 변경 불가능한 뷰가 반환되는 소트 세트
<DT><B>반환값:</B><DD>지정된 소트 세트의 변경 불가능한 뷰</DL>
</DD>
</DL>
<HR>

<A NAME="unmodifiableList(java.util.List)"><!-- --></A> <H3>
unmodifiableList</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt; <B>unmodifiableList</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;?  extends T&gt;&nbsp;list)</PRE>
<DL>
<DD>지정된 리스트의 변경 불가능한 뷰를 돌려줍니다. 이 메소드를 사용하면(자), 모듈은 사용자에게 내부 리스트에의 「읽기 전용」액세스권을 제공할 수 있습니다. 반환된 리스트에서의 쿼리오퍼레이션은, 지정된 리스트를 직접 읽어들입니다.  직접인가, 그 반복자를 사용할까에 관계없이, 반환된 리스트를 변경하려고 하면(자) <tt>UnsupportedOperationException</tt> 가 throw 됩니다. <p>

반환된 리스트는, 지정된 리스트가 직렬화 가능의 경우에만 직렬화 가능하게 됩니다. 또, 지정된 리스트가 <A HREF="../../java/util/RandomAccess.html" title="java.util 안의 인터페이스"><CODE>RandomAccess</CODE></A>  를 구현하는 경우에만, 반환된 리스트는 <A HREF="../../java/util/RandomAccess.html" title="java.util 안의 인터페이스"><CODE>RandomAccess</CODE></A>  를 구현합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 변경 불가능한 뷰가 반환되는 리스트
<DT><B>반환값:</B><DD>지정된 리스트의 변경 불가능한 뷰</DL>
</DD>
</DL>
<HR>

<A NAME="unmodifiableMap(java.util.Map)"><!-- --></A> <H3>
unmodifiableMap</H3>
<PRE>
public static &lt;K, V&gt; <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;K, V&gt; <B>unmodifiableMap</B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?  extends K,?  extends V&gt;&nbsp;m)</PRE>
<DL>
<DD>지정된 맵의 변경 불가능한 뷰를 돌려줍니다. 이 메소드를 사용하면(자), 모듈은 사용자에게 내부 맵에의 「읽기 전용」액세스권을 제공할 수 있습니다. 반환된 맵에서의 쿼리오퍼레이션은, 지정된 맵을 직접 읽어들입니다.  직접인가, 그 코레크션뷰를 사용할까에 관계없이, 반환된 맵을 변경하려고 하면(자) <tt>UnsupportedOperationException</tt> 가 throw 됩니다. <p>

반환된 맵은, 지정된 맵이 직렬화 가능의 경우는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>m</CODE> - 변경 불가능한 뷰가 반환되는 맵
<DT><B>반환값:</B><DD>지정된 맵의 변경 불가능한 뷰</DL>
</DD>
</DL>
<HR>

<A NAME="unmodifiableSortedMap(java.util.SortedMap)"><!-- --></A> <H3>
unmodifiableSortedMap</H3>
<PRE>
public static &lt;K, V&gt; <A HREF="../../java/util/SortedMap.html" title="java.util 내의 인터페이스">SortedMap</A> &lt;K, V&gt; <B>unmodifiableSortedMap</B>(<A HREF="../../java/util/SortedMap.html" title="java.util 안의 인터페이스">SortedMap</A> &lt;K,?  extends V&gt;&nbsp;m)</PRE>
<DL>
<DD>지정된 소트 맵의 변경 불가능한 뷰를 돌려줍니다. 이 메소드를 사용하면(자), 모듈은 사용자에게 내부 소트 맵에의 「읽기 전용」액세스권을 제공할 수 있습니다. 반환된 소트 맵에서의 쿼리오퍼레이션은, 지정된 소트 맵을 직접 읽어들입니다. 직접인가, 그 코레크션뷰를 사용하는지, 또는 뷰 <tt>subMap</tt>,<tt>headMap</tt>,<tt>tailMap</tt> 를 사용할까에 관계없이, 반환된 소트 맵을 변경하려고 하면(자) <tt>UnsupportedOperationException</tt> 가 throw 됩니다. <p>

반환된 소트 맵은, 지정된 소트 맵이 직렬화 가능의 경우는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>m</CODE> - 변경 불가능한 뷰가 반환되는 소트 맵
<DT><B>반환값:</B><DD>지정된 소트 맵의 변경 불가능한 뷰</DL>
</DD>
</DL>
<HR>

<A NAME="synchronizedCollection(java.util.Collection)"><!-- --></A> <H3>
synchronizedCollection</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;T&gt; <B>synchronizedCollection</B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;T&gt;&nbsp;c)</PRE>
<DL>
<DD>지정된 컬렉션에 연동하는 동기 (thread 세이프인) 컬렉션을 돌려줍니다. 확실히 직렬 액세스를 실현하려면 , 기가 되는 컬렉션에의 액세스는 모두 반환된 컬렉션을 개입시켜 실시할 필요가 있습니다. <p>

반환된 컬렉션의 반복 처리를 실시하는 경우, 사용자는, 다음에 나타내도록(듯이) 수동으로 동기를 잡을 필요가 있습니다.
 <pre>
  Collection c = Collections.synchronizedCollection(myCollection);
     ...
  synchronized(c) {
      Iterator i = c.iterator(); // Must be in the synchronized block
      while (i.hasNext())
         foo(i.next());
  }
 </pre>
이것을 실시하지 않는 경우, 동작은 보증되지 않습니다.

 <p>반환된 컬렉션은,<tt>hashCode</tt> 오퍼레이션 및 <tt>equals</tt> 오퍼레이션을 기가 되는 컬렉션에 건네줄 것은 없고,<tt>Object</tt> 의 equals 및 hashCode 메소드에 의존합니다. 이것은, 기가 되는 컬렉션이 세트 또는 리스트의 경우에 그러한 오퍼레이션의 규약을 지키기 위해서 필요합니다. <p>

반환된 컬렉션은, 지정된 컬렉션이 직렬화 가능의 경우는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 동기 컬렉션에 「랩」되는 컬렉션
<DT><B>반환값:</B><DD>지정된 컬렉션의 동기 뷰</DL>
</DD>
</DL>
<HR>

<A NAME="synchronizedSet(java.util.Set)"><!-- --></A> <H3>
synchronizedSet</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A> &lt;T&gt; <B>synchronizedSet</B>(<A HREF="../../java/util/Set.html" title="java.util 안의 인터페이스">Set</A> &lt;T&gt;&nbsp;s)</PRE>
<DL>
<DD>지정된 세트에 연동하는 동기 (thread 세이프인) 세트를 돌려줍니다. 확실히 직렬 액세스를 실현하려면 , 기가 되는 세트에의 액세스는 모두 반환된 세트를 개입시켜 실시할 필요가 있습니다. <p>

반환된 세트의 반복 처리를 실시하는 경우, 사용자는, 다음에 나타내도록(듯이) 수동으로 동기를 잡을 필요가 있습니다.
 <pre>
  Set s = Collections.synchronizedSet(new HashSet());
      ...
  synchronized(s) {
      Iterator i = s.iterator(); // Must be in the synchronized block
      while (i.hasNext())
          foo(i.next());
  }
 </pre>
이것을 실시하지 않는 경우, 동작은 보증되지 않습니다.

 <p>반환되는 세트는, 지정된 세트가 직렬화 가능의 경우에 직렬화 가능하게 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 동기 세트에 「랩」되는 세트
<DT><B>반환값:</B><DD>지정된 세트의 동기 뷰</DL>
</DD>
</DL>
<HR>

<A NAME="synchronizedSortedSet(java.util.SortedSet)"><!-- --></A> <H3>
synchronizedSortedSet</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/SortedSet.html" title="java.util 내의 인터페이스">SortedSet</A> &lt;T&gt; <B>synchronizedSortedSet</B>(<A HREF="../../java/util/SortedSet.html" title="java.util 안의 인터페이스">SortedSet</A> &lt;T&gt;&nbsp;s)</PRE>
<DL>
<DD>지정된 소트 세트에 연동하는 동기 (thread 세이프인) 소트 세트를 돌려줍니다. 확실히 직렬 액세스를 실현하려면 , 기가 되는 소트 세트에의 액세스는 모두, 반환된 소트 세트 (또는 그 뷰)를 개입시켜 실시할 필요가 있습니다. <p>

반환된 소트 세트, 또는 그 <tt>subSet</tt>,<tt>headSet</tt>, 혹은 <tt>tailSet</tt> 뷰의 반복 처리를 실시하는 경우, 사용자는, 다음에 나타내도록(듯이) 수동으로 동기를 잡을 필요가 있습니다.
 <pre>
  SortedSet s = Collections.synchronizedSortedSet(new TreeSet());
      ...
  synchronized(s) {
      Iterator i = s.iterator(); // Must be in the synchronized block
      while (i.hasNext())
          foo(i.next());
  }
 </pre>
또는
 <pre>
  SortedSet s = Collections.synchronizedSortedSet(new TreeSet());
  SortedSet s2 = s.headSet(foo);
      ...
  synchronized(s) {  // Note: s, not s2!!!
      Iterator i = s2.iterator(); // Must be in the synchronized block
      while (i.hasNext())
          foo(i.next());
  }
 </pre>
이것을 실시하지 않는 경우, 동작은 보증되지 않습니다.

 <p>반환된 소트 세트는, 지정된 소트 세트가 직렬화 가능의 경우는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 동기 소트 세트에 「랩」되는 소트 세트
<DT><B>반환값:</B><DD>지정된 소트 세트의 동기 뷰</DL>
</DD>
</DL>
<HR>

<A NAME="synchronizedList(java.util.List)"><!-- --></A> <H3>
synchronizedList</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt; <B>synchronizedList</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;T&gt;&nbsp;list)</PRE>
<DL>
<DD>지정된 리스트에 연동하는 동기 (thread 세이프인) 리스트를 돌려줍니다. 확실히 직렬 액세스를 실현하려면 , 기본으로 되는 리스트에의 액세스는 모두, 반환된 리스트를 개입시켜 실시할 필요가 있습니다. <p>

반환된 리스트의 반복 처리를 실시하는 경우, 사용자는, 다음에 나타내도록(듯이) 수동으로 동기를 잡을 필요가 있습니다.
 <pre>
  List list = Collections.synchronizedList(new ArrayList());
      ...
  synchronized(list) {
      Iterator i = list.iterator(); // Must be in synchronized block
      while (i.hasNext())
          foo(i.next());
  }
 </pre>
이것을 실시하지 않는 경우, 동작은 보증되지 않습니다.

 <p>반환된 리스트는, 지정된 리스트가 직렬화 가능의 경우에만 직렬화 가능하게 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 동기 리스트에 「랩」되는 리스트
<DT><B>반환값:</B><DD>지정된 리스트의 동기 뷰</DL>
</DD>
</DL>
<HR>

<A NAME="synchronizedMap(java.util.Map)"><!-- --></A> <H3>
synchronizedMap</H3>
<PRE>
public static &lt;K, V&gt; <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;K, V&gt; <B>synchronizedMap</B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;K, V&gt;&nbsp;m)</PRE>
<DL>
<DD>지정된 맵에 연동하는 동기 (thread 세이프인) 맵을 돌려줍니다. 확실히 직렬 액세스를 실현하려면 , 기본으로 되는 맵에의 액세스는 모두, 반환된 맵을 개입시켜 실시할 필요가 있습니다. <p>

반환된 맵의 코레크션뷰에서의 반복 처리를 실시하는 경우, 사용자는, 다음에 나타내도록(듯이) 수동으로 동기를 잡을 필요가 있습니다.
 <pre>
  Map m = Collections.synchronizedMap(new HashMap());
      ...
  Set s = m.keySet();  // Needn't be in synchronized block
      ...
  synchronized(m) {  // Synchronizing on m, not s!
      Iterator i = s.iterator(); // Must be in synchronized block
      while (i.hasNext())
          foo(i.next());
  }
 </pre>
이것을 실시하지 않는 경우, 동작은 보증되지 않습니다.

 <p>반환된 맵은, 지정된 맵이 직렬화 가능의 경우는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>m</CODE> - 동기 맵에 「랩」되는 맵
<DT><B>반환값:</B><DD>지정된 맵의 동기 뷰</DL>
</DD>
</DL>
<HR>

<A NAME="synchronizedSortedMap(java.util.SortedMap)"><!-- --></A> <H3>
synchronizedSortedMap</H3>
<PRE>
public static &lt;K, V&gt; <A HREF="../../java/util/SortedMap.html" title="java.util 내의 인터페이스">SortedMap</A> &lt;K, V&gt; <B>synchronizedSortedMap</B>(<A HREF="../../java/util/SortedMap.html" title="java.util 안의 인터페이스">SortedMap</A> &lt;K, V&gt;&nbsp;m)</PRE>
<DL>
<DD>지정된 소트 맵에 연동하는 동기 (thread 세이프인) 소트 맵을 돌려줍니다. 확실히 직렬 액세스를 실현하려면 , 기본으로 되는 소트 맵에의 액세스는 모두, 반환된 소트 맵 (또는 그 뷰)을 개입시켜 실시할 필요가 있습니다. <p>

반환된 소트 맵의 코레크션뷰, 또는 <tt>subMap</tt>,<tt>headMap</tt>,<tt>tailMap</tt> 뷰의 코레크션뷰에서의 반복 처리를 실시하는 경우, 사용자는, 다음에 나타내도록(듯이) 수동으로 동기를 잡을 필요가 있습니다.
 <pre>
  SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
      ...
  Set s = m.keySet();  // Needn't be in synchronized block
      ...
  synchronized(m) {  // Synchronizing on m, not s!
      Iterator i = s.iterator(); // Must be in synchronized block
      while (i.hasNext())
          foo(i.next());
  }
 </pre>
또는
 <pre>
  SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
  SortedMap m2 = m.subMap(foo, bar);
      ...
  Set s2 = m2.keySet();  // Needn't be in synchronized block
      ...
  synchronized(m) {  // Synchronizing on m, not m2 or s2!
      Iterator i = s.iterator(); // Must be in synchronized block
      while (i.hasNext())
          foo(i.next());
  }
 </pre>
이것을 실시하지 않는 경우, 동작은 보증되지 않습니다.

 <p>반환된 소트 맵은, 지정된 소트 맵이 직렬화 가능의 경우는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>m</CODE> - 동기 소트 맵에 「랩」되는 소트 맵
<DT><B>반환값:</B><DD>지정된 소트 맵의 동기 뷰</DL>
</DD>
</DL>
<HR>

<A NAME="checkedCollection(java.util.Collection, java.lang.Class)"><!-- --></A> <H3>
checkedCollection</H3>
<PRE>
public static &lt;E&gt; <A HREF="../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;E&gt; <B>checkedCollection</B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;E&gt;&nbsp;c,
                                                  <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;E&gt;&nbsp;type)</PRE>
<DL>
<DD>지정된 컬렉션의, 동적으로 형태 보증된 뷰를 돌려줍니다. 부정한 형태의 요소를 삽입하려고 하자, 곧바로 <tt>ClassCastException</tt> 가 throw 됩니다. 동적으로 형태 보증된 뷰가 생성되기 전은 컬렉션에 부정한 형태의 요소가 포함되지 않고, 후속의 컬렉션에의 액세스가 모두 이 뷰를 개입시켜 행해지는 경우, 컬렉션에는 부정한 형태의 요소가 포함되지 않는 것이 보증됩니다. <i></i>

 <p>언어내의 총칭 메카니즘에 의해 컴파일시 (정적)의 형태 체크가 제공됩니다만, 체크되지 않는 캐스트를 사용해 이 메카니즘을 무효로 할 수 없습니다. 일반적으로, 이런 종류의 체크되지 않는 조작 모두로 컴파일러가 경고를 발행하기 위해(때문에), 이것은 문제로는 되지 않습니다. 다만, 때로는, 정적인 형태 체크만으로는 불충분한 경우가 있습니다. 예를 들어, 컬렉션이 서드 파티의 라이브러리에게 건네지지만, 라이브러리 코드가 부정한 형태의 요소를 삽입해 컬렉션을 파괴해 버리는 것이 있어서는 안되는 경우 등입니다.  동적으로 형태 보증된 뷰의 다른 용도는, 디버그입니다.

 <p>프로그램이 <tt>ClassCastException</tt> 로 실패해, 부정한 형태의 요소가 파라미터화 된 컬렉션에 넣어진 것을 나타내는 경우를 생각합시다. 유감스럽게, 부정한 요소가 삽입되는 곳의 예외가 항상 발생할 가능성이 있기 (위해)때문에, 이 예외로부터 문제의 소스에 관한 정보를 거의 또는 전혀 얻을 수 있지 않습니다. 문제가 재현 가능한 경우는, 프로그램을 변경해 동적인 형태 보증된 뷰로 컬렉션을 일시적으로 랩 하는 것으로, 소스를 재빠르게 판정할 수 있습니다. 예를 들어, 선언
 <pre>
     Collection&lt;String&gt; c = new HashSet&lt;String&gt;();
 </pre>
(은)는, 다음의 선언으로 일시적으로 옮겨놓을 수가 있습니다.
 <pre>
     Collection&lt;String&gt; c = Collections.checkedCollection(
         new HashSet&lt;String&gt;(), String.class);
 </pre>
프로그램을 재차 실행하면(자), 부정한 형태의 요소가 컬렉션에 삽입된 위치에서 프로그램이 실패하기 위해(때문에), 문제의 원인을 분명히 식별할 수 있습니다. 문제를 수정하면(자), 변경한 선언을 바탕으로 되돌립니다.

 <p>반환된 컬렉션은, hashCode 오퍼레이션 및 equals 오퍼레이션을 기가 되는 컬렉션에 건네줄 것은 없고,<tt>Object</tt> 의 <tt>equals</tt> 메소드 및 <tt>hashCode</tt> 메소드에 의존합니다. 이것은, 기가 되는 컬렉션이 세트 또는 리스트의 경우에 그러한 오퍼레이션의 규약을 지키기 위해서 필요합니다.

 <p>반환된 컬렉션은, 지정된 컬렉션이 직렬화 가능의 경우는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 동적으로 형태 보증된 뷰가 반환되는 컬렉션<DD><CODE>type</CODE> - <tt>c</tt> 가 보관 유지하는 것이 용서된 요소의 형태
<DT><B>반환값:</B><DD>지정된 컬렉션의, 동적으로 형태 보증된 뷰<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkedSet(java.util.Set, java.lang.Class)"><!-- --></A> <H3>
checkedSet</H3>
<PRE>
public static &lt;E&gt; <A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A> &lt;E&gt; <B>checkedSet</B>(<A HREF="../../java/util/Set.html" title="java.util 안의 인터페이스">Set</A> &lt;E&gt;&nbsp;s,
                                    <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;E&gt;&nbsp;type)</PRE>
<DL>
<DD>지정된 세트의 동적으로 형태 보증된 뷰를 돌려줍니다. 부정한 형태의 요소를 삽입하려고 하자, 곧바로 <tt>ClassCastException</tt> 가 throw 됩니다. 동적으로 형태 보증된 뷰가 생성되기 전은 세트에 부정한 형태의 요소가 포함되지 않고, 세트에의 후속의 액세스가 모두 이 뷰를 개입시켜 행해지는 경우, 세트에는 부정한 형태의 요소가 포함되지 않는 것이 보증됩니다.

 <p>동적으로 형태 보증된 뷰의 사용에 대해서는,<A HREF="../../java/util/Collections.html#checkedCollection(java.util.Collection, java.lang.Class)"><CODE>checkedCollection</CODE></A>  메소드의 문서를 참조해 주세요.

 <p>반환되는 세트는, 지정된 세트가 직렬화 가능의 경우에 직렬화 가능하게 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 동적으로 형태 보증된 뷰가 반환되는 세트<DD><CODE>type</CODE> - <tt>s</tt> 가 보관 유지하는 것이 용서된 요소의 형태
<DT><B>반환값:</B><DD>지정된 세트의 동적으로 형태 보증된 뷰<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkedSortedSet(java.util.SortedSet, java.lang.Class)"><!-- --></A> <H3>
checkedSortedSet</H3>
<PRE>
public static &lt;E&gt; <A HREF="../../java/util/SortedSet.html" title="java.util 내의 인터페이스">SortedSet</A> &lt;E&gt; <B>checkedSortedSet</B>(<A HREF="../../java/util/SortedSet.html" title="java.util 안의 인터페이스">SortedSet</A> &lt;E&gt;&nbsp;s,
                                                <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;E&gt;&nbsp;type)</PRE>
<DL>
<DD>지정된 소트 세트의 동적으로 형태 보증된 뷰를 돌려줍니다. 부정한 형태의 요소를 삽입하려고 하자, 곧바로 <tt>ClassCastException</tt> 가 throw 됩니다. 동적으로 형태 보증된 뷰가 생성되기 전은 소트 세트에 부정한 형태의 요소가 포함되지 않고, 소트 세트에의 후속의 액세스가 모두 이 뷰를 개입시켜 행해지는 경우, 소트 세트에는 부정한 형태의 요소가 포함되지 않는 것이 보증됩니다.

 <p>동적으로 형태 보증된 뷰의 사용에 대해서는,<A HREF="../../java/util/Collections.html#checkedCollection(java.util.Collection, java.lang.Class)"><CODE>checkedCollection</CODE></A>  메소드의 문서를 참조해 주세요.

 <p>반환된 소트 세트는, 지정된 소트 세트가 직렬화 가능의 경우는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 동적으로 형태 보증된 뷰가 반환되는 소트 세트<DD><CODE>type</CODE> - <tt>s</tt> 가 보관 유지하는 것이 용서된 요소의 형태
<DT><B>반환값:</B><DD>지정된 소트 세트의 동적으로 형태 보증된 뷰<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkedList(java.util.List, java.lang.Class)"><!-- --></A> <H3>
checkedList</H3>
<PRE>
public static &lt;E&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;E&gt; <B>checkedList</B>(<A HREF="../../java/util/List.html" title="java.util 안의 인터페이스">List</A> &lt;E&gt;&nbsp;list,
                                      <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;E&gt;&nbsp;type)</PRE>
<DL>
<DD>지정된 리스트의 동적으로 형태 보증된 뷰를 돌려줍니다. 부정한 형태의 요소를 삽입하려고 하자, 곧바로 <tt>ClassCastException</tt> 가 throw 됩니다. 동적으로 형태 보증된 뷰가 생성되기 전은 리스트에 부정한 형태의 요소가 포함되지 않고, 후속의 리스트에의 액세스가 모두 이 뷰를 개입시켜 행해지는 경우, 리스트에는 부정한 형태의 요소가 포함되지 않는 것이 보증됩니다. <i></i>

 <p>동적으로 형태 보증된 뷰의 사용에 대해서는,<A HREF="../../java/util/Collections.html#checkedCollection(java.util.Collection, java.lang.Class)"><CODE>checkedCollection</CODE></A>  메소드의 문서를 참조해 주세요.

 <p>반환된 리스트는, 지정된 리스트가 직렬화 가능의 경우에만 직렬화 가능하게 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>list</CODE> - 동적으로 형태 보증된 뷰가 반환되는 리스트<DD><CODE>type</CODE> - <tt>list</tt> 가 보관 유지하는 것이 용서된 요소의 형태
<DT><B>반환값:</B><DD>지정된 리스트의 동적으로 형태 보증된 뷰<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkedMap(java.util.Map, java.lang.Class, java.lang.Class)"><!-- --></A> <H3>
checkedMap</H3>
<PRE>
public static &lt;K, V&gt; <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;K, V&gt; <B>checkedMap</B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;K, V&gt;&nbsp;m,
                                        <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;K&gt;&nbsp;keyType,
                                        <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;V&gt;&nbsp;valueType)</PRE>
<DL>
<DD>지정된 맵의 동적으로 형태 보증된 뷰를 돌려줍니다. 키 또는 값이 부정한 형태를 보관 유지하는 매핑을 삽입하려고 하자, 곧바로 <tt>ClassCastException</tt> 가 throw 됩니다. 같이 키에 현재 관련지을 수 있고 있는 값을 변경하려고 하면(자), 변경이 맵 자체를 개입시켜 시도되는지, 맵의<A HREF="../../java/util/Map.html#entrySet()"><CODE>엔트리 세트</CODE></A> 뷰로부터 취득된 <A HREF="../../java/util/Map.Entry.html" title="java.util 동안의 인터페이스"><CODE>Map.Entry</CODE></A>  인스턴스를 개입시켜 시도될까에 관계없이, 곧바로 <tt>ClassCastException</tt> 가 throw 됩니다.

 <p>동적으로 형태 보증된 뷰가 생성되기 전에, 부정한 형태의 키 또는 값이 맵에 포함되지 않고, 맵에의 후속의 액세스가 모두 뷰 (또는 코레크션뷰의 1 개)를 개입시켜 행해지는 경우, 맵에 부정한 형태의 키나 값이 포함되지 않는 것이 보증됩니다.

 <p>동적으로 형태 보증된 뷰의 사용에 대해서는,<A HREF="../../java/util/Collections.html#checkedCollection(java.util.Collection, java.lang.Class)"><CODE>checkedCollection</CODE></A>  메소드의 문서를 참조해 주세요.

 <p>반환된 맵은, 지정된 맵이 직렬화 가능의 경우는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>m</CODE> - 동적으로 형태 보증된 뷰가 반환되는 맵<DD><CODE>keyType</CODE> - <tt>m</tt> 가 보관 유지하는 것이 용서된 키의 형태<DD><CODE>valueType</CODE> - <tt>m</tt> 가 보관 유지하는 것이 용서된 값의 형태
<DT><B>반환값:</B><DD>지정된 맵의 동적으로 형태 보증된 뷰<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkedSortedMap(java.util.SortedMap, java.lang.Class, java.lang.Class)"><!-- --></A> <H3>
checkedSortedMap</H3>
<PRE>
public static &lt;K, V&gt; <A HREF="../../java/util/SortedMap.html" title="java.util 내의 인터페이스">SortedMap</A> &lt;K, V&gt; <B>checkedSortedMap</B>(<A HREF="../../java/util/SortedMap.html" title="java.util 안의 인터페이스">SortedMap</A> &lt;K, V&gt;&nbsp;m,
                                                    <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;K&gt;&nbsp;keyType,
                                                    <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;V&gt;&nbsp;valueType)</PRE>
<DL>
<DD>지정된 소트 맵의 동적으로 형태 보증된 뷰를 돌려줍니다. 키 또는 값이 부정한 형태를 보관 유지하는 매핑을 삽입하려고 하자, 곧바로 <tt>ClassCastException</tt> 가 throw 됩니다. 같이 키에 현재 관련지을 수 있고 있는 값을 변경하려고 하면(자), 변경이 맵 자체를 개입시켜 시도되는지, 맵의<A HREF="../../java/util/Map.html#entrySet()"><CODE>엔트리 세트</CODE></A> 뷰로부터 취득된 <A HREF="../../java/util/Map.Entry.html" title="java.util 동안의 인터페이스"><CODE>Map.Entry</CODE></A>  인스턴스를 개입시켜 시도될까에 관계없이, 곧바로 <tt>ClassCastException</tt> 가 throw 됩니다.

 <p>동적으로 형태 보증된 뷰가 생성되기 전에, 부정한 형태의 키 또는 값이 맵에 포함되지 않고, 맵에의 후속의 액세스가 모두 뷰 (또는 코레크션뷰의 1 개)를 개입시켜 행해지는 경우, 맵에 부정한 형태의 키나 값이 포함되지 않는 것이 보증됩니다.

 <p>동적으로 형태 보증된 뷰의 사용에 대해서는,<A HREF="../../java/util/Collections.html#checkedCollection(java.util.Collection, java.lang.Class)"><CODE>checkedCollection</CODE></A>  메소드의 문서를 참조해 주세요.

 <p>반환된 맵은, 지정된 맵이 직렬화 가능의 경우는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>m</CODE> - 동적으로 형태 보증된 뷰가 반환되는 맵<DD><CODE>keyType</CODE> - <tt>m</tt> 가 보관 유지하는 것이 용서된 키의 형태<DD><CODE>valueType</CODE> - <tt>m</tt> 가 보관 유지하는 것이 용서된 값의 형태
<DT><B>반환값:</B><DD>지정된 맵의 동적으로 형태 보증된 뷰<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="emptySet()"><!-- --></A> <H3>
emptySet</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A> &lt;T&gt; <B>emptySet</B>()</PRE>
<DL>
<DD>빈 상태(empty)세트 (불변)를 돌려줍니다. 이 세트는 직렬화가 가능합니다. 같은 이름을 붙일 수 있었던 필드와는 달라, 이 메소드는 파라미터화 됩니다.

 <p>다음에, 빈 상태(empty)세트를 취득하기 위한 형 보증된 방법의 예를 나타냅니다.
 <pre>
     Set&lt;String&gt; s = Collections.emptySet();
 </pre>
구현상의 주의:이 메소드의 구현에서는, 호출할 것에 개별의 <tt>Set</tt> 객체를 작성할 필요는 없습니다. 이 메소드는 같은 이름을 붙일 수 있었던 필드를 사용한 비교 가능한 코스트가 있는 것 같은 것입니다 (이 메소드와는 달라, 필드는 형태 보증하지 않는다).
<P>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Collections.html#EMPTY_SET"><CODE>EMPTY_SET</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="emptyList()"><!-- --></A> <H3>
emptyList</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt; <B>emptyList</B>()</PRE>
<DL>
<DD>빈 상태(empty)의 리스트를 돌려줍니다 (불변). 이 리스트는 직렬화 가능합니다.

 <p>다음에, 빈 상태(empty)의 리스트를 취득하기 위한 형 보증된 방법의 예를 나타냅니다.
 <pre>
     List&lt;String&gt; s = Collections.emptyList();
 </pre>
구현상의 주의:이 메소드의 구현에서는, 각 호출할 것에 개별의 <tt>List</tt> 객체를 작성할 필요는 없습니다. 이 메소드는 같은 이름을 붙일 수 있었던 필드를 사용한 비교 가능한 코스트가 있는 것 같은 것입니다 (이 메소드와는 달라, 필드는 형태 보증하지 않는다).
<P>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Collections.html#EMPTY_LIST"><CODE>EMPTY_LIST</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="emptyMap()"><!-- --></A> <H3>
emptyMap</H3>
<PRE>
public static final &lt;K, V&gt; <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;K, V&gt; <B>emptyMap</B>()</PRE>
<DL>
<DD>빈 상태(empty)의 맵을 돌려줍니다 (불변). 이 맵은 직렬화 가능합니다.

 <p>다음에, 빈 상태(empty)세트를 취득하기 위한 형 보증된 방법의 예를 나타냅니다.
 <pre>
     Map&lt;String, Date&gt; s = Collections.emptyMap();
 </pre>
구현상의 주의:이 메소드의 구현에서는, 각 호출할 것에 개별의 <tt>Map</tt> 객체를 작성할 필요는 없습니다. 이 메소드는 같은 이름을 붙일 수 있었던 필드를 사용한 비교 가능한 코스트가 있는 것 같은 것입니다 (이 메소드와는 달라, 필드는 형태 보증하지 않는다).
<P>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Collections.html#EMPTY_MAP"><CODE>EMPTY_MAP</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="singleton(java.lang.Object)"><!-- --></A> <A NAME="singleton(T)"><!-- --></A> <H3>
singleton</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A> &lt;T&gt; <B>singleton</B>(T&nbsp;o)</PRE>
<DL>
<DD>지정된 객체만을 포함하고 있는 불변세트를 돌려줍니다. 반환되는 세트는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>o</CODE> - 반환되는 세트에 포함되고 있는 유일한 객체
<DT><B>반환값:</B><DD>지정된 객체만을 포함하고 있는 불변세트</DL>
</DD>
</DL>
<HR>

<A NAME="singletonList(java.lang.Object)"><!-- --></A> <A NAME="singletonList(T)"><!-- --></A> <H3>
singletonList</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt; <B>singletonList</B>(T&nbsp;o)</PRE>
<DL>
<DD>지정된 객체만을 포함하고 있는 불변의 리스트를 돌려줍니다. 반환되는 리스트의 요소수
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>o</CODE> - 반환되는 리스트에 포함되고 있는 유일한 객체
<DT><B>반환값:</B><DD>지정된 객체만을 포함하고 있는 불변세트<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="singletonMap(java.lang.Object,java.lang.Object)"><!-- --></A> <A NAME="singletonMap(K, V)"><!-- --></A> <H3>
singletonMap</H3>
<PRE>
public static &lt;K, V&gt; <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;K, V&gt; <B>singletonMap</B>(K&nbsp;key,
                                          V&nbsp;value)</PRE>
<DL>
<DD>지정된 값으로 지정된 키만을 매핑 하는 불변의 맵을 돌려줍니다. 반환되는 맵은 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 반환되는 맵에 포함되고 있는 유일한 키<DD><CODE>value</CODE> - 반환되는 맵에 의해 <tt>key</tt> 가 매핑 되는 값
<DT><B>반환값:</B><DD>지정된 키와 값의 매핑만이 포함되는 불변의 맵<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="nCopies(int,java.lang.Object)"><!-- --></A> <A NAME="nCopies(int, T)"><!-- --></A> <H3>
nCopies</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt; <B>nCopies</B>(int&nbsp;n,
                                  T&nbsp;o)</PRE>
<DL>
<DD>지정된 객체의 <tt>n</tt> 개의 카피로 구성되는 불변의 리스트를 돌려줍니다. 새롭게 할당할 수 있었던 데이터 객체는, 데이터 객체에의 1 개의 참조를 가지는 작은 객체입니다. 이 메소드는,<tt>List.addAll</tt> 메소드와 함께 리스트를 확장하기 위해서 사용됩니다. 반환되는 리스트는 직렬화 가능합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>n</CODE> - 반환되는 리스트의 요소수<DD><CODE>o</CODE> - 반환되는 리스트에 반복해 나타나는 요소
<DT><B>반환값:</B><DD>지정된 객체의 <tt>n</tt> 개의 카피로 구성되는 불변의 리스트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - n &lt; 0 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/util/List.html#addAll(java.util.Collection)"><CODE>List.addAll(Collection)</CODE></A> , 
<A HREF="../../java/util/List.html#addAll(int, java.util.Collection)"><CODE>List.addAll(int, Collection)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="reverseOrder()"><!-- --></A> <H3>
reverseOrder</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/Comparator.html" title="java.util 내의 인터페이스">Comparator</A> &lt;T&gt; <B>reverseOrder</B>()</PRE>
<DL>
<DD><tt>Comparable</tt> 인터페이스를 구현하는 객체의 컬렉션으로 「자연 순서 붙이고」의 역을 의무화 하는 Comparator를 돌려줍니다. 자연 순서부란, 객체 자신의 <tt>compareTo</tt> 메소드가 가리키는 순서입니다. 이것에 의해,<tt>Comparable</tt> 인터페이스를 구현하는 객체의 컬렉션 (또는 배열)을 간단하게 역자연 순서로 소트 (또는 보수) 할 수 있습니다. 예를 들어, a 가 캐릭터 라인의 배열이라고 가정합니다.  <pre>
                Arrays.sort(a, Collections.reverseOrder());
</pre> 역인 나무의 사전 편집순서 (알파벳순서)로 배열을 소트 합니다. <p>

반환되는 Comparator는 직렬화 가능합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD><tt>Comparable</tt> 인터페이스를 구현하는 객체의 컬렉션으로 역의 자연 순서를 의무화 하는 Comparator<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스"><CODE>Comparable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="reverseOrder(java.util.Comparator)"><!-- --></A> <H3>
reverseOrder</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/Comparator.html" title="java.util 내의 인터페이스">Comparator</A> &lt;T&gt; <B>reverseOrder</B>(<A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;T&gt;&nbsp;cmp)</PRE>
<DL>
<DD>지정된 Comparator의 역순서를 의무화 하는 Comparator를 돌려줍니다. 지정된 Comparator가 null 의 경우, 이 메소드는 <A HREF="../../java/util/Collections.html#reverseOrder()"><CODE>reverseOrder()</CODE></A>  와 등가가 됩니다 (즉, Comparable 인터페이스를 구현하는 객체의 컬렉션에 역의 「자연 순서」를 의무화 하는 Comparator를 돌려준다).

 <p>반환되는 Comparator는 직렬화 가능합니다 (지정된 Comparator도 직렬화 가능한가 null 의 경우).
<P>
<DD><DL>

<DT><B>반환값:</B><DD>지정된 Comparator의 역순서를 의무화 하는 Comparator<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="enumeration(java.util.Collection)"><!-- --></A> <H3>
enumeration</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/Enumeration.html" title="java.util 내의 인터페이스">Enumeration</A> &lt;T&gt; <B>enumeration</B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;T&gt;&nbsp;c)</PRE>
<DL>
<DD>지정된 컬렉션의 열거를 돌려줍니다. 컬렉션은, 열거를 필요로 하는 종래의 API 와의 상호 운용성을 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 열거가 반환되는 컬렉션
<DT><B>반환값:</B><DD>지정된 컬렉션의 열거<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Enumeration.html" title="java.util 내의 인터페이스"><CODE>Enumeration</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="list(java.util.Enumeration)"><!-- --></A> <H3>
list</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/ArrayList.html" title="java.util 내의 클래스">ArrayList</A> &lt;T&gt; <B>list</B>(<A HREF="../../java/util/Enumeration.html" title="java.util 안의 인터페이스">Enumeration</A> &lt;T&gt;&nbsp;e)</PRE>
<DL>
<DD>지정된 열거에 의해 반환된 요소를 포함한 배열 리스트를, 반환된 차례로 돌려줍니다. 이 메소드에서는, 열거를 돌려주는 종래의 API 와 컬렉션을 필요로 하는 신규 API 와의 상호 운용성을 실현하고 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 반환되는 배열 리스트의 요소를 제공하는 열거
<DT><B>반환값:</B><DD>지정된 열거에 의해 반환되는 요소를 포함한 배열 리스트<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Enumeration.html" title="java.util 내의 인터페이스"><CODE>Enumeration</CODE></A> , 
<A HREF="../../java/util/ArrayList.html" title="java.util 안의 클래스"><CODE>ArrayList</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="frequency(java.util.Collection, java.lang.Object)"><!-- --></A> <H3>
frequency</H3>
<PRE>
public static int <B>frequency</B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;? &gt;&nbsp;c,
                            <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;o)</PRE>
<DL>
<DD>지정된 컬렉션내에서, 지정된 객체와 등가인 요소의 수를 돌려줍니다. 즉, 컬렉션내에서 <tt>(o == null ?  e == null :o.equals(e))</tt> 인 요소 <tt>e</tt> 의 수를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - <tt>o</tt> 의 빈도를 판정하는 컬렉션<DD><CODE>o</CODE> - 빈도를 판정하는 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>c</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="disjoint(java.util.Collection, java.util.Collection)"><!-- --></A> <H3>
disjoint</H3>
<PRE>
public static boolean <B>disjoint</B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;? &gt;&nbsp;c1,
                               <A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;? &gt;&nbsp;c2)</PRE>
<DL>
<DD>지정된 2 개의 컬렉션에 공통의 요소가 존재하지 않는 경우,<tt>true</tt> 를 돌려줍니다.

 <p><tt>Collection</tt> 의 범용 규약에 준거하지 않는 컬렉션에 대해서 이 메소드를 사용하는 경우는, 주의가 필요합니다. 구현이, 한편의 컬렉션에 대해서 처리를 반복해 실행해, 한편의 컬렉션내에 포함될지 어떨지를 테스트하는 (또는 등가인 계산을 실행한다) 경우가 있습니다. 한편의 컬렉션이 비표준의 등가 테스트를 사용하는 경우 (순서가 등가와의 호환성을 가지지 않는 <A HREF="../../java/util/SortedSet.html" title="java.util 동안의 인터페이스"><CODE>SortedSet</CODE></A>  나,<A HREF="../../java/util/IdentityHashMap.html" title="java.util 안의 클래스"><CODE>IdentityHashMap</CODE></A>  의 키 세트와 같이) , 양쪽 모두의 컬렉션으로 같은 비표준의 등가 테스트를 사용할 필요가 있습니다.  그렇지 않은 경우의 이 메소드의 결과는 정의되고 있지 않습니다.

 <p>양쪽 모두의 파라미터내에서 같은 컬렉션을 건네주는 것은 허용 되고 있습니다.  이 경우, 컬렉션이 빈 상태(empty)의 경우에게만, 메소드는 true 를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c1</CODE> - 컬렉션<DD><CODE>c2</CODE> - 컬렉션
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 어느 쪽인가의 컬렉션이 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="addAll(java.util.Collection,java.lang.Object[])"><!-- --></A> <A NAME="addAll(java.util.Collection, T...)"><!-- --></A> <H3>
addAll</H3>
<PRE>
public static &lt;T&gt; boolean <B>addAll</B>(<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;?  super T&gt;&nbsp;c,
                                 T...&nbsp;elements)</PRE>
<DL>
<DD>지정된 모든 요소가 지정된 컬렉션에 추가합니다. 추가되는 요소는 개별적으로 지정될까 배열로서 지정됩니다. 이 편리한 메소드의 동작은,<tt>c.addAll(Arrays.asList(elements))</tt> 와 동일합니다만, 이 메소드는 대부분의 구현으로 매우 고속으로 실행됩니다.

 <p>요소를 개별적으로 지정하는 경우, 이 메소드에서는, 다음의 예의 같게, 여러종류의 요소를 기존의 컬렉션에 간단하게 추가할 수 있습니다.
 <pre>
     Collections.addAll(flavors, "Peaches 'n Plutonium", "Rocky Racoon");
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - <tt>elements</tt> 가 삽입되는 컬렉션<DD><CODE>elements</CODE> - <tt>c</tt> 에 삽입되는 요소
<DT><B>반환값:</B><DD>이 호출의 결과, 컬렉션이 변경되었을 경우는 <tt>true</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - <tt>c</tt> 가 <tt>add</tt> 오퍼레이션을 지원하지 않는 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>elements</tt> 에 1 개 이상의 null 요소가 포함되어 있어<tt>c</tt> 가 null 요소를 허가하지 않는 경우, 혹은 <tt>c</tt> 또는 <tt>elements</tt> 가 <tt>null</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>elements</tt> 의 값이 있는 프로퍼티이 원인으로,<tt>c</tt> 에 추가할 수 없는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Collection.html#addAll(java.util.Collection)"><CODE>Collection.addAll(Collection)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="newSetFromMap(java.util.Map)"><!-- --></A> <H3>
newSetFromMap</H3>
<PRE>
public static &lt;E&gt; <A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스">Set</A> &lt;E&gt; <B>newSetFromMap</B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;E,<A HREF="../../java/lang/Boolean.html" title="java.lang 안의 클래스">Boolean</A> &gt;&nbsp;map)</PRE>
<DL>
<DD>지정된 맵에 연동하는 세트를 돌려줍니다. 결과적으로 얻을 수 있는 세트에는, 그 연동하는 맵과 같은 순서, 병행성, 및 퍼포먼스 특성이 표시됩니다. 이 팩토리 메소드는, 본질적으로,<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스"><CODE>Map</CODE></A>  구현에 대응하는 <A HREF="../../java/util/Set.html" title="java.util 동안의 인터페이스"><CODE>Set</CODE></A>  구현을 제공합니다. <A HREF="../../java/util/HashMap.html" title="java.util 안의 클래스"><CODE>HashMap</CODE></A>  나 <A HREF="../../java/util/TreeMap.html" title="java.util 안의 클래스"><CODE>TreeMap</CODE></A>  등 대응하는 <A HREF="../../java/util/Set.html" title="java.util 동안의 인터페이스"><CODE>Set</CODE></A>  구현이 벌써 있는 <A HREF="../../java/util/Map.html" title="java.util 동안의 인터페이스"><CODE>Map</CODE></A>  구현에서는, 이 메소드를 사용할 필요는 없습니다.

 <p>이 메소드에 의해 반환되는 세트에서의 각각의 메소드 호출에 의해, 1 개의 예외를 제외해, 기본으로 되는 맵인가 그 <tt>keySet</tt> 뷰로 메소드 호출이 1 개만 발생합니다. <tt>addAll</tt> 메소드는, 기본으로 되는 맵의 일련의 <tt>put</tt> 호출로서 구현됩니다.

 <p>지정된 맵은, 이 메소드가 불려 간 시점에서는 빈 상태(empty)이 아니면 안되어, 이 메소드의 종료후는 직접 액세스 할 수 없습니다. 이러한 조건은, 다음의 코드의 발췌에 나타내도록(듯이), 맵이 빈 상태(empty) 상태로 작성되어 이 메소드에 직접 건네받아 맵에의 참조가 보관 유지되지 않는 경우에 보증됩니다.
 <pre>
    Set&lt;Object&gt; weakHashSet = Collections.newSetFromMap(
        new WeakHashMap&lt;Object, Boolean&gt;());
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>map</CODE> - 기본으로 되는 맵
<DT><B>반환값:</B><DD>맵에 연동하고 있는 세트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>map</tt> 가 빈 상태(empty)이 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="asLifoQueue(java.util.Deque)"><!-- --></A> <H3>
asLifoQueue</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/Queue.html" title="java.util 내의 인터페이스">Queue</A> &lt;T&gt; <B>asLifoQueue</B>(<A HREF="../../java/util/Deque.html" title="java.util 안의 인터페이스">Deque</A> &lt;T&gt;&nbsp;deque)</PRE>
<DL>
<DD><A HREF="../../java/util/Deque.html" title="java.util 안의 인터페이스"><CODE>Deque</CODE></A>  의 뷰를 후입선출 (Lifo) <A HREF="../../java/util/Queue.html" title="java.util 내의 인터페이스"><CODE>Queue</CODE></A>  로서 돌려줍니다. <tt>add</tt> 메소드는 <tt>push</tt> 에 맵 되어<tt>remove</tt> 메소드는 <tt>pop</tt> 에 맵 되어 이하와 같이  맵 됩니다. 이 뷰는,<tt>Queue</tt> 가 필요한 메소드를 사용하고 싶지만 Lifo 순서부가 필요한 경우에 유효한 일이 있습니다.

 <p>이 메소드에 의해 반환되는 큐에서의 각각의 메소드 호출에 의해, 1 개의 예외를 제외해, 기본으로 되는 양단 큐로 메소드 호출이 1 개만 발생합니다. <A HREF="../../java/util/Collection.html#addAll(java.util.Collection)"><CODE>addAll</CODE></A>  메소드는, 기본으로 되는 양단 큐의 일련의 <A HREF="../../java/util/Deque.html#addFirst(E)"><CODE>addFirst</CODE></A>  호출로서 실행됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>deque</CODE> - 양단 큐
<DT><B>반환값:</B><DD>큐<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Collections.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/util/Collection.html" title="java.util 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/util/Comparator.html" title="java.util 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/util/Collections.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Collections.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
