<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:57:16 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Proxy (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Proxy (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Proxy.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/lang/reflect/ParameterizedType.html" title="java.lang.reflect 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/lang/reflect/ReflectPermission.html" title="java.lang.reflect 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/lang/reflect/Proxy.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Proxy.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang.reflect</FONT>
<BR>
클래스 Proxy</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.lang.reflect.Proxy</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>Proxy</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
<code>Proxy</code> 는, 동적 프록시의 클래스 및 인스턴스를 생성하는 정적 메소드를 제공해, 또, 그러한 메소드에 의해 생성된 동적 프록시 클래스 모든 슈퍼 클래스이기도 합니다.

 <p>인터페이스 <code>Foo</code> 의 프록시를 생성하려면 , 다음과 같이 설정합니다.
 <pre>
InvocationHandler handler = new MyInvocationHandler(...);
Class proxyClass = Proxy.getProxyClass(
Foo.class.getClassLoader(), new Class[] { Foo.class });
Foo f = (Foo) proxyClass.
getConstructor(new Class[] { InvocationHandler.class }).
newInstance(new Object[] { handler });
 </pre>
혹은 좀 더 단순하게, 다음과 같이 설정합니다.
 <pre>
Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
new Class[] { Foo.class },
handler);
 </pre>

 <p>동적 프록시 클래스 (이하 단지 프록시 클래스라고 부른다)는, 클래스 생성의 실행시로 지정된 인터페이스의 리스트를 구현하는 클래스에서, 다음에 말하는 동작을 합니다.

프록시 인터페이스는, 프록시 클래스에 의해 구현되는 인터페이스입니다.

프록시 인스턴스는, 프록시 클래스의 인스턴스입니다.

각 프록시 인스턴스에는 관련한 「호출 핸들러」객체가 있어, 이것은 인터페이스 <A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 내의 인터페이스"><CODE>InvocationHandler</CODE></A>  를 구현하고 있습니다. 프록시 인터페이스의 1 개를 사용한 프록시 인스턴스에서의 메소드 호출은, 인스턴스의 호출 핸들러의 <A HREF="../../../java/lang/reflect/InvocationHandler.html#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])"><CODE>invoke</CODE></A>  메소드에 발송 되어 불려 간 메소드를 식별하는 <code>java.lang.reflect.Method</code> 객체, 및 인수를 포함하는 <code>Object</code> 형의 배열을 프록시 인스턴스에 인도합니다. 호출 핸들러는 encode 된 메소드 호출을 적절히 처리해, 호출 핸들러가 돌려주는 결과가, 프록시 인스턴스에서의 메소드 호출의 결과로서 돌려주어집니다.

 <p>프록시 클래스에는, 다음의 특성이 있습니다.

 <ul>
<li>프록시 클래스는 public 또는 final 로, abstract 가 아닙니다.

<li>프록시 클래스의 수식되어 있지 않은 이름은 지정되지 않습니다. 다만 캐릭터 라인 「<code>$Proxy</code>」로 시작되는 클래스명의 영역을 프록시 클래스를 위해서(때문에) 확보해 둘 필요가 있습니다.

<li>프록시 클래스는,<code>java.lang.reflect.Proxy</code> 를 상속합니다.

<li>프록시 클래스는, 작성시로 지정된 차례로 인터페이스를 구현합니다.

<li>public 이외의 인터페이스를 구현하는 경우는, 그 인터페이스와 같은 패키지에 정의됩니다. public 인터페이스를 구현하는 경우는, 프록시 클래스의 패키지는 지정되지 않습니다. 패키지의 실링은, 프록시 클래스가 실행시에 특정의 패키지로 정의되는 방해로는 되지 않습니다. 특정의 서명자를 가지는 같은 클래스 로더와 같은 패키지로 벌써 정의되고 있는 클래스에 대해서도 같습니다.

<li>프록시 클래스는, 작성시로 지정된 모든 인터페이스를 구현합니다.  이 때문에,<code>Class</code> 객체상에서 <code>getInterfaces</code> 를 호출했을 경우는, 같은 인터페이스의 리스트를 포함한 배열이, 작성시로 지정된 차례로 돌려주어집니다. <code> Class</code> 객체상에서 <code>getMethods</code> 를 호출했을 경우는, 그러한 인터페이스내의 모든 메소드를 포함한 <code>Method</code> 객체의 배열이 돌려주어집니다. <code> getMethod</code> 를 호출했을 경우는, 프록시 인터페이스내에서 목적의 메소드가 검색됩니다.

<li><A HREF="../../../java/lang/reflect/Proxy.html#isProxyClass(java.lang.Class)"><CODE>Proxy.isProxyClass</CODE></A>  메소드는,<code>Proxy.getProxyClass</code> 에 의해 반환된 프록시 클래스, 혹은 <code>Proxy.newProxyInstance</code> 에 의해 반환된 객체의 클래스등의 프록시 클래스에 인도해졌을 경우에 true 를 돌려줍니다. 그 이외의 경우는 false 를 돌려줍니다.

<li>프록시 클래스의 <code>java.security.ProtectionDomain</code> 는,<code>java.lang.Object</code> 등의, bootstrap 클래스 로더에 의해 로드 되는 시스템 클래스의 <code>java.security.ProtectionDomain</code> 와 같습니다. 프록시 클래스의 코드는, 신뢰된 시스템 코드에 의해 생성되기 (위해)때문에입니다. 표준에서는, 이 보호 도메인에 대해서 <code>java.security.AllPermission</code> 가 주어집니다.

<li>각 프록시 클래스에는, 프록시 인스턴스의 호출 핸들러를 설정하기 위해서, 1 개의 인수 즉 인터페이스 <A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 내의 인터페이스"><CODE>InvocationHandler</CODE></A>  의 구현을 취하는 1 개의 public 생성자 이 있습니다. 리플렉션 API 를 사용해 public 생성자 에 액세스 하는 것 외에,<A HREF="../../../java/lang/reflect/Proxy.html#newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler)"><CODE>Proxy.newInstance</CODE></A>  메소드를 호출해 프록시 인스턴스를 생성할 수도 있습니다. 이 메소드는 <A HREF="../../../java/lang/reflect/Proxy.html#getProxyClass(java.lang.ClassLoader, java.lang.Class...)"><CODE>Proxy.getProxyClass</CODE></A>  의 호출 동작을, 호출 핸들러를 가지는 생성자 의 호출과 결합합니다.
 </ul>

 <p>프록시 인스턴스에는, 다음의 특성이 있습니다.

 <ul>
<li><code>proxy</code> 프록시 인스턴스, 및 그 <code>Foo</code> 프록시 클래스에 의해 구현된 인터페이스에 대해서 다음의 식을 실행하면(자), true 가 돌려주어집니다.
 <pre>
<code>proxy instanceof Foo</code>
 </pre>
다음의 캐스트 조작은, 정상 종료해,<code>ClassCastException</code> 는 throw 되지 않습니다.
 <pre>
<code>(Foo) proxy</code>
 </pre>

<li>각 프록시 인스턴스에는, 그 생성자 에 인도해진, 관련하는 호출 핸들러가 있습니다. static 의 <A HREF="../../../java/lang/reflect/Proxy.html#getInvocationHandler(java.lang.Object)"><CODE>Proxy.getInvocationHandler</CODE></A>  메소드는, 그 인수로서 건네받은 프록시 인스턴스에 관련하는 호출 핸들러를 돌려줍니다.

<li>프록시 인스턴스에서의 인터페이스 메소드의 호출은, 그 메소드의 문서로 진술되고 있도록(듯이) encode 되어 호출 핸들러의 <A HREF="../../../java/lang/reflect/InvocationHandler.html#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])"><CODE>invoke</CODE></A>  메소드에 발송 됩니다.

<li>프록시 인스턴스상의 <code>java.lang.Object</code> 에 선언되고 있는 <code>hashCode</code>,<code>equals</code> 또는 <code>toString</code> 호출은, 전술한 것처럼 인터페이스 메소드 호출과 같은 방법으로, encode 되어 호출 핸들러의 <code>invoke</code> 메소드에 발송 됩니다. <code>invoke</code> 에게 건네지는 <code>Method</code> 객체의 선언 클래스는,<code>java.lang.Object</code> 입니다. <code>java.lang.Object</code> 로부터 상속되는 프록시 인스턴스의 그 외의 public 메소드는, 프록시 클래스에 의해 오버라이드(override) 되지 않습니다.  이 때문에, 이러한 메소드의 호출은,<code>java.lang.Object</code> 의 인스턴스에 대한 호출과 같게 행해집니다.
 </ul>

<h3>복수의 프록시 인터페이스로 중복 하는 메소드</h3>

 <p>복수의 인터페이스에, 같은 이름과 파라메이타시그니챠를 가지는 메소드가 포함되는 경우는, 프록시 클래스의 인터페이스의 차례가 구별됩니다. 프록시 인스턴스상에서 「중복 하는 메소드」가 불려 갔을 경우, 호출 핸들러에게 건네지는 <code>Method</code> 객체로, 프록시 메소드의 호출에 사용된 인터페이스의 참조형으로부터 선언 클래스를 할당하지 못하는 것이 있습니다. 이러한 제약이 존재하는 것은, 생성된 프록시 클래스내의 대응하는 메소드의 구현으로부터, 그 구현이 불려 갔을 때에 사용된 인터페이스를 특정할 수 없기 때문입니다. 이 때문에, 프록시 인스턴스상에서 중복 하는 메소드가 불려 갔을 경우는, 메소드 호출에 사용된 참조형 에 관계없이, 프록시 클래스의 인터페이스 리스트로 그 메소드 (직접 또는 슈퍼 인터페이스로부터 상속)를 포함한 인터페이스 가운데, 최초의 인터페이스의 메소드의 <code>Method</code> 객체가 호출해 핸들러의 <code>invoke</code> 메소드에게 건네집니다.

 <p>프록시 인터페이스에,<code>java.lang.Object</code> 의 <code>hashCode</code>,<code>equals</code>, 또는 <code>toString</code> 메소드와 같은 이름 및 파라메이타시그니챠를 가지는 메소드가 포함되는 경우는, 프록시 인스턴스상에서 그 메소드가 불려 가면(자), 호출 핸들러에게 건네지는 <code>Method</code> 객체의 선언 클래스는 <code>java.lang.Object</code> 가 됩니다. 즉, public 로 비 final 인 <code>java.lang.Object</code> 의 메소드는, 호출 핸들러에 건네주는 <code>Method</code> 객체를 결정할 때, 논리적으로 다른 프록시 인터페이스보다 우선됩니다.

 <p>중복 하는 메소드가 호출해 핸들러에 발송 되었을 경우는,<code>invoke</code> 메소드로부터 throw 할 수 있는 예외의 형태는, 체크되는 형태 가운데, 불려 가는 모든 프록시 인터페이스의 메소드로 지정되고 있는,<code>throws</code> 구의 예외의 형태에 할당할 수가 있는 것으로 한정됩니다. <code>invoke</code> 메소드가, 호출에 사용할 수 있는 프록시 인터페이스의 1 개의 메소드로 선언된 예외 타입의 어느 것에도 할당하고 할 수 없는 확인이 끝난 예외를 throw 했을 경우, 확인되어 있지 않은 <code>UndeclaredThrowableException</code> 가 프록시 인스턴스에서의 호출에 의해 throw 됩니다. 즉,<code>invoke</code> 메소드에게 건네진 <code>Method</code> 객체상에서,<code>getExceptionTypes</code> 를 호출해 예외의 형태를 취득해도,<code>invoke</code> 메소드로부터 정상적으로 throw 되지 않는 것이 있습니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 내의 인터페이스"><CODE>InvocationHandler</CODE></A> , 
<A HREF="../../../serialized-form.html#java.lang.reflect.Proxy">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 내의 인터페이스">InvocationHandler</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/reflect/Proxy.html#h">h</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 프록시 인스턴스의 호출 핸들러입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/reflect/Proxy.html#Proxy(java.lang.reflect.InvocationHandler)">Proxy</A> </B>(<A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 안의 인터페이스">InvocationHandler</A> &nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 값으로, 서브 클래스 (일반적으로은 동적 프록시 클래스)로부터 그 호출 핸들러에 새로운 <code>Proxy</code> 인스턴스를 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 내의 인터페이스">InvocationHandler</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/reflect/Proxy.html#getInvocationHandler(java.lang.Object)">getInvocationHandler</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;proxy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 프록시 인스턴스의 호출 핸들러를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/reflect/Proxy.html#getProxyClass(java.lang.ClassLoader, java.lang.Class...)">getProxyClass</A> </B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader,
              <A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;...&nbsp;interfaces)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클래스 로더와 인터페이스의 배열의 지정된 프록시 클래스의 <code>java.lang.Class</code> 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/reflect/Proxy.html#isProxyClass(java.lang.Class)">isProxyClass</A> </B>(<A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 클래스가 <code>getProxyClass</code> 메소드 또는 <code>newProxyInstance</code> 메소드를 사용해 동적으로 생성되어 프록시 클래스가 되는 경우에만, true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/reflect/Proxy.html#newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler)">newProxyInstance</A> </B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader,
                 <A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;[]&nbsp;interfaces,
                 <A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 안의 인터페이스">InvocationHandler</A> &nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 호출 핸들러에 대해서 메소드 호출을 발송 하는, 지정된 인터페이스의 프록시 클래스의 인스턴스를 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="h"><!-- --></A> <H3>
h</H3>
<PRE>
protected <A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 내의 인터페이스">InvocationHandler</A>  <B>h</B></PRE>
<DL>
<DD>이 프록시 인스턴스의 호출 핸들러입니다.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Proxy(java.lang.reflect.InvocationHandler)"><!-- --></A> <H3>
Proxy</H3>
<PRE>
protected <B>Proxy</B>(<A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 안의 인터페이스">InvocationHandler</A> &nbsp;h)</PRE>
<DL>
<DD>지정된 값으로, 서브 클래스 (일반적으로은 동적 프록시 클래스)로부터 그 호출 핸들러에 새로운 <code>Proxy</code> 인스턴스를 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>h</CODE> - 이 프록시 인스턴스의 호출 핸들러</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getProxyClass(java.lang.ClassLoader, java.lang.Class...)"><!-- --></A> <H3>
getProxyClass</H3>
<PRE>
public static <A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>getProxyClass</B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader,
                                     <A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;...&nbsp;interfaces)
                              throws <A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 내의 클래스">IllegalArgumentException</A> </PRE>
<DL>
<DD>클래스 로더와 인터페이스의 배열의 지정된 프록시 클래스의 <code>java.lang.Class</code> 객체를 돌려줍니다. 프록시 클래스는 지정된 클래스 로더에 의해 정의되어 지정된 인터페이스를 모두 구현합니다. 인터페이스의 같은 순열의 프록시 클래스가 벌써 클래스 로더에 의해 정의되고 있는 경우, 기존의 프록시 클래스가 돌려주어집니다.  그렇지 않은 경우는, 이러한 인터페이스의 프록시 클래스가 동적으로 생성되어 클래스 로더에 의해 정의됩니다.

 <p><code>Proxy.getProxyClass</code> 에 건네줄 수 있는 파라미터에는, 몇개의 제약이 있습니다.

 <ul>
<li><code>interfaces</code> 배열의 모든 <code>Class</code> 객체는, 클래스 또는 원시형은 아니고 인터페이스를 나타내지 않으면 안 된다

<li><code>interfaces</code> 배열의 복수의 요소가, 같은 <code>Class</code> 객체를 참조해서는 안 된다

<li>모든 형태의 인터페이스는, 대응하는 클래스 로더로부터 이름으로 참조할 수 없으면 안 된다. 즉, 클래스 로더가 <code>cl</code>, 각 인터페이스가 <code>i</code> 의 경우는, 다음의 식이 true 가 아니면 안된다
 <pre>
Class.forName(i.getName(), false, cl) == i
 </pre>

<li>public 이외의 인터페이스는, 모두 같은 패키지내에 없으면 안 된다.  같은 패키지내에 없는 경우는, 인터페이스가 정의되고 있는 패키지 에 관계없이, 프록시 클래스는 모든 인터페이스를 구현할 수 없다

<li>지정된 인터페이스가 같은 서명을 가지는 경우, 그러한 메소드의 임의의 조에 대해서
 <ul>
<li>임의의 메소드의 반환값의 형태가 원시형 또는 void 의 경우, 그러한 메소드는 모두 반환값의 형태가 같지 않으면 안 된다
<li>그렇지 않은 경우, 몇개의 메소드에 의한 반환값의 형태는, 나머지의 메소드에 의한 반환값의 형태 모두에 대해서 할당하고 가능하지 않으면 안 된다
 </ul>

<li>프록시 클래스를 작성할 때는, Virtual Machine 에 정의되고 있는 클래스의 제한을 넘어서는 안 된다. 예를 들어, VM 가, 클래스를 구현할 수 있는 인터페이스수를 65535 에 제한하고 있는 경우는,<code>interfaces</code> 배열의 사이즈는 65535 를 넘어서는 안 된다
 </ul>

 <p>이러한 제약에 대해서 위반이 발생했을 경우는,<code>Proxy.getProxyClass</code> 에 의해 <code>IllegalArgumentException</code> 가 throw 됩니다. <code>interfaces</code> 배열의 인수 또는 요소가 <code>null</code> 의 경우는,<code>NullPointerException</code> 가 throw 됩니다.

 <p>프록시 인터페이스는, 차례가 구별됩니다. 프록시 클래스를 2 회 요구했을 때에, 인터페이스의 편성이 같아 차례가 다른 경우는, 2 개(살)이 다른 프록시 클래스가 작성됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>loader</CODE> - 프록시 클래스를 정의하는 클래스 로더<DD><CODE>interfaces</CODE> - 프록시 클래스가 구현하는 인터페이스의 리스트
<DT><B>반환값:</B><DD>지정된 클래스 로더로 정의되어 지정된 인터페이스를 구현하는 프록시 클래스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>getProxyClass</code> 에 인도해지는 파라미터에 관한 제약중 한쪽이 지켜질 수  없었던 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>interfaces</code> 배열의 인수 또는 그 요소중 한쪽이 <code>null</code> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler)"><!-- --></A> <H3>
newProxyInstance</H3>
<PRE>
public static <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>newProxyInstance</B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader,
                                      <A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;[]&nbsp;interfaces,
                                      <A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 안의 인터페이스">InvocationHandler</A> &nbsp;h)
                               throws <A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 내의 클래스">IllegalArgumentException</A> </PRE>
<DL>
<DD>지정된 호출 핸들러에 대해서 메소드 호출을 발송 하는, 지정된 인터페이스의 프록시 클래스의 인스턴스를 돌려줍니다. 이 메소드는, 다음과 동등합니다.
 <pre>
Proxy.getProxyClass(loader, interfaces).
getConstructor(new Class[] { InvocationHandler.class }).
newInstance(new Object[] { handler });
 </pre>

 <p><code>Proxy.newProxyInstance</code> 는,<code>Proxy.getProxyClass</code> 의 경우와 같은 이유로써,<code>IllegalArgumentException</code> 를 throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>loader</CODE> - 프록시 클래스를 정의하는 클래스 로더<DD><CODE>interfaces</CODE> - 프록시 클래스가 구현하는 인터페이스의 리스트<DD><CODE>h</CODE> - 메소드 호출의 발송처의 호출 핸들러
<DT><B>반환값:</B><DD>지정된 클래스 로더로 정의되고 지정된 인터페이스를 구현하는 프록시 클래스의, 지정된 호출 핸들러를 가지는 프록시 인터페이스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>getProxyClass</code> 에 인도해지는 파라미터에 관한 제약중 한쪽이 지켜질 수  없었던 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>interfaces</code> 배열의 인수 또는 그 요소중 한쪽이 <code>null</code> 의 경우, 또는 호출해 핸들러 <code>h</code> 가 <code>null</code> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="isProxyClass(java.lang.Class)"><!-- --></A> <H3>
isProxyClass</H3>
<PRE>
public static boolean <B>isProxyClass</B>(<A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)</PRE>
<DL>
<DD>지정된 클래스가 <code>getProxyClass</code> 메소드 또는 <code>newProxyInstance</code> 메소드를 사용해 동적으로 생성되어 프록시 클래스가 되는 경우에만, true 를 돌려줍니다.

 <p>이 메소드의 신뢰성은, 이 메소드에 의해 시큐리티 보호를 할 수 있을지 어떨지를 결정할 때에 중요합니다. 이 때문에, 해당 클래스가 <code>Proxy</code> 를 확장할지 어떨지를 이 메소드의 구현으로 테스트하는 것 만으로는 충분하다고는 말할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cl</CODE> - 테스트하는 클래스
<DT><B>반환값:</B><DD>클래스가 프록시 클래스의 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>cl</code> 가 <code>null</code> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getInvocationHandler(java.lang.Object)"><!-- --></A> <H3>
getInvocationHandler</H3>
<PRE>
public static <A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 내의 인터페이스">InvocationHandler</A>  <B>getInvocationHandler</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;proxy)
                                              throws <A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 내의 클래스">IllegalArgumentException</A> </PRE>
<DL>
<DD>지정된 프록시 인스턴스의 호출 핸들러를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>proxy</CODE> - 호출 핸들러를 돌려주는 프록시 인스턴스
<DT><B>반환값:</B><DD>프록시 인스턴스의 호출 핸들러
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 인수가 프록시 인스턴스가 아닌 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Proxy.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/lang/reflect/ParameterizedType.html" title="java.lang.reflect 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/lang/reflect/ReflectPermission.html" title="java.lang.reflect 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/lang/reflect/Proxy.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Proxy.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
