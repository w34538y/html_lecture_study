<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:55:19 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
AffineTransform (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="AffineTransform (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AffineTransform.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;전의 클래스 &nbsp;
&nbsp;<A HREF="../../../java/awt/geom/Arc2D.html" title="java.awt.geom 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/awt/geom/AffineTransform.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="AffineTransform.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt.geom</FONT>
<BR>
클래스 AffineTransform</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.awt.geom.AffineTransform</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> , <A HREF="../../../java/lang/Cloneable.html" title="java.lang 안의 인터페이스">Cloneable</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>AffineTransform</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스">Cloneable</A> , <A HREF="../../../java/io/Serializable.html" title="java.io 안의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
<code>AffineTransform</code> 클래스는, 선의 직선성과 평행성을 유지한채로 2 차원 좌표간의 선형 매핑을 실행하는 2 차원 아핀 변환을 표현합니다. 아핀 변환은, 일련의 평행이동, 슬캘링, 반전, 회전, 변형에 의해 구성됩니다.  &nbsp;<p>
이러한 좌표변화는, 암묵으로 지정된 [ 0 0 1 ] 이라고 하는 맨 마지막 줄을 가지는 3 행× 3 열의 행렬에 의해 표현할 수 있습니다. 이 행렬은, 다음의 처리에 따라, 좌표를 열이라고 봐, 좌표 벡터를 행렬로 곱셈하는 것에 의해, 전송원좌표 <code>(x, y)</code> 를 전송처 좌표 <code>(x', y')</code> 로 변환합니다.
 <pre>
        [ x']   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]
        [ y'] = [  m10  m11  m12  ] [ y ] = [ m10x + m11y + m12 ]
        [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]
 </pre>
 <p>
<a name="quadrantapproximation"><h4>90 번 회전의 처리</h4></a>  &nbsp;<p>
<code>AffineTransform</code> 클래스의 <code>rotate</code> 메소드의 변화(variation)안에는, 배정밀도치의 인수로 회전 각도 (라디안)를 지정하는 것이 있습니다. 이러한 메소드에는, 약 90 번 ( 및 180 번, 270 번, 360 번등의 배수)의 회전에 대해서 특수한 처리가 준비되어 있어 일반적인 4분원 회전은 보다 효율적으로 처리됩니다. 이 특수한 처리에 의해, 90 번의 배수에 근사적인 각도를 정확하게 90 번의 배수로서 취급할 수가 있습니다. 90 번의 수배정도인 경우, 4분원 회전으로서 다루어지는 각도의 범위는 약 0.00000121 번의 폭입니다. 이 섹션에서는, 이러한 특수한 처리가 필요하게 되는 이유와 그 구현 방법에 대해 설명합니다.  &nbsp;<p>
90 번은 라디안으로 <code>PI/2</code> 와 나타내져 한편 PI 는 초월수 (그 때문에 무리수)이기 (위해)때문에, 90 번의 배수를 라디안으로 계측 된 유한의 배정밀도치로서 정확하게 나타낼 수 없습니다. 그 때문에, 유한의 배수도치를 사용해 4분원 회전 (90, 180, 270, 360 도)을 표현하는 것은 이론적으로 불가능합니다. 배정밀도 부동 소수점치를 사용하면,<code>PI/2</code> 의 배수 (0 이외)에 매우 가까운 값을 얻을 수 있습니다만, 정현 (sin) 또는 여현 (cos)으로 정확하게 0.0, 1.0, 또는 -1. 0 을 얻으려면  충분히 가깝다고는 말할 수 없습니다. 그 때문에,<code>Math.sin()</code> 및 <code>Math.cos()</code> 의 구현에서는,<code>Math.sin(0.0)</code> 의 경우를 제외해 0.0 을 돌려줄 것은 없습니다. 다만 같은 구현이어도, 90 번의 배수 마다 일정 범위내의 값에 대해서는, 정확히 1.0 및 -1. 0 을 돌려줍니다. 이것은, 올바른 응답이 1.0 또는 -1. 0 에 매우 가깝기 때문에, 배정밀도의 유효 숫자에서는, 0.0 에 가까운 값의 경우와 동일한 정도의 정확함으로 차이를 나타낼 수가 없기 때문입니다.  &nbsp;<p>
이러한 문제에 의한 최종 결과적으로,<code>Math.sin()</code> 메소드 및 <code>Math.cos()</code> 메소드가 이러한 라디안 베이스의 회전 조작중에 발생하는 행렬의 변경에 대해서 값을 직접 생성하기 위해서 사용되는 경우는, 정현 및 여현으로 취득되는 0.0 이외의 값이 원인으로 행렬이 조금 다르기 (위해)때문에, 얻을 수 있는 변형은 <code>rotate(Math.PI/2. 0)</code> 과 같이 간단한 경우여도 4분원 회전으로서 엄밀하게 분류되지 않습니다. 이러한 변형이 4분원 회전으로서 분류되지 않는 경우, 변형의 종류에 근거해 후속의 조작을 최적화하려고 하는 그 이후의 코드는, 가장 범용적인 구현에 위탁됩니다.  &nbsp;<p>
4분원 회전은 매우 자주(잘) 행해지는 조작이기 (위해)때문에, 회전을 변형에 적용하는 경우와 얻을 수 있던 변형을 좌표에 적용하는 경우의 양쪽 모두로, 이 클래스는 4분원 회전을 어느 정도 빨리 처리할 수 없으면 안됩니다. 이러한 최적화 처리를 실현하기 위해서(때문에), 라디안으로 계측 된 회전 각도를 사용하는 메소드에서는, 4분원 회전을 의도한 각도를 검출하면(자), 4분원 회전으로서 취급합니다. 그 때문에 이러한 메소드에서는,<code>Math.sin(<em>theta</em>)</code> 와 <code>Math.cos(<em>theta</em>)</code> 중 한쪽이 정확하게 1.0 또는 -1. 0 을 돌려주는 경우에, 각도 <em>theta</em> 를 4분원 회전으로서 취급합니다. 기준으로서<code>Math.PI/2. 0</code> 의 수배정도의 경우에, 이 프로퍼티은 약 0.0000000211 라디안 (또는 0.00000121 번)의 범위에서 true 를 보관 유지합니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../serialized-form.html#java.awt.geom.AffineTransform">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP">TYPE_FLIP</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 flag bit는, 이 객체에 의해 정의되는 변환이, 다른 flag bit에 의해 지정되는 변환에 가세해, 어느 축을 중심으로 하는 경상반전을 실행하는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION">TYPE_GENERAL_ROTATION</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 flag bit는, 이 객체에 의해 정의되는 변환이, 다른 flag bit에 의해 지정되는 변환에 가세해, 임의의 각도에 의한 회전을 실행하는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE">TYPE_GENERAL_SCALE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 flag bit는, 이 객체에 의해 정의되는 변환이, 다른 flag bit에 의해 지정되는 변환에 가세해, 범용적인 슬캘링을 실행하는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM">TYPE_GENERAL_TRANSFORM</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 정수는, 이 객체에 의해 정의되는 변환이, 입력 좌표의 임의의 변환을 실행하는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY">TYPE_IDENTITY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 정수는, 이 객체에 의해 정의되는 변환이 항등변환인 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_MASK_ROTATION">TYPE_MASK_ROTATION</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 정수는, 회전 flag bit의 몇개의 비트 마스크입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_MASK_SCALE">TYPE_MASK_SCALE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 정수는, 스케일 flag bit의 몇개의 비트 마스크입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION">TYPE_QUADRANT_ROTATION</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 flag bit는, 이 객체에 의해 정의되는 변환이, 다른 flag bit에 의해 지정되는 변환에 가세해, 90 번의 배수에 4분원 회전을 실행하는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION">TYPE_TRANSLATION</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 flag bit는, 이 객체에 의해 정의되는 변환이, 다른 flag bit에 의해 지정되는 변환에 가세해, 1 개의 이동을 실행하는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE">TYPE_UNIFORM_SCALE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 flag bit는, 이 객체에 의해 정의되는 변환이, 다른 flag bit에 의해 지정되는 변환에 가세해, 한결같은 슬캘링을 실행하는 것을 나타냅니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#AffineTransform()">AffineTransform</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;항등변환을 표현하는 새로운 <code>AffineTransform</code> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#AffineTransform(java.awt.geom.AffineTransform)">AffineTransform</A> </B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>AffineTransform</code> 객체의 카피인, 새로운 <code>AffineTransform</code> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#AffineTransform(double[])">AffineTransform</A> </B>(double[]&nbsp;flatmatrix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 변환 행렬의 4 개의 비평행이동 엔트리 또는 6 개의 지정 가능 엔트리의 어느 쪽인지를 표현하는 배정밀도치의 배열로부터, 새로운 <code>AffineTransform</code> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#AffineTransform(double, double, double, double, double, double)">AffineTransform</A> </B>(double&nbsp;m00,
                double&nbsp;m10,
                double&nbsp;m01,
                double&nbsp;m11,
                double&nbsp;m02,
                double&nbsp;m12)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 변환 행렬의 6 개의 지정 가능 엔트리를 표현하는 6 개의 배정밀도치로부터, 새로운 <code>AffineTransform</code> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#AffineTransform(float[])">AffineTransform</A> </B>(float[]&nbsp;flatmatrix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 변환 행렬의 4 개의 비평행이동 엔트리 또는 6 개의 지정 가능 엔트리의 어느 쪽인지를 표현하는 부동 소수점치의 배열로부터, 새로운 <code>AffineTransform</code> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#AffineTransform(float, float, float, float, float, float)">AffineTransform</A> </B>(float&nbsp;m00,
                float&nbsp;m10,
                float&nbsp;m01,
                float&nbsp;m11,
                float&nbsp;m02,
                float&nbsp;m12)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 변환 행렬의 6 개의 지정 가능 엔트리를 표현하는 6 개의 부동 소수점치로부터, 새로운 <code>AffineTransform</code> 를 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#clone()">clone</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>AffineTransform</code> 객체의 카피를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#concatenate(java.awt.geom.AffineTransform)">concatenate</A> </B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Tx</code> 에 의해 원의 사용자 공간에 맵 된 새로운 사용자 공간을 제공하기 위해서 가장 일반적으로 사용되는 방법으로,<code>AffineTransform</code> <code>Tx</code> 를 이 <code>AffineTransform</code> Cx 에 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#createInverse()">createInverse</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;역변환을 표현하는 <code>AffineTransform</code> 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#createTransformedShape(java.awt.Shape)">createTransformedShape</A> </B>(<A HREF="../../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;pSrc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>Shape</code> 를 이 변환에 의해 변환해, 그 <code>Shape</code> 의 기하학적 도형에 의해 정의되는 새로운 <A HREF="../../../java/awt/Shape.html" title="java.awt 동안의 인터페이스"><CODE>Shape</CODE></A>  객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#deltaTransform(double[], int, double[], int, int)">deltaTransform</A> </B>(double[]&nbsp;srcPts,
               int&nbsp;srcOff,
               double[]&nbsp;dstPts,
               int&nbsp;dstOff,
               int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에 의해 상대적인 거리 벡터의 배열을 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 내의 클래스">Point2D</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#deltaTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)">deltaTransform</A> </B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptSrc,
               <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptDst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ptSrc</code> 에 의해 지정되는 상대적인 거리 벡터를 변환해, 그 결과를 <code>ptDst</code> 에 포함합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#equals(java.lang.Object)">equals</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>AffineTransform</code> 이, 지정된 인수와 같은 아핀 좌표변화를 표현하는 경우에 <code>true</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getDeterminant()">getDeterminant</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;변환의 행렬 표현의 행렬식을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])">getMatrix</A> </B>(double[]&nbsp;flatmatrix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬내의 6 개의 지정 가능한 값을 꺼내, 배정밀도치의 배열에 배치합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getQuadrantRotateInstance(int)">getQuadrantRotateInstance</A> </B>(int&nbsp;numquadrants)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 수의 4분원만 좌표를 회전시키는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getQuadrantRotateInstance(int, double, double)">getQuadrantRotateInstance</A> </B>(int&nbsp;numquadrants,
                          double&nbsp;anchorx,
                          double&nbsp;anchory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 엥커 포인트를 중심으로 해, 지정된 수의 4분원만 좌표를 회전시키는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getRotateInstance(double)">getRotateInstance</A> </B>(double&nbsp;theta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;회전 변환을 표현하는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getRotateInstance(double, double)">getRotateInstance</A> </B>(double&nbsp;vecx,
                  double&nbsp;vecy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;회전 벡터에 따라 좌표를 회전시키는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getRotateInstance(double, double, double)">getRotateInstance</A> </B>(double&nbsp;theta,
                  double&nbsp;anchorx,
                  double&nbsp;anchory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;엥커 포인트를 중심으로 해 좌표를 회전시키는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getRotateInstance(double, double, double, double)">getRotateInstance</A> </B>(double&nbsp;vecx,
                  double&nbsp;vecy,
                  double&nbsp;anchorx,
                  double&nbsp;anchory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;회전 벡터에 따라, 엥커 포인트를 중심으로 해 좌표를 회전시키는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getScaleInstance(double, double)">getScaleInstance</A> </B>(double&nbsp;sx,
                 double&nbsp;sy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;슬캘링 변환을 표현하는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getScaleX()">getScaleX</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬의 X 좌표 슬캘링 요소 (m00)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getScaleY()">getScaleY</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬의 Y 좌표 슬캘링 요소 (m11)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getShearInstance(double, double)">getShearInstance</A> </B>(double&nbsp;shx,
                 double&nbsp;shy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;셔링 변환을 표현하는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getShearX()">getShearX</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬의 X 좌표 셔링 요소 (m01)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getShearY()">getShearY</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬의 Y 좌표 셔링 요소 (m10)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getTranslateInstance(double, double)">getTranslateInstance</A> </B>(double&nbsp;tx,
                     double&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;평행이동 변환을 표현하는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getTranslateX()">getTranslateX</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬의 평행이동 요소 (m02)의 X 좌표를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getTranslateY()">getTranslateY</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬의 평행이동 요소 (m12)의 Y 좌표를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getType()">getType</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환의 변환 프로퍼티을 기술하는 flag bit를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#hashCode()">hashCode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환의 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#inverseTransform(double[], int, double[], int, int)">inverseTransform</A> </B>(double[]&nbsp;srcPts,
                 int&nbsp;srcOff,
                 double[]&nbsp;dstPts,
                 int&nbsp;dstOff,
                 int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에 의해 배정밀도의 좌표의 배열을 역변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 내의 클래스">Point2D</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#inverseTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)">inverseTransform</A> </B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptSrc,
                 <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptDst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>ptSrc</code> 를 역변환해, 그 결과를 <code>ptDst</code> 에 포함합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#invert()">invert</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 자신의 역변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#isIdentity()">isIdentity</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>AffineTransform</code> 이 항등변환인 경우에 <code>true</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#preConcatenate(java.awt.geom.AffineTransform)">preConcatenate</A> </B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Tx</code> 가 기존의 사용자 공간은 아니고 절대 픽셀 공간을 기준(�좌표변화를 변경하는 등 일반적으로는 그다지 사용되지 않는 방법으로,<code>AffineTransform</code> <code>Tx</code> 를 이 <code>AffineTransform</code> Cx 에 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#quadrantRotate(int)">quadrantRotate</A> </B>(int&nbsp;numquadrants)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을, 지정된 수의 4분원만 좌표를 회전시키는 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#quadrantRotate(int, double, double)">quadrantRotate</A> </B>(int&nbsp;numquadrants,
               double&nbsp;anchorx,
               double&nbsp;anchory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을, 지정된 엥커 포인트를 중심으로 해, 지정된 수의 4분원만 좌표를 회전시키는 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#rotate(double)">rotate</A> </B>(double&nbsp;theta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 회전 변환에 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#rotate(double, double)">rotate</A> </B>(double&nbsp;vecx,
       double&nbsp;vecy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을, 회전 벡터에 따라 좌표를 회전시키는 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#rotate(double, double, double)">rotate</A> </B>(double&nbsp;theta,
       double&nbsp;anchorx,
       double&nbsp;anchory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을, 엥커 포인트를 중심으로 해 좌표를 회전하는 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#rotate(double, double, double, double)">rotate</A> </B>(double&nbsp;vecx,
       double&nbsp;vecy,
       double&nbsp;anchorx,
       double&nbsp;anchory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을, 회전 벡터에 따라, 엥커 포인트를 중심으로 해 좌표를 회전시키는 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#scale(double, double)">scale</A> </B>(double&nbsp;sx,
      double&nbsp;sy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 슬캘링 변환에 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToIdentity()">setToIdentity</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 항등변환으로 다시 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToQuadrantRotation(int)">setToQuadrantRotation</A> </B>(int&nbsp;numquadrants)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을, 지정된 수의 4분원만 좌표를 회전시키는 회전 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToQuadrantRotation(int, double, double)">setToQuadrantRotation</A> </B>(int&nbsp;numquadrants,
                      double&nbsp;anchorx,
                      double&nbsp;anchory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을, 지정된 엥커 포인트를 중심으로 해, 지정된 수의 4분원만 좌표를 회전시키는, 평행이동 후의 회전 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToRotation(double)">setToRotation</A> </B>(double&nbsp;theta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 회전 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToRotation(double, double)">setToRotation</A> </B>(double&nbsp;vecx,
              double&nbsp;vecy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을, 회전 벡터에 따라 좌표를 회전시키는 회전 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToRotation(double, double, double)">setToRotation</A> </B>(double&nbsp;theta,
              double&nbsp;anchorx,
              double&nbsp;anchory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 평행이동 후의 회전 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToRotation(double, double, double, double)">setToRotation</A> </B>(double&nbsp;vecx,
              double&nbsp;vecy,
              double&nbsp;anchorx,
              double&nbsp;anchory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을, 회전 벡터에 따라, 엥커 포인트를 중심으로 해 좌표를 회전시키는 회전 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToScale(double, double)">setToScale</A> </B>(double&nbsp;sx,
           double&nbsp;sy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 슬캘링 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToShear(double, double)">setToShear</A> </B>(double&nbsp;shx,
           double&nbsp;shy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 셔링 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToTranslation(double, double)">setToTranslation</A> </B>(double&nbsp;tx,
                 double&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 평행이동 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setTransform(java.awt.geom.AffineTransform)">setTransform</A> </B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을, 지정된 <code>AffineTransform</code> 객체내의 변환의 카피로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setTransform(double, double, double, double, double, double)">setTransform</A> </B>(double&nbsp;m00,
             double&nbsp;m10,
             double&nbsp;m01,
             double&nbsp;m11,
             double&nbsp;m02,
             double&nbsp;m12)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 6 개의 배정밀도치에 의해 지정되고 있는 행렬로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#shear(double, double)">shear</A> </B>(double&nbsp;shx,
      double&nbsp;shy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 셔링 변환에 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스"><CODE>Object</CODE></A>  의 값을 나타내는 <code>String</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#transform(double[], int, double[], int, int)">transform</A> </B>(double[]&nbsp;srcPts,
          int&nbsp;srcOff,
          double[]&nbsp;dstPts,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에 의해, 배정밀도의 좌표의 배열을 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#transform(double[], int, float[], int, int)">transform</A> </B>(double[]&nbsp;srcPts,
          int&nbsp;srcOff,
          float[]&nbsp;dstPts,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에 의해 배정밀도의 좌표의 배열을 변환해, 결과를 float 치의 배열에 포함합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#transform(float[], int, double[], int, int)">transform</A> </B>(float[]&nbsp;srcPts,
          int&nbsp;srcOff,
          double[]&nbsp;dstPts,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에 의해 부동 소수점의 좌표의 배열을 변환해, 결과를 double 치의 배열에 포함합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#transform(float[], int, float[], int, int)">transform</A> </B>(float[]&nbsp;srcPts,
          int&nbsp;srcOff,
          float[]&nbsp;dstPts,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에 의해, 부동 소수점의 좌표의 배열을 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#transform(java.awt.geom.Point2D[], int, java.awt.geom.Point2D[], int, int)">transform</A> </B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> []&nbsp;ptSrc,
          int&nbsp;srcOff,
          <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> []&nbsp;ptDst,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에 의해 포인트 객체의 배열을 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 내의 클래스">Point2D</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#transform(java.awt.geom.Point2D, java.awt.geom.Point2D)">transform</A> </B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptSrc,
          <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptDst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>ptSrc</code> 를 변환해, 그 결과를 <code>ptDst</code> 에 포함합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#translate(double, double)">translate</A> </B>(double&nbsp;tx,
          double&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 평행이동 변환에 연결합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="TYPE_IDENTITY"><!-- --></A> <H3>
TYPE_IDENTITY</H3>
<PRE>
public static final int <B>TYPE_IDENTITY</B></PRE>
<DL>
<DD>이 정수는, 이 객체에 의해 정의되는 변환이 항등변환인 것을 나타냅니다. 항등변환에서는, 출력 좌표가 항상 입력 좌표와 같게 됩니다. 이 변환이 항등변환이 아닌 경우, 형태는 정수 GENERAL_TRANSFORM 인가, 이 변환이 실행하는 다양한 좌표변화를 위한 적절한 flag bit의 편성의 어딘가에 됩니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A> , 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_IDENTITY">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_TRANSLATION"><!-- --></A> <H3>
TYPE_TRANSLATION</H3>
<PRE>
public static final int <B>TYPE_TRANSLATION</B></PRE>
<DL>
<DD>이 flag bit는, 이 객체에 의해 정의되는 변환이, 다른 flag bit에 의해 지정되는 변환에 가세해, 1 개의 이동을 실행하는 것을 나타냅니다. 이동에서는, 벡터의 길이나 각도를 바꾸지 않고 좌표를 x 방향과 y 방향으로 일정량만 이동합니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A> , 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_TRANSLATION">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_UNIFORM_SCALE"><!-- --></A> <H3>
TYPE_UNIFORM_SCALE</H3>
<PRE>
public static final int <B>TYPE_UNIFORM_SCALE</B></PRE>
<DL>
<DD>이 flag bit는, 이 객체에 의해 정의되는 변환이, 다른 flag bit에 의해 지정되는 변환에 가세해, 한결같은 슬캘링을 실행하는 것을 나타냅니다. 일률적인 슬캘링에서는, 벡터간의 각도를 바꾸지 않고 벡터의 길이를 x 방향과 y 방향의 어느 쪽에도 일정량만 곱셈합니다. 이 flag bit는, TYPE_GENERAL_SCALE 플래그와 서로 배타적입니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A> , 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_UNIFORM_SCALE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_GENERAL_SCALE"><!-- --></A> <H3>
TYPE_GENERAL_SCALE</H3>
<PRE>
public static final int <B>TYPE_GENERAL_SCALE</B></PRE>
<DL>
<DD>이 flag bit는, 이 객체에 의해 정의되는 변환이, 다른 flag bit에 의해 지정되는 변환에 가세해, 범용적인 슬캘링을 실행하는 것을 나타냅니다. 범용적인 슬캘링에서는, 수직인 벡터간의 각도를 바꾸지 않고 벡터의 길이를 x 방향과 y 방향으로 다른 양만 곱셈합니다. 이 flag bit는, TYPE_UNIFORM_SCALE 플래그와 서로 배타적입니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A> , 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_GENERAL_SCALE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_MASK_SCALE"><!-- --></A> <H3>
TYPE_MASK_SCALE</H3>
<PRE>
public static final int <B>TYPE_MASK_SCALE</B></PRE>
<DL>
<DD>이 정수는, 스케일 flag bit의 몇개의 비트 마스크입니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A> , 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_MASK_SCALE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_FLIP"><!-- --></A> <H3>
TYPE_FLIP</H3>
<PRE>
public static final int <B>TYPE_FLIP</B></PRE>
<DL>
<DD>이 flag bit는, 이 객체에 의해 정의되는 변환이, 다른 flag bit에 의해 지정되는 변환에 가세해, 어느 축을 중심으로 하는 경상반전을 실행하는 것을 나타냅니다.  경상반전에 의해, 일반적으로은 오른손의 좌표계가 왼손의 좌표계로 변경됩니다. 오른손의 좌표계는, 오른손의 엄지의 첨단을 응시하고 있는 상태로 엄지 이외의 손가락을 굽히는 것과 같은 방향으로, 정의 X 축이 반시계방향으로 회전해 정의 Y 축으로 겹치는 것입니다. 왼손의 좌표계는, 왼손의 엄지 이외를 굽히는 것과 같은 방향으로, 정의 X 축이 시계 방향으로 회전해 정의 Y 축으로 겹치는 것입니다. 적절한 조정 회전을 지정하면(자) 회전의 각도는 모두 같게 되므로, 원의 반전 또는 밀러 변환의 각도를 판정하는 산술적 방법은 없습니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A> , 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_FLIP">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_QUADRANT_ROTATION"><!-- --></A> <H3>
TYPE_QUADRANT_ROTATION</H3>
<PRE>
public static final int <B>TYPE_QUADRANT_ROTATION</B></PRE>
<DL>
<DD>이 flag bit는, 이 객체에 의해 정의되는 변환이, 다른 flag bit에 의해 지정되는 변환에 가세해, 90 번의 배수에 4분원 회전을 실행하는 것을 나타냅니다. 회전에서는, 벡터의 길이를 바꾸지 않고 , 원의 방향 에 관계없이 같은 양만 벡터의 각도를 변경합니다. 이 flag bit는, TYPE_GENERAL_ROTATION 플래그와 서로 배타적입니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A> , 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_QUADRANT_ROTATION">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_GENERAL_ROTATION"><!-- --></A> <H3>
TYPE_GENERAL_ROTATION</H3>
<PRE>
public static final int <B>TYPE_GENERAL_ROTATION</B></PRE>
<DL>
<DD>이 flag bit는, 이 객체에 의해 정의되는 변환이, 다른 flag bit에 의해 지정되는 변환에 가세해, 임의의 각도에 의한 회전을 실행하는 것을 나타냅니다. 회전에서는, 벡터의 길이를 바꾸지 않고 , 원의 방향 에 관계없이 같은 양만 벡터의 각도를 변경합니다. 이 flag bit는, TYPE_QUADRANT_ROTATION 플래그와 서로 배타적입니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A> , 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_GENERAL_ROTATION">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_MASK_ROTATION"><!-- --></A> <H3>
TYPE_MASK_ROTATION</H3>
<PRE>
public static final int <B>TYPE_MASK_ROTATION</B></PRE>
<DL>
<DD>이 정수는, 회전 flag bit의 몇개의 비트 마스크입니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A> , 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_MASK_ROTATION">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_GENERAL_TRANSFORM"><!-- --></A> <H3>
TYPE_GENERAL_TRANSFORM</H3>
<PRE>
public static final int <B>TYPE_GENERAL_TRANSFORM</B></PRE>
<DL>
<DD>이 정수는, 이 객체에 의해 정의되는 변환이, 입력 좌표의 임의의 변환을 실행하는 것을 나타냅니다. 이 변환을 상기의 정수의 어느 쪽인가에 분류되는 경우, 형태는 정수 TYPE_IDENTITY 인가, 이 변환이 실행하는 다양한 좌표변화를 위한 적절한 flag bit의 편성의 어딘가에 됩니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A> , 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_GENERAL_TRANSFORM">정수 필드치</A> </DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AffineTransform()"><!-- --></A> <H3>
AffineTransform</H3>
<PRE>
public <B>AffineTransform</B>()</PRE>
<DL>
<DD>항등변환을 표현하는 새로운 <code>AffineTransform</code> 를 구축합니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DL>
<HR>

<A NAME="AffineTransform(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
AffineTransform</H3>
<PRE>
public <B>AffineTransform</B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</PRE>
<DL>
<DD>지정된 <code>AffineTransform</code> 객체의 카피인, 새로운 <code>AffineTransform</code> 를 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>Tx</CODE> - 카피하는 <code>AffineTransform</code> 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DL>
<HR>

<A NAME="AffineTransform(float, float, float, float, float, float)"><!-- --></A> <H3>
AffineTransform</H3>
<PRE>
public <B>AffineTransform</B>(float&nbsp;m00,
                       float&nbsp;m10,
                       float&nbsp;m01,
                       float&nbsp;m11,
                       float&nbsp;m02,
                       float&nbsp;m12)</PRE>
<DL>
<DD>3×3 변환 행렬의 6 개의 지정 가능 엔트리를 표현하는 6 개의 부동 소수점치로부터, 새로운 <code>AffineTransform</code> 를 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>m00</CODE> - 3×3 행렬의 X 좌표 슬캘링 요소<DD><CODE>m10</CODE> - 3×3 행렬의 Y 좌표 셔링 요소<DD><CODE>m01</CODE> - 3×3 행렬의 X 좌표 셔링 요소<DD><CODE>m11</CODE> - 3×3 행렬의 Y 좌표 슬캘링 요소<DD><CODE>m02</CODE> - 3×3 행렬의 X 좌표 평행이동 요소<DD><CODE>m12</CODE> - 3×3 행렬의 Y 좌표 평행이동 요소<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DL>
<HR>

<A NAME="AffineTransform(float[])"><!-- --></A> <H3>
AffineTransform</H3>
<PRE>
public <B>AffineTransform</B>(float[]&nbsp;flatmatrix)</PRE>
<DL>
<DD>3×3 변환 행렬의 4 개의 비평행이동 엔트리 또는 6 개의 지정 가능 엔트리의 어느 쪽인지를 표현하는 부동 소수점치의 배열로부터, 새로운 <code>AffineTransform</code> 를 구축합니다. 각 치는, 배열로부터 {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;[m02&nbsp;m12]} 라고 하는 형식에서 꺼내집니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>flatmatrix</CODE> - 새로운 <code>AffineTransform</code> 객체로 설정된다
 각 치를 포함하고 있는 float 치의 배열. 배열의 길이는
 4 이상으로 보여진다. 배열의 길이가 
 6 보다 작은 경우, 최초의 4 개의 값만이 취득된다. 배열의
 길이가 6 보다 큰 경우, 최초의 6 개의 값이 취득되는<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DL>
<HR>

<A NAME="AffineTransform(double, double, double, double, double, double)"><!-- --></A> <H3>
AffineTransform</H3>
<PRE>
public <B>AffineTransform</B>(double&nbsp;m00,
                       double&nbsp;m10,
                       double&nbsp;m01,
                       double&nbsp;m11,
                       double&nbsp;m02,
                       double&nbsp;m12)</PRE>
<DL>
<DD>3×3 변환 행렬의 6 개의 지정 가능 엔트리를 표현하는 6 개의 배정밀도치로부터, 새로운 <code>AffineTransform</code> 를 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>m00</CODE> - 3×3 행렬의 X 좌표 슬캘링 요소<DD><CODE>m10</CODE> - 3×3 행렬의 Y 좌표 셔링 요소<DD><CODE>m01</CODE> - 3×3 행렬의 X 좌표 셔링 요소<DD><CODE>m11</CODE> - 3×3 행렬의 Y 좌표 슬캘링 요소<DD><CODE>m02</CODE> - 3×3 행렬의 X 좌표 평행이동 요소<DD><CODE>m12</CODE> - 3×3 행렬의 Y 좌표 평행이동 요소<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DL>
<HR>

<A NAME="AffineTransform(double[])"><!-- --></A> <H3>
AffineTransform</H3>
<PRE>
public <B>AffineTransform</B>(double[]&nbsp;flatmatrix)</PRE>
<DL>
<DD>3×3 변환 행렬의 4 개의 비평행이동 엔트리 또는 6 개의 지정 가능 엔트리의 어느 쪽인지를 표현하는 배정밀도치의 배열로부터, 새로운 <code>AffineTransform</code> 를 구축합니다. 각 치는, 배열로부터 {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;[m02&nbsp;m12]} 라고 하는 형식에서 꺼내집니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>flatmatrix</CODE> - 새로운 <code>AffineTransform</code> 객체로 설정된다
 각 치를 포함하고 있는 double 치의 배열. 배열의 길이는
 4 이상으로 보여진다. 배열의 길이가 
 6 보다 작은 경우, 최초의 4 개의 값만이 취득된다. 배열의
 길이가 6 보다 큰 경우, 최초의 6 개의 값이 취득되는<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getTranslateInstance(double, double)"><!-- --></A> <H3>
getTranslateInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getTranslateInstance</B>(double&nbsp;tx,
                                                   double&nbsp;ty)</PRE>
<DL>
<DD>평행이동 변환을 표현하는 변환을 돌려줍니다. 반환되는 변환의 행렬 표현은, 다음과 같이 됩니다.
 <pre>
                [   1    0    tx  ]
                [   0    1    ty  ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tx</CODE> - 좌표가 X 축방향으로 평행이동 된다
 거리<DD><CODE>ty</CODE> - 좌표가 Y 축방향으로 평행이동 된다
 거리
<DT><B>반환값:</B><DD>지정된 벡터로 작성된,
        평행이동 변환을 나타내는 <code>AffineTransform</code> 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRotateInstance(double)"><!-- --></A> <H3>
getRotateInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getRotateInstance</B>(double&nbsp;theta)</PRE>
<DL>
<DD>회전 변환을 표현하는 변환을 돌려줍니다. 반환되는 변환의 행렬 표현은, 다음과 같이 됩니다.
 <pre>
                [   cos(theta)    -sin(theta)    0   ]
                [   sin(theta)     cos(theta)    0   ]
                [       0              0         1   ]
 </pre>
정의 각도 theta 로 회전하면(자), 정의 X 축의 점이 정의 Y 축으로 향해 회전합니다. 전술의 「<a href="#quadrantapproximation">90 번 회전의 처리</a>」의 설명도 참조해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 계측 한 회전 각도
<DT><B>반환값:</B><DD>지정된 회전 각도로 작성된,
        회전 변환을 나타내는 <code>AffineTransform</code> 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRotateInstance(double, double, double)"><!-- --></A> <H3>
getRotateInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getRotateInstance</B>(double&nbsp;theta,
                                                double&nbsp;anchorx,
                                                double&nbsp;anchory)</PRE>
<DL>
<DD>엥커 포인트를 중심으로 해 좌표를 회전시키는 변환을 돌려줍니다. 이 오퍼레이션은, 좌표를 엥커 포인트가 원점 (S1)이 되도록(듯이) 이동해, 이러한 좌표를 새로운 원점 (S2)을 중심으로 회전하고 나서, 마지막에 그 중개적인 원점을 전의 엥커 포인트 (S3)의 좌표에 되돌리기 위해서(때문에) 이동하는 것에 상당합니다.  &nbsp;<p>
이 조작은, 다음의 일련의 호출해에 상당합니다.
 <pre>
     AffineTransform Tx = new AffineTransform();
     Tx.translate(anchorx, anchory);    // S3:
final translation     Tx.rotate(theta);               // S2:rotate around anchor
     Tx.translate(-anchorx, -anchory);  // S1:translate anchor to origin
 </pre>
반환되는 변환의 행렬 표현은, 다음과 같이 됩니다.
 <pre>
                [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]
                [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]
                [       0              0               1        ]
 </pre>
정의 각도 theta 로 회전하면(자), 정의 X 축의 점이 정의 Y 축으로 향해 회전합니다. 전술의 「<a href="#quadrantapproximation">90 번 회전의 처리</a>」의 설명도 참조해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 계측 한 회전 각도<DD><CODE>anchorx</CODE> - 회전의 엥커 포인트의 X 좌표<DD><CODE>anchory</CODE> - 회전의 엥커 포인트의 Y 좌표
<DT><B>반환값:</B><DD>지정된 점을 중심으로서 지정된 회전 각도로 
        좌표를 회전하는 <code>AffineTransform</code> 
        객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRotateInstance(double, double)"><!-- --></A> <H3>
getRotateInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getRotateInstance</B>(double&nbsp;vecx,
                                                double&nbsp;vecy)</PRE>
<DL>
<DD>회전 벡터에 따라 좌표를 회전시키는 변환을 돌려줍니다. 모든 좌표는 원점을 중심으로 같은 양만 회전합니다. 이 회전량으로, 원의 정의 X 축으로 따른 좌표는, 원점으로부터 지정된 벡터 좌표를 가리키는 벡터에 가지런히 할 수 있습니다. <code>vecx</code> 와 <code>vecy</code> 의 양쪽 모두가 0.0 의 경우, 항등변환이 돌려주어집니다. 이 조작은, 이하를 호출하는 것과 동등합니다.
 <pre>
     AffineTransform.getRotateInstance(Math.atan2(vecy, vecx));
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>vecx</CODE> - 회전 벡터의 X 좌표<DD><CODE>vecy</CODE> - 회전 벡터의 Y 좌표
<DT><B>반환값:</B><DD>지정된 회전 벡터에 따라
  좌표를 회전시키는 <code>AffineTransform</code> 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRotateInstance(double, double, double, double)"><!-- --></A> <H3>
getRotateInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getRotateInstance</B>(double&nbsp;vecx,
                                                double&nbsp;vecy,
                                                double&nbsp;anchorx,
                                                double&nbsp;anchory)</PRE>
<DL>
<DD>회전 벡터에 따라, 엥커 포인트를 중심으로 해 좌표를 회전시키는 변환을 돌려줍니다. 모든 좌표는 지정된 엥커 포인트의 좌표를 중심으로 같은 양만 회전합니다. 이 회전량으로, 원의 정의 X 축으로 따른 좌표는, 원점으로부터 지정된 벡터 좌표를 가리키는 벡터에 가지런히 할 수 있습니다. <code>vecx</code> 와 <code>vecy</code> 의 양쪽 모두가 0.0 의 경우, 항등변환이 돌려주어집니다. 이 조작은, 이하를 호출하는 것과 동등합니다.
 <pre>
     AffineTransform.getRotateInstance(Math.atan2(vecy, vecx),
                                       anchorx, anchory);
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>vecx</CODE> - 회전 벡터의 X 좌표<DD><CODE>vecy</CODE> - 회전 벡터의 Y 좌표<DD><CODE>anchorx</CODE> - 회전의 엥커 포인트의 X 좌표<DD><CODE>anchory</CODE> - 회전의 엥커 포인트의 Y 좌표
<DT><B>반환값:</B><DD>지정된 회전 벡터에 따라 
        지정된 점을 중심으로 해 좌표를 회전시킨다 
  <code>AffineTransform</code> 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getQuadrantRotateInstance(int)"><!-- --></A> <H3>
getQuadrantRotateInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getQuadrantRotateInstance</B>(int&nbsp;numquadrants)</PRE>
<DL>
<DD>지정된 수의 4분원만 좌표를 회전시키는 변환을 돌려줍니다. 이 조작은, 이하를 호출하는 것과 동등합니다.
 <pre>
     AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0);
 </pre>
정의 수의 4분원만 회전하면(자), 정의 X 축의 점이 정의 Y 축으로 향해 회전합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>numquadrants</CODE> - 회전시키는 90 번의 호의 수
<DT><B>반환값:</B><DD>지정된 수의 4분원만
  좌표를 회전시키는 <code>AffineTransform</code> 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getQuadrantRotateInstance(int, double, double)"><!-- --></A> <H3>
getQuadrantRotateInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getQuadrantRotateInstance</B>(int&nbsp;numquadrants,
                                                        double&nbsp;anchorx,
                                                        double&nbsp;anchory)</PRE>
<DL>
<DD>지정된 엥커 포인트를 중심으로 해, 지정된 수의 4분원만 좌표를 회전시키는 변환을 돌려줍니다. 이 조작은, 이하를 호출하는 것과 동등합니다.
 <pre>
     AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0,
                                       anchorx, anchory);
 </pre>
정의 수의 4분원만 회전하면(자), 정의 X 축의 점이 정의 Y 축으로 향해 회전합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>numquadrants</CODE> - 회전시키는 90 번의 호의 수<DD><CODE>anchorx</CODE> - 회전의 엥커 포인트의 X 좌표<DD><CODE>anchory</CODE> - 회전의 엥커 포인트의 Y 좌표
<DT><B>반환값:</B><DD>지정된 엥커 포인트를 중심으로 해, 
        지정된 수의 4분원만 좌표를 회전시킨다 
  <code>AffineTransform</code> 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getScaleInstance(double, double)"><!-- --></A> <H3>
getScaleInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getScaleInstance</B>(double&nbsp;sx,
                                               double&nbsp;sy)</PRE>
<DL>
<DD>슬캘링 변환을 표현하는 변환을 돌려줍니다. 반환되는 변환의 행렬 표현은, 다음과 같이 됩니다.
 <pre>
                [   sx   0    0   ]
                [   0    sy   0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>sx</CODE> - 좌표를 X 축방향으로 슬캘링 하기 위해서
 사용하는 계수<DD><CODE>sy</CODE> - 좌표를 Y 축방향으로 슬캘링 하기 위해서
 사용하는 계수
<DT><B>반환값:</B><DD>지정된 계수로 좌표를 scaled다  
        <code>AffineTransform</code> 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getShearInstance(double, double)"><!-- --></A> <H3>
getShearInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getShearInstance</B>(double&nbsp;shx,
                                               double&nbsp;shy)</PRE>
<DL>
<DD>셔링 변환을 표현하는 변환을 돌려줍니다. 반환되는 변환의 행렬 표현은, 다음과 같이 됩니다.
 <pre>
                [   1   shx   0   ]
                [  shy   1    0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>shx</CODE> - Y 좌표의 계수로 좌표를 정의 X 축의
 방향으로 이동하기 위해서(때문에) 사용하는 승수<DD><CODE>shy</CODE> - X 좌표의 계수로 좌표를 정의 Y 축의
 방향으로 이동하기 위해서(때문에) 사용하는 승수
<DT><B>반환값:</B><DD>지정된 승수로 좌표를 변형시킨다  
        <code>AffineTransform</code> 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getType()"><!-- --></A> <H3>
getType</H3>
<PRE>
public int <B>getType</B>()</PRE>
<DL>
<DD>이 변환의 변환 프로퍼티을 기술하는 flag bit를 돌려줍니다. 반환되는 값은, 정수 TYPE_IDENTITY 또는 TYPE_GENERAL_TRANSFORM 의 어느 쪽인지, 혹은 적절한 flag bit의 편성이 됩니다. flag bit의 유효한 편성은, TYPE_UNIFORM_SCALE flag bit 또는 TYPE_GENERAL_SCALE flag bit의 어느 쪽일까하고, TYPE_QUADRANT_ROTATION flag bit 또는 TYPE_GENERAL_ROTATION flag bit의 어딘가에 더해, TYPE_TRANSLATION flag bit를 결합하는 배타적 논리합의 연산입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 변환에 적용되는 임의의 지정 플래그에 의한다
 논리합의 편성<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDeterminant()"><!-- --></A> <H3>
getDeterminant</H3>
<PRE>
public double <B>getDeterminant</B>()</PRE>
<DL>
<DD>변환의 행렬 표현의 행렬식을 돌려줍니다. 행렬식은, 역변환의 존재를 판정하기 위해서도, X 와 Y 의 슬캘링의 편성에 의한 변환을 표현하는 1 개의 값을 취득하기 위해서도 사용할 수 있습니다.  &nbsp;<p>
행렬식이 제로가 아닌 경우, 이 변환에는 역변환이 존재해, 역변환에 의존하는 다양한 메소드는 <A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 안의 클래스"><CODE>NoninvertibleTransformException</CODE></A>  를 throw 할 필요가 없습니다. 행렬식이 제로의 경우, 이 변환은 모든 입력 좌표를 선 또는 점에 맵 하므로 역변환할 수 없습니다. 행렬식이 충분히 제로에 가까운 경우, 역변환 오퍼레이션은 의미가 있는 결과를 낼 수 있을 뿐(만큼)의 정밀도를 확보 가능한 있고 경우가 있습니다.  &nbsp;<p>
<code>getType</code> 메소드로 나타나도록(듯이), 이 변환이 한결같은 슬캘링을 표현하는 경우, 행렬식은 모든 점이 원점을 기준에 확장 또는 축소되는 한결같은 슬캘링 계수의 2 승을 나타냅니다. 이 변환이 한결같지 않은 슬캘링 또는보다 범용적인 변환을 표현하는 경우, 행렬식이 나타내는 값은, 역변환이 가능한가 어떤가를 판정하기 위해(때문에)인 만큼 사용할 수 있습니다.  &nbsp;<p>
산술적으로, 행렬식은 다음의 공식에서 계산됩니다.
 <pre>
                |  m00  m01  m02  |
                |  m10  m11  m12  |  =  m00 * m11 - m01 * m10
                |   0    0    1   |
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>좌표를 변환하기 위해서 사용되는 행렬의
 행렬식<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#createInverse()"><CODE>createInverse()</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#inverseTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)"><CODE>inverseTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMatrix(double[])"><!-- --></A> <H3>
getMatrix</H3>
<PRE>
public void <B>getMatrix</B>(double[]&nbsp;flatmatrix)</PRE>
<DL>
<DD>3×3 아핀 변환 행렬내의 6 개의 지정 가능한 값을 꺼내, 배정밀도치의 배열에 배치합니다. 각 치는 배열에 {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;m02&nbsp;m12&nbsp;} 라고 하는 형식에서 포함됩니다. 4 개의 double 치의 배열도 지정할 수 있습니다.  그 경우는, 배열의 비평행이동 부분을 나타내는 최초의 4 개의 요소만이 꺼내져 값은 배열에 {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;} 라고 하는 형식에서 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>flatmatrix</CODE> - 반환값을 포함하기 위해서 사용하는 double 치의
 배열<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getScaleX()"><CODE>getScaleX()</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#getScaleY()"><CODE>getScaleY()</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#getShearX()"><CODE>getShearX()</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#getShearY()"><CODE>getShearY()</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#getTranslateX()"><CODE>getTranslateX()</CODE></A> , 
<A HREF="../../../java/awt/geom/AffineTransform.html#getTranslateY()"><CODE>getTranslateY()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getScaleX()"><!-- --></A> <H3>
getScaleX</H3>
<PRE>
public double <B>getScaleX</B>()</PRE>
<DL>
<DD>3×3 아핀 변환 행렬의 X 좌표 슬캘링 요소 (m00)를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아핀 변환 행렬의 슬캘링 요소의 
  X 좌표를 나타내는 double 치<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])"><CODE>getMatrix(double[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getScaleY()"><!-- --></A> <H3>
getScaleY</H3>
<PRE>
public double <B>getScaleY</B>()</PRE>
<DL>
<DD>3×3 아핀 변환 행렬의 Y 좌표 슬캘링 요소 (m11)를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아핀 변환 행렬의 슬캘링 요소의 
  Y 좌표를 나타내는 double 치<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])"><CODE>getMatrix(double[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getShearX()"><!-- --></A> <H3>
getShearX</H3>
<PRE>
public double <B>getShearX</B>()</PRE>
<DL>
<DD>3×3 아핀 변환 행렬의 X 좌표 셔링 요소 (m01)를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아핀 변환 행렬의 셔링 요소의 
  X 좌표를 나타내는 double 치<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])"><CODE>getMatrix(double[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getShearY()"><!-- --></A> <H3>
getShearY</H3>
<PRE>
public double <B>getShearY</B>()</PRE>
<DL>
<DD>3×3 아핀 변환 행렬의 Y 좌표 셔링 요소 (m10)를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아핀 변환 행렬의 셔링 요소의 
  Y 좌표를 나타내는 double 치<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])"><CODE>getMatrix(double[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTranslateX()"><!-- --></A> <H3>
getTranslateX</H3>
<PRE>
public double <B>getTranslateX</B>()</PRE>
<DL>
<DD>3×3 아핀 변환 행렬의 평행이동 요소 (m02)의 X 좌표를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아핀 변환 행렬의 평행이동 요소의 
  X 좌표를 나타내는 double 치<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])"><CODE>getMatrix(double[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTranslateY()"><!-- --></A> <H3>
getTranslateY</H3>
<PRE>
public double <B>getTranslateY</B>()</PRE>
<DL>
<DD>3×3 아핀 변환 행렬의 평행이동 요소 (m12)의 Y 좌표를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아핀 변환 행렬의 평행이동 요소의 
  Y 좌표를 나타내는 double 치<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])"><CODE>getMatrix(double[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="translate(double, double)"><!-- --></A> <H3>
translate</H3>
<PRE>
public void <B>translate</B>(double&nbsp;tx,
                      double&nbsp;ty)</PRE>
<DL>
<DD>이 변환을 평행이동 변환에 연결합니다. 이것은, concatenate(T)를 호출하는 것에 상당합니다.  다만, T 는 다음의 행렬로 표현되는 <code>AffineTransform</code> 입니다.
 <pre>
                [   1    0    tx  ]
                [   0    1    ty  ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tx</CODE> - 좌표가 X 축방향으로 평행이동 된다
 거리<DD><CODE>ty</CODE> - 좌표가 Y 축방향으로 평행이동 된다
 거리<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double)"><!-- --></A> <H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(double&nbsp;theta)</PRE>
<DL>
<DD>이 변환을 회전 변환에 연결합니다. 이것은, concatenate(R)를 호출하는 것에 상당합니다. 다만, R 는 다음의 행렬로 표현되는 <code>AffineTransform</code> 입니다.
 <pre>
                [   cos(theta)    -sin(theta)    0   ]
                [   sin(theta)     cos(theta)    0   ]
                [       0              0         1   ]
 </pre>
정의 각도 theta 로 회전하면(자), 정의 X 축의 점이 정의 Y 축으로 향해 회전합니다. 전술의 「<a href="#quadrantapproximation">90 번 회전의 처리</a>」의 설명도 참조해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 계측 한 회전 각도<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double, double, double)"><!-- --></A> <H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(double&nbsp;theta,
                   double&nbsp;anchorx,
                   double&nbsp;anchory)</PRE>
<DL>
<DD>이 변환을, 엥커 포인트를 중심으로 해 좌표를 회전하는 변환과 연결합니다. 이 오퍼레이션은, 좌표를 엥커 포인트가 원점 (S1)이 되도록(듯이) 이동해, 이러한 좌표를 새로운 원점 (S2)을 중심으로 회전하고 나서, 마지막에 그 중개적인 원점을 전의 엥커 포인트 (S3)의 좌표에 되돌리기 위해서(때문에) 이동하는 것에 상당합니다.  &nbsp;<p>
이 조작은, 다음의 일련의 호출해에 상당합니다.
 <pre>
     translate(anchorx, anchory);      // S3:final translation
     rotate(theta);                    // S2:rotate around anchor
     translate(-anchorx, -anchory);    // S1:translate anchor to origin
 </pre>
정의 각도 theta 로 회전하면(자), 정의 X 축의 점이 정의 Y 축으로 향해 회전합니다. 전술의 「<a href="#quadrantapproximation">90 번 회전의 처리</a>」의 설명도 참조해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 계측 한 회전 각도<DD><CODE>anchorx</CODE> - 회전의 엥커 포인트의 X 좌표<DD><CODE>anchory</CODE> - 회전의 엥커 포인트의 Y 좌표<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double, double)"><!-- --></A> <H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(double&nbsp;vecx,
                   double&nbsp;vecy)</PRE>
<DL>
<DD>이 변환을, 회전 벡터에 따라 좌표를 회전시키는 변환과 연결합니다. 모든 좌표는 원점을 중심으로 같은 양만 회전합니다. 이 회전량으로, 원의 정의 X 축으로 따른 좌표는, 원점으로부터 지정된 벡터 좌표를 가리키는 벡터에 가지런히 할 수 있습니다. <code>vecx</code> 와 <code>vecy</code> 의 양쪽 모두가 0.0 의 경우, 이 변환에 추가의 회전은 행해지지 않습니다. 이 조작은, 이하를 호출하는 것과 동등합니다.
 <pre>
          rotate(Math.atan2(vecy, vecx));
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>vecx</CODE> - 회전 벡터의 X 좌표<DD><CODE>vecy</CODE> - 회전 벡터의 Y 좌표<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double, double, double, double)"><!-- --></A> <H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(double&nbsp;vecx,
                   double&nbsp;vecy,
                   double&nbsp;anchorx,
                   double&nbsp;anchory)</PRE>
<DL>
<DD>이 변환을, 회전 벡터에 따라, 엥커 포인트를 중심으로 해 좌표를 회전시키는 변환과 연결합니다. 모든 좌표는 지정된 엥커 포인트의 좌표를 중심으로 같은 양만 회전합니다. 이 회전량으로, 원의 정의 X 축으로 따른 좌표는, 원점으로부터 지정된 벡터 좌표를 가리키는 벡터에 가지런히 할 수 있습니다. <code>vecx</code> 와 <code>vecy</code> 의 양쪽 모두가 0.0 의 경우, 변환은 결코 변경되지 않습니다. 이 메소드는, 이하를 호출하는 것과 동등합니다.
 <pre>
     rotate(Math.atan2(vecy, vecx), anchorx, anchory);
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>vecx</CODE> - 회전 벡터의 X 좌표<DD><CODE>vecy</CODE> - 회전 벡터의 Y 좌표<DD><CODE>anchorx</CODE> - 회전의 엥커 포인트의 X 좌표<DD><CODE>anchory</CODE> - 회전의 엥커 포인트의 Y 좌표<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="quadrantRotate(int)"><!-- --></A> <H3>
quadrantRotate</H3>
<PRE>
public void <B>quadrantRotate</B>(int&nbsp;numquadrants)</PRE>
<DL>
<DD>이 변환을, 지정된 수의 4분원만 좌표를 회전시키는 변환과 연결합니다. 이것은, 이하를 호출하는 것과 동등합니다.
 <pre>
     rotate(numquadrants * Math.PI / 2.0);
 </pre>
정의 수의 4분원만 회전하면(자), 정의 X 축의 점이 정의 Y 축으로 향해 회전합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>numquadrants</CODE> - 회전시키는 90 번의 호의 수<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="quadrantRotate(int, double, double)"><!-- --></A> <H3>
quadrantRotate</H3>
<PRE>
public void <B>quadrantRotate</B>(int&nbsp;numquadrants,
                           double&nbsp;anchorx,
                           double&nbsp;anchory)</PRE>
<DL>
<DD>이 변환을, 지정된 엥커 포인트를 중심으로 해, 지정된 수의 4분원만 좌표를 회전시키는 변환과 연결합니다. 이 메소드는, 이하를 호출하는 것과 동등합니다.
 <pre>
     rotate(numquadrants * Math.PI / 2.0, anchorx, anchory);
 </pre>
정의 수의 4분원만 회전하면(자), 정의 X 축의 점이 정의 Y 축으로 향해 회전합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>numquadrants</CODE> - 회전시키는 90 번의 호의 수<DD><CODE>anchorx</CODE> - 회전의 엥커 포인트의 X 좌표<DD><CODE>anchory</CODE> - 회전의 엥커 포인트의 Y 좌표<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="scale(double, double)"><!-- --></A> <H3>
scale</H3>
<PRE>
public void <B>scale</B>(double&nbsp;sx,
                  double&nbsp;sy)</PRE>
<DL>
<DD>이 변환을 슬캘링 변환에 연결합니다. 이것은, concatenate(S)를 호출하는 것에 상당합니다.  다만, S 는 다음의 행렬로 표현되는 <code>AffineTransform</code> 입니다.
 <pre>
                [   sx   0    0   ]
                [   0    sy   0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>sx</CODE> - 좌표를 X 축방향으로 슬캘링 하기 위해서   
 사용하는 계수<DD><CODE>sy</CODE> - 좌표를 Y 축방향으로 슬캘링 하기 위해서
 사용하는 계수<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="shear(double, double)"><!-- --></A> <H3>
shear</H3>
<PRE>
public void <B>shear</B>(double&nbsp;shx,
                  double&nbsp;shy)</PRE>
<DL>
<DD>이 변환을 셔링 변환에 연결합니다. 이것은, concatenate(SH)를 호출하는 것에 상당합니다.  다만, SH 는 다음의 행렬로 표현되는 <code>AffineTransform</code> 입니다.
 <pre>
                [   1   shx   0   ]
                [  shy   1    0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>shx</CODE> - Y 좌표의 계수로 좌표를 정의 X 축의
 방향으로 이동하기 위해서(때문에) 사용하는 승수<DD><CODE>shy</CODE> - X 좌표의 계수로 좌표를 정의 Y 축의
 방향으로 이동하기 위해서(때문에) 사용하는 승수<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setToIdentity()"><!-- --></A> <H3>
setToIdentity</H3>
<PRE>
public void <B>setToIdentity</B>()</PRE>
<DL>
<DD>이 변환을 항등변환으로 다시 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setToTranslation(double, double)"><!-- --></A> <H3>
setToTranslation</H3>
<PRE>
public void <B>setToTranslation</B>(double&nbsp;tx,
                             double&nbsp;ty)</PRE>
<DL>
<DD>이 변환을 평행이동 변환으로 설정합니다. 이 변환을 표현하는 행렬은 다음과 같이 됩니다.
 <pre>
                [   1    0    tx  ]
                [   0    1    ty  ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tx</CODE> - 좌표가 X 축방향으로 평행이동 된다
 거리<DD><CODE>ty</CODE> - 좌표가 Y 축방향으로 평행이동 된다
 거리<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setToRotation(double)"><!-- --></A> <H3>
setToRotation</H3>
<PRE>
public void <B>setToRotation</B>(double&nbsp;theta)</PRE>
<DL>
<DD>이 변환을 회전 변환으로 설정합니다. 이 변환을 표현하는 행렬은 다음과 같이 됩니다.
 <pre>
                [   cos(theta)    -sin(theta)    0   ]
                [   sin(theta)     cos(theta)    0   ]
                [       0              0         1   ]
 </pre>
정의 각도 theta 로 회전하면(자), 정의 X 축의 점이 정의 Y 축으로 향해 회전합니다. 전술의 「<a href="#quadrantapproximation">90 번 회전의 처리</a>」의 설명도 참조해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 계측 한 회전 각도<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setToRotation(double, double, double)"><!-- --></A> <H3>
setToRotation</H3>
<PRE>
public void <B>setToRotation</B>(double&nbsp;theta,
                          double&nbsp;anchorx,
                          double&nbsp;anchory)</PRE>
<DL>
<DD>이 변환을 평행이동 후의 회전 변환으로 설정합니다. 이 오퍼레이션은, 좌표를 엥커 포인트가 원점 (S1)이 되도록(듯이) 이동해, 이러한 좌표를 새로운 원점 (S2)을 중심으로 회전하고 나서, 마지막에 그 중개적인 원점을 전의 엥커 포인트 (S3)의 좌표에 되돌리기 위해서(때문에) 이동하는 것에 상당합니다.  &nbsp;<p>
이 조작은, 다음의 일련의 호출해에 상당합니다.
 <pre>
     setToTranslation(anchorx, anchory); // S3:final translation
     rotate(theta);                    // S2:rotate around anchor
     translate(-anchorx, -anchory);    // S1:translate anchor to origin
 </pre>
이 변환을 표현하는 행렬은 다음과 같이 됩니다.
 <pre>
                [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]
                [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]
                [       0              0               1        ]
 </pre>
정의 각도 theta 로 회전하면(자), 정의 X 축의 점이 정의 Y 축으로 향해 회전합니다. 전술의 「<a href="#quadrantapproximation">90 번 회전의 처리</a>」의 설명도 참조해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 계측 한 회전 각도<DD><CODE>anchorx</CODE> - 회전의 엥커 포인트의 X 좌표<DD><CODE>anchory</CODE> - 회전의 엥커 포인트의 Y 좌표<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setToRotation(double, double)"><!-- --></A> <H3>
setToRotation</H3>
<PRE>
public void <B>setToRotation</B>(double&nbsp;vecx,
                          double&nbsp;vecy)</PRE>
<DL>
<DD>이 변환을, 회전 벡터에 따라 좌표를 회전시키는 회전 변환으로 설정합니다. 모든 좌표는 원점을 중심으로 같은 양만 회전합니다. 이 회전량으로, 원의 정의 X 축으로 따른 좌표는, 원점으로부터 지정된 벡터 좌표를 가리키는 벡터에 가지런히 할 수 있습니다. <code>vecx</code> 와 <code>vecy</code> 의 양쪽 모두가 0.0 의 경우, 변환은 항등변환으로 설정됩니다. 이 조작은, 이하를 호출하는 것과 동등합니다.
 <pre>
     setToRotation(Math.atan2(vecy, vecx));
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>vecx</CODE> - 회전 벡터의 X 좌표<DD><CODE>vecy</CODE> - 회전 벡터의 Y 좌표<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setToRotation(double, double, double, double)"><!-- --></A> <H3>
setToRotation</H3>
<PRE>
public void <B>setToRotation</B>(double&nbsp;vecx,
                          double&nbsp;vecy,
                          double&nbsp;anchorx,
                          double&nbsp;anchory)</PRE>
<DL>
<DD>이 변환을, 회전 벡터에 따라, 엥커 포인트를 중심으로 해 좌표를 회전시키는 회전 변환으로 설정합니다. 모든 좌표는 지정된 엥커 포인트의 좌표를 중심으로 같은 양만 회전합니다. 이 회전량으로, 원의 정의 X 축으로 따른 좌표는, 원점으로부터 지정된 벡터 좌표를 가리키는 벡터에 가지런히 할 수 있습니다. <code>vecx</code> 와 <code>vecy</code> 의 양쪽 모두가 0.0 의 경우, 변환은 항등변환으로 설정됩니다. 이 조작은, 이하를 호출하는 것과 동등합니다.
 <pre>
     setToTranslation(Math.atan2(vecy, vecx), anchorx, anchory);
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>vecx</CODE> - 회전 벡터의 X 좌표<DD><CODE>vecy</CODE> - 회전 벡터의 Y 좌표<DD><CODE>anchorx</CODE> - 회전의 엥커 포인트의 X 좌표<DD><CODE>anchory</CODE> - 회전의 엥커 포인트의 Y 좌표<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setToQuadrantRotation(int)"><!-- --></A> <H3>
setToQuadrantRotation</H3>
<PRE>
public void <B>setToQuadrantRotation</B>(int&nbsp;numquadrants)</PRE>
<DL>
<DD>이 변환을, 지정된 수의 4분원만 좌표를 회전시키는 회전 변환으로 설정합니다. 이 조작은, 이하를 호출하는 것과 동등합니다.
 <pre>
     setToRotation(numquadrants * Math.PI / 2.0);
 </pre>
정의 수의 4분원만 회전하면(자), 정의 X 축의 점이 정의 Y 축으로 향해 회전합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>numquadrants</CODE> - 회전시키는 90 번의 호의 수<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setToQuadrantRotation(int, double, double)"><!-- --></A> <H3>
setToQuadrantRotation</H3>
<PRE>
public void <B>setToQuadrantRotation</B>(int&nbsp;numquadrants,
                                  double&nbsp;anchorx,
                                  double&nbsp;anchory)</PRE>
<DL>
<DD>이 변환을, 지정된 엥커 포인트를 중심으로 해, 지정된 수의 4분원만 좌표를 회전시키는, 평행이동 후의 회전 변환으로 설정합니다. 이 조작은, 이하를 호출하는 것과 동등합니다.
 <pre>
     setToRotation(numquadrants * Math.PI / 2.0, anchorx, anchory);
 </pre>
정의 수의 4분원만 회전하면(자), 정의 X 축의 점이 정의 Y 축으로 향해 회전합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>numquadrants</CODE> - 회전시키는 90 번의 호의 수<DD><CODE>anchorx</CODE> - 회전의 엥커 포인트의 X 좌표<DD><CODE>anchory</CODE> - 회전의 엥커 포인트의 Y 좌표<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setToScale(double, double)"><!-- --></A> <H3>
setToScale</H3>
<PRE>
public void <B>setToScale</B>(double&nbsp;sx,
                       double&nbsp;sy)</PRE>
<DL>
<DD>이 변환을 슬캘링 변환으로 설정합니다. 이 변환을 표현하는 행렬은 다음과 같이 됩니다.
 <pre>
                [   sx   0    0   ]
                [   0    sy   0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>sx</CODE> - 좌표를 X 축방향으로 슬캘링 하기 위해서
 사용하는 계수<DD><CODE>sy</CODE> - 좌표를 Y 축방향으로 슬캘링 하기 위해서
 사용하는 계수<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setToShear(double, double)"><!-- --></A> <H3>
setToShear</H3>
<PRE>
public void <B>setToShear</B>(double&nbsp;shx,
                       double&nbsp;shy)</PRE>
<DL>
<DD>이 변환을 셔링 변환으로 설정합니다. 이 변환을 표현하는 행렬은 다음과 같이 됩니다.
 <pre>
                [   1   shx   0   ]
                [  shy   1    0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>shx</CODE> - Y 좌표의 계수로 좌표를 정의 X 축의
 방향으로 이동하기 위해서(때문에) 사용하는 승수<DD><CODE>shy</CODE> - X 좌표의 계수로 좌표를 정의 Y 축의
 방향으로 이동하기 위해서(때문에) 사용하는 승수<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTransform(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
setTransform</H3>
<PRE>
public void <B>setTransform</B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</PRE>
<DL>
<DD>이 변환을, 지정된 <code>AffineTransform</code> 객체내의 변환의 카피로 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>Tx</CODE> - 변환의 카피원의 <code>AffineTransform</code> 
 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTransform(double, double, double, double, double, double)"><!-- --></A> <H3>
setTransform</H3>
<PRE>
public void <B>setTransform</B>(double&nbsp;m00,
                         double&nbsp;m10,
                         double&nbsp;m01,
                         double&nbsp;m11,
                         double&nbsp;m02,
                         double&nbsp;m12)</PRE>
<DL>
<DD>이 변환을 6 개의 배정밀도치에 의해 지정되고 있는 행렬로 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>m00</CODE> - 3×3 행렬의 X 좌표 슬캘링 요소<DD><CODE>m10</CODE> - 3×3 행렬의 Y 좌표 셔링 요소<DD><CODE>m01</CODE> - 3×3 행렬의 X 좌표 셔링 요소<DD><CODE>m11</CODE> - 3×3 행렬의 Y 좌표 슬캘링 요소<DD><CODE>m02</CODE> - 3×3 행렬의 X 좌표 평행이동 요소<DD><CODE>m12</CODE> - 3×3 행렬의 Y 좌표 평행이동 요소<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="concatenate(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
concatenate</H3>
<PRE>
public void <B>concatenate</B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</PRE>
<DL>
<DD><code>Tx</code> 에 의해 원의 사용자 공간에 맵 된 새로운 사용자 공간을 제공하기 위해서 가장 일반적으로 사용되는 방법으로,<code>AffineTransform</code> <code>Tx</code> 를 이 <code>AffineTransform</code> Cx 에 연결합니다. Cx 를 갱신하면(자), 결합된 변환을 실행할 수 있습니다. 갱신된 변환 Cx'로 점 p 를 변환하는 것은, 최초로 <code>Tx</code> 로 p 를 변환하고 나서, 그 결과를 원의 변환 Cx 로 변환하는 것에 상당합니다. 즉, Cx'(p) = Cx(Tx(p))입니다.  행렬 표기에서는, 이 변환 Cx 가 행렬 [this] 로 표현되어<code>Tx</code> 가 행렬 [Tx] 로 표현되는 경우, 이 메소드는 다음의 처리를 실시합니다.
 <pre>
                [this] = [this] x [Tx]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>Tx</CODE> - 이 <code>AffineTransform</code> 객체에
 연결되는 <code>AffineTransform</code> 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#preConcatenate(java.awt.geom.AffineTransform)"><CODE>preConcatenate(java.awt.geom.AffineTransform)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="preConcatenate(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
preConcatenate</H3>
<PRE>
public void <B>preConcatenate</B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</PRE>
<DL>
<DD><code>Tx</code> 가 기존의 사용자 공간은 아니고 절대 픽셀 공간을 기준(�좌표변화를 변경하는 등 일반적으로는 그다지 사용되지 않는 방법으로,<code>AffineTransform</code> <code>Tx</code> 를 이 <code>AffineTransform</code> Cx 에 연결합니다. Cx 를 갱신하면(자), 결합된 변환을 실행할 수 있습니다. 갱신된 변환 Cx'로 점 p 를 변환하는 것은, 최초로 원의 변환 Cx 로 p 를 변환하고 나서, 그 결과를 <code>Tx</code> 로 변환하는 것에 상당합니다. 즉, Cx'(p) = Tx(Cx(p))입니다.  행렬 표기에서는, 이 변환 Cx 가 행렬 [this] 로 표현되어<code>Tx</code> 가 행렬 [Tx] 로 표현되는 경우, 이 메소드는 다음의 처리를 실시합니다.
 <pre>
                [this] = [Tx] x [this]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>Tx</CODE> - 이 <code>AffineTransform</code> 객체에
 연결되는 <code>AffineTransform</code> 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#concatenate(java.awt.geom.AffineTransform)"><CODE>concatenate(java.awt.geom.AffineTransform)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createInverse()"><!-- --></A> <H3>
createInverse</H3>
<PRE>
public <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>createInverse</B>()
                              throws <A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 내의 클래스">NoninvertibleTransformException</A> </PRE>
<DL>
<DD>역변환을 표현하는 <code>AffineTransform</code> 객체를 돌려줍니다. 이 변환 Tx 의 역변환 Tx'는, Tx 에 의해 변환된 좌표를 그 원의 좌표에 맵 해 되돌립니다. 즉, Tx'(Tx(p)) = p = Tx(Tx'(p))입니다.  &nbsp;<p>
이 변환이 모든 좌표를 점이나 선에 맵 하는 경우, 변환은 역사상을 가지지 않습니다.  이것은, 전송처의 점이나 선에 없는 좌표가 역사상을 가지지 않기 때문입니다. <code>getDeterminant</code> 메소드를 사용하면(자), 이 변환이 역사상을 가질지 어떨지를 판정할 수 있습니다.  이 변환이 역사상을 가지지 않는 경우,<code>createInverse</code> 메소드가 불려 가면(자), 예외가 throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>역변환을 표현하는 새롭다 
 <code>AffineTransform</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 안의 클래스">NoninvertibleTransformException</A> </CODE> - 행렬을 반전할 수 없는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getDeterminant()"><CODE>getDeterminant()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="invert()"><!-- --></A> <H3>
invert</H3>
<PRE>
public void <B>invert</B>()
            throws <A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 내의 클래스">NoninvertibleTransformException</A> </PRE>
<DL>
<DD>이 변환을 자신의 역변환으로 설정합니다. 이 변환 Tx 의 역변환 Tx'는, Tx 에 의해 변환된 좌표를 그 원의 좌표에 맵 해 되돌립니다. 즉, Tx'(Tx(p)) = p = Tx(Tx'(p))입니다.  &nbsp;<p>
이 변환이 모든 좌표를 점이나 선에 맵 하는 경우, 변환은 역사상을 가지지 않습니다.  이것은, 전송처의 점이나 선에 없는 좌표가 역사상을 가지지 않기 때문입니다. <code>getDeterminant</code> 메소드를 사용하면(자), 이 변환이 역사상을 가질지 어떨지를 판정할 수 있습니다. 이 변환이 역사상을 가지지 않는 경우,<code>invert</code> 메소드가 불려 가면(자), 예외가 throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 안의 클래스">NoninvertibleTransformException</A> </CODE> - 행렬을 반전할 수 없는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getDeterminant()"><CODE>getDeterminant()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="transform(java.awt.geom.Point2D, java.awt.geom.Point2D)"><!-- --></A> <H3>
transform</H3>
<PRE>
public <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 내의 클래스">Point2D</A>  <B>transform</B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptSrc,
                         <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptDst)</PRE>
<DL>
<DD>지정된 <code>ptSrc</code> 를 변환해, 그 결과를 <code>ptDst</code> 에 포함합니다. <code>ptDst</code> 가 <code>null</code> 의 경우, 새로운 <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 동안의 클래스"><CODE>Point2D</CODE></A>  객체를 할당할 수 있고 나서, 변환의 결과가 이 객체에 포함됩니다. 어느 쪽의 경우도, 편의상, 변환 후의 점을 포함하고 있는 <code>ptDst</code> 가 돌려주어집니다. <code>ptSrc</code> 와 <code>ptDst</code> 가 같은 객체의 경우, 입력점은 변환 후의 점으로써 적절히 덧쓰기됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ptSrc</CODE> - 변환 대상의 지정된 <code>Point2D</code><DD><CODE>ptDst</CODE> - <code>ptSrc</code> 의 변환 결과를 포함하고 있다
 지정된 <code>Point2D</code>
<DT><B>반환값:</B><DD><code>ptSrc</code> 를 변환해, 결과를
 <code>ptDst</code> 에 포함한 뒤의 <code>ptDst</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="transform(java.awt.geom.Point2D[], int, java.awt.geom.Point2D[], int, int)"><!-- --></A> <H3>
transform</H3>
<PRE>
public void <B>transform</B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> []&nbsp;ptSrc,
                      int&nbsp;srcOff,
                      <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> []&nbsp;ptDst,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>이 변환에 의해 포인트 객체의 배열을 변환합니다. <code><code>ptDst</code> 배열의 요소중 한쪽이 <code>null</code> 이면, 새로운 <code>Point2D</code> 객체를 할당할 수 있어 변환의 결과가 포함되기 전에 그 요소에 포함됩니다.  &nbsp;<p>
다만, 이 메소드는, 전송원배열에 놓여져 계산의 전송원으로서 사용되는 <code>Point2D</code> 객체에 결과를 포함하는 것에 의해 일으켜지는 문제를 피하기 위한 예방 조치를 취하고 있지 않습니다. 이 메소드는, 지정된 <code>Point2D</code> 객체가 같은 1 개의 점의 변환 오퍼레이션의 전송원과 전송처의 양쪽 모두인 경우, 오퍼랜드 위에 결과가 포함되지 않게, 결과를 계산의 종료후까지 포함하지 않는 것을 보증합니다. 그러나, 전송처 <code>Point2D</code> 객체가 다른 오퍼레이션의 전송원배열에 놓여져 전송원 <code>Point2D</code> 객체가 되는 경우, 그 점의 원의 좌표는 변환 가능하게 되기 전에 덧쓰기됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ptSrc</CODE> - 전송원의 포인트 객체가 포함되고 있는 배열<DD><CODE>ptDst</CODE> - 변환 포인트 객체가 반환된다
 배열<DD><CODE>srcOff</CODE> - 전송원배열내의
 변환되는 최초의 포인트 객체에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 변환된 최초의 포인트 객체가 포함된다
 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 포인트 객체의 수<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="transform(float[], int, float[], int, int)"><!-- --></A> <H3>
transform</H3>
<PRE>
public void <B>transform</B>(float[]&nbsp;srcPts,
                      int&nbsp;srcOff,
                      float[]&nbsp;dstPts,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>이 변환에 의해, 부동 소수점의 좌표의 배열을 변환합니다. 2 개의 좌표 배열 섹션은 완전하게 같은가, 결과의 유효성에 영향을 주지 않고 같은 배열의 섹션을 오버랩 한 것입니다. 이 메소드는, 전송원의 좌표가 변환 가능하게 되기 전에, 지금까지의 오퍼레이션에 의해 덧쓰기되지 않는 것을 보증합니다. 좌표는, 지정된 오프셋(offset)로부터 시작되는 배열에 <code>[x0, y0, x1, y1, ..., xn, yn]</code> 라고 하는 순서로 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcPts</CODE> - 전송원의 점좌표가 돌려주어지고 있는 배열.
 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>dstPts</CODE> - 변환된 점좌표가 반환된다
 배열. 각 점은 x, &nbsp;y 좌표의 페어로서
 포함되는<DD><CODE>srcOff</CODE> - 전송원배열내의
 변환되는 최초의 점에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 변환된 최초의 점이 포함된다
 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 점의 수<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="transform(double[], int, double[], int, int)"><!-- --></A> <H3>
transform</H3>
<PRE>
public void <B>transform</B>(double[]&nbsp;srcPts,
                      int&nbsp;srcOff,
                      double[]&nbsp;dstPts,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>이 변환에 의해, 배정밀도의 좌표의 배열을 변환합니다. 2 개의 좌표 배열 섹션은 완전하게 같은가, 결과의 유효성에 영향을 주지 않고 같은 배열의 섹션을 오버랩 한 것입니다. 이 메소드는, 전송원의 좌표가 변환 가능하게 되기 전에, 지금까지의 오퍼레이션에 의해 덧쓰기되지 않는 것을 보증합니다. 좌표는, 지정된 오프셋(offset)로부터 시작되는 배열에 <code>[x0, y0, x1, y1, ..., xn, yn]</code> 라고 하는 순서로 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcPts</CODE> - 전송원의 점좌표가 돌려주어지고 있는 배열.
 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>dstPts</CODE> - 변환된 점좌표가 반환된다
 배열. 각 점은 x, &nbsp;y 좌표의 페어로서
 포함된다. <DD><CODE>srcOff</CODE> - 전송원배열내의
 변환되는 최초의 점에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 변환된 최초의 점이 포함된다
 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 포인트 객체의 수<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="transform(float[], int, double[], int, int)"><!-- --></A> <H3>
transform</H3>
<PRE>
public void <B>transform</B>(float[]&nbsp;srcPts,
                      int&nbsp;srcOff,
                      double[]&nbsp;dstPts,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>이 변환에 의해 부동 소수점의 좌표의 배열을 변환해, 결과를 double 치의 배열에 포함합니다. 좌표는, 지정된 오프셋(offset)로부터 시작되는 배열에 <code>[x0, y0, x1, y1, ..., xn, yn]</code> 라고 하는 순서로 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcPts</CODE> - 전송원의 점좌표가 돌려주어지고 있는 배열.
 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>dstPts</CODE> - 변환된 점좌표가 반환된다
 배열. 각 점은 x, &nbsp;y 좌표의 페어로서
 포함되는<DD><CODE>srcOff</CODE> - 전송원배열내의
 변환되는 최초의 점에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 변환된 최초의 점이 포함된다
 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 점의 수<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="transform(double[], int, float[], int, int)"><!-- --></A> <H3>
transform</H3>
<PRE>
public void <B>transform</B>(double[]&nbsp;srcPts,
                      int&nbsp;srcOff,
                      float[]&nbsp;dstPts,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>이 변환에 의해 배정밀도의 좌표의 배열을 변환해, 결과를 float 치의 배열에 포함합니다. 좌표는, 지정된 오프셋(offset)로부터 시작되는 배열에 <code>[x0, y0, x1, y1, ..., xn, yn]</code> 라고 하는 순서로 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcPts</CODE> - 전송원의 점좌표가 돌려주어지고 있는 배열.
 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>dstPts</CODE> - 변환된 점좌표가 반환된다
 배열. 각 점은 x, &nbsp;y 좌표의 페어로서 
 포함된다. <DD><CODE>srcOff</CODE> - 전송원배열내의
 변환되는 최초의 점에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 변환된 최초의 점이 포함된다
 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 포인트 객체의 수<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="inverseTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)"><!-- --></A> <H3>
inverseTransform</H3>
<PRE>
public <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 내의 클래스">Point2D</A>  <B>inverseTransform</B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptSrc,
                                <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptDst)
                         throws <A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 내의 클래스">NoninvertibleTransformException</A> </PRE>
<DL>
<DD>지정된 <code>ptSrc</code> 를 역변환해, 그 결과를 <code>ptDst</code> 에 포함합니다. <code>ptDst</code> 가 <code>null</code> 의 경우, 새로운 <code>Point2D</code> 객체를 할당할 수 있고 나서, 변환의 결과가 이 객체에 포함됩니다. 어느 쪽의 경우도, 편의상, 변환 후의 점을 포함하고 있는 <code>ptDst</code> 가 돌려주어집니다. <code>ptSrc</code> 와 <code>ptDst</code> 가 같은 객체의 경우, 입력점은 변환 후의 점으로써 적절히 덧쓰기됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ptSrc</CODE> - 역변환되는 점<DD><CODE>ptDst</CODE> - 결과적으로 생성되는 변환 후의 점
<DT><B>반환값:</B><DD>역변환의 결과를 포함하고 있다 
 <code>ptDst</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 안의 클래스">NoninvertibleTransformException</A> </CODE> - 행렬을 반전할 수 없다
                                         경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="inverseTransform(double[], int, double[], int, int)"><!-- --></A> <H3>
inverseTransform</H3>
<PRE>
public void <B>inverseTransform</B>(double[]&nbsp;srcPts,
                             int&nbsp;srcOff,
                             double[]&nbsp;dstPts,
                             int&nbsp;dstOff,
                             int&nbsp;numPts)
                      throws <A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 내의 클래스">NoninvertibleTransformException</A> </PRE>
<DL>
<DD>이 변환에 의해 배정밀도의 좌표의 배열을 역변환합니다. 2 개의 좌표 배열 섹션은 완전하게 같은가, 결과의 유효성에 영향을 주지 않고 같은 배열의 섹션을 오버랩 한 것입니다. 이 메소드는, 전송원의 좌표가 변환 가능하게 되기 전에, 지금까지의 오퍼레이션에 의해 덧쓰기되지 않는 것을 보증합니다. 좌표는, 지정된 오프셋(offset)로부터 시작되는 배열에 <code>[x0, y0, x1, y1, ..., xn, yn]</code> 라고 하는 순서로 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcPts</CODE> - 전송원의 점좌표가 돌려주어지고 있는 배열.
 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>dstPts</CODE> - 변환된 점좌표가 반환된다
 배열. 각 점은 x, &nbsp;y 좌표의 페어로서 
 포함된다. <DD><CODE>srcOff</CODE> - 전송원배열내의
 변환되는 최초의 점에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 변환된 최초의 점이 포함된다
 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 포인트 객체의 수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 안의 클래스">NoninvertibleTransformException</A> </CODE> - 행렬을 반전할 수 없다
                                         경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="deltaTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)"><!-- --></A> <H3>
deltaTransform</H3>
<PRE>
public <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 내의 클래스">Point2D</A>  <B>deltaTransform</B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptSrc,
                              <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptDst)</PRE>
<DL>
<DD><code>ptSrc</code> 에 의해 지정되는 상대적인 거리 벡터를 변환해, 그 결과를 <code>ptDst</code> 에 포함합니다. 상대적 거리 벡터는, 아핀 변환 행렬의 평행이동 컴퍼넌트를 적용하는 일 없이, 다음의 식을 사용해 변환됩니다.
 <pre>
        [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
        [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
        [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
 </pre>
<code>ptDst</code> 가 <code>null</code> 의 경우, 새로운 <code>Point2D</code> 객체를 할당할 수 있고 나서, 변환의 결과가 이 객체에 포함됩니다. 어느 쪽의 경우도, 편의상, 변환 후의 점을 포함하고 있는 <code>ptDst</code> 가 돌려주어집니다. <code>ptSrc</code> 와 <code>ptDst</code> 가 같은 객체의 경우, 입력점은 변환 후의 점으로써 적절히 덧쓰기됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ptSrc</CODE> - 델타 변환되는 거리 벡터<DD><CODE>ptDst</CODE> - 결과적으로 변환된 거리 벡터
<DT><B>반환값:</B><DD>변환의 결과를 포함하고 있다 
 <code>ptDst</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="deltaTransform(double[], int, double[], int, int)"><!-- --></A> <H3>
deltaTransform</H3>
<PRE>
public void <B>deltaTransform</B>(double[]&nbsp;srcPts,
                           int&nbsp;srcOff,
                           double[]&nbsp;dstPts,
                           int&nbsp;dstOff,
                           int&nbsp;numPts)</PRE>
<DL>
<DD>이 변환에 의해 상대적인 거리 벡터의 배열을 변환합니다. 상대적 거리 벡터는, 아핀 변환 행렬의 평행이동 컴퍼넌트를 적용하는 일 없이, 다음의 식을 사용해 변환됩니다.
 <pre>
        [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
        [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
        [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
 </pre>
2 개의 좌표 배열 섹션은 완전하게 같은가, 결과의 유효성에 영향을 주지 않고 같은 배열의 섹션을 오버랩 한 것입니다. 이 메소드는, 전송원의 좌표가 변환 가능하게 되기 전에, 지금까지의 오퍼레이션에 의해 덧쓰기되지 않는 것을 보증합니다. 좌표는, 지정된 오프셋(offset)로부터 시작되는 배열에 <code>[x0, y0, x1, y1, ..., xn, yn]</code> 라고 하는 순서로 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcPts</CODE> - 전송원의 거리 벡터가 포함되고 있는 배열.
 각 벡터는 상대 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>dstPts</CODE> - 변환 끝난 거리 벡터가 반환된다
 배열. 각 벡터는 상대 x, &nbsp;y 좌표의 페어로서
 포함된다. <DD><CODE>srcOff</CODE> - 전송원배열내의
 변환되는 최초의 벡터에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 변환된 최초의 벡터가 포함된다
 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 벡터 좌표 페어의
 수<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="createTransformedShape(java.awt.Shape)"><!-- --></A> <H3>
createTransformedShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>createTransformedShape</B>(<A HREF="../../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;pSrc)</PRE>
<DL>
<DD>지정된 <code>Shape</code> 를 이 변환에 의해 변환해, 그 <code>Shape</code> 의 기하학적 도형에 의해 정의되는 새로운 <A HREF="../../../java/awt/Shape.html" title="java.awt 동안의 인터페이스"><CODE>Shape</CODE></A>  객체를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pSrc</CODE> - 이 변환으로 변환되는 지정되었다 
 <code>Shape</code> 객체
<DT><B>반환값:</B><DD>변환된 <code>Shape</code> 의 기하학적 도형을 정의한다
 새로운 <code>Shape</code> 객체,<code>pSrc</code> 가 null 의 경우는 null<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스"><CODE>Object</CODE></A>  의 값을 나타내는 <code>String</code> 를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>Object</code> 의 값을 나타낸다 
 <code>String</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isIdentity()"><!-- --></A> <H3>
isIdentity</H3>
<PRE>
public boolean <B>isIdentity</B>()</PRE>
<DL>
<DD>이 <code>AffineTransform</code> 이 항등변환인 경우에 <code>true</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>AffineTransform</code> 가 항등변환인 경우는 <code>true</code>,
 그렇지 않은 경우는 <code>false</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="clone()"><!-- --></A> <H3>
clone</H3>
<PRE>
public <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>clone</B>()</PRE>
<DL>
<DD>이 <code>AffineTransform</code> 객체의 카피를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>AffineTransform</code> 객체의 카피이다 
 <code>Object</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스"><CODE>Cloneable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>이 변환의 해시 코드를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 변환의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Object.html#equals(java.lang.Object)"><CODE>Object.equals(java.lang.Object)</CODE></A> , 
<A HREF="../../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>이 <code>AffineTransform</code> 이, 지정된 인수와 같은 아핀 좌표변화를 표현하는 경우에 <code>true</code> 를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 이 <code>AffineTransform</code> 와 같은가 어떤가가 비교된다 
 <code>Object</code>
<DT><B>반환값:</B><DD><code>obj</code> 가 이 <code>AffineTransform</code> 객체와 동일한 경우는
 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A> , 
<A HREF="../../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AffineTransform.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;전의 클래스 &nbsp;
&nbsp;<A HREF="../../../java/awt/geom/Arc2D.html" title="java.awt.geom 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/awt/geom/AffineTransform.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="AffineTransform.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
