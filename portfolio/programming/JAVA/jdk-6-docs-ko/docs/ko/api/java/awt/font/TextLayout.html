<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:55:18 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
TextLayout (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="TextLayout (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/TextLayout.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/awt/font/TextLayout.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="TextLayout.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt.font</FONT>
<BR>
클래스 TextLayout</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.awt.font.TextLayout</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스">Cloneable</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public final class <B>TextLayout</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스">Cloneable</A> </DL>
</PRE>

<P>
<code>TextLayout</code> 는, 서식 첨부 문자 데이터의 불변의 그래픽 표현입니다.  &nbsp;<p>
이 클래스는 다음의 기능을 제공합니다.
 <ul>
<li>암묵적인 쌍방향의 분석과 늘어놓고 대체
<li>커서의 위치 지정과 이동 (혼합 방향 텍스트를 위한 분할 커서를 포함한다)
<li>하이라이트 (혼합 방향 텍스트를 위한 논리적 하이라이트와 시각적 하이라이트를 포함한다)
<li>복수의 baseline (낭만 baseline, 매달려 baseline, 및 센터 baseline)
<li>히트의 테스트
<li>위치 가지런히 하고
<li>디폴트 폰트의 치환
<li>아센트, 디 센트, 및 유효폭등의 시학 정보
<li>draw
 </ul>
 <p>
<code>TextLayout</code> 객체는,<code>draw</code> 메소드를 사용해 draw 할 수 있습니다.  &nbsp;<p>
<code>TextLayout</code> 는, 직접 또는 <A HREF="../../../java/awt/font/LineBreakMeasurer.html" title="java.awt.font 안의 클래스"><CODE>LineBreakMeasurer</CODE></A>  를 개입시켜 작성할 수 있습니다. 직접 작성되는 경우, 소스 텍스트는 1 개의 단락을 나타냅니다. <code>LineBreakMeasurer</code> 에서는, 특정의 폭에 들어가는 복수의 행에 서식 첨부 텍스트를 분할할 수 있습니다. 자세한 것은,<code>LineBreakMeasurer</code> 의 문서를 참조해 주세요.  &nbsp;<p>
<code>TextLayout</code> 의 구축은, 논리적이게는 다음의 순서로 행해집니다.
 <ul>
<li>단락 속성이 추출되어 조사할 수 있다
<li>쌍방향이 늘어놓고 바꾸고를 위해서(때문에) 텍스트가 분석되어 필요한 경우는 늘어놓고 바꾸고 정보가 계산된다
<li>텍스트가 스타일 런에 부분화된다
<li>스타일 런용의 폰트가 선택된다.  선택 방법은, 최초로 속성 <A HREF="../../../java/awt/font/TextAttribute.html#FONT"><CODE>TextAttribute.FONT</CODE></A>  가 있는 경우는 폰트가 사용되어 그렇지 않은 경우는, 정의 끝난 속성을 사용해 디폴트 폰트가 계산된다
<li>텍스트가 복수의 baseline에 있는 경우, 런 또는 서브 런은 공통의 baseline를 공유하는 서브 런에 한층 더 분할된다
<li>선택된 폰트를 사용해 각 런에 Glyph베크톨이 생성된다
<li>최종적인 쌍방향이 늘어놓고 바꾸고가 Glyph베크톨로 실행된다
 </ul>
 <p>
<code>TextLayout</code> 객체의 메소드로부터 반환되는 모든 그래픽 정보는,<code>TextLayout</code> 객체의 baseline와 좌단의 교점인 <code>TextLayout</code> 의 원점을 기준으로 하고 있습니다. 또,<code>TextLayout</code> 객체의 메소드에게 건네지는 좌표는,<code>TextLayout</code> 객체의 원점을 기준으로 하고 있는 것이라고 보여집니다. 일반적으로, 클라이언트는,<code>TextLayout</code> 객체의 좌표계와 다른 객체 (<A HREF="../../../java/awt/Graphics.html" title="java.awt 안의 클래스"><CODE>Graphics</CODE></A>  객체등)의 좌표계와의 사이에 변환이 필요하게 됩니다.  &nbsp;<p>
<code>TextLayout</code> 객체는, 서식 첨부 텍스트로부터 구축됩니다만, 소스 텍스트에의 참조는 보관 유지하지 않습니다. 이 때문에,<code>TextLayout</code> 를 생성하기 위해서 사용된 텍스트에 그 후 변경이 더해져도,<code>TextLayout</code> 에 영향은 없습니다.  &nbsp;<p>
<code>TextLayout</code> 객체의 3 개의 메소드 (<code>getNextRightHit</code>,<code>getNextLeftHit</code>, 및 <code>hitTestChar</code>)는,<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스"><CODE>TextHitInfo</CODE></A>  의 인스턴스를 돌려줍니다. 그러한 <code>TextHitInfo</code> 객체에 포함되는 오프셋(offset)는,<code>TextLayout</code> 를 작성하기 위해서 사용된 텍스트는 아니고,<code>TextLayout</code> 의 선두를 기준으로 합니다. 똑같이,<code>TextHitInfo</code> 의 인스턴스를 파라미터로서 받는 <code>TextLayout</code> 의 메소드도,<code>TextHitInfo</code> 객체의 오프셋(offset)의 기준은 <code>TextLayout</code> 이며, 기본이 되는 텍스트 스토리지 모델은 아니면 상정합니다.  &nbsp;<p>
<strong>례</strong>:<p>
<code>TextLayout</code> 와 그 경계의 구형의 작성 및 draw
 <blockquote><pre>
   Graphics2D g = ...;
   Point2D loc = ...;
   Font font = Font.getFont("Helvetica-bold-italic");
   FontRenderContext frc = g.getFontRenderContext();
   TextLayout layout = new TextLayout("This is a string", font, frc);
   layout.draw(g, (float) loc.getX(), (float) loc.getY());

   Rectangle2D bounds = layout.getBounds();
   bounds.setRect(bounds.getX() +loc.getX(),
                  bounds.getY() +loc.getY(),
                  bounds.getWidth(),
                  bounds.getHeight());
   g.draw(bounds);
 </pre>
 </blockquote>
 <p>
<code>TextLayout</code> 로 히트를 테스트합니다 (특정의 그래픽 위치에 있는 문자를 판정한다).
 <blockquote><pre>
   Point2D click = ...;
   TextHitInfo hit = layout.hitTestChar(
                         (float) (click.getX() - loc.getX()),
                         (float) (click.getY() - loc.getY()));
 </pre>
 </blockquote>
 <p>
오른쪽 커서 키가 밀렸던 것에 반응합니다.
 <blockquote><pre>
   int insertionIndex = ...;
   TextHitInfo next = layout.getNextRightHit(insertionIndex);
   if (next ! = null) {
       // translate graphics to origin of layout on screen
       g.translate(loc.getX(), loc.getY());
       Shape[] carets = layout.getCaretShapes(next.getInsertionIndex());
       g.draw(carets[0]);
       if (carets[1] ! = null) {
           g.draw(carets[1]);
       }
   }
 </pre></blockquote>
 <p>
소스 텍스트의 부분 캐릭터 라인에 대응하는 선택 범위를 draw 합니다. 선택된 영역은, 시각적으로 연속하지 않은 경우가 있습니다.
 <blockquote><pre>
   // selStart, selLimit should be relative to the layout,
   // not to the source text

   int selStart = ..., selLimit = ...;
   Color selectionColor = ...;
   Shape selection = layout.getLogicalHighlightShape(selStart, selLimit);
   // selection may consist of disjoint areas
   // graphics is assumed to be tranlated to origin of layout
   g.setColor(selectionColor);
   g.fill(selection);
 </pre></blockquote>
 <p>
시각적으로 연속한 선택 범위를 draw 합니다. 선택 범위는, 소스 텍스트의 복수의 부분 캐릭터 라인에 대응하는 일이 있습니다. 대응하는 소스 텍스트의 부분 캐릭터 라인의 범위는,<code>getLogicalRangesForVisualSelection()</code> 에 의해 취득할 수 있습니다.
 <blockquote><pre>
   TextHitInfo selStart = ..., selLimit = ...;
   Shape selection = layout.getVisualHighlightShape(selStart, selLimit);
   g.setColor(selectionColor);
   g.fill(selection);
   int[] ranges = getLogicalRangesForVisualSelection(selStart, selLimit);
   // ranges[0], ranges[1] is the first selection range,
   // ranges[2], ranges[3] is the second selection range, etc.
 </pre></blockquote>
 <p>
주:폰트를 회전하면(자) 텍스트의 baseline가 회전하는 일이 있어, 복수의 런으로 회전이 다르면(자), baseline가 굴곡 하거나 지그재그가 되는 일이 있습니다. 이 보기 드문 가능성에 대처하기 위해서, 일부의 폰트 API 는 지정에 따라 「baseline를 기준으로 한 좌표로」메트릭스를 돌려주거나 파라미터를 받거나 합니다 (아센트나 유효폭 등). 그 이외의 API 는, 「표준의 좌표로」처리합니다 (getBounds 등). baseline를 기준으로 한 좌표에서는, x 좌표는 baseline에 따른 거리 (정의 x 는 baseline에 따라 진행될 방향), y 좌표는 x 에서의 baseline에 대한 수선에 따른 거리 (정의 y 는 baseline 벡터로부터 시계회전에 90 번의 방향)에 맵 됩니다. 표준의 좌표에서는, 좌표는 TextLayout 의 원점을 0,0 으로서 x 축 및 y 축으로 따라 측정됩니다. 관련하는 각 API 의 문서에는, 어느 값이 어느 좌표계로 나타내질지가 나타나고 있습니다. 일반적으로, 측정에 관련하는 API 는 baseline를 기준으로 한 좌표, 표시에 관련하는 API 는 표준의 좌표를 사용합니다.
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html" title="java.awt.font 내의 클래스"><CODE>LineBreakMeasurer</CODE></A> , 
<A HREF="../../../java/awt/font/TextAttribute.html" title="java.awt.font 안의 클래스"><CODE>TextAttribute</CODE></A> , 
<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스"><CODE>TextHitInfo</CODE></A> , 
<A HREF="../../../java/awt/font/LayoutPath.html" title="java.awt.font 안의 클래스"><CODE>LayoutPath</CODE></A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;강한 caret의 장소를 결정하는 정책를 정의합니다. </TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 내의 클래스">TextLayout.CaretPolicy</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#DEFAULT_CARET_POLICY">DEFAULT_CARET_POLICY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CaretPolicy</code> 는, 정책가 클라이언트에 의해 지정되어 있지 않은 경우에 사용됩니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#TextLayout(java.text.AttributedCharacterIterator, java.awt.font.FontRenderContext)">TextLayout</A> </B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;text,
           <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서식 첨부 텍스트의 반복자로부터 <code>TextLayout</code> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#TextLayout(java.lang.String, java.awt.Font, java.awt.font.FontRenderContext)">TextLayout</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;string,
           <A HREF="../../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font,
           <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>String</code> 및 <A HREF="../../../java/awt/Font.html" title="java.awt 안의 클래스"><CODE>Font</CODE></A>  로부터 <code>TextLayout</code> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#TextLayout(java.lang.String, java.util.Map, java.awt.font.FontRenderContext)">TextLayout</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;string,
           <A HREF="../../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?  extends <A HREF="../../../java/text/AttributedCharacterIterator.Attribute.html" title="java.text 내의 클래스">AttributedCharacterIterator.Attribute</A> ,? &gt;&nbsp;attributes,
           <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>String</code> 및 속성 세트로부터 <code>TextLayout</code> 를 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#clone()">clone</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 의 카피를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#draw(java.awt.Graphics2D, float, float)">draw</A> </B>(<A HREF="../../../java/awt/Graphics2D.html" title="java.awt 안의 클래스">Graphics2D</A> &nbsp;g2,
     float&nbsp;x,
     float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <A HREF="../../../java/awt/Graphics2D.html" title="java.awt 동안의 클래스"><CODE>Graphics2D</CODE></A>  문맥의 지정된 위치에 이 <code>TextLayout</code> 를 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#equals(java.lang.Object)">equals</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>Object</code> 가 <code>TextLayout</code> 객체로, 지정된 <code>Object</code> 가 이 <code>TextLayout</code> 와 동일한 경우에 <code>true</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#equals(java.awt.font.TextLayout)">equals</A> </B>(<A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 안의 클래스">TextLayout</A> &nbsp;rhs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 개의 레이아웃이 동일한 경우에 <code>true</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getAdvance()">getAdvance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 의 유효폭을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getAscent()">getAscent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 의 아센트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getBaseline()">getBaseline</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 의 baseline를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getBaselineOffsets()">getBaselineOffsets</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 로 사용되는 baseline의 오프셋(offset) 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getBlackBoxBounds(int, int)">getBlackBoxBounds</A> </B>(int&nbsp;firstEndpoint,
                  int&nbsp;secondEndpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 범위에 있는 모든 문자의 블랙 박스 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 내의 클래스">Rectangle2D</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getBounds()">getBounds</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 의 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretInfo(java.awt.font.TextHitInfo)">getCaretInfo</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>hit</code> 에 대응하는 caret에 대한 정보를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretInfo(java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)">getCaretInfo</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit,
             <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>hit</code> 에 대응하는 caret에 대한 정보를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShape(java.awt.font.TextHitInfo)">getCaretShape</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 의 자연 경계내의 지정된 히트에 있는 caret를 나타내는 <code>Shape</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShape(java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)">getCaretShape</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit,
              <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 경계내의 지정된 히트에 있는 caret를 나타내는 <A HREF="../../../java/awt/Shape.html" title="java.awt 동안의 인터페이스"><CODE>Shape</CODE></A>  를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShapes(int)">getCaretShapes</A> </B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;강한 caret와 약한 caret에 대응하는 2 개의 윤곽선을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShapes(int, java.awt.geom.Rectangle2D)">getCaretShapes</A> </B>(int&nbsp;offset,
               <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;강한 caret와 약한 caret에 대응하는 2 개의 윤곽선을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShapes(int, java.awt.geom.Rectangle2D, java.awt.font.TextLayout.CaretPolicy)">getCaretShapes</A> </B>(int&nbsp;offset,
               <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds,
               <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> &nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;강한 caret와 약한 caret에 대응하는 2 개의 윤곽선을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCharacterCount()">getCharacterCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 가 나타내는 문자수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCharacterLevel(int)">getCharacterLevel</A> </B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index</code> 에 있는 문자의 레벨을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getDescent()">getDescent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 의 디 센트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스">TextLayout</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getJustifiedLayout(float)">getJustifiedLayout</A> </B>(float&nbsp;justificationWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 폭에 행 가지런히 하고 된, 이 <code>TextLayout</code> 의 카피를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/LayoutPath.html" title="java.awt.font 내의 클래스">LayoutPath</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLayoutPath()">getLayoutPath</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LayoutPath 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLeading()">getLeading</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TextLayout</code> 의 leading를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLogicalHighlightShape(int, int)">getLogicalHighlightShape</A> </B>(int&nbsp;firstEndpoint,
                         int&nbsp;secondEndpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 범위의 논리적인 선택 범위를 둘러싸는 <code>Shape</code> 를, 이 <code>TextLayout</code> 의 자연 경계까지 확장해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLogicalHighlightShape(int, int, java.awt.geom.Rectangle2D)">getLogicalHighlightShape</A> </B>(int&nbsp;firstEndpoint,
                         int&nbsp;secondEndpoint,
                         <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 범위의 논리적인 선택 범위를 둘러싸는 <code>Shape</code> 를, 지정된 <code>bounds</code> 까지 확장해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLogicalRangesForVisualSelection(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)">getLogicalRangesForVisualSelection</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;firstEndpoint,
                                   <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;secondEndpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;시각적인 선택 범위에 대응하는 텍스트의 논리적인 범위를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextLeftHit(int)">getNextLeftHit</A> </B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;왼쪽 (상) 방향의 다음의 caret의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextLeftHit(int, java.awt.font.TextLayout.CaretPolicy)">getNextLeftHit</A> </B>(int&nbsp;offset,
               <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> &nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;왼쪽 (상) 방향의 다음의 caret의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextLeftHit(java.awt.font.TextHitInfo)">getNextLeftHit</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;왼쪽 (상) 방향의 다음의 caret의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextRightHit(int)">getNextRightHit</A> </B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 오른쪽 (하) 방향의 다음의 caret의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextRightHit(int, java.awt.font.TextLayout.CaretPolicy)">getNextRightHit</A> </B>(int&nbsp;offset,
                <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> &nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 오른쪽 (하) 방향의 다음의 caret의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextRightHit(java.awt.font.TextHitInfo)">getNextRightHit</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 오른쪽 (하) 방향의 다음의 caret의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getOutline(java.awt.geom.AffineTransform)">getOutline</A> </B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 의 윤곽을 나타내는 <code>Shape</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getPixelBounds(java.awt.font.FontRenderContext, float, float)">getPixelBounds</A> </B>(<A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc,
               float&nbsp;x,
               float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 위치에서 지정된 <code>FontRenderContext</code> 를 사용해, 그래픽스내에 이 <code>TextLayout</code> 가 draw 될 때의 인덱스의 위치에 있는 Glyph의 픽셀 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getVisibleAdvance()">getVisibleAdvance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 의 유효폭을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)">getVisualHighlightShape</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;firstEndpoint,
                        <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;secondEndpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 범위의 시각적인 선택 범위를 둘러싸는 <code>Shape</code> 를, 경계까지 확장해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)">getVisualHighlightShape</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;firstEndpoint,
                        <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;secondEndpoint,
                        <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 범위의 시각적인 선택 범위를 둘러싸는 윤곽선을,<code>bounds</code> 까지 확장해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getVisualOtherHit(java.awt.font.TextHitInfo)">getVisualOtherHit</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 히트의 caret의 반대측의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#handleJustify(float)">handleJustify</A> </B>(float&nbsp;justificationWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 레이아웃을 행 가지런히 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#hashCode()">hashCode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 의 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#hitTestChar(float, float)">hitTestChar</A> </B>(float&nbsp;x,
            float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 점에 대응하는 <code>TextHitInfo</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#hitTestChar(float, float, java.awt.geom.Rectangle2D)">hitTestChar</A> </B>(float&nbsp;x,
            float&nbsp;y,
            <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 점에 대응하는 <code>TextHitInfo</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#hitToPoint(java.awt.font.TextHitInfo, java.awt.geom.Point2D)">hitToPoint</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit,
           <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;point)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;히트를 표준 좌표의 포인트로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#isLeftToRight()">isLeftToRight</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 의 베이스가 될 방향이 왼쪽에서 오른쪽의 경우에 <code>true</code> 를 돌려주어, 오른쪽에서 왼쪽의 경우에 <code>false</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#isVertical()">isVertical</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 가 수직의 경우에 <code>true</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 의 디버그 정보를 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DEFAULT_CARET_POLICY"><!-- --></A> <H3>
DEFAULT_CARET_POLICY</H3>
<PRE>
public static final <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 내의 클래스">TextLayout.CaretPolicy</A>  <B>DEFAULT_CARET_POLICY</B></PRE>
<DL>
<DD>이 <code>CaretPolicy</code> 는, 정책가 클라이언트에 의해 지정되어 있지 않은 경우에 사용됩니다. 이 정책에서는, 방향이 행의 방향과 같은 문자의 히트가, 반대 방향의 문자의 히트보다 강해집니다. 문자의 방향이 같은 경우, 문자의 리딩 엣지의 히트가, 문자의 트레이 링 엣지의 히트보다 강해집니다.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="TextLayout(java.lang.String, java.awt.Font, java.awt.font.FontRenderContext)"><!-- --></A> <H3>
TextLayout</H3>
<PRE>
public <B>TextLayout</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;string,
                  <A HREF="../../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font,
                  <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</PRE>
<DL>
<DD><code>String</code> 및 <A HREF="../../../java/awt/Font.html" title="java.awt 안의 클래스"><CODE>Font</CODE></A>  로부터 <code>TextLayout</code> 를 구축합니다. 모든 텍스트는, 지정된 <code>Font</code> 를 사용해 서식이 설정됩니다.  &nbsp;<p>
<code>String</code> 에는, 1 단락의 텍스트를 지정할 필요가 있습니다. 쌍방향 알고리즘에서는, 단락 전체가 요구되기 때문입니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>string</CODE> - 표시하는 텍스트<DD><CODE>font</CODE> - 텍스트의 서식을 설정하기 위해서 사용되는 <code>Font</code><DD><CODE>frc</CODE> - 텍스트를 정확하게 측정하기 위해서 필요한
       그래픽스 디바이스에 관한 정보를 포함한다.
       텍스트 측정은, 디바이스의 해상도에 의해 조금 달라,
       에일리어징 제거등의 속성에 따라서 다르다.
       이 파라미터는,
       <code>TextLayout</code> 와 사용자 공간의 사이의 이동은 지정하지 않는다</DL>
</DL>
<HR>

<A NAME="TextLayout(java.lang.String, java.util.Map, java.awt.font.FontRenderContext)"><!-- --></A> <H3>
TextLayout</H3>
<PRE>
public <B>TextLayout</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;string,
                  <A HREF="../../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?  extends <A HREF="../../../java/text/AttributedCharacterIterator.Attribute.html" title="java.text 내의 클래스">AttributedCharacterIterator.Attribute</A> ,? &gt;&nbsp;attributes,
                  <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</PRE>
<DL>
<DD><code>String</code> 및 속성 세트로부터 <code>TextLayout</code> 를 구축합니다.  &nbsp;<p>
모든 텍스트는, 지정된 속성에 의해 서식이 설정됩니다.  &nbsp;<p>
<code>string</code> 에는, 1 단락의 텍스트를 지정할 필요가 있습니다. 쌍방향 알고리즘에서는, 단락 전체가 요구되기 때문입니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>string</CODE> - 표시하는 텍스트<DD><CODE>attributes</CODE> - 텍스트의 서식을 설정하기 위해서 사용되는 속성<DD><CODE>frc</CODE> - 텍스트를 정확하게 측정하기 위해서 필요한
       그래픽스 디바이스에 관한 정보를 포함한다.
       텍스트 측정은, 디바이스의 해상도에 의해 조금 달라,
       에일리어징 제거등의 속성에 따라서 다르다.
       이 파라미터는,
       <code>TextLayout</code> 와 사용자 공간의 사이의 이동은 지정하지 않는다</DL>
</DL>
<HR>

<A NAME="TextLayout(java.text.AttributedCharacterIterator, java.awt.font.FontRenderContext)"><!-- --></A> <H3>
TextLayout</H3>
<PRE>
public <B>TextLayout</B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;text,
                  <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</PRE>
<DL>
<DD>서식 첨부 텍스트의 반복자로부터 <code>TextLayout</code> 를 구축합니다.  &nbsp;<p>
반복자는, 1 단락의 텍스트를 지정할 필요가 있습니다. 쌍방향 알고리즘에서는, 단락 전체가 요구되기 때문입니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>text</CODE> - 표시하는 서식 첨부 텍스트<DD><CODE>frc</CODE> - 텍스트를 정확하게 측정하기 위해서 필요한
       그래픽스 디바이스에 관한 정보를 포함한다.
       텍스트 측정은, 디바이스의 해상도에 의해 조금 달라,
       에일리어징 제거등의 속성에 따라서 다르다.
       이 파라미터는,
       <code>TextLayout</code> 와 사용자 공간의 사이의 이동은 지정하지 않는다</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="clone()"><!-- --></A> <H3>
clone</H3>
<PRE>
protected <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>clone</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 의 카피를 작성합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 인스턴스의 복제<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스"><CODE>Cloneable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getJustifiedLayout(float)"><!-- --></A> <H3>
getJustifiedLayout</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스">TextLayout</A>  <B>getJustifiedLayout</B>(float&nbsp;justificationWidth)</PRE>
<DL>
<DD>지정된 폭에 행 가지런히 하고 된, 이 <code>TextLayout</code> 의 카피를 작성합니다.  &nbsp;<p>
이 <code>TextLayout</code> 가 벌써 행 가지런히 하고 되고 있는 경우는 예외가 throw 됩니다. 이 <code>TextLayout</code> 객체의 행 가지런히 하고 비율이 제로의 경우, 이 <code>TextLayout</code> 과 동일한 <code>TextLayout</code> 가 돌려주어집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>justificationWidth</CODE> - 행 가지런히 하고 하기 위해서 사용하는 폭.
 최선의 결과를 얻기 위해서(때문에)는,
 행의 현재의 유효폭과의 차이는 작은 것이 좋다
<DT><B>반환값:</B><DD>지정된 폭에 행 가지런히 하고 된 <code>TextLayout</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/Error.html" title="java.lang 안의 클래스">Error</A> </CODE> - 이 레이아웃이 벌써 행 가지런히 하고 되고 있는 경우, Error 가
 throw 된다</DL>
</DD>
</DL>
<HR>

<A NAME="handleJustify(float)"><!-- --></A> <H3>
handleJustify</H3>
<PRE>
protected void <B>handleJustify</B>(float&nbsp;justificationWidth)</PRE>
<DL>
<DD>이 레이아웃을 행 가지런히 합니다. 행 가지런히 하고를 제어하기 위해서 사브크라사에 의해 오버라이드(override) 됩니다 (사브크라사가 있는 경우).

레이아웃은, 단락의 속성 (소스 텍스트로부터 파생.  레이아웃 속성에 의해 디폴트로 설정되는 경우가 있다)가 제로 이외의 행 가지런히 하고 비율을 나타내는 경우에만 행 가지런히 하고를 실시합니다. 텍스트는, 지정된 폭에 행 가지런히 하고 됩니다. 현재의 구현은, 행 가지런히 하고 폭을 채우기 위해서(때문에) 한깅판크츄에이션이나 말미의 공백도 조정합니다. 레이아웃은, 일단 행 가지런히 하고 된 뒤는, 행 가지런히 다시 할 수가 없습니다.  &nbsp;<p>
코드에 따라서는, 레이아웃의 불변성에 의존하는 경우가 있습니다. 사브크라사는 이 메소드를 직접 호출하는 것이 아니라, getJustifiedLayout 를 호출하는 것이 좋을 것입니다.  getJustifiedLayout 는, 이 레이아웃의 복제에 대해서 이 메소드를 호출하므로, 원의 레이아웃은 보존됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>justificationWidth</CODE> - 행 가지런히 하고 하기 위해서 사용하는 폭.
 최선의 결과를 얻기 위해서(때문에)는,
 행의 현재의 유효폭과의 차이는 작은 것이 좋은<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getJustifiedLayout(float)"><CODE>getJustifiedLayout(float)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBaseline()"><!-- --></A> <H3>
getBaseline</H3>
<PRE>
public byte <B>getBaseline</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 의 baseline를 돌려줍니다. baseline는,<code>Font</code> 로 정의되는 값 (roman, centered, hanging)의 1 개입니다. 아센트 및 디 센트는, 이 baseline를 기준으로 합니다. <code>baselineOffsets</code> 도 이 baseline를 기준으로 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 의 baseline<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getBaselineOffsets()"><CODE>getBaselineOffsets()</CODE></A> , 
<A HREF="../../../java/awt/Font.html" title="java.awt 안의 클래스"><CODE>Font</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBaselineOffsets()"><!-- --></A> <H3>
getBaselineOffsets</H3>
<PRE>
public float[] <B>getBaselineOffsets</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 로 사용되는 baseline의 오프셋(offset) 배열을 돌려줍니다.  &nbsp;<p>
이 배열은,<code>Font</code> 로 정의되는 값 (roman, centered, hanging)의 1 개로 인덱스 붙이고 됩니다. 이러한 값은, 이 <code>TextLayout</code> 객체의 baseline를 기준으로 합니다.  그 때문에,<code>getBaselineOffsets[getBaseline()] == 0</code> 이 됩니다. 오프셋(offset)를 <code>TextLayout</code> 객체의 baseline의 위치에 가산하면(자), 새로운 baseline의 위치를 취득할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 에 사용되는 baseline를 포함한다
    오프셋(offset) 배열<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getBaseline()"><CODE>getBaseline()</CODE></A> , 
<A HREF="../../../java/awt/Font.html" title="java.awt 안의 클래스"><CODE>Font</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAdvance()"><!-- --></A> <H3>
getAdvance</H3>
<PRE>
public float <B>getAdvance</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 의 유효폭을 돌려줍니다. 유효폭은, 원점에서 우단 (하단)의 문자의 유효폭까지의 거리입니다. 이것은 baseline를 기준으로 한 좌표로 나타내집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 의 유효폭</DL>
</DD>
</DL>
<HR>

<A NAME="getVisibleAdvance()"><!-- --></A> <H3>
getVisibleAdvance</H3>
<PRE>
public float <B>getVisibleAdvance</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 의 유효폭을 돌려줍니다. 말미의 공백은 포함되지 않습니다. 이것은 baseline를 기준으로 한 좌표로 나타내집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 의 말미의 공백을 제외했다
      유효폭<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getAdvance()"><CODE>getAdvance()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAscent()"><!-- --></A> <H3>
getAscent</H3>
<PRE>
public float <B>getAscent</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 의 아센트를 돌려줍니다. 아센트는,<code>TextLayout</code> 위 ( 오른쪽)로부터 baseline까지의 거리입니다. 이 거리는 항상 정의 값 또는 제로입니다. 아센트는, 상 첨부 텍스트를 포함하기 위해서 충분한 크기이며, 각 Glyph의 아센트, 오프셋(offset), 및 baseline의 합계의 최대치입니다. 이것은, TextLayout 내의 모든 텍스트의 baseline로부터의 최대 아센트입니다. baseline를 기준으로 한 좌표로 나타내집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 의 아센트</DL>
</DD>
</DL>
<HR>

<A NAME="getDescent()"><!-- --></A> <H3>
getDescent</H3>
<PRE>
public float <B>getDescent</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 의 디 센트를 돌려줍니다. 디 센트는, baseline로부터 <code>TextLayout</code> 아래 (왼쪽)까지의 거리입니다. 이 거리는 항상 정의 값 또는 제로입니다. 디 센트는, 하부나무 텍스트를 포함하기 위해서 충분한 크기이며, 각 Glyph의 디 센트, 오프셋(offset), 및 baseline의 합계의 최대치입니다. 이것은, TextLayout 내의 모든 텍스트의 baseline로부터의 최대 디 센트입니다. baseline를 기준으로 한 좌표로 나타내집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 의 디 센트</DL>
</DD>
</DL>
<HR>

<A NAME="getLeading()"><!-- --></A> <H3>
getLeading</H3>
<PRE>
public float <B>getLeading</B>()</PRE>
<DL>
<DD><code>TextLayout</code> 의 leading를 돌려줍니다. leading는, 이 <code>TextLayout</code> 용으로서 추천 되고 있는 행간 스페이스입니다. 이것은 baseline를 기준으로 한 좌표로 나타내집니다.  &nbsp;<p>
leading는,<code>TextLayout</code> 의 모든 Glyph베크톨의 leading, 디 센트, 및 baseline로부터 계산됩니다. 알고리즘은, 대략 다음과 같습니다.
 <blockquote><pre>
 maxD = 0;
 maxDL = 0;
 for (GlyphVector g in all glyphvectors) {
    maxD = max(maxD, g.getDescent() + offsets[g.getBaseline()]);
    maxDL = max(maxDL, g.getDescent() + g.getLeading() +
                       offsets[g.getBaseline()]);
 }
 return maxDL - maxD;
 </pre></blockquote>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 의 선두</DL>
</DD>
</DL>
<HR>

<A NAME="getBounds()"><!-- --></A> <H3>
getBounds</H3>
<PRE>
public <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 내의 클래스">Rectangle2D</A>  <B>getBounds</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 의 경계를 돌려줍니다. 경계는 표준의 좌표로 나타내집니다.
　<p>래스터화이기 때문에, TextLayout 에 의해 draw 된 픽셀이 모두 이 경계내에 들어간다고는 할 수 없습니다. </p>
TextLayout</code> 의 아센트, 디 센트, 원점, 또는 유효폭과 완전하게는 일치하지 않는 경우가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 의 경계이다 
        <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스"><CODE>Rectangle2D</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPixelBounds(java.awt.font.FontRenderContext, float, float)"><!-- --></A> <H3>
getPixelBounds</H3>
<PRE>
public <A HREF="../../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getPixelBounds</B>(<A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc,
                                float&nbsp;x,
                                float&nbsp;y)</PRE>
<DL>
<DD>지정된 위치에서 지정된 <code>FontRenderContext</code> 를 사용해, 그래픽스내에 이 <code>TextLayout</code> 가 draw 될 때의 인덱스의 위치에 있는 Glyph의 픽셀 경계를 돌려줍니다. 그래픽스 draw 문맥은, 이 <code>TextLayout</code> 의 작성에 사용되는 <code>FontRenderContext</code> 와 같은 필요는 없고, null 에서도 괜찮습니다. null 의 경우, 이 <code>TextLayout</code> 의 <code>FontRenderContext</code> 가 사용됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>frc</CODE> - <code>Graphics</code> 의 <code>FontRenderContext</code><DD><CODE>x</CODE> - 이 <code>TextLayout</code> 을 draw 하는 x 좌표<DD><CODE>y</CODE> - 이 <code>TextLayout</code> 를 draw 하는 y 좌표
<DT><B>반환값:</B><DD>영향을 받는 픽셀의 경계를 나타내는 <code>Rectangle</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/GlyphVector.html#getPixelBounds(java.awt.font.FontRenderContext, float, float)"><CODE>GlyphVector.getPixelBounds(java.awt.font.FontRenderContext, float, float)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isLeftToRight()"><!-- --></A> <H3>
isLeftToRight</H3>
<PRE>
public boolean <B>isLeftToRight</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 의 베이스가 될 방향이 왼쪽에서 오른쪽의 경우에 <code>true</code> 를 돌려주어, 오른쪽에서 왼쪽의 경우에 <code>false</code> 를 돌려줍니다. <code>TextLayout</code> 에는, 왼쪽에서 오른쪽 (LTR) 또는 오른쪽에서 왼쪽 (RTL)의 어느 쪽인가의 베이스가 될 방향이 있습니다. 베이스가 될 방향은, 행의 텍스트의 실제의 방향 (LTR, RTL, 또는 혼합)에는 의존하지 않습니다. 왼쪽에서 오른쪽의 레이아웃은, 디폴트에서는 좌단 가지런히 하가 됩니다. 레이아웃이 탭 첨부의 행에 놓여졌을 경우, 탭은 왼쪽에서 오른쪽이 되므로, 논리적으로 연속하는 레이아웃은 왼쪽에서 오른쪽으로 배치됩니다. RTL 레이아웃의 경우는 이 반대입니다. 이 경우, 디폴트에서는 우단 가지런히 해 탭은 오른쪽에서 왼쪽이 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 의 베이스가 될 방향이 
         왼쪽에서 오른쪽의 경우는 <code>true</code>,
         그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="isVertical()"><!-- --></A> <H3>
isVertical</H3>
<PRE>
public boolean <B>isVertical</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 가 수직의 경우에 <code>true</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 가 수직의 경우는 <code>true</code>,
      그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="getCharacterCount()"><!-- --></A> <H3>
getCharacterCount</H3>
<PRE>
public int <B>getCharacterCount</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 가 나타내는 문자수를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 의 문자수</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretInfo(java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
getCaretInfo</H3>
<PRE>
public float[] <B>getCaretInfo</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit,
                            <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</PRE>
<DL>
<DD><code>hit</code> 에 대응하는 caret에 대한 정보를 돌려줍니다. 배열의 최초의 요소는, caret와 baseline의 교점입니다. baseline에 따른 거리로 나타내집니다. 배열의 2 번째의 요소는, caret의 역기울기 (런/라이즈)입니다. 그 점에서의 baseline를 기준으로 해 측정됩니다.  &nbsp;<p>
이 메소드는, 정보 (을) 위해서만 사용됩니다. caret를 표시하려면 ,<code>getCaretShapes</code> 를 사용해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - 이 <code>TextLayout</code> 의 문자의 히트<DD><CODE>bounds</CODE> - caret 정보가 구축되는 경계.
     경계는 baseline를 기준으로 한 좌표로 나타내진다
<DT><B>반환값:</B><DD>caret의 위치와 기울기가 포함되고 있는 2 요소
 배열. 반환되는 caret 정보는, baseline를 기준으로 한 좌표로 나타내지는<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getCaretShapes(int, java.awt.geom.Rectangle2D, java.awt.font.TextLayout.CaretPolicy)"><CODE>getCaretShapes(int, Rectangle2D, TextLayout.CaretPolicy)</CODE></A> , 
<A HREF="../../../java/awt/Font.html#getItalicAngle()"><CODE>Font.getItalicAngle()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getCaretInfo(java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getCaretInfo</H3>
<PRE>
public float[] <B>getCaretInfo</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</PRE>
<DL>
<DD><code>hit</code> 에 대응하는 caret에 대한 정보를 돌려줍니다. 이 메소드는,<code>getCaretInfo</code> 의 간이 overload이며, 이 <code>TextLayout</code> 의 자연 경계를 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - 이 <code>TextLayout</code> 의 문자의 히트
<DT><B>반환값:</B><DD>히트에 대응하는 caret에 대한 정보 반환된다
     caret 정보는, baseline를 기준으로 한 좌표로 나타내진다</DL>
</DD>
</DL>
<HR>

<A NAME="getNextRightHit(java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getNextRightHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getNextRightHit</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</PRE>
<DL>
<DD>오른쪽 (하) 방향의 다음의 caret의 히트를 돌려줍니다.  이 방향으로 히트가 없는 경우는 <code>null</code> 를 돌려줍니다. 히트 문자의 인덱스가 경계내에 없는 경우는,<A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스"><CODE>IllegalArgumentException</CODE></A>  가 throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - 이 레이아웃의 문자의 히트
<DT><B>반환값:</B><DD>지정된 히트의 caret에 대해서 오른쪽 (하) 방향에 위치하는 다음의 caret의 히트,
 또는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getNextRightHit(int, java.awt.font.TextLayout.CaretPolicy)"><!-- --></A> <H3>
getNextRightHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getNextRightHit</B>(int&nbsp;offset,
                                   <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> &nbsp;policy)</PRE>
<DL>
<DD>오른쪽 (하) 방향의 다음의 caret의 히트를 돌려줍니다.  이 방향으로 히트가 없는 경우는 <code>null</code> 가 돌려주어집니다. 히트는, 지정된 정책에 의한, 지정된 오프셋(offset) 위치의 강한 caret의 우측에 있습니다. 반환되는 히트는, 지정된 정책에 의한, 2 개의 히트의 강한 (분)편입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code> 의 삽입 오프셋(offset).
 0 보다 작은 값이나 <code>TextLayout</code> 객체의 
 문자 카운트보다 큰 값은 불가<DD><CODE>policy</CODE> - 강한 caret를 선택하기 위해서 사용되는 정책
<DT><B>반환값:</B><DD>지정된 히트의 caret에 대해서 오른쪽 (하) 방향에 위치하는 다음의 caret의 히트,
 또는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getNextRightHit(int)"><!-- --></A> <H3>
getNextRightHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getNextRightHit</B>(int&nbsp;offset)</PRE>
<DL>
<DD>오른쪽 (하) 방향의 다음의 caret의 히트를 돌려줍니다.  이 방향으로 히트가 없는 경우는 <code>null</code> 가 돌려주어집니다. 히트는, 디폴트의 정책에 의한, 지정된 오프셋(offset) 위치의 강한 caret의 오른쪽에 있습니다. 반환되는 히트는, 디폴트의 정책에 의한, 2 개의 히트의 강한 (분)편입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code> 의 삽입 오프셋(offset).
 0 보다 작은 값이나 <code>TextLayout</code> 객체의
 문자 카운트보다 큰 값은 불가
<DT><B>반환값:</B><DD>지정된 히트의 caret에 대해서 오른쪽 (하) 방향에 위치하는 다음의 caret의 히트,
 또는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getNextLeftHit(java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getNextLeftHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getNextLeftHit</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</PRE>
<DL>
<DD>왼쪽 (상) 방향의 다음의 caret의 히트를 돌려줍니다.  이 방향으로 히트가 없는 경우는 <code>null</code> 가 돌려주어집니다. 히트 문자의 인덱스가 경계내에 없는 경우는,<code>IllegalArgumentException</code> 가 throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - 이 <code>TextLayout</code> 의 문자의 히트
<DT><B>반환값:</B><DD>지정된 히트의 caret에 대해서 왼쪽 (상) 방향에 위치하는 다음의 caret의 히트,
 또는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getNextLeftHit(int, java.awt.font.TextLayout.CaretPolicy)"><!-- --></A> <H3>
getNextLeftHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getNextLeftHit</B>(int&nbsp;offset,
                                  <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> &nbsp;policy)</PRE>
<DL>
<DD>왼쪽 (상) 방향의 다음의 caret의 히트를 돌려줍니다.  이 방향으로 히트가 없는 경우는 <code>null</code> 가 돌려주어집니다. 히트는, 지정된 정책에 의한, 지정된 오프셋(offset) 위치의 강한 caret의 왼쪽에 있습니다. 반환되는 히트는, 지정된 정책에 의한, 2 개의 히트의 강한 (분)편입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code> 의 삽입 오프셋(offset).
 0 보다 작은 값이나 <code>TextLayout</code> 객체의
 문자 카운트보다 큰 값은 불가<DD><CODE>policy</CODE> - 강한 caret를 선택하기 위해서 사용되는 정책
<DT><B>반환값:</B><DD>지정된 히트의 caret에 대해서 왼쪽 (상) 방향에 위치하는 다음의 caret의 히트,
 또는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getNextLeftHit(int)"><!-- --></A> <H3>
getNextLeftHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getNextLeftHit</B>(int&nbsp;offset)</PRE>
<DL>
<DD>왼쪽 (상) 방향의 다음의 caret의 히트를 돌려줍니다.  이 방향으로 히트가 없는 경우는 <code>null</code> 가 돌려주어집니다. 히트는, 디폴트의 정책에 의한, 지정된 오프셋(offset) 위치의 강한 caret의 왼쪽입니다. 반환되는 히트는, 디폴트의 정책에 의한, 2 개의 히트의 강한 (분)편입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code> 의 삽입 오프셋(offset).   
 0 보다 작은 값이나 <code>TextLayout</code> 객체의
 문자 카운트보다 큰 값은 불가
<DT><B>반환값:</B><DD>지정된 히트의 caret에 대해서 왼쪽 (상) 방향에 위치하는 다음의 caret의 히트,
 또는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getVisualOtherHit(java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getVisualOtherHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getVisualOtherHit</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</PRE>
<DL>
<DD>지정된 히트의 caret의 반대측의 히트를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - 지정된 히트
<DT><B>반환값:</B><DD>지정된 히트의 caret의 반대 측에 있다
    히트</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShape(java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
getCaretShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getCaretShape</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit,
                           <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</PRE>
<DL>
<DD>지정된 경계내의 지정된 히트에 있는 caret를 나타내는 <A HREF="../../../java/awt/Shape.html" title="java.awt 동안의 인터페이스"><CODE>Shape</CODE></A>  를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - caret를 생성하는 히트<DD><CODE>bounds</CODE> - caret의 생성으로 사용한다  
    <code>TextLayout</code> 의 경계. 경계는 baseline를 기준으로 한 좌표로
    나타내진다
<DT><B>반환값:</B><DD>caret를 나타내는 <code>Shape</code>반환된다
    형상은 표준의 좌표로 나타내진다</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShape(java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getCaretShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getCaretShape</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</PRE>
<DL>
<DD>이 <code>TextLayout</code> 의 자연 경계내의 지정된 히트에 있는 caret를 나타내는 <code>Shape</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - caret를 생성하는 히트
<DT><B>반환값:</B><DD>caret를 나타내는 <code>Shape</code>반환된다
     형상은 표준의 좌표로 나타내진다</DL>
</DD>
</DL>
<HR>

<A NAME="getCharacterLevel(int)"><!-- --></A> <H3>
getCharacterLevel</H3>
<PRE>
public byte <B>getCharacterLevel</B>(int&nbsp;index)</PRE>
<DL>
<DD><code>index</code> 에 있는 문자의 레벨을 돌려줍니다. 인덱스 -1 및 <code>characterCount</code> 에는, 이 <code>TextLayout</code> 의 기저 레벨을 할당할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index</CODE> - 레벨을 취득하는 문자의 인덱스
<DT><B>반환값:</B><DD>지정된 인덱스에 있는 문자의 레벨</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShapes(int, java.awt.geom.Rectangle2D, java.awt.font.TextLayout.CaretPolicy)"><!-- --></A> <H3>
getCaretShapes</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> [] <B>getCaretShapes</B>(int&nbsp;offset,
                              <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds,
                              <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> &nbsp;policy)</PRE>
<DL>
<DD>강한 caret와 약한 caret에 대응하는 2 개의 윤곽선을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code> 의 오프셋(offset)<DD><CODE>bounds</CODE> - caret를 확장하는 경계. 이
 경계는 baseline를 기준으로 한 좌표로 나타내지는<DD><CODE>policy</CODE> - 지정한 <code>CaretPolicy</code>
<DT><B>반환값:</B><DD>2 살의 패스의 배열. 요소 0 은 강한 caret.
 2 개의 caret가 있는 경우, 요소 1 은 약한 caret.
 그렇지 않은 경우, 요소 1 은 <code>null</code>. 반환되는 형상은
 표준의 좌표로 나타내진다</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShapes(int, java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
getCaretShapes</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> [] <B>getCaretShapes</B>(int&nbsp;offset,
                              <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</PRE>
<DL>
<DD>강한 caret와 약한 caret에 대응하는 2 개의 윤곽선을 돌려줍니다. 이 메소드는,<code>getCaretShapes</code> 의 간이 overload이며, 디폴트의 caret 정책를 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code> 의 오프셋(offset)<DD><CODE>bounds</CODE> - caret를 확장하는 경계. 이것은
     baseline를 기준으로 한 좌표로 나타내진다
<DT><B>반환값:</B><DD><code>DEFAULT_CARET_POLICY</code> 에서의 정의에 의한,
    강한 caret와 약한 caret에 대응하는 2 살의 패스. 이것들은
    표준의 좌표로 나타내진다</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShapes(int)"><!-- --></A> <H3>
getCaretShapes</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> [] <B>getCaretShapes</B>(int&nbsp;offset)</PRE>
<DL>
<DD>강한 caret와 약한 caret에 대응하는 2 개의 윤곽선을 돌려줍니다. 이 메소드는,<code>getCaretShapes</code> 의 간이 overload이며, 디폴트의 caret 정책 및 이 <code>TextLayout</code> 객체의 자연 경계를 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code> 의 오프셋(offset)
<DT><B>반환값:</B><DD><code>DEFAULT_CARET_POLICY</code> 에서의 정의에 의한,
    강한 caret와 약한 caret에 대응하는 2 살의 패스. 이것들은
    표준의 좌표로 나타내진다</DL>
</DD>
</DL>
<HR>

<A NAME="getLogicalRangesForVisualSelection(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getLogicalRangesForVisualSelection</H3>
<PRE>
public int[] <B>getLogicalRangesForVisualSelection</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;firstEndpoint,
                                                <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;secondEndpoint)</PRE>
<DL>
<DD>시각적인 선택 범위에 대응하는 텍스트의 논리적인 범위를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>firstEndpoint</CODE> - 시각적인 범위의 한편의 단 점<DD><CODE>secondEndpoint</CODE> - 시각적인 범위의 이제(벌써) 한편의 단 점.
 <code>firstEndpoint</code> 보다 작아도 가능
<DT><B>반환값:</B><DD>선택된 범위의 개시/리밋트의 페어를 나타낸다
 정수의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><CODE>getVisualHighlightShape(TextHitInfo, TextHitInfo, Rectangle2D)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
getVisualHighlightShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getVisualHighlightShape</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;firstEndpoint,
                                     <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;secondEndpoint,
                                     <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</PRE>
<DL>
<DD>지정된 범위의 시각적인 선택 범위를 둘러싸는 윤곽선을,<code>bounds</code> 까지 확장해 돌려줍니다.  &nbsp;<p>
선택 범위에, 좌단 (상단)의 위치가 포함되는 경우, 그 선택 범위는 <code>bounds</code> 의 왼쪽 (위)까지 확장됩니다. 그 선택 범위에 우단 (하단)의 위치가 포함되는 경우, 선택 범위는 경계의 오른쪽 (아래)까지 확장됩니다. 선택 범위의 높이 (수직선상의 폭)는, 항상 <code>bounds</code> 까지 확장됩니다.  &nbsp;<p>
선택 범위는 항상 연속하고 있습니다만, 혼합 방향 텍스트의 행의 경우, 논리적으로 선택된 텍스트는 불연속이 되는 일이 있습니다. 선택된 텍스트의 논리적인 범위는,<code>getLogicalRangesForVisualSelection</code> 를 사용해 취득할 수 있습니다. 예를 들어, 「ABCdef」라고 하는 텍스트를 예에 생각해 보겠습니다.  대문자는 오른쪽에서 왼쪽의 텍스트를 나타내, 오른쪽에서 왼쪽의 행으로 draw 되어 시각적인 선택 범위는 0L ( 「A」의 리딩 엣지)에서 3T ( 「d」의 트레이 링 엣지)입니다.  이 텍스트는 다음과 같이 표시됩니다. 밑줄 첨부 볼드의 영역은 선택 범위를 나타내고 있습니다. <br>
 <br><pre>
    d<u><b>efCBA  </b></u>
 </pre>
논리적인 선택 범위는, 0 ~ 3, 4 ~ 6 (ABC, ef)입니다.  왜냐하면, 시각적으로 연속한 텍스트는 논리적이게는 불연속이기 때문입니다. 또, 레이아웃의 우단의 위치 ( 「A」의 우측)가 선택되고 있으므로, 선택 범위는 경계의 오른쪽까지 확장됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>firstEndpoint</CODE> - 시각적인 선택 범위의 한편의 단 점<DD><CODE>secondEndpoint</CODE> - 시각적인 선택 범위의 이제(벌써) 한편의 단 점<DD><CODE>bounds</CODE> - 선택 범위가 확장되는 경계의 구형.
     이것은 baseline를 기준으로 한 좌표로 나타내진다
<DT><B>반환값:</B><DD>선택 범위를 둘러싸는 <code>Shape</code>이것은
     표준의 좌표로 나타내지는<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getLogicalRangesForVisualSelection(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)"><CODE>getLogicalRangesForVisualSelection(TextHitInfo, TextHitInfo)</CODE></A> , 
<A HREF="../../../java/awt/font/TextLayout.html#getLogicalHighlightShape(int, int, java.awt.geom.Rectangle2D)"><CODE>getLogicalHighlightShape(int, int, Rectangle2D)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getVisualHighlightShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getVisualHighlightShape</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;firstEndpoint,
                                     <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;secondEndpoint)</PRE>
<DL>
<DD>지정된 범위의 시각적인 선택 범위를 둘러싸는 <code>Shape</code> 를, 경계까지 확장해 돌려줍니다. 이 메소드는,<code>getVisualHighlightShape</code> 의 간이 overload이며, 이 <code>TextLayout</code> 의 자연 경계를 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>firstEndpoint</CODE> - 시각적인 선택 범위의 한편의 단 점<DD><CODE>secondEndpoint</CODE> - 시각적인 선택 범위의 이제(벌써) 한편의 단 점
<DT><B>반환값:</B><DD>선택 범위를 둘러싸는 <code>Shape</code>이것은
     표준의 좌표로 나타내진다</DL>
</DD>
</DL>
<HR>

<A NAME="getLogicalHighlightShape(int, int, java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
getLogicalHighlightShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getLogicalHighlightShape</B>(int&nbsp;firstEndpoint,
                                      int&nbsp;secondEndpoint,
                                      <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</PRE>
<DL>
<DD>지정된 범위의 논리적인 선택 범위를 둘러싸는 <code>Shape</code> 를, 지정된 <code>bounds</code> 까지 확장해 돌려줍니다.  &nbsp;<p>
선택 범위에 최초의 논리 문자가 포함되어 있는 경우, 그 선택 범위는 이 <code>TextLayout</code> 의 선두의 앞의 <code>bounds</code> 의 부분까지 확장됩니다. 선택 범위에 마지막 논리 문자가 포함되어 있는 경우, 그 선택 범위는 이 <code>TextLayout</code> 의 마지막 나머지의 <code>bounds</code> 의 부분까지 확장됩니다. 선택 범위의 높이 (수직선상의 폭)는, 항상 <code>bounds</code> 까지 확장됩니다.  &nbsp;<p>
혼합 방향 텍스트의 행의 경우, 선택 범위가 불연속이 되는 일이 있습니다. 선두와 리밋트의 사이의 논리적인 범위에 위치하는 문자만이 선택되어 있는 것처럼 보입니다. 예를 들어, 「ABCdef」라고 하는 텍스트를 예에 생각해 보겠습니다.  대문자는 오른쪽에서 왼쪽의 텍스트를 나타내, 오른쪽에서 왼쪽의 행으로 draw 되어 논리적인 선택 범위는 0 ~ 4 (ABCd)입니다. 텍스트는 다음과 같이 표시됩니다.  선택 범위는 볼드로 표시되어 확장 부분은 밑줄로 표시됩니다. <br>
 <br><pre>
    <u><b>d</b></u>ef<u><b>CBA  </b></u>
 </pre>
선택 범위는 불연속입니다.  그 이유는, 선택된 문자가 시각적으로 불연속이기 때문입니다. 또, 선택 범위에 최초의 논리 문자 (A)가 포함되기 (위해)때문에, 선택 범위는 레이아웃의 선두보다 전의 <code>bounds</code> 의 부분까지 확장됩니다.  이 경우 ( 오른쪽에서 왼쪽의 행)는,<code>bounds</code> 의 오른쪽의 부분입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>firstEndpoint</CODE> - 선택하는 문자의 범위의 단 점<DD><CODE>secondEndpoint</CODE> - 선택하는 문자의 범위의 이제(벌써) 한편의 단 점.
 <code>firstEndpoint</code> 보다 작아도 가능. 이 범위에는,
 min(firstEndpoint, secondEndpoint)의 문자는 포함되지만,
 max(firstEndpoint, secondEndpoint)의 문자는 제외되는<DD><CODE>bounds</CODE> - 선택 범위가 확장되는 경계의 구형.
     이것은 baseline를 기준으로 한 좌표로 나타내진다
<DT><B>반환값:</B><DD>선택 범위를 둘러싸는 영역 이것은
     표준의 좌표로 나타내지는<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><CODE>getVisualHighlightShape(TextHitInfo, TextHitInfo, Rectangle2D)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getLogicalHighlightShape(int, int)"><!-- --></A> <H3>
getLogicalHighlightShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getLogicalHighlightShape</B>(int&nbsp;firstEndpoint,
                                      int&nbsp;secondEndpoint)</PRE>
<DL>
<DD>지정된 범위의 논리적인 선택 범위를 둘러싸는 <code>Shape</code> 를, 이 <code>TextLayout</code> 의 자연 경계까지 확장해 돌려줍니다. 이 메소드는,<code>getLogicalHighlightShape</code> 의 간이 overload이며, 이 <code>TextLayout</code> 의 자연 경계를 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>firstEndpoint</CODE> - 선택하는 문자의 범위의 단 점<DD><CODE>secondEndpoint</CODE> - 선택하는 문자의 범위의 이제(벌써) 한편의 단 점.
 <code>firstEndpoint</code> 보다 작아도 가능..   이 범위에는,
 min(firstEndpoint, secondEndpoint)의 문자는 포함되지만,
 max(firstEndpoint, secondEndpoint)의 문자는 제외된다
<DT><B>반환값:</B><DD>선택 범위를 둘러싸는 <code>Shape</code>이것은
     표준의 좌표로 나타내진다</DL>
</DD>
</DL>
<HR>

<A NAME="getBlackBoxBounds(int, int)"><!-- --></A> <H3>
getBlackBoxBounds</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getBlackBoxBounds</B>(int&nbsp;firstEndpoint,
                               int&nbsp;secondEndpoint)</PRE>
<DL>
<DD>지정된 범위에 있는 모든 문자의 블랙 박스 경계를 돌려줍니다. 블랙 박스 경계란, 개시와 리밋트의 사이의 모든 문자에 대응하는 모든 Glyph의 바운딩 박스의 결합으로 구성되는 영역입니다. 이 영역은 불연속이 되는 경우가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>firstEndpoint</CODE> - 문자의 범위의 한편의 단 점<DD><CODE>secondEndpoint</CODE> - 문자의 범위의 이제(벌써) 한편의 단 점. 이것은 
 <code>firstEndpoint</code> 보다 작아도 가능
<DT><B>반환값:</B><DD>블랙 박스 경계를 둘러싸는 <code>Shape</code>. 이것은
     표준의 좌표로 나타내진다</DL>
</DD>
</DL>
<HR>

<A NAME="hitTestChar(float, float, java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
hitTestChar</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>hitTestChar</B>(float&nbsp;x,
                               float&nbsp;y,
                               <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</PRE>
<DL>
<DD>지정된 점에 대응하는 <code>TextHitInfo</code> 를 돌려줍니다. TextLayout</code> 의 경계의 외측의 좌표는, 행의 문자의 위치에 관계없이, 최초의 논리 문자의 리딩 엣지, 또는 마지막 논리 문자의 트레이 링 엣지의 어느 쪽인지 적절한 (분)편의 히트에 대응합니다. baseline에 따른 방향만이, 이 평가에 사용됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 이 <code>TextLayout</code> 의
     원점으로부터의 x 오프셋(offset). 이것은 표준의 좌표로 나타내지는<DD><CODE>y</CODE> - 이 <code>TextLayout</code> 의
     원점으로부터의 y 오프셋(offset). 이것은 표준의 좌표로 나타내지는<DD><CODE>bounds</CODE> - <code>TextLayout</code> 의 경계. 이것은
     baseline를 기준으로 한 좌표로 나타내진다
<DT><B>반환값:</B><DD>지정된 점아래의 문자 및 엣지 (리딩 엣지 또는 트레이 링 엣지)를
     기술하는 히트</DL>
</DD>
</DL>
<HR>

<A NAME="hitTestChar(float, float)"><!-- --></A> <H3>
hitTestChar</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>hitTestChar</B>(float&nbsp;x,
                               float&nbsp;y)</PRE>
<DL>
<DD>지정된 점에 대응하는 <code>TextHitInfo</code> 를 돌려줍니다. 이 메소드는,<code>hitTestChar</code> 의 간이 overload이며, 이 <code>TextLayout</code> 의 자연스러운 경계를 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 이 <code>TextLayout</code> 의
     원점으로부터의 x 오프셋(offset). 이것은 표준의 좌표로 나타내지는<DD><CODE>y</CODE> - 이 <code>TextLayout</code> 의
     원점으로부터의 y 오프셋(offset). 이것은 표준의 좌표로 나타내진다
<DT><B>반환값:</B><DD>지정된 점아래의 문자 및 엣지 (리딩 엣지 또는 트레이 링 엣지)를
 기술하는 히트</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 의 해시 코드를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 의 해시 코드<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Object.html#equals(java.lang.Object)"><CODE>Object.equals(java.lang.Object)</CODE></A> , 
<A HREF="../../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>지정된 <code>Object</code> 가 <code>TextLayout</code> 객체로, 지정된 <code>Object</code> 가 이 <code>TextLayout</code> 와 동일한 경우에 <code>true</code> 를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 동일한지 어떤지가 판정되는 <code>Object</code>
<DT><B>반환값:</B><DD>지정된 <code>Object</code> 가
      이 <code>TextLayout</code> 와 동일한 경우는 <code>true</code>,
      그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A> , 
<A HREF="../../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.awt.font.TextLayout)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 안의 클래스">TextLayout</A> &nbsp;rhs)</PRE>
<DL>
<DD>2 개의 레이아웃이 동일한 경우에 <code>true</code> 를 돌려줍니다. 2 개의 레이아웃은, 그것들이 같은 순서로 같은 Glyph베크톨을 포함하고 있는 경우에 동일해집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rhs</CODE> - 이 <code>TextLayout</code> 와 비교한다  
       <code><code>TextLayout</code></code>
<DT><B>반환값:</B><DD>지정된 <code>TextLayout</code> 가
      이 <code>TextLayout</code> 와 동일한 경우는 <code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 의 디버그 정보를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 의 <code>textLine</code> 를 나타낸다 
        <code>String</code></DL>
</DD>
</DL>
<HR>

<A NAME="draw(java.awt.Graphics2D, float, float)"><!-- --></A> <H3>
draw</H3>
<PRE>
public void <B>draw</B>(<A HREF="../../../java/awt/Graphics2D.html" title="java.awt 안의 클래스">Graphics2D</A> &nbsp;g2,
                 float&nbsp;x,
                 float&nbsp;y)</PRE>
<DL>
<DD>지정된 <A HREF="../../../java/awt/Graphics2D.html" title="java.awt 동안의 클래스"><CODE>Graphics2D</CODE></A>  문맥의 지정된 위치에 이 <code>TextLayout</code> 를 draw 합니다. 레이아웃의 원점은 x, &nbsp;y 입니다.  draw는, 이 정도치의 <code>getBounds()</code> 내의 임의의 점에 접합니다. <code>g2</code> 는 변경되지 않습니다. 텍스트는 baseline의 패스에 따라 draw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g2</CODE> - 레이아웃의 draw처의 <code>Graphics2D</code> 
         문맥<DD><CODE>x</CODE> - 이 <code>TextLayout</code> 의 원점의 X 좌표<DD><CODE>y</CODE> - 이 <code>TextLayout</code> 의 원점의 Y 좌표<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getBounds()"><CODE>getBounds()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getOutline(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
getOutline</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getOutline</B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;tx)</PRE>
<DL>
<DD>이 <code>TextLayout</code> 의 윤곽을 나타내는 <code>Shape</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tx</CODE> - 이 <code>TextLayout</code> 의 윤곽에 적용한다
     임의 지정 <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 중의 클래스"><CODE>AffineTransform</CODE></A> 
<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 의 윤곽이다 
     <code>Shape</code>. 이것은 표준의 좌표로 나타내진다</DL>
</DD>
</DL>
<HR>

<A NAME="getLayoutPath()"><!-- --></A> <H3>
getLayoutPath</H3>
<PRE>
public <A HREF="../../../java/awt/font/LayoutPath.html" title="java.awt.font 내의 클래스">LayoutPath</A>  <B>getLayoutPath</B>()</PRE>
<DL>
<DD>LayoutPath 를 돌려줍니다. 레이아웃 패스가 디폴트의 패스인 경우는 (x 가 유효폭, y 가 오프셋(offset)에 맵 된다), null 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>레이아웃 패스<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hitToPoint(java.awt.font.TextHitInfo, java.awt.geom.Point2D)"><!-- --></A> <H3>
hitToPoint</H3>
<PRE>
public void <B>hitToPoint</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit,
                       <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;point)</PRE>
<DL>
<DD>히트를 표준 좌표의 포인트로 변환합니다. 이 포인트는, 문자의 baseline상에 있어, 경우에 응해 문자의 리딩 엣지 또는 트레이 링 엣지에 해당됩니다. 이 히트로 나타내지는 문자의 옆에서 패스가 분할되고 있는 경우, 포인트는 문자에 인접합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - 체크 대상의 히트. 이것은 TextLayout 상의
 유효한 히트가 아니면 안되는<DD><CODE>point</CODE> - 반환되는 포인트. 포인트는
     표준의 좌표로 나타내진다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 히트가 TextLayout 에 대해서 유효하지 않다
 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - hit 또는 point 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/TextLayout.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/awt/font/TextLayout.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="TextLayout.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
