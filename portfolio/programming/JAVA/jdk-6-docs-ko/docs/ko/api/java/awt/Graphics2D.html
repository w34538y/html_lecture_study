<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:52:54 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Graphics2D (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Graphics2D (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics2D.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/awt/GraphicsConfigTemplate.html" title="java.awt 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/awt/Graphics2D.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Graphics2D.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt</FONT>
<BR>
클래스 Graphics2D</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">java.awt.Graphics</A> 
      <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.awt.Graphics2D</B>
</PRE>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>Graphics2D</B><DT>extends <A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </DL>
</PRE>

<P>
<code>Graphics2D</code> 클래스는, <A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스"><CODE>Graphics</CODE></A>  클래스를 확장해, 기하학적 도형, 좌표변화, 칼라 관리, 및 텍스트 배치에 대해 고도의 제어를 실시합니다. 이 클래스는, Java(TM) 플랫폼에서 2D 의 도형, 텍스트, 및 이미지를 draw하기 위한 기본 클래스입니다.  &nbsp;<p>
<h2>좌표 공간</h2>
<code>Graphics2D</code> 객체에게 건네지는 모든 좌표는, 사용자 공간 (어플리케이션에 의해 사용된다)으로 불리는, 디바이스에 의존하지 않는 좌표계로 지정됩니다. <code>Graphics2D</code> 객체에는, 디바이스 공간에서 사용자 공간의 좌표를 디바이스에 의존하는 좌표로 변환하는 방법을 정의하는 <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 동안의 클래스"><CODE>AffineTransform</CODE></A>  객체가, draw 상태의 일부로서 포함됩니다.  &nbsp;<p>
디바이스 공간의 좌표는, 일반적으로, 개별의 디바이스 픽셀을 나타내, 이러한 픽셀간에 무한하게 가는 간격에 늘어놓을 수 있고 있습니다. 일부의 <code>Graphics2D</code> 객체에서는, draw 조작을 수중에 넣을 수가 있습니다.  그래픽스 메타파일로서 수중에 넣는 것으로, 후에 물리적인 해상도가 불명한 구상 디바이스를 사용해 재생할 수가 있습니다. draw 조작을 수중에 넣으려면  해상도가 불명해서,<code>Graphics2D</code> <code>Transform</code> 를 설정해 사용자 좌표를 가상 디바이스 공간으로 변환하도록(듯이) 합니다. 타겟 디바이스가 예상되는 해상도가 개산 됩니다만, 그 견적이 올바르지 않은 경우에는, 재생시에 한층 더 변환을 적용할 필요가 있습니다.  &nbsp;<p>
draw 속성 객체에 의해 실행되는 일부의 조작에는 디바이스 공간에서 처리되는 것도 있습니다만,<code>Graphics2D</code> 의 메소드는 모두 사용자 공간 좌표를 취급합니다.  &nbsp;<p>
모든 <code>Graphics2D</code> 객체는, draw가 행해지는 위치를 정의하는 타겟과 관련지을 수 있고 있습니다. <A HREF="../../java/awt/GraphicsConfiguration.html" title="java.awt 안의 클래스"><CODE>GraphicsConfiguration</CODE></A>  객체는, 픽셀 형식 및 해상도라고 하는 draw 타겟의 특성을 정의합니다. <code>Graphics2D</code> 객체에서는, 항상 같은 draw 타겟이 사용됩니다.  &nbsp;<p>
<code>Graphics2D</code> 객체가 작성될 때,<code>GraphicsConfiguration</code> 는,<code>Graphics2D</code> (<A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스"><CODE>Component</CODE></A>  또는 <A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스"><CODE>Image</CODE></A> )의 타겟으로서<a name="#deftransform">디폴트 변환</a>을 지정합니다. 이 디폴트 변환에서는, 사용자 공간 좌표계를 화면과 프린터의 디바이스 좌표에 매핑 해, 원점을 디바이스의 타겟 영역의 좌상구석에, 우측으로 확장하려면 X 좌표를, 하부에 확장하려면 Y 좌표를 늘리는 것 같은 매핑을 실시합니다. 스크린 디바이스등의 72 dpi 에 가까운 디바이스의 경우, 디폴트 변환의 슬캘링은 그러한 디바이스의 식별 정보로 설정됩니다. 프린터등의 고해상도 디바이스의 경우, 디폴트 변환의 슬캘링은, 1 평방 인치 근처 약 72 사용자 공간 좌표로 설정됩니다. 이미지 버퍼에서는, 디폴트의 변환은 <code>Identity</code> 변환입니다.

<h2>draw 프로세스</h2>
draw 프로세스는,<code>Graphics2D</code> draw 속성에 의해 제어되는 4 개의 단계로 나눌 수가 있습니다.  렌더링에서는 이러한 스텝의 대부분을 최적화할 수 있습니다. 최적화는, 장래의 호출에 대비해 결과를 캐쉬에 포함해 두거나 복수의 가상 스텝을 실질적으로 1 개의 조작에 정리하거나 다양한 속성에 관한 단순한 공통의 문제점을, 조작외의 부분을 변경하는 것으로써 배제하거나 하는 것, 등에 의해 행해집니다.  &nbsp;<p>
draw 프로세스의 순서를 다음에 설명합니다.
 <ol>
 <li>
draw 하는 대상을 지정한다  
 <li>
draw 조작을 현재의 </code>Clip</code> 에 제한한다. <code>Clip</code> 는 사용자 공간 <A HREF="../../java/awt/Shape.html" title="java.awt 중의 인터페이스"><CODE>Shape</CODE></A>  에 의해 지정되어<code>Graphics</code> 및 <code>Graphics2D</code> 의 다양한 클립 조작 메소드를 사용해 프로그램에 의해 제어됩니다. 이 「사용자 클립」은, 현재의 <code>Transform</code> 에 의해 디바이스 공간에 변환되어 윈도우의 가시성 및 디바이스의 크기에 의해 정의되는 「디바이스 클립」이라고 결합됩니다. 사용자 클립과 디바이스 클립의 결합에 의해, 최종적인 클리핑 영역을 결정하는 「복합 클립」을 정의합니다. 렌더링 시스템은, 사용자 클립을 변경해 복합 클립의 결과를 반영할 수 없습니다.  
 <li>
draw 하는 색을 지정한다
 <li>
<code>Graphics2D</code> 문맥의 현재 <A HREF="../../java/awt/Composite.html" title="java.awt 중의 인터페이스"><CODE>Composite</CODE></A>  속성을 사용해, 목적지의 draw 표면으로 지정된 색을 바른다
 </ol>
<br> 3 종류의 draw 조작에 대해, 각각의 draw 프로세스의 상세를 다음에 나타냅니다.
 <ol>
 <li>
<b><a name="rendershape"><code>Shape</code> 의 조작</a> </b>
 <ol>
 <li>
<code>draw(Shape)</code> 조작의 경우,<code>Graphics2D</code> 문맥의 현재 <A HREF="../../java/awt/Stroke.html" title="java.awt 중의 인터페이스"><CODE>Stroke</CODE></A>   속성으로 <A HREF="../../java/awt/Stroke.html#createStrokedShape(java.awt.Shape)"><CODE>createStrokedShape</CODE></A>   메소드를 사용해, 지정의 <code>Shape</code> 의 윤곽을 포함하는 새로운 <code>Shape</code> 객체가 구축됩니다.
 <li>
<code>Shape</code> 는,<code>Graphics2D</code> 문맥의 현재의 <code>Transform</code> 를 사용해 사용자 공간으로부터 디바이스 공간에 변환됩니다.
 <li>
<code>Shape</code> 의 윤곽은,<code>Shape</code> 의 <A HREF="../../java/awt/Shape.html#getPathIterator(java.awt.geom.AffineTransform)"><CODE>getPathIterator</CODE></A>  메소드를 사용해 추출됩니다.  이 메소드는,<code>Shape</code> 의 경계를 따라 반복 처리를 실시하는 <A HREF="../../java/awt/geom/PathIterator.html" title="java.awt.geom 동안의 인터페이스"><CODE>PathIterator</CODE></A>  객체를 돌려줍니다.
 <li>
<code>PathIterator</code> 객체에 의해 반환되는 곡선 세그먼트(segment)를 <code>Graphics2D</code> 객체를 처리할 수 없는 경우는,<code>Shape</code> 의 평탄화를 실시하는 대체 메소드 <A HREF="../../java/awt/Shape.html#getPathIterator(java.awt.geom.AffineTransform, double)"><CODE>getPathIterator</CODE></A>  를 호출할 수가 있습니다.
 <li>
<code>Graphics2D</code> 문맥의 현재 <A HREF="../../java/awt/Paint.html" title="java.awt 중의 인터페이스"><CODE>Paint</CODE></A>  가, 디바이스 공간에서 draw 하는 색을 지정하는 <A HREF="../../java/awt/PaintContext.html" title="java.awt 동안의 인터페이스"><CODE>PaintContext</CODE></A>  를 취득하기 위해서 조회됩니다.
 </ol>
 <li>
<b><a name=rendertext>텍스트 조작</a> </b>
 <ol>
 <li>
지정된 <code>String</code> 를 draw 하기 위해서 필요한 Glyph세트는, 이하의 순서로 지정됩니다.
 <ol>
 <li>
인수가 <code>String</code> 의 경우, 폰트가 구현하는 기본 레이아웃 및 형상 결정 알고리즘에 관계없이 그것들을 이용해 표시하기 위해서,<code>Graphics2D</code> 문맥의 현재의 <code>Font</code> 는 <code>String</code> 의 Unicode 캐릭터 라인을 Glyph세트로 변환하도록(듯이) 요구됩니다.
 <li>
인수가 <A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스"><CODE>AttributedCharacterIterator</CODE></A>  의 경우, 반복자는, 매입 폰트 속성을 사용해, 그 자체를 <A HREF="../../java/awt/font/TextLayout.html" title="java.awt.font 안의 클래스"><CODE>TextLayout</CODE></A>  로 변환하도록(듯이) 요구됩니다. <code>TextLayout</code> 는, 기입 방향이 다른 복수의 폰트를 위해서(때문에) 자동적으로 Unicode 의 쌍방향 레이아웃 조정을 실행하는, 보다 고성능인 Glyph레이아우트아르고리즘을 구현할 수 있습니다.
 <li>
인수가 <A HREF="../../java/awt/font/GlyphVector.html" title="java.awt.font 안의 클래스"><CODE>GlyphVector</CODE></A>  의 경우,<code>GlyphVector</code> 객체는, 각 Glyph의 위치를 나타내는 명시적인 좌표를 가지는 폰트 독자적인 적절한 Glyph코드를 벌써 포함하고 있습니다.
 </ol>
 <li>
현재의 <code>Font</code> 를 조회하면(자), 지정된 Glyph의 아우트라인을 취득할 수 있습니다. 이러한 아우트라인은, 순서 1 으로 지정된 각 Glyph의 위치를 기준으로 한 사용자 공간의 형상으로서 처리됩니다.
 <li>
문자의 아우트라인이,<a href="#rendershape">「<code>Shape</code> 의 조작」</a>으로 설명한 것처럼 전부 칠해집니다.
 <li>
현재의 <code>Paint</code> 가, 디바이스 공간에서 draw 하는 색을 지정하는 <code>PaintContext</code> 를 취득하기 위해서 조회됩니다.
 </ol>
 <li>
<b><a name= renderingimage><code>Image</code> 의 조작</a> </b>
 <ol>
 <li>
대상이 되는 영역은, 소스 <code>Image</code> 의 바운딩 박스로 정의됩니다. 이 바운딩 박스는,<code>Image</code> 객체의 로컬인 좌표계인 이미지 공간에서 지정됩니다.  
 <li>
<code>AffineTransform</code> 이 <A HREF="../../java/awt/Graphics2D.html#drawImage(java.awt.Image, java.awt.geom.AffineTransform, java.awt.image.ImageObserver)"><CODE>drawImage(Image, AffineTransform, ImageObserver)</CODE></A>  에게 건네지는 경우는, 이미지 공간으로부터 사용자 공간에 바운딩 박스를 변환하기 위해서, 그 <code>AffineTransform</code> 가 사용됩니다. <code>AffineTransform</code> 가 지정되지 않는 경우, 바운딩 박스는 벌써 사용자 공간에 있는 것으로서 다루어집니다.
 <li>
소스 <code>Image</code> 의 바운딩 박스는, 현재의 <code>Transform</code> 를 사용해 사용자 공간으로부터 디바이스 공간에 변환됩니다. 다만, 바운딩 박스를 변환한 결과가, 디바이스 공간에서 구형 영역이 된다고는 할 수 없습니다.
 <li>
<code>Image</code> 객체는 draw 하는 색을 지정합니다. 색은, 현재의 <code>Transform</code> 와 옵션의 이미지 변환에 의해 지정된 소스로부터 목적지에의 매핑에 따라 샘플링 됩니다.
 </ol>
 </ol>

<h2>디폴트의 draw 속성</h2>
<code>Graphics2D</code> draw 속성의 디폴트 값를 다음에 나타냅니다.
 <dl compact>
<dt><i><code>Paint</code></i>
<dd><code>Component</code> 의 색
<dt><i><code>Font</code></i>
<dd><code>Component</code> 의 <code>Font</code>
<dt><i><code>Stroke</code></i>
<dd>선폭 1, 파선 이루어, 마이타세그먼트 결합, 및 모퉁이 엔드 캡을 가지는 모퉁이 펜
<dt><i><code>Transform</code></i>
<dd><code>Component</code> 의 <code>GraphicsConfiguration</code> 용의 <A HREF="../../java/awt/GraphicsConfiguration.html#getDefaultTransform()"><CODE>getDefaultTransform</CODE></A> 
<dt><i><code>Composite</code></i>
<dd><A HREF="../../java/awt/AlphaComposite.html#SRC_OVER"><CODE>AlphaComposite.SRC_OVER</CODE></A>  규칙
<dt><i><code>Clip</code></i>
<dd>draw <code>Clip</code> 이루어, 출력은 <code>Component</code> 에 클립 된다
 </dl>

<h2>draw 호환성</h2>
JDK<sup><font size=-2>TM</font></sup> 1.1 draw 모델은, 좌표가 픽셀간의 무한하게 가는 간격에 존재한다고 하는 픽셀화 모델에 근거합니다. draw 조작은, 윤곽 선상의 엥커 포인트의 오른쪽 및 아래의 픽셀을 전부 칠하는 1 픽셀폭의 펜을 사용해 행해집니다. JDK 1.1 draw 모델은, 지정된 번호의 픽셀에 제대로 들어가지 않으면 안 되는 이산 펜에 정수 좌표를 변환할 필요가 있는, 플랫폼 렌더링의 대부분의 기존 클래스의 기능에 준거하고 있습니다.  &nbsp;<p>
Java 2D(TM) (Java(TM) 2 플랫폼) API 는, 평활화 렌더링을 지원하고 있습니다. 1 픽셀폭의 펜은, 픽셀 N+1 와 대비한 픽셀 N 에 완전하게 들어갈 필요는 없습니다.  펜은, 부분적으로 양쪽 모두의 픽셀에 걸릴 수가 있습니다. 이동하고 있는 펜의 인연이 양쪽 모두의 픽셀에 걸리면(자), 펜의 서브 픽셀 위치가 사용자에게 표시되기 (위해)때문에, 대폭 펜의 바이어스 방향을 선택할 필요는 없습니다. 한편,<A HREF="../../java/awt/RenderingHints.html#KEY_ANTIALIASING"><CODE>KEY_ANTIALIASING</CODE></A>  힌트 키를 <A HREF="../../java/awt/RenderingHints.html#VALUE_ANTIALIAS_OFF"><CODE>VALUE_ANTIALIAS_OFF</CODE></A>  힌트치로 설정하는 것에 의해 평활화를 무효로 했을 경우는, 디바이스 공간에서 정수 좌표에 따라 draw 하고 있을 때 등, 펜이 픽셀 경계를 넘으려 하고 있을 때 어느 쪽의 픽셀을 수정할까 판단하기 위해서(때문에), 렌더링은 바이어스를 적용할 필요가 있습니다. 평활화 렌더링의 기능에 의해, draw 모델은 펜의 바이어스를 지정하는 필요성이 없어졌습니다만, 화면상에서 1 픽셀폭의 수평선 및 수직선을 draw 하는 공통의 케이스에서는, 평활화 렌더링과 비평활화 렌더링은 똑같이 동작할 필요가 있습니다. <A HREF="../../java/awt/RenderingHints.html#KEY_ANTIALIASING"><CODE>KEY_ANTIALIASING</CODE></A>  힌트 키를 <A HREF="../../java/awt/RenderingHints.html#VALUE_ANTIALIAS_ON"><CODE>VALUE_ANTIALIAS_ON</CODE></A>  로 설정해 평활화를 유효하게 했기 때문에, 이 선폭이 돌연 2 배가 되어 불투명도가 반이 되는 것을 막으려면 , 그러한 선의 윤곽선을 모델로 지정하는 것에 의해, 그 선이 특정의 픽셀세트를 완전하게 커버해 윤곽이 선명히 되도록(듯이) 합니다.  &nbsp;<p>
Java 2D API 는 JDK 1.1 의 draw 동작과의 호환성을 유지하고 있어, Java 2D API 에서는 종래부터의 조작이나 기존의 렌더링의 동작으로 변경은 없습니다. 일반적인 <code>draw</code> 메소드 및 <code>fill</code> 메소드에 매핑 되는 종래의 메소드가 정의되고 있기 (위해)때문에,<code>Stroke</code> 속성과 <code>Transform</code> 속성의 설정 및 draw 힌트에 근거해 <code>Graphics2D</code> 가 <code>Graphics</code> 를 어떻게 확장하고 있을지가 명확하게 나타나고 있습니다. 그 정의는, 디폴트의 속성 설정에서는 똑같이 실행됩니다. 예를 들어, 디폴트의 <code>Stroke</code> 는, 폭 1 및 파선 없음의 <code>BasicStroke</code> 이며, 화면 draw의 디폴트의 Transform 는 항등변환입니다.  &nbsp;<p>
다음의 2 개의 규칙은, 에일리어징 제거 또는 비에일리어징 제거의 어느 쪽이 사용되고 있어도, 예측 가능한 draw 동작을 제공합니다.
 <ul>
<li> 디바이스 픽셀간에 디바이스 좌표가 정의되어 그것에 의해 에일리어징 제거와 에일리어징 제거의 draw의 사이에 일관성이 있는 결과를 얻을 수 있습니다. 좌표가 픽셀의 중심에 있도록(듯이) 정의되었을 경우, 구형등의 형상에 의해 커버되는 일부의 픽셀은 반밖에 커버되지 않습니다. 비에일리어징 제거의 draw의 경우, 반커버된 픽셀은 형상의 안쪽이나 외측의 어느 쪽인지가 draw 됩니다. 에일리어징 제거의 draw에서는, 형상의 엣지 전체에 있는 픽셀이 반만큼 커버됩니다. 그러나, 픽셀의 사이에 좌표가 정의되고 있으면, 구형등의 형상은, 에일리어징 제거를 사용해 draw 되는 제발에 관계없이, 반만큼 커버된 픽셀을 가질 것은 없습니다.  
<li> <code>BasicStroke</code> 객체를 사용해 stroke 한 선 및 도형의 윤곽을 「정규화」하는 것으로, draw 가능한 다양한 위치에서 비에일리어징 제거 draw 또는 에일리어징 제거 draw 할 경우에, 일관성이 있는 윤곽을 draw 할 수가 있습니다. 이 정규화 프로세스는,<A HREF="../../java/awt/RenderingHints.html#KEY_STROKE_CONTROL"><CODE>KEY_STROKE_CONTROL</CODE></A>  힌트에 의해 제어됩니다. 정확한 정규화 알고리즘은 지정됩니다만, 이 정규화의 목표는, 픽셀 구라두에 선이 어떻게 들어가는 것에 관계없이, 시각적으로 일관성이 있는 선을 draw 할 수 있도록(듯이) 하는 것, 및 에일리어징 제거 모드에서의 수평선 및 수직선을 보다 치밀하게 해, 에일리어징 제거되어 있지 않은 경우의 선이 될 수 있도록 접근하는 것입니다. 일반적으로의 정규화의 스텝에서는, 부동 소수점의 선폭이 동등의 가능성으로 짝수 또는 홀수의 픽셀수에 사사오입 할 수 있도록(듯이), 에일리어징 제거 된 선의 끝을 보다 픽셀의 중심에 해 겹치는 양을 줄이든가, 혹은 에일리어징 제거되어 있지 않은 선의 서브 픽셀의 위치 결정을 조정합니다. 이 프로세스에서는, 끝을 픽셀의 반까지 이동해 (일반적으로은 양축으로 따라 정의 무한대 방향), 이러한 결과의 일관성을 높일 수가 있습니다.
 </ul>
 <p>
다음에 나타내는 일반적인 종래의 메소드의 정의는, 디폴트 속성 설정에서는 이전으로 지정된 동작과 같이 실행됩니다.
 <ul>
 <li>
<code>fillRect</code>,<code>fillRoundRect</code>,<code>fillOval</code>,<code>fillArc</code>,<code>fillPolygon</code>,<code>clearRect</code> 등의 <code>fill</code> 조작의 경우는, 목적의 <code>Shape</code> 를 지정해 <A HREF="../../java/awt/Graphics2D.html#fill(java.awt.Shape)"><CODE>fill</CODE></A>  를 호출할 수가 있습니다. 예를 들어 구형을 전부 칠하는 경우는,
 <pre>
 fill(new Rectangle(x, y, w, h));
 </pre>
(을)를 호출합니다.  &nbsp;<p>
 <li>
똑같이,<code>drawLine</code>,<code>drawRect</code>,<code>drawRoundRect</code>,<code>drawOval</code>,<code>drawArc</code>,<code>drawPolyline</code>,<code>drawPolygon</code> 등의 draw 조작의 경우는, 목적의 <code>Shape</code> 를 지정해 <A HREF="../../java/awt/Graphics2D.html#draw(java.awt.Shape)"><CODE>draw</CODE></A>  를 호출할 수가 있습니다. 예를 들어 구형을 draw 하는 경우는,
 <pre>
 draw(new Rectangle(x, y, w, h));
 </pre>
(을)를 호출합니다.  &nbsp;<p>
 <li>
<code>draw3DRect</code> 메소드와 <code>fill3DRect</code> 메소드는,<code>Graphics</code> 클래스에서는 <code>drawLine</code> 메소드와 <code>fillRect</code> 메소드를 사용해 구현되고 있습니다.  이러한 동작은,<code>Graphics2D</code> 문맥의 현재의 <code>Stroke</code> 객체와 <code>Paint</code> 객체에 근거해 예측할 수 있습니다. <code>Graphics2D</code> 클래스는, 현재의 <code>Paint</code> 를 오버라이드(override) 해, 이러한 2 개의 객체의 구현을 현재의 <code>Color</code> 를 배타적으로 사용하는 버젼으로 오버라이드(override) 합니다.  이 클래스는, 기존의 메소드와 완전하게 동일한 동작을 기술하기 위해서,<code>Stroke</code> 의 현재의 설정 (와)는 관계없는 것으로 <code>fillRect</code> 를 사용합니다.
 </ul>
<code>Graphics</code> 클래스는, 페인트 되는 색을 제어하기 위해서 <code>setColor</code> 메소드만을 정의합니다. Java 2D API 는,<code>Color</code> 객체를 확장해 새로운 <code>Paint</code> 인터페이스를 구현하므로, 기존의 <code>setColor</code> 메소드는 현재의 <code>Paint</code> 속성을 <code>Color</code> 객체로 설정하기 위한 편리한 메소드가 되어 있습니다. <code> setColor(c)</code> 는 <code>setPaint(c)</code> 에 상당합니다.  &nbsp;<p>
<code>Graphics</code> 클래스는, 색을 목적지에 적용하는 방법을 제어하기 위해서 2 개의 메소드를 정의합니다.
 <ol>
 <li>
<code>setPaintMode</code> 메소드는,<code>setComposite(new AlphaComposite.SrcOver)</code> 에 상당하는 디폴트의 <code>Composite</code> 를 설정하는 편리한 메소드로서 구현됩니다.
 <li>
<code>setXORMode(Color xorcolor)</code> 메소드는, 소스 칼라의 <code>Alpha</code> 컴퍼넌트를 무시해, 목적지 칼라를 그 값으로 설정하는 특수한 <code>Composite</code> 객체를 설정하기 위한 편리한 메소드로서 구현됩니다.
 <pre>
 dstpixel = (PixelOf(srccolor) ^ PixelOf(xorcolor) ^ dstpixel);
 </pre>
 </ol>
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/RenderingHints.html" title="java.awt 내의 클래스"><CODE>RenderingHints</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#Graphics2D()">Graphics2D</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Graphics2D</code> 객체를 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#addRenderingHints(java.util.Map)">addRenderingHints</A> </B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?,?&gt;&nbsp;hints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw 알고리즘에 관한 임의의 수의 추천 설정의 값을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)">clip</A> </B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Clip</code> 가 지정된 <code>Shape</code> 의 내부와 교차시켜, 결과적으로 생긴 공통 부분에 그 <code>Clip</code> 를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#draw(java.awt.Shape)">draw</A> </B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Graphics2D</code> 문맥의 설정을 사용하는 것으로,<code>Shape</code> 의 윤곽을 stroke로 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#draw3DRect(int, int, int, int, boolean)">draw3DRect</A> </B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height,
           boolean&nbsp;raised)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형의 윤곽을 3D 로 강조 표시해 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawGlyphVector(java.awt.font.GlyphVector, float, float)">drawGlyphVector</A> </B>(<A HREF="../../java/awt/font/GlyphVector.html" title="java.awt.font 안의 클래스">GlyphVector</A> &nbsp;g,
                float&nbsp;x,
                float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥의 draw 속성을 사용하는 것으로, 지정된 <A HREF="../../java/awt/font/GlyphVector.html" title="java.awt.font 동안의 클래스"><CODE>GlyphVector</CODE></A>  의 텍스트를 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawImage(java.awt.image.BufferedImage, java.awt.image.BufferedImageOp, int, int)">drawImage</A> </B>(<A HREF="../../java/awt/image/BufferedImage.html" title="java.awt.image 안의 클래스">BufferedImage</A> &nbsp;img,
          <A HREF="../../java/awt/image/BufferedImageOp.html" title="java.awt.image 안의 인터페이스">BufferedImageOp</A> &nbsp;op,
          int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../java/awt/image/BufferedImageOp.html" title="java.awt.image 내의 인터페이스"><CODE>BufferedImageOp</CODE></A>  로 필터 처리되는 <code>BufferedImage</code> 를 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawImage(java.awt.Image, java.awt.geom.AffineTransform, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;xform,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;obs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이미지 공간으로부터 사용자 공간에의 변환을 적용하고 나서, 이미지를 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawRenderableImage(java.awt.image.renderable.RenderableImage, java.awt.geom.AffineTransform)">drawRenderableImage</A> </B>(<A HREF="../../java/awt/image/renderable/RenderableImage.html" title="java.awt.image.renderable 안의 인터페이스">RenderableImage</A> &nbsp;img,
                    <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;xform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이미지 공간으로부터 사용자 공간에의 변환을 적용하고 나서,<A HREF="../../java/awt/image/renderable/RenderableImage.html" title="java.awt.image.renderable 안의 인터페이스"><CODE>RenderableImage</CODE></A>  를 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)">drawRenderedImage</A> </B>(<A HREF="../../java/awt/image/RenderedImage.html" title="java.awt.image 안의 인터페이스">RenderedImage</A> &nbsp;img,
                  <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;xform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이미지 공간으로부터 사용자 공간에의 변환을 적용하고 나서,<A HREF="../../java/awt/image/RenderedImage.html" title="java.awt.image 안의 인터페이스"><CODE>RenderedImage</CODE></A>  를 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawString(java.text.AttributedCharacterIterator, float, float)">drawString</A> </B>(<A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;iterator,
           float&nbsp;x,
           float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 반복자에 의해 텍스트를 그려,<A HREF="../../java/awt/font/TextAttribute.html" title="java.awt.font 안의 클래스"><CODE>TextAttribute</CODE></A>  클래스의 스펙에 근거해 속성을 적용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawString(java.text.AttributedCharacterIterator, int, int)">drawString</A> </B>(<A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;iterator,
           int&nbsp;x,
           int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 반복자에 의해 텍스트를 그려,<A HREF="../../java/awt/font/TextAttribute.html" title="java.awt.font 안의 클래스"><CODE>TextAttribute</CODE></A>  클래스의 스펙에 근거해 속성을 적용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawString(java.lang.String, float, float)">drawString</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str,
           float&nbsp;x,
           float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥의 현재의 텍스트 속성 상태를 사용하는 것으로, 특정의 <code>String</code> 에 의해 지정된 텍스트를 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawString(java.lang.String, int, int)">drawString</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str,
           int&nbsp;x,
           int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥의 현재의 텍스트 속성 상태를 사용하는 것으로, 지정된 <code>String</code> 의 텍스트를 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#fill(java.awt.Shape)">fill</A> </B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥의 설정을 사용하는 것으로,<code>Shape</code> 의 내부를 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#fill3DRect(int, int, int, int, boolean)">fill3DRect</A> </B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height,
           boolean&nbsp;raised)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 색으로 전부 칠해지고 있는, 3D 로 강조 표시된 구형을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getBackground()">getBackground</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;영역을 클리어 하는데 사용하는 백그라운드 칼라를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Composite.html" title="java.awt 내의 인터페이스">Composite</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getComposite()">getComposite</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥에서의 현재의 <code>Composite</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/GraphicsConfiguration.html" title="java.awt 내의 클래스">GraphicsConfiguration</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getDeviceConfiguration()">getDeviceConfiguration</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Graphics2D</code> 에 관련한 디바이스 구성을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/font/FontRenderContext.html" title="java.awt.font 내의 클래스">FontRenderContext</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getFontRenderContext()">getFontRenderContext</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Graphics2D</code> 문맥에서의 <code>Font</code> 의 draw 문맥을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Paint.html" title="java.awt 내의 인터페이스">Paint</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getPaint()">getPaint</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥에서의 현재의 <code>Paint</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getRenderingHint(java.awt.RenderingHints.Key)">getRenderingHint</A> </B>(<A HREF="../../java/awt/RenderingHints.Key.html" title="java.awt 안의 클래스">RenderingHints.Key</A> &nbsp;hintKey)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw 알고리즘의 추천 설정의 값을 1 개 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/RenderingHints.html" title="java.awt 내의 클래스">RenderingHints</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getRenderingHints()">getRenderingHints</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw 알고리즘의 추천 설정을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Stroke.html" title="java.awt 내의 인터페이스">Stroke</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getStroke()">getStroke</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥에서의 현재의 <code>Stroke</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getTransform()">getTransform</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥에서의 현재의 <code>Transform</code> 의 카피를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#hit(java.awt.Rectangle, java.awt.Shape, boolean)">hit</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;rect,
    <A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s,
    boolean&nbsp;onStroke)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>Shape</code> 가 지정된 <A HREF="../../java/awt/Rectangle.html" title="java.awt 동안의 클래스"><CODE>Rectangle</CODE></A>  (디바이스 공간에 있다)와 교차할지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#rotate(double)">rotate</A> </B>(double&nbsp;theta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Graphics2D</code> <code>Transform</code> 를 회전 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#rotate(double, double, double)">rotate</A> </B>(double&nbsp;theta,
       double&nbsp;x,
       double&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Graphics2D</code> <code>Transform</code> 를 이동 후의 회전 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#scale(double, double)">scale</A> </B>(double&nbsp;sx,
      double&nbsp;sy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Graphics2D</code> <code>Transform</code> 를 슬캘링 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setBackground(java.awt.Color)">setBackground</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;color)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥의 백그라운드 칼라를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)">setComposite</A> </B>(<A HREF="../../java/awt/Composite.html" title="java.awt 안의 인터페이스">Composite</A> &nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥의 <code>Composite</code> 를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)">setPaint</A> </B>(<A HREF="../../java/awt/Paint.html" title="java.awt 안의 인터페이스">Paint</A> &nbsp;paint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥에 <code>Paint</code> 속성을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setRenderingHint(java.awt.RenderingHints.Key, java.lang.Object)">setRenderingHint</A> </B>(<A HREF="../../java/awt/RenderingHints.Key.html" title="java.awt 안의 클래스">RenderingHints.Key</A> &nbsp;hintKey,
                 <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;hintValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw 알고리즘의 추천 설정의 값을 1 개 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setRenderingHints(java.util.Map)">setRenderingHints</A> </B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?,?&gt;&nbsp;hints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw 알고리즘의 모든 추천 설정의 값을, 지정된 <code>hints</code> 에 옮겨놓습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setStroke(java.awt.Stroke)">setStroke</A> </B>(<A HREF="../../java/awt/Stroke.html" title="java.awt 안의 인터페이스">Stroke</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥의 <code>Stroke</code> 를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)">setTransform</A> </B>(<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥으로 Transform 를 덧쓰기합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#shear(double, double)">shear</A> </B>(double&nbsp;shx,
      double&nbsp;shy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Graphics2D</code> <code>Transform</code> 를 셔링 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)">transform</A> </B>(<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>AffineTransform</code> 객체를 이 <code>Graphics2D</code> 에서의 <code>Transform</code> 를 사용해, 후 지정 우선 적용이라고 하는 규칙에 따라 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#translate(double, double)">translate</A> </B>(double&nbsp;tx,
          double&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Graphics2D</code> <code>Transform</code> 를 이동 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#translate(int, int)">translate</A> </B>(int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 문맥의 원점을, 현재의 좌표계의 점 (<i>x</i>, &nbsp;<i>y</i>)으로 이동합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Graphics"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Graphics.html#clearRect(int, int, int, int)">clearRect</A> , <A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)">clipRect</A> , <A HREF="../../java/awt/Graphics.html#copyArea(int, int, int, int, int, int)">copyArea</A> , <A HREF="../../java/awt/Graphics.html#create()">create</A> , <A HREF="../../java/awt/Graphics.html#create(int, int, int, int)">create</A> , <A HREF="../../java/awt/Graphics.html#dispose()">dispose</A> , <A HREF="../../java/awt/Graphics.html#drawArc(int, int, int, int, int, int)">drawArc</A> , <A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)">drawBytes</A> , <A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)">drawChars</A> , <A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A> , <A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">drawImage</A> , <A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A> , <A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, java.awt.image.ImageObserver)">drawImage</A> , <A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A> , <A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.image.ImageObserver)">drawImage</A> , <A HREF="../../java/awt/Graphics.html#drawLine(int, int, int, int)">drawLine</A> , <A HREF="../../java/awt/Graphics.html#drawOval(int, int, int, int)">drawOval</A> , <A HREF="../../java/awt/Graphics.html#drawPolygon(int[], int[], int)">drawPolygon</A> , <A HREF="../../java/awt/Graphics.html#drawPolygon(java.awt.Polygon)">drawPolygon</A> , <A HREF="../../java/awt/Graphics.html#drawPolyline(int[], int[], int)">drawPolyline</A> , <A HREF="../../java/awt/Graphics.html#drawRect(int, int, int, int)">drawRect</A> , <A HREF="../../java/awt/Graphics.html#drawRoundRect(int, int, int, int, int, int)">drawRoundRect</A> , <A HREF="../../java/awt/Graphics.html#fillArc(int, int, int, int, int, int)">fillArc</A> , <A HREF="../../java/awt/Graphics.html#fillOval(int, int, int, int)">fillOval</A> , <A HREF="../../java/awt/Graphics.html#fillPolygon(int[], int[], int)">fillPolygon</A> , <A HREF="../../java/awt/Graphics.html#fillPolygon(java.awt.Polygon)">fillPolygon</A> , <A HREF="../../java/awt/Graphics.html#fillRect(int, int, int, int)">fillRect</A> , <A HREF="../../java/awt/Graphics.html#fillRoundRect(int, int, int, int, int, int)">fillRoundRect</A> , <A HREF="../../java/awt/Graphics.html#finalize()">finalize</A> , <A HREF="../../java/awt/Graphics.html#getClip()">getClip</A> , <A HREF="../../java/awt/Graphics.html#getClipBounds()">getClipBounds</A> , <A HREF="../../java/awt/Graphics.html#getClipBounds(java.awt.Rectangle)">getClipBounds</A> , <A HREF="../../java/awt/Graphics.html#getClipRect()">getClipRect</A> , <A HREF="../../java/awt/Graphics.html#getColor()">getColor</A> , <A HREF="../../java/awt/Graphics.html#getFont()">getFont</A> , <A HREF="../../java/awt/Graphics.html#getFontMetrics()">getFontMetrics</A> , <A HREF="../../java/awt/Graphics.html#getFontMetrics(java.awt.Font)">getFontMetrics</A> , <A HREF="../../java/awt/Graphics.html#hitClip(int, int, int, int)">hitClip</A> , <A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)">setClip</A> , <A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)">setClip</A> , <A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)">setColor</A> , <A HREF="../../java/awt/Graphics.html#setFont(java.awt.Font)">setFont</A> , <A HREF="../../java/awt/Graphics.html#setPaintMode()">setPaintMode</A> , <A HREF="../../java/awt/Graphics.html#setXORMode(java.awt.Color)">setXORMode</A> , <A HREF="../../java/awt/Graphics.html#toString()">toString</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Graphics2D()"><!-- --></A> <H3>
Graphics2D</H3>
<PRE>
protected <B>Graphics2D</B>()</PRE>
<DL>
<DD>새로운 <code>Graphics2D</code> 객체를 구축합니다. <code>Graphics2D</code> 는 abstract 클래스이며, 다양한 출력 디바이스를 위해서(때문에) 서브 클래스에서 커스터마이즈 되지 않으면 안 되기 때문에,<code>Graphics2D</code> 객체를 직접 작성할 수 없습니다. 대신에, 다른 <code>Graphics2D</code> 객체로부터 취득하는지,<code>Component</code> 에 의해 작성하든가, 혹은 <A HREF="../../java/awt/image/BufferedImage.html" title="java.awt.image 안의 클래스"><CODE>BufferedImage</CODE></A>  객체등의 이미지로부터 취득하지 않으면 안됩니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#getGraphics()"><CODE>Component.getGraphics()</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#create()"><CODE>Graphics.create()</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="draw3DRect(int, int, int, int, boolean)"><!-- --></A> <H3>
draw3DRect</H3>
<PRE>
public void <B>draw3DRect</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       boolean&nbsp;raised)</PRE>
<DL>
<DD>지정된 구형의 윤곽을 3D 로 강조 표시해 draw 합니다. 구형의 구석은, 경사해, 좌상구석으로부터 빛을 쬔 것처럼 강조 표시됩니다.  &nbsp;<p>
강조 표시 효과에 사용되는 색은, 현재의 색에 근거해 지정됩니다. draw 된 구형은, 폭 <code>width&nbsp;+&nbsp;1</code> 픽셀, 높이 <code>height&nbsp;+&nbsp;1</code> 픽셀의 영역을 커버합니다. 이 메소드는 현재의 <code>Color</code> 만을 사용해, 현재의 <code>Paint</code> 는 무시합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Graphics.html#draw3DRect(int, int, int, int, boolean)">draw3DRect</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - draw 되는 구형의 x 좌표<DD><CODE>y</CODE> - draw 되는 구형의 y 좌표<DD><CODE>width</CODE> - draw 되는 구형의 폭<DD><CODE>height</CODE> - draw 되는 구형의 높이<DD><CODE>raised</CODE> - 구형이 표면으로부터 떠오른 것처럼 보이는지,
                      표면에 조각해 붐비어진 것처럼 보이는지를 지정한다  
                      boolean 치<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fill3DRect(int, int, int, int, boolean)"><CODE>Graphics.fill3DRect(int, int, int, int, boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fill3DRect(int, int, int, int, boolean)"><!-- --></A> <H3>
fill3DRect</H3>
<PRE>
public void <B>fill3DRect</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       boolean&nbsp;raised)</PRE>
<DL>
<DD>현재의 색으로 전부 칠해지고 있는, 3D 로 강조 표시된 구형을 그립니다. 구형의 구석은, 경사해, 좌상구석으로부터 빛을 쬔 것처럼 강조 표시됩니다. 강조 표시 효과 및 전부 칠해에 사용되는 색은, 현재의 <code>Color</code> 에 의해 지정됩니다. 이 메소드는 현재의 <code>Color</code> 만을 사용해, 현재의 <code>Paint</code> 는 무시합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Graphics.html#fill3DRect(int, int, int, int, boolean)">fill3DRect</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 전부 칠해지는 구형의 x 좌표<DD><CODE>y</CODE> - 전부 칠해지는 구형의 y 좌표<DD><CODE>width</CODE> - 전부 칠해지는 구형의 폭<DD><CODE>height</CODE> - 전부 칠해지는 구형의 높이<DD><CODE>raised</CODE> - 구형이 표면으로부터 떠오른 것처럼 보이는지, 
                      표면에 조각해 붐비어진 것처럼 보이는지를 지정한다  
                      boolean 치<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#draw3DRect(int, int, int, int, boolean)"><CODE>Graphics.draw3DRect(int, int, int, int, boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="draw(java.awt.Shape)"><!-- --></A> <H3>
draw</H3>
<PRE>
public abstract void <B>draw</B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s)</PRE>
<DL>
<DD>현재의 <code>Graphics2D</code> 문맥의 설정을 사용하는 것으로,<code>Shape</code> 의 윤곽을 stroke로 draw 합니다. 적용되는 draw 속성에는,<code>Clip</code>,<code>Transform</code>,<code>Paint</code>,<code>Composite</code>, 및 <code>Stroke</code> 의 각 속성이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - draw 되는 <code>Shape</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setStroke(java.awt.Stroke)"><CODE>setStroke(java.awt.Stroke)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, java.awt.geom.AffineTransform, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;xform,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;obs)</PRE>
<DL>
<DD>이미지 공간으로부터 사용자 공간에의 변환을 적용하고 나서, 이미지를 draw 합니다. 사용자 공간으로부터 디바이스 공간에의 변환은,<code>Graphics2D</code> 에서의 현재의 <code>Transform</code> 에 의해 행해집니다. 지정된 변환은,<code>Graphics2D</code> 문맥의 변환 속성에 적용되기 전에 이미지에 적용됩니다. 적용되는 draw 속성에는,<code>Clip</code>,<code>Transform</code>, 및 <code>Composite</code> 의 각 속성이 있습니다. 다만, 지정된 변환이 역변환을 가지지 않는 경우, draw는 행해지지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - draw 되는 지정 이미지.  
            <code>img</code> 가 null 의 경우에는 아무것도 실시하지 않는<DD><CODE>xform</CODE> - 이미지 공간으로부터 사용자 공간에의 변환<DD><CODE>obs</CODE> - <code>Image</code> 의 것보다 많은 부분이
 변환된다고 통지된다 
 <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A> 
<DT><B>반환값:</B><DD><code>Image</code> 가 모두 로드 되어 
 완전하게 draw 되었을 경우는 <code>true</code>,
 <code>Image</code> 가 아직 로드안의 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.image.BufferedImage, java.awt.image.BufferedImageOp, int, int)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract void <B>drawImage</B>(<A HREF="../../java/awt/image/BufferedImage.html" title="java.awt.image 안의 클래스">BufferedImage</A> &nbsp;img,
                               <A HREF="../../java/awt/image/BufferedImageOp.html" title="java.awt.image 안의 인터페이스">BufferedImageOp</A> &nbsp;op,
                               int&nbsp;x,
                               int&nbsp;y)</PRE>
<DL>
<DD><A HREF="../../java/awt/image/BufferedImageOp.html" title="java.awt.image 안의 인터페이스"><CODE>BufferedImageOp</CODE></A>  로 필터 처리되는 <code>BufferedImage</code> 를 draw 합니다. 적용되는 draw 속성에는,<code>Clip</code>,<code>Transform</code>, 및 <code>Composite</code> 의 각 속성이 있습니다. 이것은, 다음의 조작에 상당합니다.
 <pre>
 img1 = op.filter(img, null);
 drawImage(img1, new AffineTransform(1f, 0f, 0f, 1f, x, y), null);
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>op</CODE> - draw전에 이미지에 적용되는 필터<DD><CODE>img</CODE> - draw 되는 지정 <code>BufferedImage</code>.  
            <code>img</code> 가 null 의 경우에는 아무것도 실시하지 않는<DD><CODE>x</CODE> - 이미지의 좌상구석이 draw 되는 사용자 공간의
 위치의 x 좌표<DD><CODE>y</CODE> - 이미지의 좌상구석이 draw 되는 사용자 공간의
 위치의 y 좌표<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)"><!-- --></A> <H3>
drawRenderedImage</H3>
<PRE>
public abstract void <B>drawRenderedImage</B>(<A HREF="../../java/awt/image/RenderedImage.html" title="java.awt.image 안의 인터페이스">RenderedImage</A> &nbsp;img,
                                       <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;xform)</PRE>
<DL>
<DD>이미지 공간으로부터 사용자 공간에의 변환을 적용하고 나서,<A HREF="../../java/awt/image/RenderedImage.html" title="java.awt.image 안의 인터페이스"><CODE>RenderedImage</CODE></A>  를 draw 합니다. 사용자 공간으로부터 디바이스 공간에의 변환은,<code>Graphics2D</code> 에서의 현재의 <code>Transform</code> 에 의해 행해집니다. 지정된 변환은,<code>Graphics2D</code> 문맥의 변환 속성에 적용되기 전에 이미지에 적용됩니다. 적용되는 draw 속성에는,<code>Clip</code>,<code>Transform</code>, 및 <code>Composite</code> 의 각 속성이 있습니다. 다만, 지정된 변환이 역변환을 가지지 않는 경우, draw는 행해지지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - draw 되는 이미지. <code>img</code> 가 
            null 의 경우에는 아무것도 실시하지 않는<DD><CODE>xform</CODE> - 이미지 공간으로부터 사용자 공간에의 변환<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawRenderableImage(java.awt.image.renderable.RenderableImage, java.awt.geom.AffineTransform)"><!-- --></A> <H3>
drawRenderableImage</H3>
<PRE>
public abstract void <B>drawRenderableImage</B>(<A HREF="../../java/awt/image/renderable/RenderableImage.html" title="java.awt.image.renderable 안의 인터페이스">RenderableImage</A> &nbsp;img,
                                         <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;xform)</PRE>
<DL>
<DD>이미지 공간으로부터 사용자 공간에의 변환을 적용하고 나서,<A HREF="../../java/awt/image/renderable/RenderableImage.html" title="java.awt.image.renderable 안의 인터페이스"><CODE>RenderableImage</CODE></A>  를 draw 합니다. 사용자 공간으로부터 디바이스 공간에의 변환은,<code>Graphics2D</code> 에서의 현재의 <code>Transform</code> 에 의해 행해집니다. 지정된 변환은,<code>Graphics2D</code> 문맥의 변환 속성에 적용되기 전에 이미지에 적용됩니다. 적용되는 draw 속성에는,<code>Clip</code>,<code>Transform</code>, 및 <code>Composite</code> 의 각 속성이 있습니다. 다만, 지정된 변환이 역변환을 가지지 않는 경우, draw는 행해지지 않습니다.
<p> 
<code>Graphics2D</code> 객체로 설정된 draw 힌트는,<code>RenderableImage</code> 의 draw에 사용할 수 있습니다. 특정의 <code>RenderableImage</code> 에 의해 인식된 특정의 힌트에 명시적인 제어가 필요한 경우나, 어느 힌트가 사용될까를 알아 둘 필요가 있는 경우에는,<code>RenderedImage</code> 를 <code>RenderableImage</code> 로부터 직접 취득해,<A HREF="../../java/awt/Graphics2D.html#drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)"><CODE>drawRenderedImage</CODE></A>  를 사용해 draw 할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - draw 되는 이미지. <code>img</code> 가 
            null 의 경우에는 아무것도 실시하지 않는<DD><CODE>xform</CODE> - 이미지 공간으로부터 사용자 공간에의 변환<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)"><CODE>drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.lang.String, int, int)"><!-- --></A> <H3>
drawString</H3>
<PRE>
public abstract void <B>drawString</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str,
                                int&nbsp;x,
                                int&nbsp;y)</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥의 현재의 텍스트 속성 상태를 사용하는 것으로, 지정된 <code>String</code> 의 텍스트를 draw 합니다. 최초의 문자의 baseline는, 사용자 공간의 것 (<i>x</i>, &nbsp;<i>y</i>)에 위치합니다. 적용되는 draw 속성에는,<code>Clip</code>,<code>Transform</code>,<code>Paint</code>,<code>Font</code>, 및 <code>Composite</code> 의 각 속성이 있습니다. 헤브라이어나 아라비아어등의 필기 시스템의 문자에서는, Glyph는 오른쪽에서 왼쪽으로 draw 됩니다. 이 경우에는, 지정된 좌표는 baseline의 좌단의 문자 위치에 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Graphics.html#drawString(java.lang.String, int, int)">drawString</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - draw 되는 캐릭터 라인<DD><CODE>x</CODE> - <code>String</code> 가 draw 된다
 위치의 x 좌표<DD><CODE>y</CODE> - <code>String</code> 가 draw 된다
 위치의 y 좌표
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>str</code> 가  
         <code>null</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)"><CODE>Graphics.drawBytes(byte[], int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)"><CODE>Graphics.drawChars(char[], int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.lang.String, float, float)"><!-- --></A> <H3>
drawString</H3>
<PRE>
public abstract void <B>drawString</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str,
                                float&nbsp;x,
                                float&nbsp;y)</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥의 현재의 텍스트 속성 상태를 사용하는 것으로, 특정의 <code>String</code> 에 의해 지정된 텍스트를 draw 합니다. 최초의 문자의 baseline는, 사용자 공간의 것 (<i>x</i>, &nbsp;<i>y</i>)에 위치합니다. 적용되는 draw 속성에는,<code>Clip</code>,<code>Transform</code>,<code>Paint</code>,<code>Font</code>, 및 <code>Composite</code> 의 각 속성이 있습니다. 헤브라이어나 아라비아어등의 필기 시스템의 문자에서는, Glyph는 오른쪽에서 왼쪽으로 draw 됩니다. 이 경우에는, 지정된 좌표는 baseline의 좌단의 문자 위치에 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - draw 되는 <code>String</code><DD><CODE>x</CODE> - <code>String</code> 가 draw 된다
 위치의 x 좌표<DD><CODE>y</CODE> - <code>String</code> 가 draw 된다
 위치의 y 좌표
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>str</code> 가 
         </code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setFont(java.awt.Font)"><CODE>Graphics.setFont(java.awt.Font)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.text.AttributedCharacterIterator, int, int)"><!-- --></A> <H3>
drawString</H3>
<PRE>
public abstract void <B>drawString</B>(<A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;iterator,
                                int&nbsp;x,
                                int&nbsp;y)</PRE>
<DL>
<DD>지정된 반복자에 의해 텍스트를 그려,<A HREF="../../java/awt/font/TextAttribute.html" title="java.awt.font 안의 클래스"><CODE>TextAttribute</CODE></A>  클래스의 스펙에 근거해 속성을 적용합니다.  &nbsp;<p>
최초의 문자의 baseline는, 사용자 공간의 것 (<i>x</i>, &nbsp;<i>y</i>)에 위치합니다. 헤브라이어나 아라비아어등의 필기 시스템의 문자에서는, Glyph는 오른쪽에서 왼쪽으로 draw 됩니다.  이 경우에는, 지정된 좌표는 baseline의 좌단의 문자 위치에 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Graphics.html#drawString(java.text.AttributedCharacterIterator, int, int)">drawString</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>iterator</CODE> - draw 되는 텍스트를 가지는 반복자<DD><CODE>x</CODE> - 반복자의 텍스트가 draw 된다 
 x 좌표<DD><CODE>y</CODE> - 반복자의 텍스트가 draw 된다 
 y 좌표
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>iterator</code> 가
         </code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.text.AttributedCharacterIterator, float, float)"><!-- --></A> <H3>
drawString</H3>
<PRE>
public abstract void <B>drawString</B>(<A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;iterator,
                                float&nbsp;x,
                                float&nbsp;y)</PRE>
<DL>
<DD>지정된 반복자에 의해 텍스트를 그려,<A HREF="../../java/awt/font/TextAttribute.html" title="java.awt.font 안의 클래스"><CODE>TextAttribute</CODE></A>  클래스의 스펙에 근거해 속성을 적용합니다.  &nbsp;<p>
최초의 문자의 baseline는, 사용자 공간의 것 (<i>x</i>, &nbsp;<i>y</i>)에 위치합니다. 헤브라이어나 아라비아어등의 필기 시스템의 문자에서는, Glyph는 오른쪽에서 왼쪽으로 draw 됩니다.  이 경우에는, 지정된 좌표는 baseline의 좌단의 문자 위치에 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>iterator</CODE> - draw 되는 텍스트를 가지는 반복자<DD><CODE>x</CODE> - 반복자의 텍스트가 draw 된다 
 x 좌표<DD><CODE>y</CODE> - 반복자의 텍스트가 draw 된다 
 y 좌표
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>iterator</code> 가
         </code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawGlyphVector(java.awt.font.GlyphVector, float, float)"><!-- --></A> <H3>
drawGlyphVector</H3>
<PRE>
public abstract void <B>drawGlyphVector</B>(<A HREF="../../java/awt/font/GlyphVector.html" title="java.awt.font 안의 클래스">GlyphVector</A> &nbsp;g,
                                     float&nbsp;x,
                                     float&nbsp;y)</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥의 draw 속성을 사용하는 것으로, 지정된 <A HREF="../../java/awt/font/GlyphVector.html" title="java.awt.font 동안의 클래스"><CODE>GlyphVector</CODE></A>  의 텍스트를 draw 합니다. 적용되는 draw 속성에는,<code>Clip</code>,<code>Transform</code>,<code>Paint</code>, 및 <code>Composite</code> 의 각 속성이 있습니다. <code>GlyphVector</code> 는, 개개의 Glyph를 <A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스"><CODE>Font</CODE></A>  로부터 지정합니다. 또,<code>GlyphVector</code> 는, Glyph의 위치도 포함할 수 있습니다. 이 메소드를 사용하면(자), 화면에 일련의 캐릭터 라인을 가장 빠르게 draw 할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - draw 되는 <code>GlyphVector</code><DD><CODE>x</CODE> - Glyph가 draw 되는 사용자 공간의 
 x 위치<DD><CODE>y</CODE> - Glyph가 draw 되는 사용자 공간의 
 y 위치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>g</code> 가 <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Font.html#createGlyphVector(java.awt.font.FontRenderContext, java.lang.String)"><CODE>Font.createGlyphVector(java.awt.font.FontRenderContext, java.lang.String)</CODE></A> , 
<A HREF="../../java/awt/font/GlyphVector.html" title="java.awt.font 안의 클래스"><CODE>GlyphVector</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fill(java.awt.Shape)"><!-- --></A> <H3>
fill</H3>
<PRE>
public abstract void <B>fill</B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s)</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥의 설정을 사용하는 것으로,<code>Shape</code> 의 내부를 전부 칠합니다. 적용되는 draw 속성에는,<code>Clip</code>,<code>Transform</code>,<code>Paint</code>, 및 <code>Composite</code> 의 각 속성이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 전부 칠해지는 <code>Shape</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="hit(java.awt.Rectangle, java.awt.Shape, boolean)"><!-- --></A> <H3>
hit</H3>
<PRE>
public abstract boolean <B>hit</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;rect,
                            <A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s,
                            boolean&nbsp;onStroke)</PRE>
<DL>
<DD>지정된 <code>Shape</code> 가 지정된 <A HREF="../../java/awt/Rectangle.html" title="java.awt 동안의 클래스"><CODE>Rectangle</CODE></A>  (디바이스 공간에 있다)와 교차할지 어떨지를 판정합니다. <code>onStroke</code> 가 false 의 경우, 이 메소드는 지정된 <code>Shape</code> 의 내부가 지정된 <code>Rectangle</code> 와 교차할지 어떨지를 조사합니다. <code>onStroke</code> 가 <code>true</code> 의 경우, 이 메소드는 지정된 <code>Shape</code> 의 윤곽의 <code>Stroke</code> 가 지정된 <code>Rectangle</code> 와 교차할지 어떨지를 조사합니다. 고려되는 draw 속성에는,<code>Clip</code>,<code>Transform</code>, 및 <code>Stroke</code> 의 각 속성이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rect</CODE> - 히트를 조사하는 디바이스 공간의 영역<DD><CODE>s</CODE> - 히트를 조사하는 <code>Shape</code><DD><CODE>onStroke</CODE> - stroke로 draw 된 형상을 조사할까 
 전부 칠해진 형상을 조사하는지를 선택하는 플래그. 플래그가 <code>true</code> 의 경우는, 
 <code>Stroke</code> 의 윤곽이 조사할 수 있다. 플래그가  
 <code>false</code> 의 경우는, 전부 칠해진 <code>Shape</code> 가 조사할 수 있다
<DT><B>반환값:</B><DD>히트가 있는 경우는 <code>true</code>, 그렇지 않은 경우는  
 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setStroke(java.awt.Stroke)"><CODE>setStroke(java.awt.Stroke)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#fill(java.awt.Shape)"><CODE>fill(java.awt.Shape)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#draw(java.awt.Shape)"><CODE>draw(java.awt.Shape)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDeviceConfiguration()"><!-- --></A> <H3>
getDeviceConfiguration</H3>
<PRE>
public abstract <A HREF="../../java/awt/GraphicsConfiguration.html" title="java.awt 내의 클래스">GraphicsConfiguration</A>  <B>getDeviceConfiguration</B>()</PRE>
<DL>
<DD>이 <code>Graphics2D</code> 에 관련한 디바이스 구성을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>Graphics2D</code> 속성의 디바이스 구성</DL>
</DD>
</DL>
<HR>

<A NAME="setComposite(java.awt.Composite)"><!-- --></A> <H3>
setComposite</H3>
<PRE>
public abstract void <B>setComposite</B>(<A HREF="../../java/awt/Composite.html" title="java.awt 안의 인터페이스">Composite</A> &nbsp;comp)</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥의 <code>Composite</code> 를 설정합니다. <code>Composite</code> 는,<code>drawImage</code>,<code>drawString</code>,<code>draw</code>, 및 <code>fill</code> 등의 모든 draw 메소드로 사용됩니다. <code>Composite</code> 는, 그래픽스 디바이스에서의 draw 처리중에 새로운 픽셀이 기존의 픽셀과 어떻게 결합되는지를 지정합니다.
　<p>이 <code>Graphics2D</code> 문맥이 표시 화면의 <code>Component</code> 에 draw 되고 있는 경우,<code>Composite</code> 는 <code>AlphaComposite</code> 클래스의 인스턴스가 아닌 커스텀 객체입니다. 시큐리티 매니저가 있는 경우는, 시큐리티 매니저의 <code>checkPermission</code> 메소드가 액세스권 <code>AWTPermission("readDisplayPixels")</code> 를 지정해 불려 갑니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>comp</CODE> - draw에 사용되는 <code>Composite</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 화면에 draw 하기 위해서 커스텀 <code>Composite</code> 객체가
         사용되고 있어 시큐리티 매니저가 설정되어 있는 경우에,
         시큐리티 매니저의 <code>checkPermission</code> 메소드가
         이 조작을 허가하지 않을 때<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#setXORMode(java.awt.Color)"><CODE>Graphics.setXORMode(java.awt.Color)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setPaintMode()"><CODE>Graphics.setPaintMode()</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#getComposite()"><CODE>getComposite()</CODE></A> , 
<A HREF="../../java/awt/AlphaComposite.html" title="java.awt 안의 클래스"><CODE>AlphaComposite</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> , 
<A HREF="../../java/awt/AWTPermission.html" title="java.awt 안의 클래스"><CODE>AWTPermission</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPaint(java.awt.Paint)"><!-- --></A> <H3>
setPaint</H3>
<PRE>
public abstract void <B>setPaint</B>(<A HREF="../../java/awt/Paint.html" title="java.awt 안의 인터페이스">Paint</A> &nbsp;paint)</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥에 <code>Paint</code> 속성을 설정합니다. 이 메소드를 <code>null</code> <code>Paint</code> 객체로 호출해도, 이 <code>Graphics2D</code> 의 현재의 <code>Paint</code> 속성에는 영향을 주지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>paint</CODE> - draw 프로세스로 색을 생성하기 위해서 사용된다  
 <code>Paint</code>, 또는 <code>null</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#getPaint()"><CODE>getPaint()</CODE></A> , 
<A HREF="../../java/awt/GradientPaint.html" title="java.awt 안의 클래스"><CODE>GradientPaint</CODE></A> , 
<A HREF="../../java/awt/TexturePaint.html" title="java.awt 안의 클래스"><CODE>TexturePaint</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setStroke(java.awt.Stroke)"><!-- --></A> <H3>
setStroke</H3>
<PRE>
public abstract void <B>setStroke</B>(<A HREF="../../java/awt/Stroke.html" title="java.awt 안의 인터페이스">Stroke</A> &nbsp;s)</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥의 <code>Stroke</code> 를 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - draw 프로세스로 <code>Shape</code> 를 stroke로 
 draw 하기 위해서 사용되는 <code>Stroke</code> 객체<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/BasicStroke.html" title="java.awt 내의 클래스"><CODE>BasicStroke</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#getStroke()"><CODE>getStroke()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRenderingHint(java.awt.RenderingHints.Key, java.lang.Object)"><!-- --></A> <H3>
setRenderingHint</H3>
<PRE>
public abstract void <B>setRenderingHint</B>(<A HREF="../../java/awt/RenderingHints.Key.html" title="java.awt 안의 클래스">RenderingHints.Key</A> &nbsp;hintKey,
                                      <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;hintValue)</PRE>
<DL>
<DD>draw 알고리즘의 추천 설정의 값을 1 개 설정합니다. Hint 카테고리에는, draw 품질을 제어하는 것으로, draw 프로세스에서의 draw 속도와 draw 품질과의 전체적인 타협점을 제어하는 것이 포함됩니다. <code>RenderingHints</code> 클래스에서, 공통의 키와 값의 정의의 일부를 참조할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hintKey</CODE> - 설정되는 힌트의 키<DD><CODE>hintValue</CODE> - 지정된 힌트 카테고리의 추천 설정을
 가리키는 값<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#getRenderingHint(java.awt.RenderingHints.Key)"><CODE>getRenderingHint(RenderingHints.Key)</CODE></A> , 
<A HREF="../../java/awt/RenderingHints.html" title="java.awt 안의 클래스"><CODE>RenderingHints</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRenderingHint(java.awt.RenderingHints.Key)"><!-- --></A> <H3>
getRenderingHint</H3>
<PRE>
public abstract <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getRenderingHint</B>(<A HREF="../../java/awt/RenderingHints.Key.html" title="java.awt 안의 클래스">RenderingHints.Key</A> &nbsp;hintKey)</PRE>
<DL>
<DD>draw 알고리즘의 추천 설정의 값을 1 개 돌려줍니다. Hint 카테고리에는, draw 품질을 제어하는 것으로, draw 프로세스에서의 draw 속도와 draw 품질과의 전체적인 타협점을 제어하는 것이 포함됩니다. <code>RenderingHints</code> 클래스에서, 공통의 키와 값의 정의의 일부를 참조할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hintKey</CODE> - 취득하는 힌트에 대응하는 키
<DT><B>반환값:</B><DD>지정된 힌트 키의 값을 나타내는 객체.
 몇개의 키와 그 키에 관련한 값은 <code>RenderingHints</code> 클래스에서
 정의되고 있는<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/RenderingHints.html" title="java.awt 내의 클래스"><CODE>RenderingHints</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setRenderingHint(java.awt.RenderingHints.Key, java.lang.Object)"><CODE>setRenderingHint(RenderingHints.Key, Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRenderingHints(java.util.Map)"><!-- --></A> <H3>
setRenderingHints</H3>
<PRE>
public abstract void <B>setRenderingHints</B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?,?&gt;&nbsp;hints)</PRE>
<DL>
<DD>draw 알고리즘의 모든 추천 설정의 값을, 지정된 <code>hints</code> 에 옮겨놓습니다. draw 힌트의 기존의 값은 모두 파기되어 기존의 힌트와 값의 새로운 세트가 지정된 <A HREF="../../java/util/Map.html" title="java.util 동안의 인터페이스"><CODE>Map</CODE></A>  객체로부터 초기화됩니다. Hint 카테고리에는, draw 품질을 제어하는 것으로, draw 프로세스에서의 draw 속도와 draw 품질과의 전체적인 타협점을 제어하는 것이 포함됩니다. <code>RenderingHints</code> 클래스에서, 공통의 키와 값의 정의의 일부를 참조할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hints</CODE> - 설정되는 draw 힌트<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#getRenderingHints()"><CODE>getRenderingHints()</CODE></A> , 
<A HREF="../../java/awt/RenderingHints.html" title="java.awt 안의 클래스"><CODE>RenderingHints</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="addRenderingHints(java.util.Map)"><!-- --></A> <H3>
addRenderingHints</H3>
<PRE>
public abstract void <B>addRenderingHints</B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?,?&gt;&nbsp;hints)</PRE>
<DL>
<DD>draw 알고리즘에 관한 임의의 수의 추천 설정의 값을 설정합니다. 지정된 <code>Map</code> 객체에 있는 draw 힌트의 값만이 변경됩니다. 지정된 객체에 없는 추천 설정은 변경되지 않습니다. Hint 카테고리에는, draw 품질을 제어하는 것으로, draw 프로세스에서의 draw 속도와 draw 품질과의 전체적인 타협점을 제어하는 것이 포함됩니다. <code>RenderingHints</code> 클래스에서, 공통의 키와 값의 정의의 일부를 참조할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hints</CODE> - 설정되는 draw 힌트<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/RenderingHints.html" title="java.awt 내의 클래스"><CODE>RenderingHints</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRenderingHints()"><!-- --></A> <H3>
getRenderingHints</H3>
<PRE>
public abstract <A HREF="../../java/awt/RenderingHints.html" title="java.awt 내의 클래스">RenderingHints</A>  <B>getRenderingHints</B>()</PRE>
<DL>
<DD>draw 알고리즘의 추천 설정을 돌려줍니다. Hint 카테고리에는, draw 품질을 제어하는 것으로, draw 프로세스에서의 draw 속도와 draw 품질과의 전체적인 타협점을 제어하는 것이 포함됩니다. 1 회의 오퍼레이션으로 지정된 모든 힌트 키와 값의 페어를 돌려줍니다. <code>RenderingHints</code> 클래스에서, 공통의 키와 값의 정의의 일부를 참조할 수 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 추천 설정을 포함하고 있는 <code>RenderingHints</code> 의
 인스턴스에의 참조<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/RenderingHints.html" title="java.awt 내의 클래스"><CODE>RenderingHints</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setRenderingHints(java.util.Map)"><CODE>setRenderingHints(Map)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="translate(int, int)"><!-- --></A> <H3>
translate</H3>
<PRE>
public abstract void <B>translate</B>(int&nbsp;x,
                               int&nbsp;y)</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥의 원점을, 현재의 좌표계의 점 (<i>x</i>, &nbsp;<i>y</i>)으로 이동합니다. <code>Graphics2D</code> 문맥을 수정해, 새로운 원점이 <code>Graphics2D</code> 문맥의 원의 좌표계의 점 (<i>x</i>, &nbsp;<i>y</i>)에 대응하도록(듯이) 합니다. 이 그래픽스 문맥으로 그 이후의 draw 조작으로 사용되는 좌표는 모두, 이 새로운 원점을 기준으로 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Graphics.html#translate(int, int)">translate</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 지정된 x 좌표<DD><CODE>y</CODE> - 지정된 y 좌표<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="translate(double, double)"><!-- --></A> <H3>
translate</H3>
<PRE>
public abstract void <B>translate</B>(double&nbsp;tx,
                               double&nbsp;ty)</PRE>
<DL>
<DD>현재의 <code>Graphics2D</code> <code>Transform</code> 를 이동 변환과 연결합니다. 이후의 draw는, 이전의 위치를 기준으로 지정된 거리로 이동합니다. 이것은, transform(T)를 호출하는 것에 상당합니다.  다만, T 는 다음의 행렬에 의해 표현되는 <code>AffineTransform</code> 입니다.
 <pre>
                [   1    0    tx  ]
                [   0    1    ty  ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tx</CODE> - x 축으로 따라 이동하는 거리<DD><CODE>ty</CODE> - y 축으로 따라 이동하는 거리</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double)"><!-- --></A> <H3>
rotate</H3>
<PRE>
public abstract void <B>rotate</B>(double&nbsp;theta)</PRE>
<DL>
<DD>현재의 <code>Graphics2D</code> <code>Transform</code> 를 회전 변환과 연결합니다. 이후의 draw는, 이전의 원점을 기준으로 지정된 라디안으로 회전합니다. 이것은,<code>transform(R)</code> 를 호출하는 것에 상당합니다.  다만, R 는 다음의 행렬에 의해 표현되는 <code>AffineTransform</code> 입니다.
 <pre>
                [   cos(theta)    -sin(theta)    0   ]
                [   sin(theta)     cos(theta)    0   ]
                [       0              0         1   ]
 </pre>
정의 각도 theta 로 회전하면(자), 정의 x 축의 점이 정의 y 축으로 향해 회전됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 나타낸 회전 각도</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double, double, double)"><!-- --></A> <H3>
rotate</H3>
<PRE>
public abstract void <B>rotate</B>(double&nbsp;theta,
                            double&nbsp;x,
                            double&nbsp;y)</PRE>
<DL>
<DD>현재의 <code>Graphics2D</code> <code>Transform</code> 를 이동 후의 회전 변환과 연결합니다. 이후의 draw는, 지정된 위치로 이동해, 지정된 라디안으로 회전해, 원의 평행이동과 같은 양으로 평행이동 다시 하는 것으로 작성되는 변환에 의해 변환됩니다. 이것은, 다음의 calling sequence에 상당합니다.
 <pre>
                translate(x, y);
                rotate(theta);
                translate(-x, -y);
 </pre>
정의 각도 theta 로 회전하면(자), 정의 x 축의 점이 정의 y 축으로 향해 회전됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 나타낸 회전 각도<DD><CODE>x</CODE> - 회전의 원점의 x 좌표<DD><CODE>y</CODE> - 회전의 원점의 y 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="scale(double, double)"><!-- --></A> <H3>
scale</H3>
<PRE>
public abstract void <B>scale</B>(double&nbsp;sx,
                           double&nbsp;sy)</PRE>
<DL>
<DD>현재의 <code>Graphics2D</code> <code>Transform</code> 를 슬캘링 변환과 연결합니다.  이후의 draw는, 이전의 슬캘링을 기준으로 지정된 슬캘링 계수에 따라 사이즈 변경됩니다. 이것은,<code>transform(S)</code> 를 호출하는 것에 상당합니다.  다만, S 는 다음의 행렬에 의해 표현되는 <code>AffineTransform</code> 입니다.
 <pre>
                [   sx   0    0   ]
                [   0    sy   0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>sx</CODE> - 이후의 draw 조작의 X 좌표가
 이전의 draw 조작을 기준에
 곱셈되는 양<DD><CODE>sy</CODE> - 이후의 draw 조작의 Y 좌표가 
 이전의 draw 조작을 기준에 
 곱셈되는 양</DL>
</DD>
</DL>
<HR>

<A NAME="shear(double, double)"><!-- --></A> <H3>
shear</H3>
<PRE>
public abstract void <B>shear</B>(double&nbsp;shx,
                           double&nbsp;shy)</PRE>
<DL>
<DD>현재의 <code>Graphics2D</code> <code>Transform</code> 를 셔링 변환과 연결합니다. 이후의 draw는, 이전의 위치를 기준으로 지정된 승수로 셔링 됩니다. 이것은,<code>transform(SH)</code> 를 호출하는 것에 상당합니다.  다만, SH 는 다음의 행렬에 의해 표현되는 <code>AffineTransform</code> 입니다.
 <pre>
                [   1   shx   0   ]
                [  shy   1    0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>shx</CODE> - Y 좌표의 함수로서 좌표를 정의  
 X 축방향으로 쉬프트하기 위한 승수<DD><CODE>shy</CODE> - X 좌표의 함수로서 좌표를 정의 
 Y 축방향으로 쉬프트하기 위한 승수</DL>
</DD>
</DL>
<HR>

<A NAME="transform(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
transform</H3>
<PRE>
public abstract void <B>transform</B>(<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</PRE>
<DL>
<DD><code>AffineTransform</code> 객체를 이 <code>Graphics2D</code> 에서의 <code>Transform</code> 를 사용해, 후 지정 우선 적용이라고 하는 규칙에 따라 변환합니다. 현재의 <code>Transform</code> 가 Cx 인 경우, Tx 에 의한 변환의 결과는 새로운 <code>Transform</code> Cx'가 됩니다. Cx'는, 이 <code>Graphics2D</code> 용의 현재의 <code>Transform</code> 가 됩니다. 갱신된 <code>Transform</code> Cx'로 점 p 를 변환하는 것은, 최초로 Tx 로 p 를 변환하고 나서, 그 결과를 원의 <code>Transform</code> Cx 로 변환하는 것에 상당합니다. 즉, Cx'(p) = Cx(Tx(p))입니다. 필요에 따라서 Tx 의 카피를 실시하면, Tx 를 그 이상 수정해도 draw에 영향을 주지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>Tx</CODE> - 현재의 <code>Transform</code> 로 변환된다 
 <code>AffineTransform</code> 객체<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스"><CODE>AffineTransform</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setTransform(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
setTransform</H3>
<PRE>
public abstract void <B>setTransform</B>(<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥으로 Transform 를 덧쓰기합니다. 경고:이 메소드는 새로운 좌표변화를 기존의 변환상에서 적용하는 목적에서는 사용<b>하지 말아 주세요</b>.  이것은,<code>Graphics2D</code> 에는, Swing 컴퍼넌트의 draw 또는 프린터의 해상도를 조정하기 위한 슬캘링 변환의 적용 등, 다른 목적을 위해서(때문에) 필요한 변환이 벌써 포함되어 있기 때문입니다.   
　<p>좌표변화를 추가하기 위해서,<code>transform</code>,<code>rotate</code>,<code>scale</code>, 또는<code>shear</code> 메소드를 사용합니다. <code>setTransform</code> 는, 이 예로 나타나고 있는 대로, draw 종료후에 원의 <code>Graphics2D</code> 변환을 복원하기 (위해)때문에인 만큼 사용됩니다.
 <pre><blockquote>
 // Get the current transform
 AffineTransform saveAT = g2.getTransform();
 // Perform transformation
 g2d.transform(...);
 // Render
 g2d.draw(...);
 // Restore original transform
 g2d.setTransform(saveAT);
 </blockquote></pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>Tx</CODE> - <code>getTransform</code> 메소드로부터 취득되었다
           <code>AffineTransform</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#getTransform()"><CODE>getTransform()</CODE></A> , 
<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스"><CODE>AffineTransform</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTransform()"><!-- --></A> <H3>
getTransform</H3>
<PRE>
public abstract <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getTransform</B>()</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥에서의 현재의 <code>Transform</code> 의 카피를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD><code>Graphics2D</code> 문맥에서의 
             현재의 <code>AffineTransform</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A> , 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPaint()"><!-- --></A> <H3>
getPaint</H3>
<PRE>
public abstract <A HREF="../../java/awt/Paint.html" title="java.awt 내의 인터페이스">Paint</A>  <B>getPaint</B>()</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥에서의 현재의 <code>Paint</code> 를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>색 또는 패턴을 정의하는 현재의 
 <code>Graphics2D</code> <code>Paint</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getComposite()"><!-- --></A> <H3>
getComposite</H3>
<PRE>
public abstract <A HREF="../../java/awt/Composite.html" title="java.awt 내의 인터페이스">Composite</A>  <B>getComposite</B>()</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥에서의 현재의 <code>Composite</code> 를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>거듭해 맞댐 스타일을 정의하는 현재의 
              <code>Graphics2D</code> <code>Composite</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setBackground(java.awt.Color)"><!-- --></A> <H3>
setBackground</H3>
<PRE>
public abstract void <B>setBackground</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;color)</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥의 백그라운드 칼라를 설정합니다. 백그라운드 칼라는, 영역을 클리어 하기 위해서 사용됩니다. <code>Graphics2D</code> 를 <code>Component</code> 용으로 작성하면(자), 백그라운드 칼라가 <code>Component</code> 로부터 상속됩니다. <code>Graphics2D</code> 문맥에서의 백그라운드 칼라를 설정해도, 그 이후의 <code>clearRect()</code> 호출해에 작용하는 것만으로,<code>Component</code> 의 백그라운드 칼라에는 영향을 미치지 않습니다. <code>Component</code> 의 백그라운드를 변경하려면 ,<code>Component</code> 의 적절한 메소드를 사용합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>color</CODE> - 이후의 <code>clearRect</code> 의 호출로
 사용되는 백그라운드 칼라<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#getBackground()"><CODE>getBackground()</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#clearRect(int, int, int, int)"><CODE>Graphics.clearRect(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBackground()"><!-- --></A> <H3>
getBackground</H3>
<PRE>
public abstract <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>getBackground</B>()</PRE>
<DL>
<DD>영역을 클리어 하는데 사용하는 백그라운드 칼라를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>백그라운드 칼라를 정의하는 현재의 
 <code>Graphics2D</code> <code>Color</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setBackground(java.awt.Color)"><CODE>setBackground(java.awt.Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getStroke()"><!-- --></A> <H3>
getStroke</H3>
<PRE>
public abstract <A HREF="../../java/awt/Stroke.html" title="java.awt 내의 인터페이스">Stroke</A>  <B>getStroke</B>()</PRE>
<DL>
<DD><code>Graphics2D</code> 문맥에서의 현재의 <code>Stroke</code> 를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>선의 스타일을 정의하는 현재의 
                 <code>Graphics2D</code> <code>Stroke</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setStroke(java.awt.Stroke)"><CODE>setStroke(java.awt.Stroke)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="clip(java.awt.Shape)"><!-- --></A> <H3>
clip</H3>
<PRE>
public abstract void <B>clip</B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s)</PRE>
<DL>
<DD>현재의 <code>Clip</code> 가 지정된 <code>Shape</code> 의 내부와 교차시켜, 결과적으로 생긴 공통 부분에 그 <code>Clip</code> 를 설정합니다. 지정된 <code>Shape</code> 는, 현재의 <code>Clip</code> 와 교차하기 전에, 현재의 <code>Graphics2D</code> <code>Transform</code> 를 사용해 변환됩니다. 이 메소드를 사용하면(자), 현재의 <code>Clip</code> 를 작게 할 수 있습니다. <code><code>Clip</code> 를 크게 하려면 ,<code>setClip</code> 메소드를 사용합니다. 이 메소드에 의해 변경된 사용자 클립은, 디바이스의 경계 및 가시성과 관련한 클리핑과는 무관계합니다. 지금까지 설정되어 있는 클립이 없는 경우, 또는 <A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)"><CODE>setClip</CODE></A>  에 <code>null</code> 인수를 사용해 클립이 클리어 되고 있는 경우는, 지정된 <code>Shape</code> 가 새로운 사용자 클립이 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 현재의 <code>Clip</code> 와 교차한다 
          <code>Shape</code>. <code>s</code> 가 <code>null</code> 의 경우,
          이 메소드는 현재의 <code>Clip</code> 를 클리어 한다</DL>
</DD>
</DL>
<HR>

<A NAME="getFontRenderContext()"><!-- --></A> <H3>
getFontRenderContext</H3>
<PRE>
public abstract <A HREF="../../java/awt/font/FontRenderContext.html" title="java.awt.font 내의 클래스">FontRenderContext</A>  <B>getFontRenderContext</B>()</PRE>
<DL>
<DD>이 <code>Graphics2D</code> 문맥에서의 <code>Font</code> 의 draw 문맥을 돌려줍니다. <A HREF="../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스"><CODE>FontRenderContext</CODE></A>  는, 에일리어징 제거나 부분 메트릭스등의 어플리케이션 힌트외, 타겟 디바이스에 특유의 해상도 (dpi)등의 정보를 캡슐화합니다. 이러한 정보는,<code>Font</code> 나 <code>TextLayout</code> 등의 문자 체재의 포맷을 실행하는 객체의 사용시에 어플리케이션에 의해 제공됩니다. 이 정보는 또, 각종 draw 힌트가 텍스트 draw에 적용되었을 때에, 그 자체의 레이아웃을 실행해, 유효폭이나 행의 높이 등, Glyph의 각종 특성의 정확한 계측을 필요로 하는 어플리케이션에 의해 제공되지 않으면 안됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>FontRenderContext 의 인스턴스에의 참조<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/font/FontRenderContext.html" title="java.awt.font 내의 클래스"><CODE>FontRenderContext</CODE></A> , 
<A HREF="../../java/awt/Font.html#createGlyphVector(java.awt.font.FontRenderContext, java.lang.String)"><CODE>Font.createGlyphVector(java.awt.font.FontRenderContext, java.lang.String)</CODE></A> , 
<A HREF="../../java/awt/font/TextLayout.html" title="java.awt.font 안의 클래스"><CODE>TextLayout</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics2D.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/awt/GraphicsConfigTemplate.html" title="java.awt 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/awt/Graphics2D.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Graphics2D.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
