<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:57:04 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Thread (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Thread (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Thread.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/System.html" title="java.lang 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/Thread.State.html" title="java.lang 내의 열거형"><B>차의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Thread.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Thread.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang</FONT>
<BR>
클래스 Thread</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.lang.Thread</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>Thread</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> </DL>
</PRE>

<P>
「thread」란, 프로그램내에서의 실행 thread입니다. Java 가상 머신에서는, 어플리케이션은 병렬에 실행되는 복수의 thread를 사용할 수가 있습니다.  &nbsp;<p>
각 thread에는 우선 순위를 붙일 수 있고 있습니다. 우선 순위의 높은 thread는, 우선 순위의 낮은 thread보다 우선해 실행됩니다. 게다가 각 thread가 demon로서 마크 되고 있는 경우도 있으면, 되어 있지 않은 경우도 있습니다. 어느 thread로 실행중의 코드가 새로운 <code>Thread</code> 객체를 작성하면(자), 이 새로운 thread에는, 그 시점에서는, 작성측의 thread의 우선 순위에 동일한 우선 순위가 설정되어 작성측 thread가 demon인 경우에만, demon thread.  &nbsp;<p>
일반적으로, Java 가상 머신이 기동하는 (일반적으로는 있는 지정된 클래스의 <code>main</code> 라는 이름이 붙일 수 있었던 메소드를 호출한다)와 demon thread가 아닌 thread가 1 개 존재합니다. Java 가상 머신은, 이하의 어떤 것인가의 조건이 발생할 때까지 thread를 계속 실행합니다.  
 <ul>
<li><code>Runtime</code> 클래스의 <code>exit</code> 메소드가 불려 가 시큐리티 매니저가 exit 동작을 허가했을 경우 
<li><code>run</code> 메소드의 호출로부터 복귀하는 것에 의해, 또는 <code>run</code> 메소드 이외로부터 보내지는 예외를 throw 하는 것에 의해, demon thread는 아닌 모든 thread가 종료했을 경우
 </ul>
 <p>
새로운 실행의 thread를 작성하려면 2 방법의 방법이 있습니다. 1 개의 방법은, 클래스를 <code>Thread</code> 의 서브 클래스이다고 선언하는 것입니다. 이 서브 클래스는,<code>Thread</code> 클래스의 <code>run</code> 메소드를 오버라이드(override) 하지 않으면 안됩니다. 그러면 서브 클래스의 인스턴스는 할당할 수 있어 기동될 수가 있습니다. 예를 들어, 초기치보다 큰 소수를 계산하는 thread는, 다음에 나타내도록(듯이) 해 작성할 수 있습니다.  
 <p><hr><blockquote><pre>
     class PrimeThread extends Thread {
         long minPrime;
         PrimeThread(long minPrime) {
             this.minPrime = minPrime;
         }
 
         public void run() {
             // compute primes larger than minPrime
             &nbsp;. &nbsp;. &nbsp;.
         }
     }
 </pre></blockquote><hr>
 <p>
다음에, 다음에 나타내는 코드로 thread를 작성해, thread의 실행을 개시합니다.  
 <p><blockquote><pre>
     PrimeThread p = new PrimeThread(143);
     p.start();
 </pre></blockquote>
 <p>
thread를 작성하는 이제(벌써) 1 개의 방법은,<code>Runnable</code> 인터페이스를 구현하는 클래스를 선언하는 것입니다. 그렇다면, 그 클래스는,<code>run</code> 메소드를 구현합니다. 클래스의 인스턴스를 할당할 수 있어<code>Thread</code> 의 작성시에 인수로서 건네받아 개시됩니다. 이 방법에서의 같은 예는, 다음에 나타내게 됩니다.  
 <p><hr><blockquote><pre>
     class PrimeRun implements Runnable {
         long minPrime;
         PrimeRun(long minPrime) {
             this.minPrime = minPrime;
         }
 
         public void run() {
             // compute primes larger than minPrime
             &nbsp;. &nbsp;. &nbsp;.
         }
     }
 </pre></blockquote><hr>
 <p>
다음에, 다음에 나타내는 코드로 thread를 작성해, thread의 실행을 개시합니다.  
 <p><blockquote><pre>
     PrimeRun p = new PrimeRun(143);
     new Thread(p). start();
 </pre></blockquote>
 <p>
각 thread는 식별을 위한 이름을 가집니다. 복수의 thread가 같은 이름을 가지는 일이 있습니다. thread의 작성시에 이름이 지정되지 않으면 thread에는 새로운 이름이 생성됩니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Runnable.html" title="java.lang 내의 인터페이스"><CODE>Runnable</CODE></A> , 
<A HREF="../../java/lang/Runtime.html#exit(int)"><CODE>Runtime.exit(int)</CODE></A> , 
<A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.State.html" title="java.lang 안의 열거형">Thread.State</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread 상태입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 안의 인터페이스">Thread.UncaughtExceptionHandler</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캐치 되지 않는 예외에 의해,<tt>Thread</tt> 가 돌연 종료했을 때에 불려 가는 것 핸들러의 인터페이스입니다. </TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#MAX_PRIORITY">MAX_PRIORITY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread로 설정할 수 있는 최고 우선 순위입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#MIN_PRIORITY">MIN_PRIORITY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread로 설정할 수 있는 최저 우선 순위입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#NORM_PRIORITY">NORM_PRIORITY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread에 할당할 수 있는 디폴트의 우선 순위입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread()">Thread</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 객체를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.Runnable)">Thread</A> </B>(<A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 객체를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.Runnable, java.lang.String)">Thread</A> </B>(<A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target,
       <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 객체를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.String)">Thread</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 객체를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable)">Thread</A> </B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
       <A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 객체를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)">Thread</A> </B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
       <A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target,
       <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그 실행 객체로서 <code>target</code> , 이름으로서 지정된 <code>name</code> 를 가지는,<code>group</code> 에 의해 참조되는 thread 그룹에 속하는 것 같은, 새로운 <code>Thread</code> 객체를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long)">Thread</A> </B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
       <A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target,
       <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
       long&nbsp;stackSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 객체를 할당해 실행 객체로서 <code>target</code> 를 보관 유지해, 지정된 <code>name</code> 를 이름으로서 보관 유지하도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.String)">Thread</A> </B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
       <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 객체를 할당합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#activeCount()">activeCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현행 thread의 thread 그룹내의 액티브한 thread수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#checkAccess()">checkAccess</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 실행중의 thread가, 이 thread를 변경하기 위한 액세스권을 가지고 있을지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#countStackFrames()">countStackFrames</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 호출의 정의는, 추천되어 있지 않은 <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>  에 의존합니다.
또, 이 호출의 결과는 보증되지 않습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#currentThread()">currentThread</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 실행중의 thread 객체의 참조를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#destroy()">destroy</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 메소드는 원래 클린 업없이 파기되도록(듯이) 설계되고 있었습니다.
보관 유지되는 모니터는 락 된 상태를 유지합니다.
다만, 이 메소드는 구현되지 않았습니다.
구현되고 있으면(자),<A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>  와 거의 똑같이 데드락이 발생합니다.
타겟 thread가 중요한 system resource를 보호하는 락을 보관 유지한 상태로 파기되었을 경우, 어느 thread도 다시 이 자원에 액세스 할 수 없습니다.
다른 thread가 이 자원을 잠그려고 하면(자), 데드락이 발생합니다. 일반적으로, 이러한 데드락은, 프로세스의 「동결」에 의해 밝혀집니다. 자세한 것은, 이하를 참조해 주세요.
<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#dumpStack()">dumpStack</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread의 스택 트레이스를 표준 에러 스트림에 출력합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#enumerate(java.lang.Thread[])">enumerate</A> </B>(<A HREF="../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> []&nbsp;tarray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현행 thread의 thread 그룹 및 그 하위 그룹내의 모든 액티브한 thread를, 지정된 배열에 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;<A HREF="../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> ,<A HREF="../../java/lang/StackTraceElement.html" title="java.lang 안의 클래스">StackTraceElement</A> []&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getAllStackTraces()">getAllStackTraces</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 라이브 thread의 스택 트레이스 맵을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/ClassLoader.html" title="java.lang 내의 클래스">ClassLoader</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getContextClassLoader()">getContextClassLoader</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 Thread 의 문맥 ClassLoader 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 내의 인터페이스">Thread.UncaughtExceptionHandler</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getDefaultUncaughtExceptionHandler()">getDefaultUncaughtExceptionHandler</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캐치 되지 않는 예외에 의해 thread가 돌연 종료했을 때에 불려 가는 디폴트의 핸들러를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getId()">getId</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 식별자를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getName()">getName</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getPriority()">getPriority</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 우선 순위를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/StackTraceElement.html" title="java.lang 내의 클래스">StackTraceElement</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getStackTrace()">getStackTrace</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 스택 덤프를 나타내는 스택 트레이스 요소의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Thread.State.html" title="java.lang 내의 열거형">Thread.State</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getState()">getState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread 상태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 내의 클래스">ThreadGroup</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getThreadGroup()">getThreadGroup</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 소속하는 thread 그룹을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 내의 인터페이스">Thread.UncaughtExceptionHandler</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getUncaughtExceptionHandler()">getUncaughtExceptionHandler</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캐치 되지 않는 예외에 의해 thread가 돌연 종료했을 때에 불려 가는 핸들러를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#holdsLock(java.lang.Object)">holdsLock</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현행 thread가 지정된 객체에 대한 모니터 락을 보관 유지하는 경우에게만,<tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#interrupt()">interrupt</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread에 끼어듭니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#interrupted()">interrupted</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread가 끼어들어지고 있는지 어떤지를 조사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#isAlive()">isAlive</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 생존하고 있을지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#isDaemon()">isDaemon</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 demon thread일지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#isInterrupted()">isInterrupted</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 끼어들어지고 있는 제발을 조사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#join()">join</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 종료하는 것을 대기합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#join(long)">join</A> </B>(long&nbsp;millis)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 종료하는 것을, 최고로 <code>millis</code> 밀리 세컨드 대기합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#join(long, int)">join</A> </B>(long&nbsp;millis,
     int&nbsp;nanos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;최고로 <code>millis</code> 밀리 세컨드에 <code>nanos</code> 나노초를 가산한 사이, 이 thread가 종료하는 것을 대기합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#resume()">resume</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 메소드는 데드락을 발생하기 쉽기 때문에 추천 되지 않습니다.  <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>  와 함께 사용하기 위해(때문에)인 만큼 제공되고 있습니다.

자세한 것은, 이하를 참조해 주세요.  
<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#run()">run</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 별개의 <code>Runnable</code> 실행 객체를 사용해 작성되었을 경우, 그 <code>Runnable</code> 객체의 <code>run</code> 메소드가 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setContextClassLoader(java.lang.ClassLoader)">setContextClassLoader</A> </B>(<A HREF="../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;cl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 Thread 의 문맥 ClassLoader 를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setDaemon(boolean)">setDaemon</A> </B>(boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread를, demon thread 또는 사용자 thread로서 마크 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)">setDefaultUncaughtExceptionHandler</A> </B>(<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 안의 인터페이스">Thread.UncaughtExceptionHandler</A> &nbsp;eh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캐치 되지 않는 예외에 의해, thread가 돌연 종료했을 때나, 이 thread에 대해서 그 밖에 핸들러가 정의되어 있지 않을 때에 불려 가는 디폴트의 핸들러를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setName(java.lang.String)">setName</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 이름을 인수 <code>name</code> 에 동일해지도록(듯이) 변경합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setPriority(int)">setPriority</A> </B>(int&nbsp;newPriority)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 우선 순위를 변경합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)">setUncaughtExceptionHandler</A> </B>(<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 안의 인터페이스">Thread.UncaughtExceptionHandler</A> &nbsp;eh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캐치 되지 않는 예외에 의해, 돌연 thread가 종료했을 때에 사용되는 핸들러를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#sleep(long)">sleep</A> </B>(long&nbsp;millis)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;시스템 타이머-와 스케쥴러가 정확한 것을 전제로서 현재 실행중의 thread를, 지정된 밀리 세컨드수의 사이, sleeve (일시적으로 실행을 정지) 시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#sleep(long, int)">sleep</A> </B>(long&nbsp;millis,
      int&nbsp;nanos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;시스템 타이머-와 스케쥴러가 정확한 것을 전제로서 현재 실행중의 thread를, 지정된 밀리 세컨드수로 지정된 나노초수를 가산한 사이, sleeve (실행을 정지) 시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#start()">start</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 실행을 개시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#stop()">stop</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 메소드는 본질적으로 안전하지는 않습니다. Thread.stop 를 사용해 thread를 정지하면(자), 체크되어 있지 않은 <code>ThreadDeath</code> 예외가 스택아래에서 위에게 전할 수 있었던 결과, 그 thread에 의해 락 되고 있던 모니터의 락이 모두 해제됩니다. 이러한 모니터에 의해 직전까지 보호되고 있던 객체가 무결성의 없는 상태에 있었을 경우, 망가진 객체는 다른 thread에 대해서 가시가 되어, 동작이 보증되지 않는 것이 있습니다. 많은 경우, 타겟 thread의 실행 정지를 지시하려면 ,<code>stop</code> 는 아니고, 단지 일부의 변수를 변경하는 코드를 사용할 필요가 있습니다. 타겟 thread는, 이 변수를 정기적으로 검사해, 실행을 정지해야 할 일을 변수가 가리키고 있는 경우에는, thread의 run 메소드로부터 일반적으로의 방법으로 복귀할 필요가 있습니다. 조건 변수등으로 타겟 thread가 오랫동안 대기하고 있는 경우, 대기를 중단시키려면 ,<code>interrupt</code> 메소드를 사용합니다.  
자세한 것은, 이하를 참조해 주세요.  
<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#stop(java.lang.Throwable)">stop</A> </B>(<A HREF="../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 메소드는 본질적으로 안전하지는 않습니다. <A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A>  를 참조해 주세요.
게다가 이 메소드는, 타겟 thread로 처리의 준비가 되어 있지 않은 예외의 생성에 사용되는 일이 있는 점에서도 위험합니다 (이 메소드가 없으면 thread에 의해 throw 될리가 없는, 체크된 예외 등).
자세한 것은, 이하를 참조해 주세요.  
<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#suspend()">suspend</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 메소드는 데드락을 발생하기 쉽기 때문에 추천 되지 않습니다.
타겟 thread가, 중단되는 시점에서, 중요한 system resource를 보호하는 모니터를 잠그고 있는 경우, 타겟 thread가 재개될 때까지 어느 thread도 그 자원에 액세스 할 수 없습니다. 이 때, 타겟 thread를 재개하는 thread가,<code>resume</code> 를 호출하기 전에 이 모니터를 잠그려고 하면(자), 데드락이 발생합니다. 일반적으로, 이러한 데드락은, 프로세스의 「동결」에 의해 밝혀집니다.
자세한 것은, 이하를 참조해 주세요.  
<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread의 이름, 우선 순위, thread 그룹을 포함한 이 thread의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#yield()">yield</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 실행중의 thread 객체를 일시적으로 휴지시켜, 다른 thread를 실행할 수 있도록(듯이) 합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="MIN_PRIORITY"><!-- --></A> <H3>
MIN_PRIORITY</H3>
<PRE>
public static final int <B>MIN_PRIORITY</B></PRE>
<DL>
<DD>thread로 설정할 수 있는 최저 우선 순위입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#java.lang.Thread.MIN_PRIORITY">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="NORM_PRIORITY"><!-- --></A> <H3>
NORM_PRIORITY</H3>
<PRE>
public static final int <B>NORM_PRIORITY</B></PRE>
<DL>
<DD>thread에 할당할 수 있는 디폴트의 우선 순위입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#java.lang.Thread.NORM_PRIORITY">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="MAX_PRIORITY"><!-- --></A> <H3>
MAX_PRIORITY</H3>
<PRE>
public static final int <B>MAX_PRIORITY</B></PRE>
<DL>
<DD>thread로 설정할 수 있는 최고 우선 순위입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#java.lang.Thread.MAX_PRIORITY">정수 필드치</A> </DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Thread()"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>()</PRE>
<DL>
<DD>새로운 <code>Thread</code> 객체를 할당합니다. 이 생성자 은,<code>Thread(null, null,</code> <i>gname</i><code>)</code> 와 같은 효과를 가집니다.  이 경우,<b><i>gname</i></b> 는, 새롭게 작성되는 이름입니다. 자동적으로 작성되는 이름은,<i>n</i> 를 정수로 하면(자) <code>"Thread-"+</code><i>n</i> 의 형식을 취합니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.Runnable)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target)</PRE>
<DL>
<DD>새로운 <code>Thread</code> 객체를 할당합니다. 이 생성자 은,<code>Thread(null, target,</code> <i>gname</i><code>)</code> 와 같은 효과를 가집니다.  이 경우,<i>gname</i> 는, 새롭게 작성되는 이름입니다. 자동적으로 작성되는 이름은,<i>n</i> 를 정수로 하면(자) <code>"Thread-"+</code><i>n</i> 의 형식을 취합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>target</CODE> - 그 <code>run</code> 메소드가 불려 가는 객체<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.ThreadGroup, java.lang.Runnable)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
              <A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target)</PRE>
<DL>
<DD>새로운 <code>Thread</code> 객체를 할당합니다. 이 생성자 은,<code>Thread(group, target,</code> <i>gname</i><code>)</code> 와 같은 효과를 가집니다.  이 경우,<i>gname</i> 는, 새롭게 작성되는 이름입니다. 자동적으로 작성되는 이름은,<i>n</i> 를 정수로 하면(자) <code>"Thread-"+</code><i>n</i> 의 형식을 취합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>group</CODE> - thread 그룹<DD><CODE>target</CODE> - 그 <code>run</code> 메소드가 불려 가는 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가, 지정된 thread 그룹내의 thread를 작성할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.String)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>새로운 <code>Thread</code> 객체를 할당합니다. 이 생성자 은,<code>Thread(null, null, name)</code> 와 같은 효과를 가집니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 새로운 thread의 이름<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.ThreadGroup, java.lang.String)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>새로운 <code>Thread</code> 객체를 할당합니다. 이 생성자 은,<code>Thread(group, null, name)</code> 와 같은 효과를 가집니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>group</CODE> - thread 그룹<DD><CODE>name</CODE> - 새로운 thread의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가, 지정된 thread 그룹내의 thread를 작성할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.Runnable, java.lang.String)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>새로운 <code>Thread</code> 객체를 할당합니다. 이 생성자 은,<code>Thread(null, target, name)</code> 와 같은 효과를 가집니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>target</CODE> - 그 <code>run</code> 메소드가 불려 가는 객체<DD><CODE>name</CODE> - 새로운 thread의 이름<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
              <A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>그 실행 객체로서 <code>target</code> , 이름으로서 지정된 <code>name</code> 를 가지는,<code>group</code> 에 의해 참조되는 thread 그룹에 속하는 것 같은, 새로운 <code>Thread</code> 객체를 할당합니다.  &nbsp;<p>
<code>group</code> 가 <code>null</code> 로, 시큐리티 매니저가 존재하는 경우, 그룹은 시큐리티 매니저의 <code>getThreadGroup</code> 메소드에 의해 정해집니다. <code>group</code> 가 <code>null</code> 로 시큐리티 매니저가 존재하지 않는 경우, 또는 시큐리티 매니저의 <code>getThreadGroup</code> 메소드가 <code>null</code> 를 돌려주는 경우, 그룹은 신규 thread를 작성중의 thread와 같은 ThreadGroup 로 설정됩니다.
 
 <p>시큐리티 매니저가 존재하는 경우는, ThreadGroup 를 인수로서 건네주어 <code>checkAccess</code> 메소드를 호출합니다. &nbsp;<p>또,<code>getContextClassLoader</code> 메소드 또는 <code>setContextClassLoader</code> 메소드를 오버라이드(override) 하는 서브 클래스의 생성자 에 의해 직접적 또는 간접적으로 불려 갔을 때,<code>RuntimePermission("enableContextClassLoaderOverride")</code> 액세스권을 사용해 <code>checkPermission</code> 메소드를 호출합니다. 그 결과, SecurityException 가 발생하는 일이 있습니다.

 <p>
<code>target</code> 인수가 <code>null</code> 가 아닌 경우, 이 thread가 기동되면(자) <code>target</code> 의 <code>run</code> 메소드가 불려 갑니다. target 인수가 <code>null</code> 인 경우는, 이 thread가 기동될 때 이 thread의 <code>run</code> 메소드가 불려 갑니다.  &nbsp;<p>
새롭게 작성된 thread의 우선 순위는, 그 thread를 작성한 thread, 즉 현재 실행중의 thread의 우선 순위와 같게 설정됩니다. 이 우선 순위를 새로운 값으로 변경하는 경우는,<code>setPriority</code> 메소드를 사용할 수 있습니다.  &nbsp;<p>
새롭게 작성된 thread는, 그것을 작성하는 thread가 demon thread와 마크 되고 있는 경우에만, demon thread와 마크 됩니다. thread가 demon일지 어떨지를 변경하는 경우는,<code>setDaemon</code> 메소드를 사용할 수 있습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>group</CODE> - thread 그룹<DD><CODE>target</CODE> - 그 <code>run</code> 메소드가 불려 가는 객체<DD><CODE>name</CODE> - 새로운 thread의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가, 지정된 thread 그룹내에 thread를 작성할 수 없는, 또는 문맥 클래스 로더의 메소드를 오버라이드(override) 할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Runnable.html#run()"><CODE>Runnable.run()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#setDaemon(boolean)"><CODE>setDaemon(boolean)</CODE></A> , 
<A HREF="../../java/lang/Thread.html#setPriority(int)"><CODE>setPriority(int)</CODE></A> , 
<A HREF="../../java/lang/ThreadGroup.html#checkAccess()"><CODE>ThreadGroup.checkAccess()</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.Thread)"><CODE>SecurityManager.checkAccess(java.lang.Thread)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
              <A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
              long&nbsp;stackSize)</PRE>
<DL>
<DD>새로운 <code>Thread</code> 객체를 할당해 실행 객체로서 <code>target</code> 를 보관 유지해, 지정된 <code>name</code> 를 이름으로서 보관 유지하도록(듯이) 합니다. 또,<code>group</code> 에 의해 참조되는 thread 그룹에 소속해, 지정된 「스택 사이즈」를 보관 유지합니다.

 <p>이 생성자 은, thread의 스택 사이즈 지정이 가능한 점을 제외해,<A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A>  와 같습니다. 스택 사이즈는, 가상 머신을 이 thread의 스택에 할당하는 address 공간의 대략의 바이트수가 됩니다. <b><tt>stackSize</tt> 파라미터가 존재하는 경우, 그 효과는 플랫폼에 의해 크게 다릅니다. </b>

 <p>몇개의 플랫폼에서는,<tt>stackSize</tt> 파라미터에 의해 큰 값을 지정하는 것으로, thread가 <A HREF="../../java/lang/StackOverflowError.html" title="java.lang 안의 클래스"><CODE>StackOverflowError</CODE></A>  를 throw 하기 전에 의해 큰 회귀 심도를 달성하는 것이 가능하게 됩니다. 같이보다 작은 값을 지정하는 것으로, 보다 많은 thread가 <A HREF="../../java/lang/OutOfMemoryError.html" title="java.lang 안의 클래스"><CODE>OutOfMemoryError</CODE></A>  (또는 다른 내부 에러)를 throw 하지 않고 , 병행해 존재하는 것이 가능하게 됩니다. <tt>stackSize</tt> 파라미터의 값과 최대 회귀 심도나 병행 레벨과의 관계는 플랫폼에 따라서 다릅니다. <b>플랫폼에 따라서는,<tt>stackSize</tt> 파라미터의 값이 어떤 영향을 주지 않는 경우가 있습니다. </b>
 
 <p>가상 머신은,<tt>stackSize</tt> 파라미터를 자유롭게 취급해, 지시할 수가 있습니다. 플랫폼에서는 지정된 값이 너무 작은 경우, 가상 머신은 대신에 플랫폼 고유의 최소치를 사용할 수 있습니다.  지정된 값이 너무 큰 경우에는, 가상 머신은 대신에 플랫폼 고유의 최대치를 사용할 수 있습니다. 같이 가상 머신은, 적절한 경우에는 지정된 값의 절상해 또는 인하를 자유롭게 실행 (또는 완전하게 무시)할 수 있습니다.

 <p><tt>stackSize</tt> 파라미터에 값제로를 지정하면(자), 이 생성자 은 <tt>Thread(ThreadGroup, Runnable, String)</tt> 생성자 과 정확하게 같은 동작을 실행합니다.

 <p>이 생성자 의 동작은 플랫폼에 따라서 다르기 위해서(때문에), 신중하게 사용할 필요가 있습니다. 지정된 계산의 실행에 필요한 thread 스택 사이즈는, JRE 구현에 따라서 다를 가능성이 있습니다. 이 때문에, 스택 사이즈 파라미터를 주의 깊게 튜닝 하거나 어플리케이션을 실행하는 JRE 구현 마다 튜닝을 반복하거나 하는 것이 필요한 경우가 있습니다.

 <p>구현상의 주의 :Java 플랫폼 구현자는,<tt>stackSize parameter</tt> 를 기준으로 해 구현의 동작을 문서화해 두는 것을 추천합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>group</CODE> - thread 그룹<DD><CODE>target</CODE> - 그 <code>run</code> 메소드가 불려 가는 객체<DD><CODE>name</CODE> - 새로운 thread의 이름<DD><CODE>stackSize</CODE> - 신규 thread의 스택 사이즈 또는 제로 (이 파라미터를 무시하는 것을 나타낸다)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가, 지정된 thread 그룹내의 thread를 작성할 수 없는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="currentThread()"><!-- --></A> <H3>
currentThread</H3>
<PRE>
public static <A HREF="../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A>  <B>currentThread</B>()</PRE>
<DL>
<DD>현재 실행중의 thread 객체의 참조를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재 실행중의 thread</DL>
</DD>
</DL>
<HR>

<A NAME="yield()"><!-- --></A> <H3>
yield</H3>
<PRE>
public static void <B>yield</B>()</PRE>
<DL>
<DD>현재 실행중의 thread 객체를 일시적으로 휴지시켜, 다른 thread를 실행할 수 있도록(듯이) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sleep(long)"><!-- --></A> <H3>
sleep</H3>
<PRE>
public static void <B>sleep</B>(long&nbsp;millis)
                  throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>시스템 타이머-와 스케쥴러가 정확한 것을 전제로서 현재 실행중의 thread를, 지정된 밀리 세컨드수의 사이, sleeve (일시적으로 실행을 정지) 시킵니다. thread는 모니터의 소유권을 잃지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>millis</CODE> - 밀리 세컨드 단위의 sleeve 시간의 길이
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 어떠한 thread가 현재의 thread에 끼어들었을 경우.
이 예외가 throw 되면(자), 현재의 thread의 「인터럽트 상태」는 클리어 되는<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#notify()"><CODE>Object.notify()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sleep(long, int)"><!-- --></A> <H3>
sleep</H3>
<PRE>
public static void <B>sleep</B>(long&nbsp;millis,
                         int&nbsp;nanos)
                  throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>시스템 타이머-와 스케쥴러가 정확한 것을 전제로서 현재 실행중의 thread를, 지정된 밀리 세컨드수로 지정된 나노초수를 가산한 사이, sleeve (실행을 정지) 시킵니다. thread는 모니터의 소유권을 잃지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>millis</CODE> - 밀리 세컨드 단위의 sleeve 시간의 길이<DD><CODE>nanos</CODE> - sleeve하기 위한 0 ~ 999999 의 추가 나노초
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - millis 의 값이 음수의 경우, 또는 nanos 의 값이 0 ~ 999999 의 범위외의 경우
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 어떠한 thread가 현재의 thread에 끼어들었을 경우.
이 예외가 throw 되면(자), 현재의 thread의 「인터럽트 상태」는 클리어 되는<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#notify()"><CODE>Object.notify()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="start()"><!-- --></A> <H3>
start</H3>
<PRE>
public void <B>start</B>()</PRE>
<DL>
<DD>이 thread의 실행을 개시합니다. Java 가상 머신은, 이 thread의 <code>run</code> 메소드를 호출합니다.  &nbsp;<p>
그 결과, (<code>start</code> 메소드에의 호출로부터 복귀한다) 현재의 thread와 (그 <code>run</code> 메소드를 실행한다) 다른 thread라고 하는 2 개의 thread가 병렬에 실행됩니다.  &nbsp;<p>
thread를 여러 차례 기동하는 것은, 결코 올바르다고는 말할 수 없습니다. 특히, thread는 실행을 끝내고 나서 재기동할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalThreadStateException.html" title="java.lang 안의 클래스">IllegalThreadStateException</A> </CODE> - thread가 벌써 기동하고 있었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="run()"><!-- --></A> <H3>
run</H3>
<PRE>
public void <B>run</B>()</PRE>
<DL>
<DD>이 thread가 별개의 <code>Runnable</code> 실행 객체를 사용해 작성되었을 경우, 그 <code>Runnable</code> 객체의 <code>run</code> 메소드가 불려 갑니다. 그렇지 않은 경우, 이 메소드는 아무것도 실시하지 않고 복귀합니다.  &nbsp;<p>
<code>Thread</code> 의 서브 클래스는, 이 메소드를 오버라이드(override) 하지 않으면 안됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Runnable.html#run()">run</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#start()"><CODE>start()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="stop()"><!-- --></A> <H3>
stop</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public final void <B>stop</B>()</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 메소드는 본질적으로 안전하지는 않습니다. Thread.stop 를 사용해 thread를 정지하면(자), 체크되어 있지 않은 <code>ThreadDeath</code> 예외가 스택아래에서 위에게 전할 수 있었던 결과, 그 thread에 의해 락 되고 있던 모니터의 락이 모두 해제됩니다. 이러한 모니터에 의해 직전까지 보호되고 있던 객체가 무결성의 없는 상태에 있었을 경우, 망가진 객체는 다른 thread에 대해서 가시가 되어, 동작이 보증되지 않는 것이 있습니다. 많은 경우, 타겟 thread의 실행 정지를 지시하려면 ,<code>stop</code> 는 아니고, 단지 일부의 변수를 변경하는 코드를 사용할 필요가 있습니다. 타겟 thread는, 이 변수를 정기적으로 검사해, 실행을 정지해야 할 일을 변수가 가리키고 있는 경우에는, thread의 run 메소드로부터 일반적으로의 방법으로 복귀할 필요가 있습니다. 조건 변수등으로 타겟 thread가 오랫동안 대기하고 있는 경우, 대기를 중단시키려면 ,<code>interrupt</code> 메소드를 사용합니다.  
자세한 것은, 이하를 참조해 주세요.  
<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I>
<P>
<DD>thread에 강제적으로 실행을 정지시킵니다.  &nbsp;<p>
시큐리티 매니저가 인스톨 되고 있는 경우,<code>this</code> 를 인수로서 시큐리티 매니저의 <code>checkAccess</code> 메소드가 불려 갑니다. 이 결과, 현재의 thread로 <code>SecurityException</code> 가 throw 되는 일이 있습니다.  &nbsp;<p>
또, 이 thread가 현재의 thread와 다른 경우, 즉, 현재의 thread가 자신 이외의 thread를 정지하려고 하고 있는 경우는,<code>RuntimePermission("stopThread")</code> 를 인수로서 시큐리티 매니저의 <code>checkPermission</code> 메소드도 불려 갑니다. 이 경우에도, 현재의 thread로 <code>SecurityException</code> 가 throw 되는 일이 있습니다.  &nbsp;<p>
이 thread에 의해 나타내지는 thread는, 그것이 실행하고 있던 동작에 관계없이 강제적으로 이상 정지 당해 새롭게 생성한 <code>ThreadDeath</code> 객체를 예외로서 throw 합니다.  &nbsp;<p>
아직 기동되어 있지 않은 thread를 정지할 수가 있습니다. thread가 최종적으로 기동되자, 곧바로 종료합니다.  &nbsp;<p>
어플리케이션은, 일반적으로과는 다른 클린 업 동작을 실행해야 하는 경우를 제외해,<code>ThreadDeath</code> 를 캐치 해야 하지는 않습니다.  다만,<code>ThreadDeath</code> 를 throw 하면(자), thread가 정식으로 종료하기 전에 <code>try</code> 문의 <code>finally</code> 절이 실행되는 것에 주의해 주세요. <code>catch</code> 절이 <code>ThreadDeath</code> 객체를 캐치 하는 경우는, thread가 실제로 종료하도록(듯이) 객체를 throw 다시 하는 것이 중요합니다.  &nbsp;<p>
그렇지 않은 경우, 캐치되어 있지 않은 예외를 취급하는 최고 레벨의 에러 핸들러는, 캐치되어 있지 않은 예외가 <code>ThreadDeath</code> 의 인스턴스이면, 메세지를 출력하거나 어플리케이션에 통지하거나 하는 것은 하지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#interrupt()"><CODE>interrupt()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#start()"><CODE>start()</CODE></A> , 
<A HREF="../../java/lang/ThreadDeath.html" title="java.lang 안의 클래스"><CODE>ThreadDeath</CODE></A> , 
<A HREF="../../java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread, java.lang.Throwable)"><CODE>ThreadGroup.uncaughtException(Thread, Throwable)</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.Thread)"><CODE>SecurityManager.checkAccess(Thread)</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="stop(java.lang.Throwable)"><!-- --></A> <H3>
stop</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public final void <B>stop</B>(<A HREF="../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;obj)</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 메소드는 본질적으로 안전하지는 않습니다. <A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A>  를 참조해 주세요.
게다가 이 메소드는, 타겟 thread로 처리의 준비가 되어 있지 않은 예외의 생성에 사용되는 일이 있는 점에서도 위험합니다 (이 메소드가 없으면 thread에 의해 throw 될리가 없는, 체크된 예외 등).
자세한 것은, 이하를 참조해 주세요.  
<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I>
<P>
<DD>thread에 강제적으로 실행을 정지시킵니다.  &nbsp;<p>
시큐리티 매니저가 인스톨 되고 있는 경우, 시큐리티 매니저의 <code>checkAccess</code> 메소드가 불려 갑니다. 이 결과, 현재의 thread로 <code>SecurityException</code> 가 throw 되는 일이 있습니다.  &nbsp;<p>
또, 이 thread가 현재의 thread와 다른 경우, 즉, 현재의 thread가 자신 이외의 thread를 정지하려고 하고 있는 경우, 또는 <code>obj</code> 가 <code>ThreadDeath</code> 의 인스턴스가 아닌 경우는,<code>RuntimePermission("stopThread")</code> 를 인수로서 시큐리티 매니저의 <code>checkPermission</code> 메소드가 불려 갑니다. 이 경우에도, 현재의 thread로 <code>SecurityException</code> 가 throw 되는 일이 있습니다.  &nbsp;<p>
인수 <code>obj</code> 가 null 의 경우,<code>NullPointerException</code> 가 (현재의 thread내에서) throw 됩니다.  &nbsp;<p>
이 thread에 의해 나타내지는 thread는, 그것이 실행하는 동작에는 관계없이 강제적으로 종료되어 예외로서 <code>Throwable</code> 객체 <code>obj</code> 가 throw 됩니다. 이것은 일반적으로에서는 행해지지 않는 동작이기 (위해)때문에, 일반적으로은 인수를 설정하지 않는 <code>stop</code> 메소드를 사용해 주세요.  &nbsp;<p>
아직 기동되어 있지 않은 thread를 정지할 수가 있습니다. thread가 최종적으로 기동되자, 곧바로 종료합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - throw 대상의 Throwable 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - obj 가 <tt>null</tt> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#interrupt()"><CODE>interrupt()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#start()"><CODE>start()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.Thread)"><CODE>SecurityManager.checkAccess(Thread)</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="interrupt()"><!-- --></A> <H3>
interrupt</H3>
<PRE>
public void <B>interrupt</B>()</PRE>
<DL>
<DD>이 thread에 끼어듭니다.
 
 <p> 현재의 thread가 자신에게 끼어들지 않은 한 (이 인터럽트는 허가된다), 이 thread의 <A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess</CODE></A>  메소드가 불려 갑니다.

 <p> 이 메소드에 의해,<A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스"><CODE>SecurityException</CODE></A>  가 throw 되는 경우가 있습니다.  <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스"><CODE>Object</CODE></A>  클래스의 <A HREF="../../java/lang/Object.html#wait()"><CODE>wait()</CODE></A> ,<A HREF="../../java/lang/Object.html#wait(long)"><CODE>wait(long)</CODE></A> , 또는 <A HREF="../../java/lang/Object.html#wait(long, int)"><CODE>wait(long, int)</CODE></A>  메소드의 호출해, 또는 이 클래스의 <A HREF="../../java/lang/Thread.html#join()"><CODE>join()</CODE></A> ,<A HREF="../../java/lang/Thread.html#join(long)"><CODE>join(long)</CODE></A> ,<A HREF="../../java/lang/Thread.html#join(long, int)"><CODE>join(long, int)</CODE></A> ,<A HREF="../../java/lang/Thread.html#sleep(long)"><CODE>sleep(long)</CODE></A> , 또는 <A HREF="../../java/lang/Thread.html#sleep(long, int)"><CODE>sleep(long, int)</CODE></A>  메소드의 호출로 이 thread가 블록 되는 경우, 인터럽트 상태는 클리어 되어<A HREF="../../java/lang/InterruptedException.html" title="java.lang 동안의 클래스"><CODE>InterruptedException</CODE></A>  를 받습니다.

 <p> <A HREF="../../java/nio/channels/InterruptibleChannel.html" title="java.nio.channels 안의 인터페이스"><CODE><code>interruptible channel</code></CODE></A>  에 대한 I/O 조작으로 이 thread가 블록 되는 경우, 채널은 닫혀져 thread의 인터럽트 상태가 설정됩니다.  또, thread는 <A HREF="../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스"><CODE>ClosedByInterruptException</CODE></A>  를 받습니다.

 <p> <A HREF="../../java/nio/channels/Selector.html" title="java.nio.channels 안의 클래스"><CODE>Selector</CODE></A>  로 이 thread가 블록 되는 경우, thread의 인터럽트 상태가 설정되어, 선택 조작으로부터 즉석에서 돌려주어집니다.  일반적으로, 반환되는 값은, 셀렉터의 <A HREF="../../java/nio/channels/Selector.html#wakeup()"><CODE>wakeup</CODE></A>  메소드가 불려 갔을 경우와 같이, 제로 이외의 값이 됩니다.

 <p> 전술의 조건의 어느 것에도 들어맞지 않는 경우, 이 thread의 인터럽트 상태가 설정됩니다.  </p>

 <p> 생존하고 있지 않는 thread가 인터럽트를 받는 것이, 효과를 가질 필요가 없는 경우
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="interrupted()"><!-- --></A> <H3>
interrupted</H3>
<PRE>
public static boolean <B>interrupted</B>()</PRE>
<DL>
<DD>현재의 thread가 끼어들어지고 있는지 어떤지를 조사합니다. 이 메소드에 의해 thread의 「인터럽트 상태」가 클리어 됩니다. 즉, 이 메소드가 계속해 2 회 불려 갔을 경우, 2 번째의 호출은 false 를 돌려줍니다 (최초의 호출이 끼어들어 상태를 클리어 한 후에, 2 번째의 호출이 그것을 확인하기 전에 현재의 thread가 한번 더 끼어들어졌을 경우를 제외하다).

 <p>thread가 인터럽트의 시점에서 생존하고 있지 않았기(위해)때문에 무시된 thread에서의 인터럽트는, 이 메소드에 의해 반영되어 false 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 thread가 끼어들어지고 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#isInterrupted()"><CODE>isInterrupted()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isInterrupted()"><!-- --></A> <H3>
isInterrupted</H3>
<PRE>
public boolean <B>isInterrupted</B>()</PRE>
<DL>
<DD>이 thread가 끼어들어지고 있는 제발을 조사합니다. 이 메소드에 의해 thread의 「인터럽트 상태」가 영향을 받을 것은 없습니다.

 <p>thread가 인터럽트의 시점에서 생존하고 있지 않았기(위해)때문에 무시된 thread에서의 인터럽트는, 이 메소드에 의해 반영되어 false 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread가 끼어들어지고 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#interrupted()"><CODE>interrupted()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="destroy()"><!-- --></A> <H3>
destroy</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public void <B>destroy</B>()</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 메소드는 원래 클린 업없이 파기되도록(듯이) 설계되고 있었습니다.
보관 유지되는 모니터는 락 된 상태를 유지합니다.
다만, 이 메소드는 구현되지 않았습니다.
구현되고 있으면(자),<A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>  와 거의 똑같이 데드락이 발생합니다.
타겟 thread가 중요한 system resource를 보호하는 락을 보관 유지한 상태로 파기되었을 경우, 어느 thread도 다시 이 자원에 액세스 할 수 없습니다.
다른 thread가 이 자원을 잠그려고 하면(자), 데드락이 발생합니다. 일반적으로, 이러한 데드락은, 프로세스의 「동결」에 의해 밝혀집니다. 자세한 것은, 이하를 참조해 주세요.
<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I>
<P>
<DD><A HREF="../../java/lang/NoSuchMethodError.html" title="java.lang 안의 클래스"><CODE>NoSuchMethodError</CODE></A>  를 throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NoSuchMethodError.html" title="java.lang 안의 클래스">NoSuchMethodError</A> </CODE> - always</DL>
</DD>
</DL>
<HR>

<A NAME="isAlive()"><!-- --></A> <H3>
isAlive</H3>
<PRE>
public final boolean <B>isAlive</B>()</PRE>
<DL>
<DD>이 thread가 생존하고 있을지 어떨지를 판정합니다. 지정된 ID 의 thread가 기동되어 생존하고 있는 경우, thread는 생존하고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread가 생존하고 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="suspend()"><!-- --></A> <H3>
suspend</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public final void <B>suspend</B>()</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 메소드는 데드락을 발생하기 쉽기 때문에 추천 되지 않습니다.
타겟 thread가, 중단되는 시점에서, 중요한 system resource를 보호하는 모니터를 잠그고 있는 경우, 타겟 thread가 재개될 때까지 어느 thread도 그 자원에 액세스 할 수 없습니다. 이 때, 타겟 thread를 재개하는 thread가,<code>resume</code> 를 호출하기 전에 이 모니터를 잠그려고 하면(자), 데드락이 발생합니다. 일반적으로, 이러한 데드락은, 프로세스의 「동결」에 의해 밝혀집니다.
자세한 것은, 이하를 참조해 주세요.  
<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I>
<P>
<DD>이 thread를 중단합니다.  &nbsp;<p>
우선, 이 thread의 <code>checkAccess</code> 메소드가, 인수없이 불려 갑니다. 이 결과, 현재의 thread로 <code>SecurityException </code> 가 throw 되는 일이 있습니다.  &nbsp;<p>
thread는, 생존하고 있는 경우에 중단되어 재개되지 않는 처리를 먼저 진행할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="resume()"><!-- --></A> <H3>
resume</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public final void <B>resume</B>()</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 메소드는 데드락을 발생하기 쉽기 때문에 추천 되지 않습니다.  <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>  와 함께 사용하기 위해(때문에)인 만큼 제공되고 있습니다.

자세한 것은, 이하를 참조해 주세요.  
<a href="../../../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I>
<P>
<DD>중단된 thread를 재개합니다.  &nbsp;<p>
우선, 이 thread의 <code>checkAccess</code> 메소드가, 인수없이 불려 갑니다. 이 결과, 현재의 thread로 <code>SecurityException </code> 가 throw 되는 일이 있습니다.  &nbsp;<p>
thread는, 생존하고 있지만 중단되고 있는 경우, 실행이 재개되어 처리를 먼저 진행하는 것이 허가됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPriority(int)"><!-- --></A> <H3>
setPriority</H3>
<PRE>
public final void <B>setPriority</B>(int&nbsp;newPriority)</PRE>
<DL>
<DD>이 thread의 우선 순위를 변경합니다.  &nbsp;<p>
우선, 이 thread의 <code>checkAccess</code> 메소드가, 인수없이 불려 갑니다. 그 결과,<code>SecurityException</code> 가 throw 되는 일이 있습니다.  &nbsp;<p>
그렇지 않은 경우, 이 thread의 우선 순위는, 지정된 <code>newPriority</code> 와 thread의 thread 그룹의 최고 허용 우선 순위 중의 어느 쪽인지 작은 (분)편으로 설정됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newPriority</CODE> - 이 thread를 설정하는 우선 순위
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 우선 순위가 <code>MIN_PRIORITY</code> ~ <code>MAX_PRIORITY</code> 의 범위외인 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#getPriority()"><CODE>getPriority()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#getThreadGroup()"><CODE>getThreadGroup()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#MAX_PRIORITY"><CODE>MAX_PRIORITY</CODE></A> , 
<A HREF="../../java/lang/Thread.html#MIN_PRIORITY"><CODE>MIN_PRIORITY</CODE></A> , 
<A HREF="../../java/lang/ThreadGroup.html#getMaxPriority()"><CODE>ThreadGroup.getMaxPriority()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPriority()"><!-- --></A> <H3>
getPriority</H3>
<PRE>
public final int <B>getPriority</B>()</PRE>
<DL>
<DD>이 thread의 우선 순위를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread의 우선 순위<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setPriority(int)"><CODE>setPriority(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setName(java.lang.String)"><!-- --></A> <H3>
setName</H3>
<PRE>
public final void <B>setName</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>이 thread의 이름을 인수 <code>name</code> 에 동일해지도록(듯이) 변경합니다.  &nbsp;<p>
우선, 이 thread의 <code>checkAccess</code> 메소드가, 인수없이 불려 갑니다. 그 결과,<code>SecurityException</code> 가 throw 되는 일이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 이 thread의 새로운 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#getName()"><CODE>getName()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getName()"><!-- --></A> <H3>
getName</H3>
<PRE>
public final <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getName</B>()</PRE>
<DL>
<DD>이 thread의 이름을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread의 이름<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setName(java.lang.String)"><CODE>setName(String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getThreadGroup()"><!-- --></A> <H3>
getThreadGroup</H3>
<PRE>
public final <A HREF="../../java/lang/ThreadGroup.html" title="java.lang 내의 클래스">ThreadGroup</A>  <B>getThreadGroup</B>()</PRE>
<DL>
<DD>이 thread가 소속하는 thread 그룹을 돌려줍니다. 이 thread가 종료되고 있는 (정지되고 있다) 경우, 이 메소드는 null 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread의 thread 그룹</DL>
</DD>
</DL>
<HR>

<A NAME="activeCount()"><!-- --></A> <H3>
activeCount</H3>
<PRE>
public static int <B>activeCount</B>()</PRE>
<DL>
<DD>현행 thread의 thread 그룹내의 액티브한 thread수를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현행 thread의 thread 그룹내의 액티브한 thread수</DL>
</DD>
</DL>
<HR>

<A NAME="enumerate(java.lang.Thread[])"><!-- --></A> <H3>
enumerate</H3>
<PRE>
public static int <B>enumerate</B>(<A HREF="../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> []&nbsp;tarray)</PRE>
<DL>
<DD>현행 thread의 thread 그룹 및 그 하위 그룹내의 모든 액티브한 thread를, 지정된 배열에 카피합니다. 이 메소드는, 현행 thread의 thread 그룹의 <code>enumerate</code> 메소드를, 배열 인수를 지정해 호출할 뿐입니다.  &nbsp;<p>
시큐리티 매니저가 존재하는 경우,<code>enumerate</code> 메소드는, thread 그룹을 인수로서 시큐리티 매니저의 <code>checkAccess</code> 메소드를 호출합니다. 그 결과,<code>SecurityException</code> 가 throw 되는 일이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tarray</CODE> - Thread 객체의 카피처 배열
<DT><B>반환값:</B><DD>배열에 포함되는 thread수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 시큐리티 매니저의 <code>checkAccess</code> 메소드가 이 조작을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/ThreadGroup.html#enumerate(java.lang.Thread[])"><CODE>ThreadGroup.enumerate(Thread[])</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.ThreadGroup)"><CODE>SecurityManager.checkAccess(ThreadGroup)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="countStackFrames()"><!-- --></A> <H3>
countStackFrames</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public int <B>countStackFrames</B>()</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>이 호출의 정의는, 추천되어 있지 않은 <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>  에 의존합니다.
또, 이 호출의 결과는 보증되지 않습니다. </I>
<P>
<DD>이 thread내의 스택 프레임수를 카운트 합니다. thread는 중단될 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread내의 스택 프레임의 수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalThreadStateException.html" title="java.lang 안의 클래스">IllegalThreadStateException</A> </CODE> - 이 thread가 중단되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="join(long)"><!-- --></A> <H3>
join</H3>
<PRE>
public final void <B>join</B>(long&nbsp;millis)
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>이 thread가 종료하는 것을, 최고로 <code>millis</code> 밀리 세컨드 대기합니다. <code></code> 의 타임 아웃은 영원히 대기하는 것을 의미합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>millis</CODE> - 밀리 세컨드 단위의 대기 시간
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 어떠한 thread가 현재의 thread에 끼어들었을 경우.
이 예외가 throw 되면(자), 현재의 thread의 「인터럽트 상태」는 클리어 된다</DL>
</DD>
</DL>
<HR>

<A NAME="join(long, int)"><!-- --></A> <H3>
join</H3>
<PRE>
public final void <B>join</B>(long&nbsp;millis,
                       int&nbsp;nanos)
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>최고로 <code>millis</code> 밀리 세컨드에 <code>nanos</code> 나노초를 가산한 사이, 이 thread가 종료하는 것을 대기합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>millis</CODE> - 밀리 세컨드 단위의 대기 시간<DD><CODE>nanos</CODE> - 대기하기 위한 0 ~ 999999 의 추가 나노초
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - millis 의 값이 음수의 경우, 또는 nanos 의 값이 0 ~ 999999 의 범위외의 경우
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 어떠한 thread가 현재의 thread에 끼어들었을 경우.
이 예외가 throw 되면(자), 현재의 thread의 「인터럽트 상태」는 클리어 된다</DL>
</DD>
</DL>
<HR>

<A NAME="join()"><!-- --></A> <H3>
join</H3>
<PRE>
public final void <B>join</B>()
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>이 thread가 종료하는 것을 대기합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 어떠한 thread가 현재의 thread에 끼어들었을 경우.
이 예외가 throw 되면(자), 현재의 thread의 「인터럽트 상태」는 클리어 된다</DL>
</DD>
</DL>
<HR>

<A NAME="dumpStack()"><!-- --></A> <H3>
dumpStack</H3>
<PRE>
public static void <B>dumpStack</B>()</PRE>
<DL>
<DD>현재의 thread의 스택 트레이스를 표준 에러 스트림에 출력합니다. 이 메소드는 디버그의 경우에만 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Throwable.html#printStackTrace()"><CODE>Throwable.printStackTrace()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDaemon(boolean)"><!-- --></A> <H3>
setDaemon</H3>
<PRE>
public final void <B>setDaemon</B>(boolean&nbsp;on)</PRE>
<DL>
<DD>이 thread를, demon thread 또는 사용자 thread로서 마크 합니다. Java 가상 머신은, 실행중의 thread가 demon thread만으로 되면(자) 종료합니다.  &nbsp;<p>
이 메소드는, thread 기동전에 호출할 필요가 있습니다.  &nbsp;<p>
이 메소드는, 인수없이 이 thread의 <code>checkAccess</code> 메소드를 호출합니다. 이 결과, 현재의 thread로 <code>SecurityException </code> 가 throw 되는 일이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>on</CODE> - <code>true</code> 의 경우, 이 thread를 demon thread로서 마크 한다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalThreadStateException.html" title="java.lang 안의 클래스">IllegalThreadStateException</A> </CODE> - 이 thread가 액티브한 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#isDaemon()"><CODE>isDaemon()</CODE></A> , 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isDaemon()"><!-- --></A> <H3>
isDaemon</H3>
<PRE>
public final boolean <B>isDaemon</B>()</PRE>
<DL>
<DD>이 thread가 demon thread일지 어떨지를 판정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread가 demon thread인 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setDaemon(boolean)"><CODE>setDaemon(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="checkAccess()"><!-- --></A> <H3>
checkAccess</H3>
<PRE>
public final void <B>checkAccess</B>()</PRE>
<DL>
<DD>현재 실행중의 thread가, 이 thread를 변경하기 위한 액세스권을 가지고 있을지 어떨지를 판정합니다.  &nbsp;<p>
시큐리티 매니저가 존재하는 경우, 이 thread가 그 인수로 지정되어 <code>checkAccess</code> 메소드가 불려 갑니다. 그 결과,<code>SecurityException</code> 가 throw 되는 일이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread에의 액세스가 용서되지 않은 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.Thread)"><CODE>SecurityManager.checkAccess(Thread)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>thread의 이름, 우선 순위, thread 그룹을 포함한 이 thread의 캐릭터 라인 표현을 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread의 캐릭터 라인 표현</DL>
</DD>
</DL>
<HR>

<A NAME="getContextClassLoader()"><!-- --></A> <H3>
getContextClassLoader</H3>
<PRE>
public <A HREF="../../java/lang/ClassLoader.html" title="java.lang 내의 클래스">ClassLoader</A>  <B>getContextClassLoader</B>()</PRE>
<DL>
<DD>이 Thread 의 문맥 ClassLoader 를 돌려줍니다. 문맥 ClassLoader 는, 클래스 및 자원을 로드할 때, 이 thread로 실행중의 코드가 사용하기 위해서 thread의 작성 측에야는 제공됩니다. 문맥 ClassLoader 가 설정되어 있지 않은 경우, 디폴트에서는 친 Thread 의 ClassLoader 문맥이 됩니다. 일반적으로, 친thread의 문맥 ClassLoader 는, 어플리케이션의 로드에 사용되는 클래스 로더로 설정됩니다.

 <p>시큐리티 매니저가 존재하는 경우, 호출측의 클래스 로더가 null 는 아니고, 문맥 클래스 로더가 요구되고 있는 thread의 문맥 클래스 로더와 같지 않고, 그 문맥 클래스 로더의 상위 객체도 아닐 때는, 문맥 ClassLoader 를 취득해도 괜찮은지 어떤지를 확인하기 위해서,<code>RuntimePermission("getClassLoader")</code> 액세스권을 사용해, 시큐리티 매니저의 <code>checkPermission</code> 메소드가 불려 갑니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 Thread 의 문맥 ClassLoader
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 시큐리티 매니저의 <code>checkPermission</code> 메소드가 문맥 ClassLoader 의 취득을 허가하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setContextClassLoader(java.lang.ClassLoader)"><CODE>setContextClassLoader(java.lang.ClassLoader)</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> , 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setContextClassLoader(java.lang.ClassLoader)"><!-- --></A> <H3>
setContextClassLoader</H3>
<PRE>
public void <B>setContextClassLoader</B>(<A HREF="../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;cl)</PRE>
<DL>
<DD>이 Thread 의 문맥 ClassLoader 를 설정합니다. 문맥 ClassLoader 는 thread의 작성시로 설정되어 이것에 의해 thread의 작성측은, 클래스 및 자원의 로드시에 thread로 실행중의 코드에 적절한 클래스 로더를 제공할 수 있게 됩니다.

 <p>시큐리티 매니저가 존재하는 경우, 최초로, 문맥 ClassLoader 를 설정해도 좋은지 어떤지를 조사하기 위해서(때문에) <code>RuntimePermission("setContextClassLoader")</code> 액세스권을 사용해 <code>checkPermission</code> 메소드가 불려 갑니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cl</CODE> - 이 Thread 의 문맥 ClassLoader
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 문맥 ClassLoader 를 설정할 수 없는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#getContextClassLoader()"><CODE>getContextClassLoader()</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> , 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="holdsLock(java.lang.Object)"><!-- --></A> <H3>
holdsLock</H3>
<PRE>
public static boolean <B>holdsLock</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>현행 thread가 지정된 객체에 대한 모니터 락을 보관 유지하는 경우에게만,<tt>true</tt> 를 돌려줍니다.

 <p>이 메소드는, 이하와 같이, 프로그램이, 현행 thread가 지정된 락을 벌써 보관 유지하고 있는 것을 나타낼 때에 사용됩니다.
 <pre>
assert Thread.holdsLock(obj);
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 소유권의 락을 테스트하는 객체
<DT><B>반환값:</B><DD>현행 thread가 지정된 객체에 대한 모니터 락을 보관 유지하는 경우,<tt>true</tt> 가 반환된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - obj 가 <tt>null</tt> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getStackTrace()"><!-- --></A> <H3>
getStackTrace</H3>
<PRE>
public <A HREF="../../java/lang/StackTraceElement.html" title="java.lang 내의 클래스">StackTraceElement</A> [] <B>getStackTrace</B>()</PRE>
<DL>
<DD>이 thread의 스택 덤프를 나타내는 스택 트레이스 요소의 배열을 돌려줍니다. 이 thread가 기동하고 있지 않았던 경우나 종료하고 있었을 경우, 이 메소드는 제로의 길이의 배열을 돌려줍니다. 반환된 배열이 제로 이외의 길이의 배열인 경우, 배열의 최초의 요소는 스택의 최상부를 나타냅니다.  이것은 순서로 불려 간 가장 새로운 메소드입니다. 배열의 마지막 요소는, 스택의 저부를 나타냅니다.  이것은 순서로 불려 간 가장 낡은 메소드입니다.

 <p>이것은 순서로 불려 간 가장 낡은 메소드입니다.  시큐리티 매니저가 존재해, 이 thread가 현재의 thread가 아닌 경우, 스택 트레이스를 취득해도 좋은지 어떤지를 조사하기 위해서(때문에),<tt>RuntimePermission("getStackTrace")</tt> 액세스권을 사용해 시큐리티 매니저의 <tt>checkPermission</tt> 메소드가 불려 갑니다.  

 <p>가상 머신안에는, 특정의 상황하로 스택 트레이스로부터 1 개 이상의 스택 프레임을 생략 하는 것이 있습니다. 극단적인 경우, 이 thread에 관한 스택 트레이스 정보를 가지지 않는 가상 머신이, 이 메소드로부터 길이 제로의 배열을 돌려주는 것이 허가됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>1 개의 스택 프레임을 나타내는 <tt>StackTraceElement</tt> 의 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 시큐리티 매니저의 <tt>checkPermission</tt> 메소드가 thread의 스택 트레이스의 취득을 허가하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> , 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A> , 
<A HREF="../../java/lang/Throwable.html#getStackTrace()"><CODE>Throwable.getStackTrace()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAllStackTraces()"><!-- --></A> <H3>
getAllStackTraces</H3>
<PRE>
public static <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;<A HREF="../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> ,<A HREF="../../java/lang/StackTraceElement.html" title="java.lang 안의 클래스">StackTraceElement</A> []&gt; <B>getAllStackTraces</B>()</PRE>
<DL>
<DD>모든 라이브 thread의 스택 트레이스 맵을 돌려줍니다. 맵 키는 thread입니다.  또, 각 맵의 값은 대응하는 <tt>Thread</tt> 의 스택 덤프를 나타내는 <tt>StackTraceElement</tt> 의 배열입니다. 반환된 스택 트레이스는,<A HREF="../../java/lang/Thread.html#getStackTrace()"><CODE>getStackTrace</CODE></A>  메소드에 대해서 지정된 포맷입니다.

 <p>이 메소드가 불려 가고 있는 동안에, thread가 실행되고 있을 가능성이 있습니다. 각 thread의 스택 트레이스는, snapshot를 나타낼 뿐입니다.  각 스택 트레이스는 다른 시기에 취득할 수 있습니다. 가상 머신이 thread에 관한 스택 트레이스 정보를 가지지 않는 경우, 맵치에 길이 제로의 배열이 돌려주어집니다.

 <p>시큐리티 매니저가 존재해, 이 thread가 현재의 thread가 아닌 경우, 모든 thread의 스택 트레이스를 취득해도 좋은지 어떤지를 조사하기 위해서(때문에),<tt>RuntimePermission("getStackTrace")</tt> 액세스권과 <tt>RuntimePermission("modifyThreadGroup")</tt> 액세스권을 사용해 시큐리티 매니저의 <tt>checkPermission</tt> 메소드가 불려 갑니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><tt>Thread</tt> 로부터, 대응하는 thread의 스택 트레이스를 나타내는 <tt>StackTraceElement</tt> 의 배열까지의 <tt>Map</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 시큐리티 매니저의 <tt>checkPermission</tt> 메소드가 thread의 스택 트레이스의 취득을 허가하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#getStackTrace()"><CODE>getStackTrace()</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> , 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A> , 
<A HREF="../../java/lang/Throwable.html#getStackTrace()"><CODE>Throwable.getStackTrace()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getId()"><!-- --></A> <H3>
getId</H3>
<PRE>
public long <B>getId</B>()</PRE>
<DL>
<DD>이 thread의 식별자를 돌려줍니다. thread ID 는, thread가 작성되었을 때에 생성된 정의 <tt>long</tt> 형의 숫자입니다. thread ID 는 일의이며, 그 수명을 통해서 변경될 것은 없습니다. thread가 종료하면(자), thread ID 는 재사용 가능합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread의 ID<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getState()"><!-- --></A> <H3>
getState</H3>
<PRE>
public <A HREF="../../java/lang/Thread.State.html" title="java.lang 내의 열거형">Thread.State</A>  <B>getState</B>()</PRE>
<DL>
<DD>이 thread 상태를 돌려줍니다. 이 메소드는, 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread 상태<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><!-- --></A> <H3>
setDefaultUncaughtExceptionHandler</H3>
<PRE>
public static void <B>setDefaultUncaughtExceptionHandler</B>(<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 안의 인터페이스">Thread.UncaughtExceptionHandler</A> &nbsp;eh)</PRE>
<DL>
<DD>캐치 되지 않는 예외에 의해, thread가 돌연 종료했을 때나, 이 thread에 대해서 그 밖에 핸들러가 정의되어 있지 않을 때에 불려 가는 디폴트의 핸들러를 설정합니다.  

 <p>캐치 되지 않는 예외의 취급은 thread에 의해 우선 제어되어 다음에 thread <A HREF="../../java/lang/ThreadGroup.html" title="java.lang 중의 클래스"><CODE>ThreadGroup</CODE></A>  객체에 의해, 최종적으로는 디폴트의 캐치 되지 않는 예외 핸들러에 의해 제어됩니다. thread가 명시적인 캐치 되지 않는 예외 핸들러 세트를 가지지 않는 경우, thread의 thread 그룹 (친thread 그룹을 포함한다)은,<tt>uncaughtException</tt> 메소드를 특수화 하지 않습니다.  다음에, 디폴트 핸들러의 <tt>uncaughtException</tt> 메소드가 불려 갑니다. &nbsp;<p>디폴트의 캐치 되지 않는 예외 핸들러를 설정하는 것으로, 어플리케이션에서는, 시스템으로 제공된 「디폴트」의 동작을 벌써 받아들이고 있는 thread의 캐치 되지 않는 예외를 취급하는 방법 (특정의 디바이스나 파일에의 로그인등)을 변경할 수 있습니다.

 <p>일반적으로, 디폴트의 캐치 되지 않는 예외 핸들러는, thread의 <tt>ThreadGroup</tt> 객체와 달라서는 안됩니다.  이것은, 무한의 재귀를 부를 가능성이 있기 때문입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>eh</CODE> - 디폴트의 캐치 되지 않는 예외 핸들러로서 사용하는 객체. <tt>
null</tt> 의 경우, 디폴트의 핸들러는 없다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해,<tt><A HREF="../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A>  (&quot;setDefaultUncaughtExceptionHandler&quot;)</tt> 를 거부했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><CODE>setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)</CODE></A> , 
<A HREF="../../java/lang/Thread.html#getUncaughtExceptionHandler()"><CODE>getUncaughtExceptionHandler()</CODE></A> , 
<A HREF="../../java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread, java.lang.Throwable)"><CODE>ThreadGroup.uncaughtException(java.lang.Thread, java.lang.Throwable)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultUncaughtExceptionHandler()"><!-- --></A> <H3>
getDefaultUncaughtExceptionHandler</H3>
<PRE>
public static <A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 내의 인터페이스">Thread.UncaughtExceptionHandler</A>  <B>getDefaultUncaughtExceptionHandler</B>()</PRE>
<DL>
<DD>캐치 되지 않는 예외에 의해 thread가 돌연 종료했을 때에 불려 가는 디폴트의 핸들러를 돌려줍니다. 반환값이 <tt>null</tt> 의 경우, 디폴트의 핸들러는 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><CODE>setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getUncaughtExceptionHandler()"><!-- --></A> <H3>
getUncaughtExceptionHandler</H3>
<PRE>
public <A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 내의 인터페이스">Thread.UncaughtExceptionHandler</A>  <B>getUncaughtExceptionHandler</B>()</PRE>
<DL>
<DD>캐치 되지 않는 예외에 의해 thread가 돌연 종료했을 때에 불려 가는 핸들러를 돌려줍니다. 이 thread가 명시적으로 설정된 캐치 되지 않는 예외 핸들러를 가지지 않는 경우, thread가 종료하지 않는 한, thread의 <tt>ThreadGroup</tt> 객체가 돌려주어집니다.  이 경우,<tt>null</tt> 가 돌려주어집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><!-- --></A> <H3>
setUncaughtExceptionHandler</H3>
<PRE>
public void <B>setUncaughtExceptionHandler</B>(<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 안의 인터페이스">Thread.UncaughtExceptionHandler</A> &nbsp;eh)</PRE>
<DL>
<DD>캐치 되지 않는 예외에 의해, 돌연 thread가 종료했을 때에 사용되는 핸들러를 설정합니다. &nbsp;<p>캐치 되지 않는 예외 핸들러를 명시적으로 설정하는 것으로, thread는 캐치 되지 않는 예외를 완전하게 제어할 수 있습니다. 이러한 핸들러가 설정되어 있지 않은 경우는, thread의 <tt>ThreadGroup</tt> 객체가 핸들러로서 기능합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>eh</CODE> - thread의 캐치 되지 않는 예외 핸들러로서 사용되는 객체.
<tt>null</tt> 의 경우, thread는 명시적인 핸들러를 가지지 않는다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread의 변경이 용서되지 않은 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><CODE>setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)</CODE></A> , 
<A HREF="../../java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread, java.lang.Throwable)"><CODE>ThreadGroup.uncaughtException(java.lang.Thread, java.lang.Throwable)</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Thread.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/System.html" title="java.lang 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/Thread.State.html" title="java.lang 내의 열거형"><B>차의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Thread.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Thread.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
