<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:57:44 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
FileChannel (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="FileChannel (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/FileChannel.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/nio/channels/DatagramChannel.html" title="java.nio.channels 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/nio/channels/FileChannel.MapMode.html" title="java.nio.channels 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/nio/channels/FileChannel.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="FileChannel.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.nio.channels</FONT>
<BR>
클래스 FileChannel</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html" title="java.nio.channels.spi 내의 클래스">java.nio.channels.spi.AbstractInterruptibleChannel</A> 
      <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.nio.channels.FileChannel</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/io/Closeable.html" title="java.io 내의 인터페이스">Closeable</A> , <A HREF="../../../java/nio/channels/ByteChannel.html" title="java.nio.channels 안의 인터페이스">ByteChannel</A> , <A HREF="../../../java/nio/channels/Channel.html" title="java.nio.channels 안의 인터페이스">Channel</A> , <A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 안의 인터페이스">GatheringByteChannel</A> , <A HREF="../../../java/nio/channels/InterruptibleChannel.html" title="java.nio.channels 안의 인터페이스">InterruptibleChannel</A> , <A HREF="../../../java/nio/channels/ReadableByteChannel.html" title="java.nio.channels 안의 인터페이스">ReadableByteChannel</A> , <A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 안의 인터페이스">ScatteringByteChannel</A> , <A HREF="../../../java/nio/channels/WritableByteChannel.html" title="java.nio.channels 안의 인터페이스">WritableByteChannel</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>FileChannel</B><DT>extends <A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html" title="java.nio.channels.spi 내의 클래스">AbstractInterruptibleChannel</A> <DT>implements <A HREF="../../../java/nio/channels/ByteChannel.html" title="java.nio.channels 내의 인터페이스">ByteChannel</A> , <A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 안의 인터페이스">GatheringByteChannel</A> , <A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 안의 인터페이스">ScatteringByteChannel</A> </DL>
</PRE>

<P>
파일의 읽어들여, 기입해, 매핑, 조작용 채널입니다.

 <p> 파일 채널은, 파일내에,<A HREF="../../../java/nio/channels/FileChannel.html#position()"><CODE><code>조회</code></CODE></A>  및 <A HREF="../../../java/nio/channels/FileChannel.html#position(long)"><CODE><code>변경</code></CODE></A>  이 가능한 현재의 「위치」를 가지고 있습니다. 파일 자체에는, read/기입과 현재의 <A HREF="../../../java/nio/channels/FileChannel.html#size()"><CODE>사이즈</CODE></A>  의 조회가 가능한 가변 길이의 바이트 순서가 포함되어 있습니다. 파일의 사이즈는, 현재의 사이즈를 웃도는 바이트수가 기입해지면(자) 커져,<A HREF="../../../java/nio/channels/FileChannel.html#truncate(long)"><CODE>잘라버림</CODE></A>  에 의해 작아집니다. 파일에는, 액세스 허가, 컨텐츠 타입, 최종 갱신 시각등의 「메타데이타」도 관련지을 수 있고 있습니다. 이 클래스는, 메타데이타아크세스를 위한 메소드는 정의하지 않습니다.

 <p> 이 클래스는, 바이트 채널에 대한 일반적인 조작 (읽어들여, 기입해, 클로즈) 외에, 다음과 같은 파일 고유의 조작을 정의합니다.  </p>

 <ul>

<li><p> 바이트의 것 <A HREF="../../../java/nio/channels/FileChannel.html#read(java.nio.ByteBuffer, long)"><CODE>read</CODE></A>  이나 <A HREF="../../../java/nio/channels/FileChannel.html#write(java.nio.ByteBuffer, long)"><CODE>기입</CODE></A>  는 , 채널의 현재 위치에 영향을 미치는 일 없이, 파일내의 절대 위치에서 행해진다  </p></li>

<li><p> 파일의 영역은 메모리에 직접<A HREF="../../../java/nio/channels/FileChannel.html#map(java.nio.channels.FileChannel.MapMode, long, long)"><CODE>매핑</CODE></A> 된다. 파일의 사이즈가 큰 경우는, 일반적으로의 <tt>read</tt> 메소드나 <tt>write</tt> 메소드를 호출하는 것보다, 이 방법 쪽이 효율적
   </p></li>

<li><p> 파일의 갱신은, 기초가 되고 있는 기억장치에<A HREF="../../../java/nio/channels/FileChannel.html#force(boolean)"><CODE>강제 써내</CODE></A> 된다. 따라서, 시스템이 크래쉬 해도 데이터의 손실은 회피된다  </p></li>

<li><p> 바이트는 파일로부터<A HREF="../../../java/nio/channels/FileChannel.html#transferTo(long, long, java.nio.channels.WritableByteChannel)"><CODE>다른 채널에</CODE></A> 전송 할 수 있다. 반대로,<A HREF="../../../java/nio/channels/FileChannel.html#transferFrom(java.nio.channels.ReadableByteChannel, long, long)"><CODE>다른 채널로부터</CODE></A> 전송 할 수도 있다. 많은  operating system에서는, 파일 시스템의 캐쉬와의 사이에 매우 고속으로  직접 송수신 하는 것으로써, 이 전송을 최적화할 수 있다
   </p></li>

<li><p> 파일의 영역은, 그 외의 프로그램으로부터 액세스 할 수 없게<A HREF="../../../java/nio/channels/FileLock.html" title="java.nio.channels 동안의 클래스"><CODE>락</CODE></A> 할 수 있다  </p></li>

 </ul>

 <p> 파일 채널은, 복수의 병행 thread로 안전하게 사용할 수 있습니다. <A HREF="../../../java/nio/channels/Channel.html#close()"><CODE>close</CODE></A>  메소드는,<A HREF="../../../java/nio/channels/Channel.html" title="java.nio.channels 안의 인터페이스"><CODE>Channel</CODE></A>  인터페이스의 지정 대로, 언제라도 호출할 수가 있습니다. 채널의 위치를 사용하는 조작, 또는 파일 사이즈를 변경할 가능성이 있는 조작은, 1 개(살)씩 실행하게 되어 있습니다. 전의 조작의 진행중에 같은 조작을 새롭게 개시하려고 하면(자), 최초의 조작이 끝날 때까지 새로운 조작은 블록 됩니다. 그 외의 조작, 특히 명시적인 위치를 사용하는 조작은, 전의 조작과 동시 병행으로 실행할 수 있습니다. 동시 동시성 처리를 할지 어떨지는 기초가 되는 구현에 의해 정해지기 (위해)때문에, 미지정입니다.

 <p> 이 클래스의 인스턴스에 의해 제공된 파일의 뷰는, 같은 프로그램내의 그 외의 인스턴스에 의해 제공된 같은 파일의 뷰와 모순되지 않는 것이 보증되고 있습니다. 그러나, 기초가 되는  operating system의 캐쉬 처리나, 네트워크 파일 시스템 프로토콜에 의한 지연이 원인으로, 이 클래스의 인스턴스에 의해 제공된 뷰와 병행해 실행되고 있는 프로그램으로 인식되는 그 외의 뷰가 모순될 가능성이 없는 것은 아닙니다. 이 문제는, 이러한 프로그램을 기술하고 있는 언어의 차이나, 이것들이 동일 머신으로 실행되고 있는지 어떤지와는 관계없이 발생합니다. 이러한 모순은, 시스템에 의해 생기는 것이기 (위해)때문에 미지정입니다.

 <p> 이 클래스는, 기존의 파일을 여는 메소드나 새로운 파일을 작성하는 메소드는 정의하지 않습니다. 이러한 메소드는, 장래의 릴리스로 추가될 가능성이 있습니다. 이번의 릴리스로 파일 채널을 취득하고 싶은 경우는, 기존의 <A HREF="../../../java/io/FileInputStream.html#getChannel()"><CODE>FileInputStream</CODE></A> ,<A HREF="../../../java/io/FileOutputStream.html#getChannel()"><CODE>FileOutputStream</CODE></A> ,<A HREF="../../../java/io/RandomAccessFile.html#getChannel()"><CODE>RandomAccessFile</CODE></A>  의 몇개의 객체의 <tt>getChannel</tt> 메소드를 호출합니다. 이렇게 하는 것으로, 기초에 있는 같은 파일에 접속된 파일 채널이 돌려주어집니다.

 <p> 파일 채널 상태는, 채널을 돌려준 <tt>getChannel</tt> 메소드를 가지는 객체 상태와 밀접한 관계에 있습니다. 예를 들어, 채널의 위치를 명시적으로, 혹은 바이트의 read나 기입에 의해 변경하면(자), 발생원의 객체의 파일 위치가 바뀝니다 (역도 마찬가지). 파일 채널로부터 파일의 길이를 변경하면(자), 발생원객체로부터 보았을 때의 길이가 바뀝니다 (역도 마찬가지). 바이트의 기입에 의해 파일의 컨텐츠를 변경하면(자), 원의 객체로부터 보았을 때의 컨텐츠가 바뀝니다 (역도 마찬가지). <a name="open-mode">

<a name="open-mode"><p> 이 클래스는, 다양한 점으로써, 「read 가능」, 「기입 가능」, 또는 「read와 기입이 가능」인 인스턴스가 필요한 일을 지정하고 있습니다. <A HREF="../../../java/io/FileInputStream.html" title="java.io 안의 클래스"><CODE>FileInputStream</CODE></A>  인스턴스의 <A HREF="../../../java/io/FileInputStream.html#getChannel()"><CODE>getChannel</CODE></A>  메소드로 취득한 채널은 읽어들여 가능합니다. <A HREF="../../../java/io/FileOutputStream.html" title="java.io 안의 클래스"><CODE>FileOutputStream</CODE></A>  인스턴스의 <A HREF="../../../java/io/FileOutputStream.html#getChannel()"><CODE>getChannel</CODE></A>  메소드로 취득한 채널은 기입해 가능합니다. 그리고,<A HREF="../../../java/io/RandomAccessFile.html" title="java.io 안의 클래스"><CODE>RandomAccessFile</CODE></A>  인스턴스의 <A HREF="../../../java/io/RandomAccessFile.html#getChannel()"><CODE>getChannel</CODE></A>  메소드로 취득한 채널은, 인스턴스가 모드<tt>「r」</tt>로 작성되었을 경우는 읽어들여 가능, 모드<tt>「rw」</tt>로 작성되었을 경우는 read와 기입이 가능합니다. <a name="append-mode">

<a name="append-mode"><p> 예를 들어,<A HREF="../../../java/io/FileOutputStream.html#FileOutputStream(java.io.File, boolean)"><CODE>FileOutputStream(File, boolean)</CODE></A>  생성자 을 호출해 2 번째의 파라미터에 <tt>true</tt> 를 건네주는 것에 의해 파일 출력 스트림을 작성했을 경우, 이 스트림로부터 취득한 기입 가능한 파일 채널은, 「추가 모드」가 됩니다. 이 모드로 관련한 기입 조작을 호출하면(자), 우선 위치가 파일의 말미까지 진행됩니다. 그 후, 요구된 데이터가 기입해집니다. 이러한 위치의 이동과 데이터의 기입은, 불가분인 단일의 조작으로서 행해집니다. 이 조작은, 시스템에 의존하고 있기 (위해)때문에 미지정입니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/io/FileInputStream.html#getChannel()"><CODE>FileInputStream.getChannel()</CODE></A> , 
<A HREF="../../../java/io/FileOutputStream.html#getChannel()"><CODE>FileOutputStream.getChannel()</CODE></A> , 
<A HREF="../../../java/io/RandomAccessFile.html#getChannel()"><CODE>RandomAccessFile.getChannel()</CODE></A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.MapMode.html" title="java.nio.channels 안의 클래스">FileChannel.MapMode</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;파일 매핑방식의 형태 보증된 열거입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#FileChannel()">FileChannel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 클래스의 새로운 인스턴스를 초기화합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#force(boolean)">force</A> </B>(boolean&nbsp;metaData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 파일의 갱신 내용은, 그 기억장치에 강제적으로 기입해집니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/nio/channels/FileLock.html" title="java.nio.channels 내의 클래스">FileLock</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#lock()">lock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 파일상에 배타 락을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/nio/channels/FileLock.html" title="java.nio.channels 내의 클래스">FileLock</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#lock(long, long, boolean)">lock</A> </B>(long&nbsp;position,
     long&nbsp;size,
     boolean&nbsp;shared)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 파일의 지정된 영역을 잠급니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/nio/MappedByteBuffer.html" title="java.nio 내의 클래스">MappedByteBuffer</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#map(java.nio.channels.FileChannel.MapMode, long, long)">map</A> </B>(<A HREF="../../../java/nio/channels/FileChannel.MapMode.html" title="java.nio.channels 안의 클래스">FileChannel.MapMode</A> &nbsp;mode,
    long&nbsp;position,
    long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 파일의 영역을 직접 메모리에 매핑 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#position()">position</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 파일 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/nio/channels/FileChannel.html" title="java.nio.channels 내의 클래스">FileChannel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#position(long)">position</A> </B>(long&nbsp;newPosition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 파일 위치를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#read(java.nio.ByteBuffer)">read</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 바이트 순서를 지정의 버퍼에 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#read(java.nio.ByteBuffer[])">read</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 바이트 순서가 지정된 버퍼에 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#read(java.nio.ByteBuffer[], int, int)">read</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts,
     int&nbsp;offset,
     int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 바이트 순서가 지정된 버퍼의 서브 순서에 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#read(java.nio.ByteBuffer, long)">read</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst,
     long&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 바이트 순서를, 지정된 파일 위치로부터 버퍼에 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#size()">size</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 파일의 현재의 사이즈를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#transferFrom(java.nio.channels.ReadableByteChannel, long, long)">transferFrom</A> </B>(<A HREF="../../../java/nio/channels/ReadableByteChannel.html" title="java.nio.channels 안의 인터페이스">ReadableByteChannel</A> &nbsp;src,
             long&nbsp;position,
             long&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 read 가능한 바이트 채널로부터 이 채널의 파일에 바이트를 전송 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#transferTo(long, long, java.nio.channels.WritableByteChannel)">transferTo</A> </B>(long&nbsp;position,
           long&nbsp;count,
           <A HREF="../../../java/nio/channels/WritableByteChannel.html" title="java.nio.channels 안의 인터페이스">WritableByteChannel</A> &nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 파일로부터 지정된 기입 가능한 바이트 채널에 바이트를 전송 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/nio/channels/FileChannel.html" title="java.nio.channels 내의 클래스">FileChannel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#truncate(long)">truncate</A> </B>(long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 파일의 말미를 절약해 지정된 사이즈로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/nio/channels/FileLock.html" title="java.nio.channels 내의 클래스">FileLock</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#tryLock()">tryLock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 파일상에서 배타 락을 획득하려고 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/nio/channels/FileLock.html" title="java.nio.channels 내의 클래스">FileLock</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#tryLock(long, long, boolean)">tryLock</A> </B>(long&nbsp;position,
        long&nbsp;size,
        boolean&nbsp;shared)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 파일의 지정된 영역에서 락을 획득하려고 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#write(java.nio.ByteBuffer)">write</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 바이트 순서를 지정의 버퍼로부터 써냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#write(java.nio.ByteBuffer[])">write</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 바이트 순서가 지정된 버퍼로부터 써냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#write(java.nio.ByteBuffer[], int, int)">write</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs,
      int&nbsp;offset,
      int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 바이트 순서가 지정된 버퍼의 서브 순서로부터 써냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/FileChannel.html#write(java.nio.ByteBuffer, long)">write</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
      long&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 버퍼의 바이트 순서를 이 채널의 지정된 파일 위치에 기입합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.nio.channels.spi.AbstractInterruptibleChannel"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.nio.channels.spi. <A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html" title="java.nio.channels.spi 안의 클래스">AbstractInterruptibleChannel</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html#begin()">begin</A> , <A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html#close()">close</A> , <A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html#end(boolean)">end</A> , <A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html#implCloseChannel()">implCloseChannel</A> , <A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html#isOpen()">isOpen</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.nio.channels.Channel"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.nio.channels. <A HREF="../../../java/nio/channels/Channel.html" title="java.nio.channels 안의 인터페이스">Channel</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/nio/channels/Channel.html#close()">close</A> , <A HREF="../../../java/nio/channels/Channel.html#isOpen()">isOpen</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="FileChannel()"><!-- --></A> <H3>
FileChannel</H3>
<PRE>
protected <B>FileChannel</B>()</PRE>
<DL>
<DD>이 클래스의 새로운 인스턴스를 초기화합니다.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="read(java.nio.ByteBuffer)"><!-- --></A> <H3>
read</H3>
<PRE>
public abstract int <B>read</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)
                  throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 바이트 순서를 지정의 버퍼에 읽어들입니다.

 <p> 바이트의 read는, 이 채널의 현재의 파일 위치로부터 개시됩니다.  그 후, 실제로 읽힌 바이트수에 의해 파일 위치가 갱신됩니다. 그 이외의 경우, 이 메소드는 <A HREF="../../../java/nio/channels/ReadableByteChannel.html" title="java.nio.channels 안의 인터페이스"><CODE>ReadableByteChannel</CODE></A>  인터페이스의 지정대로 동작합니다.  </p>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../java/nio/channels/ReadableByteChannel.html" title="java.nio.channels 내의 인터페이스">ReadableByteChannel</A> </CODE> 내의 <CODE><A HREF="../../../java/nio/channels/ReadableByteChannel.html#read(java.nio.ByteBuffer)">read</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>dst</CODE> - 바이트의 전송처 버퍼
<DT><B>반환값:</B><DD>읽힌 문자수. 제로인가, 채널이 스트림의 마지막에 이르고 있는 경우는 <tt>-1</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - read 조작의 진행중에, 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - read 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="read(java.nio.ByteBuffer[], int, int)"><!-- --></A> <H3>
read</H3>
<PRE>
public abstract long <B>read</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts,
                          int&nbsp;offset,
                          int&nbsp;length)
                   throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 바이트 순서가 지정된 버퍼의 서브 순서에 읽어들입니다.

 <p> 바이트의 read는, 이 채널의 현재의 파일 위치로부터 개시됩니다.  그 후, 실제로 읽힌 바이트수에 의해 파일 위치가 갱신됩니다. 그 이외의 경우, 이 메소드는 <A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 안의 인터페이스"><CODE>ScatteringByteChannel</CODE></A>  인터페이스의 지정대로 동작합니다.   </p>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 내의 인터페이스">ScatteringByteChannel</A> </CODE> 내의 <CODE><A HREF="../../../java/nio/channels/ScatteringByteChannel.html#read(java.nio.ByteBuffer[], int, int)">read</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>dsts</CODE> - 바이트의 전송처 버퍼<DD><CODE>offset</CODE> - 최초의 바이트의 전송처가 되는 버퍼 배열내의 오프셋(offset).

<tt>dsts.length</tt> 이하의 부가 아닌 값<DD><CODE>length</CODE> - 액세스 되는 최대 버퍼수.

<tt>dsts.length</tt>&nbsp;-&nbsp;<tt>offset</tt> 이하의 부가 아닌 값
<DT><B>반환값:</B><DD>읽힌 문자수. 제로인가, 채널이 스트림의 마지막에 이르고 있는 경우는 <tt>-1</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - read 조작의 진행중에, 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - read 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="read(java.nio.ByteBuffer[])"><!-- --></A> <H3>
read</H3>
<PRE>
public final long <B>read</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts)
                throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 바이트 순서가 지정된 버퍼에 읽어들입니다.

 <p> 바이트의 read는, 이 채널의 현재의 파일 위치로부터 개시됩니다.  그 후, 실제로 읽힌 바이트수에 의해 파일 위치가 갱신됩니다. 그 이외의 경우, 이 메소드는 <A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 안의 인터페이스"><CODE>ScatteringByteChannel</CODE></A>  인터페이스의 지정대로 동작합니다.   </p>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 내의 인터페이스">ScatteringByteChannel</A> </CODE> 내의 <CODE><A HREF="../../../java/nio/channels/ScatteringByteChannel.html#read(java.nio.ByteBuffer[])">read</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>dsts</CODE> - 바이트의 전송처 버퍼
<DT><B>반환값:</B><DD>읽힌 문자수. 제로인가, 채널이 스트림의 마지막에 이르고 있는 경우는 <tt>-1</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - read 조작의 진행중에, 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - read 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="write(java.nio.ByteBuffer)"><!-- --></A> <H3>
write</H3>
<PRE>
public abstract int <B>write</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src)
                   throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 바이트 순서를 지정의 버퍼로부터 써냅니다.

 <p> 채널이 추가 모드 이외의 경우, 바이트의 서두는, 이 채널의 현재의 파일 위치로부터 개시됩니다.  추가 모드에서는, 최초로, 위치가 파일의 말미까지 진행됩니다. 파일의 사이즈는, 기입해진 바이트수에 맞추어 필요하면 커집니다.  파일 위치는, 실제로 기입해진 바이트수에 의해 갱신됩니다. 그 이외의 점으로써, 이 메소드는 <A HREF="../../../java/nio/channels/WritableByteChannel.html" title="java.nio.channels 안의 인터페이스"><CODE>WritableByteChannel</CODE></A>  인터페이스의 지정대로 동작합니다.  </p>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../java/nio/channels/WritableByteChannel.html" title="java.nio.channels 내의 인터페이스">WritableByteChannel</A> </CODE> 내의 <CODE><A HREF="../../../java/nio/channels/WritableByteChannel.html#write(java.nio.ByteBuffer)">write</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>src</CODE> - 바이트의 취득처 버퍼
<DT><B>반환값:</B><DD>기입해지는 바이트수. 제로의 경우도 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 기입중에 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - 기입중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해, 현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="write(java.nio.ByteBuffer[], int, int)"><!-- --></A> <H3>
write</H3>
<PRE>
public abstract long <B>write</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs,
                           int&nbsp;offset,
                           int&nbsp;length)
                    throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 바이트 순서가 지정된 버퍼의 서브 순서로부터 써냅니다.

 <p> 채널이 추가 모드 이외의 경우, 바이트의 서두는, 이 채널의 현재의 파일 위치로부터 개시됩니다.  추가 모드에서는, 최초로, 위치가 파일의 말미까지 진행됩니다. 파일의 사이즈는, 기입해진 바이트수에 맞추어 필요하면 커집니다.  파일 위치는, 실제로 기입해진 바이트수에 의해 갱신됩니다. 그 이외의 점으로써, 이 메소드는 <A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 안의 인터페이스"><CODE>GatheringByteChannel</CODE></A>  인터페이스의 지정대로 동작합니다.   </p>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 내의 인터페이스">GatheringByteChannel</A> </CODE> 내의 <CODE><A HREF="../../../java/nio/channels/GatheringByteChannel.html#write(java.nio.ByteBuffer[], int, int)">write</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcs</CODE> - 바이트의 취득처 버퍼<DD><CODE>offset</CODE> - 최초의 바이트의 취득처가 되는 버퍼 배열내의 오프셋(offset). <tt>srcs.length</tt> 이하의 부가 아닌 값<DD><CODE>length</CODE> - 액세스 되는 최대 버퍼수.

<tt>srcs.length</tt>&nbsp;-&nbsp;<tt>offset</tt> 이하의 부가 아닌 값
<DT><B>반환값:</B><DD>기입해지는 바이트수. 제로의 경우도 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 기입중에 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - 기입 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="write(java.nio.ByteBuffer[])"><!-- --></A> <H3>
write</H3>
<PRE>
public final long <B>write</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs)
                 throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 바이트 순서가 지정된 버퍼로부터 써냅니다.

 <p> 채널이 추가 모드 이외의 경우, 바이트의 서두는, 이 채널의 현재의 파일 위치로부터 개시됩니다.  추가 모드에서는, 최초로, 위치가 파일의 말미까지 진행됩니다. 파일의 사이즈는, 기입해진 바이트수에 맞추어 필요하면 커집니다.  파일 위치는, 실제로 기입해진 바이트수에 의해 갱신됩니다. 그 이외의 점으로써, 이 메소드는 <A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 안의 인터페이스"><CODE>GatheringByteChannel</CODE></A>  인터페이스의 지정대로 동작합니다.   </p>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 내의 인터페이스">GatheringByteChannel</A> </CODE> 내의 <CODE><A HREF="../../../java/nio/channels/GatheringByteChannel.html#write(java.nio.ByteBuffer[])">write</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcs</CODE> - 바이트의 취득처 버퍼
<DT><B>반환값:</B><DD>기입해지는 바이트수. 제로의 경우도 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 기입중에 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - 기입 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="position()"><!-- --></A> <H3>
position</H3>
<PRE>
public abstract long <B>position</B>()
                       throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 파일 위치를 돌려줍니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 채널의 파일 위치. 파일의 선두로부터 현재의 위치까지의

바이트수를 나타내는 부가 아닌 정수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="position(long)"><!-- --></A> <H3>
position</H3>
<PRE>
public abstract <A HREF="../../../java/nio/channels/FileChannel.html" title="java.nio.channels 내의 클래스">FileChannel</A>  <B>position</B>(long&nbsp;newPosition)
                              throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 파일 위치를 설정합니다.

 <p> 위치의 값을 파일의 현재의 사이즈보다 큰 값으로 설정하는 것은 정당한 처리입니다.  그러나, 이 처리에 의해 파일의 사이즈가 변경되는 것은 아닙니다. 파일의 현재의 사이즈보다 큰 값이 설정되어 있는 위치에서 바이트를 읽어내려고 하면(자), 즉석에서 파일의 마지막이 통지됩니다. 같은 위치에서 바이트를 기입하려고 하면(자), 새로운 바이트에 맞추어 파일의 사이즈가 커집니다.  이전의 파일의 마지막으로부터 새롭게 기입해진 바이트까지의 사이에 존재하는 바이트의 값은 미지정입니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newPosition</CODE> - 새로운 위치. 파일의 선두로부터의 바이트수를 나타내는 부가 아닌 정수
<DT><B>반환값:</B><DD>이 파일 채널
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 새로운 위치가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A> <H3>
size</H3>
<PRE>
public abstract long <B>size</B>()
                   throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 파일의 현재의 사이즈를 돌려줍니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 채널의 파일의 현재의 사이즈 (바이트 단위)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="truncate(long)"><!-- --></A> <H3>
truncate</H3>
<PRE>
public abstract <A HREF="../../../java/nio/channels/FileChannel.html" title="java.nio.channels 내의 클래스">FileChannel</A>  <B>truncate</B>(long&nbsp;size)
                              throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 파일의 말미를 절약해 지정된 사이즈로 합니다.

 <p> 지정된 사이즈가 현재의 파일 사이즈보다 작은 경우, 파일의 말미를 절약할 수 있어 새로운 파일의 마지막에 들어가지 않는 바이트가 파기됩니다. 지정된 사이즈가 현재의 파일 사이즈와 같은가, 그것보다 큰 경우, 파일 사이즈는 변경되지 않습니다. 어느 쪽의 경우도, 이 채널의 파일 위치가 지정된 사이즈보다 큰 경우, 그 사이즈에 맞추어 파일 사이즈가 변경됩니다.
 </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>size</CODE> - 새로운 사이즈. 부가 아닌 바이트수
<DT><B>반환값:</B><DD>이 파일 채널
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/NonWritableChannelException.html" title="java.nio.channels 안의 클래스">NonWritableChannelException</A> </CODE> - 이 채널이 기입해 가능하지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 새로운 사이즈가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="force(boolean)"><!-- --></A> <H3>
force</H3>
<PRE>
public abstract void <B>force</B>(boolean&nbsp;metaData)
                    throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 파일의 갱신 내용은, 그 기억장치에 강제적으로 기입해집니다.

 <p> 이 채널의 파일이 로컬의 기억장치상에 있는 경우, 이 메소드의 반환값으로부터, 이 채널의 작성시 또는 이 메소드의 제일 최근의 호출해 이후의 파일의 변경 내용이 모두 그 디바이스에 기입해지고 있는 것을 알 수 있습니다. 이 방법에 의해, 시스템이 크래쉬 했을 때, 중요한 정보를 손실로부터 보호할 수 있습니다.

 <p> 한편, 파일이 로컬의 기억장치상에 없는 경우, 기입은 행해지지 않습니다.

 <p> <tt>metaData</tt> 파라미터를 사용해, 이 메소드로 실행해야 하는 입출력 조작의 수를 제한할 수 있습니다. 이 파라미터에 <tt>false</tt> 를 건네주었을 경우, 기억장치에 기입할 필요가 있는 것은, 파일의 컨텐츠의 갱신 내용 뿐입니다. <tt> true</tt> 를 건네주었을 경우는, 파일의 컨텐츠와 메타데이타의 갱신 내용을 기입할 필요가 있습니다. 이것에는, 일반적으로 1 개 이상의 입출력 조작이 필요합니다.  이 파라미터에 실효성이 있을지 어떨지는, 기초가 되는  operating system에 의해 정해지기 (위해)때문에, 미지정입니다.

 <p> 이 메소드를 호출하면(자), 채널이 읽어들여 전용이어도 입출력 조작이 발생합니다. 예를 들어, 파일의 메타데이타로서 최종 액세스 시각을 보존해, 파일의 읽을 여행에 갱신하는 것 같은  operating system도 있습니다. 이 처리가 실제로 행해질지 어떨지는 시스템에 의해 정해지기 (위해)때문에, 미지정입니다.

 <p> 이 메소드는, 이 클래스에 정의된 메소드에 의해 이 채널의 파일에 더해진 변경을 강제할 뿐입니다. <A HREF="../../../java/nio/channels/FileChannel.html#map(java.nio.channels.FileChannel.MapMode, long, long)"><CODE>map</CODE></A>  메소드 호출에 의해 취득한<A HREF="../../../java/nio/MappedByteBuffer.html" title="java.nio 동안의 클래스"><CODE>맵 된 byte 버퍼</CODE></A> 의 컨텐츠의 변경에 의해 생기는 변경은, 반드시 강제당하지 않습니다. 맵 된 byte 버퍼의 <A HREF="../../../java/nio/MappedByteBuffer.html#force()"><CODE>force</CODE></A>  메소드를 호출하면(자), 버퍼 컨텐츠에 대한 변경 내용이 강제적으로 기입해집니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>metaData</CODE> - <tt>true</tt> 의 경우, 이 메소드는, 파일의 컨텐츠 및 메타데이타를 기억 영역에 강제적으로 기입할 필요가 있다.

그 이외의 경우는 컨텐츠의 변경만을 강제적으로 기입한다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="transferTo(long, long, java.nio.channels.WritableByteChannel)"><!-- --></A> <H3>
transferTo</H3>
<PRE>
public abstract long <B>transferTo</B>(long&nbsp;position,
                                long&nbsp;count,
                                <A HREF="../../../java/nio/channels/WritableByteChannel.html" title="java.nio.channels 안의 인터페이스">WritableByteChannel</A> &nbsp;target)
                         throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 파일로부터 지정된 기입 가능한 바이트 채널에 바이트를 전송 합니다.

 <p> 이 채널의 파일의 지정된 <tt>position</tt> 로부터 최대 <tt>count</tt> 바이트를 읽어들여, 타겟 채널에 기입하려고 합니다. 이 메소드를 호출해도, 채널의 본래의 성질이나 상태에 의해, 요구된 바이트의 일부가 전송 되지 않는 경우도 있습니다. 이 채널의 파일의 바이트수가, 지정된 <tt>position</tt> 로부터 시작되는 <tt>count</tt> 보다 적은 경우나, 타겟 채널이 비블록 모드로, 출력 버퍼내의 빈바이트수가 <tt>count</tt> 보다 적은 경우, 전송 되는 바이트수는 요구된 바이트수보다 적게 됩니다.

 <p> 이 메소드는 이 채널의 위치를 변경하지 않습니다. 지정된 위치가 파일의 현재의 사이즈보다 큰 경우, 바이트는 일절 전송 되지 않습니다. 타겟 채널에 위치가 지정되고 있는 경우, 바이트는 그 위치로부터 기입해집니다.  그 후, 기입해진 바이트수에 맞추어 위치가 증가합니다.

 <p> 이 채널로부터 데이터를 읽어들여 타겟 채널에 기입한다고 하는 단순한 루프보다, 이 메소드 쪽이 쭉 효율적으로 처리할 수 있을 가능성이 있습니다. 많은  operating system는, 파일 시스템 캐쉬로부터 타겟 채널에 바이트를 직접 전송 할 수 있습니다.  이 때, 바이트의 카피는 행해지지 않습니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>position</CODE> - 전송이 개시되는 파일내의 위치. 부가 아닌<DD><CODE>count</CODE> - 전송 되는 최대 바이트수. 부가 아닌<DD><CODE>target</CODE> - 타겟 채널
<DT><B>반환값:</B><DD>실제로 전송 된 바이트수. 제로의 경우도 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 상기의 파라미터의 전제 조건이 채워지지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/NonReadableChannelException.html" title="java.nio.channels 안의 클래스">NonReadableChannelException</A> </CODE> - 이 채널이 읽어들여 가능하지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/NonWritableChannelException.html" title="java.nio.channels 안의 클래스">NonWritableChannelException</A> </CODE> - 타겟 채널이 기입해 가능하지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널 또는 타겟 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 전송중에, 다른 thread에 의해 몇개의 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - 전송중에 다른 thread로부터의 인터럽트가 있었기 때문에 양쪽 모두의 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="transferFrom(java.nio.channels.ReadableByteChannel, long, long)"><!-- --></A> <H3>
transferFrom</H3>
<PRE>
public abstract long <B>transferFrom</B>(<A HREF="../../../java/nio/channels/ReadableByteChannel.html" title="java.nio.channels 안의 인터페이스">ReadableByteChannel</A> &nbsp;src,
                                  long&nbsp;position,
                                  long&nbsp;count)
                           throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>지정된 read 가능한 바이트 채널로부터 이 채널의 파일에 바이트를 전송 합니다.

 <p> 소스 채널로부터 최대 <tt>count</tt> 바이트를 읽어들여, 이 채널의 파일의 지정된 <tt>position</tt> 에 기입하려고 합니다. 이 메소드를 호출해도, 채널의 본래의 성질이나 상태에 의해, 요구된 바이트의 일부가 전송 되지 않는 경우도 있습니다. 소스 채널의 바이트수가 <tt>count</tt> 보다 적은 경우나, 소스 채널이 비블록 모드로, 입력 버퍼내에 남아 있는 곧바로 이용할 수 있는 빈바이트수가 <tt>count</tt> 보다 적은 경우, 전송 되는 바이트수는 요구된 바이트수보다 적게 됩니다.

 <p> 이 메소드는 이 채널의 위치를 변경하지 않습니다. 지정된 위치가 파일의 현재의 사이즈보다 큰 경우, 바이트는 일절 전송 되지 않습니다. 소스 채널에 위치가 지정되고 있는 경우, 바이트는 그 위치로부터 읽어내집니다.  그 후, 읽어내진 바이트수에 맞추어 위치가 증가합니다.

 <p> 소스 채널로부터 데이터를 읽어들여 이 채널에 기입한다고 하는 단순한 루프보다, 이 메소드 쪽이 쭉 효율적으로 처리할 수 있을 가능성이 있습니다. 많은  operating system는, 소스 채널로부터 파일 시스템 캐쉬에 바이트를 직접 전송 할 수 있습니다.  이 때, 바이트의 카피는 행해지지 않습니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>src</CODE> - 소스 채널<DD><CODE>position</CODE> - 전송이 개시되는 파일내의 위치. 부가 아닌<DD><CODE>count</CODE> - 전송 되는 최대 바이트수. 부가 아니다
<DT><B>반환값:</B><DD>실제로 전송 된 바이트수. 제로의 경우도 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 상기의 파라미터의 전제 조건이 채워지지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/NonReadableChannelException.html" title="java.nio.channels 안의 클래스">NonReadableChannelException</A> </CODE> - 소스 채널이 읽어들여 가능하지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/NonWritableChannelException.html" title="java.nio.channels 안의 클래스">NonWritableChannelException</A> </CODE> - 이 채널이 기입해 가능하지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널 또는 소스 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 전송중에, 다른 thread에 의해 몇개의 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - 전송중에 다른 thread로부터의 인터럽트가 있었기 때문에 양쪽 모두의 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="read(java.nio.ByteBuffer, long)"><!-- --></A> <H3>
read</H3>
<PRE>
public abstract int <B>read</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst,
                         long&nbsp;position)
                  throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 바이트 순서를, 지정된 파일 위치로부터 버퍼에 읽어들입니다.

 <p> 이 메소드는, 바이트가 채널의 현재 위치는 아니고 지정된 파일 위치로부터 읽어내진다고 하는 점을 제외하면,<A HREF="../../../java/nio/channels/FileChannel.html#read(java.nio.ByteBuffer)"><CODE>read(ByteBuffer)</CODE></A> 메소드와 같습니다. 이 메소드는 이 채널의 위치를 변경하지 않습니다. 지정된 위치가 파일의 현재의 사이즈보다 큰 경우, 바이트는 일절 읽어내지지 않습니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>dst</CODE> - 바이트의 전송처 버퍼<DD><CODE>position</CODE> - 전송이 개시되는 파일 위치. 부가 아니다
<DT><B>반환값:</B><DD>읽어내지는 바이트수. 제로인가, 지정된 위치가 파일의 현재의 사이즈보다 큰 경우는

<tt>-1</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 위치가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../../java/nio/channels/NonReadableChannelException.html" title="java.nio.channels 안의 클래스">NonReadableChannelException</A> </CODE> - 이 채널이 읽어들여 가능하지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - read 조작의 진행중에, 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - read 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="write(java.nio.ByteBuffer, long)"><!-- --></A> <H3>
write</H3>
<PRE>
public abstract int <B>write</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
                          long&nbsp;position)
                   throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>지정된 버퍼의 바이트 순서를 이 채널의 지정된 파일 위치에 기입합니다.

 <p> 이 메소드는, 바이트가 채널의 현재 위치는 아니고 지정된 파일 위치로부터 기입해진다고 하는 점을 제외하면,<A HREF="../../../java/nio/channels/FileChannel.html#write(java.nio.ByteBuffer)"><CODE>write(ByteBuffer)</CODE></A>  메소드와 같습니다. 이 메소드는 이 채널의 위치를 변경하지 않습니다. 지정된 위치가 현재의 파일 사이즈보다 큰 경우, 파일 사이즈는 새로운 바이트에 맞추어 커집니다.  이전의 파일의 마지막과 새롭게 기입해진 바이트의 사이의 바이트의 값은 미지정입니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>src</CODE> - 바이트의 전송원버퍼<DD><CODE>position</CODE> - 전송이 개시되는 파일 위치. 부가 아니다
<DT><B>반환값:</B><DD>기입해지는 바이트수. 제로의 경우도 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 위치가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../../java/nio/channels/NonWritableChannelException.html" title="java.nio.channels 안의 클래스">NonWritableChannelException</A> </CODE> - 이 채널이 기입해 가능하지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 기입중에 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - 기입 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="map(java.nio.channels.FileChannel.MapMode, long, long)"><!-- --></A> <H3>
map</H3>
<PRE>
public abstract <A HREF="../../../java/nio/MappedByteBuffer.html" title="java.nio 내의 클래스">MappedByteBuffer</A>  <B>map</B>(<A HREF="../../../java/nio/channels/FileChannel.MapMode.html" title="java.nio.channels 안의 클래스">FileChannel.MapMode</A> &nbsp;mode,
                                     long&nbsp;position,
                                     long&nbsp;size)
                              throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 파일의 영역을 직접 메모리에 매핑 합니다.

 <p> 파일의 영역을 메모리에 매핑 하는 처리는, 다음의 3 개의 모드 쳐 어느쪽이든으로 행해집니다.
 </p>

 <ul type=disc>

<li><p> <i>read 전용:</i>버퍼를 수정하려고 하면(자) <A HREF="../../../java/nio/ReadOnlyBufferException.html" title="java.nio 동안의 클래스"><CODE>ReadOnlyBufferException</CODE></A>  가 throw 된다 (<A HREF="../../../java/nio/channels/FileChannel.MapMode.html#READ_ONLY"><CODE>MapMode.READ_ONLY</CODE></A> ) </p></li>

<li><p> <i>읽어들여/기입:</i>버퍼에의 변경은 최종적으로 파일에 전달되는. 이 변경은, 같은 파일에 매핑 되고 있는 그 외의 프로그램에 의해 인식되는 경우라고 인식되지 않는 경우가 있다 (<A HREF="../../../java/nio/channels/FileChannel.MapMode.html#READ_WRITE"><CODE>MapMode.READ_WRITE</CODE></A> ) </p></li>

<li><p> <i>비공개:</i>버퍼에의 변경은 파일에 전달되지 않고, 같은 파일에 매핑 되고 있는 그 외의 프로그램에 의해 인식될 것도 없다. 그 대신에, 변경된 부분의 비공개의 카피가 작성된다 (<A HREF="../../../java/nio/channels/FileChannel.MapMode.html#PRIVATE"><CODE>MapMode.PRIVATE</CODE></A> ) </p></li>

 </ul>

 <p> 이 채널은, read 전용의 매핑의 경우는 읽어들여, read/기입의 매핑 또는 비공개 매핑의 경우는 read와 기입의 양쪽 모두가 가능하게 되지 않으면 안됩니다.

 <p> 이 메소드가 돌려주는<A HREF="../../../java/nio/MappedByteBuffer.html" title="java.nio 동안의 클래스"><CODE>맵 된 byte 버퍼</CODE></A> 의 위치는 제로, 리밋트와 용량은 <tt>size</tt> 입니다.  마크는 미정도리가 됩니다. 버퍼와 이 버퍼가 가리키는 매핑은, 버퍼 자체가 가베지 컬렉트될 때까지 유효합니다.

 <p> 매핑의 결과는, 그 작성에 사용된 파일 채널에는 의존하지 않습니다. 예를 들어, 채널을 클로즈 해도, 매핑의 유효성은 바뀌지 않습니다.

 <p> 많은 경우, 메모리에 매핑 된 파일의 자세한 것은, 본질적으로 기초가 되는  operating system에 의존하기 위해(때문에), 미지정입니다. 요구된 영역이 이 채널의 파일내에 완전하게는 포함되지 않은 경우, 이 메소드의 동작은 미지정입니다. 기초가 되는 파일의 컨텐츠 또는 사이즈의 어느 쪽이 변경되었는지, 이 프로그램에 의한 변경 또는 다른 프로그램에 의한 변경의 어느 쪽인지, 및, 변경이 버퍼에 전달될지 어떨지는 미지정입니다. 버퍼의 변경이 파일에 전달되는 속도는 미지정입니다.

 <p> 대부분의  operating system에서는, 파일을 메모리에 매핑 하는 편이, 일반적으로의 <A HREF="../../../java/nio/channels/FileChannel.html#read(java.nio.ByteBuffer)"><CODE>read</CODE></A>  메소드 또는 <A HREF="../../../java/nio/channels/FileChannel.html#write(java.nio.ByteBuffer)"><CODE>write</CODE></A>  메소드를 사용해 수십 킬로바이트의 데이터의 읽어들여 또는 기입을 실시하는 것보다도 부하가 커집니다. 성능을 중시한다면, 비교적 큰 파일만을 매핑 하는 것을 추천합니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>mode</CODE> - 파일의 매핑을 읽어내 전용 모드로 실시하는 경우는 <A HREF="../../../java/nio/channels/FileChannel.MapMode.html" title="java.nio.channels 안의 클래스"><CODE>FileChannel.MapMode</CODE></A>  클래스에 정의되고 있는 정수 <A HREF="../../../java/nio/channels/FileChannel.MapMode.html#READ_ONLY"><CODE>READ_ONLY</CODE></A> ,

읽어내/기입 모드로 실시하는 경우는 동클래스에 정의되고 있는 정수 <A HREF="../../../java/nio/channels/FileChannel.MapMode.html#READ_WRITE"><CODE>READ_WRITE</CODE></A> ,

비공개 (copy-on-write) 모드로 실시하는 경우는 동클래스에 정의되고 있는 정수 <A HREF="../../../java/nio/channels/FileChannel.MapMode.html#PRIVATE"><CODE>PRIVATE</CODE></A> <DD><CODE>position</CODE> - 파일내의 매핑 된 영역의 개시 위치. 부가 아닌<DD><CODE>size</CODE> - 매핑 되는 영역의 사이즈.  부가 아닌,<A HREF="../../../java/lang/Integer.html#MAX_VALUE"><CODE>Integer.MAX_VALUE</CODE></A>  이하의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/NonReadableChannelException.html" title="java.nio.channels 안의 클래스">NonReadableChannelException</A> </CODE> - <tt>mode</tt> 가 <A HREF="../../../java/nio/channels/FileChannel.MapMode.html#READ_ONLY"><CODE>READ_ONLY</CODE></A>  인데, 이 채널이 읽어들여 불가 상태가 되어 있었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/NonWritableChannelException.html" title="java.nio.channels 안의 클래스">NonWritableChannelException</A> </CODE> - <tt>mode</tt> 가 <A HREF="../../../java/nio/channels/FileChannel.MapMode.html#READ_WRITE"><CODE>READ_WRITE</CODE></A>  또는 <A HREF="../../../java/nio/channels/FileChannel.MapMode.html#PRIVATE"><CODE>PRIVATE</CODE></A>  인데,

채널이 읽어내/기입 불가 상태가 되어 있었을 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 상기의 파라미터의 전제 조건이 채워지지 않은 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/nio/channels/FileChannel.MapMode.html" title="java.nio.channels 내의 클래스"><CODE>FileChannel.MapMode</CODE></A> , 
<A HREF="../../../java/nio/MappedByteBuffer.html" title="java.nio 안의 클래스"><CODE>MappedByteBuffer</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="lock(long, long, boolean)"><!-- --></A> <H3>
lock</H3>
<PRE>
public abstract <A HREF="../../../java/nio/channels/FileLock.html" title="java.nio.channels 내의 클래스">FileLock</A>  <B>lock</B>(long&nbsp;position,
                              long&nbsp;size,
                              boolean&nbsp;shared)
                       throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 파일의 지정된 영역을 잠급니다.

 <p> 이 메소드의 호출은, 영역이 락 되는지, 이 채널이 클로즈 되는지, thread의 호출해에 인터럽트가 발생할 때까지 블록 됩니다.
 
 <p> 이 메소드의 호출중에 이 채널이 다른 thread에 의해 클로즈 되면(자),<A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스"><CODE>AsynchronousCloseException</CODE></A>  가 throw 됩니다.
 
 <p> 락의 획득을 대기중에 thread 호출해에 인터럽트가 발생했을 경우, 인터럽트 상태가 설정되어<A HREF="../../../java/nio/channels/FileLockInterruptionException.html" title="java.nio.channels 동안의 클래스"><CODE>FileLockInterruptionException</CODE></A>  가 throw 됩니다. 이 메소드의 호출시에 호출해 원의 인터럽트 상태가 설정되면(자), 즉시 예외가 throw 됩니다.  thread의 인터럽트 상태는 변경되지 않습니다.

 <p> <tt>position</tt> 파라미터와 <tt>size</tt> 파라미터로 지정된 영역이, 기초에 있는 파일에 포함되어 있거나, 그 파일과 오버랩 하거나 하고 있을 필요는 없습니다. 락 영역의 사이즈는 고정입니다.  초기 상태에서는 파일의 마지막이 락 영역내에 포함되어 있어도, 파일 사이즈가 이 영역에서(보다) 커져 버렸을 경우, 새로운 부분에는 락이 적용되지 않습니다. 파일 전체에 락을 적용할 필요가 있는 것에도 불구하고, 파일 사이즈가 커질 가능성이 있는 경우는, 제로로부터 예측되는 최대 파일 사이즈 이상까지의 영역을 잠급니다. 제로 인수의 <A HREF="../../../java/nio/channels/FileChannel.html#lock()"><CODE>lock()</CODE></A>  메소드는, 단순하게 사이즈 <A HREF="../../../java/lang/Long.html#MAX_VALUE"><CODE>Long.MAX_VALUE</CODE></A>  의 영역을 잠급니다.

 <p> 공유 락을 지원하지 않는  operating system에서는, 공유 락 요구가 배타 락 요구에 자동적으로 변환됩니다. 새롭게 획득한 락이 공유 락일까 배타 락일까는, 결과적으로 얻을 수 있는 락 객체의 <A HREF="../../../java/nio/channels/FileLock.html#isShared()"><CODE>isShared</CODE></A>  메소드를 호출하는 것으로 판단할 수 있습니다.

 <p> 파일 락은 Java 가상 머신 전체를 위해서(때문에) 보관 유지됩니다. 이것들은, 동일 가상 머신내의 복수 thread에 의한 파일에의 액세스를 제어하는데는 적합하지 않습니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>position</CODE> - 락 영역이 개시되는 파일 위치. 부가 아닌<DD><CODE>size</CODE> - 락 영역의 사이즈. 부가 아니다. <tt>position</tt>&nbsp;+&nbsp;<tt>size</tt> 의 합계도 부가 아닌<DD><CODE>shared</CODE> - 공유 락을 요구하는 경우는 <tt>true</tt>. 이 경우, 이 채널은 읽기가 (경우에 따라서는 기입도) 가능하지 않으면 안 된다.

배타 락을 요구하는 경우는 <tt>false</tt>. 이 경우, 이 채널은 기입이 (경우에 따라서는 읽기도) 가능하지 않으면 안 된다
<DT><B>반환값:</B><DD>신규 획득 락을 나타내는 락 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 상기의 파라미터의 전제 조건이 채워지지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 이 메소드내에서 thread 호출이 블록 되고 있는 동안에, 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/FileLockInterruptionException.html" title="java.nio.channels 안의 클래스">FileLockInterruptionException</A> </CODE> - 호출원thread가, 이 메소드내에서 블록 되고 있는 동안에
인터럽트를 받았을 경우
<DD><CODE><A HREF="../../../java/nio/channels/OverlappingFileLockException.html" title="java.nio.channels 안의 클래스">OverlappingFileLockException</A> </CODE> - 요구된 영역을 오버랩 하는 락이 이 Java 가상 머신에 벌써 확보되고 있는 경우.

또는, 이 메소드내에서 블록 되고 있는 다른 thread가 오버랩 한 영역을 잠그려 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/NonReadableChannelException.html" title="java.nio.channels 안의 클래스">NonReadableChannelException</A> </CODE> - <tt>shared</tt> 가 <tt>true</tt> 이면, 이 채널은 읽어내 불가 상태
<DD><CODE><A HREF="../../../java/nio/channels/NonWritableChannelException.html" title="java.nio.channels 안의 클래스">NonWritableChannelException</A> </CODE> - <tt>shared</tt> 가 <tt>false</tt> 인 것에도 불구하고, 이 채널이 기입해 불가 상태인 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/nio/channels/FileChannel.html#lock()"><CODE>lock()</CODE></A> , 
<A HREF="../../../java/nio/channels/FileChannel.html#tryLock()"><CODE>tryLock()</CODE></A> , 
<A HREF="../../../java/nio/channels/FileChannel.html#tryLock(long, long, boolean)"><CODE>tryLock(long, long, boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="lock()"><!-- --></A> <H3>
lock</H3>
<PRE>
public final <A HREF="../../../java/nio/channels/FileLock.html" title="java.nio.channels 내의 클래스">FileLock</A>  <B>lock</B>()
                    throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 파일상에 배타 락을 설정합니다.

 <p> 이 메소드를 <tt>fc.lock()</tt> 의 형식에서 호출했을 경우, 다음의 호출과 같은 결과를 얻을 수 있습니다.

 <pre>
fc. <A HREF="../../../java/nio/channels/FileChannel.html#lock(long, long, boolean)"><CODE>lock</CODE></A> (0L, Long.MAX_VALUE, false) </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>신규 획득 락을 나타내는 락 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 이 메소드내에서 thread 호출이 블록 되고 있는 동안에, 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/FileLockInterruptionException.html" title="java.nio.channels 안의 클래스">FileLockInterruptionException</A> </CODE> - 호출원thread가, 이 메소드내에서 블록 되고 있는 동안에
인터럽트를 받았을 경우
<DD><CODE><A HREF="../../../java/nio/channels/OverlappingFileLockException.html" title="java.nio.channels 안의 클래스">OverlappingFileLockException</A> </CODE> - 요구된 영역을 오버랩 하는 락이 이 Java 가상 머신에 벌써 확보되고 있는 경우.

또는, 이 메소드내에서 블록 되고 있는 다른 thread가 같은 파일의 오버랩 한 영역을 잠그려 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/NonWritableChannelException.html" title="java.nio.channels 안의 클래스">NonWritableChannelException</A> </CODE> - 이 채널이 기입해 가능하지 않은 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/nio/channels/FileChannel.html#lock(long, long, boolean)"><CODE>lock(long, long, boolean)</CODE></A> , 
<A HREF="../../../java/nio/channels/FileChannel.html#tryLock()"><CODE>tryLock()</CODE></A> , 
<A HREF="../../../java/nio/channels/FileChannel.html#tryLock(long, long, boolean)"><CODE>tryLock(long, long, boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="tryLock(long, long, boolean)"><!-- --></A> <H3>
tryLock</H3>
<PRE>
public abstract <A HREF="../../../java/nio/channels/FileLock.html" title="java.nio.channels 내의 클래스">FileLock</A>  <B>tryLock</B>(long&nbsp;position,
                                 long&nbsp;size,
                                 boolean&nbsp;shared)
                          throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 파일의 지정된 영역에서 락을 획득하려고 합니다.

 <p> 이 메소드는 블록 되지 않습니다. 이 메소드를 호출하면(자), 요구된 영역에서 락을 획득했는지, 락의 획득에 실패했는지를 나타내는 결과가 즉시 돌려주어집니다. 오버랩 한 락이 다른 프로그램에 의해 보관 유지되고 있었기 때문에 락에 실패했을 경우,<tt>null</tt> 가 돌려주어집니다. 그 외의 원인으로 락에 실패했을 경우는, 적절한 예외가 throw 됩니다.

 <p> <tt>position</tt> 파라미터와 <tt>size</tt> 파라미터로 지정된 영역이, 기초에 있는 파일에 포함되어 있거나, 그 파일과 오버랩 하거나 하고 있을 필요는 없습니다. 락 영역의 사이즈는 고정입니다.  초기 상태에서는 파일의 마지막이 락 영역내에 포함되어 있어도, 파일 사이즈가 이 영역에서(보다) 커져 버렸을 경우, 새로운 부분에는 락이 적용되지 않습니다. 파일 전체에 락을 적용할 필요가 있는 것에도 불구하고, 파일 사이즈가 커질 가능성이 있는 경우는, 제로로부터 예측되는 최대 파일 사이즈 이상까지의 영역을 잠급니다. 제로 인수의 <A HREF="../../../java/nio/channels/FileChannel.html#tryLock()"><CODE>tryLock()</CODE></A>  메소드는, 단순하게 사이즈 <A HREF="../../../java/lang/Long.html#MAX_VALUE"><CODE>Long.MAX_VALUE</CODE></A>  의 영역을 잠급니다.

 <p> 공유 락을 지원하지 않는  operating system에서는, 공유 락 요구가 배타 락 요구에 자동적으로 변환됩니다. 새롭게 획득한 락이 공유 락일까 배타 락일까는, 결과적으로 얻을 수 있는 락 객체의 <A HREF="../../../java/nio/channels/FileLock.html#isShared()"><CODE>isShared</CODE></A>  메소드를 호출하는 것으로 판단할 수 있습니다.

 <p> 파일 락은 Java 가상 머신 전체를 위해서(때문에) 보관 유지됩니다. 이것들은, 동일 가상 머신내의 복수 thread에 의한 파일에의 액세스를 제어하는데는 적합하지 않습니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>position</CODE> - 락 영역이 개시되는 파일 위치. 부가 아닌<DD><CODE>size</CODE> - 락 영역의 사이즈. 부가 아니다. <tt>position</tt>&nbsp;+&nbsp;<tt>size</tt> 의 합계도 부가 아닌<DD><CODE>shared</CODE> - 공유 락을 요구하는 경우는 <tt>true</tt>, 배타 락을 요구하는 경우는 <tt>false</tt>
<DT><B>반환값:</B><DD>신규 획득 락을 나타내는 락 객체. 오버랩 한 락이 다른 프로그램에 의해 확보되고 있었기 때문에

락에 실패했을 경우는 <tt>null</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 상기의 파라미터의 전제 조건이 채워지지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/OverlappingFileLockException.html" title="java.nio.channels 안의 클래스">OverlappingFileLockException</A> </CODE> - 요구된 영역을 오버랩 하는 락이 이 Java 가상 머신에 벌써 확보되고 있는 경우.

또는, 이 메소드내에서 블록 되고 있는 다른 thread가 같은 파일의 오버랩 한 영역을 잠그려 하고 있는 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/nio/channels/FileChannel.html#lock()"><CODE>lock()</CODE></A> , 
<A HREF="../../../java/nio/channels/FileChannel.html#lock(long, long, boolean)"><CODE>lock(long, long, boolean)</CODE></A> , 
<A HREF="../../../java/nio/channels/FileChannel.html#tryLock()"><CODE>tryLock()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="tryLock()"><!-- --></A> <H3>
tryLock</H3>
<PRE>
public final <A HREF="../../../java/nio/channels/FileLock.html" title="java.nio.channels 내의 클래스">FileLock</A>  <B>tryLock</B>()
                       throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 파일상에서 배타 락을 획득하려고 합니다.

 <p> 이 메소드를 <tt>fc.trylock()</tt> 의 형식에서 호출했을 경우, 다음의 호출과 같은 결과를 얻을 수 있습니다.

 <pre>
fc. <A HREF="../../../java/nio/channels/FileChannel.html#tryLock(long, long, boolean)"><CODE>tryLock</CODE></A> (0L, Long.MAX_VALUE, false) </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>신규 획득 락을 나타내는 락 객체. 오버랩 한 락이 다른 프로그램에 의해 확보되고 있었기 때문에

락에 실패했을 경우는 <tt>null</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/OverlappingFileLockException.html" title="java.nio.channels 안의 클래스">OverlappingFileLockException</A> </CODE> - 요구된 영역을 오버랩 하는 락이 이 Java 가상 머신에 벌써 확보되고 있는 경우.

또는, 이 메소드내에서 블록 되고 있는 다른 thread가 오버랩 한 영역을 잠그려 하고 있는 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/nio/channels/FileChannel.html#lock()"><CODE>lock()</CODE></A> , 
<A HREF="../../../java/nio/channels/FileChannel.html#lock(long, long, boolean)"><CODE>lock(long, long, boolean)</CODE></A> , 
<A HREF="../../../java/nio/channels/FileChannel.html#tryLock(long, long, boolean)"><CODE>tryLock(long, long, boolean)</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/FileChannel.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/nio/channels/DatagramChannel.html" title="java.nio.channels 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/nio/channels/FileChannel.MapMode.html" title="java.nio.channels 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/nio/channels/FileChannel.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="FileChannel.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
