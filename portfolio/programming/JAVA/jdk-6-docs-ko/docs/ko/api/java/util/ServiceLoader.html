<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:00:10 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
ServiceLoader (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ServiceLoader (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ServiceLoader.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/util/ServiceConfigurationError.html" title="java.util 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/util/ServiceLoader.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ServiceLoader.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util</FONT>
<BR>
클래스 ServiceLoader&lt;S&gt;</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.ServiceLoader&lt;S&gt;</B>
</PRE>
<DL>
<DT><DT><B>형태 파라미터:</B><DD><CODE>S</CODE> - 이 로더에 의해 로드 되는 서비스의 형태</DL>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/lang/Iterable.html" title="java.lang 내의 인터페이스">Iterable</A> &lt;S&gt;</DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public final class <B>ServiceLoader&lt;S&gt;</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../java/lang/Iterable.html" title="java.lang 내의 인터페이스">Iterable</A> &lt;S&gt;</DL>
</PRE>

<P>
간단한 서비스 프로바이더 로드 기구입니다.

 <p> 「서비스」란, 기존의 인터페이스 및 클래스 (일반적으로은 추상 클래스)세트입니다. 「서비스 프로바이더」란, 특정의 서비스의 구현입니다. 일반적으로, 프로바이더의 클래스에 의해, 서비스 자체에 정의되고 있는 클래스의 인터페이스와 서브 클래스가 구현됩니다. 서비스 프로바이더를 Java 플랫폼의 구현에 인스톨 할 때는, 확장 기능의 형식, 즉, 확장 기능의 일반적으로의 디렉토리에 배치되는 jar 파일의 형식에서 행해집니다. 프로바이더를 이용 가능하게 하려면 , 어플리케이션의 클래스 패스에 추가하는지, 플랫폼 고유의 방법을 사용합니다.

 <p> 서비스는 로드 목적을 위해서(때문에), 단일의 형태, 즉 단일의 인터페이스 또는 추상 클래스로서 표현됩니다. (구상 클래스도 사용할 수 있습니다만, 그것은 추천할 수 없습니다. ) 특정의 서비스의 프로바이더에는, 그 「서비스 타입」을 프로바이더에 고유의 데이터나 코드로 확장한, 1 개(살) 이상의 구상 클래스가 포함되어 있습니다. <i></i>일반적으로, 「프로바이더 클래스」에는, 프로바이더 자체가 모두 포함될 것은 없습니다. 요구시에 실제의 프로바이더를 작성할 수 있는 코드와 함께, 프로바이더가 특정의 요구를 채울 수가 있을지 어떨지를 식별하기 위해서 필요한 정보로 구성되는 프록시가 되어 있습니다. <i></i>프로바이더 클래스의 내용은, 개별의 서비스에 크게 의존합니다. 1 개의 클래스 또는 인터페이스로 프로바이더 클래스를 통합할 수 없습니다. 이 때문에, 이러한 형태는 여기에서는 정의되고 있지 않습니다. 이 기능이 강제하는 유일한 요구는, 프로바이더 클래스에는, 로드안에 인스턴스를 생성할 수 있도록(듯이), 인수를 취하지 않는 생성자 이 존재하지 않으면 안 되는, 이라고 하는 것입니다.

 <p><a name="format">서비스 프로바이더는, 자원 디렉토리 <tt>META-INF/services</tt> 에 「프로바이더 구성 파일」을 배치하는 것에 의해 식별됩니다. <i></i>이 파일의 이름은, 서비스의 형태의 완전 수식<a  href="../lang/ClassLoader.html#name">바이너리명</a>이 됩니다. 이 파일에는, 구상 프로바이더 클래스의 완전 수식 바이너리명이 1 행에 1 개씩 기술됩니다. 각각의 이름을 둘러싸는 공백 문자와 탭 문자, 및 공백행은 무시됩니다. 코멘트 문자는 <tt>'#'</tt> (<tt>'&#92;u0023'</tt>,<font size="-1">NUMBER SIGN</font>)입니다.  줄머리에 코멘트 문자가 삽입되고 있는 경우, 그 행의 모든 문자는 무시됩니다. 파일은 UTF-8 로 encode 되고 있을 필요가 있습니다.

 <p> 특정의 구상 프로바이더 클래스가 복수의 구성 파일내, 또는 같은 구성 파일내에서 반복해 지정되고 있는 경우, 중복 한 지정은 무시됩니다. 특정의 프로바이더를 지정한 구성 파일을, 프로바이더 자체와 같은 JAR 파일 (또는 그 외의 배포 단위) 내에 포함할 필요는 없습니다. 이 프로바이더에는, 구성 파일의 검색시에 최초로 조회된 클래스 로더로부터 액세스 할 수 없으면 안됩니다. 그 클래스 로더는, 파일이 실제로 로드 되었을 때의 클래스 로더와 동일하다라고는 한정되지 않는 것에 주의해 주세요.

 <p> 프로바이더의 검색과 인스턴스화는, 지연적으로, 즉 On Demand로 행해집니다. 서비스 로더는, 이전에 로드 된 프로바이더의 캐쉬를 유지 관리합니다. <A HREF="../../java/util/ServiceLoader.html#iterator()"><CODE>iterator</CODE></A>  메소드가 불려 갈 때마다, 반복자가 1 개 돌려주어집니다. 이 반복자는 우선, 캐쉬의 모든 요소를 인스턴스화 된 차례로 생성해, 다음에, 남아 모든 프로바이더를 지연적으로 검색해 인스턴스화해, 각 프로바이더를 순서에 캐쉬에 추가합니다. <A HREF="../../java/util/ServiceLoader.html#reload()"><CODE>reload</CODE></A>  메소드를 사용하면, 캐쉬를 클리어 할 수 있습니다.

 <p> 서비스 로더는 항상, 호출원의 시큐리티 문맥내에서 실행됩니다. 신뢰할 수 있는 시스템 코드는 일반적으로, 이 클래스내의 메소드나 그러한 메소드로부터 반환되는 반복자의 메소드를, 특권 첨부의 시큐리티 문맥내로부터 호출해야 합니다.

 <p> 이 클래스의 인스턴스는, 복수의 thread로 병행해 사용할 수 없습니다.

 <p> 특히 지정되어 있지 않은 한, 이 클래스내의 메소드에 <tt>null</tt> 인수를 건네주면(자),<A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스"><CODE>NullPointerException</CODE></A>  가 throw 됩니다.


 <p><span style="font-weight: bold; padding-right: 1em">예</span> 있는 프로토콜용의 일련의 엔코더/디코더 페어를 표현하기 위해서 설계된 서비스 타입 <tt>com.example.CodecSet</tt> 가 있다고 합니다. 이 경우, 그것은 다음의 2 개의 추상 메소드를 포함한 추상 클래스입니다.

 <blockquote><pre>
 public abstract Encoder getEncoder(String encodingName);
 public abstract Decoder getDecoder(String encodingName);</pre></blockquote>

각 메소드는 적절한 객체를 돌려줍니다. 다만, 프로바이더가 지정된 인코딩을 지원하지 않는 경우는 <tt>null</tt> 를 돌려줍니다. 일반적으로의 프로바이더에서는, 복수의 인코딩이 지원되고 있습니다.

 <p> <tt>com.example.impl.StandardCodecs</tt> 가 <tt>CodecSet</tt> 서비스의 구현의 1 개인 경우, 그 JAR 파일에는 다음의 이름의 파일도 포함되어 있습니다.

 <blockquote><pre>
 META-INF/services/com.example.CodecSet</pre></blockquote>

 <p> 이 파일에는, 다음의 행이 포함됩니다.

 <blockquote><pre>
 com.example.impl.StandardCodecs    # Standard codecs</pre></blockquote>

 <p> <tt>CodecSet</tt> 클래스는, 초기화시에 단일의 서비스 인스턴스를 작성 및 보존합니다.

 <blockquote><pre>
 private static ServiceLoader&lt;CodecSet&gt; codecSetLoader
     = ServiceLoader.load(CodecSet.class);</pre></blockquote>

 <p> 지정된 인코딩명에 대응하는 엔코더를 검색하기 위해서, 그것은 static 팩토리 메소드를 정의합니다. 이 메소드는, 기존으로 사용 가능한 프로바이더에 대해서 반복 처리를 실행해, 적절한 엔코더가 발견되었는지 프로바이더의 유효기간이 끊어졌을 경우에게만 리턴 합니다.

 <blockquote><pre>
 public static Encoder getEncoder(String encodingName) {
     for (CodecSet cp : codecSetLoader) {
         Encoder enc = cp.getEncoder(encodingName);
         if (enc ! = null)
             return enc;
     }
     return null;
 }</pre></blockquote>

 <p> <tt>getDecoder</tt> 메소드도 이와 같이 정의됩니다.


 <p><span style="font-weight: bold; padding-right: 1em">사용상의 주의점</span> 프로바이더의 로드에 사용되는 클래스 로더의 클래스 패스에 원격 네트워크 URL 가 포함되어 있는 경우, 프로바이더 구성 파일의 검색중에 그러한 URL 가 간접 참조됩니다.

 <p> 이 활동은 정상적입니다만, 그 경우, Web 서버의 로그내에 불가해한 엔트리가 작성될 가능성이 있습니다. 다만, Web 서버가 올바르게 구성되어 있지 않은 경우에는, 이 활동에 의해 프로바이더 로드 알고리즘이 의사적으로 실패할 가능성이 있습니다.

 <p> 요구된 자원이 존재하지 않는 경우, Web 서버는 HTTP 404 (Not Found) 응답을 돌려주어야 합니다. 그런데 , Web 서버 속에는, 그러한 경우에 HTTP 200 (OK) 응답과 유용한 HTML 에러 페이지를 돌려주도록(듯이), 잘못해 구성되어 있는 것도 있습니다. 그 경우, 이 클래스가 그 HTML 페이지를 프로바이더 구성 파일로서 해석하려고 한 시점에서,<A HREF="../../java/util/ServiceConfigurationError.html" title="java.util 안의 클래스"><CODE>ServiceConfigurationError</CODE></A>  가 throw 됩니다. 이 문제의 최선의 해결책은, 잘못해 구성된 Web 서버가 올바른 응답 코드 (HTTP 404)와 HTML 에러 페이지를 돌려주도록(듯이), 수정하는 것입니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/util/Iterator.html" title="java.util 내의 인터페이스">Iterator</A> &lt;<A HREF="../../java/util/ServiceLoader.html" title="ServiceLoader 내의 형태 파라미터">S</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/ServiceLoader.html#iterator()">iterator</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 로더의 서비스의 사용 가능한 프로바이더를, 지연적으로 로드합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;S&gt; <A HREF="../../java/util/ServiceLoader.html" title="java.util 내의 클래스">ServiceLoader</A> &lt;S&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/ServiceLoader.html#load(java.lang.Class)">load</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;S&gt;&nbsp;service)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 서비스 타입의 새로운 서비스 로더를, 현재의 thread의 <A HREF="../../java/lang/Thread.html#getContextClassLoader()">문맥 클래스 로더</A>  를 사용해 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;S&gt; <A HREF="../../java/util/ServiceLoader.html" title="java.util 내의 클래스">ServiceLoader</A> &lt;S&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/ServiceLoader.html#load(java.lang.Class, java.lang.ClassLoader)">load</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;S&gt;&nbsp;service,
     <A HREF="../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 서비스 타입과 클래스 로더에 대응하는 새로운 서비스 로더를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;S&gt; <A HREF="../../java/util/ServiceLoader.html" title="java.util 내의 클래스">ServiceLoader</A> &lt;S&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/ServiceLoader.html#loadInstalled(java.lang.Class)">loadInstalled</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;S&gt;&nbsp;service)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 서비스 타입의 새로운 서비스 로더를, 확장 클래스 로더를 사용해 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/ServiceLoader.html#reload()">reload</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 로더의 프로바이더 캐쉬를 클리어 해, 모든 프로바이더가 재로드 되도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/ServiceLoader.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 서비스를 기술한 캐릭터 라인을 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="reload()"><!-- --></A> <H3>
reload</H3>
<PRE>
public void <B>reload</B>()</PRE>
<DL>
<DD>이 로더의 프로바이더 캐쉬를 클리어 해, 모든 프로바이더가 재로드 되도록(듯이) 합니다.

 <p> 이 메소드가 불려 가면(자),<A HREF="../../java/util/ServiceLoader.html#iterator()"><CODE>iterator</CODE></A>  메소드의 후속의 호출은, 작성된지 얼마 안된 로더가 실시하는 것 멈춘 구 같이 프로바이더를 처음부터 지연적으로 검색 및 인스턴스화합니다.

 <p> 이 메소드는, 실행중의 Java 가상 머신내에 새로운 프로바이더를 인스톨 할 수 있는 것 같은 상황으로 사용하기 위한의 것입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="iterator()"><!-- --></A> <H3>
iterator</H3>
<PRE>
public <A HREF="../../java/util/Iterator.html" title="java.util 내의 인터페이스">Iterator</A> &lt;<A HREF="../../java/util/ServiceLoader.html" title="ServiceLoader 내의 형태 파라미터">S</A> &gt; <B>iterator</B>()</PRE>
<DL>
<DD>이 로더의 서비스의 사용 가능한 프로바이더를, 지연적으로 로드합니다.

 <p> 이 메소드로부터 반환되는 반복자는 우선, 프로바이더 캐쉬의 모든 요소를 인스턴스화 된 차례로 생성합니다. 다음에, 반복자는 남아 모든 프로바이더를 지연적으로 로드해 인스턴스화해, 각 프로바이더를 순서에 캐쉬에 추가합니다.

 <p> 지연성을 실현하기 위해서(때문에), 사용 가능한 프로바이더 구성 파일을 해석해, 프로바이더를 인스턴스화한다고 하는 실제의 작업은, 반복자 자체에 의해 행해집니다. 따라서, 그 <A HREF="../../java/util/Iterator.html#hasNext()"><CODE>hasNext</CODE></A>  및 <A HREF="../../java/util/Iterator.html#next()"><CODE>next</CODE></A>  메소드는, 프로바이더 구성 파일이 지정된 형식에 위반하고 있는 경우, 검색 및 인스턴스화할 수 없는 프로바이더 클래스가 프로바이더 구성 파일내로 지정되고 있었을 경우, 클래스를 인스턴스화한 결과를 서비스 타입에 대입할 수 없는 경우, 또는 다음의 프로바이더를 검색 및 인스턴스화할 때에 그 외의 모든 종류의 예외나 에러가 throw 되었을 경우에,<A HREF="../../java/util/ServiceConfigurationError.html" title="java.util 안의 클래스"><CODE>ServiceConfigurationError</CODE></A>  를 throw 할 가능성이 있습니다. 서비스 반복자를 사용하는 경우에, 완강한 코드를 기술하기 위해서 필요한 (일)것은,<A HREF="../../java/util/ServiceConfigurationError.html" title="java.util 안의 클래스"><CODE>ServiceConfigurationError</CODE></A>  를 캐치 하는 것 뿐입니다.

 <p> 그러한 에러가 throw 되었을 경우, 반복자의 후속의 호출은 최선의 노력을 다해, 다음에 사용 가능한 프로바이더를 검색 및 인스턴스화하려고 합니다만, 일반적으로, 그러한 복구는 반드시 성공한다고는인가 선.

<blockquote style="font-size: smaller; line-height: 1.2"><span  style="padding-right: 1em; font-weight: bold">설계상의 주의점</span> 이러한 경우에 에러를 throw 하는 것은, 극단적으로 보일지도 모릅니다. 이러한 동작이 되어 있는 이유는, 부정한 프로바이더 구성 파일은 부정한 클래스 파일과 같이, Java 가상 머신의 구성 방법이나 사용 방법에 관한 심각한 문제를 나타내고 있는 것에 있습니다. 이 때문에, 복구하려고 하거나 한층 더 나쁜 것에 아무 통지도 없게 실패하거나 하는 것보다도, 에러를 throw 하는 것을 추천합니다. </blockquote>

 <p> 이 메소드로부터 반환되는 반복자는, 삭제를 지원하지 않습니다. 그 <A HREF="../../java/util/Iterator.html#remove()"><CODE>remove</CODE></A>  메소드를 호출하면(자),<A HREF="../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A>  가 throw 됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/lang/Iterable.html" title="java.lang 내의 인터페이스">Iterable</A> &lt;<A HREF="../../java/util/ServiceLoader.html" title="ServiceLoader 내의 형태 파라미터">S</A> &gt;</CODE> 내의 <CODE><A HREF="../../java/lang/Iterable.html#iterator()">iterator</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 로더의 서비스의 프로바이더를 지연적으로 로드하는 반복자</DL>
</DD>
</DL>
<HR>

<A NAME="load(java.lang.Class, java.lang.ClassLoader)"><!-- --></A> <H3>
load</H3>
<PRE>
public static &lt;S&gt; <A HREF="../../java/util/ServiceLoader.html" title="java.util 내의 클래스">ServiceLoader</A> &lt;S&gt; <B>load</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;S&gt;&nbsp;service,
                                        <A HREF="../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader)</PRE>
<DL>
<DD>지정된 서비스 타입과 클래스 로더에 대응하는 새로운 서비스 로더를 작성합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>service</CODE> - 서비스를 나타내는 인터페이스 또는 추상 클래스<DD><CODE>loader</CODE> - 프로바이더 구성 파일과 프로바이더 클래스의 로드에 사용하는 클래스 로더. 시스템 클래스 로더 (그것이 실패했을 경우는 bootstrap 클래스 로더)를 사용하는 경우는 <tt>null</tt>
<DT><B>반환값:</B><DD>새로운 서비스 로더</DL>
</DD>
</DL>
<HR>

<A NAME="load(java.lang.Class)"><!-- --></A> <H3>
load</H3>
<PRE>
public static &lt;S&gt; <A HREF="../../java/util/ServiceLoader.html" title="java.util 내의 클래스">ServiceLoader</A> &lt;S&gt; <B>load</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;S&gt;&nbsp;service)</PRE>
<DL>
<DD>지정된 서비스 타입의 새로운 서비스 로더를, 현재의 thread의 <A HREF="../../java/lang/Thread.html#getContextClassLoader()">문맥 클래스 로더</A>  를 사용해 작성합니다.

 <p> 이 메소드를 다음의 형식에서 호출하면(자), 상기의 동작을 합니다.

 <blockquote><pre>
 ServiceLoader.load(<i>service</i>)</pre></blockquote>

이것은, 다음과 같이 지정하는 것과 같습니다.

 <blockquote><pre>
 ServiceLoader.load(<i>service</i>,
                    Thread.currentThread(). getContextClassLoader())</pre></blockquote>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>service</CODE> - 서비스를 나타내는 인터페이스 또는 추상 클래스
<DT><B>반환값:</B><DD>새로운 서비스 로더</DL>
</DD>
</DL>
<HR>

<A NAME="loadInstalled(java.lang.Class)"><!-- --></A> <H3>
loadInstalled</H3>
<PRE>
public static &lt;S&gt; <A HREF="../../java/util/ServiceLoader.html" title="java.util 내의 클래스">ServiceLoader</A> &lt;S&gt; <B>loadInstalled</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;S&gt;&nbsp;service)</PRE>
<DL>
<DD>지정된 서비스 타입의 새로운 서비스 로더를, 확장 클래스 로더를 사용해 작성합니다.

 <p> 이 편리한 메소드는 단순하게, 확장 클래스 로더를 검색해 (이것을 <tt><i>extClassLoader</i></tt> 로 한다), 다음의 값을 돌려줍니다.

 <blockquote><pre>
 ServiceLoader.load(<i>service</i>, <i>extClassLoader</i>)</pre></blockquote>

 <p> 확장 클래스 로더가 발견되지 않는 경우는 시스템 클래스 로더가 사용되어 시스템 클래스 로더가 존재하지 않는 경우는 bootstrap 클래스 로더가 사용됩니다.

 <p> 이 메소드는, 인스톨 끝난 프로바이더만이 필요한 경우에 사용하기 위한의 것입니다. 결과적으로 얻을 수 있는 서비스는, 현재의 Java 가상 머신에 인스톨 되고 있는 프로바이더만을 검색 및 로드합니다. 어플리케이션의 클래스 패스상의 프로바이더는 무시됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>service</CODE> - 서비스를 나타내는 인터페이스 또는 추상 클래스
<DT><B>반환값:</B><DD>새로운 서비스 로더</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 서비스를 기술한 캐릭터 라인을 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>설명문자열</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ServiceLoader.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/util/ServiceConfigurationError.html" title="java.util 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/util/Set.html" title="java.util 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/util/ServiceLoader.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ServiceLoader.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
