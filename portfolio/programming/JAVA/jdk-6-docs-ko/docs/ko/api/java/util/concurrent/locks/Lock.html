<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:01:04 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Lock (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Lock (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Lock.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/LockSupport.html" title="java.util.concurrent.locks 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/locks/Lock.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Lock.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent.locks</FONT>
<BR>
인터페이스 Lock</H2>
<DL>
<DT><B>기존의 구현 클래스의 일람:</B> <DD><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 내의 클래스">ReentrantLock</A> , <A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 안의 클래스">ReentrantReadWriteLock.ReadLock</A> , <A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" title="java.util.concurrent.locks 안의 클래스">ReentrantReadWriteLock.WriteLock</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public interface <B>Lock</B></DL>
</PRE>

<P>
<code>Lock</code> 구현은,<code>synchronized</code> 의 메소드나 문장을 사용하는 것으로 취득 가능한 락 조작보다 광범위한 락 조작을 제공합니다. 이 구현을 사용하면(자), 보다 유연한 구조나 완전히 다른 프로퍼티을 보관 유지하거나 관련하는 복수 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 중의 인터페이스"><CODE>Condition</CODE></A>  객체를 지원할 수 있게 됩니다.

 <p>락은, 복수의 thread에 의한 공유 자원에의 액세스를 제어하기 위한 툴입니다. 일반적으로, 락은 공유 자원에의 배타적인 액세스를 제공합니다. 락을 취득할 수 있는 것은 한 번에 1 개의 thread 뿐이어서, 모든 공유 자원에 액세스 하려면  락을 최초로 취득할 필요가 있습니다. 다만,<A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>ReadWriteLock</CODE></A>  의 read 락등의 일부의 락에서는, 공유 자원에의 병행 액세스가 허가되는 경우가 있습니다.

 <p><code>synchronized</code> 메소드나 문장의 사용에 의해, 각 객체에 관련지을 수 있었던 암묵의 감시 락에의 액세스를 제공할 수 있습니다만, 락의 취득 및 해제은 모두 블록 구조에 따라 실시하는 것이 요구됩니다. 이 때문에, 복수의 락이 취득되었을 경우, 그 해제은 취득과는 반대의 순서로 실시할 필요가 있습니다. 또, 모든 락의 해제은, 그것들이 취득된 범위내에서 실시할 필요가 있습니다.

 <p><code>synchronized</code> 메소드 및 문장의 범위 기구는, 감시 락의 프로그래밍을 큰폭으로 용이하게함과 함께, 락에 관련한 일반적인 프로그래밍 에러의 대부분을 피하는데 도움이 됩니다만, 락의 조작을 보다 유연하게 실시할 필요가 있는 상황이 존재합니다. 예를 들어, 데이터 구조에 병행해 액세스 하는 일부의 traversal 알고리즘에서는, 「hand-over-hand」또는 「chain locking」를 사용할 필요가 있습니다. 이 경우, 노드 A 의 락을 취득해, 다음에 노드 B 의 락을 취득해, 다음에 A 를 해제해 C 를 취득해, 다음에 B 를 해제해 D 를 취득한다, 라고 하는 상태에 처리를 진행시킵니다. <code>Lock</code> 인터페이스를 구현하면(자), 다른 스코프내에서 락을 취득 및 해제하거나 복수의 락을 임의의 순서로 취득 및 해제하는 것이 가능하게 되기 (위해)때문에, 이런 종류의 테크닉을 이용할 수 있게 됩니다.

 <p>이와 같이 유연성이 높아지면(자), 새로운 책임도 발생합니다. 블록 구조 락이 존재하지 않게 되는 것으로,<code>synchronized</code> 메소드 및 문장으로 실행되는 락의 자동 해제이 기능하지 않게 됩니다. 대부분의 경우, 다음의 코드를 사용할 필요가 있습니다.

 <pre><tt>     Lock l = ...;
     l.lock();
     try {
         // access the resource protected by this lock
     } finally {
         l.unlock();
     }
 </tt></pre>

락 및 락 해제가 다른 스코프내에서 행해지는 경우, 락의 보관 유지중에 실행되는 모든 코드가 try-finally 또는 try-catch 에 의해 보호되어 필요에 따라서 락이 확실히 해제되도록(듯이) 주위를 기울일 필요가 있습니다.

 <p><code>Lock</code> 구현은, 락 (<A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock()"><CODE>tryLock()</CODE></A> )를 취득하기 위한 비블록 시행, 끼어들어 가능한 락 (<A HREF="../../../../java/util/concurrent/locks/Lock.html#lockInterruptibly()"><CODE>lockInterruptibly()</CODE></A>  나 타임 아웃 가능한 락 (<A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock(long, java.util.concurrent.TimeUnit)"><CODE>tryLock(long, TimeUnit)</CODE></A> )를 취득하는 시행을 제공하는 것으로써,<code>synchronized</code> 메소드 및 문장에의 추가 기능을 제공합니다.

 <p><code>Lock</code> 클래스는, 보증된 순서 붙여 재입 불가능한 사용, 데드락의 검출 등, 암묵의 감시 락과는 완전히 다른 동작이나 시멘틱스를 제공할 수 있습니다. 구현이 이러한 특수 시멘틱스를 제공하는 경우, 구현은 이러한 시멘틱스를 문서화할 필요가 있습니다.

 <p><code>Lock</code> 인스턴스는 일반적으로의 객체에 지나지 않고, 그 자체를 <code>synchronized</code> 문의 타겟으로서 사용할 수 있는 것에 유의해 주세요. <code>Lock</code> 인스턴스의 감시 락을 취득하는 것으로, 그 인스턴스의 몇개의 <A HREF="../../../../java/util/concurrent/locks/Lock.html#lock()"><CODE>lock()</CODE></A>  메소드를 호출하는 것으로는, 특히 관계가 없습니다. 혼란을 피하기 (위해)때문에, 독자적인 구현 이외에서는, 이러한 방법으로 <code>Lock</code> 인스턴스를 결코 사용하지 않는 것을 추천합니다.

 <p>특히 명기되어 있지 않은 한, 몇개의 파라미터에 대해 <code>null</code> 치를 건네주면(자),<A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스"><CODE>NullPointerException</CODE></A>  가 throw 됩니다.

<h3>메모리의 동기화</h3>

 <p>모든 <code>Lock</code> 구현은,<a href="http://java.sun.com/docs/books/jls/">「Java 언어 스펙 제 3 판 (17.4 메모리 모델)」</a>에 기술되고 있도록(듯이), 편입 감시 락이 제공하는 것과 같은 메모리 동기 시멘틱스를 시행할 필요가 있습니다. <em></em>
 <ul>
<li>성공하는 <code>lock</code> 조작은, 성공하는 <em>Lock</em> 액션과 같은 메모리 동기 효과가 있다.
<li>성공하는 <code>unlock</code> 조작은, 성공하는 <em>Unlock</em> 액션과 같은 메모리 동기 효과가 있다.
 </ul>

성공하지 않는 락 및 락 해제 조작, 및 재입 가능한 락/락 해제 조작은, 메모리 동기 효과를 일절 필요로 하지 않습니다.

<h3>구현상의 고려사항</h3>

 <p> 락 취득의 3 개의 형식 (인터럽트가능, 인터럽트 불가, 및 시각 지정)에서는, 퍼포먼스 특성, 순서부의 보증, 다른 구현 품질이 다릅니다. 또, 「진행중의」락 취득에의 끼어들어 기능도, 지정된 <code>Lock</code> 클래스에서는 사용할 수 없습니다. <em></em>이 때문에, 3 개의 락 취득 형식 모두로, 구현이 엄밀하게 같은 보증이나 시멘틱스를 정의할 필요는 없습니다. 또, 진행중의 락 취득의 인터럽트를 지원할 필요도 없습니다. 구현은, 각 락 메소드의 제공하는 시멘틱스 및 보증을 명확하게 문서화할 필요가 있습니다. 또, 락 취득의 인터럽트가 지원되는 범위내 (전체 또는 메소드 엔트리만)에서, 이 인터페이스로 정의된 인터럽트 시멘틱스에 따를 필요도 있습니다.

 <p>일반적으로, 인터럽트는 취소를 의미해, 인터럽트의 체크는 빈번하게 행해지는 것은 아니기 때문에, 구현은 일반적으로의 메소드 복귀에 대한 인터럽트에 긍정적으로 응답할 수 있습니다. 이것은, 다른 액션이 thread를 블록 해제한 뒤에, 인터럽트가 발생했던 것(적)이 나타나는 경우에도 들어맞읍니다. 구현은, 이 동작을 문서화할 필요가 있습니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 내의 클래스"><CODE>ReentrantLock</CODE></A> , 
<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A> , 
<A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>ReadWriteLock</CODE></A> </DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Lock.html#lock()">lock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;락을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Lock.html#lockInterruptibly()">lockInterruptibly</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread가 <A HREF="../../../../java/lang/Thread.html#interrupt()">interrupted</A>  가 아닌 한, 락을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스">Condition</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Lock.html#newCondition()">newCondition</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Lock</code> 인스턴스에 바인드 된 신규 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스"><CODE>Condition</CODE></A>  를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock()">tryLock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;호출시에 락되어 있지 않은 경우에게만, 락을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock(long, java.util.concurrent.TimeUnit)">tryLock</A> </B>(long&nbsp;time,
        <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 대기 시간내에 락이 이용 가능하고, 현재의 thread로<A HREF="../../../../java/lang/Thread.html#interrupt()">인터럽트</a>가 발생하고 있지 않는 경우에, 락을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Lock.html#unlock()">unlock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락을 해제합니다. </TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="lock()"><!-- --></A> <H3>
lock</H3>
<PRE>
void <B>lock</B>()</PRE>
<DL>
<DD>락을 가져옵니다.

 <p>락을 사용할 수 없는 경우, 현재의 thread는 thread의 스케줄링에 관해서 무효가 되어, 락이 취득될 때까지 대기합니다.

 <p><b>구현상의 고려사항</b>

 <p><code>Lock</code> 구현은, 데드락을 일으키는 호출등의 락의 부정사용을 검출해, 그러한 상황으로 (체크되지 않는다) 예외를 throw 할 수 있습니다. <code>Lock</code> 구현에 의해, 해당하는 상황 및 예외의 형태를 문서화할 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lockInterruptibly()"><!-- --></A> <H3>
lockInterruptibly</H3>
<PRE>
void <B>lockInterruptibly</B>()
                       throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>현재의 thread가 <A HREF="../../../../java/lang/Thread.html#interrupt()">interrupted</A>  가 아닌 한, 락을 가져옵니다.

 <p>이용 가능한 경우에 락을 취득해, 곧바로 복귀합니다.

 <p>락을 사용할 수 없는 경우, 현재의 thread는 thread의 스케줄링에 관해서 무효가 되어, 다음의 2 개중 한쪽이 일어날 때까지 대기합니다.

 <ul>
<li>현재의 thread에 의해 락이 취득된다.
<li>다른 thread가 현재의 thread에<A HREF="../../../../java/lang/Thread.html#interrupt()">인터럽트</a>를 실시해, 락 취득의 인터럽트가 지원된다.
 </ul>

 <p>현재의 thread로,
 <ul>
<li>이 메소드에의 엔트리상에서 설정된 인터럽트 상태가 보관 유지되는지,
<li>락의 취득 및 락 취득의 중단이 지원되고 있는 상황으로,<A HREF="../../../../java/lang/Thread.html#interrupt()">인터럽트</a>가 발생하는 경우,
 </ul>
<A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스"><CODE>InterruptedException</CODE></A>  가 throw 되어 현재의 thread의 인터럽트 상태가 클리어 됩니다.

 <p><b>구현상의 고려사항</b>

 <p>어느 상황하에서는 락 취득에 끼어들지 못하고, 경우에 따라서는 부하의 큰 조작이 되는 경우가 있습니다. 프로그래머는, 이러한 경우가 있는 것을 의식해 둘 필요가 있습니다. 구현은, 해당하는 상황을 문서화할 필요가 있습니다.

 <p>구현은, 일반적으로의 메소드 복귀에 대한 인터럽트에 긍정적으로 응답할 수 있습니다.

 <p><code>Lock</code> 구현은, 데드락을 일으키는 호출등의 락의 부정사용을 검출해, 그러한 상황으로 (체크되지 않는다) 예외를 throw 할 수 있습니다. <code>Lock</code> 구현에 의해, 해당하는 상황 및 예외의 형태를 문서화할 필요가 있습니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 락의 취득중 ( 및 락 취득의 중단이 지원되고 있는 상황)에, 현재의 thread로 인터럽트가 발생하는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryLock()"><!-- --></A> <H3>
tryLock</H3>
<PRE>
boolean <B>tryLock</B>()</PRE>
<DL>
<DD>호출시에 락되어 있지 않은 경우에게만, 락을 가져옵니다.

 <p>가능한 경우에 락을 취득해, 값 <code>true</code> 로 곧바로 복귀합니다. 락이 이용 가능하지 않은 경우, 이 메소드는 값 <code>false</code> 로 곧바로 복귀합니다.

 <p>이 메소드의 일반적으로의 사용 방법을 다음에 나타냅니다.
 <pre>
      Lock lock = ...;
      if (lock.tryLock()) {
          try {
              // manipulate protected state
          } finally {
              lock.unlock();
          }
      } else {
          // perform alternative actions
      }
 </pre>
이 사용에 의해, 락이 취득되었을 경우에 락이 해제되는 것, 및 락이 취득되지 않았던 경우에 락 해제를 시도하지 않는 것이 보증됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>락이 취득되었을 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="tryLock(long, java.util.concurrent.TimeUnit)"><!-- --></A> <H3>
tryLock</H3>
<PRE>
boolean <B>tryLock</B>(long&nbsp;time,
                <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)
                throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>지정된 대기 시간내에 락이 이용 가능하고, 현재의 thread로<A HREF="../../../../java/lang/Thread.html#interrupt()">인터럽트</a>가 발생하고 있지 않는 경우에, 락을 가져옵니다.

 <p>락이 이용 가능한 경우, 이 메소드는 즉시 값 <code>true</code> 로 복귀합니다. 락을 이용할 수 없는 경우, 현재의 thread가 thread 스케줄링에 관해서 무효가 되어, 다음의 3 개중 한쪽이 일어날 때까지 대기합니다.
 <ul>
<li>현재의 thread에 의해 락이 취득된다.
<li>다른 thread가 현재의 thread에<A HREF="../../../../java/lang/Thread.html#interrupt()">인터럽트</a>를 실시해, 락 취득의 인터럽트가 지원된다.
<li>지정된 대기 시간이 경과한다.
 </ul>

 <p>락이 취득되면(자),<code>true</code> 가 돌려주어집니다.

 <p>현재의 thread로,
 <ul>
<li>이 메소드에의 엔트리상에서 설정된 인터럽트 상태가 보관 유지되는지,
<li>락의 취득 및 락 취득의 중단이 지원되고 있는 상황으로,<A HREF="../../../../java/lang/Thread.html#interrupt()">인터럽트</a>가 발생하는 경우,
 </ul>
<A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스"><CODE>InterruptedException</CODE></A>  가 throw 되어 현재의 thread의 인터럽트 상태가 클리어 됩니다.

 <p>지정된 대기 시간이 경과하면(자), 값 <code>false</code> 가 돌려주어집니다. 시간이 제로 또는 그것보다 작은 경우, 메소드는 대기하지 않습니다.

 <p><b>구현상의 고려사항</b>

 <p>어느 상황하에서는 락 취득에 끼어들지 못하고, 경우에 따라서는 부하의 큰 조작이 되는 경우가 있습니다. 프로그래머는, 이러한 경우가 있는 것을 의식해 둘 필요가 있습니다. 구현은, 해당하는 상황을 문서화할 필요가 있습니다.

 <p>구현은, 일반적으로의 메소드 복귀에 대한 인터럽트, 또는 타임 아웃의 리포트에 긍정적으로 응답할 수 있습니다.

 <p><code>Lock</code> 구현은, 데드락을 일으키는 호출등의 락의 부정사용을 검출해, 그러한 상황으로 (체크되지 않는다) 예외를 throw 할 수 있습니다. <code>Lock</code> 구현에 의해, 해당하는 상황 및 예외의 형태를 문서화할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>time</CODE> - 락의 최장 대기 시간<DD><CODE>unit</CODE> - <code>time</code> 인수의 시간 단위
<DT><B>반환값:</B><DD>락이 취득되었을 경우는 <code>true</code>, 락이 취득되기 전에 대기 시간이 경과했을 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 락의 취득중 ( 및 락 취득의 중단이 지원되고 있는 상황)에, 현재의 thread로 인터럽트가 발생하는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="unlock()"><!-- --></A> <H3>
unlock</H3>
<PRE>
void <B>unlock</B>()</PRE>
<DL>
<DD>이 락을 해제합니다.

 <p><b>구현상의 고려사항</b>

 <p>일반적으로,<code>Lock</code> 구현은, 락을 해제 가능한 thread에 관해서 제한을 부과해 (일반적으로, 락의 홀더만을 해제할 수 있다), 제한이 침범되었을 경우에는 (체크되지 않는다) 예외를 throw 할 수 있습니다. <code>Lock</code> 구현에 의해, 제한 및 예외의 형태를 문서화할 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="newCondition()"><!-- --></A> <H3>
newCondition</H3>
<PRE>
<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A>  <B>newCondition</B>()</PRE>
<DL>
<DD>이 <code>Lock</code> 인스턴스에 바인드 된 신규 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스"><CODE>Condition</CODE></A>  를 돌려줍니다.

 <p>상태의 대기를 실행하기 전에, 현재의 thread가 락을 보관 유지할 필요가 있습니다. <A HREF="../../../../java/util/concurrent/locks/Condition.html#await()"><CODE>Condition.await()</CODE></A>  에의 호출에 의해, 대기가 복귀하기 전에 락을 대기 및 재취득하기 전에, 락이 원자적으로 해제됩니다.

 <p><b>구현상의 고려사항</b>

 <p><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A>  인스턴스의 엄밀한 조작은 <code>Lock</code> 구현에 의존하기 위해(때문에), 구현에 의해 문서화할 필요가 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>Lock</code> 인스턴스용의 신규 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스"><CODE>Condition</CODE></A> 
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <code>Lock</code> 구현이 상태를 지원하지 않는 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Lock.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/LockSupport.html" title="java.util.concurrent.locks 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/locks/Lock.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Lock.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
