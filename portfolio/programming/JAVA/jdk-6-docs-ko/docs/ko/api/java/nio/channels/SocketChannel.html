<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:57:50 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
SocketChannel (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SocketChannel (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SocketChannel.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/nio/channels/ServerSocketChannel.html" title="java.nio.channels 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/nio/channels/UnresolvedAddressException.html" title="java.nio.channels 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/nio/channels/SocketChannel.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="SocketChannel.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.nio.channels</FONT>
<BR>
클래스 SocketChannel</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html" title="java.nio.channels.spi 내의 클래스">java.nio.channels.spi.AbstractInterruptibleChannel</A> 
      <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../java/nio/channels/SelectableChannel.html" title="java.nio.channels 내의 클래스">java.nio.channels.SelectableChannel</A> 
          <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html" title="java.nio.channels.spi 내의 클래스">java.nio.channels.spi.AbstractSelectableChannel</A> 
              <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.nio.channels.SocketChannel</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/io/Closeable.html" title="java.io 내의 인터페이스">Closeable</A> , <A HREF="../../../java/nio/channels/ByteChannel.html" title="java.nio.channels 안의 인터페이스">ByteChannel</A> , <A HREF="../../../java/nio/channels/Channel.html" title="java.nio.channels 안의 인터페이스">Channel</A> , <A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 안의 인터페이스">GatheringByteChannel</A> , <A HREF="../../../java/nio/channels/InterruptibleChannel.html" title="java.nio.channels 안의 인터페이스">InterruptibleChannel</A> , <A HREF="../../../java/nio/channels/ReadableByteChannel.html" title="java.nio.channels 안의 인터페이스">ReadableByteChannel</A> , <A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 안의 인터페이스">ScatteringByteChannel</A> , <A HREF="../../../java/nio/channels/WritableByteChannel.html" title="java.nio.channels 안의 인터페이스">WritableByteChannel</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>SocketChannel</B><DT>extends <A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html" title="java.nio.channels.spi 내의 클래스">AbstractSelectableChannel</A> <DT>implements <A HREF="../../../java/nio/channels/ByteChannel.html" title="java.nio.channels 내의 인터페이스">ByteChannel</A> , <A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 안의 인터페이스">ScatteringByteChannel</A> , <A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 안의 인터페이스">GatheringByteChannel</A> </DL>
</PRE>

<P>
스트림형 접속 소켓용의 선택 가능 채널입니다.
 
 <p> 소켓 채널은, 접속 네트워크 소켓의 완전한 추상화가 아닙니다. 소켓 옵션의 바인드, 종료, 및 조작은,<A HREF="../../../java/nio/channels/SocketChannel.html#socket()"><CODE>socket</CODE></A>  메소드 호출에 의해 취득한 관련 <A HREF="../../../java/net/Socket.html" title="java.net 내의 클래스"><CODE>Socket</CODE></A>  객체를 개입시켜 실시할 필요가 있습니다. 임의의 기존 소켓의 채널을 작성하거나 소켓 채널에 관련한 소켓으로 <A HREF="../../../java/net/SocketImpl.html" title="java.net 안의 클래스"><CODE>SocketImpl</CODE></A>  객체를 사용하도록(듯이) 지정할 수 없습니다.

 <p> 소켓 채널은, 이 클래스의 <A HREF="../../../java/nio/channels/SocketChannel.html#open()"><CODE>open</CODE></A>  메소드중 1 개(살)을 호출하는 것에 의해 작성할 수 있습니다. 새롭게 작성된 소켓 채널은 오픈입니다만, 접속은 확립되어 있지 않습니다. 미접속의 채널에 대해서 입력 조작을 호출하려고 하면(자),<A HREF="../../../java/nio/channels/NotYetConnectedException.html" title="java.nio.channels 안의 클래스"><CODE>NotYetConnectedException</CODE></A>  가 throw 됩니다. 소켓 채널을 접속하려면 , 그 <A HREF="../../../java/nio/channels/SocketChannel.html#connect(java.net.SocketAddress)"><CODE>connect</CODE></A>  메소드를 호출합니다. 접속된 소켓 채널은, 클로즈 할 때까지 접속된 채로 있습니다. 소켓 채널이 접속되고 있을지 어떨지는,<A HREF="../../../java/nio/channels/SocketChannel.html#isConnected()"><CODE>isConnected</CODE></A>  메소드의 호출에 의해 판단할 수 있습니다.

 <p> 소켓 채널은 「비블록 접속」을 지원합니다. 소켓 채널의 작성과 원격 소켓에의 링크의 확립 프로세스는 <A HREF="../../../java/nio/channels/SocketChannel.html#connect(java.net.SocketAddress)"><CODE>connect</CODE></A>  메소드에 의해 개시되어 나중에 <A HREF="../../../java/nio/channels/SocketChannel.html#finishConnect()"><CODE>finishConnect</CODE></A>  메소드에 의해 완료합니다. 접속 조작이 실행중일지 어떨지는,<A HREF="../../../java/nio/channels/SocketChannel.html#isConnectionPending()"><CODE>isConnectionPending</CODE></A>  메소드의 호출에 의해 판단할 수 있습니다.

 <p> 소켓 채널의 입력측과 출력측은, 실제로 채널을 클로즈 하는 일 없이, 따로 따로 「정지」됩니다. 관련 소켓 객체의 <A HREF="../../../java/net/Socket.html#shutdownInput()"><CODE>shutdownInput</CODE></A>  메소드를 호출해 채널의 입력측을 정지한 뒤, 한층 더 채널을 읽어내려고 하면(자), 스트림의 마지막을 나타내는 <tt>-1</tt> 이 돌려주어집니다. 관련 소켓 객체의 <A HREF="../../../java/net/Socket.html#shutdownOutput()"><CODE>shutdownOutput</CODE></A>  메소드를 호출해 채널의 출력측을 정지한 뒤, 한층 더 채널에 기입하려고 하면(자),<A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스"><CODE>ClosedChannelException</CODE></A>  가 throw 됩니다.

 <p> 소켓 채널은,<A HREF="../../../java/nio/channels/Channel.html" title="java.nio.channels 안의 인터페이스"><CODE>Channel</CODE></A>  클래스로 지정되고 있는 비동기 클로즈 조작과 자주(잘) 닮은 「비동기 정지」를 지원합니다. 한편의 thread가 소켓의 채널에 대한 read 조작의 도중에 블록 되고 있는데, 이제(벌써) 한편의 thread가 소켓의 입력측을 정지했을 경우, 블록 된 thread의 read 조작은, 바이트를 일절 읽어내는 일 없이 종료해,<tt>-1</tt> 를 돌려줍니다. 한편의 thread가 소켓의 채널에 대한 기입 조작의 도중에 블록 되고 있는데, 이제(벌써) 한편의 thread가 소켓의 출력측을 정지했을 경우, 블록 된 thread는 <A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스"><CODE>AsynchronousCloseException</CODE></A>  를 받습니다.

 <p> 소켓 채널은, 복수의 병행 thread로 안전하게 사용할 수 있습니다. 데이터 그램 채널은 병행 read 및 기입을 지원합니다. 다만, read를 실시하는 thread도 기입을 실시하는 thread도 특정의 시점에서는 항상 1 개 이하입니다. <A HREF="../../../java/nio/channels/SocketChannel.html#connect(java.net.SocketAddress)"><CODE>connect</CODE></A>  메소드와 <A HREF="../../../java/nio/channels/SocketChannel.html#finishConnect()"><CODE>finishConnect</CODE></A>  메소드는 서로 동기 하고 있어, 어느 쪽인지 한편의 메소드의 호출중에 읽어들여 또는 기입해 조작을 개시하려고 하면(자), 이 처리는 최초의 호출이 완료할 때까지 블록 됩니다.   </p>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#SocketChannel(java.nio.channels.spi.SelectorProvider)">SocketChannel</A> </B>(<A HREF="../../../java/nio/channels/spi/SelectorProvider.html" title="java.nio.channels.spi 안의 클래스">SelectorProvider</A> &nbsp;provider)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 클래스의 새로운 인스턴스를 초기화합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#connect(java.net.SocketAddress)">connect</A> </B>(<A HREF="../../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;remote)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 소켓을 접속합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#finishConnect()">finishConnect</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓 채널의 접속 처리를 완료합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#isConnected()">isConnected</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 네트워크 소켓이 접속되고 있는지 어떤지를 판단합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#isConnectionPending()">isConnectionPending</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널상에서 접속 조작이 진행중인가 어떤가를 판단합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/nio/channels/SocketChannel.html" title="java.nio.channels 내의 클래스">SocketChannel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#open()">open</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓 채널을 오픈합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/nio/channels/SocketChannel.html" title="java.nio.channels 내의 클래스">SocketChannel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#open(java.net.SocketAddress)">open</A> </B>(<A HREF="../../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;remote)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓 채널을 오픈해, 원격 주소에 접속합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#read(java.nio.ByteBuffer)">read</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 바이트 순서를 지정의 버퍼에 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#read(java.nio.ByteBuffer[])">read</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 바이트 순서가 지정된 버퍼에 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#read(java.nio.ByteBuffer[], int, int)">read</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts,
     int&nbsp;offset,
     int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 바이트 순서가 지정된 버퍼의 서브 순서에 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/net/Socket.html" title="java.net 내의 클래스">Socket</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#socket()">socket</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널에 관련한 소켓을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#validOps()">validOps</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 지원되고 있는 조작을 식별하는 조작 세트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#write(java.nio.ByteBuffer)">write</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 바이트 순서를 지정의 버퍼로부터 써냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#write(java.nio.ByteBuffer[])">write</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 바이트 순서가 지정된 버퍼로부터 써냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/nio/channels/SocketChannel.html#write(java.nio.ByteBuffer[], int, int)">write</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs,
      int&nbsp;offset,
      int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 채널의 바이트 순서가 지정된 버퍼의 서브 순서로부터 써냅니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.nio.channels.spi.AbstractSelectableChannel"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.nio.channels.spi. <A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html" title="java.nio.channels.spi 안의 클래스">AbstractSelectableChannel</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html#blockingLock()">blockingLock</A> , <A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html#configureBlocking(boolean)">configureBlocking</A> , <A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html#implCloseChannel()">implCloseChannel</A> , <A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html#implCloseSelectableChannel()">implCloseSelectableChannel</A> , <A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html#implConfigureBlocking(boolean)">implConfigureBlocking</A> , <A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html#isBlocking()">isBlocking</A> , <A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html#isRegistered()">isRegistered</A> , <A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html#keyFor(java.nio.channels.Selector)">keyFor</A> , <A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html#provider()">provider</A> , <A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html#register(java.nio.channels.Selector, int, java.lang.Object)">register</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.nio.channels.SelectableChannel"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.nio.channels. <A HREF="../../../java/nio/channels/SelectableChannel.html" title="java.nio.channels 안의 클래스">SelectableChannel</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/nio/channels/SelectableChannel.html#register(java.nio.channels.Selector, int)">register</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.nio.channels.spi.AbstractInterruptibleChannel"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.nio.channels.spi. <A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html" title="java.nio.channels.spi 안의 클래스">AbstractInterruptibleChannel</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html#begin()">begin</A> , <A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html#close()">close</A> , <A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html#end(boolean)">end</A> , <A HREF="../../../java/nio/channels/spi/AbstractInterruptibleChannel.html#isOpen()">isOpen</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.nio.channels.Channel"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.nio.channels. <A HREF="../../../java/nio/channels/Channel.html" title="java.nio.channels 안의 인터페이스">Channel</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/nio/channels/Channel.html#close()">close</A> , <A HREF="../../../java/nio/channels/Channel.html#isOpen()">isOpen</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SocketChannel(java.nio.channels.spi.SelectorProvider)"><!-- --></A> <H3>
SocketChannel</H3>
<PRE>
protected <B>SocketChannel</B>(<A HREF="../../../java/nio/channels/spi/SelectorProvider.html" title="java.nio.channels.spi 안의 클래스">SelectorProvider</A> &nbsp;provider)</PRE>
<DL>
<DD>이 클래스의 새로운 인스턴스를 초기화합니다.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="open()"><!-- --></A> <H3>
open</H3>
<PRE>
public static <A HREF="../../../java/nio/channels/SocketChannel.html" title="java.nio.channels 내의 클래스">SocketChannel</A>  <B>open</B>()
                          throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>소켓 채널을 오픈합니다.

 <p> 새로운 채널을 작성하려면 , 시스템 전체의 디폴트인 <A HREF="../../../java/nio/channels/spi/SelectorProvider.html" title="java.nio.channels.spi 동안의 클래스"><CODE>SelectorProvider</CODE></A>  객체의 <A HREF="../../../java/nio/channels/spi/SelectorProvider.html#openSocketChannel()"><CODE>openSocketChannel</CODE></A>  메소드를 호출합니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>새로운 소켓 채널
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="open(java.net.SocketAddress)"><!-- --></A> <H3>
open</H3>
<PRE>
public static <A HREF="../../../java/nio/channels/SocketChannel.html" title="java.nio.channels 내의 클래스">SocketChannel</A>  <B>open</B>(<A HREF="../../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;remote)
                          throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>소켓 채널을 오픈해, 원격 주소에 접속합니다.

 <p> 이 편리한 메소드는,<A HREF="../../../java/nio/channels/SocketChannel.html#open()"><CODE>open()</CODE></A>  메소드의 호출과 같이 기능합니다. 구체적으로는, 결과적으로 얻을 수 있는 소켓 채널에 대해서 <A HREF="../../../java/nio/channels/SocketChannel.html#connect(java.net.SocketAddress)"><CODE>connect</CODE></A>  메소드를 호출해, 이것을 <tt>remote</tt> 에 건네주어, 그 채널을 돌려줍니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>remote</CODE> - 새로운 채널의 접속처 원격 주소
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 접속 조작의 진행중에, 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - 접속 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해, 현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/UnresolvedAddressException.html" title="java.nio.channels 안의 클래스">UnresolvedAddressException</A> </CODE> - 지정된 원격 주소가 완전하게 해결되지 않는 경우
<DD><CODE><A HREF="../../../java/nio/channels/UnsupportedAddressTypeException.html" title="java.nio.channels 안의 클래스">UnsupportedAddressTypeException</A> </CODE> - 지정된 원격 주소의 타입이 지원 대상외의 경우
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 인스톨 되고 있어, 지정된 원격 엔드 포인트에의 액세스가 허가되어 있지 않은 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="validOps()"><!-- --></A> <H3>
validOps</H3>
<PRE>
public final int <B>validOps</B>()</PRE>
<DL>
<DD>이 채널의 지원되고 있는 조작을 식별하는 조작 세트를 돌려줍니다.

 <p> 소켓 채널은, 접속, 읽어내, 및 기입을 지원하므로, 이 메소드는 <tt>(</tt><A HREF="../../../java/nio/channels/SelectionKey.html#OP_CONNECT"><CODE>SelectionKey.OP_CONNECT</CODE></A>  <tt>|</tt>&nbsp;<A HREF="../../../java/nio/channels/SelectionKey.html#OP_READ"><CODE>SelectionKey.OP_READ</CODE></A>  <tt>|</tt>&nbsp;<A HREF="../../../java/nio/channels/SelectionKey.html#OP_WRITE"><CODE>SelectionKey.OP_WRITE</CODE></A> <tt>)</tt> 을 돌려줍니다.   </p>
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/nio/channels/SelectableChannel.html" title="java.nio.channels 내의 클래스">SelectableChannel</A> </CODE> 내의 <CODE><A HREF="../../../java/nio/channels/SelectableChannel.html#validOps()">validOps</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>유효한 조작 세트</DL>
</DD>
</DL>
<HR>

<A NAME="socket()"><!-- --></A> <H3>
socket</H3>
<PRE>
public abstract <A HREF="../../../java/net/Socket.html" title="java.net 내의 클래스">Socket</A>  <B>socket</B>()</PRE>
<DL>
<DD>이 채널에 관련한 소켓을 가져옵니다.

 <p> 반환되는 객체는,<A HREF="../../../java/net/Socket.html" title="java.net 안의 클래스"><CODE>Socket</CODE></A>  클래스에서 선언되어 있지 않은 public 메소드는 선언하지 않습니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 채널에 관련한 소켓</DL>
</DD>
</DL>
<HR>

<A NAME="isConnected()"><!-- --></A> <H3>
isConnected</H3>
<PRE>
public abstract boolean <B>isConnected</B>()</PRE>
<DL>
<DD>이 채널의 네트워크 소켓이 접속되고 있는지 어떤지를 판단합니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 채널의 네트워크 소켓이 접속되고 있는 경우에 한해 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="isConnectionPending()"><!-- --></A> <H3>
isConnectionPending</H3>
<PRE>
public abstract boolean <B>isConnectionPending</B>()</PRE>
<DL>
<DD>이 채널상에서 접속 조작이 진행중인가 어떤가를 판단합니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 채널상에서 접속 조작이 개시되고 있어, 아직 완료하고 있지 않는 (<A HREF="../../../java/nio/channels/SocketChannel.html#finishConnect()"><CODE>finishConnect</CODE></A>  메소드가 불려 가지 않았다) 경우에 한해 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="connect(java.net.SocketAddress)"><!-- --></A> <H3>
connect</H3>
<PRE>
public abstract boolean <B>connect</B>(<A HREF="../../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;remote)
                         throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 채널의 소켓을 접속합니다.

 <p> 이 채널이 비블록 모드의 경우, 이 메소드의 호출에 의해, 비블록 접속 조작이 개시됩니다. 로컬 접속의 경우와 같이 즉석에서 접속이 확립되는 경우, 이 메소드는 <tt>true</tt> 를 돌려줍니다. 그 이외의 경우는 <tt>false</tt>  를 돌려줍니다. 이 경우는, 나중에 <A HREF="../../../java/nio/channels/SocketChannel.html#finishConnect()"><CODE>finishConnect</CODE></A>  메소드를 호출하는 것으로, 접속 조작을 완료할 필요가 있습니다.

 <p> 이 채널이 블록 모드의 경우, 이 메소드의 호출은, 접속이 확립될까 입출력 에러가 발생할 때까지 블록 됩니다.

 <p> 이 메소드는,<A HREF="../../../java/net/Socket.html" title="java.net 안의 클래스"><CODE>Socket</CODE></A>  클래스와 완전히 같은 시큐리티 체크를 실시합니다. 시큐리티 매니저가 인스톨 되고 있는 경우, 이 메소드는, 그 <A HREF="../../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)"><CODE>checkConnect</CODE></A>  메소드가 지정된 원격 엔드 포인트의 주소 및 포트 번호에의 접속을 허가하는 것을 확인합니다.

 <p> 이 메소드는 언제라도 호출할 수가 있습니다. 이 메소드를 호출하고 있는 도중에 이 채널에 대한 읽기 또는 기입해 조작을 호출했을 경우, 최초의 호출이 완료할 때까지 다음의 호출은 블록 됩니다. 접속하려고 했지만 실패했을 경우, 즉 이 메소드의 호출이 체크 예외를 throw 하는 경우, 채널은 클로즈 됩니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>remote</CODE> - 이 채널의 접속처 원격 주소
<DT><B>반환값:</B><DD>접속이 확립되었을 경우 <tt>true</tt>, 이 채널이 비블록 모드로 접속 조작의 실행중인 경우는 <tt>false</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/AlreadyConnectedException.html" title="java.nio.channels 안의 클래스">AlreadyConnectedException</A> </CODE> - 이 채널이 벌써 접속되고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/ConnectionPendingException.html" title="java.nio.channels 안의 클래스">ConnectionPendingException</A> </CODE> - 이 채널로 벌써 비블록 접속 조작이 실행중인 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 접속 조작의 진행중에, 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - 접속 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해, 현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/UnresolvedAddressException.html" title="java.nio.channels 안의 클래스">UnresolvedAddressException</A> </CODE> - 지정된 원격 주소가 완전하게 해결되지 않는 경우
<DD><CODE><A HREF="../../../java/nio/channels/UnsupportedAddressTypeException.html" title="java.nio.channels 안의 클래스">UnsupportedAddressTypeException</A> </CODE> - 지정된 원격 주소의 타입이 지원 대상외의 경우
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 인스톨 되고 있어, 지정된 원격 엔드 포인트에의 액세스가 허가되어 있지 않은 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="finishConnect()"><!-- --></A> <H3>
finishConnect</H3>
<PRE>
public abstract boolean <B>finishConnect</B>()
                               throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>소켓 채널의 접속 처리를 완료합니다.

 <p> 소켓 채널을 비블록 모드로 해, 그 <A HREF="../../../java/nio/channels/SocketChannel.html#connect(java.net.SocketAddress)"><CODE>connect</CODE></A>  메소드를 호출하면(자), 비블록 접속 조작이 개시됩니다. 접속이 확립되는지, 접속에 실패한 뒤, 소켓 채널은 접속 가능한 상태가 됩니다. 여기서, 접속 순서를 완료하기 위해서, 이 메소드가 불려 갑니다. 접속 조작에 실패했을 경우, 이 메소드를 호출하면(자) 적절한 <A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스"><CODE>IOException</CODE></A>  이 throw 됩니다.

 <p> 이 채널이 벌써 접속되고 있는 경우, 이 메소드는 블록 되어 즉시 <tt>true</tt> 를 돌려줍니다. 이 채널이 비블록 모드의 경우, 접속 처리가 아직 완료하고 있지 않으면, 이 메소드는 <tt>false</tt> 를 돌려줍니다. 이 채널이 블록 모드의 경우, 접속이 완료하는지 실패할 때까지 이 메소드는 블록 됩니다. 덧붙여 접속이 완료했을 경우는 <tt>true</tt> 가 돌려주어져 접속에 실패했을 경우는 체크 예외가 throw 됩니다.

 <p> 이 메소드는 언제라도 호출할 수가 있습니다. 이 메소드를 호출하고 있는 도중에 이 채널에 대한 읽기 또는 기입해 조작을 호출했을 경우, 최초의 호출이 완료할 때까지 다음의 호출은 블록 됩니다. 접속하려고 했지만 실패했을 경우, 즉 이 메소드의 호출이 체크 예외를 throw 하는 경우, 채널은 클로즈 됩니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 채널의 소켓이 접속되고 있는 경우에 한해 <tt>true</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/NoConnectionPendingException.html" title="java.nio.channels 안의 클래스">NoConnectionPendingException</A> </CODE> - 이 채널이 접속되지 않고, 접속 조작도 개시되어 있지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 접속 조작의 진행중에, 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - 접속 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해, 현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="read(java.nio.ByteBuffer)"><!-- --></A> <H3>
read</H3>
<PRE>
public abstract int <B>read</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)
                  throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../java/nio/channels/ReadableByteChannel.html#read(java.nio.ByteBuffer)">ReadableByteChannel</A> </CODE> 의 기술:</B></DD>
<DD>이 채널의 바이트 순서를 지정의 버퍼에 읽어들입니다.

 <p> 채널로부터 최대 <i>r</i> 바이트를 읽어내려고 합니다. <i>r</i> 는, 이 메소드를 호출할 때 버퍼내에 존재하는 바이트수,<tt>dst.remaining()</tt> 가 됩니다.

 <p> 길이 <i>n</i> (<tt>0</tt>&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>)의 바이트 순서가 읽어내진다고 합니다. 이 바이트 순서가 버퍼에 전송 되기 (위해)때문에, 순서내의 최초의 바이트의 인덱스는 <i>p</i>, 마지막 바이트의 인덱스는 <i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>&nbsp;<tt>-</tt>&nbsp;<tt>1</tt> 이 됩니다. 덧붙여<i>p</i> 는, 이 메소드를 호출할 때의 버퍼의 위치입니다. 버퍼의 위치는, 돌려주어질 때 <i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i> 에 동일해집니다. 리밋트에 변화는 없습니다.

 <p> read 조작에 의해 버퍼가 가득 된다고는인가 선. 바이트가 일절 읽어내지지 않은 경우도 있습니다. 버퍼가 가득 될지 어떨지는, 채널의 본래의 성질과 상태에 의해 결정합니다. 예를 들어 비블록 모드의 소켓은, 소켓의 입력 버퍼로부터 즉시 취득할 수 있는 바이트 이외를 읽어낼 수가 없습니다. 같이 파일 채널은, 파일내의 바이트 이외를 읽어낼 수가 없습니다. 다만, 채널이 블록 모드이며, 버퍼내의 바이트수가 1 바이트 이상의 경우, 1 바이트 이상이 읽어내질 때까지 이 메소드는 블록 되게 되어 있습니다.

 <p> 이 메소드는 언제라도 호출할 수가 있습니다. 다만, 다른 thread가 이 채널에 대해서 읽어들여 조작을 개시하고 있는 경우, 이 메소드의 호출은 최초의 조작이 끝날 때까지 블록 됩니다.  </p>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../java/nio/channels/ReadableByteChannel.html" title="java.nio.channels 내의 인터페이스">ReadableByteChannel</A> </CODE> 내의 <CODE><A HREF="../../../java/nio/channels/ReadableByteChannel.html#read(java.nio.ByteBuffer)">read</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>dst</CODE> - 바이트의 전송처 버퍼
<DT><B>반환값:</B><DD>읽힌 문자수. 제로인가, 채널이 스트림의 마지막에 이르고 있는 경우는 <tt>-1</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/NotYetConnectedException.html" title="java.nio.channels 안의 클래스">NotYetConnectedException</A> </CODE> - 이 채널이 아직 접속되어 있지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - read 조작의 진행중에, 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - read 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="read(java.nio.ByteBuffer[], int, int)"><!-- --></A> <H3>
read</H3>
<PRE>
public abstract long <B>read</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts,
                          int&nbsp;offset,
                          int&nbsp;length)
                   throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../java/nio/channels/ScatteringByteChannel.html#read(java.nio.ByteBuffer[], int, int)">ScatteringByteChannel</A> </CODE> 의 기술:</B></DD>
<DD>이 채널의 바이트 순서가 지정된 버퍼의 서브 순서에 읽어들입니다.

 <p> 이 메소드 호출은, 이 채널로부터 최대 <i>r </i> 바이트를 읽어내려고 합니다. <i>r</i> 는, 이 메소드의 호출시로 지정된 버퍼 배열의 지정된 서브 순서에 포함되는 합계 바이트수입니다.

 <blockquote><pre>
 dsts[offset]. remaining()
     + dsts[offset+1]. remaining()
     + ... + dsts[offset+length-1]. remaining()</pre></blockquote>



 <p> 길이 <i>n</i> (<tt>0</tt>&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>)의 바이트 순서가 읽어내진다고 합니다. 이 순서의 최초의 <tt>dsts[offset]. remaining()</tt> 바이트까지가 버퍼 <tt>dsts[offset]</tt> 에 전송 되어 다음의 <tt>dsts[offset+1]. remaining()</tt> 바이트까지가 버퍼 <tt>dsts[offset+1]</tt> 에 전송 됩니다. 이 처리는, 모든 바이트 순서가 지정된 버퍼에 전송 될 때까지 반복해집니다. 각 버퍼에는 최대한의 바이트가 전송 되기 (위해)때문에, 최종 갱신 버퍼를 제외한 개개의 갱신 버퍼의 최종적인 위치는, 이 버퍼의 리밋트와 동일해집니다.

 <p> 이 메소드는 언제라도 호출할 수가 있습니다. 다만, 다른 thread가 이 채널에 대해서 읽어들여 조작을 개시하고 있는 경우, 이 메소드의 호출은 최초의 조작이 끝날 때까지 블록 됩니다.  </p>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 내의 인터페이스">ScatteringByteChannel</A> </CODE> 내의 <CODE><A HREF="../../../java/nio/channels/ScatteringByteChannel.html#read(java.nio.ByteBuffer[], int, int)">read</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>dsts</CODE> - 바이트의 전송처 버퍼<DD><CODE>offset</CODE> - 최초의 바이트의 전송처가 되는 버퍼 배열내의 오프셋(offset).

<tt>dsts.length</tt> 이하의 부가 아닌 값<DD><CODE>length</CODE> - 액세스 되는 최대 버퍼수.

<tt>dsts.length</tt>&nbsp;-&nbsp;<tt>offset</tt> 이하의 부가 아닌 값
<DT><B>반환값:</B><DD>읽힌 문자수. 제로인가, 채널이 스트림의 마지막에 이르고 있는 경우는 <tt>-1</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/NotYetConnectedException.html" title="java.nio.channels 안의 클래스">NotYetConnectedException</A> </CODE> - 이 채널이 아직 접속되어 있지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - read 조작의 진행중에, 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - read 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="read(java.nio.ByteBuffer[])"><!-- --></A> <H3>
read</H3>
<PRE>
public final long <B>read</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts)
                throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../java/nio/channels/ScatteringByteChannel.html#read(java.nio.ByteBuffer[])">ScatteringByteChannel</A> </CODE> 의 기술:</B></DD>
<DD>이 채널의 바이트 순서가 지정된 버퍼에 읽어들입니다.

 <p> 이 메소드를 <tt>c.read(dsts)</tt> 의 형식에서 호출했을 경우, 다음의 호출과 같은 결과를 얻을 수 있습니다.

 <blockquote><pre>
 c.read(dsts, 0, dsts.length);</pre></blockquote>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 내의 인터페이스">ScatteringByteChannel</A> </CODE> 내의 <CODE><A HREF="../../../java/nio/channels/ScatteringByteChannel.html#read(java.nio.ByteBuffer[])">read</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>dsts</CODE> - 바이트의 전송처 버퍼
<DT><B>반환값:</B><DD>읽힌 문자수. 제로인가, 채널이 스트림의 마지막에 이르고 있는 경우는 <tt>-1</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/NotYetConnectedException.html" title="java.nio.channels 안의 클래스">NotYetConnectedException</A> </CODE> - 이 채널이 아직 접속되어 있지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - read 조작의 진행중에, 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - read 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="write(java.nio.ByteBuffer)"><!-- --></A> <H3>
write</H3>
<PRE>
public abstract int <B>write</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src)
                   throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../java/nio/channels/WritableByteChannel.html#write(java.nio.ByteBuffer)">WritableByteChannel</A> </CODE> 의 기술:</B></DD>
<DD>이 채널의 바이트 순서를 지정의 버퍼로부터 써냅니다.

 <p> 채널에 최대 <i>r</i> 바이트를 기입하려고 합니다. <i>r</i> 는, 이 메소드를 호출할 때 버퍼내에 존재하는 바이트수,<tt>src.remaining()</tt> 가 됩니다.

 <p> 길이 <i>n</i> (<tt>0</tt>&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>)의 바이트 순서가 기입해진다고 합니다. 이 바이트 순서는, 버퍼의 인덱스 <i>p</i> 로부터 전송 됩니다. <i>p</i> 는, 이 메소드를 호출할 때의 버퍼의 위치입니다. 기입해지는 마지막 바이트의 인덱스는 <i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>&nbsp;<tt>-</tt>&nbsp;<tt>1</tt> 이 됩니다. 버퍼의 위치는, 돌려주어질 때 <i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i> 에 동일해집니다. 리밋트에 변화는 없습니다.

 <p> 특히 지정이 없는 한, 요구된 <i>r</i> 바이트가 모두 기입해지면(자) 기입 조작은 종료합니다. 채널의 종류에 따라서는, 그 상태에 응해, 일부의 바이트 밖에 기입해지지 않은 경우나, 전혀 기입을 하지 않는 경우도 있습니다. 예를 들어 비블록 모드의 소켓 채널에서는, 소켓의 출력 버퍼내의 바이트수가 최대 기입 바이트수가 됩니다.

 <p> 이 메소드는 언제라도 호출할 수가 있습니다. 다만, 다른 thread가 이 채널에 대해서 기입해 조작을 개시하고 있는 경우, 이 메소드의 호출은 최초의 조작이 끝날 때까지 블록 됩니다.  </p>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../java/nio/channels/WritableByteChannel.html" title="java.nio.channels 내의 인터페이스">WritableByteChannel</A> </CODE> 내의 <CODE><A HREF="../../../java/nio/channels/WritableByteChannel.html#write(java.nio.ByteBuffer)">write</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>src</CODE> - 바이트의 취득처 버퍼
<DT><B>반환값:</B><DD>기입해지는 바이트수. 제로의 경우도 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/NotYetConnectedException.html" title="java.nio.channels 안의 클래스">NotYetConnectedException</A> </CODE> - 이 채널이 아직 접속되어 있지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 기입중에 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - 기입중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해, 현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="write(java.nio.ByteBuffer[], int, int)"><!-- --></A> <H3>
write</H3>
<PRE>
public abstract long <B>write</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs,
                           int&nbsp;offset,
                           int&nbsp;length)
                    throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../java/nio/channels/GatheringByteChannel.html#write(java.nio.ByteBuffer[], int, int)">GatheringByteChannel</A> </CODE> 의 기술:</B></DD>
<DD>이 채널의 바이트 순서가 지정된 버퍼의 서브 순서로부터 써냅니다.

 <p> 이 채널에 최대 <i>r</i> 바이트를 기입하려고 합니다. <i>r</i> 는, 이 메소드의 호출시로 지정된 버퍼 배열의 지정된 서브 순서에 포함되는 합계 바이트수입니다.

 <blockquote><pre>
 srcs[offset]. remaining()
     + srcs[offset+1]. remaining()
     + ... + srcs[offset+length-1]. remaining()</pre></blockquote>



 <p> 길이 <i>n</i> (<tt>0</tt>&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>)의 바이트 순서가 기입해진다고 합니다. 이 순서의 최초의 <tt>srcs[offset]. remaining()</tt> 바이트까지는 버퍼 <tt>srcs[offset]</tt> 로부터 기입해져 다음의 <tt>srcs[offset+1]. remaining()</tt> 바이트는 버퍼 <tt>srcs[offset+1]</tt> 로부터 기입해집니다. 바이트 순서 전부가 기입해질 때까지, 이 처리가 반복해집니다. 각 버퍼로부터 최대한의 바이트수가 기입해지기 (위해)때문에, 갱신된 개개의 버퍼의 최종적인 위치는, 최종 갱신 버퍼를 제외해, 이 버퍼의 리밋트와 동일해집니다.

 <p> 특히 지정이 없는 한, 요구된 <i>r</i> 바이트가 모두 기입해지면(자) 기입 조작은 종료합니다. 채널의 종류에 따라서는, 그 상태에 응해, 일부의 바이트 밖에 기입해지지 않은 경우나, 전혀 기입을 하지 않는 경우도 있습니다. 예를 들어 비블록 모드의 소켓 채널에서는, 소켓의 출력 버퍼내의 바이트수가 최대 기입 바이트수가 됩니다.

 <p> 이 메소드는 언제라도 호출할 수가 있습니다. 다만, 다른 thread가 이 채널에 대해서 기입해 조작을 개시하고 있는 경우, 이 메소드의 호출은 최초의 조작이 끝날 때까지 블록 됩니다.  </p>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 내의 인터페이스">GatheringByteChannel</A> </CODE> 내의 <CODE><A HREF="../../../java/nio/channels/GatheringByteChannel.html#write(java.nio.ByteBuffer[], int, int)">write</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcs</CODE> - 바이트의 취득처 버퍼<DD><CODE>offset</CODE> - 최초의 바이트의 취득처가 되는 버퍼 배열내의 오프셋(offset). <tt>srcs.length</tt> 이하의 부가 아닌 값<DD><CODE>length</CODE> - 액세스 되는 최대 버퍼수.

<tt>srcs.length</tt>&nbsp;-&nbsp;<tt>offset</tt> 이하의 부가 아닌 값
<DT><B>반환값:</B><DD>기입해지는 바이트수. 제로의 경우도 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/NotYetConnectedException.html" title="java.nio.channels 안의 클래스">NotYetConnectedException</A> </CODE> - 이 채널이 아직 접속되어 있지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 기입중에 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - 기입 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="write(java.nio.ByteBuffer[])"><!-- --></A> <H3>
write</H3>
<PRE>
public final long <B>write</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs)
                 throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../java/nio/channels/GatheringByteChannel.html#write(java.nio.ByteBuffer[])">GatheringByteChannel</A> </CODE> 의 기술:</B></DD>
<DD>이 채널의 바이트 순서가 지정된 버퍼로부터 써냅니다.

 <p> 이 메소드를 <tt>c.write(srcs)</tt> 의 형식에서 호출했을 경우, 다음의 호출과 같은 결과를 얻을 수 있습니다.

 <blockquote><pre>
 c.write(srcs, 0, srcs.length);</pre></blockquote>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 내의 인터페이스">GatheringByteChannel</A> </CODE> 내의 <CODE><A HREF="../../../java/nio/channels/GatheringByteChannel.html#write(java.nio.ByteBuffer[])">write</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcs</CODE> - 바이트의 취득처 버퍼
<DT><B>반환값:</B><DD>기입해지는 바이트수. 제로의 경우도 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/nio/channels/NotYetConnectedException.html" title="java.nio.channels 안의 클래스">NotYetConnectedException</A> </CODE> - 이 채널이 아직 접속되어 있지 않은 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedChannelException.html" title="java.nio.channels 안의 클래스">ClosedChannelException</A> </CODE> - 이 채널이 클로즈 하고 있는 경우
<DD><CODE><A HREF="../../../java/nio/channels/AsynchronousCloseException.html" title="java.nio.channels 안의 클래스">AsynchronousCloseException</A> </CODE> - 기입중에 다른 thread에 의해 이 채널이 클로즈 되었을 경우
<DD><CODE><A HREF="../../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스">ClosedByInterruptException</A> </CODE> - 기입 조작의 진행중에 다른 thread로부터의 인터럽트가 있었기 때문에 채널이 클로즈 해,

현재의 thread의 인터럽트 상태가 설정되었을 경우
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 그 외의 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SocketChannel.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/nio/channels/ServerSocketChannel.html" title="java.nio.channels 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/nio/channels/UnresolvedAddressException.html" title="java.nio.channels 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/nio/channels/SocketChannel.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="SocketChannel.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
