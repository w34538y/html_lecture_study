<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:56:43 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
ClassLoader (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ClassLoader (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ClassLoader.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/ClassFormatError.html" title="java.lang 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/ClassLoader.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ClassLoader.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang</FONT>
<BR>
클래스 ClassLoader</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.lang.ClassLoader</B>
</PRE>
<DL>
<DT><B>직계의 기존의 서브 클래스:</B> <DD><A HREF="../../java/security/SecureClassLoader.html" title="java.security 내의 클래스">SecureClassLoader</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>ClassLoader</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
클래스 로더는, 클래스의 로드를 담당하는 객체입니다. <tt>ClassLoader</tt> 클래스는 abstract 클래스입니다. 클래스의<a  href="#name">바이너리명</a>을 지정하면(자), 클래스 로더는 클래스의 정의를 구성하는 데이터를 찾아내는지 생성합니다. 일반적인 방법으로서는, 이름을 파일명으로 변환해, 파일 시스템으로부터 그 이름의 「클래스 파일」을 읽어들입니다.

 <p> 각 <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스"><CODE><tt>Class</tt></CODE></A>  객체는, 그 객체를 정의한 <tt>ClassLoader</tt> 에의 <A HREF="../../java/lang/Class.html#getClassLoader()"><CODE>reference</CODE></A>  를 포함하고 있습니다.

 <p> 배열 클래스의 <tt>Class</tt> 객체는, 클래스 로더에 따라서는 작성되지 않고, Java Runtime 의 요구에 응해 자동적으로 작성됩니다. 배열 클래스의 클래스 로더는,<A HREF="../../java/lang/Class.html#getClassLoader()"><CODE>Class.getClassLoader()</CODE></A>  에 의해 돌려주어져 그 요소의 형태의 클래스 로더와 같게 됩니다.  요소의 형태가 원시형의 경우에는, 배열 클래스에 클래스 로더는 없습니다.

 <p> 어플리케이션은, Java 가상 머신이 동적으로 클래스를 로드하도록(듯이) 확장하기 위해(때문에),<tt>ClassLoader</tt> 의 서브 클래스를 구현합니다.

 <p> 클래스 로더는 일반적으로, 시큐리티 매니저가 시큐리티 도메인을 나타내기 위해서(때문에) 사용됩니다.

 <p> <tt>ClassLoader</tt> 클래스는, 위양 모델을 사용해 클래스와 자원을 찾습니다. <tt>ClassLoader</tt> 의 각 인스턴스는, 관련하는 친클래스 로더를 가집니다. 클래스 또는 자원을 찾아내기 위해서(때문에) 불려 가면(자),<tt>ClassLoader</tt> 인스턴스는 그 자체로 클래스 또는 자원의 검색을 시도하기 전에, 그 검색을 친클래스에 위양 합니다. 「bootstrap 클래스 로더」라고 불리는 가상 머신의 편입 클래스 로더는 그 자체에서는 부모를 가지지 않고,<tt>ClassLoader</tt> 인스턴스의 부모로서 동작합니다.

 <p> 일반적으로, Java 가상 머신은, 플랫폼에 의존하지 않는 방법으로 로컬 파일 시스템으로부터 클래스를 로드합니다. 예를 들어, UNIX 시스템에서는,<tt>CLASSPATH</tt> 환경 변수에 의해 정의된 디렉토리에서 클래스를 로드합니다.

 <p> 다만, 파일로부터 작성할 수 없는 클래스도 있습니다.  이러한 클래스는, 네트워크등의 다른 소스로부터 작성하거나 어플리케이션이 구축하거나 합니다. <A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE><tt>defineClass</tt></CODE></A>  메소드는, 바이트의 배열을 <tt>Class</tt> 클래스의 인스턴스로 변환합니다. 새롭게 정의한 클래스의 인스턴스는,<A HREF="../../java/lang/Class.html#newInstance()"><CODE><tt>Class.newInstance</tt></CODE></A>  를 사용해 생성할 수 있습니다.

 <p> 클래스 로더로 작성한 객체의 메소드와 생성자 은, 다른 클래스를 참조할 수 있습니다. 참조하는 클래스를 판정하기 위해서, Java 가상 머신은, 클래스를 최초로 작성한 클래스 로더의 <A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String)"><CODE><tt>loadClass</tt></CODE></A>  메소드를 호출합니다.

 <p> 예를 들어, 어플리케이션은 네트워크 클래스 로더를 작성해, 서버로부터 클래스 파일을 다운로드할 수 있습니다. 코드는 다음과 같이 됩니다.

 <blockquote><pre>
   ClassLoader loader&nbsp;= new NetworkClassLoader(host, &nbsp;port);
   Object main&nbsp;= loader.loadClass("Main", true). newInstance();
         &nbsp;. &nbsp;. &nbsp;.
 </pre></blockquote>

 <p> 네트워크 클래스 로더의 서브 클래스는, 네트워크로부터 클래스를 로드하기 위해서(때문에) <A HREF="../../java/lang/ClassLoader.html#findClass(java.lang.String)"><CODE><tt>findClass</tt></CODE></A>  메소드와 <tt>loadClassData</tt> 메소드를 정의하지 않으면 안됩니다. 클래스를 작성하는 바이트를 한 번 다운로드하면(자),<A HREF="../../java/lang/ClassLoader.html#defineClass(byte[], int, int)"><CODE><tt>defineClass</tt></CODE></A>  메소드를 사용해 클래스 인스턴스를 생성할 필요가 있습니다. 구현의 예를 다음에 나타냅니다.

 <blockquote><pre>
     class NetworkClassLoader extends ClassLoader {
         String host;
         int port;

         public Class findClass(String name) {
             byte[] b = loadClassData(name);
             return defineClass(name, b, 0, b.length);
         }

         private byte[] loadClassData(String name) {
             // load the class data from the connection
             &nbsp;. &nbsp;. &nbsp;.
         }
     }
 </pre></blockquote>

<h4> <a name="name">바이너리명</a>  </h4>

 <p> <tt>ClassLoader</tt> 의 메소드에 <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스"><CODE>String</CODE></A>  파라미터로서 제공되는 클래스명은,<a  href="http://java.sun.com/docs/books/jls/">「Java 언어 스펙」</a>으로 정의된 바이너리명일 필요가 있습니다.

 <p> 다음에, 유효한 클래스명의 예를 나타냅니다.
 <blockquote><pre>
   "java.lang.String"
   "javax.swing.JSpinner$DefaultEditor"
   "java.security.KeyStore$Builder$FileBuilder$1"
   "java.net.URLClassLoader$3$1"
 </pre></blockquote>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/ClassLoader.html#resolveClass(java.lang.Class)"><CODE>resolveClass(Class)</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#ClassLoader()">ClassLoader</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE><tt>getSystemClassLoader()</tt></CODE></A>  메소드에 의해 반환된 <tt>ClassLoader</tt> 를 친클래스 로더로서 사용해, 새로운 클래스 로더를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#ClassLoader(java.lang.ClassLoader)">ClassLoader</A> </B>(<A HREF="../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;parent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 친클래스 로더를 사용해, 위양을 위해서(때문에) 새로운 클래스 로더를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#clearAssertionStatus()">clearAssertionStatus</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 클래스 로더의 디폴트 선언 상태를 <tt>false</tt> 로 설정해, 클래스 로더에 관련지을 수 있었던 디폴트 패키지 및 클래스 선언 상태 설정을 모두 파기합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#defineClass(byte[], int, int)">defineClass</A> </B>(byte[]&nbsp;b,
            int&nbsp;off,
            int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I><A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE>defineClass(String, byte[], int, int)</CODE></A>  로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)">defineClass</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
            byte[]&nbsp;b,
            int&nbsp;off,
            int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트의 배열을 <tt>Class</tt> 클래스의 인스턴스로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain)">defineClass</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
            byte[]&nbsp;b,
            int&nbsp;off,
            int&nbsp;len,
            <A HREF="../../java/security/ProtectionDomain.html" title="java.security 안의 클래스">ProtectionDomain</A> &nbsp;protectionDomain)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;옵션의 <tt>ProtectionDomain</tt> 를 사용해, 바이트의 배열을 <tt>Class</tt> 클래스의 인스턴스로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, java.nio.ByteBuffer, java.security.ProtectionDomain)">defineClass</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
            <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;b,
            <A HREF="../../java/security/ProtectionDomain.html" title="java.security 안의 클래스">ProtectionDomain</A> &nbsp;protectionDomain)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;옵션의 <tt>ProtectionDomain</tt> 를 사용해,<A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스"><CODE><tt>ByteBuffer</tt></CODE></A>  를 <tt>Class</tt> 클래스의 인스턴스로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Package.html" title="java.lang 내의 클래스">Package</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#definePackage(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.net.URL)">definePackage</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;specTitle,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;specVersion,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;specVendor,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;implTitle,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;implVersion,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;implVendor,
              <A HREF="../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;sealBase)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <tt>ClassLoader</tt> 로 이름을 사용해 패키지를 정의합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#findClass(java.lang.String)">findClass</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된<a href="#name">바이너리명</a>을 가지는 클래스를 찾습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#findLibrary(java.lang.String)">findLibrary</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;libname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;네이티브 라이브러리의 절대 경로명을 돌아갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#findLoadedClass(java.lang.String)">findLoadedClass</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 로더가 이<a href="#name">바이너리명</a>을 가지는 클래스의 기동 로더로서 Java 가상 머신에 의해 기록되고 있었을 경우는, 지정된<a href="#name">바이너리명</a>을 가지는 클래스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#findResource(java.lang.String)">findResource</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이름을 가지는 자원을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/util/Enumeration.html" title="java.util 내의 인터페이스">Enumeration</A> &lt;<A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#findResources(java.lang.String)">findResources</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이름을 가지는 모든 자원을 나타내는 <A HREF="../../java/net/URL.html" title="java.net 동안의 클래스"><CODE><tt>URL</tt></CODE></A>  객체의 열거를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#findSystemClass(java.lang.String)">findSystemClass</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된<a href="#name">바이너리명</a>을 가지는 클래스를 찾아, 필요에 따라서 로드합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Package.html" title="java.lang 내의 클래스">Package</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getPackage(java.lang.String)">getPackage</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 클래스 로더인가 게다가 위객체의 어떤 것 등에 의해서 정의된 <tt>Package</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Package.html" title="java.lang 내의 클래스">Package</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getPackages()">getPackages</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 클래스 로더와 게다가 위객체에 의해 정의된 모든 <tt>Packages</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/ClassLoader.html" title="java.lang 내의 클래스">ClassLoader</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getParent()">getParent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;위양을 위한 친클래스 로더를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getResource(java.lang.String)">getResource</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이름을 가지는 자원을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getResourceAsStream(java.lang.String)">getResourceAsStream</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 자원을 읽어들이는 입력 스트림을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/util/Enumeration.html" title="java.util 내의 인터페이스">Enumeration</A> &lt;<A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getResources(java.lang.String)">getResources</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이름을 가지는 모든 자원을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/ClassLoader.html" title="java.lang 내의 클래스">ClassLoader</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()">getSystemClassLoader</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;위양을 위한 시스템 클래스 로더를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getSystemResource(java.lang.String)">getSystemResource</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클래스를 로드하기 위해서(때문에) 사용되는 검색 패스로부터, 지정된 이름의 자원을 찾습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getSystemResourceAsStream(java.lang.String)">getSystemResourceAsStream</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클래스를 로드하는데 사용되는 검색 패스로부터, 지정된 이름의 자원을, read용으로 오픈합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/util/Enumeration.html" title="java.util 내의 인터페이스">Enumeration</A> &lt;<A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#getSystemResources(java.lang.String)">getSystemResources</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클래스를 로드하기 위해서(때문에) 사용되는 검색 패스로부터, 지정된 이름의 모든 자원을 찾습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String)">loadClass</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된<a href="#name">바이너리명</a>을 가지는 클래스를 로드합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String, boolean)">loadClass</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
          boolean&nbsp;resolve)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된<a href="#name">바이너리명</a>을 가지는 클래스를 로드합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#resolveClass(java.lang.Class)">resolveClass</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 클래스를 링크합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#setClassAssertionStatus(java.lang.String, boolean)">setClassAssertionStatus</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;className,
                        boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 클래스 로더 및 내부의 상자 구조 클래스내의 이름 첨부의 톱 레벨 클래스에 대해서, 목적의 선언 상태를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#setDefaultAssertionStatus(boolean)">setDefaultAssertionStatus</A> </B>(boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 클래스 로더의 디폴트 선언 상태를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#setPackageAssertionStatus(java.lang.String, boolean)">setPackageAssertionStatus</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;packageName,
                          boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이름 첨부 패키지의 디폴트 선언 상태를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/ClassLoader.html#setSigners(java.lang.Class, java.lang.Object[])">setSigners</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;c,
           <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;signers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클래스의 서명자를 설정합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ClassLoader(java.lang.ClassLoader)"><!-- --></A> <H3>
ClassLoader</H3>
<PRE>
protected <B>ClassLoader</B>(<A HREF="../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;parent)</PRE>
<DL>
<DD>지정된 친클래스 로더를 사용해, 위양을 위해서(때문에) 새로운 클래스 로더를 작성합니다.

 <p> 시큐리티 매니저가 존재할 경우에, 시큐리티 매니저의 <A HREF="../../java/lang/SecurityManager.html#checkCreateClassLoader()"><CODE><tt>checkCreateClassLoader</tt></CODE></A>  메소드가 불려 갑니다. 이것은 시큐리티 예외가 되는 경우가 있습니다.   </p>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>parent</CODE> - 부모의 클래스 로더
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <tt>checkCreateClassLoader</tt> 메소드가 새로운 클래스 로더의 작성을 허가하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DL>
<HR>

<A NAME="ClassLoader()"><!-- --></A> <H3>
ClassLoader</H3>
<PRE>
protected <B>ClassLoader</B>()</PRE>
<DL>
<DD><A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE><tt>getSystemClassLoader()</tt></CODE></A>  메소드에 의해 반환된 <tt>ClassLoader</tt> 를 친클래스 로더로서 사용해, 새로운 클래스 로더를 작성합니다.

 <p> 시큐리티 매니저가 존재할 경우에, 시큐리티 매니저의 <A HREF="../../java/lang/SecurityManager.html#checkCreateClassLoader()"><CODE><tt>checkCreateClassLoader</tt></CODE></A>  메소드가 불려 갑니다. 이것은 시큐리티 예외가 되는 경우가 있습니다.   </p>
<P>
<DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <tt>checkCreateClassLoader</tt> 메소드가 새로운 클래스 로더의 작성을 허가하지 않는 경우</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="loadClass(java.lang.String)"><!-- --></A> <H3>
loadClass</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>loadClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                   throws <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 내의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>지정된<a href="#name">바이너리명</a>을 가지는 클래스를 로드합니다. 이 메소드는,<A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String, boolean)"><CODE>loadClass(String, boolean)</CODE></A>  메소드와 같은 방법으로 클래스를 검색합니다. Java 가상 머신이 이 메소드를 호출해, 클래스 참조를 해결합니다. 이 메소드를 호출하는 것은,<A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String, boolean)"><CODE><tt>loadClass(name, false)</tt></CODE></A>  를 호출하는 것에 상당합니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 클래스의<a href="#name">바이너리명</a> 
<DT><B>반환값:</B><DD>결과적으로 얻을 수 있는 <tt>Class</tt> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스가 발견되지 않았던 경우</DL>
</DD>
</DL>
<HR>

<A NAME="loadClass(java.lang.String, boolean)"><!-- --></A> <H3>
loadClass</H3>
<PRE>
protected <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>loadClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
                             boolean&nbsp;resolve)
                      throws <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 내의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>지정된<a href="#name">바이너리명</a>을 가지는 클래스를 로드합니다. 이 메소드의 디폴트 구현에서는, 다음의 순서로 클래스를 검색합니다.

 <p><ol>

<li><p> <A HREF="../../java/lang/ClassLoader.html#findLoadedClass(java.lang.String)"><CODE>findLoadedClass(String)</CODE></A>  를 호출해, 클래스가 벌써 로드 되었는지의 여부를 확인한다  </p></li>

<li><p> 친클래스 로더로 <A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String)"><CODE><tt>loadClass</tt></CODE></A>  메소드를 호출한다. 부모가 <tt>null</tt> 의 경우, 가상 머신에 짜넣어진 클래스 로더가 대신에 호출한다  </p></li>

<li><p> <A HREF="../../java/lang/ClassLoader.html#findClass(java.lang.String)"><CODE>findClass(String)</CODE></A>  메소드를 호출해, 클래스를 찾는다  </p></li>

 </ol>

 <p> 상기의 순서로 클래스가 발견되었을 경우,<tt>resolve</tt> 플래그가 true 때에는, 이 메소드는 결과적으로 얻을 수 있는 <tt>Class</tt> 객체에 대해서 <A HREF="../../java/lang/ClassLoader.html#resolveClass(java.lang.Class)"><CODE>resolveClass(Class)</CODE></A>  메소드를 호출합니다.

 <p> <tt>ClassLoader</tt> 의 서브 클래스가, 이 메소드는 아니고 <A HREF="../../java/lang/ClassLoader.html#findClass(java.lang.String)"><CODE>findClass(String)</CODE></A>  를 오버라이드(override) 하는 것이 추천 되고 있습니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 클래스의<a href="#name">바이너리명</a> <DD><CODE>resolve</CODE> - <tt>true</tt> 의 경우는, 클래스를 해석 처리한다
<DT><B>반환값:</B><DD>결과적으로 얻을 수 있는 <tt>Class</tt> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스가 발견되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="findClass(java.lang.String)"><!-- --></A> <H3>
findClass</H3>
<PRE>
protected <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>findClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                      throws <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 내의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>지정된<a href="#name">바이너리명</a>을 가지는 클래스를 찾습니다. 이 메소드는, 클래스를 로드하기 위한 위양 모델에 준거하는 클래스 로더 구현에 의해 오버라이드(override) 되어 필요한 클래스의 친클래스 로더의 체크 후에 <A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String)"><CODE><tt>loadClass</tt></CODE></A>  메소드에 의해 불려 갑니다. 디폴트의 구현은 <tt>ClassNotFoundException</tt> 를 throw 합니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 클래스의<a href="#name">바이너리명</a> 
<DT><B>반환값:</B><DD>결과적으로 얻을 수 있는 <tt>Class</tt> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스가 발견되지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="defineClass(byte[], int, int)"><!-- --></A> <H3>
defineClass</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>protected final <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>defineClass</B>(byte[]&nbsp;b,
                                                int&nbsp;off,
                                                int&nbsp;len)
                              throws <A HREF="../../java/lang/ClassFormatError.html" title="java.lang 내의 클래스">ClassFormatError</A> </PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I><A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE>defineClass(String, byte[], int, int)</CODE></A>  로 옮겨졌습니다. </I>
<P>
<DD>바이트의 배열을 <tt>Class</tt> 클래스의 인스턴스로 변환합니다. 최초로 <tt>Class</tt> 를 해결하지 않으면, 클래스를 사용할 수 없습니다. 이 메소드보다,<a  href="#name">바이너리명</a>을 최초의 인수로서 취득하는 버젼이 안전하기 때문에, 그 버젼을 사용하는 것을 추천합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>b</CODE> - 클래스 데이터를 구성하는 바이트. <tt>off</tt> 로부터 <tt>off+len-1</tt> 까지의 위치에 있는 byte 는,<a          href="http://java.sun.com/docs/books/vmspec/">Java 가상 머신 스펙</a>으로 정의되는 유효한 클래스 파일의 형식을 가지는<DD><CODE>off</CODE> - 클래스 데이터의 <tt>b</tt> 의 개시 오프셋(offset)<DD><CODE>len</CODE> - 클래스 데이터의 길이
<DT><B>반환값:</B><DD>지정된 클래스 데이터로부터 작성된 <tt>Class</tt> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassFormatError.html" title="java.lang 안의 클래스">ClassFormatError</A> </CODE> - 데이터가 유효한 클래스를 포함하지 않았던 경우
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - <tt>off</tt> 또는 <tt>len</tt> 의 어느 쪽인지가 부의 경우, 또는 <tt>off+len</tt> 가 <tt>b.length</tt> 보다 큰 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String, boolean)"><CODE>loadClass(String, boolean)</CODE></A> , 
<A HREF="../../java/lang/ClassLoader.html#resolveClass(java.lang.Class)"><CODE>resolveClass(Class)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="defineClass(java.lang.String, byte[], int, int)"><!-- --></A> <H3>
defineClass</H3>
<PRE>
protected final <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>defineClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
                                     byte[]&nbsp;b,
                                     int&nbsp;off,
                                     int&nbsp;len)
                              throws <A HREF="../../java/lang/ClassFormatError.html" title="java.lang 내의 클래스">ClassFormatError</A> </PRE>
<DL>
<DD>바이트의 배열을 <tt>Class</tt> 클래스의 인스턴스로 변환합니다. 최초로 <tt>Class</tt> 를 해결하지 않으면, 클래스를 사용할 수 없습니다.

 <p> 이 메소드는, 디폴트 <A HREF="../../java/security/ProtectionDomain.html" title="java.security 중의 클래스"><CODE><tt>ProtectionDomain</tt></CODE></A>  를, 새롭게 정의된 클래스에 할당합니다. <tt>ProtectionDomain</tt> 는,<A HREF="../../java/security/Policy.html#getPermissions(java.security.CodeSource)"><CODE><tt>Policy.getPolicy(). getPermissions(new CodeSource(null, null))</tt></CODE></A>  가 불려 갔을 때에 반환되는 액세스권과 같은 액세스권을 보관 유지합니다. 디폴트의 도메인은 <A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE><tt>defineClass</tt></CODE></A>  의 최초의 호출로 작성되어 그 후의 호출로 재사용됩니다.

 <p> 특정의 <tt>ProtectionDomain</tt> 를 클래스에 할당하려면 ,<tt>ProtectionDomain</tt> 를 그 인수의 1 개로서 취하는 <A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain)"><CODE><tt>defineClass</tt></CODE></A>  메소드를 사용합니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 클래스가 예상되는<a href="#name">바이너리명</a> .  불명한 경우는 <tt>null</tt><DD><CODE>b</CODE> - 클래스 데이터를 구성하는 바이트. <tt>off</tt> 로부터 <tt>off+len-1</tt> 까지의 위치에 있는 byte 는,<a          href="http://java.sun.com/docs/books/vmspec/">Java 가상 머신 스펙</a>으로 정의되는 유효한 클래스 파일의 형식을 가지는<DD><CODE>off</CODE> - 클래스 데이터의 <tt>b</tt> 의 개시 오프셋(offset)<DD><CODE>len</CODE> - 클래스 데이터의 길이
<DT><B>반환값:</B><DD>지정된 클래스 데이터로부터 작성된 <tt>Class</tt> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassFormatError.html" title="java.lang 안의 클래스">ClassFormatError</A> </CODE> - 데이터가 유효한 클래스를 포함하지 않았던 경우
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - <tt>off</tt> 또는 <tt>len</tt> 의 어느 쪽인지가 부의 경우, 또는 <tt>off+len</tt> 가 <tt>b.length</tt> 보다 큰 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 이 클래스와는 다른 증명서 세트 (부호 없음)를 사용해 서명된 클래스를 포함한 패키지에, 이 클래스를 추가하려고 하는 경우, 또는 <tt>name</tt>가 「<tt>java. </tt>」(으)로 시작되는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/ClassLoader.html#loadClass(java.lang.String, boolean)"><CODE>loadClass(String, boolean)</CODE></A> , 
<A HREF="../../java/lang/ClassLoader.html#resolveClass(java.lang.Class)"><CODE>resolveClass(Class)</CODE></A> , 
<A HREF="../../java/security/CodeSource.html" title="java.security 안의 클래스"><CODE>CodeSource</CODE></A> , 
<A HREF="../../java/security/SecureClassLoader.html" title="java.security 안의 클래스"><CODE>SecureClassLoader</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain)"><!-- --></A> <H3>
defineClass</H3>
<PRE>
protected final <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>defineClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
                                     byte[]&nbsp;b,
                                     int&nbsp;off,
                                     int&nbsp;len,
                                     <A HREF="../../java/security/ProtectionDomain.html" title="java.security 안의 클래스">ProtectionDomain</A> &nbsp;protectionDomain)
                              throws <A HREF="../../java/lang/ClassFormatError.html" title="java.lang 내의 클래스">ClassFormatError</A> </PRE>
<DL>
<DD>옵션의 <tt>ProtectionDomain</tt> 를 사용해, 바이트의 배열을 <tt>Class</tt> 클래스의 인스턴스로 변환합니다. 도메인이 <tt>null</tt> 의 경우는, 디폴트의 도메인이,<A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE>defineClass(String, byte[], int, int)</CODE></A>  의 문서로 지정되고 있는 대로 클래스에 할당할 수 있고 있습니다. 최초로 클래스를 해결하지 않으면, 클래스를 사용할 수 없습니다.

 <p> 패키지로 정의되는 최초의 클래스는, 그 패키지내에서 연속해 정의된 모든 클래스에 있는, 증명서의 정확한 세트를 판정합니다. 클래스의 증명서세트는, 클래스의 <tt>ProtectionDomain</tt> 내 <A HREF="../../java/security/CodeSource.html" title="java.security 중의 클래스"><CODE><tt>CodeSource</tt></CODE></A>  로부터 가져옵니다. 그 패키지에 추가된 클래스에는 동일한 증명서세트가 포함되어 있을 필요가 있어, 포함되지 않은 경우는 <tt>SecurityException</tt> 가 throw 됩니다. <tt>name</tt> 인수가 <tt>null</tt> 의 경우, 이 판별은 실행되지 않습니다. 반드시, 정의하는 클래스의<a href="#name">바이너리명</a>을 바이트와 함께 건네줄 필요가 있습니다. 이와 같이 해 건네주면(자), 정의하는 클래스는 실제로 생각했던 대로의 클래스가 됩니다.

 <p> <tt>java. *</tt> 패키지의 모든 클래스는 bootstrap 클래스 로더로 밖에 정의할 수 없기 때문에, 「<tt>java. </tt>」(으)로 시작되는<tt>name</tt>를 지정할 수 없습니다. <tt>name</tt> 가 <tt>null</tt> 가 아닌 경우에는, 바이트 배열 「<tt>b</tt>」로 지정된 클래스의<a href="#name">바이너리명</a>에 동일하지 않으면 안됩니다.  동일하지 않은 경우,<tt>NoClassDefFoundError</tt> 가 throw 됩니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 클래스가 예상되는<a href="#name">바이너리명</a> .  불명한 경우는 <tt>null</tt><DD><CODE>b</CODE> - 클래스 데이터를 구성하는 바이트. <tt>off</tt> 로부터 <tt>off+len-1</tt> 까지의 위치에 있는 byte 는,<a          href="http://java.sun.com/docs/books/vmspec/">Java 가상 머신 스펙</a>으로 정의되는 유효한 클래스 파일의 형식을 가지는<DD><CODE>off</CODE> - 클래스 데이터의 <tt>b</tt> 의 개시 오프셋(offset)<DD><CODE>len</CODE> - 클래스 데이터의 길이<DD><CODE>protectionDomain</CODE> - 이 클래스의 ProtectionDomain
<DT><B>반환값:</B><DD>데이터로부터 작성된 <tt>Class</tt> 객체와 임의의 <tt>ProtectionDomain</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassFormatError.html" title="java.lang 안의 클래스">ClassFormatError</A> </CODE> - 데이터가 유효한 클래스를 포함하지 않았던 경우
<DD><CODE><A HREF="../../java/lang/NoClassDefFoundError.html" title="java.lang 안의 클래스">NoClassDefFoundError</A> </CODE> - <tt>name</tt> 가 <tt>b</tt> 로 지정된 클래스의<a href="#name">바이너리명</a>으로 동일하지 않은 경우
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - <tt>off</tt> 또는 <tt>len</tt> 의 어느 쪽인지가 부의 경우, 또는 <tt>off+len</tt> 가 <tt>b.length</tt> 보다 큰 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 이 클래스와는 다른 증명서 세트를 사용해 서명된 클래스를 포함한 패키지에, 이 클래스를 추가하려고 하는 경우, 또는 <tt>name</tt> 가 「<tt>java. </tt>」(으)로 시작되는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="defineClass(java.lang.String, java.nio.ByteBuffer, java.security.ProtectionDomain)"><!-- --></A> <H3>
defineClass</H3>
<PRE>
protected final <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>defineClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
                                     <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;b,
                                     <A HREF="../../java/security/ProtectionDomain.html" title="java.security 안의 클래스">ProtectionDomain</A> &nbsp;protectionDomain)
                              throws <A HREF="../../java/lang/ClassFormatError.html" title="java.lang 내의 클래스">ClassFormatError</A> </PRE>
<DL>
<DD>옵션의 <tt>ProtectionDomain</tt> 를 사용해,<A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스"><CODE><tt>ByteBuffer</tt></CODE></A>  를 <tt>Class</tt> 클래스의 인스턴스로 변환합니다. 도메인이 <tt>null</tt> 의 경우는, 디폴트의 도메인이,<A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE>defineClass(String, byte[], int, int)</CODE></A>  의 문서로 지정되고 있는 대로 클래스에 할당할 수 있고 있습니다. 최초로 클래스를 해결하지 않으면, 클래스를 사용할 수 없습니다.

 <p>패키지의 증명서세트를 결정하고 있는 패키지로 정의된 최초의 클래스에 관한 규칙과 클래스명에서의 제약은,<A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain)"><CODE>defineClass(String, byte[], int, int, ProtectionDomain)</CODE></A>  의 문서로 지정되고 있는 것과 동등합니다.

 <p> 이 폼의 메소드 호출 <i>cl</i><tt>. defineClass(</tt><i>name</i><tt>,</tt> <i>bBuffer</i><tt>,</tt> <i>pd</i><tt>)</tt> 에서는, 다음의 문장과 정확하게 같은 결과를 얻을 수 있습니다.

<blockquote><tt>...<br> byte[] temp = new byte[</tt><i>bBuffer</i><tt>. <A HREF="../../java/nio/Buffer.html#remaining()"><CODE>remaining</CODE></A> ()];<br></tt><i>bBuffer</i><tt>. <A HREF="../../java/nio/ByteBuffer.html#get(byte[])"><CODE>get</CODE></A> (temp);<br> return <CODE>#defineClass(String, byte[], int, int, ProtectionDomain)</tt><i>cl</i><tt>. defineClass</CODE>(</tt><i>name</i><tt>, temp, 0, temp.length, </tt><i>pd</i><tt>);<br></tt></blockquote>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 예상되는<a href="#name">바이너리명</a. of the class, or >.  불명한 경우는 <tt>null</tt><DD><CODE>b</CODE> - 클래스 데이터를 구성하는 바이트. <tt>b.position()</tt> 로부터 <tt>b.position() + b.limit() -1 </tt> 까지의 위치에 있는 byte 는,<a          href="http://java.sun.com/docs/books/vmspec/">Java 가상 머신 스펙</a>으로 정의되는 유효한 클래스 파일의 형식을 가지는<DD><CODE>protectionDomain</CODE> - 이 클래스의 ProtectionDomain, 또는 <tt>null</tt>
<DT><B>반환값:</B><DD>데이터로부터 작성된 <tt>Class</tt> 객체와 임의의 <tt>ProtectionDomain</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassFormatError.html" title="java.lang 안의 클래스">ClassFormatError</A> </CODE> - 데이터가 유효한 클래스를 포함하지 않았던 경우
<DD><CODE><A HREF="../../java/lang/NoClassDefFoundError.html" title="java.lang 안의 클래스">NoClassDefFoundError</A> </CODE> - <tt>name</tt> 가 <tt>b</tt> 로 지정된 클래스의<a href="#name">바이너리명</a>으로 동일하지 않은 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 이 클래스와는 다른 증명서 세트를 사용해 서명된 클래스를 포함한 패키지에, 이 클래스를 추가하려고 하는 경우, 또는 <tt>name</tt> 가 「<tt>java. </tt>」(으)로 시작되는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain)"><CODE>defineClass(String, byte[], int, int, ProtectionDomain)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="resolveClass(java.lang.Class)"><!-- --></A> <H3>
resolveClass</H3>
<PRE>
protected final void <B>resolveClass</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;c)</PRE>
<DL>
<DD>지정된 클래스를 링크합니다. 클래스 로더는 이 메소드를 사용해, 클래스를 링크합니다. <tt>c</tt> 클래스가 벌써 링크되고 있는 경우, 이 메소드는 단지 복귀합니다. 그렇지 않은 경우,<a  href="http://java.sun.com/docs/books/jls/">「Java 언어 스펙」</a>의 「Execution」의 장으로 설명하고 있도록(듯이), 클래스는 링크됩니다.
 </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 링크하는 클래스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>c</tt> 가 <tt>null</tt> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE>defineClass(String, byte[], int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="findSystemClass(java.lang.String)"><!-- --></A> <H3>
findSystemClass</H3>
<PRE>
protected final <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>findSystemClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                                  throws <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 내의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>지정된<a href="#name">바이너리명</a>을 가지는 클래스를 찾아, 필요에 따라서 로드합니다.

 <p> 이 메소드는 시스템 클래스 로더-(<A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>getSystemClassLoader()</CODE></A>  를 참조)를 사용해 클래스를 로드합니다. 반환되는 <tt>Class</tt> 객체는, 그 클래스 객체에 관련한 <tt>ClassLoader</tt> 를 1 개 이상 가지게 됩니다. <tt>ClassLoader</tt> 의 서브 클래스는 일반적으로, 이 메소드를 호출할 필요는 없습니다.  이것은, 대부분의 클래스 로더가 <A HREF="../../java/lang/ClassLoader.html#findClass(java.lang.String)"><CODE>findClass(String)</CODE></A>  만을 오버라이드(override) 하면 좋기 때문입니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 클래스의<a href="#name">바이너리명</a> 
<DT><B>반환값:</B><DD>지정된 <tt>name</tt> 의 <tt>Class</tt> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스가 발견되지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/ClassLoader.html#ClassLoader(java.lang.ClassLoader)"><CODE>ClassLoader(ClassLoader)</CODE></A> , 
<A HREF="../../java/lang/ClassLoader.html#getParent()"><CODE>getParent()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="findLoadedClass(java.lang.String)"><!-- --></A> <H3>
findLoadedClass</H3>
<PRE>
protected final <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>findLoadedClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>이 로더가 이<a href="#name">바이너리명</a>을 가지는 클래스의 기동 로더로서 Java 가상 머신에 의해 기록되고 있었을 경우는, 지정된<a href="#name">바이너리명</a>을 가지는 클래스를 돌려줍니다. 그 이외의 경우는 <tt>null</tt> 를 돌려줍니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 클래스의<a href="#name">바이너리명</a> 
<DT><B>반환값:</B><DD><tt>Class</tt> 객체.  클래스가 로드되어 있지 않은 경우는 <tt>null</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSigners(java.lang.Class, java.lang.Object[])"><!-- --></A> <H3>
setSigners</H3>
<PRE>
protected final void <B>setSigners</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;c,
                                <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;signers)</PRE>
<DL>
<DD>클래스의 서명자를 설정합니다. 이 메소드는, 클래스의 정의 후에 호출할 필요가 있습니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - <tt>Class</tt> 객체<DD><CODE>signers</CODE> - 클래스의 서명자<DT><B>도입된 버젼:</B></DT>
  <DD>1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getResource(java.lang.String)"><!-- --></A> <H3>
getResource</H3>
<PRE>
public <A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A>  <B>getResource</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>지정된 이름을 가지는 자원을 검색합니다. 자원은, 클래스 코드로부터 코드 위치에 의존하지 않는 방법으로 액세스 가능한 데이터 (이미지, 오디오, 텍스트 등)입니다.

 <p> 자원의 이름은, 「<tt>/</tt>」으로 단락지어진 경로명이며, 이것에 의해 자원이 식별됩니다.

 <p> 이 메소드는, 우선 자원의 친클래스 로더를 검색합니다.  부모가 <tt>null</tt> 의 경우, 가상 머신에 짜넣어진 클래스 로더의 패스가 검색됩니다. 거기에 실패하면(자), 이 메소드는 자원을 찾아내기 위해서(때문에) <A HREF="../../java/lang/ClassLoader.html#findResource(java.lang.String)"><CODE>findResource(String)</CODE></A>  를 호출합니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 자원명
<DT><B>반환값:</B><DD>자원을 읽어들이기 위한 <tt>URL</tt>.  다만, 자원이 발견되지 않았던 경우나, 호출측이 자원을 취득하는 적절한 특권을 가지고 있지 않은 경우는 <tt>null</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getResources(java.lang.String)"><!-- --></A> <H3>
getResources</H3>
<PRE>
public <A HREF="../../java/util/Enumeration.html" title="java.util 내의 인터페이스">Enumeration</A> &lt;<A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A> &gt; <B>getResources</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>지정된 이름을 가지는 모든 자원을 검색합니다. 자원은, 클래스 코드로부터 코드 위치에 의존하지 않는 방법으로 액세스 가능한 데이터 (이미지, 오디오, 텍스트 등)입니다.

 <p>자원의 이름은, 「<tt>/</tt>」으로 단락지어진 경로명이며, 이것에 의해 자원이 식별됩니다.

 <p> 검색순서에 대해서는,<A HREF="../../java/lang/ClassLoader.html#getResource(java.lang.String)"><CODE>getResource(String)</CODE></A>  의 문서를 참조해 주세요.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 자원명
<DT><B>반환값:</B><DD>자원에 대한 <A HREF="../../java/net/URL.html" title="java.net 동안의 클래스"><CODE><tt>URL</tt></CODE></A>  객체의 열거.
자원이 발견되지 않았던 경우, 열거는 비운다.
클래스 로더가 액세스를 가지지 않는 자원은 열거에 들어가지 않는다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/ClassLoader.html#findResources(java.lang.String)"><CODE>findResources(String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="findResource(java.lang.String)"><!-- --></A> <H3>
findResource</H3>
<PRE>
protected <A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A>  <B>findResource</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>지정된 이름을 가지는 자원을 검색합니다. 클래스 로더의 구현은, 자원의 로드원을 특정하기 위해서 이 메소드를 오버라이드(override) 합니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 자원명
<DT><B>반환값:</B><DD>자원을 읽어들이기 위한 <tt>URL</tt> 객체.  자원이 발견되지 않았던 경우는 <tt>null</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="findResources(java.lang.String)"><!-- --></A> <H3>
findResources</H3>
<PRE>
protected <A HREF="../../java/util/Enumeration.html" title="java.util 내의 인터페이스">Enumeration</A> &lt;<A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A> &gt; <B>findResources</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                                  throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>지정된 이름을 가지는 모든 자원을 나타내는 <A HREF="../../java/net/URL.html" title="java.net 동안의 클래스"><CODE><tt>URL</tt></CODE></A>  객체의 열거를 돌려줍니다. 클래스 로더의 구현은, 자원의 로드원을 특정하기 위해서 이 메소드를 오버라이드(override) 합니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 자원명
<DT><B>반환값:</B><DD>자원 <A HREF="../../java/net/URL.html" title="java.net 중의 클래스"><CODE><tt>URL</tt></CODE></A>  객체의 열거
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSystemResource(java.lang.String)"><!-- --></A> <H3>
getSystemResource</H3>
<PRE>
public static <A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A>  <B>getSystemResource</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>클래스를 로드하기 위해서(때문에) 사용되는 검색 패스로부터, 지정된 이름의 자원을 찾습니다. 이 메소드는 시스템 클래스 로더 (<A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>getSystemClassLoader()</CODE></A>  를 참조)를 사용해 자원을 찾아냅니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 자원명
<DT><B>반환값:</B><DD>자원을 읽어들이기 위한 <A HREF="../../java/net/URL.html" title="java.net 동안의 클래스"><CODE><tt>URL</tt></CODE></A>  객체.  자원이 발견되지 않았던 경우는 <tt>null</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSystemResources(java.lang.String)"><!-- --></A> <H3>
getSystemResources</H3>
<PRE>
public static <A HREF="../../java/util/Enumeration.html" title="java.util 내의 인터페이스">Enumeration</A> &lt;<A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A> &gt; <B>getSystemResources</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                                           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>클래스를 로드하기 위해서(때문에) 사용되는 검색 패스로부터, 지정된 이름의 모든 자원을 찾습니다. 발견된 자원은 <A HREF="../../java/net/URL.html" title="java.net 안의 클래스"><CODE><tt>URL</tt></CODE></A>  객체 <A HREF="../../java/util/Enumeration.html" title="java.util 중의 인터페이스"><CODE><tt>Enumeration</tt></CODE></A>  로서 돌려주어집니다.

 <p> 검색순서에 대해서는,<A HREF="../../java/lang/ClassLoader.html#getSystemResource(java.lang.String)"><CODE>getSystemResource(String)</CODE></A>  의 문서를 참조해 주세요.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 자원명
<DT><B>반환값:</B><DD>자원 <A HREF="../../java/net/URL.html" title="java.net 내의 클래스"><CODE><tt>URL</tt></CODE></A>  객체의 열거
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getResourceAsStream(java.lang.String)"><!-- --></A> <H3>
getResourceAsStream</H3>
<PRE>
public <A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A>  <B>getResourceAsStream</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>지정된 자원을 읽어들이는 입력 스트림을 돌려줍니다.

 <p> 검색순서에 대해서는,<A HREF="../../java/lang/ClassLoader.html#getResource(java.lang.String)"><CODE>getResource(String)</CODE></A>  의 문서를 참조해 주세요.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 자원명
<DT><B>반환값:</B><DD>자원을 읽어들이기 위한 입력 스트림.  자원이 발견되지 않았던 경우는 <tt>null</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSystemResourceAsStream(java.lang.String)"><!-- --></A> <H3>
getSystemResourceAsStream</H3>
<PRE>
public static <A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A>  <B>getSystemResourceAsStream</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>클래스를 로드하는데 사용되는 검색 패스로부터, 지정된 이름의 자원을, read용으로 오픈합니다. 이 메소드는 시스템 클래스 로더 (<A HREF="../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>getSystemClassLoader()</CODE></A>  를 참조)를 사용해 자원을 찾아냅니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 자원명
<DT><B>반환값:</B><DD>자원을 읽어들이기 위한 입력 스트림.  자원이 발견되지 않았던 경우는 <tt>null</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getParent()"><!-- --></A> <H3>
getParent</H3>
<PRE>
public final <A HREF="../../java/lang/ClassLoader.html" title="java.lang 내의 클래스">ClassLoader</A>  <B>getParent</B>()</PRE>
<DL>
<DD>위양을 위한 친클래스 로더를 돌려줍니다. 구현에 따라서는 <tt>null</tt> 를 사용해, bootstrap 클래스 로더를 나타내는 경우도 있습니다. 이 메소드는, 이 클래스 로더의 부모가 bootstrap 클래스 로더의 경우에, 그러한 구현으로 <tt>null</tt> 를 돌려줍니다.

 <p> 시큐리티 매니저가 존재하는 경우, 호출측의 클래스 로더가 <tt>null</tt> 가 아니고, 이 클래스 로더의 상위 객체도 아닌 경우는, 이 메소드는 <A HREF="../../java/lang/RuntimePermission.html#RuntimePermission(java.lang.String)"><CODE><tt>RuntimePermission("getClassLoader")</tt></CODE></A>  액세스권을 사용해 시큐리티 매니저의 <A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE><tt>checkPermission</tt></CODE></A>  메소드를 호출하는 것에 의해, 친클래스 로더에 문제 없게 액세스 할 수 있는 것을 보증합니다. 그렇지 않은 경우는,<tt>SecurityException</tt> 가 throw 됩니다.   </p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>부모의 <tt>ClassLoader</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <tt>checkPermission</tt> 메소드가 이 클래스 로더의 친클래스 로더에의 액세스를 허가하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSystemClassLoader()"><!-- --></A> <H3>
getSystemClassLoader</H3>
<PRE>
public static <A HREF="../../java/lang/ClassLoader.html" title="java.lang 내의 클래스">ClassLoader</A>  <B>getSystemClassLoader</B>()</PRE>
<DL>
<DD>위양을 위한 시스템 클래스 로더를 돌려줍니다. 이것은, 새로운 <tt>ClassLoader</tt> 인스턴스의 디폴트의 위양의 부모로, 일반적으로, 어플리케이션을 기동하기 위한 클래스 로더입니다.

 <p> 이 메소드가 최초로 불려 가는 것은, 실행시의 기동 순서의 초기입니다. 이 시점에서, 메소드는 시스템 클래스 로더를 작성해, 호출하는 <tt>Thread</tt> 의 문맥 클래스 로더에 그것을 설정합니다.

 <p> 디폴트의 시스템 클래스 로더는, 이 클래스의 구현 의존 인스턴스입니다.

 <p> 이 메소드의 최초의 호출시에, 시스템 프로퍼티 「<tt>java.system.class.loader</tt>」가 정의되는 경우, 이 프로퍼티의 값이 시스템 클래스 로더로서 반환되는 클래스의 이름이 됩니다.  이 클래스는, 디폴트의 시스템 클래스 로더를 사용해 로드 됩니다. 또, 이 클래스는, 위양의 부모로서 사용되는,<tt>ClassLoader</tt> 형의 단일의 파라미터를 취하는 public 생성자 을 정의할 필요가 있습니다. 다음에, 이 생성자 을 사용해, 디폴트의 시스템 클래스 로더를 파라미터로 지정해, 인스턴스가 작성됩니다. 결과적으로 얻을 수 있는 클래스 로더는, 시스템 클래스 로더로서 정의됩니다.

 <p> 시큐리티 매니저가 존재해, 호출측의 클래스 로더가 <tt>null</tt> 가 아니고, 호출측의 클래스 로더가 시스템 클래스 로더와 같지 않는가 게다가 위객체도 아닌 경우, 이 메소드는 <A HREF="../../java/lang/RuntimePermission.html#RuntimePermission(java.lang.String)"><CODE><tt>RuntimePermission("getClassLoader")</tt></CODE></A>  액세스권을 사용해 시큐리티 매니저의 <A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE><tt>checkPermission</tt></CODE></A>  메소드를 호출하는 것으로, 시스템 클래스 로더에 액세스 할 수 있을지 어떨지를 확인합니다. 그렇지 않은 경우는,<tt>SecurityException</tt> 가 throw 됩니다.   </p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>위양을 위한 시스템 <tt>ClassLoader</tt>.  없는 경우는 <tt>null</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <tt>checkPermission</tt> 메소드가 이 시스템 클래스 로더에의 액세스를 허가하지 않는 경우
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - <tt>java.system.class.loader</tt>」프로퍼티에 의해 지정된 클래스 로더의 구축시에, 재귀적으로 불려 가는 경우
<DD><CODE><A HREF="../../java/lang/Error.html" title="java.lang 안의 클래스">Error</A> </CODE> - 시스템 프로퍼티 「<tt>java.system.class.loader</tt>」는 정의되지만, 이름 첨부 클래스를 로드할 수 없는 경우, 프로바이더 클래스는 필수 생성자 을 정의하지 않는지, 그 호출시에 예외가 throw 된다. 에러의 근본 원인은,<A HREF="../../java/lang/Throwable.html#getCause()"><CODE>Throwable.getCause()</CODE></A>  메소드를 사용해 취득할 수 있다</DL>
</DD>
</DL>
<HR>

<A NAME="definePackage(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.net.URL)"><!-- --></A> <H3>
definePackage</H3>
<PRE>
protected <A HREF="../../java/lang/Package.html" title="java.lang 내의 클래스">Package</A>  <B>definePackage</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
                                <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;specTitle,
                                <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;specVersion,
                                <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;specVendor,
                                <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;implTitle,
                                <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;implVersion,
                                <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;implVendor,
                                <A HREF="../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;sealBase)
                         throws <A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 내의 클래스">IllegalArgumentException</A> </PRE>
<DL>
<DD>이 <tt>ClassLoader</tt> 로 이름을 사용해 패키지를 정의합니다. 이것에 의해, 클래스 로더는 그 클래스의 패키지를 정의합니다. 클래스를 정의하기 전에, 패키지를 작성할 필요가 있습니다.  패키지명에 대해서는, 클래스 로더내에서 일의로 해, 작성 후의 재정의나 변경은 할 수 없습니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 패키지명<DD><CODE>specTitle</CODE> - 스펙의 타이틀<DD><CODE>specVersion</CODE> - 스펙의 버젼<DD><CODE>specVendor</CODE> - 스펙의 벤더<DD><CODE>implTitle</CODE> - 구현의 타이틀<DD><CODE>implVersion</CODE> - 구현의 버젼<DD><CODE>implVendor</CODE> - 구현의 벤더<DD><CODE>sealBase</CODE> - <tt>null</tt> 가 아닌 경우, 이 패키지는 지정된 코드 소스 <A HREF="../../java/net/URL.html" title="java.net 내의 클래스"><CODE><tt>URL</tt></CODE></A>  객체를 고려해 씰 된다. 그렇지 않은 경우, 패키지는 씰 되지 않는다
<DT><B>반환값:</B><DD>새롭게 정의된 <tt>Package</tt> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 패키지명이, 이 클래스 로더인가 또는 게다가 위객체 가운데 1 개에 존재하는 패키지와 중복 하는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPackage(java.lang.String)"><!-- --></A> <H3>
getPackage</H3>
<PRE>
protected <A HREF="../../java/lang/Package.html" title="java.lang 내의 클래스">Package</A>  <B>getPackage</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>이 클래스 로더인가 게다가 위객체의 어떤 것 등에 의해서 정의된 <tt>Package</tt> 를 돌려줍니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 패키지명
<DT><B>반환값:</B><DD>지정된 이름에 대응하는 <tt>Package</tt>. 발견되지 않는 경우는 <tt>null</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPackages()"><!-- --></A> <H3>
getPackages</H3>
<PRE>
protected <A HREF="../../java/lang/Package.html" title="java.lang 내의 클래스">Package</A> [] <B>getPackages</B>()</PRE>
<DL>
<DD>이 클래스 로더와 게다가 위객체에 의해 정의된 모든 <tt>Packages</tt> 를 돌려줍니다.   </p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 <tt>ClassLoader</tt> 에 의해 정의된 <tt>Package</tt> 객체의 배열<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="findLibrary(java.lang.String)"><!-- --></A> <H3>
findLibrary</H3>
<PRE>
protected <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>findLibrary</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;libname)</PRE>
<DL>
<DD>네이티브 라이브러리의 절대 경로명을 돌아갑니다. VM 는, 이 메소드를 호출해, 이 클래스 로더에 의해 로드 된 클래스의 네이티브 라이브러리를 검색합니다. 이 메소드가 <tt>null</tt> 를 돌려주는 경우, VM 는 「<tt>java.library.path</tt>」프로퍼티으로 지정된 패스에 따라 라이브러리를 검색합니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>libname</CODE> - 라이브러리명
<DT><B>반환값:</B><DD>네이티브 라이브러리의 절대 패스<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/System.html#loadLibrary(java.lang.String)"><CODE>System.loadLibrary(String)</CODE></A> , 
<A HREF="../../java/lang/System.html#mapLibraryName(java.lang.String)"><CODE>System.mapLibraryName(String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultAssertionStatus(boolean)"><!-- --></A> <H3>
setDefaultAssertionStatus</H3>
<PRE>
public void <B>setDefaultAssertionStatus</B>(boolean&nbsp;enabled)</PRE>
<DL>
<DD>이 클래스 로더의 디폴트 선언 상태를 설정합니다. 이 설정에 의해, 장래, 이 클래스 로더가 로드 및 초기화하는 클래스의, 디폴트 선언이 유효 또는 무효로 결정됩니다. <A HREF="../../java/lang/ClassLoader.html#setPackageAssertionStatus(java.lang.String, boolean)"><CODE>setPackageAssertionStatus(String, boolean)</CODE></A>  또는 <A HREF="../../java/lang/ClassLoader.html#setClassAssertionStatus(java.lang.String, boolean)"><CODE>setClassAssertionStatus(String, boolean)</CODE></A>  를 호출하는 것으로, 이 설정을 패키지 또는 클래스 단위로 오버라이드(override) 할 수 있습니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>enabled</CODE> - 이 클래스 로더에 의해 로드 되는 클래스의 선언이, 디폴트로 유효한 경우는 <tt>true</tt>, 디폴트로 무효인 경우는 <tt>false</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setPackageAssertionStatus(java.lang.String, boolean)"><!-- --></A> <H3>
setPackageAssertionStatus</H3>
<PRE>
public void <B>setPackageAssertionStatus</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;packageName,
                                      boolean&nbsp;enabled)</PRE>
<DL>
<DD>이름 첨부 패키지의 디폴트 선언 상태를 설정합니다. 패키지의 디폴트 선언 상태에 의해, 이름 첨부 패키지 또는 그 「서브 패키지」의 어떤 것인가에 속하는, 장래 초기화되는 클래스의 선언 상태가 정해집니다.

 <p> p 라는 이름의 패키지의 서브 패키지는, 모두 이름이 「<tt>p. </tt>」(으)로 시작됩니다. 예를 들어,<tt>javax.swing.text</tt> 는 <tt>javax.swing</tt> 의 서브 패키지입니다.  또,<tt>java.util</tt> 와 <tt>java.lang.reflect</tt> 는 어느쪽이나,<tt>java</tt> 의 서브 패키지입니다.

 <p> 1 개의 클래스에 복수의 디폴트 패키지 적용되는 경우에는, 그 클래스에 가장 관련성의 높은 디폴트 패키지가, 다른 패키지에 우선해 사용됩니다. 예를 들어,<tt>javax.lang</tt> 과 <tt>javax.lang.reflect</tt> 를 어느쪽이나 관련지을 수 있었던 디폴트 패키지를 보관 유지하는 경우, 후자의 디폴트 패키지는 <tt>javax.lang.reflect</tt> 내의 클래스에 적용됩니다.

 <p> 디폴트 패키지는, 클래스 로더의 디폴트 선언 상태보다 우선됩니다.  다만,<A HREF="../../java/lang/ClassLoader.html#setClassAssertionStatus(java.lang.String, boolean)"><CODE>setClassAssertionStatus(String, boolean)</CODE></A>  를 호출하는 것으로, 클래스 단위로 오버라이드(override) 할 수 있습니다.   </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>packageName</CODE> - 패키지 디폴트 선언 상태를 설정하는 패키지명.
<tt>null</tt> 치는, 「current」의 무명 패키지인 것을 나타낸다 (<a href="http://java.sun.com/docs/books/jls/">「Java 언어 스펙」</a>, 섹션 7.4. 2)<DD><CODE>enabled</CODE> - 이 클래스 로더에 의해 로드 되어 이름 첨부 패키지 또는 그 서브 패키지의 어떤 것인가에 속하는 클래스가, 디폴트로 유효한 선언을 보관 유지하는 경우는 <tt>true</tt>, 디폴트로 무효인 선언을 보관 유지하는 경우는 <tt>false</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setClassAssertionStatus(java.lang.String, boolean)"><!-- --></A> <H3>
setClassAssertionStatus</H3>
<PRE>
public void <B>setClassAssertionStatus</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;className,
                                    boolean&nbsp;enabled)</PRE>
<DL>
<DD>이 클래스 로더 및 내부의 상자 구조 클래스내의 이름 첨부의 톱 레벨 클래스에 대해서, 목적의 선언 상태를 설정합니다. 이 설정은, 클래스 로더의 디폴트 선언 상태, 및 패키지 단위로 적용 가능한 디폴트에 우선됩니다. 이름 첨부 클래스가 초기화 끝난 경우, 이 메소드는 무효가 됩니다 (클래스의 초기화 후에 선언 상태를 변경할 수 없기 때문에).

 <p> 이름 첨부 클래스가 톱 레벨의 클래스가 아닌 경우, 이 호출은, 어떠한 클래스의 선언 상태에 대해서도 영향을 주지 않습니다.  </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>className</CODE> - 선언 상태를 설정하는 톱 레벨의 클래스의 완전 수식 클래스명<DD><CODE>enabled</CODE> - 초기화시에, 이름 첨부 클래스에서 선언을 유효하게 하는 경우는 <tt>true</tt>, 선언을 무효로 하는 경우는 <tt>false</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearAssertionStatus()"><!-- --></A> <H3>
clearAssertionStatus</H3>
<PRE>
public void <B>clearAssertionStatus</B>()</PRE>
<DL>
<DD>이 클래스 로더의 디폴트 선언 상태를 <tt>false</tt> 로 설정해, 클래스 로더에 관련지을 수 있었던 디폴트 패키지 및 클래스 선언 상태 설정을 모두 파기합니다. 이 메소드를 이용하면(자), 클래스 로더가 커멘드행 또는 지속적인 선언 상태 설정을 모두 무시하기 위해(때문에), 「깨끗한 상태로」기동할 수 있습니다.
 </p>
<P>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ClassLoader.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/ClassFormatError.html" title="java.lang 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/ClassLoader.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ClassLoader.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
