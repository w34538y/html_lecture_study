<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:59:50 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
LinkedHashMap (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="LinkedHashMap (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LinkedHashMap.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/util/Iterator.html" title="java.util 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/util/LinkedHashSet.html" title="java.util 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/util/LinkedHashMap.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="LinkedHashMap.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_classes_inherited_from_class_java.util.AbstractMap">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util</FONT>
<BR>
클래스 LinkedHashMap&lt;K, V&gt;</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/util/AbstractMap.html" title="java.util 내의 클래스">java.util.AbstractMap</A> &lt;K, V&gt;
      <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/util/HashMap.html" title="java.util 내의 클래스">java.util.HashMap</A> &lt;K, V&gt;
          <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.LinkedHashMap&lt;K, V&gt;</B>
</PRE>
<DL>
<DT><DT><B>형태 파라미터:</B><DD><CODE>K</CODE> - 이 맵이 보관 유지하는 키의 형태<DD><CODE>V</CODE> - 맵 되는 값의 형태</DL>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> , <A HREF="../../java/lang/Cloneable.html" title="java.lang 안의 인터페이스">Cloneable</A> , <A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;K, V&gt;</DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>LinkedHashMap&lt;K, V&gt;</B><DT>extends <A HREF="../../java/util/HashMap.html" title="java.util 내의 클래스">HashMap</A> &lt;K, V&gt;<DT>implements <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;K, V&gt;</DL>
</PRE>

<P>
<p>예측 가능한 반복 순서를 가지는 <tt>Map</tt> 인터페이스의 해시 테이블과 링크 리스트의 구현입니다. 이 구현은, 모든 구현의 엔트리를 거치는 이중의 링크 리스트를 보관 유지한다고 하는 점으로써,<tt>HashMap</tt> 와는 다릅니다. 링크 리스트는, 반복 순서를 정의합니다.  이 순서는, 일반적으로 키가 맵에 삽입된 순서입니다 (삽입순서) . 키를 맵에 「재삽입」하는 경우, 삽입순서는 영향을 받지 않습니다. 호출의 직전에,<tt>m.containsKey(k)</tt> 이 <tt>true</tt> 를 돌려줄 때 <tt>m.put(k, v)</tt> 가 불려 갔을 경우, 키 <tt>k</tt> 가 맵 <tt>m</tt> 에 재삽입됩니다.

 <p>이 구현에서는,<A HREF="../../java/util/TreeMap.html" title="java.util 안의 클래스"><CODE>TreeMap</CODE></A>  관련의 부담의 증대를 지지 않고 ,<A HREF="../../java/util/HashMap.html" title="java.util 안의 클래스"><CODE>HashMap</CODE></A>  및 <A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A>  에 의한, 무지정된 일반적으로는 무질서한 순서로부터 클라이언트를 지킵니다. 이 구현을 사용해, 당초의 맵의 구현에 관계없이, 당초와 같은 순서를 가지는 맵의 카피를 생성할 수가 있습니다.
 <pre>
void foo(Map m) {
Map copy = new LinkedHashMap(m);
         ...
     }
 </pre>
모듈이 입력의 맵을 취득해, 카피해, 카피의 맵이 설정한 순서의 결과를 돌려주었을 경우, 이 기술은 특별히 도움이 됩니다. 일반적으로, 클라이언트는 제시와 같은 순서로 반환되는 것을 평가합니다.

 <p>특별한<A HREF="../../java/util/LinkedHashMap.html#LinkedHashMap(int, float, boolean)"><CODE>생성자</CODE></A> 이, 링크 해시 맵 작성을 위해 제공됩니다.  이 맵의 반복 순서는, 마지막에 엔트리에 액세스 한 순서가 됩니다.  순서는 가장 전에 액세스 한 것으로부터 시작되어, 가장 후에 액세스 한 것으로 끝납니다 (액세스순서). 이런 종류의 맵은, LRU 캐쉬를 구축하는데 최적입니다. <tt>put</tt> 또는 <tt>get</tt> 메소드를 호출하면(자), 대응하는 엔트리에 액세스 합니다 (호출 완료 후에, 대응하는 엔트리가 있으면(자) 가정합니다). 키치 매핑이 지정된 맵의 엔트리 세트 반복자에 의해 제공되는 순서로,<tt>putAll</tt> 메소드는, 지정된 맵의 매핑 마다 엔트리 액세스를 1 개 생성합니다. <i>엔트리 액세스를 생성하는 메소드는 그 밖에 없습니다. </i>특히는 코레크션뷰에 대한 오퍼레이션은, 바탕으로 되는 맵의 반복 순서에는 영향을 주지 않습니다.

 <p>맵에 새로운 매핑을 추가할 때, 자동적으로 무효인 매핑을 삭제하는 정책를 규정하기 위해서,<A HREF="../../java/util/LinkedHashMap.html#removeEldestEntry(java.util.Map.Entry)"><CODE>removeEldestEntry(Map.Entry)</CODE></A>  메소드가 오버라이드(override) 되는 경우가 있습니다.

 <p>이 클래스는, 옵션의 <tt>Map</tt> 오퍼레이션을 모두 제공해, null 요소를 허용 합니다. <tt>HashMap</tt> 와 같이, 해쉬 함수가 복수의 버킷에 적절히 요소를 분산하면(자) 가정해, 기본의 오퍼레이션 (<tt>add</tt>,<tt>contains</tt>, 및 <tt>remove</tt>)에 일정시간의 퍼포먼스를 제공합니다. 퍼포먼스는, 1 개의 예외를 제외해, 링크 리스트를 보관 유지하는 부담의 증대에 의해,<tt>HashMap</tt> 의 퍼포먼스보다 조금 뒤떨어지는 경우가 있습니다. <tt>LinkedHashMap</tt> 의 코레크션뷰의 반복에는, 용량에 관계없이, 맵의 「사이즈」에 비례한 시간이 필요하게 됩니다. 「용량」에 비례한 시간을 필요로 하므로,<tt>HashMap</tt> 의 반복은, 한층 더 비싸게 들 우려가 있습니다.

 <p>링크 해시 맵에는, 퍼포먼스에 영향을 미치는 파라미터가 2 개 있습니다. 「초기 용량」과「부하 계수」입니다. 이러한 파라미터는,<tt>HashMap</tt> 에 대해 정확하게 정의되고 있습니다. 다만, 이 클래스의 반복 회수는 용량에 의해 영향을 받지 않기 때문에, 초기 용량에 매우 비싼 값을 선택해도, 이 클래스에서는 <tt>HashMap</tt> 에 비해 그만큼 결과는 몹시는 없습니다.

 <p><strong>이 구현은 동기화 되지 않습니다. </strong>복수의 thread가 동시에 링크 해시 세트에 액세스 해, 그러한 thread의 적어도 1 개(살)이 구조적으로 맵을 변경하는 경우에는, 외부에서 동기를 잡을 필요가 있습니다. 일반적으로, 구조적인 변경은, 맵을 자연스럽게 캡슐화하는 특정의 객체로 동기를 잡는 것에 의해 달성됩니다.

이런 종류의 객체가 없는 경우에는,<A HREF="../../java/util/Collections.html#synchronizedMap(java.util.Map)"><CODE>Collections.synchronizedMap</CODE></A>  메소드를 사용해 맵을 「랩」할 필요가 있습니다. 맵에의 우발적인 비동기 액세스를 막기 위해서(때문에), 작성시에 실시하는 것이 최적입니다. <pre>
Map m = Collections.synchronizedMap(new LinkedHashMap(...));</pre>

구조적인 변경은, 1 개(살) 또는 복수의 매핑을 추가 또는 삭제해, 링크 해시 맵이 액세스순서의 경우는, 반복의 순서에 영향을 주는 오퍼레이션입니다. 링크 해시 맵이 삽입순서의 경우는, 맵에 포함 끝난 키에 관련하는 값을 단지 변경하는 것은, 구조의 수정이 아닙니다. <strong>링크 해시 맵이 액세스순서의 경우는,<tt>get</tt> 에 의해 맵을 단지 조회하는 것은, 구조의 변경이 됩니다. </strong>

 <p>이 클래스의 모든 코레크션뷰메소드에 의해 반환되는 컬렉션의 <tt>iterator</tt> 메소드에 의해 반환되는 반복자는, 「fail-fast」입니다. <em></em>반복자의 작성 후에, 반복자 자체의 <tt>remove</tt> 메소드 이외 방법으로 맵이 구조적으로 변경되면(자), 반복자는 <A HREF="../../java/util/ConcurrentModificationException.html" title="java.util 안의 클래스"><CODE>ConcurrentModificationException</CODE></A>  를 throw 합니다. 이와 같이, 병행해 변경을 하면(자), 반복자는, 장래의 예측할 수 없는 시점에 있어 예측할 수 없는 동작이 발생하는 위험을 회피하기 위해서, 즉시 한편 솜씨 자주(잘) 예외를 throw 합니다.

 <p>일반적으로, 비동기의 병행 변경이 있는 경우, 확실한 보증을 실시하는 것은 불가능해서, 반복자의 fail-fast의 동작을 보증할 수 없습니다. fail-fast 반복자는 최선 노력 원칙에 근거해,<tt>ConcurrentModificationException</tt> 를 throw 합니다. 따라서, 정확을 기하기 위해서 이 예외에 의존하는 프로그램을 쓰는 것은 잘못입니다. <i>「반복자의 fail-fast의 동작은 버그를 검출하기 위해서 사용해야 합니다」. </i>

 <p>이 클래스는,<a href="../../../technotes/guides/collections/index.html">Java Collections Framework</a>  의 멤버입니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A> , 
<A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스"><CODE>Collection</CODE></A> , 
<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스"><CODE>Map</CODE></A> , 
<A HREF="../../java/util/HashMap.html" title="java.util 안의 클래스"><CODE>HashMap</CODE></A> , 
<A HREF="../../java/util/TreeMap.html" title="java.util 안의 클래스"><CODE>TreeMap</CODE></A> , 
<A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> , 
<A HREF="../../serialized-form.html#java.util.LinkedHashMap">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_java.util.AbstractMap"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.util. <A HREF="../../java/util/AbstractMap.html" title="java.util 안의 클래스">AbstractMap</A>  로부터 상속된 상자의 클래스/인터페이스</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/util/AbstractMap.SimpleEntry.html" title="java.util 안의 클래스">AbstractMap.SimpleEntry</A> &lt;<A HREF="../../java/util/AbstractMap.SimpleEntry.html" title="AbstractMap.SimpleEntry 내의 형태 파라미터">K</A> ,<A HREF="../../java/util/AbstractMap.SimpleEntry.html" title="AbstractMap.SimpleEntry 안의 형태 파라미터">V</A> &gt;, <A HREF="../../java/util/AbstractMap.SimpleImmutableEntry.html" title="java.util 안의 클래스">AbstractMap.SimpleImmutableEntry</A> &lt;<A HREF="../../java/util/AbstractMap.SimpleImmutableEntry.html" title="AbstractMap.SimpleImmutableEntry 내의 형태 파라미터">K</A> ,<A HREF="../../java/util/AbstractMap.SimpleImmutableEntry.html" title="AbstractMap.SimpleImmutableEntry 안의 형태 파라미터">V</A> &gt;</CODE></TD>
</TR>
</TABLE>
&nbsp;

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/util/LinkedHashMap.html#LinkedHashMap()">LinkedHashMap</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트의 초기 용량 (16)과 부하 계수 (0.75)로 빈 상태(empty)의 삽입순서 <tt>LinkedHashMap</tt> 인스턴스를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/util/LinkedHashMap.html#LinkedHashMap(int)">LinkedHashMap</A> </B>(int&nbsp;initialCapacity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 초기 용량과 디폴트의 부하 계수 (0.75)로 빈 상태(empty)의 삽입순서 <tt>LinkedHashMap</tt> 인스턴스를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/util/LinkedHashMap.html#LinkedHashMap(int, float)">LinkedHashMap</A> </B>(int&nbsp;initialCapacity,
              float&nbsp;loadFactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 초기 용량과 부하 계수로 빈 상태(empty)의 삽입순서 <tt>LinkedHashMap</tt> 인스턴스를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/util/LinkedHashMap.html#LinkedHashMap(int, float, boolean)">LinkedHashMap</A> </B>(int&nbsp;initialCapacity,
              float&nbsp;loadFactor,
              boolean&nbsp;accessOrder)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 초기 용량, 부하 계수, 및 순서 모드로, 빈 상태(empty)의 <tt>LinkedHashMap</tt> 인스턴스를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/util/LinkedHashMap.html#LinkedHashMap(java.util.Map)">LinkedHashMap</A> </B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?  extends <A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">K</A> ,?  extends <A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">V</A> &gt;&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Map 와 같은 매핑으로 삽입순서의 <tt>LinkedHashMap</tt> 인스턴스를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/LinkedHashMap.html#clear()">clear</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 매핑을 맵으로부터 삭제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/LinkedHashMap.html#containsValue(java.lang.Object)">containsValue</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;맵이 1 개 또는 복수의 키와 지정된 값을 매핑 하고 있는 경우에 <tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">V</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/LinkedHashMap.html#get(java.lang.Object)">get</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 키가 맵 되고 있는 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/LinkedHashMap.html#removeEldestEntry(java.util.Map.Entry)">removeEldestEntry</A> </B>(<A HREF="../../java/util/Map.Entry.html" title="java.util 안의 인터페이스">Map.Entry</A> &lt;<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">K</A> ,<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 안의 형태 파라미터">V</A> &gt;&nbsp;eldest)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 맵이 제일 낡은 엔트리를 삭제하는 경우,<tt>true</tt> 를 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.HashMap"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.util. <A HREF="../../java/util/HashMap.html" title="java.util 안의 클래스">HashMap</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/util/HashMap.html#clone()">clone</A> , <A HREF="../../java/util/HashMap.html#containsKey(java.lang.Object)">containsKey</A> , <A HREF="../../java/util/HashMap.html#entrySet()">entrySet</A> , <A HREF="../../java/util/HashMap.html#isEmpty()">isEmpty</A> , <A HREF="../../java/util/HashMap.html#keySet()">keySet</A> , <A HREF="../../java/util/HashMap.html#put(K, V)">put</A> , <A HREF="../../java/util/HashMap.html#putAll(java.util.Map)">putAll</A> , <A HREF="../../java/util/HashMap.html#remove(java.lang.Object)">remove</A> , <A HREF="../../java/util/HashMap.html#size()">size</A> , <A HREF="../../java/util/HashMap.html#values()">values</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.AbstractMap"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.util. <A HREF="../../java/util/AbstractMap.html" title="java.util 안의 클래스">AbstractMap</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/util/AbstractMap.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/util/AbstractMap.html#hashCode()">hashCode</A> , <A HREF="../../java/util/AbstractMap.html#toString()">toString</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.Map"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.util. <A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/util/Map.html#containsKey(java.lang.Object)">containsKey</A> , <A HREF="../../java/util/Map.html#entrySet()">entrySet</A> , <A HREF="../../java/util/Map.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/util/Map.html#hashCode()">hashCode</A> , <A HREF="../../java/util/Map.html#isEmpty()">isEmpty</A> , <A HREF="../../java/util/Map.html#keySet()">keySet</A> , <A HREF="../../java/util/Map.html#put(K, V)">put</A> , <A HREF="../../java/util/Map.html#putAll(java.util.Map)">putAll</A> , <A HREF="../../java/util/Map.html#remove(java.lang.Object)">remove</A> , <A HREF="../../java/util/Map.html#size()">size</A> , <A HREF="../../java/util/Map.html#values()">values</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="LinkedHashMap(int, float)"><!-- --></A> <H3>
LinkedHashMap</H3>
<PRE>
public <B>LinkedHashMap</B>(int&nbsp;initialCapacity,
                     float&nbsp;loadFactor)</PRE>
<DL>
<DD>지정된 초기 용량과 부하 계수로 빈 상태(empty)의 삽입순서 <tt>LinkedHashMap</tt> 인스턴스를 작성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>initialCapacity</CODE> - 초기 용량<DD><CODE>loadFactor</CODE> - 부하 계수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 초기 용량이 부일까 부하 계수가 정이 아닌 경우</DL>
</DL>
<HR>

<A NAME="LinkedHashMap(int)"><!-- --></A> <H3>
LinkedHashMap</H3>
<PRE>
public <B>LinkedHashMap</B>(int&nbsp;initialCapacity)</PRE>
<DL>
<DD>지정된 초기 용량과 디폴트의 부하 계수 (0.75)로 빈 상태(empty)의 삽입순서 <tt>LinkedHashMap</tt> 인스턴스를 작성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>initialCapacity</CODE> - 초기 용량
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 초기 용량이 부의 경우</DL>
</DL>
<HR>

<A NAME="LinkedHashMap()"><!-- --></A> <H3>
LinkedHashMap</H3>
<PRE>
public <B>LinkedHashMap</B>()</PRE>
<DL>
<DD>디폴트의 초기 용량 (16)과 부하 계수 (0.75)로 빈 상태(empty)의 삽입순서 <tt>LinkedHashMap</tt> 인스턴스를 작성합니다.
<P>
</DL>
<HR>

<A NAME="LinkedHashMap(java.util.Map)"><!-- --></A> <H3>
LinkedHashMap</H3>
<PRE>
public <B>LinkedHashMap</B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?  extends <A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">K</A> ,?  extends <A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">V</A> &gt;&nbsp;m)</PRE>
<DL>
<DD>지정된 Map 와 같은 매핑으로 삽입순서의 <tt>LinkedHashMap</tt> 인스턴스를 작성합니다. <tt>LinkedHashMap</tt> 인스턴스는, 지정된 Map 의 매핑을 보관 유지하는데 충분한 디폴트의 부하 계수 (0.75) , 및 초기 용량으로 작성됩니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>m</CODE> - 매핑이 이 맵에 배치되는 맵
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 지정된 맵이 null 의 경우</DL>
</DL>
<HR>

<A NAME="LinkedHashMap(int, float, boolean)"><!-- --></A> <H3>
LinkedHashMap</H3>
<PRE>
public <B>LinkedHashMap</B>(int&nbsp;initialCapacity,
                     float&nbsp;loadFactor,
                     boolean&nbsp;accessOrder)</PRE>
<DL>
<DD>지정된 초기 용량, 부하 계수, 및 순서 모드로, 빈 상태(empty)의 <tt>LinkedHashMap</tt> 인스턴스를 작성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>initialCapacity</CODE> - 초기 용량<DD><CODE>loadFactor</CODE> - 부하 계수<DD><CODE>accessOrder</CODE> - 순서부 모드 - 액세스 유순한들 <tt>true</tt>. 삽입 유순한들<tt>false</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 초기 용량이 부일까 부하 계수가 정이 아닌 경우</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="containsValue(java.lang.Object)"><!-- --></A> <H3>
containsValue</H3>
<PRE>
public boolean <B>containsValue</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;value)</PRE>
<DL>
<DD>맵이 1 개 또는 복수의 키와 지정된 값을 매핑 하고 있는 경우에 <tt>true</tt> 를 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">K</A> ,<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 안의 형태 파라미터">V</A> &gt;</CODE> 내의 <CODE><A HREF="../../java/util/Map.html#containsValue(java.lang.Object)">containsValue</A> </CODE><DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/util/HashMap.html" title="java.util 내의 클래스">HashMap</A> &lt;<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">K</A> ,<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 안의 형태 파라미터">V</A> &gt;</CODE> 내의 <CODE><A HREF="../../java/util/HashMap.html#containsValue(java.lang.Object)">containsValue</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>value</CODE> - 맵에 있을지 어떨지를 판정되는 값
<DT><B>반환값:</B><DD>맵이 1 개 또는 복수의 키와 지정된 값을 매핑 하고 있는 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="get(java.lang.Object)"><!-- --></A> <H3>
get</H3>
<PRE>
public <A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">V</A>  <B>get</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key)</PRE>
<DL>
<DD>지정된 키가 맵 되고 있는 값을 돌려줍니다. 그 키의 매핑이 이 맵에 포함되지 않은 경우는 <code>null</code> 를 돌려줍니다.

 <p>즉, 이 메소드는,<code>(key==null ?  k==null : key.equals(k))</code> 가 되는 키 <code>k</code> 로부터 값 <code>v</code> 에의 매핑이 이 맵에 포함되어 있는 경우는 <code>v</code> 를 돌려주어, 그 이외의 경우는 <code>null</code> 를 돌려줍니다. 이러한 매핑이 1 개만 있습니다.

 <p>반환값의 <code>null</code> 는, 맵이 키의 매핑을 보관 유지하고 있지 않는 것을 나타낸다고는인가 선.  즉, 맵이 명시적으로 키를 <code>null</code> 에 맵 하는 일도 있습니다. <A HREF="../../java/util/HashMap.html#containsKey(java.lang.Object)"><CODE>containsKey</CODE></A>  오퍼레이션을 사용하면(자), 이 2 개의 경우를 구별할 수 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">K</A> ,<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 안의 형태 파라미터">V</A> &gt;</CODE> 내의 <CODE><A HREF="../../java/util/Map.html#get(java.lang.Object)">get</A> </CODE><DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/util/HashMap.html" title="java.util 내의 클래스">HashMap</A> &lt;<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">K</A> ,<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 안의 형태 파라미터">V</A> &gt;</CODE> 내의 <CODE><A HREF="../../java/util/HashMap.html#get(java.lang.Object)">get</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 관련지을 수 있었던 값이 반환되는 키
<DT><B>반환값:</B><DD>지정된 키가 맵 되고 있는 값. 그 키의 매핑이 이 맵에 포함되지 않은 경우는 <code>null</code><DT><B>관련 항목:</B><DD><A HREF="../../java/util/HashMap.html#put(K, V)"><CODE>HashMap.put(Object, Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="clear()"><!-- --></A> <H3>
clear</H3>
<PRE>
public void <B>clear</B>()</PRE>
<DL>
<DD>모든 매핑을 맵으로부터 삭제합니다. 이 호출이 돌아오면(자), 맵은 비웁니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">K</A> ,<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 안의 형태 파라미터">V</A> &gt;</CODE> 내의 <CODE><A HREF="../../java/util/Map.html#clear()">clear</A> </CODE><DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/util/HashMap.html" title="java.util 내의 클래스">HashMap</A> &lt;<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">K</A> ,<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 안의 형태 파라미터">V</A> &gt;</CODE> 내의 <CODE><A HREF="../../java/util/HashMap.html#clear()">clear</A> </CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeEldestEntry(java.util.Map.Entry)"><!-- --></A> <H3>
removeEldestEntry</H3>
<PRE>
protected boolean <B>removeEldestEntry</B>(<A HREF="../../java/util/Map.Entry.html" title="java.util 안의 인터페이스">Map.Entry</A> &lt;<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 내의 형태 파라미터">K</A> ,<A HREF="../../java/util/LinkedHashMap.html" title="LinkedHashMap 안의 형태 파라미터">V</A> &gt;&nbsp;eldest)</PRE>
<DL>
<DD>이 맵이 제일 낡은 엔트리를 삭제하는 경우,<tt>true</tt> 를 돌려줍니다. 새로운 엔트리를 맵에 삽입하면(자),<tt>put</tt> 및 <tt>putAll</tt> 에 의해 이 메소드가 불려 갑니다. 새로운 엔트리가 추가될 때마다, 이 메소드는 제일 낡은 엔트리를 삭제할 기회를 구현 측에 제공합니다. 이것은, 맵이 캐쉬를 나타내는 경우에 유효합니다. 그것에 의해, 무효가 된 엔트리를 삭제해, 맵이 메모리 소비를 저감 할 수가 있습니다.

 <p>샘플 사용:이 오버라이드(override)에 의해, 맵이 엔트리를 최대 100까지 증가시킬 수가 있어 엔트리수 100 의 정상 상태를 유지해, 새로운 엔트리가 추가될 때마다 제일 낡은 엔트리를 삭제할 수가 있습니다.
 <pre>
private static final int MAX_ENTRIES = 100;

protected boolean removeEldestEntry(Map.Entry eldest) {
return size() > MAX_ENTRIES;
     }
 </pre>

 <p>일반적으로 이 메소드는 맵을 수정하지 않습니다.  대신에, 반환값의 지시 대로에 맵에 맵 자체를 수정시킵니다. 이 메소드가 맵을 직접 수정할 수 있도록(듯이) 합니다.  다만, 수정했을 경우는,<tt>false</tt> 를 돌려줄 필요가 있습니다.  이것은, 맵이 그 이상의 수정을 시도하지 않는 것을 나타냅니다. 이 메소드내로부터의 맵 수정 후에 <tt>true</tt> 를 돌려주는 효과는 미지정입니다.

 <p>이 구현은,<tt>false</tt> 를 돌려줄 뿐입니다. 그 때문에, 이 맵은 일반적으로의 맵과 같이 작용합니다. 제일 낡은 요소는 삭제되지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>eldest</CODE> - 가장 이전에 맵에 삽입된 엔트리. 다만, 이것이 액세스순서 맵인 경우는 가장 이전에 액세스 된 엔트리. 이것은, 이 메소드가 <tt>true</tt> 를 돌려주었을 경우에 삭제되는 엔트리이다. 이 호출의 원인이 된 <tt>put</tt> 또는 <tt>putAll</tt> 호출을 하기 전에 맵이 빈 상태(empty)에서 만났을 경우, 이것은 삽입된지 얼마 안된 엔트리가 된다. 즉, 맵에 단일의 엔트리가 포함되어 있는 경우, 가장 낡은 엔트리는 가장 새로운 엔트리이기도 하다
<DT><B>반환값:</B><DD>가장 낡은 엔트리를 맵으로부터 삭제해야 할 경우는 <tt>true</tt>. 그 엔트리를 보관 유지해야 할 경우는 <tt>false</tt></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LinkedHashMap.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/util/Iterator.html" title="java.util 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/util/LinkedHashSet.html" title="java.util 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/util/LinkedHashMap.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="LinkedHashMap.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_classes_inherited_from_class_java.util.AbstractMap">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
