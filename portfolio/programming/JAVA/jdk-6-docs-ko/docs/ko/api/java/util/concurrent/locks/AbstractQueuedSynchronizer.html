<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:01:03 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
AbstractQueuedSynchronizer (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="AbstractQueuedSynchronizer (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractQueuedSynchronizer.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/locks/AbstractQueuedSynchronizer.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="AbstractQueuedSynchronizer.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent.locks</FONT>
<BR>
클래스 AbstractQueuedSynchronizer</H2>
<PRE>
<A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.html" title="java.util.concurrent.locks 내의 클래스">java.util.concurrent.locks.AbstractOwnableSynchronizer</A> 
      <IMG SRC="../../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.concurrent.locks.AbstractQueuedSynchronizer</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>AbstractQueuedSynchronizer</B><DT>extends <A HREF="../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.html" title="java.util.concurrent.locks 내의 클래스">AbstractOwnableSynchronizer</A> <DT>implements <A HREF="../../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
블록 락, 및 선입선출 (FIFO) 대기 큐에 의존하는 관련 싱크로나이저 (세마포어-, 이벤트등)를 구현하는 시스템를 제공합니다. 이 클래스는, 상태 표현을 단일의 원자 <tt>int</tt> 치에 의존하는 대부분의 종류의 싱크로나이저의 유용한 기반으로서 설계되고 있습니다. 서브 클래스는, 이 상태를 변경하는 protected 메소드를 정의할 필요가 있어, 그 메소드는 취득 또는 해제중의 객체를 사용해 상태의 의미를 정의합니다. 이것들이 지정되면(자), 이 클래스내외의 메소드는 모든 큐 및 블록 기구를 가동시킵니다. 서브 클래스는, 다른 상태 필드를 유지할 수 있습니다만, 동기에 관한 추적을 실시할 수 있는 것은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getState()"><CODE>getState()</CODE></A> ,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#setState(int)"><CODE>setState(int)</CODE></A> , 및 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#compareAndSetState(int, int)"><CODE>compareAndSetState(int, int)</CODE></A>  메소드를 사용해 조작되어 원자적으로 갱신된 <tt>int</tt> 치 뿐입니다.

 <p>서브 클래스는, public 가 아닌 내부 헬퍼 클래스로서 정의할 필요가 있습니다. 이것은, 그것을 둘러싸는 클래스의 동기 프로퍼티의 구현에 사용됩니다. <tt>AbstractQueuedSynchronizer</tt> 클래스는, 동기 인터페이스를 일절 구현하지 않습니다. 그 대신해, 구상 락 및 관련하는 싱크로나이저에 의해 적당 호출해 public 메소드를 구현할 수 있는 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#acquireInterruptibly(int)"><CODE>acquireInterruptibly(int)</CODE></A>  등의 메소드를 정의합니다.

 <p>이 클래스는, 디폴트의 「배타」모드 및 「공유」모드의 언젠가 또는 양쪽 모두를 지원합니다. 배타 모드로 취득되면(자), 다른 thread가 취득을 시도해도 성공하지 않습니다. 공유 모드에서는, 복수의 thread에 의한 취득이 가능합니다 (다만, 반드시 취득이 성공할 필요가 있는 것은 아니다). 이 클래스는, 공유 모드의 취득이 성공했을 경우, 대기중의 다음의 thread (존재하는 경우)도 취득 가능한가 어떤가를 판별할 필요가 있다고 하는 기구적인 의미를 제외해, 이러한 차이를 「인식」하지 않습니다. 다른 모드로 대기중의 thread는, 같은 FIFO 큐를 공유합니다. 일반적으로, 구현 서브 클래스는 이러한 모드의 1 개만을 지원합니다만,<A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>ReadWriteLock</CODE></A>  등에서는 양쪽 모두가 기능하는 것이 가능합니다. 배타 모드 또는 공유 모드만을 지원하는 서브 클래스는, 사용하지 않는 모드를 지원하는 메소드를 정의할 필요는 없습니다.

 <p>이 클래스는, 배타 모드를 지원하는 서브 클래스에 의해 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A>  구현으로서 사용 가능한, 상자로 된 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 동안의 클래스"><CODE>AbstractQueuedSynchronizer.ConditionObject</CODE></A>  클래스를 정의합니다.  <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#isHeldExclusively()"><CODE>isHeldExclusively()</CODE></A>  는, 이 클래스에 관계되어, 동기가 현재의 thread에 관해서 배타적으로 보관 유지되는지, 현재의 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getState()"><CODE>getState()</CODE></A>  치를 사용해 불려 간 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#release(int)"><CODE>release(int)</CODE></A>  메소드가 이 객체를 완전하게 해제하는지, 이 보존이 끝난 상태치가 지정되면(자) <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#acquire(int)"><CODE>acquire(int)</CODE></A>  가 최종적으로 이 객체를 이전에 취득된 상태에 복원하는지를 리포트합니다. 그 이외에서는,<tt>AbstractQueuedSynchronizer</tt> 메소드는 이 상태를 작성하지 않기 때문에, 이 제한을 채울 수가 없는 경우는 사용하지 말아 주세요. 당연한 일입니다만,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스"><CODE>AbstractQueuedSynchronizer.ConditionObject</CODE></A>  의 동작은 싱크로나이저 구현의 시멘틱스에 의존합니다.

 <p>이 클래스는, 내부 큐의 검증, 계측, 및 감시용 메소드, 및 상태 객체용의 유사 메소드를 제공합니다. 이것들은, 필요하게 응해  동기기구의 <tt>AbstractQueuedSynchronizer</tt> 를 사용해 클래스내에 export 할 수 있습니다.

 <p>이 클래스를 직렬화하면(자), 기본으로 되는 원자 정수의 보수 상태만이 포함되기 (위해)때문에, 직렬화 복원된 객체는 빈 상태(empty)의 thread 큐를 보관 유지합니다. 직렬화 기능을 필요로 하는 일반적으로의 서브 클래스는, 직렬화 복원시에 이것을 기존의 초기 상태에 복원하는 <tt>readObject</tt> 메소드를 정의합니다.

<h3>사용법</h3>

 <p>이 클래스를 싱크로나이저의 기반으로서 사용하려면 , 적용 가능하면 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getState()"><CODE>getState()</CODE></A> ,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#setState(int)"><CODE>setState(int)</CODE></A> ,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#compareAndSetState(int, int)"><CODE>compareAndSetState(int, int)</CODE></A>  를 사용해 동기 상태의 검증이나 변경을 실시하는 것으로, 다음의 메소드를 재정의합니다.

 <ul>
<li> <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A> 
<li> <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryRelease(int)"><CODE>tryRelease(int)</CODE></A> 
<li> <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A> 
<li> <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryReleaseShared(int)"><CODE>tryReleaseShared(int)</CODE></A> 
<li> <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#isHeldExclusively()"><CODE>isHeldExclusively()</CODE></A> 
</ul>

이러한 각 메소드는, 디폴트로 <A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A>  를 throw 합니다. 이러한 메소드의 구현은, 내부가 thread 세이프가 아니면 안되어, 또, 일반적으로은 짧고 한편 블로킹없이 없으면 안됩니다. 이러한 메소드의 정의는, 이 클래스의 지원되는 유일한 사용 방법입니다. 다른 메소드는 모두, 개별적으로 변경할 수 없기 때문에,<tt>final</tt> 라고 선언됩니다.

 <p><A HREF="../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.html" title="java.util.concurrent.locks 안의 클래스"><CODE>AbstractOwnableSynchronizer</CODE></A>  로부터 상속되는 메소드는, 배타적인 싱크로나이저를 소유하는 thread를 추적할 경우에 편리합니다. 락을 보관 유지하는 thread를 판단하는데 도움이 되는 감시 및 진단의 툴이 유효하게 되기 (위해)때문에, 이것들을 사용하는 것을 추천합니다.

 <p>이 클래스는 내부의 FIFO 큐에 근거한다고는 해도, 자동적으로 FIFO 취득 정책가 적용되는 것은 아닙니다. 배타적인 동기의 코어는, 다음의 형식이 됩니다.

 <pre>
 Acquire:
     while (! tryAcquire(arg)) {
        <em>enqueue thread if it is not already queued</em>;
        <em>possibly block current thread</em>;
     }

 Release:
     if (tryRelease(arg))
        <em>unblock the first queued thread</em>;
 </pre>

(공유 모드도 비슷하지만, cascade 신호가 관계하는 경우가 있다)

 <p>취득의 체크는 큐에 넣어지기 전에 불려 가므로, 새롭게 취득되는 thread는, 블록 및 큐에 넣어지는 것 외의 thread보다 먼저 「화물 운반선 한다」일이 가능합니다. 다만, 필요하면,<tt>tryAcquire</tt> 이나 <tt>tryAcquireShared</tt> 를 정의해, 1 개(살) 이상의 검증 메소드를 내부에서 호출하는 것으로, 화물 운반선을 무효로 할 수 있습니다. 특히, 엄밀한 FIFO 락은 <tt>tryAcquire</tt> 를 정의해,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getFirstQueuedThread()"><CODE>getFirstQueuedThread()</CODE></A>  가 현재의 thread를 돌려주지 않는 경우에 즉시 <tt>false</tt> 를 돌려주는 것이 가능합니다. 일반적으로 바람직한 비엄밀하고 공평한 버젼은,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#hasQueuedThreads()"><CODE>hasQueuedThreads()</CODE></A>  가 <tt>true</tt> 를 돌려주어,<tt>getFirstQueuedThread</tt> 가 현재의 thread가 아닌 (즉 <tt>getFirstQueuedThread</tt> 가 null 에서도 현재의 thread도 아니다) 경우에게만, 즉시 <tt>false</tt> 를 돌려줄 수가 있습니다. 새로운 변화(variation)이 가능합니다.

 <p>일반적으로, throughput와 스케이라비리티는, 디폴트의 화물 운반선 ( 「탐욕」, 「방폐」, 「호송 회피」라고도 불린다) 스트래터지의 최상정도에 위치합니다. 이것이 편향이 없고, 고갈하지 않는 것은 보증됩니다만, 먼저 큐에 넣어진 thread는, 나중에 큐에 넣어지는 thread보다 전에 재경합이 허가되어 각 재경합은 착신하는 thread에 대해서 성공하는 공평한 기회를 보관 유지합니다. 또, 취득은, 일반적으로적인 의미에서는 「스핀」하지 않습니다만, 블로킹전에 다른 계산에 삽입된 <tt>tryAcquire</tt> 의 복수의 호출을 실행 가능합니다. 이것에 의해, 배타적인 동기가 단기적으로 보관 유지될 뿐(만큼)의 경우, 스핀의 혜택의 대부분을 향수할 수 있습니다.  게다가 배타적인 동기가 보관 유지되지 않는 경우에는 거의 부담없이, 그 혜택을 향수할 수 있습니다.  필요하게 응해 「지름길」체크를 가지는 메소드를 취득하는 호출을 앞두고 배치하는 것으로, 이 값을 늘릴 수가 있습니다.

 <p>이것은, 싱크로나이저가 경합 할 가능성이 적은 경우,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#hasContended()"><CODE>hasContended()</CODE></A>  나 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#hasQueuedThreads()"><CODE>hasQueuedThreads()</CODE></A>  를 사전에 체크하는 등 방법으로 실행할 수 있습니다. 이 클래스는, 사용 범위를 <tt>int</tt> 상태, 파라미터의 취득과 해제, 및 내부 FIFO 대기 큐에 의존 가능한 싱크로나이저로 한정하는 것으로, 효율적으로 확장성의 높은 동기 기반의 일부를 제공합니다. 이것이라도 충분하지 않는 경우,<A HREF="../../../../java/util/concurrent/atomic/package-summary.html"><CODE>atomic</CODE></A>  클래스, 독자적인 커스텀 <A HREF="../../../../java/util/Queue.html" title="java.util 내의 인터페이스"><CODE>Queue</CODE></A>  클래스, 및 <A HREF="../../../../java/util/concurrent/locks/LockSupport.html" title="java.util.concurrent.locks 안의 클래스"><CODE>LockSupport</CODE></A>  블록 지원를 사용해, 싱크로나이저를 저레벨로부터 구축할 수 있습니다.

<h3>사용예</h3>

 <p>다음에, 값제로를 사용해 락 해제 상태 및 락 상태를 나타내는 재입 불가능한 상호 배타 락 클래스를 나타냅니다. 재입 불가능한 락에서는, 엄밀하게는 현재의 소유자 thread를 기록할 필요는 없습니다만, 이 클래스에서는 사용 상황을 간단하게 감시할 수 있도록(듯이), 기록을 실시합니다. 이것은, 상태의 지원 및 몇개의 계측 메소드의 공개도 실시합니다.

 <pre>
 class Mutex implements Lock, java.io.Serializable {

   // Our internal helper class
   private static class Sync extends AbstractQueuedSynchronizer {
     // Report whether in locked state
     protected boolean isHeldExclusively() {
       return getState() == 1;
     }

     // Acquire the lock if state is zero
     public boolean tryAcquire(int acquires) {
       assert acquires == 1; // Otherwise unused
       if (compareAndSetState(0, 1)) {
         setExclusiveOwnerThread(Thread.currentThread());
         return true;
       }
       return false;
     }

     // Release the lock by setting state to zero
     protected boolean tryRelease(int releases) {
       assert releases == 1; // Otherwise unused
       if (getState() == 0) throw new IllegalMonitorStateException();
       setExclusiveOwnerThread(null);
       setState(0);
       return true;
     }

    // Provide a Condition
    Condition newCondition() { return new ConditionObject(); }

    // Deserialize properly
    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
      s.defaultReadObject();
      setState(0); // reset to unlocked state
     }
   }

   // The sync object does all the hard work.We just forward to it.
   private final Sync sync = new Sync();

   public void lock()                { sync.acquire(1); }
   public boolean tryLock()          { return sync.tryAcquire(1); }
   public void unlock()              { sync.release(1); }
   public Condition newCondition()   { return sync.newCondition(); }
   public boolean isLocked()         { return sync.isHeldExclusively(); }
   public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
   public void lockInterruptibly() throws InterruptedException {
     sync.acquireInterruptibly(1);
   }
   public boolean tryLock(long timeout, TimeUnit unit)
       throws InterruptedException {
     return sync.tryAcquireNanos(1, unit.toNanos(timeout));
   }
 }
 </pre>

 <p>다음에, 기동에 단일의 <tt>signal</tt> 를 필요로 하는 것을 제외해,<A HREF="../../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent 안의 클래스"><CODE>CountDownLatch</CODE></A>  클래스에 유사한 빗장 클래스를 나타냅니다. 빗장은 비배타적이기 때문에,<tt>shared</tt> 취득 및 해제 메소드를 사용합니다.

 <pre>
 class BooleanLatch {

   private static class Sync extends AbstractQueuedSynchronizer {
     boolean isSignalled() { return getState() ! = 0; }

     protected int tryAcquireShared(int ignore) {
       return isSignalled()?  1 : -1;
     }

     protected boolean tryReleaseShared(int ignore) {
       setState(1);
       return true;
     }
   }

   private final Sync sync = new Sync();
   public boolean isSignalled() { return sync.isSignalled(); }
   public void signal()         { sync.releaseShared(1); }
   public void await() throws InterruptedException {
     sync.acquireSharedInterruptibly(1);
   }
 }
 </pre>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../../serialized-form.html#java.util.concurrent.locks.AbstractQueuedSynchronizer">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스"><CODE>Lock</CODE></A>  구현의 기반으로서 기능하는 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html" title="java.util.concurrent.locks 동안의 클래스"><CODE>AbstractQueuedSynchronizer</CODE></A>  의 Condition 구현입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#AbstractQueuedSynchronizer()">AbstractQueuedSynchronizer</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;제로의 초기 동기 상태를 사용해, 신규 <tt>AbstractQueuedSynchronizer</tt> 인스턴스를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#acquire(int)">acquire</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인터럽트를 무시해, 배타 모드로 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#acquireInterruptibly(int)">acquireInterruptibly</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드로 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#acquireShared(int)">acquireShared</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인터럽트를 무시해, 공유 모드로 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#acquireSharedInterruptibly(int)">acquireSharedInterruptibly</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드로 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#compareAndSetState(int, int)">compareAndSetState</A> </B>(int&nbsp;expect,
                   int&nbsp;update)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 상태치가 예상되는 값에 동일한 경우, 동기 상태가 지정된 갱신치에 원자적으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getExclusiveQueuedThreads()">getExclusiveQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드로 취득하기 위해서 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getFirstQueuedThread()">getFirstQueuedThread</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;큐내의 최초의 (대기 시간의 가장 길다) thread를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getQueuedThreads()">getQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;취득을 대기하고 있는 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getQueueLength()">getQueueLength</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;취득을 대기하고 있는 thread의 추정수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getSharedQueuedThreads()">getSharedQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드로 취득하기 위해서 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getState()">getState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;동기 상태의 현재가를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getWaitingThreads(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)">getWaitingThreads</A> </B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 싱크로나이저에 관련지을 수 있었던 지정 상태로 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)">getWaitQueueLength</A> </B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 싱크로나이저에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread의 추정수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#hasContended()">hasContended</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 싱크로나이저의 취득으로 경합 하고 있는 thread가 존재할지 어떨지 (즉, acquire 메소드가 블록 되었는지 어떠했는지)를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#hasQueuedThreads()">hasQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;취득을 대기중의 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#hasWaiters(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)">hasWaiters</A> </B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 싱크로나이저에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#isHeldExclusively()">isHeldExclusively</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 (호출측의) thread에 관해서, 동기가 배타적으로 행해지는 경우는 <code>true</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#isQueued(java.lang.Thread)">isQueued</A> </B>(<A HREF="../../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;thread)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 thread가, 현재 큐에 들어가 있는 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#owns(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)">owns</A> </B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 ConditionObject 가 이 싱크로나이저를 락으로서 사용할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#release(int)">release</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드로 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#releaseShared(int)">releaseShared</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드로 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#setState(int)">setState</A> </B>(int&nbsp;newState)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;동기 상태의 값을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;싱크로나이저 및 그 상태를 식별하는 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)">tryAcquire</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드에서의 취득을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireNanos(int, long)">tryAcquireNanos</A> </B>(int&nbsp;arg,
                long&nbsp;nanosTimeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드로 취득을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)">tryAcquireShared</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드에서의 취득을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireSharedNanos(int, long)">tryAcquireSharedNanos</A> </B>(int&nbsp;arg,
                      long&nbsp;nanosTimeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드로 취득을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryRelease(int)">tryRelease</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드에서의 해제을 반영하도록(듯이), 상태의 설정을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryReleaseShared(int)">tryReleaseShared</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드에서의 해제을 반영하도록(듯이), 상태의 설정을 시도합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.concurrent.locks.AbstractOwnableSynchronizer"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.util.concurrent.locks. <A HREF="../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.html" title="java.util.concurrent.locks 안의 클래스">AbstractOwnableSynchronizer</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.html#getExclusiveOwnerThread()">getExclusiveOwnerThread</A> , <A HREF="../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.html#setExclusiveOwnerThread(java.lang.Thread)">setExclusiveOwnerThread</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AbstractQueuedSynchronizer()"><!-- --></A> <H3>
AbstractQueuedSynchronizer</H3>
<PRE>
protected <B>AbstractQueuedSynchronizer</B>()</PRE>
<DL>
<DD>제로의 초기 동기 상태를 사용해, 신규 <tt>AbstractQueuedSynchronizer</tt> 인스턴스를 작성합니다.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getState()"><!-- --></A> <H3>
getState</H3>
<PRE>
protected final int <B>getState</B>()</PRE>
<DL>
<DD>동기 상태의 현재가를 돌려줍니다. 이 조작은,<tt>volatile</tt> 읽을 메모리 시멘틱스를 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재 상태치</DL>
</DD>
</DL>
<HR>

<A NAME="setState(int)"><!-- --></A> <H3>
setState</H3>
<PRE>
protected final void <B>setState</B>(int&nbsp;newState)</PRE>
<DL>
<DD>동기 상태의 값을 설정합니다. 이 조작은,<tt>volatile</tt> 기입의 메모리 시멘틱스를 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newState</CODE> - 신규 상태치</DL>
</DD>
</DL>
<HR>

<A NAME="compareAndSetState(int, int)"><!-- --></A> <H3>
compareAndSetState</H3>
<PRE>
protected final boolean <B>compareAndSetState</B>(int&nbsp;expect,
                                           int&nbsp;update)</PRE>
<DL>
<DD>현재 상태치가 예상되는 값에 동일한 경우, 동기 상태가 지정된 갱신치에 원자적으로 설정합니다. 이 조작은,<tt>volatile</tt> read 및 기입의 메모리 시멘틱스를 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>expect</CODE> - 예상되는 값<DD><CODE>update</CODE> - 새로운 값
<DT><B>반환값:</B><DD>성공하는 경우는 true. false 는, 실제의 값이 예상되는 값과 등가가 아닌 것을 나타낸다</DL>
</DD>
</DL>
<HR>

<A NAME="tryAcquire(int)"><!-- --></A> <H3>
tryAcquire</H3>
<PRE>
protected boolean <B>tryAcquire</B>(int&nbsp;arg)</PRE>
<DL>
<DD>배타 모드에서의 취득을 시도합니다. 이 메소드는, 객체가 배타 모드에서의 취득을 허가하는 상태에 있을지 어떨지를 조회해, 허가하는 상태에 있으면 가져옵니다.

 <p>이 메소드는 항상 취득을 실행하는 thread에 의해 불려 갑니다. 이 메소드가 실패를 리포트해, 한편 thread가 큐에 넣어지지 않은 경우, 취득 메소드는, 다른 thread로부터의 해제에 의해 신호가 송신될 때까지 그 thread를 큐에 넣을 수가 있습니다. 이것은,<A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock()"><CODE>Lock.tryLock()</CODE></A>  메소드의 구현에 사용할 수 있습니다.

 <p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A>  를 throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은, 항상 acquire 메소드에게 건네지는 값, 또는 상태 대기에의 엔트리로 보존되는 값이 된다.
그 이외의 경우, 이 값은 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD>성공하는 경우는 <code>true</code>. 성공시에는, 이 객체는 취득이 끝난 상태이다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 취득에 의해, 이 싱크로나이저가 부정한 상태에 놓여지는 경우.
동기가 올바르게 기능하기 위해서는, 이 예외를 일관한 방식에서 throw 할 필요가 있다
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 배타 모드가 지원되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryRelease(int)"><!-- --></A> <H3>
tryRelease</H3>
<PRE>
protected boolean <B>tryRelease</B>(int&nbsp;arg)</PRE>
<DL>
<DD>배타 모드에서의 해제을 반영하도록(듯이), 상태의 설정을 시도합니다.

 <p>이 메소드는, 해제을 실행하는 thread에 의해 항상 불려 갑니다.

 <p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A>  를 throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - release 의 인수. 이 값은, 항상 release 메소드에게 건네지는 값, 또는 상태 대기에의 엔트리에서의 현재 상태치가 된다.
그 이외의 경우, 이 값은 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD>대기중의 임의의 thread가 취득을 시도할 수가 있도록(듯이), 이 객체가 완전하게 해제된 상태에 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 해제에 의해, 이 싱크로나이저가 부정한 상태에 놓여지는 경우.
동기가 올바르게 기능하기 위해서는, 이 예외를 일관한 방식에서 throw 할 필요가 있다
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 배타 모드가 지원되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryAcquireShared(int)"><!-- --></A> <H3>
tryAcquireShared</H3>
<PRE>
protected int <B>tryAcquireShared</B>(int&nbsp;arg)</PRE>
<DL>
<DD>공유 모드에서의 취득을 시도합니다. 이 메소드는, 객체가 공유 모드에서의 취득을 허가하는 상태에 있을지 어떨지를 조회해, 허가하는 상태에 있으면 가져옵니다.

 <p>이 메소드는 항상 취득을 실행하는 thread에 의해 불려 갑니다. 이 메소드가 실패를 리포트해, 한편 thread가 큐에 넣어지지 않은 경우, 취득 메소드는, 다른 thread로부터의 해제에 의해 신호가 송신될 때까지 그 thread를 큐에 넣을 수가 있습니다.

 <p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A>  를 throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은, 항상 acquire 메소드에게 건네지는 값, 또는 상태 대기에의 엔트리로 보존되는 값이 된다.
그 이외의 경우, 이 값은 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD>실패했을 경우는 0 보다 작은 값. 공유 모드에서의 취득에 성공했지만, 이후의 공유 모드에서의 취득에 성공하지 않는 경우는 제로. 공유 모드에서의 취득에 성공해, 이후의 공유 모드에서의 취득에도 성공할 가능성이 있는 경우는 정의 값. 정의 값의 경우, 이후의 대기 thread로 이용 가능성을 체크할 필요가 있다 
(3 개(살)이 다른 반환값의 지원에 의해, 취득만이 때때로 배타적으로 동작하는 문맥내에서 이 메소드를 사용하는 것이 가능하게 된다). 성공시에는, 이 객체는 취득이 끝난 상태이다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 취득에 의해, 이 싱크로나이저가 부정한 상태에 놓여지는 경우.
동기가 올바르게 기능하기 위해서는, 이 예외를 일관한 방식에서 throw 할 필요가 있다
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 공유 모드가 지원되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryReleaseShared(int)"><!-- --></A> <H3>
tryReleaseShared</H3>
<PRE>
protected boolean <B>tryReleaseShared</B>(int&nbsp;arg)</PRE>
<DL>
<DD>공유 모드에서의 해제을 반영하도록(듯이), 상태의 설정을 시도합니다.

 <p>이 메소드는, 해제을 실행하는 thread에 의해 항상 불려 갑니다.

 <p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A>  를 throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - release 의 인수. 이 값은, 항상 release 메소드에게 건네지는 값, 또는 상태 대기에의 엔트리에서의 현재 상태치가 된다.
그 이외의 경우, 이 값은 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD>이 릴리스의 공유 모드로 대기중의 취득 (공유 또는 배타)을 허가할 수 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 해제에 의해, 이 싱크로나이저가 부정한 상태에 놓여지는 경우.
동기가 올바르게 기능하기 위해서는, 이 예외를 일관한 방식에서 throw 할 필요가 있다
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 공유 모드가 지원되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="isHeldExclusively()"><!-- --></A> <H3>
isHeldExclusively</H3>
<PRE>
protected boolean <B>isHeldExclusively</B>()</PRE>
<DL>
<DD>현재의 (호출측의) thread에 관해서, 동기가 배타적으로 행해지는 경우는 <code>true</code> 를 돌려줍니다. 비대기 상태 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 중의 클래스"><CODE>AbstractQueuedSynchronizer.ConditionObject</CODE></A>  메소드가 불려 갈 때 마다, 이 메소드가 불려 갑니다 (대기 상태의 메소드에서는 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#release(int)"><CODE>release(int)</CODE></A>  가 불려 간다).

 <p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A>  를 throw 합니다. 이 메소드는,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스"><CODE>AbstractQueuedSynchronizer.ConditionObject</CODE></A>  메소드로 내부적에게만 불려 가기 (위해)때문에, 상태가 사용되지 않는 경우는 정의할 필요가 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>동기가 배타적으로 행해지는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 상태가 지원되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="acquire(int)"><!-- --></A> <H3>
acquire</H3>
<PRE>
public final void <B>acquire</B>(int&nbsp;arg)</PRE>
<DL>
<DD>인터럽트를 무시해, 배타 모드로 가져옵니다. 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A>  를 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 이외의 경우, thread는 큐에 넣어져 대부분의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A>  를 호출합니다. 이 메소드는,<A HREF="../../../../java/util/concurrent/locks/Lock.html#lock()"><CODE>Lock.lock()</CODE></A>  메소드의 구현에 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다</DL>
</DD>
</DL>
<HR>

<A NAME="acquireInterruptibly(int)"><!-- --></A> <H3>
acquireInterruptibly</H3>
<PRE>
public final void <B>acquireInterruptibly</B>(int&nbsp;arg)
                                throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>배타 모드로 가져옵니다. 인터럽트가 발생했을 경우는, 중지합니다. 최초로 끼어들어 상태를 체크하고 나서 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A>  를 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 이외의 경우, thread는 큐에 넣어져 대부분의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할까 thread로 인터럽트가 발생할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A>  를 호출합니다. 이 메소드는,<A HREF="../../../../java/util/concurrent/locks/Lock.html#lockInterruptibly()"><CODE>Lock.lockInterruptibly()</CODE></A>  메소드의 구현에 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryAcquireNanos(int, long)"><!-- --></A> <H3>
tryAcquireNanos</H3>
<PRE>
public final boolean <B>tryAcquireNanos</B>(int&nbsp;arg,
                                     long&nbsp;nanosTimeout)
                              throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>배타 모드로 취득을 시도합니다. 인터럽트가 발생했을 경우는 중지해, 지정된 타임 아웃 시간이 경과했을 경우는 실패합니다. 최초로 끼어들어 상태를 체크하고 나서 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A>  를 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 이외의 경우, thread는 큐에 넣어져 대부분의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할까 thread로 인터럽트가 발생하는지, 타임 아웃 시간이 경과할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A>  를 호출합니다. 이 메소드는,<A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock(long, java.util.concurrent.TimeUnit)"><CODE>Lock.tryLock(long, TimeUnit)</CODE></A>  메소드의 구현에 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있는<DD><CODE>nanosTimeout</CODE> - 대기하는 최대 나노초수
<DT><B>반환값:</B><DD>취득했을 경우는 <code>true</code>, 타임 아웃 했을 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="release(int)"><!-- --></A> <H3>
release</H3>
<PRE>
public final boolean <B>release</B>(int&nbsp;arg)</PRE>
<DL>
<DD>배타 모드로 해제합니다. <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryRelease(int)"><CODE>tryRelease(int)</CODE></A>  가 true 를 돌려주는 경우, 1 개(살) 이상의 thread를 블록 해제하는 것으로 구현됩니다. 이 메소드는,<A HREF="../../../../java/util/concurrent/locks/Lock.html#unlock()"><CODE>Lock.unlock()</CODE></A>  메소드의 구현으로 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - release 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryRelease(int)"><CODE>tryRelease(int)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryRelease(int)"><CODE>tryRelease(int)</CODE></A>  로부터 반환되는 값</DL>
</DD>
</DL>
<HR>

<A NAME="acquireShared(int)"><!-- --></A> <H3>
acquireShared</H3>
<PRE>
public final void <B>acquireShared</B>(int&nbsp;arg)</PRE>
<DL>
<DD>인터럽트를 무시해, 공유 모드로 가져옵니다. 최초로 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A>  를 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 이외의 경우, thread는 큐에 넣어져 대부분의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A>  를 호출합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다</DL>
</DD>
</DL>
<HR>

<A NAME="acquireSharedInterruptibly(int)"><!-- --></A> <H3>
acquireSharedInterruptibly</H3>
<PRE>
public final void <B>acquireSharedInterruptibly</B>(int&nbsp;arg)
                                      throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>공유 모드로 가져옵니다. 최초로 끼어들어 상태를 체크하고 나서, 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A>  를 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 이외의 경우, thread는 큐에 넣어져 대부분의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할까 thread로 인터럽트가 발생할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A>  를 호출합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수.
이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryAcquireSharedNanos(int, long)"><!-- --></A> <H3>
tryAcquireSharedNanos</H3>
<PRE>
public final boolean <B>tryAcquireSharedNanos</B>(int&nbsp;arg,
                                           long&nbsp;nanosTimeout)
                                    throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>공유 모드로 취득을 시도합니다. 인터럽트가 발생했을 경우는 중지해, 지정된 타임 아웃 시간이 경과했을 경우는 실패합니다. 최초로 끼어들어 상태를 체크하고 나서, 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A>  를 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 이외의 경우, thread는 큐에 넣어져 대부분의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공하는지, thread로 인터럽트가 발생하는지, 타임 아웃 시간이 경과할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A>  를 호출합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있는<DD><CODE>nanosTimeout</CODE> - 대기하는 최대 나노초수
<DT><B>반환값:</B><DD>취득했을 경우는 <code>true</code>, 타임 아웃 했을 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="releaseShared(int)"><!-- --></A> <H3>
releaseShared</H3>
<PRE>
public final boolean <B>releaseShared</B>(int&nbsp;arg)</PRE>
<DL>
<DD>공유 모드로 해제합니다. <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryReleaseShared(int)"><CODE>tryReleaseShared(int)</CODE></A>  가 true 를 돌려주는 경우, 1 개(살) 이상의 thread를 블록 해제하는 것으로 구현됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - release 의 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryReleaseShared(int)"><CODE>tryReleaseShared(int)</CODE></A>  에 송신되지만, 그 이외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryReleaseShared(int)"><CODE>tryReleaseShared(int)</CODE></A>  로부터 반환되는 값</DL>
</DD>
</DL>
<HR>

<A NAME="hasQueuedThreads()"><!-- --></A> <H3>
hasQueuedThreads</H3>
<PRE>
public final boolean <B>hasQueuedThreads</B>()</PRE>
<DL>
<DD>취득을 대기중의 thread가 존재할지 어떨지를 조회합니다. 언젠가는 끼어들어 및 타임 아웃에 의한 취소가 발생했을 경우,<code>true</code> 가 돌려주어져도 다른 thread가 취득을 실행하는 것은 보증되지 않습니다.

 <p>이 구현에서는, 이 조작은 일정한 시간에 복귀합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>취득을 대기중외의 thread가 존재할 가능성이 있는 경우는 <code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="hasContended()"><!-- --></A> <H3>
hasContended</H3>
<PRE>
public final boolean <B>hasContended</B>()</PRE>
<DL>
<DD>이 싱크로나이저의 취득으로 경합 하고 있는 thread가 존재할지 어떨지 (즉, acquire 메소드가 블록 되었는지 어떠했는지)를 조회합니다.

 <p>이 구현에서는, 이 조작은 일정한 시간에 복귀합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>경합이 존재하는 경우는 <code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="getFirstQueuedThread()"><!-- --></A> <H3>
getFirstQueuedThread</H3>
<PRE>
public final <A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A>  <B>getFirstQueuedThread</B>()</PRE>
<DL>
<DD>큐내의 최초의 (대기 시간의 가장 길다) thread를 돌려줍니다. 현재 큐에 thread가 들어가 있지 않은 경우는 <code>null</code> 를 돌려줍니다.

 <p>일반적으로, 이 구현에서는, 이 조작은 일정시간으로 복귀합니다. 다만, 다른 thread가 큐의 변경을 병행해 실행하고 있는 경우는, 경합에 의해 처리를 반복하는 경우가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>큐내의 최초의 (대기 시간의 가장 길다) thread. 현재 큐에 thread가 들어가 있지 않은 경우는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="isQueued(java.lang.Thread)"><!-- --></A> <H3>
isQueued</H3>
<PRE>
public final boolean <B>isQueued</B>(<A HREF="../../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;thread)</PRE>
<DL>
<DD>지정된 thread가, 현재 큐에 들어가 있는 경우는 true 를 돌려줍니다.

 <p>이 구현은, 큐를 횡단(traverse) 해 지정된 thread의 존재를 판별합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>thread</CODE> - thread
<DT><B>반환값:</B><DD>지정된 thread가 큐에 들어가 있는 경우는 <code>true</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - thread가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getQueueLength()"><!-- --></A> <H3>
getQueueLength</H3>
<PRE>
public final int <B>getQueueLength</B>()</PRE>
<DL>
<DD>취득을 대기하고 있는 thread의 추정수를 돌려줍니다. 이 메소드가 내부의 데이터 구조를 횡단(traverse) 하고 있는 동안에도, thread수가 동적으로 변화하는 경우가 있기 (위해)때문에, 이 값은 추정에 지나지 않습니다. 이 메소드는, 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>취득을 대기하고 있는 thread의 추정수</DL>
</DD>
</DL>
<HR>

<A NAME="getQueuedThreads()"><!-- --></A> <H3>
getQueuedThreads</H3>
<PRE>
public final <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getQueuedThreads</B>()</PRE>
<DL>
<DD>취득을 대기하고 있는 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는, 결과의 구축중에도 동적으로 변화할 가능성이 있기 (위해)때문에, 반환되는 컬렉션은 최선이 노력한 다음의 추정에 지나지 않습니다. 반환되는 컬렉션의 요소에는, 특정의 순서는 존재하지 않습니다. 이 메소드는, 보다 포괄적인 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="getExclusiveQueuedThreads()"><!-- --></A> <H3>
getExclusiveQueuedThreads</H3>
<PRE>
public final <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getExclusiveQueuedThreads</B>()</PRE>
<DL>
<DD>배타 모드로 취득하기 위해서 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 이것은, 배타적 취득을 위해서(때문에) 대기중의 thread만을 돌려주는 것을 제외해서는,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getQueuedThreads()"><CODE>getQueuedThreads()</CODE></A>  와 같은 프로퍼티을 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="getSharedQueuedThreads()"><!-- --></A> <H3>
getSharedQueuedThreads</H3>
<PRE>
public final <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getSharedQueuedThreads</B>()</PRE>
<DL>
<DD>공유 모드로 취득하기 위해서 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 이것은, 공유적 취득을 위해서(때문에) 대기중의 thread만을 돌려주는 것을 제외해,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getQueuedThreads()"><CODE>getQueuedThreads()</CODE></A>  와 같은 프로퍼티을 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>싱크로나이저 및 그 상태를 식별하는 캐릭터 라인을 돌려줍니다. 상태는 괄호로 둘러싸여 캐릭터 라인 <code>"State ="</code> 에 이어 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getState()"><CODE>getState()</CODE></A>  의 현재가, 및 큐가 빈 상태(empty)인가 어떤가에 응해 <code>"nonempty"</code> 또는 <code>"empty"</code> 가 포함됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 싱크로나이저 및 그 상태를 식별하는 캐릭터 라인</DL>
</DD>
</DL>
<HR>

<A NAME="owns(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)"><!-- --></A> <H3>
owns</H3>
<PRE>
public final boolean <B>owns</B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</PRE>
<DL>
<DD>지정된 ConditionObject 가 이 싱크로나이저를 락으로서 사용할지 어떨지를 조회합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>소유되는 경우는 <tt>true</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="hasWaiters(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)"><!-- --></A> <H3>
hasWaiters</H3>
<PRE>
public final boolean <B>hasWaiters</B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</PRE>
<DL>
<DD>이 싱크로나이저에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread가 존재할지 어떨지를 조회합니다. 타임 아웃 및 인터럽트는 언제라도 발생할 가능성이 있기 (위해)때문에,<tt>true</tt> 가 돌려주어져도, 장래 <tt>signal</tt> 가 thread를 기동시키는 것은 보증되고 있지 않습니다. 이 메소드는, 주로 시스템 상태의 감시에 사용하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>대기중의 thread가 존재하는 경우는 <tt>true</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 배타적 동기가 보관 유지되지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 싱크로나이저와 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)"><!-- --></A> <H3>
getWaitQueueLength</H3>
<PRE>
public final int <B>getWaitQueueLength</B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</PRE>
<DL>
<DD>이 싱크로나이저에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread의 추정수를 돌려줍니다. 타임 아웃 및 인터럽트의 발생할 가능성은 언제라도 존재하기 위해(때문에), 추정수는, 실제의 대기자수에 관한 상한을 나타내는에 지나지 않습니다. 이 메소드는, 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>대기중의 thread의 추정수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 배타적 동기가 보관 유지되지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 싱크로나이저와 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitingThreads(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)"><!-- --></A> <H3>
getWaitingThreads</H3>
<PRE>
public final <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getWaitingThreads</B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</PRE>
<DL>
<DD>이 싱크로나이저에 관련지을 수 있었던 지정 상태로 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는, 결과의 구축중에도 동적으로 변화할 가능성이 있기 (위해)때문에, 반환되는 컬렉션은 최선이 노력한 다음의 추정에 지나지 않습니다. 반환되는 컬렉션의 요소에는, 특정의 순서는 존재하지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>thread의 컬렉션
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 배타적 동기가 보관 유지되지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 싱크로나이저와 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractQueuedSynchronizer.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedLongSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/locks/AbstractQueuedSynchronizer.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="AbstractQueuedSynchronizer.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
