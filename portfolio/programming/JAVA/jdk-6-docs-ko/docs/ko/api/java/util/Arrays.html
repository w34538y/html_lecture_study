<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:59:25 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Arrays (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Arrays (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Arrays.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/util/ArrayList.html" title="java.util 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/util/BitSet.html" title="java.util 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/util/Arrays.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Arrays.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util</FONT>
<BR>
클래스 Arrays</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.Arrays</B>
</PRE>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>Arrays</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
이 클래스에는, 소트나 검색 등, 배열을 조작하기 위한 다양한 메소드가 있습니다. 또, 배열을 리스트로서 표시하기 위한 static 팩토리도 있습니다.

 <p>지정된 배열 참조가 null 의 경우, 그 이외의 처리가 명시되고 있는 경우를 제외해, 이 클래스의 메소드는 모두 <tt>NullPointerException</tt> 를 throw 합니다.

 <p>이 클래스에 있는 검색 메소드의 문서에는, 「구현」의 간단한 설명이 포함되어 있습니다. 이 설명은, 「스펙」의 일부에서는 없고 「구현 정보」라고 생각해 주세요. 구현자는, 스펙에 반하지 않는 한, 다른 알고리즘을 자유롭게 사용할 수 있습니다. 예를 들어,<tt>sort(Object[])</tt> 가 사용하는 알고리즘은 머지 소트일 필요는 없습니다만, 「고정 (stable)」의 알고리즘이 아니면 안됩니다.

 <p>이 클래스는,<a href="../../../technotes/guides/collections/index.html">Java Collections Framework</a>  의 멤버입니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#asList(T...)">asList</A> </B>(T...&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열에 연동하는 고정 사이즈의 리스트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(byte[], byte)">binarySearch</A> </B>(byte[]&nbsp;a,
             byte&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 byte 치의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(byte[], int, int, byte)">binarySearch</A> </B>(byte[]&nbsp;a,
             int&nbsp;fromIndex,
             int&nbsp;toIndex,
             byte&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 byte 치의 배열로부터 지정된 값의 범위를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(char[], char)">binarySearch</A> </B>(char[]&nbsp;a,
             char&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 char 값의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(char[], int, int, char)">binarySearch</A> </B>(char[]&nbsp;a,
             int&nbsp;fromIndex,
             int&nbsp;toIndex,
             char&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 char 값의 배열로부터 지정된 값의 범위를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(double[], double)">binarySearch</A> </B>(double[]&nbsp;a,
             double&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 double 치의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(double[], int, int, double)">binarySearch</A> </B>(double[]&nbsp;a,
             int&nbsp;fromIndex,
             int&nbsp;toIndex,
             double&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 double 치의 배열로부터 지정된 값의 범위를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(float[], float)">binarySearch</A> </B>(float[]&nbsp;a,
             float&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 float 치의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(float[], int, int, float)">binarySearch</A> </B>(float[]&nbsp;a,
             int&nbsp;fromIndex,
             int&nbsp;toIndex,
             float&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 float 치의 배열로부터 지정된 값의 범위를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(int[], int)">binarySearch</A> </B>(int[]&nbsp;a,
             int&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 int 치의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(int[], int, int, int)">binarySearch</A> </B>(int[]&nbsp;a,
             int&nbsp;fromIndex,
             int&nbsp;toIndex,
             int&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 int 치의 배열로부터 지정된 값의 범위를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(long[], int, int, long)">binarySearch</A> </B>(long[]&nbsp;a,
             int&nbsp;fromIndex,
             int&nbsp;toIndex,
             long&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 long 치의 배열로부터 지정된 값의 범위를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(long[], long)">binarySearch</A> </B>(long[]&nbsp;a,
             long&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 long 치의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(java.lang.Object[], int, int, java.lang.Object)">binarySearch</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
             int&nbsp;fromIndex,
             int&nbsp;toIndex,
             <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 배열의 범위로부터 지정된 객체를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(java.lang.Object[], java.lang.Object)">binarySearch</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
             <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 배열로부터 지정된 객체를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(short[], int, int, short)">binarySearch</A> </B>(short[]&nbsp;a,
             int&nbsp;fromIndex,
             int&nbsp;toIndex,
             short&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 short 치의 배열로부터 지정된 값의 범위를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(short[], short)">binarySearch</A> </B>(short[]&nbsp;a,
             short&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 short 치의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(T[], int, int, T, java.util.Comparator)">binarySearch</A> </B>(T[]&nbsp;a,
             int&nbsp;fromIndex,
             int&nbsp;toIndex,
             T&nbsp;key,
             <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 배열의 범위로부터 지정된 객체를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(T[], T, java.util.Comparator)">binarySearch</A> </B>(T[]&nbsp;a,
             T&nbsp;key,
             <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 배열로부터 지정된 객체를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOf(boolean[], int)">copyOf</A> </B>(boolean[]&nbsp;original,
       int&nbsp;newLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 <tt>false</tt> 로 패딩 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOf(byte[], int)">copyOf</A> </B>(byte[]&nbsp;original,
       int&nbsp;newLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 제로로 패딩 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOf(char[], int)">copyOf</A> </B>(char[]&nbsp;original,
       int&nbsp;newLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 null 문자로 패딩 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOf(double[], int)">copyOf</A> </B>(double[]&nbsp;original,
       int&nbsp;newLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 제로로 패딩 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOf(float[], int)">copyOf</A> </B>(float[]&nbsp;original,
       int&nbsp;newLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 제로로 패딩 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOf(int[], int)">copyOf</A> </B>(int[]&nbsp;original,
       int&nbsp;newLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 제로로 패딩 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOf(long[], int)">copyOf</A> </B>(long[]&nbsp;original,
       int&nbsp;newLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 제로로 패딩 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;short[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOf(short[], int)">copyOf</A> </B>(short[]&nbsp;original,
       int&nbsp;newLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 제로로 패딩 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T[]</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOf(T[], int)">copyOf</A> </B>(T[]&nbsp;original,
       int&nbsp;newLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 null 로 패딩 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T, U&gt; T[]</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOf(U[], int, java.lang.Class)">copyOf</A> </B>(U[]&nbsp;original,
       int&nbsp;newLength,
       <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;?  extends T[]&gt;&nbsp;newType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 null 로 패딩 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOfRange(boolean[], int, int)">copyOfRange</A> </B>(boolean[]&nbsp;original,
            int&nbsp;from,
            int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOfRange(byte[], int, int)">copyOfRange</A> </B>(byte[]&nbsp;original,
            int&nbsp;from,
            int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOfRange(char[], int, int)">copyOfRange</A> </B>(char[]&nbsp;original,
            int&nbsp;from,
            int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOfRange(double[], int, int)">copyOfRange</A> </B>(double[]&nbsp;original,
            int&nbsp;from,
            int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOfRange(float[], int, int)">copyOfRange</A> </B>(float[]&nbsp;original,
            int&nbsp;from,
            int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOfRange(int[], int, int)">copyOfRange</A> </B>(int[]&nbsp;original,
            int&nbsp;from,
            int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOfRange(long[], int, int)">copyOfRange</A> </B>(long[]&nbsp;original,
            int&nbsp;from,
            int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;short[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOfRange(short[], int, int)">copyOfRange</A> </B>(short[]&nbsp;original,
            int&nbsp;from,
            int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T[]</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOfRange(T[], int, int)">copyOfRange</A> </B>(T[]&nbsp;original,
            int&nbsp;from,
            int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T, U&gt; T[]</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#copyOfRange(U[], int, int, java.lang.Class)">copyOfRange</A> </B>(U[]&nbsp;original,
            int&nbsp;from,
            int&nbsp;to,
            <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;?  extends T[]&gt;&nbsp;newType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#deepEquals(java.lang.Object[], java.lang.Object[])">deepEquals</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a1,
           <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 개의 지정된 배열이 서로 「심층에서 등가」인 경우,<tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#deepHashCode(java.lang.Object[])">deepHashCode</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 「심층 내용」에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#deepToString(java.lang.Object[])">deepToString</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 「심층 내용」의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(boolean[], boolean[])">equals</A> </B>(boolean[]&nbsp;a,
       boolean[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 boolean 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(byte[], byte[])">equals</A> </B>(byte[]&nbsp;a,
       byte[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 byte 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(char[], char[])">equals</A> </B>(char[]&nbsp;a,
       char[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 char 값의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(double[], double[])">equals</A> </B>(double[]&nbsp;a,
       double[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 double 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(float[], float[])">equals</A> </B>(float[]&nbsp;a,
       float[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 float 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(int[], int[])">equals</A> </B>(int[]&nbsp;a,
       int[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 int 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(long[], long[])">equals</A> </B>(long[]&nbsp;a,
       long[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 long 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(java.lang.Object[], java.lang.Object[])">equals</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
       <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 Object 의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(short[], short[])">equals</A> </B>(short[]&nbsp;a,
       short[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 short 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(boolean[], boolean)">fill</A> </B>(boolean[]&nbsp;a,
     boolean&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 boolean 치의 배열의 각 요소에, 지정된 boolean 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(boolean[], int, int, boolean)">fill</A> </B>(boolean[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     boolean&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 boolean 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(byte[], byte)">fill</A> </B>(byte[]&nbsp;a,
     byte&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 byte 치의 배열의 각 요소에, 지정된 byte 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(byte[], int, int, byte)">fill</A> </B>(byte[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     byte&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 byte 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(char[], char)">fill</A> </B>(char[]&nbsp;a,
     char&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 char 값의 배열의 각 요소에, 지정된 char 값를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(char[], int, int, char)">fill</A> </B>(char[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     char&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char 값로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 char 값를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(double[], double)">fill</A> </B>(double[]&nbsp;a,
     double&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 double 치의 배열의 각 요소에, 지정된 double 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(double[], int, int, double)">fill</A> </B>(double[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     double&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 double 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(float[], float)">fill</A> </B>(float[]&nbsp;a,
     float&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 float 치의 배열의 각 요소에, 지정된 float 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(float[], int, int, float)">fill</A> </B>(float[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     float&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 float 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(int[], int)">fill</A> </B>(int[]&nbsp;a,
     int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 int 치의 배열의 각 요소에, 지정된 int 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(int[], int, int, int)">fill</A> </B>(int[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 int 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(long[], int, int, long)">fill</A> </B>(long[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     long&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 long 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(long[], long)">fill</A> </B>(long[]&nbsp;a,
     long&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 long 치의 배열의 각 요소에, 지정된 long 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(java.lang.Object[], int, int, java.lang.Object)">fill</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Object 의 배열로, 지정된 범위에 있는 각 요소에, 지정된 Object 참조를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(java.lang.Object[], java.lang.Object)">fill</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
     <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Object 의 배열의 각 요소에, 지정된 Object 참조를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(short[], int, int, short)">fill</A> </B>(short[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     short&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 short 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(short[], short)">fill</A> </B>(short[]&nbsp;a,
     short&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 short 치의 배열의 각 요소에, 지정된 short 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(boolean[])">hashCode</A> </B>(boolean[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(byte[])">hashCode</A> </B>(byte[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(char[])">hashCode</A> </B>(char[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(double[])">hashCode</A> </B>(double[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(float[])">hashCode</A> </B>(float[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(int[])">hashCode</A> </B>(int[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(long[])">hashCode</A> </B>(long[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(java.lang.Object[])">hashCode</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(short[])">hashCode</A> </B>(short[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(byte[])">sort</A> </B>(byte[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 byte 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(byte[], int, int)">sort</A> </B>(byte[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 byte 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(char[])">sort</A> </B>(char[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 char 값의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(char[], int, int)">sort</A> </B>(char[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 char 값의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(double[])">sort</A> </B>(double[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 double 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(double[], int, int)">sort</A> </B>(double[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 double 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(float[])">sort</A> </B>(float[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 float 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(float[], int, int)">sort</A> </B>(float[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 float 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(int[])">sort</A> </B>(int[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 int 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(int[], int, int)">sort</A> </B>(int[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 int 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(long[])">sort</A> </B>(long[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 long 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(long[], int, int)">sort</A> </B>(long[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 long 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(java.lang.Object[])">sort</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요소<A HREF="../../java/lang/Comparable.html" title="java.lang 중의 인터페이스">자연 순서부</a>에 따라, 지정된 객체의 배열을 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(java.lang.Object[], int, int)">sort</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요소<A HREF="../../java/lang/Comparable.html" title="java.lang 중의 인터페이스">자연 순서부</a>에 따라, 지정된 객체의 배열의 지정된 범위를 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(short[])">sort</A> </B>(short[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 short 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(short[], int, int)">sort</A> </B>(short[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 short 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(T[], java.util.Comparator)">sort</A> </B>(T[]&nbsp;a,
     <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Comparator가 가리키는 순서에 따라, 지정된 객체의 배열을 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(T[], int, int, java.util.Comparator)">sort</A> </B>(T[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Comparator의 차례에 따라서, 지정된 객체의 배열의 지정 범위를 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(boolean[])">toString</A> </B>(boolean[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(byte[])">toString</A> </B>(byte[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(char[])">toString</A> </B>(char[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(double[])">toString</A> </B>(double[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(float[])">toString</A> </B>(float[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(int[])">toString</A> </B>(int[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(long[])">toString</A> </B>(long[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(java.lang.Object[])">toString</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(short[])">toString</A> </B>(short[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="sort(long[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(long[]&nbsp;a)</PRE>
<DL>
<DD>지정된 long 치의 배열을 수치의 승순으로 소트 합니다. 소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(long[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(long[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 long 치의 배열을 수치의 승순으로 소트 합니다. 소트 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 인덱스 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 소트 범위는 비운다).

 <p>소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(int[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(int[]&nbsp;a)</PRE>
<DL>
<DD>지정된 int 치의 배열을 수치의 승순으로 소트 합니다. 소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(int[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(int[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 int 치의 배열을 수치의 승순으로 소트 합니다. 소트 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 인덱스 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 소트 범위는 비운다). <p>

소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(short[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(short[]&nbsp;a)</PRE>
<DL>
<DD>지정된 short 치의 배열을 수치의 승순으로 소트 합니다. 소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(short[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(short[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 short 치의 배열을 수치의 승순으로 소트 합니다. 소트 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 인덱스 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 소트 범위는 비운다). <p>

소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(char[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(char[]&nbsp;a)</PRE>
<DL>
<DD>지정된 char 값의 배열을 수치의 승순으로 소트 합니다. 소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(char[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(char[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 char 값의 배열을 수치의 승순으로 소트 합니다. 소트 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 인덱스 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 소트 범위는 비운다). <p>

소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(byte[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(byte[]&nbsp;a)</PRE>
<DL>
<DD>지정된 byte 치의 배열을 수치의 승순으로 소트 합니다. 소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(byte[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(byte[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 byte 치의 배열을 수치의 승순으로 소트 합니다. 소트 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 인덱스 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 소트 범위는 비운다). <p>

소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(double[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(double[]&nbsp;a)</PRE>
<DL>
<DD>지정된 double 치의 배열을 수치의 승순으로 소트 합니다.  &nbsp;<p>
<code>&lt;</code> 의 릴레이션은, 모든 부동 소수점치에 관한 전체 순서부를 제공하지 않습니다. 이 부동 소수점치는 절대치가 다른 수치입니다만,<code>-0. 0 == 0.0</code> 은 <code>true</code> 이며, NaN 치는 모든 부동 소수점치나 그 자체와 비교해도, 그것 이하에서도 이상에서도 등치이기도 하지 않습니다. 소트를 진행시키기 위해서(때문에), 이 메소드는 수치의 승순을 확정하는 <code>&lt;</code> 릴레이션을 사용하는 대신에,<A HREF="../../java/lang/Double.html#compareTo(java.lang.Double)"><CODE>Double.compareTo(java.lang.Double)</CODE></A>  가 실시하는 전체 순서부를 사용합니다. <code>-0. 0</code> 이 <code>0.0</code> 미만으로서 다루어져 NaN 가 다른 부동 소수점치보다 크다고 보이는 점으로써, 이 순서부는,<code>&lt;</code> 릴레이션과는 다릅니다. 소트를 실시하기 위해서(때문에), 모든 NaN 치는 등가로 간주해집니다.  &nbsp;<p>
소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(double[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(double[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 double 치의 배열을 수치의 승순으로 소트 합니다. 소트 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 인덱스 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 소트 범위는 비운다).  &nbsp;<p>
<code>&lt;</code> 의 릴레이션은, 모든 부동 소수점치에 관한 전체 순서부를 제공하지 않습니다. 이 부동 소수점치는 절대치가 다른 수치입니다만,<code>-0. 0 == 0.0</code> 은 <code>true</code> 이며, NaN 치는 모든 부동 소수점치나 그 자체와 비교해도, 그것 이하에서도 이상에서도 등치이기도 하지 않습니다. 소트를 진행시키기 위해서(때문에), 이 메소드는 수치의 승순을 확정하는 <code>&lt;</code> 릴레이션을 사용하는 대신에,<A HREF="../../java/lang/Double.html#compareTo(java.lang.Double)"><CODE>Double.compareTo(java.lang.Double)</CODE></A>  가 실시하는 전체 순서부를 사용합니다. <code>-0. 0</code> 이 <code>0.0</code> 미만으로서 다루어져 NaN 가 다른 부동 소수점치보다 크다고 보이는 점으로써, 이 순서부는,<code>&lt;</code> 릴레이션과는 다릅니다. 소트를 실시하기 위해서(때문에), 모든 NaN 치는 등가로 간주해집니다.  &nbsp;<p>
소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(float[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(float[]&nbsp;a)</PRE>
<DL>
<DD>지정된 float 치의 배열을 수치의 승순으로 소트 합니다.  &nbsp;<p>
<code>&lt;</code> 의 릴레이션은, 모든 부동 소수점치에 관한 전체 순서부를 제공하지 않습니다. 이 부동 소수점치는 절대치가 다른 수치입니다만,<code>-0. 0f == 0.0f</code> 는 <code>true</code> 이며, NaN 치는 모든 부동 소수점치나 그 자체와 비교해도, 그것 이하에서도 이상에서도 등치이기도 하지 않습니다. 소트를 진행시키기 위해서(때문에), 이 메소드는 수치의 승순을 확정하는 <code>&lt;</code> 릴레이션을 사용하는 대신에,<A HREF="../../java/lang/Float.html#compareTo(java.lang.Float)"><CODE>Float.compareTo(java.lang.Float)</CODE></A>  가 실시하는 전체 순서부를 사용합니다. <code>-0. 0f</code> 가 <code>0.0f</code> 미만으로서 다루어져 NaN 가 다른 부동 소수점치보다 크다고 보이는 점으로써, 이 순서부는,<code>&lt;</code> 릴레이션과는 다릅니다. 소트를 실시하기 위해서(때문에), 모든 NaN 치는 등가로 간주해집니다.  &nbsp;<p>
소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(float[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(float[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 float 치의 배열을 수치의 승순으로 소트 합니다. 소트 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 인덱스 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 소트 범위는 비운다).  &nbsp;<p>
<code>&lt;</code> 의 릴레이션은, 모든 부동 소수점치에 관한 전체 순서부를 제공하지 않습니다. 이 부동 소수점치는 절대치가 다른 수치입니다만,<code>-0. 0f == 0.0f</code> 는 <code>true</code> 이며, NaN 치는 모든 부동 소수점치나 그 자체와 비교해도, 그것 이하에서도 이상에서도 등치이기도 하지 않습니다. 소트를 진행시키기 위해서(때문에), 이 메소드는 수치의 승순을 확정하는 <code>&lt;</code> 릴레이션을 사용하는 대신에,<A HREF="../../java/lang/Float.html#compareTo(java.lang.Float)"><CODE>Float.compareTo(java.lang.Float)</CODE></A>  가 실시하는 전체 순서부를 사용합니다. <code>-0. 0f</code> 가 <code>0.0f</code> 미만으로서 다루어져 NaN 가 다른 부동 소수점치보다 크다고 보이는 점으로써, 이 순서부는,<code>&lt;</code> 릴레이션과는 다릅니다. 소트를 실시하기 위해서(때문에), 모든 NaN 치는 등가로 간주해집니다.  &nbsp;<p>
소트 알고리즘은 조정된 퀵 소트로, 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에 의한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n 의 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트로, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(java.lang.Object[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</PRE>
<DL>
<DD>요소<A HREF="../../java/lang/Comparable.html" title="java.lang 중의 인터페이스">자연 순서부</a>에 따라, 지정된 객체의 배열을 승순으로 소트 합니다. 배열의 모든 요소는,<A HREF="../../java/lang/Comparable.html" title="java.lang 안의 인터페이스"><CODE>Comparable</CODE></A>  인터페이스를 구현하고 있을 필요가 있습니다. 또, 배열의 모든 요소는, 「서로 비교 가능」이 아니면 안됩니다. 즉, 배열의 요소가 <tt>e1</tt> 및 <tt>e2</tt> 의 경우에,<tt>e1.compareTo(e2)</tt> 로 <tt>ClassCastException</tt> 를 throw 해야 하지는 않습니다. <p>

이 소트는 고정인 것이 보증되고 있습니다. 즉, 소트를 실행해도, 동등의 요소의 순서는 바뀌지 않습니다. <p>

소트 알고리즘은 수정 머지 소트입니다. 이 소트에서는, 하위의 사브리 파업에 있어서의 최고 레벨의 요소가 상위의 사브리 파업에 있어서의 최저 레벨의 요소보다 작은 경우, 머지는 생략 됩니다. 이 알고리즘은, 항상 n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 배열에 「서로 비교 가능」이 아닌 요소 (예를 들어, 캐릭터 라인과 정수)가 있는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(java.lang.Object[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>요소<A HREF="../../java/lang/Comparable.html" title="java.lang 중의 인터페이스">자연 순서부</a>에 따라, 지정된 객체의 배열의 지정된 범위를 승순으로 소트 합니다. 소트 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 인덱스 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 소트 범위는 비운다). 범위의 모든 요소는,<A HREF="../../java/lang/Comparable.html" title="java.lang 안의 인터페이스"><CODE>Comparable</CODE></A>  인터페이스를 구현하고 있을 필요가 있습니다. 또, 범위의 모든 요소는, 「서로 비교 가능」이 아니면 안됩니다. 즉, 배열의 요소가 <tt>e1</tt> 및 <tt>e2</tt> 인 경우에,<tt>e1.compareTo(e2)</tt> 로 <tt>ClassCastException</tt> 를 throw 해야 하지는 않습니다. <p>

이 소트는 고정인 것이 보증되고 있습니다. 즉, 소트를 실행해도, 동등의 요소의 순서는 바뀌지 않습니다. <p>

소트 알고리즘은 수정 머지 소트입니다. 이 소트에서는, 하위의 사브리 파업에 있어서의 최고 레벨의 요소가 상위의 사브리 파업에 있어서의 최저 레벨의 요소보다 작은 경우, 머지는 생략 됩니다. 이 알고리즘은, 항상 n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 배열에 「서로 비교 가능」이 아닌 요소 (예를 들어, 캐릭터 라인과 정수)가 있는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(java.lang.Object[],java.util.Comparator)"><!-- --></A> <A NAME="sort(T[], java.util.Comparator)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static &lt;T&gt; void <B>sort</B>(T[]&nbsp;a,
                            <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</PRE>
<DL>
<DD>지정된 Comparator가 가리키는 순서에 따라, 지정된 객체의 배열을 소트 합니다. 배열의 모든 요소는, 지정된 Comparator로 「서로 비교 가능」이 아니면 안됩니다. 즉, 배열의 요소가 <tt>e1</tt> 및 <tt>e2</tt> 의 경우,<tt>c.compare(e1, e2)</tt> 로 <tt>ClassCastException</tt> 를 throw 해야 하지는 않습니다. <p>

이 소트는 고정인 것이 보증되고 있습니다. 즉, 소트를 실행해도, 동등의 요소의 순서는 바뀌지 않습니다. <p>

소트 알고리즘은 수정 머지 소트입니다. 이 소트에서는, 하위의 사브리 파업에 있어서의 최고 레벨의 요소가 상위의 사브리 파업에 있어서의 최저 레벨의 요소보다 작은 경우, 머지는 생략 됩니다. 이 알고리즘은, 항상 n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>c</CODE> - 배열의 순서를 결정하는 Comparator. <tt>null</tt> 치는, 요소<A HREF="../../java/lang/Comparable.html" title="java.lang 중의 인터페이스">자연 순서부</a>를 사용하는 것을 나타낸다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 지정된 Comparator로 「서로 비교」할 수 없는 요소가 배열에 있는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(java.lang.Object[],int,int,java.util.Comparator)"><!-- --></A> <A NAME="sort(T[], int, int, java.util.Comparator)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static &lt;T&gt; void <B>sort</B>(T[]&nbsp;a,
                            int&nbsp;fromIndex,
                            int&nbsp;toIndex,
                            <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</PRE>
<DL>
<DD>지정된 Comparator의 차례에 따라서, 지정된 객체의 배열의 지정 범위를 승순으로 소트 합니다. 소트 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 인덱스 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 소트 범위는 비운다). 이 범위의 모든 요소는, 지정된 Comparator로 「서로 비교 가능」이 아니면 안됩니다. 즉, 배열의 요소가 <tt>e1</tt> 및 <tt>e2</tt> 의 경우,<tt>c.compare(e1, e2)</tt> 로 <tt>ClassCastException</tt> 를 throw 해야 하지는 않습니다. <p>

이 소트는 고정인 것이 보증되고 있습니다. 즉, 소트를 실행해도, 동등의 요소의 순서는 바뀌지 않습니다. <p>

소트 알고리즘은 수정 머지 소트입니다.  이 소트에서는, 하위의 사브리 파업에 있어서의 최고 레벨의 요소가 상위의 사브리 파업에 있어서의 최저 레벨의 요소보다 작은 경우, 머지는 생략 됩니다. 이 알고리즘은, 항상 n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스<DD><CODE>c</CODE> - 배열의 순서를 결정하는 Comparator. <tt>null</tt> 치는, 요소<A HREF="../../java/lang/Comparable.html" title="java.lang 중의 인터페이스">자연 순서부</a>를 사용하는 것을 나타낸다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 지정된 Comparator로 「서로 비교」할 수 없는 요소가 배열에 있는 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(long[], long)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(long[]&nbsp;a,
                               long&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 long 치의 배열로부터 지정된 값을 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(long[])"><CODE>sort(long[])</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>배열에 검색 키가 있는 경우는 검색 키의 인덱스.               
검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 배열의 모든 요소가 지정된 키보다 작은 경우는 <tt>a.length</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(long[], int, int, long)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(long[]&nbsp;a,
                               int&nbsp;fromIndex,
                               int&nbsp;toIndex,
                               long&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 long 치의 배열로부터 지정된 값의 범위를 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(long[], int, int)"><CODE>sort(long[], int, int)</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 이 범위에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>fromIndex</CODE> - 검색되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 검색되는 마지막 요소 (범위외)의 인덱스<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>지정된 범위내의 배열에 검색 키가 있는 경우는 검색 키의 인덱스.

               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 범위내의 최초의 요소의 인덱스인가, 범위내의 모든 요소가 지정된 키보다 작은 경우는 <tt>toIndex</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>fromIndex &gt; toIndex</code> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>fromIndex &lt; 0 또는 toIndex &gt; a.length</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(int[], int)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(int[]&nbsp;a,
                               int&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 int 치의 배열로부터 지정된 값을 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(int[])"><CODE>sort(int[])</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>배열에 검색 키가 있는 경우는 검색 키의 인덱스.
               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 배열의 모든 요소가 지정된 키보다 작은 경우는 <tt>a.length</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(int[], int, int, int)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(int[]&nbsp;a,
                               int&nbsp;fromIndex,
                               int&nbsp;toIndex,
                               int&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 int 치의 배열로부터 지정된 값의 범위를 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(int[], int, int)"><CODE>sort(int[], int, int)</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 이 범위에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>fromIndex</CODE> - 검색되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 검색되는 마지막 요소 (범위외)의 인덱스<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>지정된 범위내의 배열에 검색 키가 있는 경우는 검색 키의 인덱스.

               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 범위내의 최초의 요소의 인덱스인가, 범위내의 모든 요소가 지정된 키보다 작은 경우는 <tt>toIndex</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>fromIndex &gt; toIndex</code> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>fromIndex &lt; 0 또는 toIndex &gt; a.length</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(short[], short)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(short[]&nbsp;a,
                               short&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 short 치의 배열로부터 지정된 값을 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(short[])"><CODE>sort(short[])</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>배열에 검색 키가 있는 경우는 검색 키의 인덱스.               
검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 배열의 모든 요소가 지정된 키보다 작은 경우는 <tt>a.length</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(short[], int, int, short)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(short[]&nbsp;a,
                               int&nbsp;fromIndex,
                               int&nbsp;toIndex,
                               short&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 short 치의 배열로부터 지정된 값의 범위를 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(short[], int, int)"><CODE>sort(short[], int, int)</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 이 범위에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>fromIndex</CODE> - 검색되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 검색되는 마지막 요소 (범위외)의 인덱스<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>지정된 범위내의 배열에 검색 키가 있는 경우는 검색 키의 인덱스.

               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 범위내의 최초의 요소의 인덱스인가, 범위내의 모든 요소가 지정된 키보다 작은 경우는 <tt>toIndex</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>fromIndex &gt; toIndex</code> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>fromIndex &lt; 0 또는 toIndex &gt; a.length</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(char[], char)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(char[]&nbsp;a,
                               char&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 char 값의 배열로부터 지정된 값을 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(char[])"><CODE>sort(char[])</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>배열에 검색 키가 있는 경우는 검색 키의 인덱스.
               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 배열의 모든 요소가 지정된 키보다 작은 경우는 <tt>a.length</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(char[], int, int, char)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(char[]&nbsp;a,
                               int&nbsp;fromIndex,
                               int&nbsp;toIndex,
                               char&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 char 값의 배열로부터 지정된 값의 범위를 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(char[], int, int)"><CODE>sort(char[], int, int)</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 이 범위에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>fromIndex</CODE> - 검색되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 검색되는 마지막 요소 (범위외)의 인덱스<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>지정된 범위내의 배열에 검색 키가 있는 경우는 검색 키의 인덱스.

               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 범위내의 최초의 요소의 인덱스인가, 범위내의 모든 요소가 지정된 키보다 작은 경우는 <tt>toIndex</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>fromIndex &gt; toIndex</code> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>fromIndex &lt; 0 또는 toIndex &gt; a.length</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(byte[], byte)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(byte[]&nbsp;a,
                               byte&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 byte 치의 배열로부터 지정된 값을 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(byte[])"><CODE>sort(byte[])</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>배열에 검색 키가 있는 경우는 검색 키의 인덱스.
               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 배열의 모든 요소가 지정된 키보다 작은 경우는 <tt>a.length</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(byte[], int, int, byte)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(byte[]&nbsp;a,
                               int&nbsp;fromIndex,
                               int&nbsp;toIndex,
                               byte&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 byte 치의 배열로부터 지정된 값의 범위를 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(byte[], int, int)"><CODE>sort(byte[], int, int)</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 이 범위에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>fromIndex</CODE> - 검색되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 검색되는 마지막 요소 (범위외)의 인덱스<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>지정된 범위내의 배열에 검색 키가 있는 경우는 검색 키의 인덱스.

               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 범위내의 최초의 요소의 인덱스인가, 범위내의 모든 요소가 지정된 키보다 작은 경우는 <tt>toIndex</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>fromIndex &gt; toIndex</code> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>fromIndex &lt; 0 또는 toIndex &gt; a.length</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(double[], double)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(double[]&nbsp;a,
                               double&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 double 치의 배열로부터 지정된 값을 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(double[])"><CODE>sort(double[])</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다. 이 메소드에서는 모든 NaN 치를 등가로 간주합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>배열에 검색 키가 있는 경우는 검색 키의 인덱스.
               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 배열의 모든 요소가 지정된 키보다 작은 경우는 <tt>a.length</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(double[], int, int, double)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(double[]&nbsp;a,
                               int&nbsp;fromIndex,
                               int&nbsp;toIndex,
                               double&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 double 치의 배열로부터 지정된 값의 범위를 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(double[], int, int)"><CODE>sort(double[], int, int)</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 이 범위에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다. 이 메소드에서는 모든 NaN 치를 등가로 간주합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>fromIndex</CODE> - 검색되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 검색되는 마지막 요소 (범위외)의 인덱스<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>지정된 범위내의 배열에 검색 키가 있는 경우는 검색 키의 인덱스.

               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 범위내의 최초의 요소의 인덱스인가, 범위내의 모든 요소가 지정된 키보다 작은 경우는 <tt>toIndex</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>fromIndex &gt; toIndex</code> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>fromIndex &lt; 0 또는 toIndex &gt; a.length</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(float[], float)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(float[]&nbsp;a,
                               float&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 float 치의 배열로부터 지정된 값을 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(float[])"><CODE>sort(float[])</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다. 이 메소드에서는 모든 NaN 치를 등가로 간주합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>배열에 검색 키가 있는 경우는 검색 키의 인덱스.
               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 배열의 모든 요소가 지정된 키보다 작은 경우는 <tt>a.length</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(float[], int, int, float)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(float[]&nbsp;a,
                               int&nbsp;fromIndex,
                               int&nbsp;toIndex,
                               float&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 float 치의 배열로부터 지정된 값의 범위를 검색합니다. 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(float[], int, int)"><CODE>sort(float[], int, int)</CODE></A>  메소드로 범위를 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 값을 가지는 요소가 이 범위에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다. 이 메소드에서는 모든 NaN 치를 등가로 간주합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>fromIndex</CODE> - 검색되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 검색되는 마지막 요소 (범위외)의 인덱스<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>지정된 범위내의 배열에 검색 키가 있는 경우는 검색 키의 인덱스.

               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 범위내의 최초의 요소의 인덱스인가, 범위내의 모든 요소가 지정된 키보다 작은 경우는 <tt>toIndex</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>fromIndex &gt; toIndex</code> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>fromIndex &lt; 0 또는 toIndex &gt; a.length</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(java.lang.Object[], java.lang.Object)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
                               <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 배열로부터 지정된 객체를 검색합니다. 배열은, 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(java.lang.Object[])"><CODE>sort(Object[])</CODE></A>  메소드를 사용해 요소<A HREF="../../java/lang/Comparable.html" title="java.lang 중의 인터페이스">자연 순서부</a>에 따라 승순에 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 배열이 서로 비교 가능하지 않은 요소, 예를 들어 캐릭터 라인이나 정수등인 경우, 배열은 그 요소의 자연 순서부에 따라 소트 하지 못하고, 결과는 미정도리입니다. 지정된 객체와 동등의 요소가 배열에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>배열에 검색 키가 있는 경우는 검색 키의 인덱스.
               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 배열의 모든 요소가 지정된 키보다 작은 경우는 <tt>a.length</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 검색 키가 배열의 요소와 동등하지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(java.lang.Object[], int, int, java.lang.Object)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
                               int&nbsp;fromIndex,
                               int&nbsp;toIndex,
                               <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 배열의 범위로부터 지정된 객체를 검색합니다. 범위는, 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(java.lang.Object[], int, int)"><CODE>sort(Object[], int, int)</CODE></A>  메소드를 사용해 요소<A HREF="../../java/lang/Comparable.html" title="java.lang 중의 인터페이스">자연 순서부</a>에 따라 승순에 소트 할 필요가 있습니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 범위가 서로 비교 가능하지 않은 요소, 예를 들어 캐릭터 라인이나 정수등인 경우, 배열은 그 요소의 자연 순서부에 따라 소트 하지 못하고, 결과는 미정도리입니다. 지정된 객체와 동등의 요소가 범위에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>fromIndex</CODE> - 검색되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 검색되는 마지막 요소 (범위외)의 인덱스<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>지정된 범위내의 배열에 검색 키가 있는 경우는 검색 키의 인덱스.

               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 범위내의 최초의 요소의 인덱스인가, 범위내의 모든 요소가 지정된 키보다 작은 경우는 <tt>toIndex</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 검색 키가 지정된 범위내의 배열의 요소와 동등하지 않은 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>fromIndex &gt; toIndex</code> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>fromIndex &lt; 0 또는 toIndex &gt; a.length</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(java.lang.Object[],java.lang.Object,java.util.Comparator)"><!-- --></A> <A NAME="binarySearch(T[], T, java.util.Comparator)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static &lt;T&gt; int <B>binarySearch</B>(T[]&nbsp;a,
                                   T&nbsp;key,
                                   <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 배열로부터 지정된 객체를 검색합니다. 배열은, 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(T[], java.util.Comparator)"><CODE>sort(T[], Comparator)</CODE></A>  메소드를 사용해, 지정된 Comparator에 따라 승순에 소트 하지 않으면 안됩니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 객체와 동등의 요소가 배열에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값<DD><CODE>c</CODE> - 배열이 순서 붙이고 되는 Comparator. <tt>null</tt> 치는, 요소<A HREF="../../java/lang/Comparable.html" title="java.lang 중의 인터페이스">자연 순서부</a>를 사용하는 것을 나타낸다
<DT><B>반환값:</B><DD>배열에 검색 키가 있는 경우는 검색 키의 인덱스.
               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 배열의 모든 요소가 지정된 키보다 작은 경우는 <tt>a.length</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 지정된 Comparator로 「서로 비교 가능」이 아닌 요소가 배열에 포함되어 있는 경우, 혹은 검색 키가 이 Comparator로 배열의 요소로 서로 비교할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(java.lang.Object[],int,int,java.lang.Object,java.util.Comparator)"><!-- --></A> <A NAME="binarySearch(T[], int, int, T, java.util.Comparator)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static &lt;T&gt; int <B>binarySearch</B>(T[]&nbsp;a,
                                   int&nbsp;fromIndex,
                                   int&nbsp;toIndex,
                                   T&nbsp;key,
                                   <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 배열의 범위로부터 지정된 객체를 검색합니다. 범위는, 이 호출전에,<A HREF="../../java/util/Arrays.html#sort(T[], int, int, java.util.Comparator)"><CODE>sort(T[], int, int, Comparator)</CODE></A>  메소드를 사용해, 지정된 Comparator에 따라 승순에 소트 하지 않으면 안됩니다. 리스트가 소트되어 있지 않은 경우, 결과는 정의되지 않습니다. 지정된 객체와 동등의 요소가 범위에 다수 있는 경우에는, 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>fromIndex</CODE> - 검색되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 검색되는 마지막 요소 (범위외)의 인덱스<DD><CODE>key</CODE> - 검색되는 값<DD><CODE>c</CODE> - 배열이 순서 붙이고 되는 Comparator. <tt>null</tt> 치는, 요소<A HREF="../../java/lang/Comparable.html" title="java.lang 중의 인터페이스">자연 순서부</a>를 사용하는 것을 나타낸다
<DT><B>반환값:</B><DD>지정된 범위내의 배열에 검색 키가 있는 경우는 검색 키의 인덱스.

               검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란, 배열로 키가 삽입되는 포인트이다. 즉, 키보다 큰 범위내의 최초의 요소의 인덱스인가, 범위내의 모든 요소가 지정된 키보다 작은 경우는 <tt>toIndex</tt>. 이것에 의해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 지정된 Comparator로 「서로 비교 가능」이 아닌 요소가 범위에 포함되어 있는 경우, 혹은 검색 키가 이 Comparator로 범위내의 요소로 서로 비교할 수 없는 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>fromIndex &gt; toIndex</code> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>fromIndex &lt; 0 또는 toIndex &gt; a.length</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="equals(long[], long[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(long[]&nbsp;a,
                             long[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 long 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. 2 개의 배열이 동등으로 간주해지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt> 의 경우에도 동등으로 간주해집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 개째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 개째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="equals(int[], int[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(int[]&nbsp;a,
                             int[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 int 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. 2 개의 배열이 동등으로 간주해지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt> 의 경우에도 동등으로 간주해집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 개째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 개째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="equals(short[], short[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(short[]&nbsp;a,
                             short[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 short 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. 2 개의 배열이 동등으로 간주해지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt> 의 경우에도 동등으로 간주해집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 개째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 개째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="equals(char[], char[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(char[]&nbsp;a,
                             char[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 char 값의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. 2 개의 배열이 동등으로 간주해지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt> 의 경우에도 동등으로 간주해집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 개째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 개째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="equals(byte[], byte[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(byte[]&nbsp;a,
                             byte[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 byte 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. 2 개의 배열이 동등으로 간주해지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt> 의 경우에도 동등으로 간주해집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 개째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 개째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="equals(boolean[], boolean[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(boolean[]&nbsp;a,
                             boolean[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 boolean 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. 2 개의 배열이 동등으로 간주해지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt> 의 경우에도 동등으로 간주해집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 개째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 개째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="equals(double[], double[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(double[]&nbsp;a,
                             double[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 double 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. 2 개의 배열이 동등으로 간주해지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt> 의 경우에도 동등으로 간주해집니다. <p>

2 개의 double 치 <tt>d1</tt> 와 <tt>d2</tt> 는, 다음의 경우에 동등으로 간주해집니다.
 <pre>    <tt>new Double(d1). equals(new Double(d2))</tt></pre>
<tt>==</tt> 연산자와 달리, 이 메소드는 <tt>NaN</tt> 를 그것 자신과 동등으로 간주해, 0.0d 로 -0. 0d 는 동등으로 간주하지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 개째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 개째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Double.html#equals(java.lang.Object)"><CODE>Double.equals(Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(float[], float[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(float[]&nbsp;a,
                             float[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 float 치의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. 2 개의 배열이 동등으로 간주해지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt> 의 경우에도 동등으로 간주해집니다. <p>

다음의 경우는, 2 개의 float 치 <tt>f1</tt> 및 <tt>f2</tt> 는 동등이 됩니다.
 <pre>    <tt>new Float(f1). equals(new Float(f2))</tt></pre>
<tt>==</tt>연산자와 달리, 이 메소드는 <tt>NaN</tt> 를 그것 자신과 동등으로 간주해, 0.0f 로 -0. 0f 는 동등으로 간주하지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 개째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 개째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Float.html#equals(java.lang.Object)"><CODE>Float.equals(Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object[], java.lang.Object[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
                             <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 Object 의 배열이 서로 동등한 경우에 <tt>true</tt> 를 돌려줍니다. 2 개의 배열이 동등으로 간주해지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. <tt>e1</tt> 와 <tt>e2</tt> 의 2 개의 객체는,<tt>(e1==null ?  e2==null :e1.equals(e2))</tt> 의 경우에 동등으로 간주해집니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt> 의 경우에도 동등으로 간주해집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 개째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 개째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="fill(long[], long)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(long[]&nbsp;a,
                        long&nbsp;val)</PRE>
<DL>
<DD>지정된 long 치의 배열의 각 요소에, 지정된 long 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(long[], int, int, long)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(long[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        long&nbsp;val)</PRE>
<DL>
<DD>long 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 long 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(int[], int)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(int[]&nbsp;a,
                        int&nbsp;val)</PRE>
<DL>
<DD>지정된 int 치의 배열의 각 요소에, 지정된 int 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(int[], int, int, int)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(int[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        int&nbsp;val)</PRE>
<DL>
<DD>int 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 int 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(short[], short)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(short[]&nbsp;a,
                        short&nbsp;val)</PRE>
<DL>
<DD>지정된 short 치의 배열의 각 요소에, 지정된 short 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(short[], int, int, short)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(short[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        short&nbsp;val)</PRE>
<DL>
<DD>short 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 short 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(char[], char)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(char[]&nbsp;a,
                        char&nbsp;val)</PRE>
<DL>
<DD>지정된 char 값의 배열의 각 요소에, 지정된 char 값를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(char[], int, int, char)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(char[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        char&nbsp;val)</PRE>
<DL>
<DD>char 값로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 char 값를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(byte[], byte)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(byte[]&nbsp;a,
                        byte&nbsp;val)</PRE>
<DL>
<DD>지정된 byte 치의 배열의 각 요소에, 지정된 byte 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(byte[], int, int, byte)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(byte[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        byte&nbsp;val)</PRE>
<DL>
<DD>byte 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 byte 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(boolean[], boolean)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(boolean[]&nbsp;a,
                        boolean&nbsp;val)</PRE>
<DL>
<DD>지정된 boolean 치의 배열의 각 요소에, 지정된 boolean 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(boolean[], int, int, boolean)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(boolean[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        boolean&nbsp;val)</PRE>
<DL>
<DD>boolean 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 boolean 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(double[], double)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(double[]&nbsp;a,
                        double&nbsp;val)</PRE>
<DL>
<DD>지정된 double 치의 배열의 각 요소에, 지정된 double 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(double[], int, int, double)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(double[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        double&nbsp;val)</PRE>
<DL>
<DD>double 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 double 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(float[], float)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(float[]&nbsp;a,
                        float&nbsp;val)</PRE>
<DL>
<DD>지정된 float 치의 배열의 각 요소에, 지정된 float 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(float[], int, int, float)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(float[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        float&nbsp;val)</PRE>
<DL>
<DD>float 치로 지정된 배열 중(안)에서, 지정된 범위에 있는 각 요소에, 지정된 float 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(java.lang.Object[], java.lang.Object)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
                        <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;val)</PRE>
<DL>
<DD>지정된 Object 의 배열의 각 요소에, 지정된 Object 참조를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ArrayStoreException.html" title="java.lang 안의 클래스">ArrayStoreException</A> </CODE> - 지정된 값이, 지정된 배열에 포함할 수 있는 실행시의 형태가 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(java.lang.Object[], int, int, java.lang.Object)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;val)</PRE>
<DL>
<DD>지정된 Object 의 배열로, 지정된 범위에 있는 각 요소에, 지정된 Object 참조를 대입합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt> 의 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayStoreException.html" title="java.lang 안의 클래스">ArrayStoreException</A> </CODE> - 지정된 값이, 지정된 배열에 포함할 수 있는 실행시의 형태가 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="copyOf(java.lang.Object[],int)"><!-- --></A> <A NAME="copyOf(T[], int)"><!-- --></A> <H3>
copyOf</H3>
<PRE>
public static &lt;T&gt; T[] <B>copyOf</B>(T[]&nbsp;original,
                             int&nbsp;newLength)</PRE>
<DL>
<DD>지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 null 로 패딩 합니다. 원의 배열과 카피의 양쪽 모두로 모든 인덱스가 유효한 경우는, 2 개의 배열에 같은 값이 포함됩니다. 카피에서는 유효해도, 원의 배열에서는 유효하지 않은 인덱스가 있는 경우, 카피에는 <tt>null</tt> 가 포함됩니다. 그러한 인덱스는, 지정된 길이가 원의 배열의 길이보다 큰 경우에만 존재합니다. 결과적으로 얻을 수 있는 배열의 클래스는, 원의 배열과 완전히 같은 것입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 카피되는 배열<DD><CODE>newLength</CODE> - 반환되는 카피의 길이
<DT><B>반환값:</B><DD>지정된 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 null 로 패딩 된 원의 배열의 카피
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NegativeArraySizeException.html" title="java.lang 안의 클래스">NegativeArraySizeException</A> </CODE> - <tt>newLength</tt> 가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOf(java.lang.Object[],int,java.lang.Class)"><!-- --></A> <A NAME="copyOf(U[], int, java.lang.Class)"><!-- --></A> <H3>
copyOf</H3>
<PRE>
public static &lt;T, U&gt; T[] <B>copyOf</B>(U[]&nbsp;original,
                               int&nbsp;newLength,
                               <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;?  extends T[]&gt;&nbsp;newType)</PRE>
<DL>
<DD>지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 null 로 패딩 합니다. 원의 배열과 카피의 양쪽 모두로 모든 인덱스가 유효한 경우는, 2 개의 배열에 같은 값이 포함됩니다. 카피에서는 유효해도, 원의 배열에서는 유효하지 않은 인덱스가 있는 경우, 카피에는 <tt>null</tt> 가 포함됩니다. 그러한 인덱스는, 지정된 길이가 원의 배열의 길이보다 큰 경우에만 존재합니다. 결과적으로 얻을 수 있는 배열의 클래스는 <tt>newType</tt> 입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 카피되는 배열<DD><CODE>newLength</CODE> - 반환되는 카피의 길이<DD><CODE>newType</CODE> - 반환되는 카피의 클래스
<DT><B>반환값:</B><DD>지정된 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 null 로 패딩 된 원의 배열의 카피
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NegativeArraySizeException.html" title="java.lang 안의 클래스">NegativeArraySizeException</A> </CODE> - <tt>newLength</tt> 가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayStoreException.html" title="java.lang 안의 클래스">ArrayStoreException</A> </CODE> - <tt>original</tt> 로부터 카피되는 요소가,<tt>newType</tt> 클래스의 배열에 포함할 수 있는 실행시의 형태가 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOf(byte[], int)"><!-- --></A> <H3>
copyOf</H3>
<PRE>
public static byte[] <B>copyOf</B>(byte[]&nbsp;original,
                            int&nbsp;newLength)</PRE>
<DL>
<DD>지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 제로로 패딩 합니다. 원의 배열과 카피의 양쪽 모두로 모든 인덱스가 유효한 경우는, 2 개의 배열에 같은 값이 포함됩니다. 카피에서는 유효해도, 원의 배열에서는 유효하지 않은 인덱스가 있는 경우, 카피에는 <tt>(byte) 0</tt> 이 포함됩니다. 그러한 인덱스는, 지정된 길이가 원의 배열의 길이보다 큰 경우에만 존재합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 카피되는 배열<DD><CODE>newLength</CODE> - 반환되는 카피의 길이
<DT><B>반환값:</B><DD>지정된 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 제로로 패딩 된 원의 배열의 카피
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NegativeArraySizeException.html" title="java.lang 안의 클래스">NegativeArraySizeException</A> </CODE> - <tt>newLength</tt> 가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOf(short[], int)"><!-- --></A> <H3>
copyOf</H3>
<PRE>
public static short[] <B>copyOf</B>(short[]&nbsp;original,
                             int&nbsp;newLength)</PRE>
<DL>
<DD>지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 제로로 패딩 합니다. 원의 배열과 카피의 양쪽 모두로 모든 인덱스가 유효한 경우는, 2 개의 배열에 같은 값이 포함됩니다. 카피에서는 유효해도, 원의 배열에서는 유효하지 않은 인덱스가 있는 경우, 카피에는 <tt>(short) 0</tt> 이 포함됩니다. 그러한 인덱스는, 지정된 길이가 원의 배열의 길이보다 큰 경우에만 존재합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 카피되는 배열<DD><CODE>newLength</CODE> - 반환되는 카피의 길이
<DT><B>반환값:</B><DD>지정된 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 제로로 패딩 된 원의 배열의 카피
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NegativeArraySizeException.html" title="java.lang 안의 클래스">NegativeArraySizeException</A> </CODE> - <tt>newLength</tt> 가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOf(int[], int)"><!-- --></A> <H3>
copyOf</H3>
<PRE>
public static int[] <B>copyOf</B>(int[]&nbsp;original,
                           int&nbsp;newLength)</PRE>
<DL>
<DD>지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 제로로 패딩 합니다. 원의 배열과 카피의 양쪽 모두로 모든 인덱스가 유효한 경우는, 2 개의 배열에 같은 값이 포함됩니다. 카피에서는 유효해도, 원의 배열에서는 유효하지 않은 인덱스가 있는 경우, 카피에는 <tt>0</tt> 이 포함됩니다. 그러한 인덱스는, 지정된 길이가 원의 배열의 길이보다 큰 경우에만 존재합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 카피되는 배열<DD><CODE>newLength</CODE> - 반환되는 카피의 길이
<DT><B>반환값:</B><DD>지정된 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 제로로 패딩 된 원의 배열의 카피
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NegativeArraySizeException.html" title="java.lang 안의 클래스">NegativeArraySizeException</A> </CODE> - <tt>newLength</tt> 가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOf(long[], int)"><!-- --></A> <H3>
copyOf</H3>
<PRE>
public static long[] <B>copyOf</B>(long[]&nbsp;original,
                            int&nbsp;newLength)</PRE>
<DL>
<DD>지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 제로로 패딩 합니다. 원의 배열과 카피의 양쪽 모두로 모든 인덱스가 유효한 경우는, 2 개의 배열에 같은 값이 포함됩니다. 카피에서는 유효해도, 원의 배열에서는 유효하지 않은 인덱스가 있는 경우, 카피에는 <tt>0L</tt> 가 포함됩니다. 그러한 인덱스는, 지정된 길이가 원의 배열의 길이보다 큰 경우에만 존재합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 카피되는 배열<DD><CODE>newLength</CODE> - 반환되는 카피의 길이
<DT><B>반환값:</B><DD>지정된 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 제로로 패딩 된 원의 배열의 카피
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NegativeArraySizeException.html" title="java.lang 안의 클래스">NegativeArraySizeException</A> </CODE> - <tt>newLength</tt> 가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOf(char[], int)"><!-- --></A> <H3>
copyOf</H3>
<PRE>
public static char[] <B>copyOf</B>(char[]&nbsp;original,
                            int&nbsp;newLength)</PRE>
<DL>
<DD>지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 null 문자로 패딩 합니다. 원의 배열과 카피의 양쪽 모두로 모든 인덱스가 유효한 경우는, 2 개의 배열에 같은 값이 포함됩니다. 카피에서는 유효해도, 원의 배열에서는 유효하지 않은 인덱스가 있는 경우, 카피에는 <tt>'\\u000'</tt> 가 포함됩니다. 그러한 인덱스는, 지정된 길이가 원의 배열의 길이보다 큰 경우에만 존재합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 카피되는 배열<DD><CODE>newLength</CODE> - 반환되는 카피의 길이
<DT><B>반환값:</B><DD>지정된 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 null 문자로 패딩 된 원의 배열의 카피
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NegativeArraySizeException.html" title="java.lang 안의 클래스">NegativeArraySizeException</A> </CODE> - <tt>newLength</tt> 가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOf(float[], int)"><!-- --></A> <H3>
copyOf</H3>
<PRE>
public static float[] <B>copyOf</B>(float[]&nbsp;original,
                             int&nbsp;newLength)</PRE>
<DL>
<DD>지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 제로로 패딩 합니다. 원의 배열과 카피의 양쪽 모두로 모든 인덱스가 유효한 경우는, 2 개의 배열에 같은 값이 포함됩니다. 카피에서는 유효해도, 원의 배열에서는 유효하지 않은 인덱스가 있는 경우, 카피에는 <tt>0f</tt> 가 포함됩니다. 그러한 인덱스는, 지정된 길이가 원의 배열의 길이보다 큰 경우에만 존재합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 카피되는 배열<DD><CODE>newLength</CODE> - 반환되는 카피의 길이
<DT><B>반환값:</B><DD>지정된 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 제로로 패딩 된 원의 배열의 카피
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NegativeArraySizeException.html" title="java.lang 안의 클래스">NegativeArraySizeException</A> </CODE> - <tt>newLength</tt> 가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOf(double[], int)"><!-- --></A> <H3>
copyOf</H3>
<PRE>
public static double[] <B>copyOf</B>(double[]&nbsp;original,
                              int&nbsp;newLength)</PRE>
<DL>
<DD>지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 제로로 패딩 합니다. 원의 배열과 카피의 양쪽 모두로 모든 인덱스가 유효한 경우는, 2 개의 배열에 같은 값이 포함됩니다. 카피에서는 유효해도, 원의 배열에서는 유효하지 않은 인덱스가 있는 경우, 카피에는 <tt>0d</tt> 가 포함됩니다. 그러한 인덱스는, 지정된 길이가 원의 배열의 길이보다 큰 경우에만 존재합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 카피되는 배열<DD><CODE>newLength</CODE> - 반환되는 카피의 길이
<DT><B>반환값:</B><DD>지정된 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 제로로 패딩 된 원의 배열의 카피
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NegativeArraySizeException.html" title="java.lang 안의 클래스">NegativeArraySizeException</A> </CODE> - <tt>newLength</tt> 가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOf(boolean[], int)"><!-- --></A> <H3>
copyOf</H3>
<PRE>
public static boolean[] <B>copyOf</B>(boolean[]&nbsp;original,
                               int&nbsp;newLength)</PRE>
<DL>
<DD>지정된 배열을 카피해, 그 카피가 지정된 길이가 되도록(듯이), 필요에 따라서 절약할까 <tt>false</tt> 로 패딩 합니다. 원의 배열과 카피의 양쪽 모두로 모든 인덱스가 유효한 경우는, 2 개의 배열에 같은 값이 포함됩니다. 카피에서는 유효해도, 원의 배열에서는 유효하지 않은 인덱스가 있는 경우, 카피에는 <tt>false</tt> 가 포함됩니다. 그러한 인덱스는, 지정된 길이가 원의 배열의 길이보다 큰 경우에만 존재합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 카피되는 배열<DD><CODE>newLength</CODE> - 반환되는 카피의 길이
<DT><B>반환값:</B><DD>지정된 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 false 요소로 패딩 된 원의 배열의 카피
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NegativeArraySizeException.html" title="java.lang 안의 클래스">NegativeArraySizeException</A> </CODE> - <tt>newLength</tt> 가 0 보다 작은 값의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOfRange(java.lang.Object[],int,int)"><!-- --></A> <A NAME="copyOfRange(T[], int, int)"><!-- --></A> <H3>
copyOfRange</H3>
<PRE>
public static &lt;T&gt; T[] <B>copyOfRange</B>(T[]&nbsp;original,
                                  int&nbsp;from,
                                  int&nbsp;to)</PRE>
<DL>
<DD>지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. 범위의 최초의 인덱스 (<tt>from</tt>)는, 제로로부터 <tt>original.length</tt> 의 범위의 값이 아니면 안됩니다. <tt>original[from]</tt> 의 값은,<tt>from == original.length</tt> 또는 <tt>from == to</tt> 가 아닌 한, 카피의 최초의 요소에 배치됩니다. 원의 배열의 그 후의 요소의 값은, 카피의 그 후의 요소에 배치됩니다. 범위의 마지막 인덱스 (<tt>to</tt>)는,<tt>from</tt> 이상이 아니면 안되어,<tt>original.length</tt> 보다 커도 괜찮습니다. 그 경우, 인덱스가 <tt>original.length - from</tt> 이상의 카피의 모든 요소에 <tt>null</tt> 가 배치됩니다. 반환되는 배열의 길이는 <tt>to - from</tt> 가 됩니다.  &nbsp;<p>
결과적으로 얻을 수 있는 배열의 클래스는, 원의 배열과 완전히 같은 것입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 범위의 카피처가 되는 배열<DD><CODE>from</CODE> - 카피되는 범위의 최초의 인덱스 (범위내)<DD><CODE>to</CODE> - 카피되는 범위의 마지막 인덱스 (범위내) 
(이 인덱스는 배열의 외측에 존재하는 일도 있다)
<DT><B>반환값:</B><DD>필요한 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 null 로 패딩 된, 원의 배열의 지정된 범위를 포함한 새로운 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>from &lt; 0</tt> 또는 <tt>from &gt; original.length()</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>from &gt; to</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOfRange(java.lang.Object[],int,int,java.lang.Class)"><!-- --></A> <A NAME="copyOfRange(U[], int, int, java.lang.Class)"><!-- --></A> <H3>
copyOfRange</H3>
<PRE>
public static &lt;T, U&gt; T[] <B>copyOfRange</B>(U[]&nbsp;original,
                                    int&nbsp;from,
                                    int&nbsp;to,
                                    <A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;?  extends T[]&gt;&nbsp;newType)</PRE>
<DL>
<DD>지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. 범위의 최초의 인덱스 (<tt>from</tt>)는, 제로로부터 <tt>original.length</tt> 의 범위의 값이 아니면 안됩니다. <tt>original[from]</tt> 의 값은,<tt>from == original.length</tt> 또는 <tt>from == to</tt> 가 아닌 한, 카피의 최초의 요소에 배치됩니다. 원의 배열의 그 후의 요소의 값은, 카피의 그 후의 요소에 배치됩니다. 범위의 마지막 인덱스 (<tt>to</tt>)는,<tt>from</tt> 이상이 아니면 안되어,<tt>original.length</tt> 보다 커도 괜찮습니다. 그 경우, 인덱스가 <tt>original.length - from</tt> 이상의 카피의 모든 요소에 <tt>null</tt> 가 배치됩니다. 반환되는 배열의 길이는 <tt>to - from</tt> 가 됩니다. 결과적으로 얻을 수 있는 배열의 클래스는 <tt>newType</tt> 입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 범위의 카피처가 되는 배열<DD><CODE>from</CODE> - 카피되는 범위의 최초의 인덱스 (범위내)<DD><CODE>to</CODE> - 카피되는 범위의 마지막 인덱스 (범위내) 
(이 인덱스는 배열의 외측에 존재하는 일도 있다)<DD><CODE>newType</CODE> - 반환되는 카피의 클래스
<DT><B>반환값:</B><DD>필요한 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 null 로 패딩 된, 원의 배열의 지정된 범위를 포함한 새로운 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>from &lt; 0</tt> 또는 <tt>from &gt; original.length()</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>from &gt; to</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우
<DD><CODE><A HREF="../../java/lang/ArrayStoreException.html" title="java.lang 안의 클래스">ArrayStoreException</A> </CODE> - <tt>original</tt> 로부터 카피되는 요소가,<tt>newType</tt> 클래스의 배열에 포함할 수 있는 실행시의 형태가 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOfRange(byte[], int, int)"><!-- --></A> <H3>
copyOfRange</H3>
<PRE>
public static byte[] <B>copyOfRange</B>(byte[]&nbsp;original,
                                 int&nbsp;from,
                                 int&nbsp;to)</PRE>
<DL>
<DD>지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. 범위의 최초의 인덱스 (<tt>from</tt>)는, 제로로부터 <tt>original.length</tt> 의 범위의 값이 아니면 안됩니다. <tt>original[from]</tt> 의 값은,<tt>from == original.length</tt> 또는 <tt>from == to</tt> 가 아닌 한, 카피의 최초의 요소에 배치됩니다. 원의 배열의 그 후의 요소의 값은, 카피의 그 후의 요소에 배치됩니다. 범위의 마지막 인덱스 (<tt>to</tt>)는,<tt>from</tt> 이상이 아니면 안되어,<tt>original.length</tt> 보다 커도 괜찮습니다. 그 경우, 인덱스가 <tt>original.length - from</tt> 이상의 카피의 모든 요소에 <tt>(byte) 0</tt> 이 배치됩니다. 반환되는 배열의 길이는 <tt>to - from</tt> 가 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 범위의 카피처가 되는 배열<DD><CODE>from</CODE> - 카피되는 범위의 최초의 인덱스 (범위내)<DD><CODE>to</CODE> - 카피되는 범위의 마지막 인덱스 (범위내) 
(이 인덱스는 배열의 외측에 존재하는 일도 있다)
<DT><B>반환값:</B><DD>필요한 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 제로로 패딩 된, 원의 배열의 지정된 범위를 포함한 새로운 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>from &lt; 0</tt> 또는 <tt>from &gt; original.length()</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>from &gt; to</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOfRange(short[], int, int)"><!-- --></A> <H3>
copyOfRange</H3>
<PRE>
public static short[] <B>copyOfRange</B>(short[]&nbsp;original,
                                  int&nbsp;from,
                                  int&nbsp;to)</PRE>
<DL>
<DD>지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. 범위의 최초의 인덱스 (<tt>from</tt>)는, 제로로부터 <tt>original.length</tt> 의 범위의 값이 아니면 안됩니다. <tt>original[from]</tt> 의 값은,<tt>from == original.length</tt> 또는 <tt>from == to</tt> 가 아닌 한, 카피의 최초의 요소에 배치됩니다. 원의 배열의 그 후의 요소의 값은, 카피의 그 후의 요소에 배치됩니다. 범위의 마지막 인덱스 (<tt>to</tt>)는,<tt>from</tt> 이상이 아니면 안되어,<tt>original.length</tt> 보다 커도 괜찮습니다. 그 경우, 인덱스가 <tt>original.length - from</tt> 이상의 카피의 모든 요소에 <tt>(short) 0</tt> 이 배치됩니다. 반환되는 배열의 길이는 <tt>to - from</tt> 가 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 범위의 카피처가 되는 배열<DD><CODE>from</CODE> - 카피되는 범위의 최초의 인덱스 (범위내)<DD><CODE>to</CODE> - 카피되는 범위의 마지막 인덱스 (범위내) 
(이 인덱스는 배열의 외측에 존재하는 일도 있다)
<DT><B>반환값:</B><DD>필요한 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 제로로 패딩 된, 원의 배열의 지정된 범위를 포함한 새로운 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>from &lt; 0</tt> 또는 <tt>from &gt; original.length()</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>from &gt; to</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOfRange(int[], int, int)"><!-- --></A> <H3>
copyOfRange</H3>
<PRE>
public static int[] <B>copyOfRange</B>(int[]&nbsp;original,
                                int&nbsp;from,
                                int&nbsp;to)</PRE>
<DL>
<DD>지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. 범위의 최초의 인덱스 (<tt>from</tt>)는, 제로로부터 <tt>original.length</tt> 의 범위의 값이 아니면 안됩니다. <tt>original[from]</tt> 의 값은,<tt>from == original.length</tt> 또는 <tt>from == to</tt> 가 아닌 한, 카피의 최초의 요소에 배치됩니다. 원의 배열의 그 후의 요소의 값은, 카피의 그 후의 요소에 배치됩니다. 범위의 마지막 인덱스 (<tt>to</tt>)는,<tt>from</tt> 이상이 아니면 안되어,<tt>original.length</tt> 보다 커도 괜찮습니다. 그 경우, 인덱스가 <tt>original.length - from</tt> 이상의 카피의 모든 요소에 <tt>0</tt> 이 배치됩니다. 반환되는 배열의 길이는 <tt>to - from</tt> 가 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 범위의 카피처가 되는 배열<DD><CODE>from</CODE> - 카피되는 범위의 최초의 인덱스 (범위내)<DD><CODE>to</CODE> - 카피되는 범위의 마지막 인덱스 (범위내) 
(이 인덱스는 배열의 외측에 존재하는 일도 있다)
<DT><B>반환값:</B><DD>필요한 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 제로로 패딩 된, 원의 배열의 지정된 범위를 포함한 새로운 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>from &lt; 0</tt> 또는 <tt>from &gt; original.length()</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>from &gt; to</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOfRange(long[], int, int)"><!-- --></A> <H3>
copyOfRange</H3>
<PRE>
public static long[] <B>copyOfRange</B>(long[]&nbsp;original,
                                 int&nbsp;from,
                                 int&nbsp;to)</PRE>
<DL>
<DD>지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. 범위의 최초의 인덱스 (<tt>from</tt>)는, 제로로부터 <tt>original.length</tt> 의 범위의 값이 아니면 안됩니다. <tt>original[from]</tt> 의 값은,<tt>from == original.length</tt> 또는 <tt>from == to</tt> 가 아닌 한, 카피의 최초의 요소에 배치됩니다. 원의 배열의 그 후의 요소의 값은, 카피의 그 후의 요소에 배치됩니다. 범위의 마지막 인덱스 (<tt>to</tt>)는,<tt>from</tt> 이상이 아니면 안되어,<tt>original.length</tt> 보다 커도 괜찮습니다. 그 경우, 인덱스가 <tt>original.length - from</tt> 이상의 카피의 모든 요소에 <tt>0L</tt> 가 배치됩니다. 반환되는 배열의 길이는 <tt>to - from</tt> 가 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 범위의 카피처가 되는 배열<DD><CODE>from</CODE> - 카피되는 범위의 최초의 인덱스 (범위내)<DD><CODE>to</CODE> - 카피되는 범위의 마지막 인덱스 (범위내) 
(이 인덱스는 배열의 외측에 존재하는 일도 있다)
<DT><B>반환값:</B><DD>필요한 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 제로로 패딩 된, 원의 배열의 지정된 범위를 포함한 새로운 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>from &lt; 0</tt> 또는 <tt>from &gt; original.length()</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>from &gt; to</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOfRange(char[], int, int)"><!-- --></A> <H3>
copyOfRange</H3>
<PRE>
public static char[] <B>copyOfRange</B>(char[]&nbsp;original,
                                 int&nbsp;from,
                                 int&nbsp;to)</PRE>
<DL>
<DD>지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. 범위의 최초의 인덱스 (<tt>from</tt>)는, 제로로부터 <tt>original.length</tt> 의 범위의 값이 아니면 안됩니다. <tt>original[from]</tt> 의 값은,<tt>from == original.length</tt> 또는 <tt>from == to</tt> 가 아닌 한, 카피의 최초의 요소에 배치됩니다. 원의 배열의 그 후의 요소의 값은, 카피의 그 후의 요소에 배치됩니다. 범위의 마지막 인덱스 (<tt>to</tt>)는,<tt>from</tt> 이상이 아니면 안되어,<tt>original.length</tt> 보다 커도 괜찮습니다. 그 경우, 인덱스가 <tt>original.length - from</tt> 이상의 카피의 모든 요소에 <tt>'\\u000'</tt> 가 배치됩니다. 반환되는 배열의 길이는 <tt>to - from</tt> 가 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 범위의 카피처가 되는 배열<DD><CODE>from</CODE> - 카피되는 범위의 최초의 인덱스 (범위내)<DD><CODE>to</CODE> - 카피되는 범위의 마지막 인덱스 (범위내) 
(이 인덱스는 배열의 외측에 존재하는 일도 있다)
<DT><B>반환값:</B><DD>필요한 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 null 문자로 패딩 된, 원의 배열의 지정된 범위를 포함한 새로운 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>from &lt; 0</tt> 또는 <tt>from &gt; original.length()</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>from &gt; to</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOfRange(float[], int, int)"><!-- --></A> <H3>
copyOfRange</H3>
<PRE>
public static float[] <B>copyOfRange</B>(float[]&nbsp;original,
                                  int&nbsp;from,
                                  int&nbsp;to)</PRE>
<DL>
<DD>지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. 범위의 최초의 인덱스 (<tt>from</tt>)는, 제로로부터 <tt>original.length</tt> 의 범위의 값이 아니면 안됩니다. <tt>original[from]</tt> 의 값은,<tt>from == original.length</tt> 또는 <tt>from == to</tt> 가 아닌 한, 카피의 최초의 요소에 배치됩니다. 원의 배열의 그 후의 요소의 값은, 카피의 그 후의 요소에 배치됩니다. 범위의 마지막 인덱스 (<tt>to</tt>)는,<tt>from</tt> 이상이 아니면 안되어,<tt>original.length</tt> 보다 커도 괜찮습니다. 그 경우, 인덱스가 <tt>original.length - from</tt> 이상의 카피의 모든 요소에 <tt>0f</tt> 가 배치됩니다. 반환되는 배열의 길이는 <tt>to - from</tt> 가 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 범위의 카피처가 되는 배열<DD><CODE>from</CODE> - 카피되는 범위의 최초의 인덱스 (범위내)<DD><CODE>to</CODE> - 카피되는 범위의 마지막 인덱스 (범위내) 
(이 인덱스는 배열의 외측에 존재하는 일도 있다)
<DT><B>반환값:</B><DD>필요한 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 제로로 패딩 된, 원의 배열의 지정된 범위를 포함한 새로운 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>from &lt; 0</tt> 또는 <tt>from &gt; original.length()</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>from &gt; to</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOfRange(double[], int, int)"><!-- --></A> <H3>
copyOfRange</H3>
<PRE>
public static double[] <B>copyOfRange</B>(double[]&nbsp;original,
                                   int&nbsp;from,
                                   int&nbsp;to)</PRE>
<DL>
<DD>지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. 범위의 최초의 인덱스 (<tt>from</tt>)는, 제로로부터 <tt>original.length</tt> 의 범위의 값이 아니면 안됩니다. <tt>original[from]</tt> 의 값은,<tt>from == original.length</tt> 또는 <tt>from == to</tt> 가 아닌 한, 카피의 최초의 요소에 배치됩니다. 원의 배열의 그 후의 요소의 값은, 카피의 그 후의 요소에 배치됩니다. 범위의 마지막 인덱스 (<tt>to</tt>)는,<tt>from</tt> 이상이 아니면 안되어,<tt>original.length</tt> 보다 커도 괜찮습니다. 그 경우, 인덱스가 <tt>original.length - from</tt> 이상의 카피의 모든 요소에 <tt>0d</tt> 가 배치됩니다. 반환되는 배열의 길이는 <tt>to - from</tt> 가 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 범위의 카피처가 되는 배열<DD><CODE>from</CODE> - 카피되는 범위의 최초의 인덱스 (범위내)<DD><CODE>to</CODE> - 카피되는 범위의 마지막 인덱스 (범위내) 
(이 인덱스는 배열의 외측에 존재하는 일도 있다)
<DT><B>반환값:</B><DD>필요한 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 제로로 패딩 된, 원의 배열의 지정된 범위를 포함한 새로운 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>from &lt; 0</tt> 또는 <tt>from &gt; original.length()</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>from &gt; to</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyOfRange(boolean[], int, int)"><!-- --></A> <H3>
copyOfRange</H3>
<PRE>
public static boolean[] <B>copyOfRange</B>(boolean[]&nbsp;original,
                                    int&nbsp;from,
                                    int&nbsp;to)</PRE>
<DL>
<DD>지정된 배열의 지정된 범위를 새로운 배열에 카피합니다. 범위의 최초의 인덱스 (<tt>from</tt>)는, 제로로부터 <tt>original.length</tt> 의 범위의 값이 아니면 안됩니다. <tt>original[from]</tt> 의 값은,<tt>from == original.length</tt> 또는 <tt>from == to</tt> 가 아닌 한, 카피의 최초의 요소에 배치됩니다. 원의 배열의 그 후의 요소의 값은, 카피의 그 후의 요소에 배치됩니다. 범위의 마지막 인덱스 (<tt>to</tt>)는,<tt>from</tt> 이상이 아니면 안되어,<tt>original.length</tt> 보다 커도 괜찮습니다. 그 경우, 인덱스가 <tt>original.length - from</tt> 이상의 카피의 모든 요소에 <tt>false</tt> 가 배치됩니다. 반환되는 배열의 길이는 <tt>to - from</tt> 가 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>original</CODE> - 범위의 카피처가 되는 배열<DD><CODE>from</CODE> - 카피되는 범위의 최초의 인덱스 (범위내)<DD><CODE>to</CODE> - 카피되는 범위의 마지막 인덱스 (범위내) 
(이 인덱스는 배열의 외측에 존재하는 일도 있다)
<DT><B>반환값:</B><DD>필요한 길이로 하기 위해서(때문에) 절약할 수 있던, 또는 false 요소로 패딩 된, 원의 배열의 지정된 범위를 포함한 새로운 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>from &lt; 0</tt> 또는 <tt>from &gt; original.length()</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>from &gt; to</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>original</tt> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="asList(java.lang.Object[])"><!-- --></A> <A NAME="asList(T...)"><!-- --></A> <H3>
asList</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt; <B>asList</B>(T...&nbsp;a)</PRE>
<DL>
<DD>지정된 배열에 연동하는 고정 사이즈의 리스트를 돌려줍니다. 반환된 리스트에의 변경은, 그대로 배열에 기입해집니다. 이 메소드는,<A HREF="../../java/util/Collection.html#toArray()"><CODE>Collection.toArray()</CODE></A>  와 조합하는 것으로, 배열 베이스의 API 와 컬렉션 베이스의 API 의 중개역으로서 기능합니다. 또, 반환되는 리스트는 직렬화 가능해,<A HREF="../../java/util/RandomAccess.html" title="java.util 안의 인터페이스"><CODE>RandomAccess</CODE></A>  를 구현합니다.

 <p>이 메소드는, 다음의 여러종류의 요소를 포함하도록(듯이) 초기화하는 고정 사이즈의 리스트를 작성하기 위한 편리한 방법도 제공합니다.
 <pre>
     List&lt;String&gt; stooges = Arrays.asList("Larry", "Moe", "Curly");
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 리스트의 기가 되는 배열
<DT><B>반환값:</B><DD>지정된 배열의 리스트 표시</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(long[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(long[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>long</tt> 배열 <tt>a</tt> 및 <tt>b</tt> 를 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

 <p>이 메소드가 돌려주는 값은,<tt>a</tt> 의 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Long.html" title="java.lang 동안의 클래스"><CODE>Long</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메소드를 호출해 취득하는 값과 같습니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 이 메소드는 0 을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(int[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(int[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 null 이외의 <tt>int</tt> 배열 <tt>a</tt> 및 <tt>b</tt> 를 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

 <p>이 메소드가 돌려주는 값은,<tt>a</tt> 의 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Integer.html" title="java.lang 동안의 클래스"><CODE>Integer</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메소드를 호출해 취득하는 값과 같습니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 이 메소드는 0 을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(short[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(short[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>short</tt> 배열 <tt>a</tt> 및 <tt>b</tt> 를 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

 <p>이 메소드가 돌려주는 값은,<tt>a</tt> 의 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Short.html" title="java.lang 동안의 클래스"><CODE>Short</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메소드를 호출해 취득하는 값과 같습니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 이 메소드는 0 을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(char[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(char[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>char</tt> 배열 <tt>a</tt> 및 <tt>b</tt> 를 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

 <p>이 메소드가 돌려주는 값은,<tt>a</tt> 의 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Character.html" title="java.lang 동안의 클래스"><CODE>Character</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메소드를 호출해 취득하는 값과 같습니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 이 메소드는 0 을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(byte[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(byte[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>byte</tt> 배열 <tt>a</tt> 및 <tt>b</tt> 를 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

 <p>이 메소드가 돌려주는 값은,<tt>a</tt> 의 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Byte.html" title="java.lang 동안의 클래스"><CODE>Byte</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메소드를 호출해 취득하는 값과 같습니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 이 메소드는 0 을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(boolean[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(boolean[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>boolean</tt> 배열 <tt>a</tt> 및 <tt>b</tt> 를 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

 <p>이 메소드가 돌려주는 값은,<tt>a</tt> 의 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Boolean.html" title="java.lang 동안의 클래스"><CODE>Boolean</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메소드를 호출해 취득하는 값과 같습니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 이 메소드는 0 을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(float[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(float[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>float</tt> 배열 <tt>a</tt> 및 <tt>b</tt> 를 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

 <p>이 메소드가 돌려주는 값은,<tt>a</tt> 의 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Float.html" title="java.lang 동안의 클래스"><CODE>Float</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메소드를 호출해 취득하는 값과 같습니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 이 메소드는 0 을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(double[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(double[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>double</tt> 배열 <tt>a</tt> 및 <tt>b</tt> 를 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

 <p>이 메소드가 돌려주는 값은,<tt>a</tt> 의 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Double.html" title="java.lang 동안의 클래스"><CODE>Double</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메소드를 호출해 취득하는 값과 같습니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 이 메소드는 0 을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(java.lang.Object[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 배열에 요소 이외의 배열이 포함되는 경우, 해시 코드는 내용은 아니고 식별 정보에 근거한 것이 됩니다. 이것에 의해, 자신을 요소로서 포함한 배열에 대해서, 이 메소드를 1 개 또는 복수의 배열 레벨을 개입시켜 직접 또는 간접적으로 호출하는 것이 가능하게 됩니다.

 <p>2 개의 배열 <tt>a</tt> 및 <tt>b</tt> 를 <tt>Arrays.equals(a, b)</tt> 라고 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

 <p>이 메소드에 의해 반환되는 값은,<tt>a</tt> 가 <tt>null</tt> 인 경우를 제외해,<tt>Arrays.asList(a). hashCode()</tt> 에 의해 반환되는 값에 동일해집니다. <tt>a</tt> 가 <tt>null</tt> 인 경우는,<tt>0</tt> 이 돌려주어집니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 내용 베이스의 해시 코드를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#deepHashCode(java.lang.Object[])"><CODE>deepHashCode(Object[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="deepHashCode(java.lang.Object[])"><!-- --></A> <H3>
deepHashCode</H3>
<PRE>
public static int <B>deepHashCode</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 「심층 내용」에 근거하는 해시 코드를 돌려줍니다. 배열에 요소 이외의 배열이 포함되는 경우, 해시 코드는 내용 및 그 외 모두에 근거한 것이 됩니다. 이 때문에, 자신을 요소로서 포함한 배열에 대해서, 이 메소드를 1 개 또는 복수의 배열 레벨을 개입시켜 직접 또는 간접적으로 호출할 수 없습니다. 이런 종류의 호출 동작은, 정의되고 있지 않습니다.

 <p>2 개의 배열 <tt>a</tt> 및 <tt>b</tt> 를 <tt>Arrays.deepEquals(a, b)</tt> 라고 표현할 수 있는 경우, 이것을 <tt>Arrays.deepHashCode(a) == Arrays.deepHashCode(b)</tt> 라고도 표현할 수 있습니다.

 <p>이 메소드에 의해 반환되는 값의 계산은,<tt>a</tt> 와 같은 요소를 같은 순서로 포함한 리스트에 대한 <A HREF="../../java/util/List.html#hashCode()"><CODE>List.hashCode()</CODE></A>  에 의해 반환되는 값의 계산 과 유사합니다. 다만,<tt>a</tt> 의 요소 <tt>e</tt> 자신이 배열의 경우, 그 해시 코드의 계산은,<tt>e.hashCode()</tt> 를 호출하는 것이 아니라,<tt>Arrays.hashCode(e)</tt> 의 적절한 overload를 호출하는지 (<tt>e</tt> 가 원시형의 배열인 경우),<tt>Arrays.deepHashCode(e)</tt> 를 재귀적으로 호출하는 (<tt>e</tt> 가 참조형의 배열인 경우)  것에 따라 실행됩니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 이 메소드는 0 을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 심층 내용 베이스의 해시 코드를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 심층 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#hashCode(java.lang.Object[])"><CODE>hashCode(Object[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="deepEquals(java.lang.Object[], java.lang.Object[])"><!-- --></A> <H3>
deepEquals</H3>
<PRE>
public static boolean <B>deepEquals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a1,
                                 <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a2)</PRE>
<DL>
<DD>2 개의 지정된 배열이 서로 「심층에서 등가」인 경우,<tt>true</tt> 를 돌려줍니다. <A HREF="../../java/util/Arrays.html#equals(java.lang.Object[], java.lang.Object[])"><CODE>equals(Object[], Object[])</CODE></A>  메소드와는 달라, 이 메소드는 임의의 깊이로 상자로 된 배열에서의 사용에 적절하고 있습니다.

 <p>양쪽 모두가 <tt>null</tt> 인 경우, 2 개의 배열 참조는 심층에서 등가이다고 보입니다. 또, 동수의 요소를 포함한 배열을 참조하는 경우, 2 개의 배열내의 대응하는 요소 페어는 심층에서 등가가 됩니다.

 <p><tt>null</tt> 의 가능성이 있는 2 개의 요소 <tt>e1</tt> 및 <tt>e2</tt> 는, 다음의 조건의 어느 쪽인가에 적합하는 경우, 심층에서 등가입니다.
 <ul>
<li> <tt>e1</tt> 와 <tt>e2</tt> 의 양쪽 모두가 객체 참조형의 배열이며,<tt>Arrays.deepEquals(e1, e2)</tt> 가 true 를 돌려준다
<li> <tt>e1</tt> 와 <tt>e2</tt> 가 같은 원시형의 배열이며,<tt>Arrays.equals(e1, e2)</tt> 의 적절한 overload가 true 를 돌려준다
<li> <tt>e1 == e2</tt>
<li> <tt>e1.equals(e2)</tt> 가 true 를 돌려준다
 </ul>
이 정의에서는, 임의의 깊이의 <tt>null</tt> 요소가 허용 되는 점에 주의해 주세요.

 <p>지정된 배열의 어느 쪽인지로, 1 개(살) 또는 복수의 배열 레벨을 개입시켜 직접 또는 간접적으로 자신이 요소로서 포함되는 경우, 이 메소드의 동작은 정의되고 있지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a1</CODE> - 동등한지 어떤지를 판정하는 1 개째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 개째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#equals(java.lang.Object[], java.lang.Object[])"><CODE>equals(Object[], Object[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toString(long[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(long[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는, 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는,<tt>String.valueOf(long)</tt> 에 의해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(int[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(int[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는, 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는,<tt>String.valueOf(int)</tt> 에 의해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(short[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(short[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는, 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는,<tt>String.valueOf(short)</tt> 에 의해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(char[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(char[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는, 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는,<tt>String.valueOf(char)</tt> 에 의해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(byte[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(byte[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는, 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는,<tt>String.valueOf(byte)</tt> 에 의해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(boolean[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(boolean[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는, 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는,<tt>String.valueOf(boolean)</tt> 에 의해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(float[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(float[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는, 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는,<tt>String.valueOf(float)</tt> 에 의해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(double[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(double[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는, 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는,<tt>String.valueOf(double)</tt> 에 의해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt> 의 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(java.lang.Object[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 캐릭터 라인 표현을 돌려줍니다. 배열에 요소 이외의 배열이 포함되는 경우,<tt>Object</tt> 로부터 확장된 <A HREF="../../java/lang/Object.html#toString()"><CODE>Object.toString()</CODE></A>  메소드에 의해 배열이 캐릭터 라인에 변환됩니다. <tt>Object</tt> 에는, 내용은 아니고 식별 정보가 기술되고 있습니다.

 <p>이 메소드에 의해 반환되는 값은,<tt>a</tt> 가 <tt>null</tt> 인 경우를 제외해,<tt>Arrays.asList(a). toString()</tt> 에 의해 반환되는 값과 동일해집니다. <tt>a</tt> 가 <tt>null</tt> 인 경우는, 「<tt>null</tt>」가 돌려주어집니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#deepToString(java.lang.Object[])"><CODE>deepToString(Object[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="deepToString(java.lang.Object[])"><!-- --></A> <H3>
deepToString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>deepToString</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 「심층 내용」의 캐릭터 라인 표현을 돌려줍니다. 배열에 요소 이외의 배열이 포함되는 경우, 캐릭터 라인 표현에는 그 내용등이 포함됩니다. 이 메소드는, 다차원 배열의 캐릭터 라인에의 변환용으로 설계되고 있습니다.

 <p>캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는, 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는, 그 자체가 배열이 아닌 한 <tt>String.valueOf(Object)</tt> 에 의해 캐릭터 라인에 변환됩니다.

 <p>요소 <tt>e</tt> 가 원시형의 배열인 경우,<tt>Arrays.toString(e)</tt> 의 적절한 overload를 호출하는 것으로 캐릭터 라인에 변환됩니다. 요소 <tt>e</tt> 가 참조형의 배열인 경우, 이 메소드를 재귀적으로 호출하는 것으로 캐릭터 라인에 변환됩니다.

 <p>무한의 재귀를 피하기 (위해)때문에, 지정된 배열에 자신이 요소로서 포함되는지, 1 개(살) 또는 복수의 배열 레벨을 개입시킨 자신에게로의 간접 참조가 포함되는 경우, 자기 참조는 캐릭터 라인 「<tt>[...]</tt>」에 변환됩니다. 예를 들어, 자신에게로의 참조만을 포함한 배열은, 「<tt>[[...]]</tt>」로서 draw 됩니다.

 <p>지정된 배열이 <tt>null</tt> 의 경우, 이 메소드는 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt> 의 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#toString(java.lang.Object[])"><CODE>toString(Object[])</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Arrays.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/util/ArrayList.html" title="java.util 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/util/BitSet.html" title="java.util 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/util/Arrays.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Arrays.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
