<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:57:31 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
URI (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="URI (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/URI.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/net/UnknownServiceException.html" title="java.net 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/net/URISyntaxException.html" title="java.net 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/net/URI.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="URI.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.net</FONT>
<BR>
클래스 URI</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.net.URI</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> , <A HREF="../../java/lang/Comparable.html" title="java.lang 안의 인터페이스">Comparable</A> &lt;<A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A> &gt;</DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public final class <B>URI</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스">Comparable</A> &lt;<A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A> &gt;, <A HREF="../../java/io/Serializable.html" title="java.io 안의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
URI (Uniform Resource Identifier) 참조를 나타냅니다.

 <p> 후술 하는 몇개의 작은 변경을 제외하면, 이 클래스의 인스턴스는,<a href="http://www.ietf.org/rfc/rfc2396.txt">「RFC&nbsp;2396: Uniform Resource Identifiers (URI): Generic Syntax」</a>  로 정의되어<a  href="http://www.ietf.org/rfc/rfc2732.txt">「RFC&nbsp;2732: Format for Literal IPv6 Addresses in URLs」</a>  로 수정된 URI 참조를 나타냅니다. 리터럴 IPv6 주소 형식에서는 스코프 ID 도 지원됩니다. 스코프 ID 의 구문이나 사용 방법에 대해서는,<a href="Inet6Address.html#scoped">여기</a>를 참조해 주세요. 이 클래스는, 컴퍼넌트로부터 또는 캐릭터 라인 형식을 해석해 URI 인스턴스를 작성하기 위한 생성자 , 인스턴스의 각종 컴퍼넌트에 액세스하기 위한 메소드, 및 URI 인스턴스를 정규화, 해결, 상대화하기 위한 메소드를 제공합니다. 이 클래스의 인스턴스는 불변입니다.


<h4> URI 구문과 컴퍼넌트 </h4>

최고정도 레벨의 캐릭터 라인 형식의 URI 참조 (이후는 단지 「URI」라고 한다)의 구문은 다음과 같습니다.

 <blockquote>
[schema<tt><b>:</b></tt><i></i>]schema 고유 부분[<tt><b>#</b></tt>fragment]
 </blockquote>

여기서, 꺽쇄묶음 [...] (은)는 생략 가능한 컴퍼넌트를 나타내, 문자 <tt><b>:</b></tt> 와 <tt><b>#</b></tt> 는 그 문자 자체를 나타냅니다.

 <p> 「절대」URI 는 schema를 지정해, 절대가 아닌 URI 는 「상대」라고 불립니다. 또, URI 는 「불투명」일까 「계층적」일까에 의해 분류됩니다.

 <p> 「불투명」URI 는, schema 고유 부분이 slash (<tt>/</tt>)로 시작되지 않는 절대 URI 입니다. 불투명 URI 는 그 이상 해석되지 않습니다. 불투명 URI 의 예를 다음에 나타냅니다.

 <blockquote><table cellpadding=0 cellspacing=0 summary="layout">
<tr><td><tt>mailto:java-net@java.sun.com</tt><td></tr>
<tr><td><tt>news:comp.lang.java</tt><td></tr>
<tr><td><tt>urn:isbn:096139210x</tt></td></tr>
 </table></blockquote>

 <p> 「계층」URI 는, schema 고유 부분이 slash로 시작되는 절대 URI, 또는 상대 URI (schema를 지정하지 않는 URI)입니다. 계층 URI 의 예를 다음에 나타냅니다.

 <blockquote>
<tt>http://java.sun.com/j2se/1. 3/</tt><br> <tt>docs/guide/collections/designfaq.html#28</tt><br> <tt>../../../demo/jfc/SwingSet2/src/SwingSet2.java</tt><br> <tt>file:///~/calendar</tt>
 </blockquote>

 <p> 계층 URI 는, 구문에 따라 한층 더 해석됩니다.

 <blockquote>
[schema<tt><b>:</b></tt>][<tt><b>//</b></tt>기관][패스][<tt><b>? </b></tt>쿼리][<tt><b>#</b></tt>fragment]
 </blockquote>

여기서,<tt><b>:</b></tt>,<tt><b>/</b></tt>,<tt><b>? </b></tt>, 및 <tt><b>#</b></tt> 은 그 문자 자체를 나타냅니다. 계층 URI 의 schema 고유 부분은, schema와 fragment 컴퍼넌트의 사이의 문자로 구성됩니다.

 <p> 계층 URI 의 기관 컴퍼넌트가 지정되고 있는 경우, 그 기관 컴퍼넌트는 「서버 베이스」또는 「레지스트리 베이스」입니다. 서버 베이스 기관은, 잘 알려져 있는 구문에 따라 해석됩니다.

 <blockquote>
[사용자 정보<tt><b>@</b></tt>]호스트[<tt><b>:</b></tt>포트]<i></i><i></i><i></i>
 </blockquote>

여기서,<tt><b>@</b></tt> 라고 <tt><b>:</b></tt> 는 그 문자 자체를 나타냅니다. 현재 사용되고 있는 URI schema의 대부분은 서버 베이스입니다. 이와 같이 해석되지 않는 기관 컴퍼넌트는, 레지스트리 베이스라고 보여집니다.

 <p> 계층 URI 의 패스 컴포넌트는, slash (<tt>/</tt>)로 시작되는 경우는 절대로 불려 그렇지 않은 경우는 상대로 불립니다. 절대인 계층 URI 또는 기관을 지정하는 계층 URI 의 패스 컴포넌트는 항상 절대입니다.

 <p> URI 인스턴스에는, 전부 다음의 9 개의 컴퍼넌트가 있습니다.

 <blockquote><table summary="Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment">
<tr><th><i>Component</i></th><th><i>형</i></th></tr>
<tr><td>schema</td><td><tt>String</tt></td></tr>
<tr><td>schema 고유 부분 &nbsp;&nbsp;&nbsp;&nbsp;</td><td><tt>String</tt></td></tr>
<tr><td>기관</td><td><tt>String</tt></td></tr>
<tr><td>사용자 정보</td><td><tt>String</tt></td></tr>
<tr><td>host</td><td><tt>String</tt></td></tr>
<tr><td>port</td><td><tt>int</tt></td></tr>
<tr><td>path</td><td><tt>String</tt></td></tr>
<tr><td>쿼리</td><td><tt>String</tt></td></tr>
<tr><td>fragment</td><td><tt>String</tt></td></tr>
 </table></blockquote>

지정된 인스턴스에서는, 어느 특정의 컴퍼넌트도 「미정도리」인가 「정의가 끝난 상태」이며, 개별의 형태의 값을 가집니다. 미정도리의 캐릭터 라인 컴퍼넌트는 <tt>null</tt> 로 나타내져 미정도리의 정수 컴퍼넌트는 <tt>-1</tt> 으로 나타내집니다. 캐릭터 라인 컴퍼넌트는, 값으로 해서 빈 상태(empty)의 캐릭터 라인을 가지도록(듯이) 정의할 수 있습니다. 이것은, 그 컴퍼넌트가 지정되지 않은 것으로 동등하지는 않습니다.

 <p> 특정의 컴퍼넌트가 인스턴스로 정의빌려주어지지 않은가는, 표현되는 URI 의 형태에 의해 다릅니다. 절대 URI 에는 schema 컴퍼넌트가 있습니다. 불투명 URI 에는 schema, schema 고유 부분, 및 아마 fragment가 있습니다만, 그 외의 컴퍼넌트는 없습니다. 계층 URI 에는, 항상 패스 (다만 빈 상태(empty)의 경우 있어) 및 schema 고유 부분 (적어도 패스를 포함한다)이 있어, 한층 더 그 외의 컴퍼넌트중 한쪽이 있는 경우가 있습니다. 기관 컴퍼넌트가 존재하고 있어 서버 베이스인 경우, 호스트 컴퍼넌트는 정의됩니다. 사용자 정보와 포트 컴퍼넌트는 정의되는 경우도 있습니다.


<h4> URI 인스턴스의 조작 </h4>

이 클래스에서 지원되는 주요한 조작은, 「정규화」, 「해결」, 및 「상대화」입니다.

 <p> 「정규화」는, 계층 URI 의 패스 컴포넌트로부터 불필요한 「<tt>. </tt>」 및 「<tt>..</tt>」세그먼트(segment)를 삭제하는 프로세스입니다. 각 「<tt>. </tt>」세그먼트(segment)는 단지 삭제됩니다. 「<tt>..</tt>」세그먼트(segment)는, 「<tt>..</tt>」이외의 세그먼트(segment)가 선행하는 경우에만 삭제됩니다. 정규화는 불투명 URI 에는 영향을 주지 않습니다.

 <p> <i></i>「해결」이란, 어느 URI 를 다른 「베이스」URI 에 근거해 해결하는 처리입니다. <i></i>결과적으로 얻을 수 있는 URI 는, RFC&nbsp;2396 에 규정된 방법에 근거해, 양쪽 모두의 URI 의 컴퍼넌트로부터 구축됩니다. 구체적으로는, 원의 URI 로 지정되어 있지 않은 컴퍼넌트에 대해서는, 베이스 URI 로부터 취득됩니다. 계층 URI 의 경우, 원의 패스는, 베이스의 패스에 근거해 해결된 뒤, 정규화됩니다. 예를 들어, 다음과 같이 됩니다.

 <blockquote>
<tt>docs/guide/collections/designfaq.html#28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>(1)
 </blockquote>

(을)를 베이스 URI <tt>http://java.sun.com/j2se/1. 3/</tt> 에 대해서 해결하면(자), 결과의 URI 는 다음과 같이 됩니다.

 <blockquote>
<tt>http://java.sun.com/j2se/1. 3/docs/guide/collections/designfaq.html#28</tt>
 </blockquote>

상대 URI

 <blockquote>
<tt>../../../demo/jfc/SwingSet2/src/SwingSet2.java&nbsp;&nbsp;&nbsp;&nbsp;</tt>(2)
 </blockquote>

(을)를 이 결과에 대해서 해결하면(자), 다음과 같이 됩니다.

 <blockquote>
<tt>http://java.sun.com/j2se/1. 3/demo/jfc/SwingSet2/src/SwingSet2.java</tt>
 </blockquote>

절대와 상대의 양쪽 모두의 URI 의 해결, 및 계층 URI 의 경우는 절대와 상대의 양쪽 모두의 패스의 해결이 지원됩니다. URI <tt>file:///~calendar</tt> 는 절대이므로, 이것을 다른 임의의 URI 에 대해서 해결하면(자), 원의 URI 가 생성될 뿐입니다. 상기의 상대 URI (2)를 상대 베이스 URI (1)에 대해서 해결하면(자), 정규화되고 있어도 상대 인 채의 URI 가 생성됩니다.

 <blockquote>
<tt>demo/jfc/SwingSet2/src/SwingSet2.java</tt>
 </blockquote>

 <p> <i></i>마지막에 「상대화」란, 해결의 역입니다. 임의의 2 개의 정규화가 끝난 URI  <i>u</i> 와 &nbsp;<i>v</i> 에 대해, 다음이 성립됩니다.

 <blockquote>
<i>u</i><tt>. relativize(</tt><i>u</i><tt>. resolve(</tt><i>v</i><tt>)). equals(</tt><i>v</i><tt>)</tt>&nbsp;&nbsp; 및<br> <i>u</i><tt>. resolve(</tt><i>u</i><tt>. relativize(</tt><i>v</i><tt>)). equals(</tt><i>v</i><tt>)</tt>&nbsp;&nbsp;<br>
 </blockquote>

이 조작은, 가능하면 어디서에서도, 문서의 베이스 URI 에 대해서 상대적이 아니면 안되는 URI 를 포함한 문서를 구축하는 경우에 편리합니다. 예를 들어, 다음의 URI

 <blockquote>
<tt>http://java.sun.com/j2se/1. 3/docs/guide/index.html</tt>
 </blockquote>

(을)를 다음의 베이스 URI 에 대해서 상대화하면(자),

 <blockquote>
<tt>http://java.sun.com/j2se/1. 3</tt>
 </blockquote>

상대 URI <tt>docs/guide/index.html</tt> 가 생성됩니다.


<h4> 문자 카테고리 </h4>

URI 참조의 각종 컴퍼넌트로 허가되는 문자는, RFC&nbsp;2396 로 엄밀하게 지정되고 있습니다. 다음의 카테고리를 사용해, 이 제약에 대해 설명합니다. 이러한 카테고리의 대부분은 그 스펙으로부터 놓치고 있습니다.

 <blockquote><table cellspacing=2 summary="Describes categories alpha,digit,alphanum,unreserved,punct,reserved,escaped,and other">
<tr><th valign=top><i>영문자</i></th>
<td><tt>A</tt>&nbsp;로부터 &nbsp;<tt>Z</tt>, 및 <tt>a</tt>&nbsp;로부터 &nbsp;<tt>z</tt> 까지의 US-ASCII 영문자</td></tr>
<tr><th valign=top><i>숫자</i></th>
<td><tt>0</tt>&nbsp;로부터 &nbsp;<tt>9</tt> 까지의 US-ASCII 10 진수자</td></tr>
<tr><th valign=top><i>영숫자</i></th>
<td>모든 「영문자」 및 「숫자」문자</td></tr>
<tr><th valign=top><i>미예약</i>&nbsp;&nbsp;&nbsp;&nbsp;</th>
<td>모든 「영숫자」문자, 및 캐릭터 라인 「<tt>_-!.~'()*</tt>」 안의 문자</td></tr>
<tr><th valign=top><i>구두점</i></th>
<td>캐릭터 라인 「<tt>,;:$&+=</tt>」 안의 문자</td></tr>
<tr><th valign=top><i>예약이 끝난 상태</i></th>
<td>모든 「구두점」문자, 및 캐릭터 라인 「<tt>? /[]@</tt>」 안의 문자</td></tr>
<tr><th valign=top><i>이스케이프</i></th>
<td>이스케이프 된 8중창. 즉, 퍼센트 문자 (<tt>%</tt>)와 거기에 계속되는 2 자리수의 16 진수 (<tt>0</tt> - <tt>9</tt>,<tt>A</tt> - <tt>F</tt>, 및 <tt>a</tt> - <tt>f</tt>)로 구성되는 삼중항</td></tr>
<tr><th valign=top><i>그 외</i></th>
<td>US-ASCII 캐릭터 세트에 포함되지 않고, 제어 문자 (<A HREF="../../java/lang/Character.html#isISOControl(char)"><CODE>Character.isISOControl</CODE></A>  메소드를 사용해 판정)가 아니고, 공백 문자 (<A HREF="../../java/lang/Character.html#isSpaceChar(char)"><CODE>Character.isSpaceChar</CODE></A>  메소드를 사용해 판정)가 아닌 Unicode 문자 &nbsp;&nbsp; (US-ASCII 로 한정되고 있는 <b>RFC 2396 을 변경한 것</b>)<i></i></td></tr>
 </table></blockquote>

 <p><a name="legal-chars"></a> 모든 유효한 URI 문자세트는 「미예약」, 「예약」, 「이스케이프」, 및 「그 외」의 문자로 구성됩니다.


<h4> 이스케이프 된 8중창, 인용부호, encode, 및 복호화 </h4>

RFC 2396 에서는, 이스케이프 된 8중창을 사용자 정보, 패스, 쿼리, 및 fragment의 각 컴퍼넌트에 표시할 수가 있습니다. URI 에 있어서의 이스케이프 처리의 목적은, 다음의 2 개입니다.

 <ul>

<li><p>  URI 에 「그 외」의 문자를 1 개도 포함하지 않게 하는 것으로 URI 를 RFC&nbsp;2396 에 엄밀하게 준거시킬 필요가 있는 경우에, 비 US-ASCII 문자를 「encode」한다. <i></i><i></i>  </p></li>

<li><p> 그대로는 부정하게 되는 컴퍼넌트내의 문자를 「인용부호로 둘러싼다」. 사용자 정보, 패스, 쿼리, 및 fragment의 각 컴퍼넌트는, 유효 또는 부정이라고 보여지는 문자의 조건이 다소 다르다.  
   </p></li>

 </ul>

이러한 목적이기 때문에, 이 클래스에는 다음의 3 개의 관련 조작이 준비되어 있습니다.

 <ul>

<li><p><a name="encode"></a>  문자는 UTF-8 캐릭터 세트내의 그 문자를 나타내는 이스케이프 된 8중창의 순서로 옮겨놓아 「encode」된다. 예를 들어, 유로 통화 기호 (<tt>'&#92;u20AC'</tt>)는 <tt>%E2%82%AC</tt> 로서 encode 된다 (특정의 캐릭터 세트를 지정하지 않는 <b>RFC&nbsp;2396 를 변경한 것</b>) </p></li>

<li><p><a name="quote"></a> 모든 부정한 문자는, 단지 encode 해 「인용부호로 둘러싸인다」. 예를 들어 공백 문자는,<tt>%20</tt> 로 옮겨놓아 인용부호로 둘러싸인다. UTF-8 에는 US-ASCII 가 포함되므로, US-ASCII 문자의 경우, 이 변환으로 RFC&nbsp;2396 로 요구되는 효과를 정확하게 얻을 수 있다 </p></li>

<li><p><a name="decode"></a>  이스케이프 된 8중창의 순서를 「디코드」한다. <i></i>구체적으로는, 그 순서가 UTF-8 캐릭터 세트내에서 나타내고 있는 문자 순서로 치환한다. UTF-8 는 US-ASCII 를 포함한다. 따라서, 디코드 처리는, 인용부호로 둘러싸인 모든 US-ASCII 문자의 인용부호를 해제하는 효과와 encode 된 모든 비 US-ASCII 문자를 디코드하는 효과가 있다. 이스케이프 된 8중창의 디코드시에<a    href="../nio/charset/CharsetDecoder.html#ce">디코드 에러</a>가 발생했을 경우, 그 에러의 발생한 octet 는, Unicode 치환 문자인<tt>「&#92;uFFFD」</tt>로 옮겨진다.   </p></li>

 </ul>

이러한 조작은, 다음에 나타내도록(듯이), 이 클래스의 생성자 과 메소드로 공개됩니다.

 <ul>

<li><p> <A HREF="../../java/net/URI.html#URI(java.lang.String)"><CODE><code>단일 인수 생성자</code></CODE></A>  은, 그 인수내의 모든 부정 문자가 인용부호로 둘러싸는 것을 요구하지만, 존재하는 이스케이프 된 8중창과 「그 외」의 문자는 모두 그대로 유지한다. <i></i>  </p></li>

<li><p> <A HREF="../../java/net/URI.html#URI(java.lang.String, java.lang.String, java.lang.String, int, java.lang.String, java.lang.String, java.lang.String)"><CODE><code>복수 인수 생성자</code></CODE></A>  은, 부정 문자를 포함한 컴퍼넌트로부터의 요구에 따라 부정 문자를 인용부호로 둘러싼다. 퍼센트 문자 (<tt>「%」</tt>)는 항상, 이러한 생성자 에 의해 둘러싸인다. <i></i>「그 외」의 문자는 모두 그대로 유지된다.   </p></li>

<li><p> <A HREF="../../java/net/URI.html#getRawUserInfo()"><CODE>getRawUserInfo</CODE></A> ,<A HREF="../../java/net/URI.html#getRawPath()"><CODE>getRawPath</CODE></A> ,<A HREF="../../java/net/URI.html#getRawQuery()"><CODE>getRawQuery</CODE></A> ,<A HREF="../../java/net/URI.html#getRawFragment()"><CODE>getRawFragment</CODE></A> ,<A HREF="../../java/net/URI.html#getRawAuthority()"><CODE>getRawAuthority</CODE></A> , 및 <A HREF="../../java/net/URI.html#getRawSchemeSpecificPart()"><CODE>getRawSchemeSpecificPart</CODE></A>  메소드는, 대응하는 컴퍼넌트의 값을 그대로의 형식에서 돌려주어, 이스케이프 된 8중창을 해석하지 않는다. 이러한 메소드로부터 반환되는 캐릭터 라인에는, 이스케이프 된 8중창과 「그 외」의 문자의 양쪽 모두가 포함되어 있는 일이 있어, 부정한 문자는 포함되지 않는다.  <i></i>  </p></li>

<li><p> <A HREF="../../java/net/URI.html#getUserInfo()"><CODE>getUserInfo</CODE></A> ,<A HREF="../../java/net/URI.html#getPath()"><CODE>getPath</CODE></A> ,<A HREF="../../java/net/URI.html#getQuery()"><CODE>getQuery</CODE></A> ,<A HREF="../../java/net/URI.html#getFragment()"><CODE>getFragment</CODE></A> ,<A HREF="../../java/net/URI.html#getAuthority()"><CODE>getAuthority</CODE></A> , 및 <A HREF="../../java/net/URI.html#getSchemeSpecificPart()"><CODE>getSchemeSpecificPart</CODE></A>  메소드는, 대응하는 컴퍼넌트내의 모든 이스케이프 된 8중창을 디코드한다. 이러한 메소드로부터 반환되는 캐릭터 라인에는, 「그 외」의 문자와 부정 문자의 어느쪽이나 포함될 가능성이 있지만, 이스케이프 된 8중창이 포함될 것은 없다. <i></i>  </p></li>

<li><p> <A HREF="../../java/net/URI.html#toString()"><CODE>toString</CODE></A>  메소드는, 모든 필요한 인용부호를 가지는 URI 캐릭터 라인을 돌려주지만, 「그 외」의 문자가 포함되는 경우가 있다. <i></i>
   </p></li>

<li><p> <A HREF="../../java/net/URI.html#toASCIIString()"><CODE>toASCIIString</CODE></A>  메소드는, 완전하게 인용부호로 둘러싸여 encode 된 URI 캐릭터 라인을 돌려준다. 이 캐릭터 라인에는 「그 외」의 문자는 포함되지 않는다. <i></i>  </p></li>

 </ul>


<h4> 아이덴티티 </h4>

임의의 URI <i>u</i> 의 경우에, 항상 다음과 같이 됩니다.

 <blockquote>
<tt>new URI(</tt><i>u</i><tt>. toString()). equals(</tt><i>u</i><tt>)</tt>&nbsp;
 </blockquote>

빈 상태(empty)의 기관의 전에 2 개의 slash가 있거나 (<tt>file:///tmp/</tt>&nbsp; 등), 호스트명의 후에 구두점이 있어도 포트가 지정되어 있지 않거나 (<tt>http://java.sun.com:</tt>&nbsp; 등) 하는 것 같은 장황 구문을 포함하지 않고, 인용부호로 둘러쌀 필요가 있는 문자 이외의 문자를 encode 하지 않는 URI <i>u</i> 의 경우는, 다음과 같이 됩니다.

 <blockquote>
<tt>new URI(</tt><i>u</i><tt>. getScheme(),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><i>u</i><tt>. getSchemeSpecificPart(),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><i>u</i><tt>. getFragment())<br> . equals(</tt><i>u</i><tt>)</tt>
 </blockquote>

모든 경우에 대해

 <blockquote>
<tt>new URI(</tt><i>u</i><tt>. getScheme(),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><i>u</i><tt>. getUserInfo(), &nbsp;</tt><i>u</i><tt>. getAuthority(),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><i>u</i><tt>. getPath(), &nbsp;</tt><i>u</i><tt>. getQuery(),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><i>u</i><tt>. getFragment())<br> . equals(</tt><i>u</i><tt>)</tt>
 </blockquote>

<i>u</i> 가 계층의 경우

 <blockquote>
<tt>new URI(</tt><i>u</i><tt>. getScheme(),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><i>u</i><tt>. getUserInfo(), &nbsp;</tt><i>u</i><tt>. getHost(), &nbsp;</tt><i>u</i><tt>. getPort(),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><i>u</i><tt>. getPath(), &nbsp;</tt><i>u</i><tt>. getQuery(),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><i>u</i><tt>. getFragment())<br> . equals(</tt><i>u</i><tt>)</tt>
 </blockquote>

<i>u</i> 가 계층에서, 기관을 가지지 않는가 서버 베이스의 기관을 가지는 경우


<h4> URI, URL, 및 URN </h4>

URI 는 Uniform Resource <i>Identifier</i> 이며, URL 는 Uniform Resource <i>Locator</i> 입니다. 따라서, 추상적으로 말하면, 모든 URL 는 URI 입니다만, 모든 URI 가 URL 이다고는인가 선. 이것은, URI 의 다른 부범위인 URN (Uniform Resource <i>Names</i>)가 있기 (위해)때문에입니다. URN 는 자원에 이름을 붙입니다만, 그 검색 방법은 지정하지 않습니다. 전에 나타낸 <tt>mailto</tt>,<tt>news</tt>, 및 <tt>isbn</tt> 의 각 URI 는, URN 의 예입니다.

 <p> URI 와 URL 와의 개념상의 구별은, 이 클래스와 <A HREF="../../java/net/URL.html" title="java.net 안의 클래스"><CODE>URL</CODE></A>  클래스의 사이의 상위에 반영되고 있습니다.

 <p> 이 클래스의 인스턴스는, RFC&nbsp;2396 로 정의되고 있는 구문으로서의 URI 참조를 나타냅니다. URI 는 절대, 상대의 어느 쪽인가에 됩니다. URI 캐릭터 라인은, schema가 지정되고 있어도 거기에 붙어 고려하지 않고, 일반적인 구문에 따라 해석됩니다. 호스트가 존재하고 있어도 그 검색은 실행되지 않고, schema에 의존하는 스트림 핸들러의 구축도 행해지지 않습니다. 등가성, 해시 처리, 및 비교는, 인스턴스의 문자 내용에 근거해 엄밀하게 정의됩니다. 바꾸어 말하면, URI 인스턴스는 기본적으로, 비교, 정규화, 해결, 및 상대화라고 하는, schema에 의존하지 않는 구문상의 조작을 지원하는, 구조화 된 캐릭터 라인입니다.

 <p> 이것에 대해,<A HREF="../../java/net/URL.html" title="java.net 안의 클래스"><CODE>URL</CODE></A>  클래스의 인스턴스는, URL 의 구문상의 컴퍼넌트를 나타낼 뿐만 아니라, 그 기술 대상이 되는 자원에의 액세스에 필요한 정보도 일부 갖추고 있습니다. URL 는 절대가 아니면 안됩니다. 즉, 항상 schema를 지정하지 않으면 안됩니다. URL 캐릭터 라인은, 그 schema에 따라 해석됩니다. 어느 URL 에 대해서도 스트림 핸들러가 반드시 확립됩니다. 실제, 사용 가능한 핸들러가 존재하지 않는 schema의 URL 인스턴스를 작성하는 것은 불가능합니다. 등가성과 해시 처리는, schema와 호스트의 인터넷 주소 (존재하는 경우)의 양쪽 모두에 의존합니다. 비교는 정의되지 않습니다. 바꾸어 말하면, URL 는, 해결이라고 하는 구문상의 조작과 호스트의 검색이나 지정된 자원에의 접속의 개방적인 어느 네트워크 입출력 조작을 지원하는, 구조화 된 캐릭터 라인입니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><a href="http://ietf.org/rfc/rfc2279.txt"><i>RFC 2279:UTF-8,
transformation format of ISO 10646</i></a> , <br><a  href="http://www.ietf.org/rfc/rfc2373.txt"><i>RFC&nbsp;2373:IPv6 Addressing
Architecture</i></a> , <br><a  href="http://www.ietf.org/rfc/rfc2396.txt"><i>RFC&nbsp;2396:Uniform
Resource Identifiers (URI) :Generic Syntax</i></a> , <br><a  href="http://www.ietf.org/rfc/rfc2732.txt"><i>RFC&nbsp;2732:Format for
Literal IPv6 Addresses in URLs</i></a> , <br><a  href="URISyntaxException.html">URISyntaxException</a> , 
<A HREF="../../serialized-form.html#java.net.URI">직렬화 된 형식</A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/net/URI.html#URI(java.lang.String)">URI</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 캐릭터 라인을 해석해 URI 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/net/URI.html#URI(java.lang.String, java.lang.String, java.lang.String)">URI</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;scheme,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;ssp,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;fragment)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 컴퍼넌트로부터 URI 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/net/URI.html#URI(java.lang.String, java.lang.String, java.lang.String, int, java.lang.String, java.lang.String, java.lang.String)">URI</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;scheme,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;userInfo,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
    int&nbsp;port,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;path,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;query,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;fragment)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 컴퍼넌트로부터 계층 URI 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/net/URI.html#URI(java.lang.String, java.lang.String, java.lang.String, java.lang.String)">URI</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;scheme,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;path,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;fragment)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 컴퍼넌트로부터 계층 URI 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/net/URI.html#URI(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)">URI</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;scheme,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;authority,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;path,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;query,
    <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;fragment)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 컴퍼넌트로부터 계층 URI 를 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#compareTo(java.net.URI)">compareTo</A> </B>(<A HREF="../../java/net/URI.html" title="java.net 안의 클래스">URI</A> &nbsp;that)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 를 다른 객체와 비교합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#create(java.lang.String)">create</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 캐릭터 라인을 해석해 URI 를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#equals(java.lang.Object)">equals</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;ob)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 가 다른 객체와 동일한지 어떤지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getAuthority()">getAuthority</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 복호화 된 기관 컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getFragment()">getFragment</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 복호화 된 fragment 컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getHost()">getHost</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 호스트 컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getPath()">getPath</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 복호화 된 패스 컴포넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getPort()">getPort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 포트 번호를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getQuery()">getQuery</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 복호화 된 쿼리컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getRawAuthority()">getRawAuthority</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 그대로의 기관 컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getRawFragment()">getRawFragment</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 그대로의 fragment 컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getRawPath()">getRawPath</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 그대로의 패스 컴포넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getRawQuery()">getRawQuery</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 그대로의 쿼리컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getRawSchemeSpecificPart()">getRawSchemeSpecificPart</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 그대로의 schema 고유 부분을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getRawUserInfo()">getRawUserInfo</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 그대로의 사용자 정보 컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getScheme()">getScheme</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 schema 컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getSchemeSpecificPart()">getSchemeSpecificPart</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 복호화 된 schema 고유 부분을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#getUserInfo()">getUserInfo</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 복호화 된 사용자 정보 컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#hashCode()">hashCode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 해시 코드값를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#isAbsolute()">isAbsolute</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 가 절대인가 어떤가를 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#isOpaque()">isOpaque</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 가 불투명한가 어떤가를 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#normalize()">normalize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 패스를 정규화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#parseServerAuthority()">parseServerAuthority</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 기관 컴퍼넌트 (정의되고 있는 경우)로부터 사용자 정보, 호스트, 및 포트의 각 컴퍼넌트에의 해석을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#relativize(java.net.URI)">relativize</A> </B>(<A HREF="../../java/net/URI.html" title="java.net 안의 클래스">URI</A> &nbsp;uri)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 URI 를 이 URI 에 대해서 상대화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#resolve(java.lang.String)">resolve</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 캐릭터 라인을 해석해, 그 후 그 캐릭터 라인을 이 URI 에 대해서 해결해, 새로운 URI 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#resolve(java.net.URI)">resolve</A> </B>(<A HREF="../../java/net/URI.html" title="java.net 안의 클래스">URI</A> &nbsp;uri)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 URI 를 이 URI 에 대해서 해결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#toASCIIString()">toASCIIString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 컨텐츠를 US-ASCII 캐릭터 라인으로서 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 의 컨텐츠를 캐릭터 라인으로서 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/URI.html#toURL()">toURL</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 URI 로부터 URL 를 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="URI(java.lang.String)"><!-- --></A> <H3>
URI</H3>
<PRE>
public <B>URI</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)
    throws <A HREF="../../java/net/URISyntaxException.html" title="java.net 내의 클래스">URISyntaxException</A> </PRE>
<DL>
<DD>지정된 캐릭터 라인을 해석해 URI 를 구축합니다.

 <p> 이 생성자 은, 지정된 캐릭터 라인을 해석할 때에,<a  href="http://www.ietf.org/rfc/rfc2396.txt">「RFC&nbsp;2396」</a>의 부록&nbsp;A 의 문법으로 엄밀하게 따릅니다. <b><i>다만, 다음의 점에 관해서는, 문법에 따르지 않습니다. </i></b> </p>

 <ul type=disc>

<li><p> 빈 상태(empty)의 기관 컴퍼넌트는, 그 후에 빈 상태(empty)이 아닌 패스, 쿼리컴퍼넌트, fragment 컴퍼넌트가 계속되고 있는 경우에 한해, 허가된다. 이것에 의해,<tt>「file:///foo/bar」</tt>등의 URI 를 해석할 수 있게 된다. 이것은, 문법에서는 허가되어 있지 않지만, RFC&nbsp;2396 의 의도하는 곳(중)이라고 생각된다. 기관 컴퍼넌트가 빈 상태(empty)의 경우, 사용자 정보, 호스트, 포트의 각 컴퍼넌트는 미정도리가 된다.  </p></li>

<li><p> 빈 상태(empty)의 상대 패스는 허가된다. 이것은, 문법에서는 허가되어 있지 않지만, RFC&nbsp;2396 의 의도하는 곳(중)이라고 생각된다. 이 일탈의 주된 결과적으로,<tt>「#foo」</tt>와 같은 단독의 fragment가, 빈 상태(empty)의 패스와 지정된 fragment를 가지는 상대 URI 로서 해석되게 된다. 이 URI 는 베이스 URI 에 근거해<a    href="#resolve-frag">해결</a>할 수 있으므로 편리하다.

<li><p> 호스트 컴퍼넌트내의 IPv4 주소는,<a    href="http://www.ietf.org/rfc/rfc2732.txt">「RFC&nbsp;2732」</a>  에 따라 엄밀하게 해석된다. 닷으로 4 개에 단락지어진 주소의 각 요소에는, 3 자리수를 넘는 10 진을 포함할 수 없다. 게다가 각 요소의 값은 255 를 넘어서는 안 된다고 하는 제약이 있습니다.  </p></li>

<li> <p> 호스트 컴퍼넌트내의 호스트명이 단일의 도메인 라벨만으로 구성되는 경우, 그 호스트명은 「영숫자」문자로 시작되어도 상관없다. <i></i>이것은, 문법에서는 허가되어 있지 않지만,<a    href="http://www.ietf.org/rfc/rfc2396.txt">「RFC&nbsp;2396」</a>의 섹션&nbsp;3. 2.2 의 의도하는 곳(중)이라고 생각된다. 이 변경의 결과로서,<tt>s://123</tt> 와 같은 계층 URI 의 기관 컴퍼넌트가, 서버 베이스 기관으로서 해석되게 된다.  </p></li>

<li><p> 호스트 컴퍼넌트로 IPv6 주소의 사용이 허가된다. <a    href="http://www.ietf.org/rfc/rfc2732.txt">「RFC&nbsp;2732」</a>에 따라,IPv6 주소는 꺽쇄묶음 (<tt>「[」</tt>과<tt>「]」</tt>)으로 둘러싸지 않으면 안 된다. IPv6 주소 자체는,<a    href="http://www.ietf.org/rfc/rfc2373.txt">RFC&nbsp;2373</a>  에 따라 해석되지 않으면 안 된다. IPv6 주소는 게다가 16 바이트를 넘지 않는 주소 정보를 기술하도록(듯이) 제약된다. 이 제약은, RFC&nbsp;2373 로 암묵적으로 나타나고 있지만, 문법에서는 표현할 수 없습니다.  </p></li>

<li><p> 「그 외」의 카테고리에 포함되는 문자는, RFC&nbsp;2396 가 「이스케이프」 octet 의 사용을 허가하고 있는 장소이면 어디에서라도 사용할 수 있다. 즉, 사용자 정보, 패스, 쿼리, fragment의 각 컴퍼넌트내에서 사용할 수 있다. 게다가 기관이 레지스트리 베이스이면, 기관 컴퍼넌트내에서도 사용할 수 있다. <i></i><i></i>이것에 의해, US-ASCII 캐릭터 세트에 포함되는 문자 이외의 Unicode 문자를, URI 에 포함할 수가 있게 된다.  </p></li>

 </ul>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - URI 에 해석되는 캐릭터 라인
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>str</tt> 가 <tt>null</tt> 의 경우
<DD><CODE><A HREF="../../java/net/URISyntaxException.html" title="java.net 안의 클래스">URISyntaxException</A> </CODE> - 상기의 변경에 의해 확장된 RFC&nbsp;2396 에, 지정된 캐릭터 라인이 위반하는 경우</DL>
</DL>
<HR>

<A NAME="URI(java.lang.String, java.lang.String, java.lang.String, int, java.lang.String, java.lang.String, java.lang.String)"><!-- --></A> <H3>
URI</H3>
<PRE>
public <B>URI</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;scheme,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;userInfo,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
           int&nbsp;port,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;path,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;query,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;fragment)
    throws <A HREF="../../java/net/URISyntaxException.html" title="java.net 내의 클래스">URISyntaxException</A> </PRE>
<DL>
<DD>지정된 컴퍼넌트로부터 계층 URI 를 구축합니다.

 <p> schema가 지정되어 패스도 지정되었을 경우, 그 패스는 빈 상태(empty)인지, slash 문자 (<tt>「/」</tt>)로 시작되지 않으면 안됩니다. 그렇지 않은 경우, 새로운 URI 의 컴퍼넌트는, 대응하는 파라미터에 <tt>null</tt> 를 건네주는지,<tt>port</tt> 파라미터의 경우는 <tt>-1</tt> 을 건네주어, 미정도리대로 되는 일이 있습니다.

 <p> 이 생성자 은 우선, 다음과 같이 지정된 컴퍼넌트로부터 URI 캐릭터 라인을 구축합니다만, 그 때,<a  href="http://www.ietf.org/rfc/rfc2396.txt">「RFC&nbsp;2396」</a>의 섹션&nbsp;5. 2 의 스텝 &nbsp;7 에 기재되어 있는 규칙에 따릅니다.  </p>

 <ol>

<li><p> 최초, 결과 캐릭터 라인은 비우고 있다.  </p></li>

<li><p> schema가 지정되고 있는 경우, 그 schema가 결과의 말미에 추가되어 그 후에 구두점 문자 (<tt>「:」</tt>)가 추가된다.   </p></li>

<li><p> 사용자 정보, 호스트, 또는 포트가 지정되고 있는 경우, 캐릭터 라인<tt>「//」</tt>이 말미에 추가된다.   </p></li>

<li><p> 사용자 정보가 지정되고 있는 경우, 그 사용자 정보가 말미에 추가되어 그 후에 단가 기호 (<tt>「@」</tt>)가 추가된다. 「미예약」, 「구두점」, 「이스케이프」, 「그 외」목의 카테고리에도 포함되지 않는 문자는 모두,<a href="#quote">인용부호</a>로 둘러싸인다. <i></i><i></i><i></i><i></i>  </p></li>

<li><p> 호스트가 지정되고 있는 경우, 그 호스트가 말미에 추가된다. 호스트가 리터럴 IPv6 주소이지만, 꺽쇄묶음 (<tt>「[」</tt>과<tt>「]」</tt>)으로 둘러싸이지 않은 경우는, 꺽쇄묶음이 추가된다.
   </p></li>

<li><p> 포트 번호가 지정되고 있는 경우, 구두점 문자 (<tt>「:」</tt>)가 말미에 추가되어 그 후에 그 10 진수의 포트 번호가 추가된다.
   </p></li>

<li><p> 패스가 지정되고 있는 경우, 그 패스가 말미에 추가된다. 「미예약」, 「구두점」, 「이스케이프」, 「그 외」목의 카테고리에도 포함되지 않고, slash 문자 (<tt>「/」</tt>), 단가 기호 (<tt>「@」</tt>)의 어느 쪽과도 동일하지 않은 문자는 모두, 인용부호로 둘러싸인다. <i></i><i></i><i></i><i></i>  </p></li>

<li><p> 쿼리가 지정되고 있는 경우, 물음표 문자 (<tt>「?」</tt>)이 말미에 추가되어 그 후에 그 쿼리가 추가된다. <a href="#legal-chars">적정한 URI 문자</a>가 아닌 문자는 모두, 인용부호로 둘러싸인다.
   </p></li>

<li><p> 마지막으로, fragment가 지정되고 있는 경우, 해시 문자 (<tt>「#」</tt>)가 말미에 추가되어 그 후에 그 fragment가 추가된다. 적정한 URI 문자가 아닌 문자는 모두, 인용부호로 둘러싸인다.   </p></li>

 </ol>

 <p> 결과적으로 얻을 수 있는 URI 캐릭터 라인이 해석됩니다만, 이 해석은,<A HREF="../../java/net/URI.html#URI(java.lang.String)"><CODE>URI(String)</CODE></A>  생성자 을 호출한 뒤, 그 결과에 대해서 <A HREF="../../java/net/URI.html#parseServerAuthority()"><CODE>parseServerAuthority()</CODE></A>  메소드를 호출했는지와 같이 행해집니다. 이것에 의해,<A HREF="../../java/net/URISyntaxException.html" title="java.net 안의 클래스"><CODE>URISyntaxException</CODE></A>  가 throw 될 가능성이 있습니다.   </p>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>scheme</CODE> - schema명<DD><CODE>userInfo</CODE> - 사용자명과 인증 정보<DD><CODE>host</CODE> - 호스트명<DD><CODE>port</CODE> - 포트 번호<DD><CODE>path</CODE> - 패스<DD><CODE>query</CODE> - 쿼리<DD><CODE>fragment</CODE> - fragment
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/URISyntaxException.html" title="java.net 안의 클래스">URISyntaxException</A> </CODE> - schema와 패스의 양쪽 모두가 지정되고 있지만 패스가 상대의 경우, 지정된 컴퍼넌트로부터 구축된 URI 캐릭터 라인이 RFC&nbsp;2396 에 위반하는 경우, 또는 캐릭터 라인의 기관 컴퍼넌트가 존재하지만 서버 베이스의 기관으로서 해석할 수 없는 경우</DL>
</DL>
<HR>

<A NAME="URI(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)"><!-- --></A> <H3>
URI</H3>
<PRE>
public <B>URI</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;scheme,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;authority,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;path,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;query,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;fragment)
    throws <A HREF="../../java/net/URISyntaxException.html" title="java.net 내의 클래스">URISyntaxException</A> </PRE>
<DL>
<DD>지정된 컴퍼넌트로부터 계층 URI 를 구축합니다.

 <p> schema가 지정되어 패스도 지정되었을 경우, 그 패스는 빈 상태(empty)인지, slash 문자 (<tt>「/」</tt>)로 시작되지 않으면 안됩니다. 그렇지 않은 경우, 새로운 URI 의 컴퍼넌트는, 대응하는 파라미터에 <tt>null</tt> 를 건네주어, 미정도리대로 되는 일이 있습니다.

 <p> 이 생성자 은 우선, 다음과 같이 지정된 컴퍼넌트로부터 URI 캐릭터 라인을 구축합니다만, 그 때,<a  href="http://www.ietf.org/rfc/rfc2396.txt">「RFC&nbsp;2396」</a>의 섹션&nbsp;5. 2 의 스텝 &nbsp;7 에 기재되어 있는 규칙에 따릅니다.  </p>

 <ol>

<li><p> 최초, 결과 캐릭터 라인은 비우고 있다.   </p></li>

<li><p> schema가 지정되고 있는 경우, 그 schema가 결과의 말미에 추가되어 그 후에 구두점 문자 (<tt>「:」</tt>)가 추가된다.   </p></li>

<li><p> 기관이 지정되고 있는 경우, 캐릭터 라인<tt>「//」</tt>이 말미에 추가되어 그 후에 그 기관이 추가된다. 기관에 리터럴 IPv6 주소가 포함되는 경우, 그 주소를 꺽쇄묶음 (<tt>「[」</tt>과<tt>「]」</tt>)으로 둘러쌀 필요가 있다. 「미예약」, 「구두점」, 「이스케이프」, 「그 외」목의 카테고리에도 포함되지 않고, 단가 기호 (<tt>「@」</tt>)와 동일하지 않은 문자는 모두,<a href="#quote">인용부호</a>로 둘러싸인다. <i></i><i></i><i></i><i></i>  </p></li>

<li><p> 패스가 지정되고 있는 경우, 그 패스가 말미에 추가된다. 「미예약」, 「구두점」, 「이스케이프」, 「그 외」목의 카테고리에도 포함되지 않고, slash 문자 (<tt>「/」</tt>), 단가 기호 (<tt>「@」</tt>)의 어느 쪽과도 동일하지 않은 문자는 모두, 인용부호로 둘러싸인다. <i></i><i></i><i></i><i></i>  </p></li>

<li><p> 쿼리가 지정되고 있는 경우, 물음표 문자 (<tt>「?」</tt>)이 말미에 추가되어 그 후에 그 쿼리가 추가된다. <a href="#legal-chars">적정한 URI 문자</a>가 아닌 문자는 모두, 인용부호로 둘러싸인다.
   </p></li>

<li><p> 마지막으로, fragment가 지정되고 있는 경우, 해시 문자 (<tt>「#」</tt>)가 말미에 추가되어 그 후에 그 fragment가 추가된다. 적정한 URI 문자가 아닌 문자는 모두, 인용부호로 둘러싸인다.   </p></li>

 </ol>

 <p> 결과적으로 얻을 수 있는 URI 캐릭터 라인이 해석됩니다만, 이 해석은,<A HREF="../../java/net/URI.html#URI(java.lang.String)"><CODE>URI(String)</CODE></A>  생성자 을 호출한 뒤, 그 결과에 대해서 <A HREF="../../java/net/URI.html#parseServerAuthority()"><CODE>parseServerAuthority()</CODE></A>  메소드를 호출했는지와 같이 행해집니다. 이것에 의해,<A HREF="../../java/net/URISyntaxException.html" title="java.net 안의 클래스"><CODE>URISyntaxException</CODE></A>  가 throw 될 가능성이 있습니다.   </p>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>scheme</CODE> - schema명<DD><CODE>authority</CODE> - 기관<DD><CODE>path</CODE> - 패스<DD><CODE>query</CODE> - 쿼리<DD><CODE>fragment</CODE> - fragment
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/URISyntaxException.html" title="java.net 안의 클래스">URISyntaxException</A> </CODE> - schema와 패스의 양쪽 모두가 지정되고 있지만 패스가 상대의 경우, 지정된 컴퍼넌트로부터 구축된 URI 캐릭터 라인이 RFC&nbsp;2396 에 위반하는 경우, 또는 캐릭터 라인의 기관 컴퍼넌트가 존재하지만 서버 베이스의 기관으로서 해석할 수 없는 경우</DL>
</DL>
<HR>

<A NAME="URI(java.lang.String, java.lang.String, java.lang.String, java.lang.String)"><!-- --></A> <H3>
URI</H3>
<PRE>
public <B>URI</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;scheme,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;path,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;fragment)
    throws <A HREF="../../java/net/URISyntaxException.html" title="java.net 내의 클래스">URISyntaxException</A> </PRE>
<DL>
<DD>지정된 컴퍼넌트로부터 계층 URI 를 구축합니다.

 <p> 컴퍼넌트는,<tt>null</tt> 를 건네주어 미정도리대로 되는 일이 있습니다.

 <p> 이 간이 생성자 은, 다음과 같이 7 개의 인수의 생성자 을 호출하는것 같이 동작합니다.

<blockquote><tt>new&nbsp;<A HREF="../../java/net/URI.html#URI(java.lang.String, java.lang.String, java.lang.String, int, java.lang.String, java.lang.String, java.lang.String)"><CODE>URI</CODE></A> (scheme, &nbsp;null, &nbsp;host, &nbsp;-1, &nbsp;path, &nbsp;null, &nbsp;fragment);</tt></blockquote>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>scheme</CODE> - schema명<DD><CODE>host</CODE> - 호스트명<DD><CODE>path</CODE> - 패스<DD><CODE>fragment</CODE> - fragment
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/URISyntaxException.html" title="java.net 안의 클래스">URISyntaxException</A> </CODE> - 지정된 컴퍼넌트로부터 구축된 URI 캐릭터 라인이 RFC&nbsp;2396 에 위반하는 경우</DL>
</DL>
<HR>

<A NAME="URI(java.lang.String, java.lang.String, java.lang.String)"><!-- --></A> <H3>
URI</H3>
<PRE>
public <B>URI</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;scheme,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;ssp,
           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;fragment)
    throws <A HREF="../../java/net/URISyntaxException.html" title="java.net 내의 클래스">URISyntaxException</A> </PRE>
<DL>
<DD>지정된 컴퍼넌트로부터 URI 를 구축합니다.

 <p> 컴퍼넌트는,<tt>null</tt> 를 건네주어 미정도리대로 되는 일이 있습니다.

 <p> 이 생성자 은 우선, 다음과 같이 지정된 컴퍼넌트를 사용해 캐릭터 라인 형식의 URI 를 구축합니다.   </p>

 <ol>

<li><p> 최초, 결과 캐릭터 라인은 비우고 있다.   </p></li>

<li><p> schema가 지정되고 있는 경우, 그 schema가 결과의 말미에 추가되어 그 후에 구두점 문자 (<tt>「:」</tt>)가 추가된다.   </p></li>

<li><p> schema 고유 부분이 지정되고 있는 경우, 그 schema 고유 부분이 말미에 추가된다. <a href="#legal-chars">적정한 URI 문자</a>가 아닌 문자는 모두,<a href="#quote">인용부호</a>로 둘러싸인다.   </p></li>

<li><p> 마지막으로, fragment가 지정되고 있는 경우, 해시 문자 (<tt>「#」</tt>)가 캐릭터 라인의 말미에 추가되어 그 후에 그 fragment가 추가된다. 적정한 URI 문자가 아닌 문자는 모두, 인용부호로 둘러싸인다.   </p></li>

 </ol>

 <p> 새로운 URI 인스턴스를 작성하기 위해서 결과적으로 얻을 수 있는 URI 캐릭터 라인이 해석됩니다만, 이 해석은,<A HREF="../../java/net/URI.html#URI(java.lang.String)"><CODE>URI(String)</CODE></A>  생성자 을 호출했는지와 같이 행해집니다. 이것에 의해,<A HREF="../../java/net/URISyntaxException.html" title="java.net 안의 클래스"><CODE>URISyntaxException</CODE></A>  가 throw 될 가능성이 있습니다.   </p>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>scheme</CODE> - schema명<DD><CODE>ssp</CODE> - schema 고유 부분<DD><CODE>fragment</CODE> - fragment
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/URISyntaxException.html" title="java.net 안의 클래스">URISyntaxException</A> </CODE> - 지정된 컴퍼넌트로부터 구축된 URI 캐릭터 라인이 RFC&nbsp;2396 에 위반하는 경우</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="create(java.lang.String)"><!-- --></A> <H3>
create</H3>
<PRE>
public static <A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A>  <B>create</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)</PRE>
<DL>
<DD>지정된 캐릭터 라인을 해석해 URI 를 작성합니다.

 <p> 이 간이 팩토리 메소드는,<A HREF="../../java/net/URI.html#URI(java.lang.String)"><CODE>URI(String)</CODE></A>  생성자 을 호출했는지와 같이 동작합니다. 이 생성자 으로부터 throw 된 <A HREF="../../java/net/URISyntaxException.html" title="java.net 동안의 클래스"><CODE>URISyntaxException</CODE></A>  는 모두, 캐치 되어 새로운 <A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 동안의 클래스"><CODE>IllegalArgumentException</CODE></A>  객체내에 랩 된 뒤, throw 됩니다.

 <p> 이 메소드는, 프로그램내에서 선언된 URI 정수와 같이, 주어진 캐릭터 라인이 적정한 URI 인 것을 미리 알고 있기 위해서(때문에), 캐릭터 라인이 그처럼 해석되지 않는 경우는 프로그래밍 에러로 간주해지는 것 같은 상황으로 사용하기 위해서 제공되고 있습니다. 사용자 입력이나, 에러가 포함될 가능성의 높은 그 외의 어떠한 소스에 근거해 URI 가 구축되는 것 같은 상황에서는,<A HREF="../../java/net/URISyntaxException.html" title="java.net 안의 클래스"><CODE>URISyntaxException</CODE></A>  를 직접 throw 하는 생성자 을 사용하도록 해 주세요.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - URI 에 해석되는 캐릭터 라인
<DT><B>반환값:</B><DD>새로운 URI
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>str</tt> 가 <tt>null</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 캐릭터 라인이 RFC&nbsp;2396 에 위반하는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="parseServerAuthority()"><!-- --></A> <H3>
parseServerAuthority</H3>
<PRE>
public <A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A>  <B>parseServerAuthority</B>()
                         throws <A HREF="../../java/net/URISyntaxException.html" title="java.net 내의 클래스">URISyntaxException</A> </PRE>
<DL>
<DD>이 URI 의 기관 컴퍼넌트 (정의되고 있는 경우)로부터 사용자 정보, 호스트, 및 포트의 각 컴퍼넌트에의 해석을 시도합니다.

 <p> 이 URI 의 기관 컴퍼넌트가 벌써 서버 베이스로서 인식되고 있는 경우에는, 그것은 벌써 해석되어 사용자 정보, 호스트, 포트의 각 컴퍼넌트 로 분리되고 있습니다. 이 경우, 또는 이 URI 가 기관 컴퍼넌트를 가지지 않는 경우에는, 이 메소드는 이 URI 를 그대로 돌려줍니다.

 <p> 그렇지 않은 경우, 이 메소드는 기관 컴퍼넌트로부터 사용자 정보, 호스트, 및 포트의 각 컴퍼넌트에의 해석을 한번 더 시도해 기관 컴퍼넌트를 그처럼 해석할 수 없었던 이유를 설명하는 예외를 throw 합니다.

 <p> 이 메소드가 제공되고 있는 것은,<a href="http://www.ietf.org/rfc/rfc2396.txt">「RFC&nbsp;2396」</a>  으로 지정되고 있는 총칭 URI 구문이, 부정한 서버 베이스 기관과 적정한 레지스트리 베이스 기관을 항상 구별할 수 있다고는 할 수는 없기 때문입니다. 이 때문에, 그것은, 전자의 케이스의 일부를 후자의 케이스로서 취급하지 않으면 안됩니다. 예를 들어, URI 캐릭터 라인<tt>「//foo:bar」</tt>내의 기관 컴퍼넌트는, 적정한 서버 베이스 기관이 아닙니다만, 레지스트리 베이스 기관으로서는 적정입니다.

 <p> URN, URL 의 어느 쪽인지인 것을 알 수 있고 있는 URI 를 조작하는 경우와 같은, 많은 일반적인 상황에서는, 사용되는 계층 URI 는 항상 서버 베이스가 됩니다. 따라서, 그것들은 그처럼 해석되는지, 에러로서 처리될까의 어느 쪽인지 나오지 않으면 안됩니다. 이러한 경우,

 <blockquote>
<tt>URI </tt><i>u</i><tt> = new URI(str). parseServerAuthority();</tt>
 </blockquote>

 <p> (와)과 같은 문장을 사용하면,<i>u</i> 가 참조하는 URI 에 기관 컴퍼넌트가 포함되는 경우에, 그 기관이 항상 적절한 사용자 정보, 호스트, 포트의 각 컴퍼넌트를 포함한 서버 베이스 기관인 것을 보증할 수 있습니다. 또, 이 메소드를 호출하면, 기관을 그처럼 해석할 수 없었던 경우에도, throw 된 예외에 근거해 적절한 진단 메세지를 확실히 발행할 수 있습니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>기관 필드가 서버 베이스 기관으로서 해석된 URI
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/URISyntaxException.html" title="java.net 안의 클래스">URISyntaxException</A> </CODE> - 이 URI 의 기관 컴퍼넌트가 지정되고 있지만, RFC&nbsp;2396 에 따라 서버 베이스 기관으로서 해석할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="normalize()"><!-- --></A> <H3>
normalize</H3>
<PRE>
public <A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A>  <B>normalize</B>()</PRE>
<DL>
<DD>이 URI 의 패스를 정규화합니다.

 <p> 이 URI 가 불투명한 경우, 또는 그 패스가 벌써 정규화된 형식이 되어 있는 경우는, 이 URI 가 돌려주어집니다. 그렇지 않은 경우는, 이 URI 와 같은 새로운 URI 가 구축됩니다. 다만, 그 패스가<a  href="http://www.ietf.org/rfc/rfc2396.txt">「RFC&nbsp;2396」</a>의 섹션&nbsp;5. 2, 스텝&nbsp;6, 서브 스텝 &nbsp;c 로부터 &nbsp;f 에 준거한 방법으로 이 URI 의 패스를 정규화해 구할 수 있는 경우를 제외합니다. 다음과 같이 됩니다.
 </p>

 <ol>

<li><p> 모든<tt>「.」</tt>세그먼트(segment)가 삭제된다.  </p></li>

<li><p> <tt>「..」</tt>세그먼트(segment)의 직전에<tt>「..」</tt>이외의 세그먼트(segment)가 존재하는 경우, 그 양쪽 모두의 세그먼트(segment)가 삭제된다. 이 순서가 해당하지 않게 될 때까지 반복해진다.  </p></li>

<li><p> 패스가 상대이며, 그 최초의 세그먼트(segment)에 구두점 문자 (<tt>「:」</tt>)가 포함되어 있는 경우, 그 전에<tt>「.」</tt>세그먼트(segment)가 추가된다. 이것에 의해,<tt>「a:b/c/d」</tt>와 같은 패스를 포함한 상대 URI 가, schema<tt>「a」</tt>와 schema 고유 부분<tt>「b/c/d」</tt>를 가지는 불투명 URI 로서 나중에 재차 해석되어 버리는 것을 막을 수가 있다. <b><i>(RFC&nbsp;2396 로부터의 변경)</i></b> </p></li>

 </ol>

 <p> 정규화된 패스는, 삭제를 가능하게 하는<tt>「..」</tt>(이)가 아닌 선행의 세그먼트(segment)가 불충분했던 경우, 1 개(살) 이상의<tt>「..」</tt>세그먼트(segment)로 시작됩니다. 정규화된 패스가<tt>「.」</tt>세그먼트(segment)로 시작되는 것은, 상기의 순서 3 으로 그러한 세그먼트(segment)가 삽입되었을 경우입니다. 그 이외의 경우는, 정규화된 패스에<tt>「.」</tt>세그먼트(segment)나<tt>「..」</tt>세그먼트(segment)가 포함될 것은 없습니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 와 등가인 URI. 다만, 그 패스는 정규화된 형식이 되어 있다</DL>
</DD>
</DL>
<HR>

<A NAME="resolve(java.net.URI)"><!-- --></A> <H3>
resolve</H3>
<PRE>
public <A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A>  <B>resolve</B>(<A HREF="../../java/net/URI.html" title="java.net 안의 클래스">URI</A> &nbsp;uri)</PRE>
<DL>
<DD>지정된 URI 를 이 URI 에 대해서 해결합니다.

 <p> 지정된 URI 가 벌써 절대인 경우, 또는 이 URI 가 불투명한 경우는, 지정된 URI 가 돌려주어집니다.

 <p><a name="resolve-frag"></a>  지정된 URI 의 fragment 컴퍼넌트가 정의가 끝난 상태이며, 패스 컴포넌트가 빈 상태(empty)이며, schema, 기관, 쿼리의 각 컴퍼넌트가 지정되지 않은 경우, 지정된 fragment를 가지지만, 그 이외의 모든 컴퍼넌트는 이 URI 의 값에 동일한 것 같은 URI 가 돌려주어집니다. 이것에 의해,<tt>「#foo」</tt>와 같은 단독의 fragment 참조를 나타내는 URI 를 베이스 URI 에 근거해 해석할 수 있게 되므로 편리합니다.

 <p> 그렇지 않은 경우, 이 메소드는,<a  href="http://www.ietf.org/rfc/rfc2396.txt">「RFC&nbsp;2396」</a>의 섹션&nbsp;5. 2 에 적합하는 방법으로 새로운 계층 URI 를 구축합니다. 다음과 같이 됩니다.  </p>

 <ol>

<li><p> 이 URI 의 schema와 지정된 URI 의 쿼리 및 fragment 컴퍼넌트를 사용해, 새로운 URI 가 구축된다.  </p></li>

<li><p> 지정된 URI 에 기관 컴퍼넌트가 있는 경우, 새로운 URI 의 기관과 패스는 지정된 URI 로부터 놓친다.  </p></li>

<li><p> 그렇지 않은 경우, 새로운 URI 의 기관 컴퍼넌트가 이 URI 로부터 카피되어 그 패스는 다음과 같이 해 구할 수 있다.  </p></li>

   <ol type=a>

<li><p> 지정된 URI 의 패스가 절대의 경우, 새로운 URI 의 패스는 지정된 URI 로부터 놓친다.  </p></li>

<li><p> 그 이외의 경우, 지정된 URI 의 패스는 상대이므로, 이 URI 의 패스에 근거해 지정된 URI 의 패스를 해결하는 것으로, 새로운 URI 의 패스가 계산된다. 이것을 실시하려면 , 이 URI 의 패스 (존재하는 경우)의 마지막 세그먼트(segment) 이외의 모든 세그먼트(segment)가 지정된 URI 의 패스에 연결한 뒤, 그 결과를 <A HREF="../../java/net/URI.html#normalize()"><CODE>normalize</CODE></A>  메소드를 호출했는지와 같이 정규화한다.  </p></li>

   </ol>

 </ol>

 <p> 이 메소드의 결과는, 이 URI 가 절대의 경우, 또는 지정된 URI 가 절대의 경우에만, 절대로 됩니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>uri</CODE> - 이 URI 에 대해서 해결되는 URI
<DT><B>반환값:</B><DD>결과적으로 얻을 수 있는 URI
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>uri</tt> 가 <tt>null</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="resolve(java.lang.String)"><!-- --></A> <H3>
resolve</H3>
<PRE>
public <A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A>  <B>resolve</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)</PRE>
<DL>
<DD>지정된 캐릭터 라인을 해석해, 그 후 그 캐릭터 라인을 이 URI 에 대해서 해결해, 새로운 URI 를 구축합니다.

 <p> 이 편리한 메소드는, 이 메소드의 호출이 식 <tt><A HREF="../../java/net/URI.html#resolve(java.net.URI)"><CODE>resolve</CODE></A> (URI. <A HREF="../../java/net/URI.html#create(java.lang.String)"><CODE>create</CODE></A> (str))</tt> 의 평가와 같은가와 같이 동작합니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - URI 에 해석되는 캐릭터 라인
<DT><B>반환값:</B><DD>결과적으로 얻을 수 있는 URI
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>str</tt> 가 <tt>null</tt> 의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 캐릭터 라인이 RFC&nbsp;2396 에 위반하는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="relativize(java.net.URI)"><!-- --></A> <H3>
relativize</H3>
<PRE>
public <A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A>  <B>relativize</B>(<A HREF="../../java/net/URI.html" title="java.net 안의 클래스">URI</A> &nbsp;uri)</PRE>
<DL>
<DD>지정된 URI 를 이 URI 에 대해서 상대화합니다.

 <p> 지정된 URI 의 이 URI 에 대한 상대화는, 다음과 같이 해 구할 수 있습니다.  </p>

 <ol>

<li><p> 이 URI 또는 지정된 URI 가 불투명한 경우, 2 개의 URI 의 schema와 기관 컴퍼넌트가 같지 않은 경우, 또는 이 URI 의 패스가 지정된 URI 의 패스의 접두사가 아닌 경우는, 지정된 URI 가 반환된다.  </p></li>

<li><p> 그렇지 않은 경우, 지정된 URI 로부터 놓친 쿼리 및 fragment 컴퍼넌트와 지정된 URI 의 패스의 선두로부터 이 URI 의 패스를 삭제해 요구한 패스 컴포넌트를 사용해, 새로운 상대 계층 URI 가 구축된다.  </p></li>

 </ol>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>uri</CODE> - 이 URI 에 대해서 상대화되는 URI
<DT><B>반환값:</B><DD>결과적으로 얻을 수 있는 URI
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>uri</tt> 가 <tt>null</tt> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="toURL()"><!-- --></A> <H3>
toURL</H3>
<PRE>
public <A HREF="../../java/net/URL.html" title="java.net 내의 클래스">URL</A>  <B>toURL</B>()
          throws <A HREF="../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A> </PRE>
<DL>
<DD>이 URI 로부터 URL 를 구축합니다.

 <p> 이 편리한 메소드는, 최초로 이 URI 가 절대인 것을 확인하고 나서, 이 메소드의 호출이 식 <tt>new&nbsp;URL(this.toString())</tt> 의 평가와 같은가와 같이 동작합니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 로부터 구축된 URL
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 URL 가 절대가 아닌 경우
<DD><CODE><A HREF="../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - URL 의 프로토콜 핸들러가 발견되지 않았던 경우, 또는 URL 의 구축중에 그 외의 어떠한 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getScheme()"><!-- --></A> <H3>
getScheme</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getScheme</B>()</PRE>
<DL>
<DD>이 URI 의 schema 컴퍼넌트를 돌려줍니다.

 <p> URI 의 schema 컴퍼넌트가 정의되고 있는 경우, 그 컴퍼넌트에 포함되는 것은, 「영숫자」카테고리 또는 캐릭터 라인<tt>「-. +」</tt>에 포함되는 문자만입니다. <i></i>schema는 항상, 「영문자」문자로 시작됩니다. <i></i> <p>

URI 의 schema 컴퍼넌트에 이스케이프 된 8중창을 포함할 수 없습니다. 따라서, 이 메소드는 디코드를 실행하지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 schema 컴퍼넌트. schema가 미정도리의 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="isAbsolute()"><!-- --></A> <H3>
isAbsolute</H3>
<PRE>
public boolean <B>isAbsolute</B>()</PRE>
<DL>
<DD>이 URI 가 절대인가 어떤가를 통지합니다.

 <p> URI 가 절대인 것은, 그 URI 에 schema 컴퍼넌트가 있는 경우만입니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 가 절대인 경우만 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="isOpaque()"><!-- --></A> <H3>
isOpaque</H3>
<PRE>
public boolean <B>isOpaque</B>()</PRE>
<DL>
<DD>이 URI 가 불투명한가 어떤가를 통지합니다.

 <p> URI 가 불투명해요는, 그 URI 가 절대이며, 그 schema 고유 부분이 slash 문자 ( 「/」)로 시작되지 않은 경우 뿐입니다. 불투명 URI 는, schema와 schema 고유 부분을 가지는 것 외에 경우에 따라서는 fragment도 가집니다. 그 외의 컴퍼넌트는 모두 미정도리가 됩니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 가 불투명의 경우만 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getRawSchemeSpecificPart()"><!-- --></A> <H3>
getRawSchemeSpecificPart</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getRawSchemeSpecificPart</B>()</PRE>
<DL>
<DD>이 URI 의 그대로의 schema 고유 부분을 돌려줍니다. schema 고유 부분은, 미정도리가 될 것은 없습니다만, 비우는 것은 있습니다.

 <p> URI 의 schema 고유 부분에는, 유효한 URI 문자만이 포함됩니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 그대로의 schema 고유 부분 (결코 <tt>null</tt> 는 아니다)</DL>
</DD>
</DL>
<HR>

<A NAME="getSchemeSpecificPart()"><!-- --></A> <H3>
getSchemeSpecificPart</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getSchemeSpecificPart</B>()</PRE>
<DL>
<DD>이 URI 의 복호화 된 schema 고유 부분을 돌려줍니다.

 <p> 이 메소드로부터 반환되는 캐릭터 라인은,<A HREF="../../java/net/URI.html#getRawSchemeSpecificPart()"><CODE>getRawSchemeSpecificPart</CODE></A>  메소드로부터 반환되는 캐릭터 라인과 거의 같습니다. 다른 것은, 이스케이프 된 8중창의 순서가 모두<a  href="#decode">디코드</a>되고 있는 점만입니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 디코드된 schema 고유 부분 (결코 <tt>null</tt> 는 아니다)</DL>
</DD>
</DL>
<HR>

<A NAME="getRawAuthority()"><!-- --></A> <H3>
getRawAuthority</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getRawAuthority</B>()</PRE>
<DL>
<DD>이 URI 의 그대로의 기관 컴퍼넌트를 돌려줍니다.

 <p> URI 의 기관 컴퍼넌트가 정의되고 있는 경우, 그 컴퍼넌트에 포함되는 것은, 단가 기호 (<tt>「@」</tt>)와 「미예약」, 「구두점」, 「이스케이프」, 「그 외」의 몇개의 카테고리에 포함되는 문자만입니다. <i></i><i></i><i></i><i></i>기관이 서버 베이스인 경우, 그 기관은 게다가 유효한 사용자 정보, 호스트, 포트의 각 컴퍼넌트를 가지도록(듯이) 제약됩니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 그대로의 기관 컴퍼넌트. 기관이 미정도리의 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getAuthority()"><!-- --></A> <H3>
getAuthority</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getAuthority</B>()</PRE>
<DL>
<DD>이 URI 의 복호화 된 기관 컴퍼넌트를 돌려줍니다.

 <p> 이 메소드로부터 반환되는 캐릭터 라인은,<A HREF="../../java/net/URI.html#getRawAuthority()"><CODE>getRawAuthority</CODE></A>  메소드로부터 반환되는 캐릭터 라인과 거의 같습니다. 다른 것은, 이스케이프 된 8중창의 순서가 모두<a href="#decode">디코드</a>되고 있는 점만입니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 디코드된 기관 컴퍼넌트. 기관이 미정도리의 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getRawUserInfo()"><!-- --></A> <H3>
getRawUserInfo</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getRawUserInfo</B>()</PRE>
<DL>
<DD>이 URI 의 그대로의 사용자 정보 컴퍼넌트를 돌려줍니다.

 <p> URI 의 사용자 정보 컴퍼넌트에는 (정의되고 있는 경우), 「미예약」, 「구두점」, 「이스케이프」, 및 「그 외」의 카테고리의 문자만이 포함됩니다. <i></i><i></i><i></i><i></i> </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 그대로의 사용자 정보 컴퍼넌트. 사용자 정보가 미정도리의 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getUserInfo()"><!-- --></A> <H3>
getUserInfo</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getUserInfo</B>()</PRE>
<DL>
<DD>이 URI 의 복호화 된 사용자 정보 컴퍼넌트를 돌려줍니다.

 <p> 이 메소드로부터 반환되는 캐릭터 라인은,<A HREF="../../java/net/URI.html#getRawUserInfo()"><CODE>getRawUserInfo</CODE></A>  메소드로부터 반환되는 캐릭터 라인과 거의 같습니다. 다른 것은, 이스케이프 된 8중창의 순서가 모두<a href="#decode">디코드</a>되고 있는 점만입니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 디코드된 사용자 정보 컴퍼넌트. 사용자 정보가 미정도리의 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getHost()"><!-- --></A> <H3>
getHost</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getHost</B>()</PRE>
<DL>
<DD>이 URI 의 호스트 컴퍼넌트를 돌려줍니다.

 <p> URI 의 호스트 컴퍼넌트 (정의되고 있는 경우)의 형식은, 다음의 머지않아인가입니다.  </p>

 <ul type=disc>

<li><p> 도메인명. 1 개(살) 이상의 「라벨」을 피리어드 문자 (<tt>「.」</tt>)로 단락지은 형식이 됩니다. 말미에 피리어드 문자를 1 개 붙여도 괜찮습니다. <i></i>각 라벨은 「영숫자」문자와 하이픈 문자 (<tt>「-」</tt>)로부터 구성됩니다. 다만, 하이픈이 라벨내의 선두 또는 말미의 문자로서 사용될 것은 없습니다. <i></i>2 개(살) 이상의 라벨로 구성되는 도메인명의 가장 우측의 라벨은, 「영문자」문자로 시작됩니다. <i></i> </li>

<li><p> 숫자<tt>+. </tt>숫자<tt>+. </tt>숫자<tt>+. </tt>숫자<tt>+</tt> 의 형식의, 닷으로 4 개로 구분된 IPv4 주소. 여기서, 숫자는 3 문자 이내에서, 그 값은 255 를 넘지 않습니다. </p></li>

<li><p> IPv6 주소. 꺽쇄묶음 (<tt>「[」</tt>과<tt>「]」</tt>)으로 둘러싸여 16 진수, 구두점 문자 (<tt>「:」</tt>), 및 경우에 따라서는 묻어 IPv4 주소로 구성됩니다. IPv6 주소의 완전한 구문은,<a    href="http://www.ietf.org/rfc/rfc2373.txt">「RFC&nbsp;2373: IPv6 Addressing Architecture」</a>로 지정되고 있습니다.   </p></li>

 </ul>

URI 의 호스트 컴퍼넌트에 이스케이프 된 8중창을 포함할 수 없습니다. 따라서, 이 메소드는 디코드를 실행하지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 호스트 컴퍼넌트. 호스트가 미정도리의 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getPort()"><!-- --></A> <H3>
getPort</H3>
<PRE>
public int <B>getPort</B>()</PRE>
<DL>
<DD>이 URI 의 포트 번호를 돌려줍니다.

 <p> URI 의 포트 컴퍼넌트는 (정의되고 있는 경우), 부가 아닌 정수입니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 포트 컴퍼넌트. 포트가 미정도리의 경우는 <tt>-1</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getRawPath()"><!-- --></A> <H3>
getRawPath</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getRawPath</B>()</PRE>
<DL>
<DD>이 URI 의 그대로의 패스 컴포넌트를 돌려줍니다.

 <p> URI 의 패스 컴포넌트에는 (정의되고 있는 경우), slash (<tt>/</tt>), 단가 기호 (<tt>@</tt>)와 「미예약」, 「구두점」, 「이스케이프」, 및 「그 외」의 카테고리의 문자만이 포함됩니다. <i></i><i></i><i></i><i></i> </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 패스 컴포넌트. 패스가 미정도리의 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getPath()"><!-- --></A> <H3>
getPath</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getPath</B>()</PRE>
<DL>
<DD>이 URI 의 복호화 된 패스 컴포넌트를 돌려줍니다.

 <p> 이 메소드로부터 반환되는 캐릭터 라인은,<A HREF="../../java/net/URI.html#getRawPath()"><CODE>getRawPath</CODE></A>  메소드로부터 반환되는 캐릭터 라인과 거의 같습니다. 다른 것은, 이스케이프 된 8중창의 순서가 모두<a href="#decode">디코드</a>되고 있는 점만입니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 디코드된 패스 컴포넌트. 패스가 미정도리의 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getRawQuery()"><!-- --></A> <H3>
getRawQuery</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getRawQuery</B>()</PRE>
<DL>
<DD>이 URI 의 그대로의 쿼리컴퍼넌트를 돌려줍니다.

 <p> URI 의 쿼리컴퍼넌트에는 (정의되고 있는 경우), 유효한 URI 문자만이 포함됩니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 그대로의 쿼리컴퍼넌트. 쿼리가 미정도리의 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getQuery()"><!-- --></A> <H3>
getQuery</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getQuery</B>()</PRE>
<DL>
<DD>이 URI 의 복호화 된 쿼리컴퍼넌트를 돌려줍니다.

 <p> 이 메소드로부터 반환되는 캐릭터 라인은,<A HREF="../../java/net/URI.html#getRawQuery()"><CODE>getRawQuery</CODE></A>  메소드로부터 반환되는 캐릭터 라인과 거의 같습니다. 다른 것은, 이스케이프 된 8중창의 순서가 모두<a href="#decode">디코드</a>되고 있는 점만입니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 디코드된 쿼리컴퍼넌트. 쿼리가 미정도리의 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getRawFragment()"><!-- --></A> <H3>
getRawFragment</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getRawFragment</B>()</PRE>
<DL>
<DD>이 URI 의 그대로의 fragment 컴퍼넌트를 돌려줍니다.

 <p> URI 의 fragment 컴퍼넌트에는 (정의되고 있는 경우), 유효한 URI 문자만이 포함됩니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 그대로의 fragment 컴퍼넌트. fragment가 미정도리의 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getFragment()"><!-- --></A> <H3>
getFragment</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getFragment</B>()</PRE>
<DL>
<DD>이 URI 의 복호화 된 fragment 컴퍼넌트를 돌려줍니다.

 <p> 이 메소드로부터 반환되는 캐릭터 라인은,<A HREF="../../java/net/URI.html#getRawFragment()"><CODE>getRawFragment</CODE></A>  메소드로부터 반환되는 캐릭터 라인과 거의 같습니다. 다른 것은, 이스케이프 된 8중창의 순서가 모두<a href="#decode">디코드</a>되고 있는 점만입니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 디코드된 fragment 컴퍼넌트. fragment가 미정도리의 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;ob)</PRE>
<DL>
<DD>이 URI 가 다른 객체와 동일한지 어떤지를 판정합니다.

 <p> 지정된 객체가 URI 가 아닌 경우, 이 메소드는 즉시 <tt>false</tt> 를 돌려줍니다.

 <p> 2 개의 URI 가 동일하다고 보이려면 , 어느쪽이나 불투명 URI 인지, 어느쪽이나 계층 URI 일 필요가 있습니다. schema는, 어느쪽이나 지정되지 않은지, 대문자와 소문자를 구별하지 않는 경우에 동일하지 않으면 안됩니다. fragment는, 어느쪽이나 지정되지 않은지, 동일하지 않으면 안됩니다.

 <p> 동일하다고 보여지는 2 개의 불투명 URI 의 경우, 그러한 schema 고유 부분은 동일할 필요가 있습니다.

 <p> 2 개의 계층 URI 가 동일하다고 보이려면 , 패스가 동일하고, 쿼리가 어느쪽이나 미정도리일까 동일하지 않으면 안됩니다. 기관은, 어느쪽이나 지정되지 않은지, 어느쪽이나 레지스트리 베이스인지, 어느쪽이나 서버 베이스가 아니면 안됩니다. 기관이 정의되고 있어 레지스트리 베이스인 경우, 그러한 기관은 동일하지 않으면 안됩니다. 기관이 정의되고 있어 서버 베이스인 경우, 대문자와 소문자를 구별하지 않는 경우에 호스트가 동일하고, 포트 번호가 동일하고, 사용자 정보 컴퍼넌트가 동일하지 않으면 안됩니다.

 <p> 2 개의 URI 의 사용자 정보, 패스, 쿼리, fragment, 기관, 또는 schema 고유 부분이 동일한지 어떤지 판정하는 경우, 이러한 컴퍼넌트는 encode 된 형식이 아니고 그대로의 형식에서 비교되어 이스케이프 된 8중창의 16 진수는 대문자 소문자에 관계없이 비교됩니다.

 <p> 이 메소드는 <A HREF="../../java/lang/Object.html#equals(java.lang.Object)"><CODE>Object.equals</CODE></A>  메소드의 범용 규약을 채웁니다.  </p>
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ob</CODE> - 이 객체와 비교하는 객체
<DT><B>반환값:</B><DD>지정된 객체가 이 URI 와 같은 URI 인 경우만 <tt>true</tt><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A> , 
<A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>이 URI 의 해시 코드값를 돌려줍니다. 이 해시 코드는, URI 의 모든 컴퍼넌트에 근거해,<A HREF="../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode</CODE></A>  메소드의 범용 규약을 채웁니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 해시 코드값<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#equals(java.lang.Object)"><CODE>Object.equals(java.lang.Object)</CODE></A> , 
<A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="compareTo(java.net.URI)"><!-- --></A> <H3>
compareTo</H3>
<PRE>
public int <B>compareTo</B>(<A HREF="../../java/net/URI.html" title="java.net 안의 클래스">URI</A> &nbsp;that)</PRE>
<DL>
<DD>이 URI 를 다른 객체와 비교합니다. 그 객체는 URI 가 아니면 안됩니다.

 <p> 2 개의 URI 의 대응하는 컴퍼넌트를 비교할 때에, 한편의 컴퍼넌트가 지정되지 않은데 한편이 정의가 끝난 상태였을 경우, 전자 쪽이 후자보다 작다고 보입니다. 특히 명기되어 있지 않은 한, 캐릭터 라인 컴퍼넌트는,<A HREF="../../java/lang/Comparable.html#compareTo(T)"><CODE>String.compareTo</CODE></A>  메소드로 정의되고 있도록(듯이), 본래의 대문자 소문자를 구별한 순서에 따라 순서 붙일 수 있습니다. encode의 대상이 되는 캐릭터 라인 컴퍼넌트의 비교는, encode 된 형식은 아니고 그대로의 형식에서 비교됩니다.

 <p> URI 의 순서는 다음과 같이 정의됩니다.  </p>

 <ul type=disc>

<li><p> 다른 schema를 가지는 2 개의 URI 는, 대문자 소문자에 관계없이 그러한 schema의 순서에 따라 순서 붙일 수 있다.  </p></li>

<li><p> 계층 URI 는, 같은 schema를 가지는 불투명 URI 보다 작다고 보여진다.  </p></li>

<li><p> 같은 schema를 가지는 2 개의 불투명 URI 는, 그러한 schema 고유 부분의 순서에 따라 순서 붙일 수 있다.  </p></li>

<li><p> 같은 schema와 schema 고유 부분을 가지는 2 개의 불투명 URI 는, 그러한 fragment의 순서에 따라 순서 붙일 수 있다.  </p></li>

<li><p> 같은 schema를 가지는 2 개의 계층 URI 는, 그러한 기관 컴퍼넌트의 순서에 따라 순서 붙일 수 있다.  </p></li>

   <ul type=disc>

<li><p> 양쪽 모두의 기관 컴퍼넌트가 서버 베이스인 경우, URI 는 그러한 사용자 정보 컴퍼넌트에 따라 순서 붙일 수 있다. 이러한 컴퍼넌트가 같은 경우, URI 는 대문자 소문자에 관계없이 그러한 호스트의 순서에 따라 순서 붙일 수 있다. 호스트가 같은 경우, URI 는 그러한 포트의 순서에 따라 순서 붙일 수 있다.  </p></li>

<li><p> 한편 또는 양쪽 모두의 기관 컴퍼넌트가 레지스트리 베이스인 경우, URI 는 그러한 기관 컴퍼넌트의 순서에 따라 순서 붙일 수 있다.  </p></li>

   </ul>

<li><p> 마지막으로, 같은 schema와 기관 컴퍼넌트를 가지는 2 개의 계층 URI 는, 그러한 패스의 순서에 따라 순서 붙일 수 있다. 패스가 같은 경우, 빈 상태(empty)등의 계층 URI 는, 그러한 쿼리의 순서에 따라 순서 붙일 수 있다. 쿼리가 같은 경우는, 그러한 fragment의 순서에 따라 순서 붙일 수 있다.  </p></li>

 </ul>

 <p> 이 메소드는 <A HREF="../../java/lang/Comparable.html#compareTo(T)"><CODE>Comparable.compareTo</CODE></A>  메소드의 범용 규약을 채웁니다.  </p>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스">Comparable</A> &lt;<A HREF="../../java/net/URI.html" title="java.net 내의 클래스">URI</A> &gt;</CODE> 내의 <CODE><A HREF="../../java/lang/Comparable.html#compareTo(T)">compareTo</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>that</CODE> - 이 URI 와 비교하는 객체
<DT><B>반환값:</B><DD>이 URI 가 지정된 URI 보다 작은 경우는 부의 정수, 동일한 경우는 0, 큰 경우는 정의 정수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 지정된 객체가 URI 가 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 URI 의 컨텐츠를 캐릭터 라인으로서 돌려줍니다.

 <p> 이 URI 가 이 클래스의 몇개의 생성자 을 호출하는 것으로 작성된 것인 경우, 원의 입력 캐릭터 라인과 등가인 캐릭터 라인, 또는 최초로 지정된 컴퍼넌트로부터 적당 계산된 캐릭터 라인과 등가인 캐릭터 라인이 돌려주어집니다. 그 이외의 경우, 이 URI 는 정규화, 해결, 또는 상대화에 의해 작성된 것이므로,<a  href="http://www.ietf.org/rfc/rfc2396.txt">「RFC&nbsp;2396」</a>의 섹션&nbsp;5. 2, 스텝 &nbsp;7 의 규칙에 따라, 이 URI 의 컴퍼넌트로부터 캐릭터 라인이 구축됩니다. </p>
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 캐릭터 라인 형식</DL>
</DD>
</DL>
<HR>

<A NAME="toASCIIString()"><!-- --></A> <H3>
toASCIIString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toASCIIString</B>()</PRE>
<DL>
<DD>이 URI 의 컨텐츠를 US-ASCII 캐릭터 라인으로서 돌려줍니다.

 <p> 이 URI 에 「그 외」카테고리의 문자가 1 개도 포함되지 않은 경우, 이 메소드를 호출하면(자),<A HREF="../../java/net/URI.html#toString()"><CODE>toString</CODE></A>  메소드 호출시와 같은 값이 돌려주어집니다. <i></i>그 이외의 경우, 그 메소드의 호출 후에 결과를<a  href="#encode">encode </a>했는지와 같이, 이 메소드는 동작합니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 URI 의 캐릭터 라인 형식. US-ASCII 캐릭터 세트의 문자만이 포함되도록, 필요에 따라서 encode 된다</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/URI.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/net/UnknownServiceException.html" title="java.net 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/net/URISyntaxException.html" title="java.net 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/net/URI.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="URI.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
