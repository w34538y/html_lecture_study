<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:57:06 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Throwable (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Throwable (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Throwable.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/ThreadLocal.html" title="java.lang 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/TypeNotPresentException.html" title="java.lang 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Throwable.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Throwable.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang</FONT>
<BR>
클래스 Throwable</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.lang.Throwable</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DD>
</DL>
<DL>
<DT><B>직계의 기존의 서브 클래스:</B> <DD><A HREF="../../java/lang/Error.html" title="java.lang 내의 클래스">Error</A> , <A HREF="../../java/lang/Exception.html" title="java.lang 안의 클래스">Exception</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>Throwable</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
<code>Throwable</code> 클래스는, Java 언어의 모든 에러와 예외의 슈퍼 클래스입니다. 이 클래스 (또는 그 서브 클래스 중의 1 개)의 인스턴스인 객체만이 Java 가상 머신에 의해 throw 되는지, Java 의 <code>throw</code> 구문에 의해 throw 됩니다. 똑같이, 이 클래스 또는 그 서브 클래스 중의 1 개(살)만이 <code>catch</code> 절의 인수의 형태로 지정할 수 있습니다.

 <p>일반적으로,<A HREF="../../java/lang/Error.html" title="java.lang 안의 클래스"><CODE>Error</CODE></A>  및 <A HREF="../../java/lang/Exception.html" title="java.lang 안의 클래스"><CODE>Exception</CODE></A>  의 2 개의 서브 클래스의 인스턴스는 예외적인 상황이 발생한 것을 나타내기 위해서(때문에) 사용됩니다. 이러한 인스턴스는, 일반적으로, 관련하는 정보 (스택 트레이스 데이터등)를 포함하기 위해서, 예외적인 상황에 따라 새롭게 작성됩니다.

 <p>throw 가능 객체에는, 작성시의 그 thread의 실행 스택의 snapshot가 포함됩니다. 이 클래스에는, 에러에 대한 상세한 정보를 나타내는 메세지 캐릭터 라인도 포함됩니다. 최종적으로, 이것은 「원인」 (이 throw 가능 객체의 throw를 일으킨 다른 throw 가능 객체)을 포함할 수가 있습니다. 원인 기능은, 릴리스 1.4 의 신기능입니다. 이것은, 원인 자체가 원인을 보관 유지해 예외의 연쇄를 작성할 수 있기 (위해)때문에, 「체인 된 예외」기능이라고도 불립니다.

 <p>throw 가능 객체가 원인을 보관 유지할 수 있는 1 개의 이유로서 throw 가능 객체를 throw 하는 클래스가 하위 층 추상화 위에 구축되고 있는 것이 들고 있습니다.  이 때문에, 상위 층에 대한 조작이 실패하는 것은, 하위 층에서의 조작이 실패하기 (위해)때문에입니다. 하위 층에 의해 throw 되는 throw 가능 객체를 외부에 송신하는 것은, 올바르지 않은 설계 방법입니다.  이것은, 일반적으로, 상위 층에 의해 제공되는 추상화 기능과는 관계가 없기 때문입니다. 게다가 이러한 조작을 실시하면, 상위 층의 API 를 구현의 상세하게 연결시켜 버리기 (위해)때문에, 하위 층의 예외가 체크 예외라고 보여져 버립니다. 「랩 된 예외」 (원인을 포함한 예외)을 throw 하면(자), 이러한 결점에 접하지 않고 상위 층이 장해의 상세를 호출해 측에 통신할 수 있게 됩니다. 이 때문에, 상위 층의 구현 (특히 메소드에 의해 throw 되는 예외세트)을 API 를 변경하지 않고 유연하게 변경할 수 있습니다.

 <p>throw 가능 객체가 원인을 보관 유지하는 2 번째의 이유는, throw 가능 객체를 throw 하는 메소드가, 원인을 직접 throw 하는 것을 메소드에 허가하지 않는 범용 인터페이스에 준거할 필요가 있는 것입니다. 예를 들어, 지속 컬렉션이 <A HREF="../../java/util/Collection.html" title="java.util 안의 인터페이스"><CODE>Collection</CODE></A>  인터페이스에 준거해, 그 지속성이 <tt>java.io</tt> 의 상위에 구현되는 경우를 생각합시다. <tt>add</tt> 메소드의 내부는,<A HREF="../../java/io/IOException.html" title="java.io 안의 클래스"><CODE>IOException</CODE></A>  를 throw 가능하다라고 합니다. 이 경우, 적절한 체크되지 않는 예외의 <tt>IOException</tt> 를 랩 하는 것으로써, 구현은 <tt>Collection</tt> 인터페이스에 준거하면서,<tt>IOException</tt> 의 상세를 호출해 측에 통지할 수 있습니다. 지속 컬렉션의 스펙에, 이런 종류의 예외를 throw 가능하다라고 하는 것이 나타나고 있을 필요가 있습니다.

 <p>원인은, 2 개의 방법으로 throw 가능 객체에 관련지을 수가 있습니다. 1 개(살)은 원인을 인수로서 취하는 생성자 을 사용하는 방법, 이제(벌써) 1 개(살)은 <A HREF="../../java/lang/Throwable.html#initCause(java.lang.Throwable)"><CODE>initCause(Throwable)</CODE></A>  메소드를 사용하는 방법입니다. 원인이 관련짓고를 가능하게 하는 신규 throw 가능 클래스는, 원인을 받는 생성자 을 제공해, 원인을 받는 몇개의 <tt>Throwable</tt> 생성자 에 (일반적으로 간접적으로) 위양 할 필요가 있습니다. 다음에 예를 나타냅니다.
 <pre>
try {
lowLevelOp();
} catch (LowLevelException le) {
throw new HighLevelException(le);  // Chaining-aware constructor
     }
 </pre>
<tt>initCause</tt> 메소드는 public 이기 (위해)때문에, 원인을 임의의 throw 가능 객체에 관련짓는 것이 가능합니다.  이것은, 구현이 예외 체인 기구의 <tt>Throwable</tt> 에의 추가에 선행하는 「유산 throw 가능 객체」여도 들어맞읍니다. 다음에 예를 나타냅니다.
 <pre>
try {
lowLevelOp();
} catch (LowLevelException le) {
throw (HighLevelException)
new HighLevelException(). initCause(le);  // Legacy constructor
     }
 </pre>

 <p>릴리스 1.4 이전에는, 비표준의 독자 예외 체인 기구 (<A HREF="../../java/lang/ExceptionInInitializerError.html" title="java.lang 안의 클래스"><CODE>ExceptionInInitializerError</CODE></A> ,<A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스"><CODE>ClassNotFoundException</CODE></A> ,<A HREF="../../java/lang/reflect/UndeclaredThrowableException.html" title="java.lang.reflect 안의 클래스"><CODE>UndeclaredThrowableException</CODE></A> ,<A HREF="../../java/lang/reflect/InvocationTargetException.html" title="java.lang.reflect 안의 클래스"><CODE>InvocationTargetException</CODE></A> ,<A HREF="../../java/io/WriteAbortedException.html" title="java.io 안의 클래스"><CODE>WriteAbortedException</CODE></A> ,<A HREF="../../java/security/PrivilegedActionException.html" title="java.security 안의 클래스"><CODE>PrivilegedActionException</CODE></A> ,<A HREF="../../java/awt/print/PrinterIOException.html" title="java.awt.print 안의 클래스"><CODE>PrinterIOException</CODE></A> ,<A HREF="../../java/rmi/RemoteException.html" title="java.rmi 안의 클래스"><CODE>RemoteException</CODE></A> , 및 <A HREF="../../javax/naming/NamingException.html" title="javax.naming 안의 클래스"><CODE>NamingException</CODE></A> )를 보관 유지하는 다수의 throw 가능 객체가 존재하고 있었습니다. 릴리스 1.4 에서는, 이러한 throw 가능 객체는 모두, 호환성을 위해서(때문에) 「종래의」연쇄 기구의 구현을 유지하면서, 표준의 예외 연쇄 기구를 사용할 수 있도록(듯이) 개량되고 있습니다.

 <p>게다가 릴리스 1.4 에서는, 다수의 범용 <tt>Throwable</tt> 클래스 (<A HREF="../../java/lang/Exception.html" title="java.lang 안의 클래스"><CODE>Exception</CODE></A> ,<A HREF="../../java/lang/RuntimeException.html" title="java.lang 안의 클래스"><CODE>RuntimeException</CODE></A> ,<A HREF="../../java/lang/Error.html" title="java.lang 안의 클래스"><CODE>Error</CODE></A>  등)가, 원인을 취하는 생성자 에 맞추어 개량되고 있습니다. <tt>initCause</tt> 메소드가 벌써 존재하고 있기 (위해)때문에, 이것은 엄밀하게는 필수라고 하는 것은 아닙니다만, 원인을 취하는 생성자 에의 위양을 실시하는 것보다 간편하고 표현력이 있는 방법입니다.

 <p>종래,<code>Throwable</code> 클래스 및 그 서브 클래스는 2 개의 생성자 을 보관 유지합니다.  1 개(살)은 인수를 취하지 않고, 이제(벌써) 1 개(살)은 상세 메세지의 생성에 사용 가능한 <code>String</code> 인수를 취합니다. 또, 관련지을 수 있었던 원인을 보관 유지 가능한 이러한 서브 클래스는, 게다가 2 개의 생성자 을 보관 유지합니다.  1 개(살)은 <code>Throwable</code> (원인)를 취해, 이제(벌써) 1 개(살)은 <code>String</code> (상세 메세지) 및 <code>Throwable</code> (원인)를 취합니다.

 <p>또, 릴리스 1.4 에서는,<A HREF="../../java/lang/Throwable.html#getStackTrace()"><CODE>getStackTrace()</CODE></A>  메소드도 도입되었습니다.  이 메소드를 사용하면(자), 지금까지 <A HREF="../../java/lang/Throwable.html#printStackTrace()"><CODE>printStackTrace()</CODE></A>  메소드를 사용해 텍스트 형식에서 밖에 이용할 수 없었던 스택 트레이스 정보에, 프로그램화 된 액세스를 실행할 수 있습니다. 이 정보가 이 클래스의 「직렬화 표현」에 추가되었기 때문에,<tt>getStackTrace</tt> 및 <tt>printStackTrace</tt> 가 직렬화 복원에 의해 취득된 throw 가능 객체에 대해서 적정하게 기능합니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../serialized-form.html#java.lang.Throwable">직렬화 된 형식</A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#Throwable()">Throwable</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;상세 메세지에 <code>null</code> 를 사용해, 신규 throw 가능 객체를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#Throwable(java.lang.String)">Throwable</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;message)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 상세 메세지를 사용해, 신규 throw 가능 객체를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#Throwable(java.lang.String, java.lang.Throwable)">Throwable</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;message,
          <A HREF="../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;cause)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 상세 메세지 및 원인을 사용해 신규 throw 가능 객체를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#Throwable(java.lang.Throwable)">Throwable</A> </B>(<A HREF="../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;cause)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 원인과 상세 메세지 <tt>(cause==null ?  null : cause.toString())</tt> 를 가지는, 새로운 throw 가능 객체를 구축합니다 (일반적으로, 클래스와<tt>원인</tt>의 상세 메세지를 포함합니다). </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Throwable.html" title="java.lang 내의 클래스">Throwable</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#fillInStackTrace()">fillInStackTrace</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;실행 스택 트레이스를 묻습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Throwable.html" title="java.lang 내의 클래스">Throwable</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#getCause()">getCause</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;원인이 존재하지 않는가 불명한 경우에, 이 Throwable 또는 <code>null</code> 의 원인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#getLocalizedMessage()">getLocalizedMessage</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 throw 가능 객체의, 로컬라이즈 된 기술을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#getMessage()">getMessage</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 Throwable 객체의 상세 메세지 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/StackTraceElement.html" title="java.lang 내의 클래스">StackTraceElement</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#getStackTrace()">getStackTrace</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../java/lang/Throwable.html#printStackTrace()"><CODE>printStackTrace()</CODE></A>  에 의해 제공되는 스택 트레이스 정보에 프로그램으로 액세스 할 수 있도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Throwable.html" title="java.lang 내의 클래스">Throwable</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#initCause(java.lang.Throwable)">initCause</A> </B>(<A HREF="../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;cause)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 값에 대한 이 Throwable 의 「원인」을 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#printStackTrace()">printStackTrace</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 throw 가능 객체 및 그 백 트레이스를 표준 에러 스트림에 출력합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#printStackTrace(java.io.PrintStream)">printStackTrace</A> </B>(<A HREF="../../java/io/PrintStream.html" title="java.io 안의 클래스">PrintStream</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 throw 가능 객체와 그 백 트레이스가 지정된 인쇄 스트림에 출력합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#printStackTrace(java.io.PrintWriter)">printStackTrace</A> </B>(<A HREF="../../java/io/PrintWriter.html" title="java.io 안의 클래스">PrintWriter</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 throw 가능 객체와 그 백 트레이스가 지정된 프린트 라이터에 출력합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#setStackTrace(java.lang.StackTraceElement[])">setStackTrace</A> </B>(<A HREF="../../java/lang/StackTraceElement.html" title="java.lang 안의 클래스">StackTraceElement</A> []&nbsp;stackTrace)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../java/lang/Throwable.html#getStackTrace()"><CODE>getStackTrace()</CODE></A>  에 의해 돌려주어지고 <A HREF="../../java/lang/Throwable.html#printStackTrace()"><CODE>printStackTrace()</CODE></A>  에 의해 출력되는 스택 트레이스 요소와 관련 메소드를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Throwable.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 throw 가능 객체의 짧은 기술을 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Throwable()"><!-- --></A> <H3>
Throwable</H3>
<PRE>
public <B>Throwable</B>()</PRE>
<DL>
<DD>상세 메세지에 <code>null</code> 를 사용해, 신규 throw 가능 객체를 구축합니다. 원인은 초기화되지 않고, 그 후 <A HREF="../../java/lang/Throwable.html#initCause(java.lang.Throwable)"><CODE>initCause(java.lang.Throwable)</CODE></A>  를 호출하는 것으로 초기화됩니다.

 <p><A HREF="../../java/lang/Throwable.html#fillInStackTrace()"><CODE>fillInStackTrace()</CODE></A>  메소드를 호출해, 신규 작성된 throw 가능 객체내의 스택 트레이스 데이터를 초기화합니다.
<P>
</DL>
<HR>

<A NAME="Throwable(java.lang.String)"><!-- --></A> <H3>
Throwable</H3>
<PRE>
public <B>Throwable</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;message)</PRE>
<DL>
<DD>지정된 상세 메세지를 사용해, 신규 throw 가능 객체를 구축합니다. 원인은 초기화되지 않고, 그 후 <A HREF="../../java/lang/Throwable.html#initCause(java.lang.Throwable)"><CODE>initCause(java.lang.Throwable)</CODE></A>  를 호출하는 것으로 초기화됩니다.

 <p><A HREF="../../java/lang/Throwable.html#fillInStackTrace()"><CODE>fillInStackTrace()</CODE></A>  메소드를 호출해, 신규 작성된 throw 가능 객체내의 스택 트레이스 데이터를 초기화합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>message</CODE> - 상세 메세지 상세 메세지는, 나중에 <A HREF="../../java/lang/Throwable.html#getMessage()"><CODE>getMessage()</CODE></A>  메소드로 취득하기 위해서 보존된다</DL>
</DL>
<HR>

<A NAME="Throwable(java.lang.String, java.lang.Throwable)"><!-- --></A> <H3>
Throwable</H3>
<PRE>
public <B>Throwable</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;message,
                 <A HREF="../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;cause)</PRE>
<DL>
<DD>지정된 상세 메세지 및 원인을 사용해 신규 throw 가능 객체를 구축합니다. <p><code>cause</code> 와 관련지을 수 있었던 상세 메세지가, 이 throw 가능 객체의 상세 메세지에 자동적으로 통합될 것은 없습니다.

 <p><A HREF="../../java/lang/Throwable.html#fillInStackTrace()"><CODE>fillInStackTrace()</CODE></A>  메소드를 호출해, 신규 작성된 throw 가능 객체내의 스택 트레이스 데이터를 초기화합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>message</CODE> - 상세 메세지 (나중에 <A HREF="../../java/lang/Throwable.html#getMessage()"><CODE>getMessage()</CODE></A>  메소드로 취득하기 위해서 보존된다)<DD><CODE>cause</CODE> - 원인 (나중에 <A HREF="../../java/lang/Throwable.html#getCause()"><CODE>getCause()</CODE></A>  메소드로 취득하기 위해서 보존된다).
(<tt>null</tt> 치가 허가되고 있어 원인이 존재하지 않는가 불명한 것을 나타낸다)<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DL>
<HR>

<A NAME="Throwable(java.lang.Throwable)"><!-- --></A> <H3>
Throwable</H3>
<PRE>
public <B>Throwable</B>(<A HREF="../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;cause)</PRE>
<DL>
<DD>지정된 원인과 상세 메세지 <tt>(cause==null ?  null : cause.toString())</tt> 를 가지는, 새로운 throw 가능 객체를 구축합니다 (일반적으로, 클래스와<tt>원인</tt>의 상세 메세지를 포함합니다). 이 생성자 은, throw 가능 객체가 다른 throw 가능 객체 (<A HREF="../../java/security/PrivilegedActionException.html" title="java.security 안의 클래스"><CODE>PrivilegedActionException</CODE></A>  등)의 래퍼인 경우에 유용합니다.

 <p><A HREF="../../java/lang/Throwable.html#fillInStackTrace()"><CODE>fillInStackTrace()</CODE></A>  메소드를 호출해, 신규 작성된 throw 가능 객체내의 스택 트레이스 데이터를 초기화합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>cause</CODE> - 원인 (나중에 <A HREF="../../java/lang/Throwable.html#getCause()"><CODE>getCause()</CODE></A>  메소드로 취득하기 위해서 보존된다).
(<tt>null</tt> 치가 허가되고 있어 원인이 존재하지 않는가 불명한 것을 나타낸다)<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getMessage()"><!-- --></A> <H3>
getMessage</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getMessage</B>()</PRE>
<DL>
<DD>이 Throwable 객체의 상세 메세지 캐릭터 라인을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <tt>Throwable</tt> 인스턴스의 상세 메세지 캐릭터 라인 (<tt>null</tt> 도 가능)</DL>
</DD>
</DL>
<HR>

<A NAME="getLocalizedMessage()"><!-- --></A> <H3>
getLocalizedMessage</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getLocalizedMessage</B>()</PRE>
<DL>
<DD>이 throw 가능 객체의, 로컬라이즈 된 기술을 작성합니다. 서브 클래스는 이 메소드를 오버라이드(override) 해, 로케일에 고유의 메세지를 작성할 수 있습니다. 이 메소드를 오버라이드(override) 하지 않는 서브 클래스의 경우는, 디폴트의 구현에 의해 <code>getMessage()</code> 와 같은 결과가 돌려주어집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 throw 가능 객체의, 로컬라이즈 된 기술<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCause()"><!-- --></A> <H3>
getCause</H3>
<PRE>
public <A HREF="../../java/lang/Throwable.html" title="java.lang 내의 클래스">Throwable</A>  <B>getCause</B>()</PRE>
<DL>
<DD>원인이 존재하지 않는가 불명한 경우에, 이 Throwable 또는 <code>null</code> 의 원인을 돌려줍니다. 원인은 이 Throwable 를 throw 시킨 Throwable 입니다.

 <p>이 구현은,<tt>Throwable</tt> 를 요구하는 몇개의 생성자  경유로 제공된 원인, 또는 <A HREF="../../java/lang/Throwable.html#initCause(java.lang.Throwable)"><CODE>initCause(Throwable)</CODE></A>  메소드를 사용해 작성 후로 설정된 원인을 돌려줍니다. 일반적으로, 이 메소드를 오버라이드(override) 할 필요는 없습니다만, 서브 클래스는 이 메소드를 오버라이드(override) 해, 다른 어떠한 방법으로 설정된 원인을 돌려줄 수가 있습니다. 이것은, 체인 된 예외의 <tt>Throwable</tt> 에의 추가전에 실행되는 「유산 연쇄 throw 가능 객체」의 경우에 적절한 동작입니다. <tt>PrintStackTrace</tt> 메소드의 어느쪽이든을 오버라이드(override) 할 필요는 없습니다.  이러한 메소드는 모두 <tt>getCause</tt> 메소드를 호출해, throw 가능 객체의 원인을 판별합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>throw 가능한 객체의 원인. 원인이 존재하지 않는가 불명의 경우는 <code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="initCause(java.lang.Throwable)"><!-- --></A> <H3>
initCause</H3>
<PRE>
public <A HREF="../../java/lang/Throwable.html" title="java.lang 내의 클래스">Throwable</A>  <B>initCause</B>(<A HREF="../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;cause)</PRE>
<DL>
<DD>지정된 값에 대한 이 Throwable 의 「원인」을 초기화합니다. 원인은 이 Throwable 를 throw 시킨 Throwable 입니다.

 <p>이 메소드는 최대로 1 회 밖에 호출할 수가 없습니다. 일반적으로은, 생성자 내로부터, 또는 Throwable 의 작성 직후에 불려 갑니다. <A HREF="../../java/lang/Throwable.html#Throwable(java.lang.Throwable)"><CODE>Throwable(Throwable)</CODE></A>  또는 <A HREF="../../java/lang/Throwable.html#Throwable(java.lang.String, java.lang.Throwable)"><CODE>Throwable(String, Throwable)</CODE></A>  를 사용해 이 throw 가능 객체를 작성했을 경우, 이 메소드를 한번도 호출할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cause</CODE> - 원인 (나중에 <A HREF="../../java/lang/Throwable.html#getCause()"><CODE>getCause()</CODE></A>  메소드로 취득하기 위해서 보존된다).
(<tt>null</tt> 치가 허가되고 있어 원인이 존재하지 않는가 불명한 것을 나타낸다)
<DT><B>반환값:</B><DD>이 <code>Throwable</code> 인스턴스에의 참조
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>cause</code> 가 이 Throwable 인 경우 (Throwable 는 그것 자신의 원인으로는 될 수  없다)
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 throw 가능 객체가 <A HREF="../../java/lang/Throwable.html#Throwable(java.lang.Throwable)"><CODE>Throwable(Throwable)</CODE></A>  또는 <A HREF="../../java/lang/Throwable.html#Throwable(java.lang.String, java.lang.Throwable)"><CODE>Throwable(String, Throwable)</CODE></A>  를 사용해 작성되었는지, 이 메소드가 이 throw 가능 객체에 대해서 호출을 실행이 끝난 상태인 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 throw 가능 객체의 짧은 기술을 돌려줍니다. 결과는 다음의 것을 연결한 것이 됩니다.
 <ul>
<li> 이 객체의 클래스의 <A HREF="../../java/lang/Class.html#getName()">이름</A> 
<li> ": " (구두점과 스페이스)
<li> 이 객체의 <A HREF="../../java/lang/Throwable.html#getLocalizedMessage()"><CODE>getLocalizedMessage()</CODE></A>  메소드를 호출한 결과
 </ul>
<tt>getLocalizedMessage</tt> 가 <tt>null</tt> 를 돌려주는 경우, 단지 클래스명이 돌려주어집니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 throw 가능 객체의 캐릭터 라인 표현</DL>
</DD>
</DL>
<HR>

<A NAME="printStackTrace()"><!-- --></A> <H3>
printStackTrace</H3>
<PRE>
public void <B>printStackTrace</B>()</PRE>
<DL>
<DD>이 throw 가능 객체 및 그 백 트레이스를 표준 에러 스트림에 출력합니다. 이 메소드는, 이 </code>Throwable</code> 객체의 스택 트레이스를,<code>System.err</code> 필드의 값인 에러 출력 스트림로 출력합니다. 출력의 선두행에는, 이 객체에 대한 <A HREF="../../java/lang/Throwable.html#toString()"><CODE>toString()</CODE></A>  메소드의 결과가 포함됩니다. 나머지의 행은, 이전에 <A HREF="../../java/lang/Throwable.html#fillInStackTrace()"><CODE>fillInStackTrace()</CODE></A>  메소드에 의해 기록된 데이터를 나타냅니다. 이 정보의 서식은 구현에 따라서 다릅니다만, 전형적인 서식의 예를 다음에 나타냅니다.
 <blockquote><pre>
 java.lang.NullPointerException
         at MyClass.mash(MyClass.java:9)
         at MyClass.crunch(MyClass.java:6)
         at MyClass.main(MyClass.java:3)
 </pre></blockquote>
이 예는, 다음의 프로그램을 실행하는 것에 의해 작성된 것입니다.
 <pre>
class MyClass {
public static void main (String [] args) {
crunch(null);
     }
static void crunch(int[] a) {
mash(a);
     }
static void mash(int[] b) {
System.out.println(b[0]);
     }
 }
 </pre>
초기화된 비 null 의 원인을 보관 유지하는 throw 가능 객체의 백 트레이스에는, 일반적으로, 원인의 백 트레이스가 포함됩니다. 이 정보의 서식은 구현에 따라서 다릅니다만, 전형적인 서식의 예를 다음에 나타냅니다.
 <pre>
HighLevelException:MidLevelException:LowLevelException
at Junk.a(Junk.java:13)
at Junk.main(Junk.java:4)
 Caused by:MidLevelException:LowLevelException
at Junk.c(Junk.java:23)
at Junk.b(Junk.java:17)
at Junk.a(Junk.java:11)
... 1 more
Caused by: LowLevelException
at Junk.e(Junk.java:30)
at Junk.d(Junk.java:27)
at Junk.c(Junk.java:21)
... 3 more
 </pre>
문자 <tt>"..."</tt> (을)를 포함한 행이 존재하는 것에 주목해 주세요. 이러한 행은, 이 예외의 스택 트레이스의 나머지가, 이 예외에 의해 일으켜진 예외의 스택 트레이스아래로부터의 프레임수로 일치하는 것을 나타냅니다. 일반적으로의 ( 「원인이 되는 예외」를 캐치 하는 것과 같은 메소드로부터 랩 된 예외가 throw 된다) 경우, 이 단축형을 사용하는 것으로, 출력의 길이를 큰폭으로 단축할 수 있습니다. 위의 예는, 다음의 프로그램을 실행하는 것으로 생성됩니다.
 <pre>
public class Junk {
public static void main(String args[]) {
try {
a();
} catch(HighLevelException e) {
e.printStackTrace();
         }
     }
static void a() throws HighLevelException {
try {
b();
} catch(MidLevelException e) {
throw new HighLevelException(e);
         }
     }
static void b() throws MidLevelException {
c();
     }
static void c() throws MidLevelException {
try {
d();
} catch(LowLevelException e) {
throw new MidLevelException(e);
         }
     }
static void d() throws LowLevelException {
e();
     }
static void e() throws LowLevelException {
throw new LowLevelException();
     }
 }

class HighLevelException extends Exception {
HighLevelException(Throwable cause) { super(cause); }
 }

class MidLevelException extends Exception {
MidLevelException(Throwable cause)  { super(cause); }
 }

class LowLevelException extends Exception {
 }
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printStackTrace(java.io.PrintStream)"><!-- --></A> <H3>
printStackTrace</H3>
<PRE>
public void <B>printStackTrace</B>(<A HREF="../../java/io/PrintStream.html" title="java.io 안의 클래스">PrintStream</A> &nbsp;s)</PRE>
<DL>
<DD>이 throw 가능 객체와 그 백 트레이스가 지정된 인쇄 스트림에 출력합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 출력에 사용하는 <code>PrintStream</code></DL>
</DD>
</DL>
<HR>

<A NAME="printStackTrace(java.io.PrintWriter)"><!-- --></A> <H3>
printStackTrace</H3>
<PRE>
public void <B>printStackTrace</B>(<A HREF="../../java/io/PrintWriter.html" title="java.io 안의 클래스">PrintWriter</A> &nbsp;s)</PRE>
<DL>
<DD>이 throw 가능 객체와 그 백 트레이스가 지정된 프린트 라이터에 출력합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 출력에 사용하는 <code>PrintWriter</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="fillInStackTrace()"><!-- --></A> <H3>
fillInStackTrace</H3>
<PRE>
public <A HREF="../../java/lang/Throwable.html" title="java.lang 내의 클래스">Throwable</A>  <B>fillInStackTrace</B>()</PRE>
<DL>
<DD>실행 스택 트레이스를 묻습니다. 이 메소드는, 현행 thread의 스택 프레임의 현재 상태에 관한 정보를, 이 <code>Throwable</code> 객체내에 기록합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>Throwable</code> 인스턴스에의 참조<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Throwable.html#printStackTrace()"><CODE>printStackTrace()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getStackTrace()"><!-- --></A> <H3>
getStackTrace</H3>
<PRE>
public <A HREF="../../java/lang/StackTraceElement.html" title="java.lang 내의 클래스">StackTraceElement</A> [] <B>getStackTrace</B>()</PRE>
<DL>
<DD><A HREF="../../java/lang/Throwable.html#printStackTrace()"><CODE>printStackTrace()</CODE></A>  에 의해 제공되는 스택 트레이스 정보에 프로그램으로 액세스 할 수 있도록(듯이) 합니다. 각각이 스택 프레임을 나타내는, 스택 트레이스 요소의 배열을 돌려줍니다. 배열의 길이가 제로 이외이라고 가정했을 경우의 제로 번째의 요소는, 스택의 최상부를 나타냅니다. 이것은 순서로 불려 간 마지막 메소드입니다. 일반적으로, 이것은, 이 throw 가능 객체가 작성되어 throw 된 포인트가 됩니다. 배열의 길이가 제로 이외이라고 가정했을 경우의 마지막 요소는, 스택의 최하부를 나타냅니다. 이것은 순서로 불려 간 최초의 메소드입니다.

 <p>가상 머신안에는, 특정의 상황하로 스택 트레이스로부터 1 개 이상의 스택 프레임을 생략 하는 것이 있습니다. 극단적인 경우, 이 throw 가능 객체에 관한 스택 트레이스 정보를 보관 유지하지 않는 가상 머신이, 이 메소드로부터 길이 제로의 배열을 돌려주는 것이 허가됩니다. 일반적으로, 이 메소드에 의해 반환되는 배열은,<tt>printStackTrace</tt> 에 의해 출력되는 프레임 마다 1 개의 요소를 포함합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 throw 가능 객체에 관한 스택 트레이스를 나타내는, 스택 트레이스 요소의 배열<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setStackTrace(java.lang.StackTraceElement[])"><!-- --></A> <H3>
setStackTrace</H3>
<PRE>
public void <B>setStackTrace</B>(<A HREF="../../java/lang/StackTraceElement.html" title="java.lang 안의 클래스">StackTraceElement</A> []&nbsp;stackTrace)</PRE>
<DL>
<DD><A HREF="../../java/lang/Throwable.html#getStackTrace()"><CODE>getStackTrace()</CODE></A>  에 의해 돌려주어지고 <A HREF="../../java/lang/Throwable.html#printStackTrace()"><CODE>printStackTrace()</CODE></A>  에 의해 출력되는 스택 트레이스 요소와 관련 메소드를 설정합니다.

이 메소드는, RPC 시스템 및 다른 고성능 시스템에서의 사용을 목적으로 설계되고 있어 클라이언트가 디폴트 스택 트레이스를 오버라이드(override) 할 수 있도록(듯이) 합니다.  디폴트 스택 트레이스는, throw 가능 객체의 구축시에 <A HREF="../../java/lang/Throwable.html#fillInStackTrace()"><CODE>fillInStackTrace()</CODE></A>  에 의해 생성되는지, throw 가능 객체가 직렬화 스트림로부터 읽어들일 때에 직렬화 복원됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>stackTrace</CODE> - 이 <code>Throwable</code> 와 관련짓는 스택 트레이스 요소.
지정된 배열은, 이 호출에 의해 카피된다.  메소드 호출의 복귀 후에, 지정된 배열내에서 행해진 변경은,<code>Throwable</code> 의 스택 트레이스에 영향을 미치지 않는다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>stackTrace</code> 가 <code>null</code> 의 경우, 또는 <code>stackTrace</code> 의 몇개의 요소가 <code>null</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Throwable.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/ThreadLocal.html" title="java.lang 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/TypeNotPresentException.html" title="java.lang 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Throwable.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Throwable.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
