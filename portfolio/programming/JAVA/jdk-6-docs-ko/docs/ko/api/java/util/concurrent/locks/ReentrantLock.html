<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:01:04 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
ReentrantLock (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ReentrantLock (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ReentrantLock.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html" title="java.util.concurrent.locks 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/locks/ReentrantLock.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ReentrantLock.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent.locks</FONT>
<BR>
클래스 ReentrantLock</H2>
<PRE>
<A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.concurrent.locks.ReentrantLock</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> , <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 안의 인터페이스">Lock</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>ReentrantLock</B><DT>extends <A HREF="../../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A> , <A HREF="../../../../java/io/Serializable.html" title="java.io 안의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
<code>synchronized</code> 메소드 및 문장을 사용해 액세스 하는 암묵의 감시 락과 같은 기본 동작 및 시멘틱스를 사용해, 한편 확장 기능을 가지는, 재입 가능한 상호 배타 <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스"><CODE>Lock</CODE></A>  입니다.

 <p><code>ReentrantLock</code> 는, 마지막에 락에 성공했지만 아직 락 해제하고 있지 않는 thread에 의해 「소유」됩니다. <em></em>락이 다른 thread에 소유되어 있지 않은 경우,<code>lock</code> 를 호출하는 thread가 복귀해 락의 취득에 성공합니다. 현재의 thread가 락을 벌써 소유하고 있는 경우, 메소드는 즉시 복귀합니다. 이것은,<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#isHeldByCurrentThread()"><CODE>isHeldByCurrentThread()</CODE></A>  및 <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#getHoldCount()"><CODE>getHoldCount()</CODE></A>  메소드를 사용해 체크할 수 있습니다.

 <p>이 클래스의 생성자 은, 옵션의 「공평성」파라미터를 받아들입니다. 이것이 <code>true</code> 로 설정되면(자), 경합이 존재하는 경우, 락은 가장 길게 대기하고 있는 thread에의 액세스를 허가하도록(듯이) 응답합니다. 그렇지 않은 경우, 이 락이 특정의 액세스순서를 보증할 것은 없습니다. 다수의 thread에 의해 액세스 되는 공평 락을 사용하는 프로그램은, 디폴트 설정을 사용하는 프로그램보다 낮은 (보다 저속인, 많은 경우 매우 저속인) 전체 throughput를 표시하는 경우가 있습니다만, 락을 취득할 때의 변동은 보다 작아져, 고갈하지 않는 것이 보증됩니다. 다만, 락의 공평성에 의해, thread 스케줄링의 공평성이 보증되는 것은 아닙니다. 이 때문에, 공평 락을 사용하는 다수의 thread의 1 개가 여러 차례 연속해 취득해, 액티브한 다른 thread의 진척을 보지 못하고, 락을 보관 유지하고 있지 않는 상태가 될 수도 있습니다. 또, 시간 지정이 없는 <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#tryLock()"><CODE>tryLock</CODE></A>  메소드는 공평성 설정을 존중하지 않고, 받아들이지 않습니다. 다른 thread가 대기 그 중에서 락이 유효하면 이 메소드는 성공합니다.

 <p><code>lock</code> 의 호출의 직후에 <code>try</code> 블록을 계속하는 것이, 항상 추천 되고 있습니다. 일반적으로, 다음의 구축을 실행하기 전/후에 실행합니다. <em></em>

 <pre>
 class X {
   private final ReentrantLock lock = new ReentrantLock();
   // ...

   public void m() {
     lock.lock();  // block until condition holds
     try {
       // ... method body
     } finally {
       lock.unlock()
     }
   }
 }
 </pre>

 <p>이 클래스는,<A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Lock</CODE></A>  인터페이스의 구현에 가세해<code>isLocked</code>,<code>getLockQueueLength</code>, 및 계측이나 감시에 도움이 되는 관련 <code>protected</code> 액세스 메소드를 정의합니다.

 <p>이 클래스의 직렬화는, 편입 락과 같게 동작합니다. 직렬화 해제된 락은, 직렬화시 상태에 관계없이, 락 해제 상태가 됩니다.

 <p>이 락은, 1 개의 thread로 최대 2147483647 의 재귀적 락을 지원합니다. 이 제한을 넘으려고 하면(자), 잠그는 메소드로부터 <A HREF="../../../../java/lang/Error.html" title="java.lang 안의 클래스"><CODE>Error</CODE></A>  가 throw 됩니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../../serialized-form.html#java.util.concurrent.locks.ReentrantLock">직렬화 된 형식</A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#ReentrantLock()">ReentrantLock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ReentrantLock</code> 의 인스턴스를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#ReentrantLock(boolean)">ReentrantLock</A> </B>(boolean&nbsp;fair)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 공평성 정책를 사용해 <code>ReentrantLock</code> 의 인스턴스를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#getHoldCount()">getHoldCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread의, 이 락에 대한 보관 유지수를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#getOwner()">getOwner</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 이 락을 소유하고 있는 thread를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#getQueuedThreads()">getQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락의 취득을 대기하고 있는 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#getQueueLength()">getQueueLength</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락의 취득을 대기중의 thread의 추정수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#getWaitingThreads(java.util.concurrent.locks.Condition)">getWaitingThreads</A> </B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락에 관련지을 수 있었던 지정 상태를 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#getWaitQueueLength(java.util.concurrent.locks.Condition)">getWaitQueueLength</A> </B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락에 관련지을 수 있었던 지정 상태로 대기중의 thread의 추정수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#hasQueuedThread(java.lang.Thread)">hasQueuedThread</A> </B>(<A HREF="../../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;thread)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 thread가 이 락의 취득을 대기중인가 어떤가를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#hasQueuedThreads()">hasQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락의 취득을 대기중의 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#hasWaiters(java.util.concurrent.locks.Condition)">hasWaiters</A> </B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#isFair()">isFair</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락으로 공평성이 true 로 설정되어 있는 경우는 <code>true</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#isHeldByCurrentThread()">isHeldByCurrentThread</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread가 이 락을 보관 유지하고 있을지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#isLocked()">isLocked</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락이 몇개의 thread에 의해 보관 유지되고 있는지 어떤지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#lock()">lock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;락을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#lockInterruptibly()">lockInterruptibly</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread가 <A HREF="../../../../java/lang/Thread.html#interrupt()">interrupted</A>  가 아닌 한, 락을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스">Condition</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#newCondition()">newCondition</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Lock</CODE></A>  인스턴스로 사용하는 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 동안의 인터페이스"><CODE>Condition</CODE></A>  인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락 및 그 상태를 식별하는 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#tryLock()">tryLock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;호출시에 다른 thread에 의해 보관 유지되어 있지 않은 경우에게만, 락을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#tryLock(long, java.util.concurrent.TimeUnit)">tryLock</A> </B>(long&nbsp;timeout,
        <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 대기 시간내에 다른 thread가 락을 보관 유지하지 않고, 현재의 thread로<A HREF="../../../../java/lang/Thread.html#interrupt()">인터럽트</a>가 발생하고 있지 않는 경우에, 락을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#unlock()">unlock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락의 해제을 시도합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ReentrantLock()"><!-- --></A> <H3>
ReentrantLock</H3>
<PRE>
public <B>ReentrantLock</B>()</PRE>
<DL>
<DD><code>ReentrantLock</code> 의 인스턴스를 작성합니다. 이것은,<code>ReentrantLock(false)</code> 의 사용과 등가입니다.
<P>
</DL>
<HR>

<A NAME="ReentrantLock(boolean)"><!-- --></A> <H3>
ReentrantLock</H3>
<PRE>
public <B>ReentrantLock</B>(boolean&nbsp;fair)</PRE>
<DL>
<DD>지정된 공평성 정책를 사용해 <code>ReentrantLock</code> 의 인스턴스를 작성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>fair</CODE> - 이 락이 공평 순서부 정책를 사용하는 경우는 <code>true</code></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="lock()"><!-- --></A> <H3>
lock</H3>
<PRE>
public void <B>lock</B>()</PRE>
<DL>
<DD>락을 가져옵니다.

 <p>락이 다른 thread에 보관 유지되어 있지 않은 경우, 그 락을 취득해 즉시 복귀해, 락의 보관 유지 카운트를 1 으로 설정합니다.

 <p>현재의 thread가 락을 벌써 보관 유지하고 있는 경우, 보관 유지 카운트의 값을 1 증분 해, 메소드를 즉시 복귀합니다.

 <p>락이 다른 thread에 의해 보관 유지되고 있는 경우, 현재의 thread가 thread 스케줄링에 관해서 무효가 되어, 락이 취득될 때까지 대기합니다. 락이 취득되면(자), 락 보관 유지 카운트가 1 으로 설정됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html#lock()">lock</A> </CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lockInterruptibly()"><!-- --></A> <H3>
lockInterruptibly</H3>
<PRE>
public void <B>lockInterruptibly</B>()
                       throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>현재의 thread가 <A HREF="../../../../java/lang/Thread.html#interrupt()">interrupted</A>  가 아닌 한, 락을 가져옵니다.

 <p>락이 다른 thread에 보관 유지되어 있지 않은 경우, 그 락을 취득해 즉시 복귀해, 락의 보관 유지 카운트를 1 으로 설정합니다.

 <p>현재의 thread가 락을 벌써 보관 유지하고 있는 경우, 보관 유지 카운트의 값을 1 증분 해, 메소드를 즉시 복귀합니다.

 <p>락이 다른 thread에 의해 보관 유지되고 있는 경우, 현재의 thread는 thread의 스케줄링에 관해서 무효가 되어, 다음의 2 개중 한쪽이 일어날 때까지 대기합니다.

 <ul>

<li>현재의 thread에 의해 락이 취득된다.

<li>다른 thread가 현재의 thread에<A HREF="../../../../java/lang/Thread.html#interrupt()">인터럽트</a>를 실시한다.

 </ul>

 <p>락이 현재의 thread에 의해 취득되었을 경우, 락 보관 유지 카운트가 1 으로 설정됩니다.

 <p>현재의 thread로,

 <ul>

<li>이 메소드에의 엔트리상에서 설정된 인터럽트 상태가 보관 유지되는지,

<li>락의 취득중에<A HREF="../../../../java/lang/Thread.html#interrupt()">인터럽트</a>가 발생했을 경우,

 </ul>

<A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스"><CODE>InterruptedException</CODE></A>  가 throw 되어 현재의 thread의 인터럽트 상태가 클리어 됩니다.

 <p>이 메소드는 명시적인 끼어들어 포인트이기 (위해)때문에, 이 구현에서는, 일반적으로 또는 재입 가능한 락 취득에의 인터럽트에의 응답에 높은 우선도가 주어집니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html#lockInterruptibly()">lockInterruptibly</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryLock()"><!-- --></A> <H3>
tryLock</H3>
<PRE>
public boolean <B>tryLock</B>()</PRE>
<DL>
<DD>호출시에 다른 thread에 의해 보관 유지되어 있지 않은 경우에게만, 락을 가져옵니다.

 <p>다른 thread가 락을 보관 유지하고 있지 않는 경우에 락을 취득해, 값 <code>true</code> 로 즉시 복귀해, 락 보관 유지 카운트를 1 으로 설정합니다. 이 락이 공평 순서부 정책를 사용하도록(듯이) 설정되어 있는 경우에서도, 락이 사용 가능하면, 다른 thread가 현재 락을 대기하고 있을지 어떨지에 관계없이,<code>tryLock()</code> 의 호출로 곧바로 락이 취득됩니다. <em></em>이 「인터럽트」(barging) 동작에 의해 공평성이 없어진다고는 말할 수 있어 이것은 특정의 상황하로 유용합니다. 이 락의 공평성 설정을 존중하는 경우는, 거의 등가인 <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#tryLock(long, java.util.concurrent.TimeUnit)"><CODE>tryLock(0, TimeUnit.SECONDS)</CODE></A>  를 사용합니다 (이것도 인터럽트를 검출한다).

 <p> 현재의 thread가 락을 벌써 보관 유지하고 있는 경우, 보관 유지 카운트의 값을 1 증분 해,<code>true</code> 로 복귀합니다.

 <p>락이 다른 thread에 의해 보관 유지되고 있는 경우, 이 메소드는, 값 <code>false</code> 로 즉시 복귀합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock()">tryLock</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>락되어 있지 않은 상태로, 현재의 thread에 의해 락이 취득되었는지, 락이 현재의 thread에 의해 취득이 끝난 상태인 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="tryLock(long, java.util.concurrent.TimeUnit)"><!-- --></A> <H3>
tryLock</H3>
<PRE>
public boolean <B>tryLock</B>(long&nbsp;timeout,
                       <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)
                throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>지정된 대기 시간내에 다른 thread가 락을 보관 유지하지 않고, 현재의 thread로<A HREF="../../../../java/lang/Thread.html#interrupt()">인터럽트</a>가 발생하고 있지 않는 경우에, 락을 가져옵니다.

 <p>다른 thread가 락을 보관 유지하고 있지 않는 경우에 락을 취득해, 값 <code>true</code> 로 즉시 복귀해, 락 보관 유지 카운트를 1 으로 설정합니다. 이 락이 공평 순서부 정책를 사용하도록(듯이) 설정되어 있어도, 다른 thread가 락을 대기하고 있는 경우는, 사용 가능한 락은 취득되지 않습니다. 이것은,<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#tryLock()"><CODE>tryLock()</CODE></A>  메소드와는 대조적입니다. 공평 락에 대한 화물 운반선을 허가하지 않는, 시간 설정된 <code>tryLock</code> 를 사용하는 경우는, 시간 설정과 비시간 설정의 양형식을 조합해 사용합니다.

 <pre>if (lock.tryLock() || lock.tryLock(timeout, unit) ) { ... }
 </pre>

 <p>현재의 thread가 락을 벌써 보관 유지하고 있는 경우, 보관 유지 카운트의 값을 1 증분 해,<code>true</code> 로 복귀합니다.

 <p>락이 다른 thread에 의해 보관 유지되고 있는 경우, 현재의 thread는 thread의 스케줄링에 관해서 무효가 되어, 다음의 3 개중 한쪽이 일어날 때까지 대기합니다.

 <ul>

<li>현재의 thread에 의해 락이 취득된다.

<li>다른 thread가 현재의 thread에<A HREF="../../../../java/lang/Thread.html#interrupt()">인터럽트</a>를 실시한다.

<li>지정된 대기 시간이 경과한다.

 </ul>

 <p>락이 취득되었을 경우, 값 <code>true</code> 가 돌려주어져 락 보관 유지 카운트가 1 으로 설정됩니다.

 <p>현재의 thread로,

 <ul>

<li>이 메소드에의 엔트리상에서 설정된 인터럽트 상태가 보관 유지되는지,

<li>락의 취득중에<A HREF="../../../../java/lang/Thread.html#interrupt()">인터럽트</a>가 발생했을 경우,

 </ul>
<A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스"><CODE>InterruptedException</CODE></A>  가 throw 되어 현재의 thread의 인터럽트 상태가 클리어 됩니다.

 <p>지정된 대기 시간이 경과하면(자), 값 <code>false</code> 가 돌려주어집니다. 시간이 제로 또는 그것보다 작은 경우, 메소드는 대기하지 않습니다.

 <p>이 메소드는 명시적인 끼어들어 포인트이기 (위해)때문에, 이 구현에서는, 일반적으로 또는 재입 가능한 락 취득, 및 대기 시간 경과 리포트에의 인터럽트에 대한 응답에 높은 우선도가 주어집니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock(long, java.util.concurrent.TimeUnit)">tryLock</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>timeout</CODE> - 락을 대기하는 시간<DD><CODE>unit</CODE> - timeout 인수의 시간 단위
<DT><B>반환값:</B><DD>락되어 있지 않은 상태로, 현재의 thread에 의해 락이 취득되었는지, 락이 현재의 thread에 의해 취득이 끝난 상태인 경우는 <code>true</code>, 락을 취득하기 전에 대기 시간이 경과했을 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 시간 단위가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="unlock()"><!-- --></A> <H3>
unlock</H3>
<PRE>
public void <B>unlock</B>()</PRE>
<DL>
<DD>이 락의 해제을 시도합니다.

 <p>현재의 thread가 이 락의 홀더인 경우, 보관 유지 카운트의 값이 줄여집니다. 보관 유지 카운트가 제로가 되면(자), 락이 해제됩니다. 현재의 thread가 이 락의 홀더가 아닌 경우,<A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스"><CODE>IllegalMonitorStateException</CODE></A>  가 throw 됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html#unlock()">unlock</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 현재의 thread가 이 락을 보관 유지하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="newCondition()"><!-- --></A> <H3>
newCondition</H3>
<PRE>
public <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스">Condition</A>  <B>newCondition</B>()</PRE>
<DL>
<DD>이 <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Lock</CODE></A>  인스턴스로 사용하는 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 동안의 인터페이스"><CODE>Condition</CODE></A>  인스턴스를 돌려줍니다.

 <p>반환되는 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 동안의 인터페이스"><CODE>Condition</CODE></A>  인스턴스는,<A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스"><CODE>Object</CODE></A>  감시 메소드 (<A HREF="../../../../java/lang/Object.html#wait()"><CODE>wait</CODE></A> ,<A HREF="../../../../java/lang/Object.html#notify()"><CODE>notify</CODE></A> , 및 <A HREF="../../../../java/lang/Object.html#notifyAll()"><CODE>notifyAll</CODE></A> )를 편입 감시 락으로 사용하는 경우와 같은 사용 방법을 지원합니다.

 <ul>

<li><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A>  <A HREF="../../../../java/util/concurrent/locks/Condition.html#await()">대기 </a>또는<A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()">신호 송신 </a>메소드의 어느 쪽인지가 불려 갔을 때에 이 락이 보관 유지되어 있지 않은 경우,<A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스"><CODE>IllegalMonitorStateException</CODE></A>  가 throw 됩니다.

<li>상태<A HREF="../../../../java/util/concurrent/locks/Condition.html#await()">대기 </a>메소드가 불려 가면(자), 락이 해제됩니다. 그 후, 락이 재취득되어 락 보관 유지 카운트가 메소드의 호출시 상태에 복원되고 나서, 메소드가 복귀합니다.

<li>대기중에 thread로<A HREF="../../../../java/lang/Thread.html#interrupt()">인터럽트</a>가 발생하면(자), 대기는 종료해,<A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스"><CODE>InterruptedException</CODE></A>  가 throw 되어 thread의 인터럽트 상태가 클리어 됩니다.

<li> 대기중의 thread는, FIFO 의 순서로 신호가 송신됩니다.

<li>대기중의 메소드로부터 복귀하는 thread가 락을 재취득하는 순서는, thread가 락을 최초로 취득했을 때의 순서와 같게 됩니다. 이것은, 디폴트에서는 지정되고 있지 않습니다만, 「공평」락에서는 가장 길게 대기하고 있던 thread가 우선됩니다.

 </ul>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html#newCondition()">newCondition</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>Condition 객체</DL>
</DD>
</DL>
<HR>

<A NAME="getHoldCount()"><!-- --></A> <H3>
getHoldCount</H3>
<PRE>
public int <B>getHoldCount</B>()</PRE>
<DL>
<DD>현재의 thread의, 이 락에 대한 보관 유지수를 조회합니다.

 <p>thread에는, 락 해제 액션과 일치하지 않는 락 액션 마다, 락 보관 유지가 존재합니다.

 <p>일반적으로, 보관 유지 카운트 정보는 테스트 및 디버그용으로만 사용됩니다. 예를 들어, 락을 보관 유지한 상태로 특정의 코드 섹션에 들어가서는 안 되는 경우, 그것을 다음과 같이 나타냅니다.

 <pre>
 class X {
   ReentrantLock lock = new ReentrantLock();
   // ...
   public void m() {
     assert lock.getHoldCount() == 0;
     lock.lock();
     try {
       // ... method body
     } finally {
       lock.unlock();
     }
   }
 }
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 thread의, 이 락에 대한 보관 유지수. 현재의 thread가 이 락을 보관 유지하고 있지 않는 경우는 제로</DL>
</DD>
</DL>
<HR>

<A NAME="isHeldByCurrentThread()"><!-- --></A> <H3>
isHeldByCurrentThread</H3>
<PRE>
public boolean <B>isHeldByCurrentThread</B>()</PRE>
<DL>
<DD>현재의 thread가 이 락을 보관 유지하고 있을지 어떨지를 조회합니다.

 <p>편입 감시 락용의 <A HREF="../../../../java/lang/Thread.html#holdsLock(java.lang.Object)"><CODE>Thread.holdsLock(java.lang.Object)</CODE></A>  메소드와 같이, 이 메소드는 일반적으로, 디버그 및 테스트에 사용됩니다. 예를 들어, 락이 보관 유지되고 있는 경우에게만 호출할 필요가 있는 메소드는, 그것을 다음과 같이 가리킬 수가 있습니다.

 <pre>
 class X {
   ReentrantLock lock = new ReentrantLock();
   // ...

   public void m() {
       assert lock.isHeldByCurrentThread();
       // ... method body
   }
 }
 </pre>

 <p>재입 가능한 락이 재입 불가능한 방법으로 확실히 사용되도록(듯이) 하는 경우에도, 이것을 사용할 수 있습니다. 다음에 예를 나타냅니다.

 <pre>
 class X {
   ReentrantLock lock = new ReentrantLock();
   // ...

   public void m() {
       assert ! lock.isHeldByCurrentThread();
       lock.lock();
       try {
           // ... method body
       } finally {
           lock.unlock();
       }
   }
 }
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 thread가 락을 보관 유지하는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="isLocked()"><!-- --></A> <H3>
isLocked</H3>
<PRE>
public boolean <B>isLocked</B>()</PRE>
<DL>
<DD>이 락이 몇개의 thread에 의해 보관 유지되고 있는지 어떤지를 조회합니다. 이 메소드는, 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>임의의 thread가 락을 보관 유지하는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="isFair()"><!-- --></A> <H3>
isFair</H3>
<PRE>
public final boolean <B>isFair</B>()</PRE>
<DL>
<DD>이 락으로 공평성이 true 로 설정되어 있는 경우는 <code>true</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 락으로 공평성이 true 로 설정되어 있는 경우는 <code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="getOwner()"><!-- --></A> <H3>
getOwner</H3>
<PRE>
protected <A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A>  <B>getOwner</B>()</PRE>
<DL>
<DD>현재 이 락을 소유하고 있는 thread를 돌려줍니다. 락이 소유되어 있지 않은 경우는 <code>null</code> 를 돌려줍니다. 이 메소드가 소유자가 아닌 thread에 의해 불려 가는 경우, 반환값에는 현재의 락 상태의 최대한의 근사치가 반영됩니다. 예를 들어, 락의 취득을 시도하고 있어 아직 취득하고 있지 않는 thread가 존재하는 경우도, 소유자는 일시적으로 <code>null</code> 가 되는 경우가 있습니다. 이 메소드는, 보다 포괄적인 락 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>소유자. 소유되어 있지 않은 경우는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="hasQueuedThreads()"><!-- --></A> <H3>
hasQueuedThreads</H3>
<PRE>
public final boolean <B>hasQueuedThreads</B>()</PRE>
<DL>
<DD>이 락의 취득을 대기중의 thread가 존재할지 어떨지를 조회합니다. 취소는 언제라도 발생할 가능성이 있기 (위해)때문에,<code>true</code> 가 돌려주어져도, 다른 몇개의 thread가 이 락을 취득하는 것은 보증되고 있지 않습니다. 이 메소드는, 주로 시스템 상태의 감시에 사용하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>락의 취득을 대기중외의 thread가 존재할 가능성이 있는 경우는 <code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="hasQueuedThread(java.lang.Thread)"><!-- --></A> <H3>
hasQueuedThread</H3>
<PRE>
public final boolean <B>hasQueuedThread</B>(<A HREF="../../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;thread)</PRE>
<DL>
<DD>지정된 thread가 이 락의 취득을 대기중인가 어떤가를 조회합니다. 취소는 언제라도 발생할 가능성이 있기 (위해)때문에,<code>true</code> 가 돌려주어져도, 이 thread가 이 락을 취득하는 것은 보증되고 있지 않습니다. 이 메소드는, 주로 시스템 상태의 감시에 사용하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>thread</CODE> - thread
<DT><B>반환값:</B><DD>지정된 thread가 큐에 넣어지고 있어 이 락을 대기중인 경우는 <code>true</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - thread가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getQueueLength()"><!-- --></A> <H3>
getQueueLength</H3>
<PRE>
public final int <B>getQueueLength</B>()</PRE>
<DL>
<DD>이 락의 취득을 대기중의 thread의 추정수를 돌려줍니다. 이 메소드가 내부의 데이터 구조를 횡단(traverse) 하고 있는 동안에도, thread수가 동적으로 변화하는 경우가 있기 (위해)때문에, 이 값은 추정에 지나지 않습니다. 이 메소드는, 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 락을 대기하고 있는 thread의 추정수</DL>
</DD>
</DL>
<HR>

<A NAME="getQueuedThreads()"><!-- --></A> <H3>
getQueuedThreads</H3>
<PRE>
protected <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getQueuedThreads</B>()</PRE>
<DL>
<DD>이 락의 취득을 대기하고 있는 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는, 결과의 구축중에도 동적으로 변화할 가능성이 있기 (위해)때문에, 반환되는 컬렉션은 최선이 노력한 다음의 추정에 지나지 않습니다. 반환되는 컬렉션의 요소에는, 특정의 순서는 존재하지 않습니다. 이 메소드는, 보다 포괄적인 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="hasWaiters(java.util.concurrent.locks.Condition)"><!-- --></A> <H3>
hasWaiters</H3>
<PRE>
public boolean <B>hasWaiters</B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</PRE>
<DL>
<DD>이 락에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread가 존재할지 어떨지를 조회합니다. 타임 아웃 및 인터럽트는 언제라도 발생할 가능성이 있기 (위해)때문에,<code>true</code> 가 돌려주어져도, 장래 <code>signal</code> 가 thread를 기동시키는 것은 보증되고 있지 않습니다. 이 메소드는, 주로 시스템 상태의 감시에 사용하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>대기중의 thread가 존재하는 경우는 <code>true</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 이 락을 보관 유지하고 있지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 락과 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitQueueLength(java.util.concurrent.locks.Condition)"><!-- --></A> <H3>
getWaitQueueLength</H3>
<PRE>
public int <B>getWaitQueueLength</B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</PRE>
<DL>
<DD>이 락에 관련지을 수 있었던 지정 상태로 대기중의 thread의 추정수를 돌려줍니다. 타임 아웃 및 인터럽트의 발생할 가능성은 언제라도 존재하기 위해(때문에), 추정수는, 실제의 대기자수에 관한 상한을 나타내는에 지나지 않습니다. 이 메소드는, 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>대기중의 thread의 추정수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 이 락을 보관 유지하고 있지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 락과 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitingThreads(java.util.concurrent.locks.Condition)"><!-- --></A> <H3>
getWaitingThreads</H3>
<PRE>
protected <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getWaitingThreads</B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</PRE>
<DL>
<DD>이 락에 관련지을 수 있었던 지정 상태를 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는, 결과의 구축중에도 동적으로 변화할 가능성이 있기 (위해)때문에, 반환되는 컬렉션은 최선이 노력한 다음의 추정에 지나지 않습니다. 반환되는 컬렉션의 요소에는, 특정의 순서는 존재하지 않습니다. 이 메소드는, 보다 포괄적인 상태 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>thread의 컬렉션
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 이 락을 보관 유지하고 있지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 락과 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - condition 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 락 및 그 상태를 식별하는 캐릭터 라인을 돌려줍니다. 상태는 괄호로 둘러싸여 캐릭터 라인 <code>"Unlocked"</code> 또는 캐릭터 라인 <code>"Locked by"</code> 에 이어, 소유하는 thread의<A HREF="../../../../java/lang/Thread.html#getName()">이름</a>이 포함됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 락 및 그 상태를 식별하는 캐릭터 라인</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ReentrantLock.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html" title="java.util.concurrent.locks 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/locks/ReentrantLock.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ReentrantLock.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
