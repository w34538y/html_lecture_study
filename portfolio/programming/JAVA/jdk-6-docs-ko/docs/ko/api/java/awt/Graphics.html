<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:52:53 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Graphics (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Graphics (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/awt/GradientPaint.html" title="java.awt 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/awt/Graphics2D.html" title="java.awt 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/awt/Graphics.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Graphics.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt</FONT>
<BR>
클래스 Graphics</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.awt.Graphics</B>
</PRE>
<DL>
<DT><B>직계의 기존의 서브 클래스:</B> <DD><A HREF="../../javax/swing/DebugGraphics.html" title="javax.swing 내의 클래스">DebugGraphics</A> , <A HREF="../../java/awt/Graphics2D.html" title="java.awt 안의 클래스">Graphics2D</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>Graphics</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
<code>Graphics</code> 클래스는, 모든 그래픽 문맥의 추상 base class입니다. 그래픽 문맥에 의해 어플리케이션은, 각종 디바이스에 의해 실현되는 컴퍼넌트상이나 오프 스크린 이미지상에 draw 할 수 있습니다.  &nbsp;<p>
<code>Graphics</code> 객체는, Java 가 지원하는 기본적인 draw 조작에 필요한 상태 정보를 캡슐화합니다. 이 상태 정보에는, 다음의 프로퍼티이 있습니다.  &nbsp;<p>
 <ul>
<li>렌더링 대상의 <code>Component</code> 객체
<li>렌더링을 위한 변환의 기점과 클리핑 좌표
<li>현재의 클립  
<li>현재의 색
<li>현재의 폰트
<li>현재의 논리 픽셀 조작 기능 (XOR 또는 Paint)
<li>현재의 XOR 변경색 (<A HREF="../../java/awt/Graphics.html#setXORMode(java.awt.Color)"><CODE>setXORMode(java.awt.Color)</CODE></A>  참조)
 </ul>
 <p>
좌표축은 무한하게 가늘고, 출력 디바이스의 픽셀간에 존재합니다. 도형의 윤곽을 그리는 조작은, 픽셀 사이즈의 펜을 픽셀간의 무한하게 가는 윤곽선에 따라 움직여 가는 것에 의해 동작합니다. 펜은, 윤곽선의 엥커 포인트에 매달려, 한편 우측에 위치하고 있습니다. 도형의 내부를 묻는 조작은, 무한하게 가는 윤곽선의 내부를 묻는 것으로 동작합니다. 수평의 문자를 draw 하는 조작은, baseline 좌표보다 위에 문자 Glyph의 아센다 부분을 모두 draw 합니다.  &nbsp;<p>
그래픽스 펜은 그 궤도의 윤곽선에 매달려, 한편 우측에 위치하고 있습니다. 이것은, 다음 일을 나타냅니다.
 <p><ul>
<li>지정된 구형을 커버하는 도형을 그리는 경우, 그 도형으로 오른쪽과 최하부의 옆에 픽셀을 이제(벌써) 일렬 여분으로 표시하도록(듯이) 한다. 그 점에서, 같은 구형의 내부를 묻는 것과는 다르다
<li>텍스트 라인의 baseline와 같은 <i>y</i> 좌표에 따라 수평선을 그리는 경우, 문자가 baseline보다 아래에 늘어나는 부분을 제외해, 텍스트보다 완전하게 아래에 선을 그린다
 </ul><p>
이 <code>Graphics</code> 의 메소드의 인수로서 사용되는 모든 좌표치는, 메소드의 호출전에, 이 <code>Graphics</code> 객체의 변환 바탕으로 상대적인 것이라고 보여지는 &nbsp;<p>
모든 draw 조작은,<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스"><CODE>Shape</CODE></A>  가 사용자 공간으로 지정해,<code>Graphics</code> 객체를 사용해 프로그램이 제어하는 현재의 클립에 둘러싸인 에리어에 있는 픽셀만을 변경합니다. 이 「사용자 클립」은 디바이스 공간에 변환되어 윈도우의 가시 및 디바이스의 크기에 의해 정의되는 「디바이스 클립」이라고 결합됩니다. 사용자 클립과 디바이스 클립의 결합에 의해, 최종적인 클리핑 영역을 결정하는 「복합 클립」을 정의합니다. draw 시스템은, 사용자 클립을 변경해 복합 클립의 결과를 반영할 수 없습니다. 사용자 클립은 <code>setClip</code> 또는 <code>clipRect</code> 메소드만으로 변경할 수 있습니다. 모든 draw나 기입은, 현재의 색으로, 현재의 페인트 모드와 폰트를 사용해 행해집니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스"><CODE>Component</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>setColor(java.awt.Color)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setPaintMode()"><CODE>setPaintMode()</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setXORMode(java.awt.Color)"><CODE>setXORMode(java.awt.Color)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setFont(java.awt.Font)"><CODE>setFont(java.awt.Font)</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#Graphics()">Graphics</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Graphics</code> 객체를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#clearRect(int, int, int, int)">clearRect</A> </B>(int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형을, 현재의 draw 표면의 백그라운드 칼라로 전부 칠하는 것으로 클리어 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)">clipRect</A> </B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클립과 지정된 구형을 교차시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#copyArea(int, int, int, int, int, int)">copyArea</A> </B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height,
         int&nbsp;dx,
         int&nbsp;dy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 영역을,<code>dx</code> 와 <code>dy</code> 로 지정된 거리로 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#create()">create</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Graphics</code> 객체의 카피인, 새로운 <code>Graphics</code> 객체를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#create(int, int, int, int)">create</A> </B>(int&nbsp;x,
       int&nbsp;y,
       int&nbsp;width,
       int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Graphics</code> 객체에 근거한 새로운 <code>Graphics</code> 객체를, 새로운 변환 및 클립 영역에서 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#dispose()">dispose</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 문맥을 파기해, 사용중의 system resource가 있으면 그것을 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#draw3DRect(int, int, int, int, boolean)">draw3DRect</A> </B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height,
           boolean&nbsp;raised)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형의 윤곽을 3D 로 강조 표시해 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawArc(int, int, int, int, int, int)">drawArc</A> </B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        int&nbsp;startAngle,
        int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형을 커버하는 원호 또는 타원호의 윤곽을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)">drawBytes</A> </B>(byte[]&nbsp;data,
          int&nbsp;offset,
          int&nbsp;length,
          int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 문맥의 현재의 폰트와 색을 사용해, 지정된 바이트 배열에 의해 지정된 텍스트를 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)">drawChars</A> </B>(char[]&nbsp;data,
          int&nbsp;offset,
          int&nbsp;length,
          int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 문맥의 현재의 폰트와 색을 사용해, 지정된 문자 배열에 의해 지정된 텍스트를 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          <A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bgcolor,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이미지의 현재 이용 가능한 부분만큼을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이미지의 현재 이용 가능한 부분만큼을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height,
          <A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bgcolor,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형의 내부에 들어가도록(듯이) 슬캘링 해, 지정된 이미지의 이용 가능한 부분을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형의 내부에 들어가도록(듯이) 슬캘링 해, 지정된 이미지의 이용 가능한 부분을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          int&nbsp;dx1,
          int&nbsp;dy1,
          int&nbsp;dx2,
          int&nbsp;dy2,
          int&nbsp;sx1,
          int&nbsp;sy1,
          int&nbsp;sx2,
          int&nbsp;sy2,
          <A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bgcolor,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이미지의 지정된 영역의 이용 가능한 부분을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          int&nbsp;dx1,
          int&nbsp;dy1,
          int&nbsp;dx2,
          int&nbsp;dy2,
          int&nbsp;sx1,
          int&nbsp;sy1,
          int&nbsp;sx2,
          int&nbsp;sy2,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이미지의 지정된 영역의 이용 가능한 부분을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawLine(int, int, int, int)">drawLine</A> </B>(int&nbsp;x1,
         int&nbsp;y1,
         int&nbsp;x2,
         int&nbsp;y2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 문맥의 좌표계의 점 <code>(x1, &nbsp;y1)</code> 과 점 <code>(x2, &nbsp;y2)</code> 과의 사이에 현재의 색을 사용해 선을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawOval(int, int, int, int)">drawOval</A> </B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;타원의 윤곽을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawPolygon(int[], int[], int)">drawPolygon</A> </B>(int[]&nbsp;xPoints,
            int[]&nbsp;yPoints,
            int&nbsp;nPoints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>x</i> 좌표와 <i>y</i> 좌표의 배열로 정의된 닫은 다각형을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawPolygon(java.awt.Polygon)">drawPolygon</A> </B>(<A HREF="../../java/awt/Polygon.html" title="java.awt 안의 클래스">Polygon</A> &nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>Polygon</code> 객체에 의해 정의되는 다각형의 윤곽을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawPolyline(int[], int[], int)">drawPolyline</A> </B>(int[]&nbsp;xPoints,
             int[]&nbsp;yPoints,
             int&nbsp;nPoints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>x</i> 좌표와 <i>y</i> 좌표의 배열로 정의되고 연속적으로 연결된 직선을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawRect(int, int, int, int)">drawRect</A> </B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형의 윤곽을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawRoundRect(int, int, int, int, int, int)">drawRoundRect</A> </B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height,
              int&nbsp;arcWidth,
              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;둥근 코너 첨부의 윤곽의 구형을, 이 그래픽스 문맥의 현재의 색을 사용해 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawString(java.text.AttributedCharacterIterator, int, int)">drawString</A> </B>(<A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;iterator,
           int&nbsp;x,
           int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 반복자에 의해 텍스트를 그려,<A HREF="../../java/awt/font/TextAttribute.html" title="java.awt.font 안의 클래스"><CODE>TextAttribute</CODE></A>  클래스의 스펙에 근거해 속성을 적용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawString(java.lang.String, int, int)">drawString</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str,
           int&nbsp;x,
           int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 문맥의 현재의 폰트와 색을 사용해, 지정된 캐릭터 라인에 의해 지정된 텍스트를 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fill3DRect(int, int, int, int, boolean)">fill3DRect</A> </B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height,
           boolean&nbsp;raised)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 색으로 전부 칠해지고 있는, 3D 로 강조 표시된 구형을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fillArc(int, int, int, int, int, int)">fillArc</A> </B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        int&nbsp;startAngle,
        int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형을 커버하는 원호 또는 타원호를 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fillOval(int, int, int, int)">fillOval</A> </B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형안의 타원형을 현재의 색으로 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fillPolygon(int[], int[], int)">fillPolygon</A> </B>(int[]&nbsp;xPoints,
            int[]&nbsp;yPoints,
            int&nbsp;nPoints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>x</i> 좌표와 <i>y</i> 좌표의 배열로 정의되는 닫은 다각형을 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fillPolygon(java.awt.Polygon)">fillPolygon</A> </B>(<A HREF="../../java/awt/Polygon.html" title="java.awt 안의 클래스">Polygon</A> &nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Polygon 객체로 정의된 다각형을 그래픽스 문맥의 현재의 색으로 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fillRect(int, int, int, int)">fillRect</A> </B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형을 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fillRoundRect(int, int, int, int, int, int)">fillRoundRect</A> </B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height,
              int&nbsp;arcWidth,
              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 둥근 코너 첨부의 구형을 현재의 색으로 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#finalize()">finalize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;참조되지 않게 된, 이 그래픽스 문맥을 파기합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getClip()">getClip</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클리핑 영역을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getClipBounds()">getClipBounds</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클리핑 영역의 경계의 구형을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getClipBounds(java.awt.Rectangle)">getClipBounds</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클리핑 영역의 경계의 구형을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getClipRect()">getClipRect</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK version 1.1 이후는,
 <code>getClipBounds()</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getColor()">getColor</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 문맥의 현재의 색을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Font.html" title="java.awt 내의 클래스">Font</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getFont()">getFont</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 폰트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/FontMetrics.html" title="java.awt 내의 클래스">FontMetrics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getFontMetrics()">getFontMetrics</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 폰트의 폰트 시학을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/FontMetrics.html" title="java.awt 내의 클래스">FontMetrics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getFontMetrics(java.awt.Font)">getFontMetrics</A> </B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 폰트의 폰트 시학을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#hitClip(int, int, int, int)">hitClip</A> </B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형 영역이 현재의 클리핑 영역과 교차하는 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)">setClip</A> </B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정한 좌표가 지정한 구형에 현재의 클립을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)">setClip</A> </B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;clip)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클리핑 영역을 임의의 클립 형상으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)">setColor</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 문맥의 현재의 색을, 지정된 색으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#setFont(java.awt.Font)">setFont</A> </B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 문맥의 폰트를, 지정된 폰트로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#setPaintMode()">setPaintMode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 문맥의 현재의 색으로 목적지를 덧쓰기하도록(듯이), 페인트 모드를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#setXORMode(java.awt.Color)">setXORMode</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;c1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 문맥의 현재의 색과 새롭게 지정된 색을 바꾸도록(듯이), 그래픽스 문맥의 페인트 모드를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Graphics</code> 객체의 값을 표현하고 있는,<code>String</code> 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#translate(int, int)">translate</A> </B>(int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그래픽스 문맥의 원점을 현재의 좌표계의 점 (<i>x</i>, &nbsp;<i>y</i>)으로 변환합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Graphics()"><!-- --></A> <H3>
Graphics</H3>
<PRE>
protected <B>Graphics</B>()</PRE>
<DL>
<DD>새로운 <code>Graphics</code> 객체를 작성합니다. 이 생성자 은, 그래픽스 문맥의 디폴트 생성자 입니다.  &nbsp;<p>
<code>Graphics</code> 는 abstract 클래스이므로, 어플리케이션은 이 생성자 을 직접 호출할 수 없습니다. 그래픽스 문맥은, 다른 그래픽스 문맥으로부터 취득되는지, 컴퍼넌트로 <code>getGraphics</code> 를 호출하는 것에 의해 작성됩니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#create()"><CODE>create()</CODE></A> , 
<A HREF="../../java/awt/Component.html#getGraphics()"><CODE>Component.getGraphics()</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="create()"><!-- --></A> <H3>
create</H3>
<PRE>
public abstract <A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A>  <B>create</B>()</PRE>
<DL>
<DD>이 <code>Graphics</code> 객체의 카피인, 새로운 <code>Graphics</code> 객체를 작성합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 그래픽스 문맥의 카피인, 
                       새로운 그래픽스 문맥</DL>
</DD>
</DL>
<HR>

<A NAME="create(int, int, int, int)"><!-- --></A> <H3>
create</H3>
<PRE>
public <A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A>  <B>create</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height)</PRE>
<DL>
<DD>이 <code>Graphics</code> 객체에 근거한 새로운 <code>Graphics</code> 객체를, 새로운 변환 및 클립 영역에서 작성합니다. 새로운 <code>Graphics</code> 객체는 그 원점을, 지정된 점 (<i>x</i>, &nbsp;<i>y</i>)에 변환시킵니다. 그 클립 영역은, 원의 클립 영역과 지정된 구형과의 공통 부분에서 지정됩니다. 인수는 모두, 원의 <code>Graphics</code> 객체의 좌표계에 변환됩니다. 새로운 그래픽스 문맥은, 다음의 2 점 이외에 붙어 원의 그래픽스 문맥과 같습니다.  &nbsp;<p>
 <ul>
 <li>
새로운 그래픽스 문맥은 (<i>x</i>, &nbsp;<i>y</i>)에 의해 변환된다. 즉, 새로운 그래픽스 문맥의 점 (<code>0</code>, &nbsp;<code>0</code>)은 원의 그래픽스 문맥의 점 (<i>x</i>, &nbsp;<i>y</i>)과 같게된다 
 <li>
새로운 그래픽스 문맥은, 원의 그래픽스 문맥으로부터 상속된 변환 후의 클리핑 구형이 무엇으로 있을것이다와 추가의 클리핑 구형을 가진다. 새로운 클리핑 구형의 원점은 (<code>0</code>, &nbsp;<code>0</code>)에 있어, 그 사이즈는 <code>width</code> 인수와 <code>height</code> 인수로 지정된다
 </ul>
 <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표<DD><CODE>width</CODE> - 클리핑 구형의 폭<DD><CODE>height</CODE> - 클리핑 구형의 높이
<DT><B>반환값:</B><DD>새로운 그래픽스 문맥<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#translate(int, int)"><CODE>translate(int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="translate(int, int)"><!-- --></A> <H3>
translate</H3>
<PRE>
public abstract void <B>translate</B>(int&nbsp;x,
                               int&nbsp;y)</PRE>
<DL>
<DD>그래픽스 문맥의 원점을 현재의 좌표계의 점 (<i>x</i>, &nbsp;<i>y</i>)으로 변환합니다. 이 그래픽스 문맥을, 새로운 원점이 이 그래픽스 문맥의 원의 좌표계의 점 (<i>x</i>, &nbsp;<i>y</i>)에 일치하도록(듯이) 변경합니다. 이 그래픽스 문맥에 행해진, 이 이후의 draw 조작에 사용되는 좌표는 모두 이 원점에 상대적인 값이 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="getColor()"><!-- --></A> <H3>
getColor</H3>
<PRE>
public abstract <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>getColor</B>()</PRE>
<DL>
<DD>이 그래픽스 문맥의 현재의 색을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 그래픽스 문맥의 현재의 색<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스"><CODE>Color</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>setColor(Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setColor(java.awt.Color)"><!-- --></A> <H3>
setColor</H3>
<PRE>
public abstract void <B>setColor</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;c)</PRE>
<DL>
<DD>이 그래픽스 문맥의 현재의 색을, 지정된 색으로 설정합니다. 이 그래픽스 문맥을 사용하는 이 이후의 그래픽 관련 조작은, 여기서 지정된 색을 사용합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 새로운 draw색<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스"><CODE>Color</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#getColor()"><CODE>getColor()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPaintMode()"><!-- --></A> <H3>
setPaintMode</H3>
<PRE>
public abstract void <B>setPaintMode</B>()</PRE>
<DL>
<DD>이 그래픽스 문맥의 현재의 색으로 목적지를 덧쓰기하도록(듯이), 페인트 모드를 설정합니다. 이것은, 논리 픽셀 조작 기능을 페인트 모드, 즉 덧쓰기 모드(replace mode)로 설정합니다. 이 이후의 draw 조작은, 목적지를 현재의 색으로 덧쓰기합니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setXORMode(java.awt.Color)"><!-- --></A> <H3>
setXORMode</H3>
<PRE>
public abstract void <B>setXORMode</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;c1)</PRE>
<DL>
<DD>이 그래픽스 문맥의 현재의 색과 새롭게 지정된 색을 바꾸도록(듯이), 그래픽스 문맥의 페인트 모드를 설정합니다. 이것은, 논리 픽셀 조작을 XOR 모드로 실행하도록(듯이) 지정합니다. XOR 모드에서는, 픽셀은 현재의 색과 지정된 XOR 교대색의 사이를 교대로 바뀝니다.  &nbsp;<p>
draw 조작을 실행하면(자), 현재의 색의 픽셀이 지정된 색에 바뀌어, 그 역도 들어맞읍니다.  &nbsp;<p>
여기서 다루어진 2 색 이외의 색을 가지는 픽셀은 예상할 수 없는 색에 변화합니다만, 그것들은 바탕으로 되돌릴 수 있게 되어 있습니다. 같은 그림을 2 회 draw 하면, 모든 픽셀은 초기의 설정색에 돌아옵니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c1</CODE> - XOR 의 교대색</DL>
</DD>
</DL>
<HR>

<A NAME="getFont()"><!-- --></A> <H3>
getFont</H3>
<PRE>
public abstract <A HREF="../../java/awt/Font.html" title="java.awt 내의 클래스">Font</A>  <B>getFont</B>()</PRE>
<DL>
<DD>현재의 폰트를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 그래픽스 문맥의 현재의 폰트<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Font.html" title="java.awt 내의 클래스"><CODE>Font</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setFont(java.awt.Font)"><CODE>setFont(Font)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setFont(java.awt.Font)"><!-- --></A> <H3>
setFont</H3>
<PRE>
public abstract void <B>setFont</B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font)</PRE>
<DL>
<DD>이 그래픽스 문맥의 폰트를, 지정된 폰트로 설정합니다. 이 그래픽스 문맥을 사용하는, 이 이후의 텍스트 draw 조작은, 이 폰트를 사용합니다. null 인수는 통지 없게 무시됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>font</CODE> - 폰트<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#getFont()"><CODE>getFont()</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#drawString(java.lang.String, int, int)"><CODE>drawString(java.lang.String, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)"><CODE>drawBytes(byte[], int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)"><CODE>drawChars(char[], int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getFontMetrics()"><!-- --></A> <H3>
getFontMetrics</H3>
<PRE>
public <A HREF="../../java/awt/FontMetrics.html" title="java.awt 내의 클래스">FontMetrics</A>  <B>getFontMetrics</B>()</PRE>
<DL>
<DD>현재의 폰트의 폰트 시학을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 그래픽스 문맥의 현재의 폰트의 
                    폰트메트릭스<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#getFont()"><CODE>getFont()</CODE></A> , 
<A HREF="../../java/awt/FontMetrics.html" title="java.awt 안의 클래스"><CODE>FontMetrics</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#getFontMetrics(java.awt.Font)"><CODE>getFontMetrics(Font)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getFontMetrics(java.awt.Font)"><!-- --></A> <H3>
getFontMetrics</H3>
<PRE>
public abstract <A HREF="../../java/awt/FontMetrics.html" title="java.awt 내의 클래스">FontMetrics</A>  <B>getFontMetrics</B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;f)</PRE>
<DL>
<DD>지정된 폰트의 폰트 시학을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>f</CODE> - 지정된 폰트
<DT><B>반환값:</B><DD>지정된 폰트의 폰트메트릭스<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#getFont()"><CODE>getFont()</CODE></A> , 
<A HREF="../../java/awt/FontMetrics.html" title="java.awt 안의 클래스"><CODE>FontMetrics</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#getFontMetrics()"><CODE>getFontMetrics()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getClipBounds()"><!-- --></A> <H3>
getClipBounds</H3>
<PRE>
public abstract <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getClipBounds</B>()</PRE>
<DL>
<DD>현재의 클리핑 영역의 경계의 구형을 돌려줍니다. 이 메소드는, 디바이스 경계나 윈도우 가시에 관련한 클리핑에는 의존하지 않는 사용자 클립을 참조합니다. 클립이 설정되어 있지 않은 경우, 또는 클립이 <code>setClip(null)</code> 를 사용해 클리어 되고 있는 경우는, 이 메소드는 <code>null</code> 를 돌려줍니다. 구형내의 좌표는 이 그래픽스 문맥의 좌표계의 원점을 기준으로 하고 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 클리핑 영역의 경계의 구형,
              클립이 설정되어 있지 않은 경우는 <code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#getClip()"><CODE>getClip()</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)"><CODE>setClip(Shape)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="clipRect(int, int, int, int)"><!-- --></A> <H3>
clipRect</H3>
<PRE>
public abstract void <B>clipRect</B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height)</PRE>
<DL>
<DD>현재의 클립과 지정된 구형을 교차시킵니다. 결과가 클립 되는 영역은 현재의 클리핑 영역과 지정한 구형의 교차 부분입니다. 클립이 설정되었던 적이 없는가, 또는 클립이 <code>setClip(null)</code> 를 사용해 클리어 되었기 때문에 현재의 클리핑 영역이 없는 경우는, 지정한 구형이 새로운 클립이 됩니다. 이 메소드는, 디바이스 경계나 윈도우 가시에 관련한 크리크핑에 의존하지 않는 사용자 클립을 설정합니다. 이 메소드는 현재의 클립을 작게 하는 경우에 한정해 사용할 수 있습니다. 현재의 클립을 크게 하려면 , 임의의 setClip 메소드를 사용합니다. 클리핑 영역외에서 draw 조작을 행해도 효과는 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 교차해 클립 하는 구형의 x 좌표<DD><CODE>y</CODE> - 교차해 클립 하는 구형의 y 좌표<DD><CODE>width</CODE> - 교차해 클립 하는 구형의 폭<DD><CODE>height</CODE> - 교차해 클립 하는 구형의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)"><CODE>setClip(Shape)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setClip(int, int, int, int)"><!-- --></A> <H3>
setClip</H3>
<PRE>
public abstract void <B>setClip</B>(int&nbsp;x,
                             int&nbsp;y,
                             int&nbsp;width,
                             int&nbsp;height)</PRE>
<DL>
<DD>지정한 좌표가 지정한 구형에 현재의 클립을 설정합니다. 이 메소드는, 디바이스 경계나 윈도우 가시에 관련한 크리크핑에 의존하지 않는 사용자 클립을 설정합니다. 클리핑 영역외에서 draw 조작을 행해도 효과는 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 새로운 클립 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 새로운 클립 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 새로운 클립 구형의 폭<DD><CODE>height</CODE> - 새로운 클립 구형의 높이<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)"><CODE>setClip(Shape)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#getClip()"><CODE>getClip()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getClip()"><!-- --></A> <H3>
getClip</H3>
<PRE>
public abstract <A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getClip</B>()</PRE>
<DL>
<DD>현재의 클리핑 영역을 돌려줍니다. 이 메소드는, 디바이스 경계나 윈도우 가시에 관련한 클리핑에는 의존하지 않는 사용자 클립을 돌려줍니다. 클립이 설정되어 있지 않은 경우, 또는 클립이 <code>setClip(null)</code> 를 사용해 클리어 되고 있는 경우는, 이 메소드는 <code>null</code> 를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 클리핑 영역을 나타내는 <code>Shape</code>  
              객체. 클립이 설정되어 있지 않은 경우는 
              <code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#getClipBounds()"><CODE>getClipBounds()</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)"><CODE>setClip(Shape)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setClip(java.awt.Shape)"><!-- --></A> <H3>
setClip</H3>
<PRE>
public abstract void <B>setClip</B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;clip)</PRE>
<DL>
<DD>현재의 클리핑 영역을 임의의 클립 형상으로 설정합니다. 클립을 설정하기 위해서,<code>Shape</code> 인터페이스를 구현하는 모든 객체를 사용할 수 있는 것은 아닙니다. 지원가 보증되고 있는 유일한 <code>Shape</code> 객체는,<code>getClip</code> 메소드를 사용할까 <code>Rectangle</code> 객체를 사용해 취득되는 <code>Shape</code> 객체 뿐입니다. 이 메소드는, 디바이스 경계나 윈도우 가시에 관련한 크리크핑에 의존하지 않는 사용자 클립을 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>clip</CODE> - 클립 설정에 사용하는 <code>Shape</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#getClip()"><CODE>getClip()</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="copyArea(int, int, int, int, int, int)"><!-- --></A> <H3>
copyArea</H3>
<PRE>
public abstract void <B>copyArea</B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height,
                              int&nbsp;dx,
                              int&nbsp;dy)</PRE>
<DL>
<DD>컴퍼넌트의 영역을,<code>dx</code> 와 <code>dy</code> 로 지정된 거리로 카피합니다. 이 메소드는 <code>x</code> 와 <code>y</code> 로 지정된 점으로부터, 컴퍼넌트의 아래방향 및 우측향의 영역을 카피합니다. 컴퍼넌트의 좌방향 및 윗방향의 영역을 카피하려면 ,<code>dx</code> 와 <code>dy</code> 에 0 보다 작은 값을 지정합니다. 소스의 구형이 있는 부분이 컴퍼넌트의 경계외에 있는 경우나 다른 컴퍼넌트나 윈도우로 숨겨지고 있는 경우는,<code>copyArea</code> 는 대응하고 있는 픽셀을 카피할 수 없습니다. 숨겨진 영역은, 그 컴퍼넌트의 <code>paint</code> 메소드를 호출하는 것으로 재draw 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 소스 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 소스 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 소스 구형의 폭<DD><CODE>height</CODE> - 소스 구형의 높이<DD><CODE>dx</CODE> - 픽셀을 카피하는 수평거리<DD><CODE>dy</CODE> - 픽셀을 카피하는 수직 거리</DL>
</DD>
</DL>
<HR>

<A NAME="drawLine(int, int, int, int)"><!-- --></A> <H3>
drawLine</H3>
<PRE>
public abstract void <B>drawLine</B>(int&nbsp;x1,
                              int&nbsp;y1,
                              int&nbsp;x2,
                              int&nbsp;y2)</PRE>
<DL>
<DD>이 그래픽스 문맥의 좌표계의 점 <code>(x1, &nbsp;y1)</code> 과 점 <code>(x2, &nbsp;y2)</code> 과의 사이에 현재의 색을 사용해 선을 그립니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x1</CODE> - 최초의 점의 <i>x</i> 좌표<DD><CODE>y1</CODE> - 최초의 점의 <i>y</i> 좌표<DD><CODE>x2</CODE> - 2 번째의 점의 <i>x</i> 좌표<DD><CODE>y2</CODE> - 2 번째의 점의 <i>y</i> 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="fillRect(int, int, int, int)"><!-- --></A> <H3>
fillRect</H3>
<PRE>
public abstract void <B>fillRect</B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height)</PRE>
<DL>
<DD>지정된 구형을 전부 칠합니다. 구형의 좌단과 우단은 각각 <code>x</code> 와 <code>x&nbsp;+&nbsp;width&nbsp;-&nbsp;1</code> 로, 상단과 하단은 각각 <code>y</code> 와 <code>y&nbsp;+&nbsp;height&nbsp;-&nbsp;1</code> 입니다. 이것으로 지정되는 구형은, 폭 <code>width</code> 픽셀, 높이 <code>height</code> 픽셀의 영역입니다. 구형은, 그래픽스 문맥의 현재의 색을 사용해 전부 칠해집니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 전부 칠해진다 
                         구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 전부 칠해진다 
                         구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 전부 칠해지는 구형의 폭<DD><CODE>height</CODE> - 전부 칠해지는 구형의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#clearRect(int, int, int, int)"><CODE>clearRect(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#drawRect(int, int, int, int)"><CODE>drawRect(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawRect(int, int, int, int)"><!-- --></A> <H3>
drawRect</H3>
<PRE>
public void <B>drawRect</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>지정된 구형의 윤곽을 그립니다. 구형은, 좌단과 우단이 각각 <code>x</code> 와 <code>x&nbsp;+&nbsp;width</code>, 상단과 하단이 각각 <code>y</code> 와 <code>y&nbsp;+&nbsp;height</code> 로 지정됩니다. 구형은, 그래픽스 문맥의 현재의 색을 사용해 draw 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - draw 된다 
                         구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - draw 된다 
                         구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - draw 되는 구형의 폭<DD><CODE>height</CODE> - draw 되는 구형의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillRect(int, int, int, int)"><CODE>fillRect(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#clearRect(int, int, int, int)"><CODE>clearRect(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="clearRect(int, int, int, int)"><!-- --></A> <H3>
clearRect</H3>
<PRE>
public abstract void <B>clearRect</B>(int&nbsp;x,
                               int&nbsp;y,
                               int&nbsp;width,
                               int&nbsp;height)</PRE>
<DL>
<DD>지정된 구형을, 현재의 draw 표면의 백그라운드 칼라로 전부 칠하는 것으로 클리어 합니다. 이 조작은, 현재의 페인트 모드를 사용하지 않습니다.  &nbsp;<p>
Java&nbsp;1. 1 이후는, 오프 스크린의 이미지의 백그라운드 칼라는 시스템에 의해 다릅니다. 어플리케이션은 <code>setColor</code> 에 이어 <code>fillRect</code> 를 사용하는 것에 의해, 오프 스크린 이미지를 클리어 해 특정의 색으로 하는 것을 보증합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 클리어 대상의 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 클리어 대상의 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 클리어 대상의 구형의 폭<DD><CODE>height</CODE> - 클리어 대상의 구형의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillRect(int, int, int, int)"><CODE>fillRect(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#drawRect(int, int, int, int)"><CODE>drawRect(int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>setColor(java.awt.Color)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setPaintMode()"><CODE>setPaintMode()</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#setXORMode(java.awt.Color)"><CODE>setXORMode(java.awt.Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawRoundRect(int, int, int, int, int, int)"><!-- --></A> <H3>
drawRoundRect</H3>
<PRE>
public abstract void <B>drawRoundRect</B>(int&nbsp;x,
                                   int&nbsp;y,
                                   int&nbsp;width,
                                   int&nbsp;height,
                                   int&nbsp;arcWidth,
                                   int&nbsp;arcHeight)</PRE>
<DL>
<DD>둥근 코너 첨부의 윤곽의 구형을, 이 그래픽스 문맥의 현재의 색을 사용해 그립니다. 그려지는 구형은, 좌단과 우단이 각각 <code>x</code> 와 <code>x&nbsp;+&nbsp;width</code>, 상단과 하단이 각각 <code>y</code> 와 <code>y&nbsp;+&nbsp;height</code> 로 지정됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - draw 되는 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - draw 되는 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - draw 되는 구형의 폭<DD><CODE>height</CODE> - draw 되는 구형의 높이<DD><CODE>arcWidth</CODE> - 4 구석의 호의 수평 방향의 
                    직경<DD><CODE>arcHeight</CODE> - 4 구석의 호의 수직 방향의 
                    직경<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillRoundRect(int, int, int, int, int, int)"><CODE>fillRoundRect(int, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fillRoundRect(int, int, int, int, int, int)"><!-- --></A> <H3>
fillRoundRect</H3>
<PRE>
public abstract void <B>fillRoundRect</B>(int&nbsp;x,
                                   int&nbsp;y,
                                   int&nbsp;width,
                                   int&nbsp;height,
                                   int&nbsp;arcWidth,
                                   int&nbsp;arcHeight)</PRE>
<DL>
<DD>지정된 둥근 코너 첨부의 구형을 현재의 색으로 전부 칠합니다. 구형은, 좌단과 우단이 각각 <code>x</code> 와 <code>x&nbsp;+&nbsp;width&nbsp;-&nbsp;1</code>, 상단과 하단이 각각 <code>y</code> 와 <code>y&nbsp;+&nbsp;height&nbsp;-&nbsp;1</code> 로 지정됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 전부 칠해지는 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 전부 칠해지는 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 전부 칠해지는 구형의 폭<DD><CODE>height</CODE> - 전부 칠해지는 구형의 높이<DD><CODE>arcWidth</CODE> - 4 구석의 호의 수평 방향의 
                     직경<DD><CODE>arcHeight</CODE> - 4 구석의 호의 수직 방향의 
                     직경<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawRoundRect(int, int, int, int, int, int)"><CODE>drawRoundRect(int, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="draw3DRect(int, int, int, int, boolean)"><!-- --></A> <H3>
draw3DRect</H3>
<PRE>
public void <B>draw3DRect</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       boolean&nbsp;raised)</PRE>
<DL>
<DD>지정된 구형의 윤곽을 3D 로 강조 표시해 draw 합니다. 구형의 구석은, 경사해, 좌상구석으로부터 빛을 쬔 것처럼 강조 표시됩니다.  &nbsp;<p>
강조 표시 효과에 사용되는 색은, 현재의 색에 근거해 지정됩니다. draw 된 구형은, 폭 <code>width&nbsp;+&nbsp;1</code> 픽셀, 높이 <code>height&nbsp;+&nbsp;1</code> 픽셀의 영역을 커버합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - draw 되는 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - draw 되는 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - draw 되는 구형의 폭<DD><CODE>height</CODE> - draw 되는 구형의 높이<DD><CODE>raised</CODE> - 구형이 표면으로부터 떠오른 것처럼 보이는지,
                      표면에 조각해 붐비어진 것처럼 보이는지를 지정한다  
                      boolean 치<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fill3DRect(int, int, int, int, boolean)"><CODE>fill3DRect(int, int, int, int, boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fill3DRect(int, int, int, int, boolean)"><!-- --></A> <H3>
fill3DRect</H3>
<PRE>
public void <B>fill3DRect</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       boolean&nbsp;raised)</PRE>
<DL>
<DD>현재의 색으로 전부 칠해지고 있는, 3D 로 강조 표시된 구형을 그립니다. 구형의 구석은 경사를 붙일 수 있는 좌상구석으로부터 빛을 쬘 수 있던 것처럼 강조 표시됩니다. 강조 표시 효과에 사용되는 색은 현재의 색으로부터 결정됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 전부 칠해지는 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 전부 칠해지는 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 전부 칠해지는 구형의 폭<DD><CODE>height</CODE> - 전부 칠해지는 구형의 높이<DD><CODE>raised</CODE> - 구형이 표면으로부터 떠오른 것처럼 보이는지, 
                      표면에 조각해 붐비어진 것처럼 보이는지를 지정한다  
                      boolean 치<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#draw3DRect(int, int, int, int, boolean)"><CODE>draw3DRect(int, int, int, int, boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawOval(int, int, int, int)"><!-- --></A> <H3>
drawOval</H3>
<PRE>
public abstract void <B>drawOval</B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height)</PRE>
<DL>
<DD>타원의 윤곽을 그립니다. 인수의 <code>x</code>,<code>y</code>,<code>width</code>,<code>height</code> 로 지정되는 구형내에 들어가는 엔 또는 타원이 그려집니다.  
 <p> 
타원은, 폭 <code>width&nbsp;+&nbsp;1</code> 픽셀, 높이 <code>height&nbsp;+&nbsp;1</code> 픽셀의 영역을 커버합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - draw 되는 타원의 좌상구석의  
                     <i>x</i> 좌표<DD><CODE>y</CODE> - draw 되는 타원의 좌상구석의  
                     <i>y</i> 좌표<DD><CODE>width</CODE> - draw 되는 타원의 폭<DD><CODE>height</CODE> - draw 되는 타원의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillOval(int, int, int, int)"><CODE>fillOval(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fillOval(int, int, int, int)"><!-- --></A> <H3>
fillOval</H3>
<PRE>
public abstract void <B>fillOval</B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height)</PRE>
<DL>
<DD>지정된 구형안의 타원형을 현재의 색으로 전부 칠합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 전부 칠해지는 타원의 좌상구석의  
                     <i>x</i> 좌표<DD><CODE>y</CODE> - 전부 칠해지는 타원의 좌상구석의  
                     <i>y</i> 좌표<DD><CODE>width</CODE> - 전부 칠해지는 타원의 폭<DD><CODE>height</CODE> - 전부 칠해지는 타원의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawOval(int, int, int, int)"><CODE>drawOval(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawArc(int, int, int, int, int, int)"><!-- --></A> <H3>
drawArc</H3>
<PRE>
public abstract void <B>drawArc</B>(int&nbsp;x,
                             int&nbsp;y,
                             int&nbsp;width,
                             int&nbsp;height,
                             int&nbsp;startAngle,
                             int&nbsp;arcAngle)</PRE>
<DL>
<DD>지정된 구형을 커버하는 원호 또는 타원호의 윤곽을 그립니다.  &nbsp;<p>
<code>startAngle</code> 로부터 시작되어 <code>arcAngle</code> 의 각도로 전개된 호가, 현재의 색을 사용해 그려집니다. 각도는 3 시의 위치를 0 번으로서 변환되어 정의 값은 반시계방향, 0 보다 작은 값은 시계 방향의 회전을 나타냅니다.  &nbsp;<p>
호의 중심은, 원점이 (<i>x</i>, &nbsp;<i>y</i>)로, 사이즈가 <code>width</code> 인수와 <code>height</code> 인수로 지정되는 구형의 중심이 됩니다.  &nbsp;<p>
그려지는 호는, 폭 <code>width&nbsp;+&nbsp;1</code> 픽셀, 높이 <code>height&nbsp;+&nbsp;1</code> 픽셀의 영역을 커버합니다.  &nbsp;<p>
각도의 확대는, 직각이 아닌, 경계의 구형을 기준으로 지정해, 타원의 중심으로부터 경계의 구형의 우상구석까지를 묶는 선이 항상 45 번이 되도록(듯이) 합니다. 경계의 구형의 축의 길이가 꽤 다른 경우에는, 호세그먼트(segment)의 개시 각도와 종료 각도는 경계의 타원에 있어 가장 긴 직경에 따라 한층 더 경사합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - draw 되는 호의 좌상구석의  
                    <i>x</i> 좌표<DD><CODE>y</CODE> - draw 되는 호의 좌상구석의  
                    <i>y</i> 좌표<DD><CODE>width</CODE> - draw 되는 고의 폭<DD><CODE>height</CODE> - draw 되는 고의 높이<DD><CODE>startAngle</CODE> - 개시 각도<DD><CODE>arcAngle</CODE> - 개시 각도에 대한 호의 
                    전개 각도의 크기<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillArc(int, int, int, int, int, int)"><CODE>fillArc(int, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fillArc(int, int, int, int, int, int)"><!-- --></A> <H3>
fillArc</H3>
<PRE>
public abstract void <B>fillArc</B>(int&nbsp;x,
                             int&nbsp;y,
                             int&nbsp;width,
                             int&nbsp;height,
                             int&nbsp;startAngle,
                             int&nbsp;arcAngle)</PRE>
<DL>
<DD>지정된 구형을 커버하는 원호 또는 타원호를 전부 칠합니다.  &nbsp;<p>
<code>startAngle</code> 로부터 시작되어 <code>arcAngle</code> 의 각도로 전개된 호가 그려집니다. 각도는 3 시의 위치를 0 번으로서 변환되어 정의 값은 반시계방향, 0 보다 작은 값은 시계 방향의 회전을 나타냅니다.  &nbsp;<p>
호의 중심은, 원점이 (<i>x</i>, &nbsp;<i>y</i>)로, 사이즈가 <code>width</code> 인수와 <code>height</code> 인수로 지정되는 구형의 중심이 됩니다.  &nbsp;<p>
그려지는 호는, 폭 <code>width&nbsp;+&nbsp;1</code> 픽셀, 높이 <code>height&nbsp;+&nbsp;1</code> 픽셀의 영역을 커버합니다.  &nbsp;<p>
각도의 확대는, 직각이 아닌, 경계의 구형을 기준으로 지정해, 타원의 중심으로부터 경계의 구형의 우상구석까지를 묶는 선이 항상 45 번이 되도록(듯이) 합니다. 경계의 구형의 축의 길이가 꽤 다른 경우에는, 호세그먼트(segment)의 개시 각도와 종료 각도는 경계의 타원에 있어 가장 긴 직경에 따라 한층 더 경사합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 전부 칠해지는 호의 좌상구석의  
                    <i>x</i> 좌표<DD><CODE>y</CODE> - 전부 칠해지는 호의 좌상구석의  
                    <i>y</i> 좌표<DD><CODE>width</CODE> - 전부 칠해지는 고의 폭<DD><CODE>height</CODE> - 전부 칠해지는 고의 높이<DD><CODE>startAngle</CODE> - 개시 각도<DD><CODE>arcAngle</CODE> - 개시 각도에 대한 호의 
                    전개 각도의 크기<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawArc(int, int, int, int, int, int)"><CODE>drawArc(int, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawPolyline(int[], int[], int)"><!-- --></A> <H3>
drawPolyline</H3>
<PRE>
public abstract void <B>drawPolyline</B>(int[]&nbsp;xPoints,
                                  int[]&nbsp;yPoints,
                                  int&nbsp;nPoints)</PRE>
<DL>
<DD><i>x</i> 좌표와 <i>y</i> 좌표의 배열로 정의되고 연속적으로 연결된 직선을 그립니다. 좌표 (<i>x</i>, &nbsp;<i>y</i>)의 각 페어는 점을 정의합니다. 최초의 좌표와 마지막 좌표가 일치하지 않는 경우, 도형은 닫지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>xPoints</CODE> - <i>x</i> 점의 배열<DD><CODE>yPoints</CODE> - <i>y</i> 점의 배열<DD><CODE>nPoints</CODE> - 점의 총수<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawPolygon(int[], int[], int)"><CODE>drawPolygon(int[], int[], int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawPolygon(int[], int[], int)"><!-- --></A> <H3>
drawPolygon</H3>
<PRE>
public abstract void <B>drawPolygon</B>(int[]&nbsp;xPoints,
                                 int[]&nbsp;yPoints,
                                 int&nbsp;nPoints)</PRE>
<DL>
<DD><i>x</i> 좌표와 <i>y</i> 좌표의 배열로 정의된 닫은 다각형을 그립니다. 좌표 (<i>x</i>, &nbsp;<i>y</i>)의 각 페어는 점을 정의합니다.  &nbsp;<p>
이 메소드는,<code>nPoint</code> 라인 세그먼트(segment)에 의해 정의되는 다각형을 그립니다.  이 경우, 최초의 <code>nPoint&nbsp;-&nbsp;1</code> 라인 세그먼트(segment)는, 1 &nbsp;&le;&nbsp;<i>i</i>&nbsp;&le;&nbsp;<code>nPoints</code> 에 대한,<code>(xPoints[i&nbsp;-&nbsp;1], &nbsp;yPoints[i&nbsp;-&nbsp;1])</code> 로부터 <code>(xPoints[i], &nbsp;yPoints[i])</code> 까지의 라인 세그먼트(segment)입니다. 마지막 점과 최초의 점이 일치하지 않는 경우, 그것들을 접속하는 라인을 draw 하면 그림은 자동적으로 덮습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>xPoints</CODE> - <code>x</code> 좌표의 배열<DD><CODE>yPoints</CODE> - <code>y</code> 좌표의 배열<DD><CODE>nPoints</CODE> - 점의 총수<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillPolygon(int[], int[], int)"><CODE>fillPolygon(int[], int[], int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#drawPolyline(int[], int[], int)"><CODE>drawPolyline(int[], int[], int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawPolygon(java.awt.Polygon)"><!-- --></A> <H3>
drawPolygon</H3>
<PRE>
public void <B>drawPolygon</B>(<A HREF="../../java/awt/Polygon.html" title="java.awt 안의 클래스">Polygon</A> &nbsp;p)</PRE>
<DL>
<DD>지정된 <code>Polygon</code> 객체에 의해 정의되는 다각형의 윤곽을 그립니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>p</CODE> - draw 대상의 다각형<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillPolygon(int[], int[], int)"><CODE>fillPolygon(int[], int[], int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#drawPolyline(int[], int[], int)"><CODE>drawPolyline(int[], int[], int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fillPolygon(int[], int[], int)"><!-- --></A> <H3>
fillPolygon</H3>
<PRE>
public abstract void <B>fillPolygon</B>(int[]&nbsp;xPoints,
                                 int[]&nbsp;yPoints,
                                 int&nbsp;nPoints)</PRE>
<DL>
<DD><i>x</i> 좌표와 <i>y</i> 좌표의 배열로 정의되는 닫은 다각형을 전부 칠합니다.  &nbsp;<p>
이 메소드는,<code>nPoint</code> 라인 세그먼트(segment)에 의해 정의되는 다각형을 그립니다.  이 경우, 최초의 <code>nPoint&nbsp;-&nbsp;1</code> 라인 세그먼트(segment)는, 1 &nbsp;&le;&nbsp;<i>i</i>&nbsp;&le;&nbsp;<code>nPoints</code> 에 대한,<code>(xPoints[i&nbsp;-&nbsp;1], &nbsp;yPoints[i&nbsp;-&nbsp;1])</code> 로부터 <code>(xPoints[i], &nbsp;yPoints[i])</code> 까지의 라인 세그먼트(segment)입니다. 마지막 점과 최초의 점이 일치하지 않는 경우, 그것들을 접속하는 라인을 draw 하면 그림은 자동적으로 덮습니다.  &nbsp;<p>
다각형내의 영역은, 우기 전부 칠해 규칙 (교호 규칙이라고도 한다)을 사용해 정의됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>xPoints</CODE> - <code>x</code> 좌표의 배열<DD><CODE>yPoints</CODE> - <code>y</code> 좌표의 배열<DD><CODE>nPoints</CODE> - 점의 총수<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawPolygon(int[], int[], int)"><CODE>drawPolygon(int[], int[], int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fillPolygon(java.awt.Polygon)"><!-- --></A> <H3>
fillPolygon</H3>
<PRE>
public void <B>fillPolygon</B>(<A HREF="../../java/awt/Polygon.html" title="java.awt 안의 클래스">Polygon</A> &nbsp;p)</PRE>
<DL>
<DD>지정된 Polygon 객체로 정의된 다각형을 그래픽스 문맥의 현재의 색으로 전부 칠합니다.  &nbsp;<p>
다각형내의 영역은, 우기 전부 칠해 규칙 (교호 규칙이라고도 한다)을 사용해 정의됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>p</CODE> - 전부 칠해 대상의 다각형<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawPolygon(int[], int[], int)"><CODE>drawPolygon(int[], int[], int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.lang.String, int, int)"><!-- --></A> <H3>
drawString</H3>
<PRE>
public abstract void <B>drawString</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str,
                                int&nbsp;x,
                                int&nbsp;y)</PRE>
<DL>
<DD>이 그래픽스 문맥의 현재의 폰트와 색을 사용해, 지정된 캐릭터 라인에 의해 지정된 텍스트를 그립니다. 좌단의 문자의 baseline는, 이 그래픽스 문맥의 좌표계의 위치 (<i>x</i>, &nbsp;<i>y</i>)에 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - draw 되는 캐릭터 라인<DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>str</code> 가 <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)"><CODE>drawBytes(byte[], int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)"><CODE>drawChars(char[], int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.text.AttributedCharacterIterator, int, int)"><!-- --></A> <H3>
drawString</H3>
<PRE>
public abstract void <B>drawString</B>(<A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;iterator,
                                int&nbsp;x,
                                int&nbsp;y)</PRE>
<DL>
<DD>지정된 반복자에 의해 텍스트를 그려,<A HREF="../../java/awt/font/TextAttribute.html" title="java.awt.font 안의 클래스"><CODE>TextAttribute</CODE></A>  클래스의 스펙에 근거해 속성을 적용합니다.  &nbsp;<p>
좌단의 문자의 baseline는, 이 그래픽스 문맥의 좌표계의 위치 (<i>x</i>, &nbsp;<i>y</i>)에 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>iterator</CODE> - draw 되는 텍스트를 가지는 반복자<DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>iterator</code> 가
 <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)"><CODE>drawBytes(byte[], int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)"><CODE>drawChars(char[], int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawChars(char[], int, int, int, int)"><!-- --></A> <H3>
drawChars</H3>
<PRE>
public void <B>drawChars</B>(char[]&nbsp;data,
                      int&nbsp;offset,
                      int&nbsp;length,
                      int&nbsp;x,
                      int&nbsp;y)</PRE>
<DL>
<DD>이 그래픽스 문맥의 현재의 폰트와 색을 사용해, 지정된 문자 배열에 의해 지정된 텍스트를 그립니다. 최초의 문자의 baseline는, 이 그래픽스 문맥의 좌표계의 위치 (<i>x</i>, &nbsp;<i>y</i>)에 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>data</CODE> - draw 되는 문자의 배열<DD><CODE>offset</CODE> - 데이터의 개시 오프셋(offset)<DD><CODE>length</CODE> - draw 되는 문자수<DD><CODE>x</CODE> - 텍스트의 baseline의 <i>x</i> 좌표<DD><CODE>y</CODE> - 텍스트의 baseline의 <i>y</i> 좌표
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>data</code> 가 <code>null</code> 의 경우
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - <code>offset</code> 또는 
 <code>length</code> 가 제로보다 작은 경우, 
 혹은 <code>offset+length</code> 가 <code>data</code> 배열의 길이보다
 큰 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)"><CODE>drawBytes(byte[], int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#drawString(java.lang.String, int, int)"><CODE>drawString(java.lang.String, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawBytes(byte[], int, int, int, int)"><!-- --></A> <H3>
drawBytes</H3>
<PRE>
public void <B>drawBytes</B>(byte[]&nbsp;data,
                      int&nbsp;offset,
                      int&nbsp;length,
                      int&nbsp;x,
                      int&nbsp;y)</PRE>
<DL>
<DD>이 그래픽스 문맥의 현재의 폰트와 색을 사용해, 지정된 바이트 배열에 의해 지정된 텍스트를 그립니다. 최초의 문자의 baseline는, 이 그래픽스 문맥의 좌표계의 위치 (<i>x</i>, &nbsp;<i>y</i>)에 있습니다.  &nbsp;<p>
각 바이트는 범위 0 ~ 255 의 Unicode 코드 포인트로서 해석되기 (위해)때문에, 이 메소드의 사용은 추천 되지 않습니다. 이 범위에 있는 라틴 문자를 그리는 경우만 사용할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>data</CODE> - draw 되는 데이터<DD><CODE>offset</CODE> - 데이터의 개시 오프셋(offset)<DD><CODE>length</CODE> - draw 되는 바이트수<DD><CODE>x</CODE> - 텍스트의 baseline의 <i>x</i> 좌표<DD><CODE>y</CODE> - 텍스트의 baseline의 <i>y</i> 좌표
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>data</code> 가 <code>null</code> 의 경우
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - <code>offset</code> 또는 
 <code>length</code> 가 제로보다 작은 경우, 혹은 <code>offset+length</code> 가 
  <code>data</code> 배열의 길이보다 큰 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)"><CODE>drawChars(char[], int, int, int, int)</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#drawString(java.lang.String, int, int)"><CODE>drawString(java.lang.String, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  int&nbsp;x,
                                  int&nbsp;y,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</PRE>
<DL>
<DD>지정된 이미지의 현재 이용 가능한 부분만큼을 그립니다. 이미지는, 이 그래픽스 문맥의 좌표 공간의 것 (<i>x</i>, &nbsp;<i>y</i>)에 그 좌상구석을 맞추어 draw 됩니다. 이미지내의 투명 픽셀은, 거기에 벌써 존재하는 어떠한 픽셀에도 영향을 주지 않습니다.  &nbsp;<p>
완전한 이미지가 로드가 끝난 상태가 아니고, 현재의 출력 디바이스에 대해서 디저링이 끝난 상태 및 변환이 끝난 상태가 아니어도, 이 메소드는 모든 경우에 즉시 복귀합니다.  &nbsp;<p>
이미지가 완전하게 로드 되어 픽셀이 변경되지 않게 되었을 경우,<code>drawImage</code> 는 <code>true</code> 를 돌려줍니다. 이미지가 완전하게 로드되어 있지 않은 경우,<code>drawImage</code> 는 <code>false</code> 를 돌려주어, 이미지의 한층 더 많은 부분이 이용 가능하게 되는지, 애니메이션의 다른 프레임에 draw 되어 이미지를 로드하는 프로세스에 의해 지정의 이미지 옵저버에 통지됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - draw 되는 지정 이미지<code>img</code> 가 
               null 의 경우에는 아무것도 실시하지 않는<DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표<DD><CODE>observer</CODE> - 이미지가 한층 더 변환되는 것이 
                          통지되는 객체
<DT><B>반환값:</B><DD>이미지 픽셀이 아직 변경중의 경우는 <code>false</code>,
           그렇지 않은 경우는 <code>true</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Image.html" title="java.awt 내의 클래스"><CODE>Image</CODE></A> , 
<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A> , 
<A HREF="../../java/awt/image/ImageObserver.html#imageUpdate(java.awt.Image, int, int, int, int, int)"><CODE>ImageObserver.imageUpdate(java.awt.Image, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, int, int, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  int&nbsp;x,
                                  int&nbsp;y,
                                  int&nbsp;width,
                                  int&nbsp;height,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</PRE>
<DL>
<DD>지정된 구형의 내부에 들어가도록(듯이) 슬캘링 해, 지정된 이미지의 이용 가능한 부분을 그립니다.  &nbsp;<p>
이미지는, 이 그래픽스 문맥의 좌표 공간의 지정된 구형내에 draw 되어 필요에 따라서 슬캘링 됩니다. 투명 픽셀은, 거기에 벌써 존재하는 어떠한 픽셀에도 영향을 주지 않습니다.  &nbsp;<p>
이 메소드는, 이미지 전체가 현재의 출력 디바이스에 대해서 슬캘링 끝나, 디저링 끝나, 변환이 끝난 상태가 아니어도, 모든 경우에 즉시 복귀합니다. 현재의 출력 표현이 아직 완전하지 않은 경우,<code>drawImage</code> 는 <code>false</code> 를 돌려줍니다. 보다 많은 이미지가 이용 가능하게 되면(자), 이미지를 로드하는 프로세스가, 그 <code>imageUpdate</code> 메소드를 호출하는 것에 의해 이미지 옵저버에 통지합니다.  &nbsp;<p>
슬캘링 하고 있지 않는 이미지를 이 출력 디바이스용으로 구축하고 있다고 하는 이유만으로, scaled 이미지를 즉시 사용할 수 있다고는인가 선. 이미지는 사이즈 마다 개별적으로 캐쉬되어 원의 데이터로부터 다른 이미지 작성 순서에 의해 생성되는 일도 있기 때문입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - draw 되는 지정 이미지<code>img</code> 가 
                  null 의 경우에는 아무것도 실시하지 않는<DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표<DD><CODE>width</CODE> - 구형의 폭<DD><CODE>height</CODE> - 구형의 높이<DD><CODE>observer</CODE> - 이미지가 한층 더 변환되는 것이 
                          통지되는 객체
<DT><B>반환값:</B><DD>이미지 픽셀이 아직 변경중의 경우는 <code>false</code>,
           그렇지 않은 경우는 <code>true</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Image.html" title="java.awt 내의 클래스"><CODE>Image</CODE></A> , 
<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A> , 
<A HREF="../../java/awt/image/ImageObserver.html#imageUpdate(java.awt.Image, int, int, int, int, int)"><CODE>ImageObserver.imageUpdate(java.awt.Image, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, java.awt.Color, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  int&nbsp;x,
                                  int&nbsp;y,
                                  <A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bgcolor,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</PRE>
<DL>
<DD>지정된 이미지의 현재 이용 가능한 부분만큼을 그립니다. 이미지는, 이 그래픽스 문맥의 좌표 공간의 것 (<i>x</i>, &nbsp;<i>y</i>)에 그 좌상구석을 맞추어 draw 됩니다. 투명 픽셀은 지정된 백그라운드 칼라로 draw 됩니다.
 <p> 
이 조작은, 지정된 이미지의 폭과 높이의 구형이 지정된 색으로 전부 칠하고 나서, 그 위에 이미지를 그리는 것에 상당합니다만, 아마 그것보다 효율적입니다.  &nbsp;<p>
완전한 이미지가 로드가 끝난 상태가 아니고, 현재의 출력 디바이스에 대해서 디저링이 끝난 상태 및 변환이 끝난 상태가 아니어도, 이 메소드는 모든 경우에 즉시 복귀합니다.  &nbsp;<p>
이미지가 완전하게 로드 되어 픽셀이 변경되지 않게 되었을 경우,<code>drawImage</code> 는 <code>true</code> 를 돌려줍니다. 이미지가 완전하게 로드되어 있지 않은 경우,<code>drawImage</code> 는 <code>false</code> 를 돌려주어, 이미지의 한층 더 많은 부분이 이용 가능하게 되는지, 애니메이션의 다른 프레임에 draw 되어 이미지를 로드하는 프로세스에 의해 지정의 이미지 옵저버에 통지됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - draw 되는 지정 이미지<code>img</code> 가 
               null 의 경우에는 아무것도 실시하지 않는<DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표<DD><CODE>bgcolor</CODE> - 이미지의 불투명하지 않은 부분아래에
                         칠해지는 백그라운드 칼라<DD><CODE>observer</CODE> - 이미지가 한층 더 변환되는 것이 
                          통지되는 객체
<DT><B>반환값:</B><DD>이미지 픽셀이 아직 변경중의 경우는 <code>false</code>,
           그렇지 않은 경우는 <code>true</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Image.html" title="java.awt 내의 클래스"><CODE>Image</CODE></A> , 
<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A> , 
<A HREF="../../java/awt/image/ImageObserver.html#imageUpdate(java.awt.Image, int, int, int, int, int)"><CODE>ImageObserver.imageUpdate(java.awt.Image, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  int&nbsp;x,
                                  int&nbsp;y,
                                  int&nbsp;width,
                                  int&nbsp;height,
                                  <A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bgcolor,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</PRE>
<DL>
<DD>지정된 구형의 내부에 들어가도록(듯이) 슬캘링 해, 지정된 이미지의 이용 가능한 부분을 그립니다.  &nbsp;<p>
이미지는, 이 그래픽스 문맥의 좌표 공간의 지정된 구형내에 draw 되어 필요에 따라서 슬캘링 됩니다. 투명 픽셀은 지정된 백그라운드 칼라로 draw 됩니다. 이 조작은, 지정된 이미지의 폭과 높이의 구형이 지정된 색으로 전부 칠하고 나서, 그 위에 이미지를 그리는 것에 상당합니다만, 아마 그것보다 효율적입니다.  &nbsp;<p>
이 메소드는, 이미지 전체가 현재의 출력 디바이스에 대해서 슬캘링 끝나, 디저링 끝나, 변환이 끝난 상태가 아니어도, 모든 경우에 즉시 복귀합니다. 현재의 출력 표현이 아직 완전하지 않은 경우,<code>drawImage</code> 는 <code>false</code> 를 돌려줍니다. 보다 많은 이미지가 이용 가능하게 되면(자), 이미지를 로드하는 프로세스에 의해 지정의 이미지 옵저버에 통지됩니다.  &nbsp;<p>
슬캘링 하고 있지 않는 이미지를 이 출력 디바이스용으로 구축하고 있다고 하는 이유만으로, scaled 이미지를 즉시 사용할 수 있다고는인가 선. 이미지는 사이즈 마다 개별적으로 캐쉬되어 원의 데이터로부터 다른 이미지 작성 순서에 의해 생성되는 일도 있기 때문입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - draw 되는 지정 이미지<code>img</code> 가 
                     null 의 경우에는 아무것도 실시하지 않는<DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표<DD><CODE>width</CODE> - 구형의 폭<DD><CODE>height</CODE> - 구형의 높이<DD><CODE>bgcolor</CODE> - 이미지의 불투명하지 않은 부분아래에
                         칠해지는 백그라운드 칼라<DD><CODE>observer</CODE> - 이미지가 한층 더 변환되는 것이 
                          통지되는 객체
<DT><B>반환값:</B><DD>이미지 픽셀이 아직 변경중의 경우는 <code>false</code>,
           그렇지 않은 경우는 <code>true</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Image.html" title="java.awt 내의 클래스"><CODE>Image</CODE></A> , 
<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A> , 
<A HREF="../../java/awt/image/ImageObserver.html#imageUpdate(java.awt.Image, int, int, int, int, int)"><CODE>ImageObserver.imageUpdate(java.awt.Image, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  int&nbsp;dx1,
                                  int&nbsp;dy1,
                                  int&nbsp;dx2,
                                  int&nbsp;dy2,
                                  int&nbsp;sx1,
                                  int&nbsp;sy1,
                                  int&nbsp;sx2,
                                  int&nbsp;sy2,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</PRE>
<DL>
<DD>지정된 이미지의 지정된 영역의 이용 가능한 부분을 그립니다. 지정된 영역의 내부에 들어가도록(듯이) 즉시 슬캘링 해 그립니다. 투명 픽셀은, 거기에 벌써 존재하는 어떠한 픽셀에도 영향을 주지 않습니다.  &nbsp;<p>
이 메소드는, draw 되는 이미지 영역이 현재의 출력 디바이스에 대해서 슬캘링 끝나, 디저링 끝나, 변환이 끝난 상태가 아니어도, 모든 경우에 즉시 복귀합니다. 현재의 출력 표현이 아직 완전하지 않은 경우,<code>drawImage</code> 는 <code>false</code> 를 돌려줍니다. 보다 많은 이미지가 이용 가능하게 되면(자), 이미지를 로드하는 프로세스에 의해 지정의 이미지 옵저버에 통지됩니다.  &nbsp;<p>
이 메소드는 항상 슬캘링되어 있지 않은 이미지를 사용해, 슬캘링 된 구형을 그려, 필요한 슬캘링을 즉시 실행합니다. 이것은 이 조작에 대해서는, 캐쉬된 슬캘링 끝난 이미지를 사용하지 않습니다. 소스 구형의 최초의 좌표를 목적지 구형의 최초의 좌표에, 소스의 2 번째의 좌표를 목적지의 2 번째의 좌표에라고 하는 대응으로 매핑 해, 소스로부터 목적지에의 이미지의 슬캘링을 실행합니다. 서브 이미지는, 그 할당을 유지하는 필요성에 응해 슬캘링 되고 반전됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - draw 되는 지정 이미지<code>img</code> 가 
                  null 의 경우에는 아무것도 실시하지 않는<DD><CODE>dx1</CODE> - 목적지 구형의 최초의 구석의 
                    <i>x</i> 좌표<DD><CODE>dy1</CODE> - 목적지 구형의 최초의 구석의 
                    <i>y</i> 좌표<DD><CODE>dx2</CODE> - 목적지 구형의 2 번째의 구석의 
                    <i>x</i> 좌표<DD><CODE>dy2</CODE> - 목적지 구형의 2 번째의 구석의 
                    <i>y</i> 좌표<DD><CODE>sx1</CODE> - 소스 구형의 최초의 구석의 
                    <i>x</i> 좌표<DD><CODE>sy1</CODE> - 소스 구형의 최초의 구석의 
                    <i>y</i> 좌표<DD><CODE>sx2</CODE> - 소스 구형의 2 번째의 구석의 
                    <i>x</i> 좌표<DD><CODE>sy2</CODE> - 소스 구형의 2 번째의 구석의 
                    <i>y</i> 좌표<DD><CODE>observer</CODE> - 이미지가 한층 더 슬캘링 되어 변환되는 것을
                    통지하는 객체
<DT><B>반환값:</B><DD>이미지 픽셀이 아직 변경중의 경우는 <code>false</code>,
           그렇지 않은 경우는 <code>true</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Image.html" title="java.awt 내의 클래스"><CODE>Image</CODE></A> , 
<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A> , 
<A HREF="../../java/awt/image/ImageObserver.html#imageUpdate(java.awt.Image, int, int, int, int, int)"><CODE>ImageObserver.imageUpdate(java.awt.Image, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  int&nbsp;dx1,
                                  int&nbsp;dy1,
                                  int&nbsp;dx2,
                                  int&nbsp;dy2,
                                  int&nbsp;sx1,
                                  int&nbsp;sy1,
                                  int&nbsp;sx2,
                                  int&nbsp;sy2,
                                  <A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bgcolor,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</PRE>
<DL>
<DD>지정된 이미지의 지정된 영역의 이용 가능한 부분을 그립니다. 지정된 영역의 내부에 들어가도록(듯이) 즉시 슬캘링 해 그립니다.  &nbsp;<p>
투명 픽셀은 지정된 백그라운드 칼라로 draw 됩니다. 이 조작은, 지정된 이미지의 폭과 높이의 구형이 지정된 색으로 전부 칠하고 나서, 그 위에 이미지를 그리는 것에 상당합니다만, 아마 그것보다 효율적입니다.  &nbsp;<p>
이 메소드는, draw 되는 이미지 영역이 현재의 출력 디바이스에 대해서 슬캘링 끝나, 디저링 끝나, 변환이 끝난 상태가 아니어도, 모든 경우에 즉시 복귀합니다. 현재의 출력 표현이 아직 완전하지 않은 경우,<code>drawImage</code> 는 <code>false</code> 를 돌려줍니다. 보다 많은 이미지가 이용 가능하게 되면(자), 이미지를 로드하는 프로세스에 의해 지정의 이미지 옵저버에 통지됩니다.  &nbsp;<p>
이 메소드는 항상 슬캘링되어 있지 않은 이미지를 사용해, 슬캘링 된 구형을 그려, 필요한 슬캘링을 즉시 실행합니다. 이것은 이 조작에 대해서는, 캐쉬된 슬캘링 끝난 이미지를 사용하지 않습니다. 소스 구형의 최초의 좌표를 목적지 구형의 최초의 좌표에, 소스의 2 번째의 좌표를 목적지의 2 번째의 좌표에라고 하는 대응으로 매핑 해, 소스로부터 목적지에의 이미지의 슬캘링을 실행합니다. 서브 이미지는, 그 할당을 유지하는 필요성에 응해 슬캘링 되고 반전됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - draw 되는 지정 이미지<code>img</code> 가 
                  null 의 경우에는 아무것도 실시하지 않는<DD><CODE>dx1</CODE> - 목적지 구형의 최초의 구석의 
                    <i>x</i> 좌표<DD><CODE>dy1</CODE> - 목적지 구형의 최초의 구석의 
                    <i>y</i> 좌표<DD><CODE>dx2</CODE> - 목적지 구형의 2 번째의 구석의 
                    <i>x</i> 좌표<DD><CODE>dy2</CODE> - 목적지 구형의 2 번째의 구석의 
                    <i>y</i> 좌표<DD><CODE>sx1</CODE> - 소스 구형의 최초의 구석의 
                    <i>x</i> 좌표<DD><CODE>sy1</CODE> - 소스 구형의 최초의 구석의 
                    <i>y</i> 좌표<DD><CODE>sx2</CODE> - 소스 구형의 2 번째의 구석의 
                    <i>x</i> 좌표<DD><CODE>sy2</CODE> - 소스 구형의 2 번째의 구석의 
                    <i>y</i> 좌표<DD><CODE>bgcolor</CODE> - 이미지의 불투명하지 않은 부분아래에
                    칠해지는 백그라운드 칼라<DD><CODE>observer</CODE> - 이미지가 한층 더 슬캘링 되어 변환되는 것을
                    통지하는 객체
<DT><B>반환값:</B><DD>이미지 픽셀이 아직 변경중의 경우는 <code>false</code>,
           그렇지 않은 경우는 <code>true</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Image.html" title="java.awt 내의 클래스"><CODE>Image</CODE></A> , 
<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A> , 
<A HREF="../../java/awt/image/ImageObserver.html#imageUpdate(java.awt.Image, int, int, int, int, int)"><CODE>ImageObserver.imageUpdate(java.awt.Image, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="dispose()"><!-- --></A> <H3>
dispose</H3>
<PRE>
public abstract void <B>dispose</B>()</PRE>
<DL>
<DD>이 그래픽스 문맥을 파기해, 사용중의 system resource가 있으면 그것을 해제합니다. <code>Graphics</code> 객체를 <code>dispose</code> 의 호출 후에 사용할 수 없습니다.  &nbsp;<p>
Java 프로그램이 실행되고 있으면(자), 단시간 프레임내에서 다수의 <code>Graphics</code> 객체를 작성할 수 있습니다. 가비지 컬렉터의 finalize프로세스도 같은 system resource를 파기합니다만, 관련하는 자원을 수동으로 해제하는 것이 추천 됩니다.  즉, 장기간에 걸쳐 완료까지 실행되지 않을 가능성이 있는 finalize프로세스에 의존하는 것보다도, 이 메소드를 호출해 자원을 수동으로 해제해 주세요.  &nbsp;<p>
컴퍼넌트의 <code>paint</code> 메소드와 <code>update</code> 메소드에 인수로서 제공되는 Graphics 객체는, 이러한 메소드가 복귀했을 때에 시스템에 의해 자동적으로 해제됩니다. 효율성을 확보하려면 ,<code>Graphics</code> 객체가 컴퍼넌트 또는 다른 <code>Graphics</code> 객체로부터 직접 작성되었을 경우만, 그 객체를 사용해 종료했을 때에 <code>dispose</code> 를 호출하도록(듯이) 프로그래밍 하지 않으면 안됩니다.
<P>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#finalize()"><CODE>finalize()</CODE></A> , 
<A HREF="../../java/awt/Component.html#paint(java.awt.Graphics)"><CODE>Component.paint(java.awt.Graphics)</CODE></A> , 
<A HREF="../../java/awt/Component.html#update(java.awt.Graphics)"><CODE>Component.update(java.awt.Graphics)</CODE></A> , 
<A HREF="../../java/awt/Component.html#getGraphics()"><CODE>Component.getGraphics()</CODE></A> , 
<A HREF="../../java/awt/Graphics.html#create()"><CODE>create()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="finalize()"><!-- --></A> <H3>
finalize</H3>
<PRE>
public void <B>finalize</B>()</PRE>
<DL>
<DD>참조되지 않게 된, 이 그래픽스 문맥을 파기합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#finalize()">finalize</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#dispose()"><CODE>dispose()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 <code>Graphics</code> 객체의 값을 표현하고 있는,<code>String</code> 객체를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 그래픽스 문맥의 캐릭터 라인 표현</DL>
</DD>
</DL>
<HR>

<A NAME="getClipRect()"><!-- --></A> <H3>
getClipRect</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getClipRect</B>()</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK version 1.1 이후는,
 <code>getClipBounds()</code> 로 옮겨졌습니다. </I>
<P>
<DD>현재의 클리핑 영역의 경계의 구형을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 클리핑 영역의 경계의 구형,
              클립이 설정되어 있지 않은 경우는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="hitClip(int, int, int, int)"><!-- --></A> <H3>
hitClip</H3>
<PRE>
public boolean <B>hitClip</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height)</PRE>
<DL>
<DD>지정된 구형 영역이 현재의 클리핑 영역과 교차하는 경우는 true 를 돌려줍니다. 지정된 구형 영역의 좌표는 사용자 공간 좌표에 있어, 이 그래픽스 문맥의 좌표계의 원점을 기준으로 하고 있습니다. 이 메소드는, 결과를 재빠르게 계산하는 알고리즘을 사용합니다만, 지정된 구형 영역이 클리핑 영역과 교차하지 않는 경우에서도 true 를 돌려주는 경우가 있습니다. 이 때문에, 이용하는 알고리즘에는 정밀도와 속도와의 타협이 필요하게 됩니다.  다만, 지정된 구형 영역이 현재의 클리핑 영역과 교차하지 않는 것이 보증되지 않는 한 false 를 돌려줄 것은 없습니다. 이 메소드로 사용하는 클리핑 영역은, 디바이스 또는 이미지 경계와 윈도우 가시에 관련한 클리핑과 동시에, 이 그래픽스 문맥의 클립 메소드에 의해 지정된 사용자 클립의 교차를 표현할 수가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 현재의 클리핑 영역이라고 비교되는 구형의 x 좌표<DD><CODE>y</CODE> - 현재의 클리핑 영역이라고 비교되는 구형의 y 좌표<DD><CODE>width</CODE> - 현재의 클리핑 영역이라고 비교되는 구형의 폭<DD><CODE>height</CODE> - 현재의 클리핑 영역이라고 비교되는 구형의 높이
<DT><B>반환값:</B><DD>지정된 구형이 현재의 클립의 경계와
         교차하는 경우는 <code>true</code>, 그렇지 않은 경우는
         <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="getClipBounds(java.awt.Rectangle)"><!-- --></A> <H3>
getClipBounds</H3>
<PRE>
public <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getClipBounds</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;r)</PRE>
<DL>
<DD>현재의 클리핑 영역의 경계의 구형을 돌려줍니다. 구형내의 좌표는 이 그래픽스 문맥의 좌표계의 원점을 기준으로 하고 있습니다. 이 메소드는 <A HREF="../../java/awt/Graphics.html#getClipBounds()"><CODE>getClipBounds</CODE></A>  과는 달리, 새로운 것을 할당하지 말고 기존의 구형을 사용합니다. 이 메소드는, 디바이스 경계나 윈도우 가시에 관련한 클리핑에는 의존하지 않는 사용자 클립을 참조합니다. 클립이 설정되어 있지 않은 경우, 또는 클립이 <code>setClip(null)</code> 를 사용해 클리어 되고 있는 경우는, 이 메소드는 지정한 <code>Rectangle</code> 를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>r</CODE> - 현재의 클리핑 영역의 카피처의
              구형. 이 구형에 현재의 값이 있으면
              덧쓰기된다
<DT><B>반환값:</B><DD>현재의 클리핑 영역의 경계의 구형</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/awt/GradientPaint.html" title="java.awt 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/awt/Graphics2D.html" title="java.awt 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/awt/Graphics.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Graphics.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
