<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:00:58 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
ThreadPoolExecutor (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ThreadPoolExecutor (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ThreadPoolExecutor.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/concurrent/ThreadPoolExecutor.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ThreadPoolExecutor.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent</FONT>
<BR>
클래스 ThreadPoolExecutor</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="java.util.concurrent 내의 클래스">java.util.concurrent.AbstractExecutorService</A> 
      <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.concurrent.ThreadPoolExecutor</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 내의 인터페이스">Executor</A> , <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 안의 인터페이스">ExecutorService</A> </DD>
</DL>
<DL>
<DT><B>직계의 기존의 서브 클래스:</B> <DD><A HREF="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent 내의 클래스">ScheduledThreadPoolExecutor</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>ThreadPoolExecutor</B><DT>extends <A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="java.util.concurrent 내의 클래스">AbstractExecutorService</A> </DL>
</PRE>

<P>
풀 된 복수의 thread의 1 개를 사용해 송신된 각 태스크를 실행하는 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 동안의 인터페이스"><CODE>ExecutorService</CODE></A>  입니다. 일반적으로은 <A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 안의 클래스"><CODE>Executors</CODE></A>  팩토리 메소드를 사용해 구성됩니다.

 <p>thread 풀에서는, 2 개의 문제에 대처합니다. 우선, 태스크 근처의 호출 오버헤드가 감소하기 위해(때문에), 일반적으로은 대량의 비동기 태스크의 실행시에 퍼포먼스가 향상합니다. 또, 태스크의 컬렉션을 실행할 경우에 소비되는 자원 (thread를 포함한다)의 경계 설정 및 관리를 위한 방법을 제공합니다. 각 <tt>ThreadPoolExecutor</tt> 도 기본적인 통계 정보 (완료한 태스크의 수등)를 보관 유지합니다.

 <p>폭넓은 문맥으로 유용하기 때문에 , 이 클래스에서는 많은 조정 가능한 파라미터나 확장성 훅을 제공합니다. 다만 프로그래머는, 보다 편리한 <A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 안의 클래스"><CODE>Executors</CODE></A>  팩토리 메소드인 <A HREF="../../../java/util/concurrent/Executors.html#newCachedThreadPool()"><CODE>Executors.newCachedThreadPool()</CODE></A>  (자동 thread 재생이 있는 안 바운드 형식의 thread 풀),<A HREF="../../../java/util/concurrent/Executors.html#newFixedThreadPool(int)"><CODE>Executors.newFixedThreadPool(int)</CODE></A>  (고정 사이즈의 thread 풀), 및 <A HREF="../../../java/util/concurrent/Executors.html#newSingleThreadExecutor()"><CODE>Executors.newSingleThreadExecutor()</CODE></A>  (단일 백그라운드의 thread)를 사용해 주세요. 이러한 팩토리 메소드는, 가장 일반적인 사용을 상정한 설정을 사전 설정합니다. 그렇지 않은 경우, 이 클래스를 수동으로 설정해 조정할 때는 다음의 가이드에 따라 주세요.

 <dl>

<dt>코어 및 최대 풀 사이즈</dt>

<dd>corePoolSize (<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()"><CODE>getCorePoolSize()</CODE></A>  를 참조)와 maximumPoolSize (<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize()"><CODE>getMaximumPoolSize()</CODE></A>  를 참조)로 설정된 경계에 따라,<tt>ThreadPoolExecutor</tt> 는 자동적으로 풀 사이즈를 조정합니다 (<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getPoolSize()"><CODE>getPoolSize()</CODE></A>  를 참조). 새로운 태스크가 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)"><CODE>execute(java.lang.Runnable)</CODE></A>  메소드로 송신되어 corePoolSize 보다 적은 수의 thread가 실행중인 경우는, 그 외의 워크스 레드가 IDLE 상태여도, 요구를 처리하기 위해서 새로운 thread가 작성됩니다. corePoolSize 보다 많아, maximumPoolSize 보다 적은 수의 thread가 실행중인 경우, 새로운 thread가 작성되는 것은 큐가 가득해 있는 경우만입니다. corePoolSize 와 maximumPoolSize 를 같은 값으로 설정하면(자), 고정 사이즈의 thread 풀이 작성됩니다. maximumPoolSize 을 <tt>Integer.MAX_VALUE</tt> 등의 실질적으로 안 바운드 형식인 값으로 설정하면(자), 풀에 임의의 수의 병행 태스크를 포함할 수가 있습니다. 코어 풀 사이즈와 최대 풀 사이즈는 구축시에게만 설정되는 것이 가장 일반적입니다만,<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize(int)"><CODE>setCorePoolSize(int)</CODE></A>  및 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize(int)"><CODE>setMaximumPoolSize(int)</CODE></A>  를 사용해 동적으로 변경할 수도 있습니다.  </dd>

<dt>On Demand 구축</dt>

<dd> 디폴트에서는, 새로운 태스크의 도착시에게만 코어 thread가 처음 작성되어 기동됩니다만,<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartCoreThread()"><CODE>prestartCoreThread()</CODE></A>  또는 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartAllCoreThreads()"><CODE>prestartAllCoreThreads()</CODE></A>  메소드를 사용해 동적으로 오버라이드(override) 할 수 있습니다. 빈 상태(empty)이 아닌 큐로 풀을 구축하는 경우는, thread를 사전에 기동할 수도 있습니다.  </dd>

<dt>새로운 thread의 작성</dt>

<dd>새로운 thread는 <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스"><CODE>ThreadFactory</CODE></A>  를 사용해 작성됩니다. 특히 지정이 없는 경우는,<A HREF="../../../java/util/concurrent/Executors.html#defaultThreadFactory()"><CODE>Executors.defaultThreadFactory()</CODE></A>  가 사용됩니다. 이 경우에 작성되는 thread는, 모두 같은 <A HREF="../../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스"><CODE>ThreadGroup</CODE></A>  내에 있어, 같은 <tt>NORM_PRIORITY</tt> 우선 순위와 비demon 상태를 가집니다. 다른 ThreadFactory 를 지정하면(자), thread의 이름, thread 그룹, 우선 순위, demon 상태등을 변경할 수 있습니다. 요구시에 <tt>newThread</tt> 로부터 null 가 돌려주어져 <tt>ThreadFactory</tt> 가 thread의 작성에 실패하면(자), executor 는 속행합니다만, 태스크를 전혀 실행할 수 없을 가능성이 있습니다.  </dd>

<dt>킵얼라이브 시간</dt>

<dd>현재 풀에 corePoolSize 의 수보다 많은 thread가 있는 경우, 초과한 만큼의 thread는, IDLE 상태가 되어 있는 기간이 keepAliveTime 를 넘으면(자) 종료합니다 (<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime(java.util.concurrent.TimeUnit)"><CODE>getKeepAliveTime(java.util.concurrent.TimeUnit)</CODE></A>  를 참조). 이것에 의해, 풀이 액티브하게 사용되어 있지 않을 때의 자원의 소비량을 줄일 수가 있습니다. 풀이 나중에 액티브하게 되면(자), 새로운 thread가 구축됩니다. 이 파라미터는,<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime(long, java.util.concurrent.TimeUnit)"><CODE>setKeepAliveTime(long, java.util.concurrent.TimeUnit)</CODE></A>  메소드를 사용해 동적으로 변경할 수 있습니다. <tt>Long.MAX_VALUE</tt> <A HREF="../../../java/util/concurrent/TimeUnit.html#NANOSECONDS"><CODE>TimeUnit.NANOSECONDS</CODE></A>  의 값을 사용하면(자), 아이돌 thread가 종료전에 종료하는 일도 실질적으로 무효가 됩니다. 디폴트에서는, corePoolSizeThreads 를 넘는 경우에게만 킵얼라이브 정책를 적용합니다. 다만 keepAliveTime 의 값이 제로 이외이면,<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#allowCoreThreadTimeOut(boolean)"><CODE>allowCoreThreadTimeOut(boolean)</CODE></A>  메소드를 사용해, 이 타임 아웃 정책를 코어 thread에도 적용할 수가 있습니다.  </dd>

<dt>큐잉</dt>

<dd><A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스"><CODE>BlockingQueue</CODE></A>  는, 송신된 태스크를 전송 및 보관 유지하기 위해서 사용할 수 있습니다. 이 큐의 사용은, 풀의 사이즈 설정과 서로 작용합니다.

 <ul>

<li> corePoolSize 보다 적은 수의 thread가 실행되고 있는 경우, executor 는 큐잉보다 새로운 thread의 추가를 항상 우선합니다. </li>

<li> corePoolSize 이상의 수의 thread가 실행되고 있는 경우, executor 는 새로운 thread의 추가보다 요구의 큐잉을 항상 우선합니다. </li>

<li> 요구를 큐에 넣을 수가 없는 경우, 새로운 thread를 작성하는 것으로써 maximumPoolSize 를 넘지 않는 경우는 새로운 thread가 작성되어 넘는 경우는 태스크가 거부됩니다. </li>

 </ul>

큐잉의 일반적인 방식에는 다음의 3 종류가 있습니다.
 <ol>

<li> <em> 직접 핸드 오프</em>. 워크 큐에 적절한 디폴트의 선택사항은, 태스크를 보관 유지하지 않고 thread에 핸드 오프 하는 <A HREF="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent 동안의 클래스"><CODE>SynchronousQueue</CODE></A>  입니다. <A HREF="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent 안의 클래스"><CODE>SynchronousQueue</CODE></A>  는, 본래는 태스크를 보관 유지합니다. 이 경우, 태스크를 실행하기 위해서 곧바로 이용할 수 있는 thread가 없으면 태스크를 큐에 넣으려고 했을 때에 실패해, 새로운 thread가 구축됩니다. 이 정책에 의해, 내부적인 의존관계(dependencies)를 가질 가능성이 있는 요구 세트의 처리시에 록 업이 회피됩니다. 일반적으로 직접 핸드 오프에서는, 송신된 새로운 태스크가 거부되는 것을 회피하기 위해서, 안 바운드 형식의 maximumPoolSizes 가 필요합니다. 이것에 의해, 평균해 처리 능력을 넘는 속도로 커멘드가 차례차례로 도착하면(자), 안 바운드 형식의 thread가 커질 가능성이 있습니다.   </li>

<li><em> 안 바운드 형식의 큐</em>. 안 바운드 형식의 큐 (사전 정의된 용량을 가지지 않는 <A HREF="../../../java/util/concurrent/LinkedBlockingQueue.html" title="java.util.concurrent 동안의 클래스"><CODE>LinkedBlockingQueue</CODE></A>  등)를 사용하면(자), corePoolSize 의 모든 thread가 Busy 상태인 경우에, 새로운 태스크는 큐내에서 대기합니다. 이것에 의해, corePoolSize 를 넘는 thread는 작성되지 않게 됩니다. 즉 maximumPoolSize 의 값은 효과가 없어집니다. 각 태스크가 완전하게 독립하고 있기 (위해)때문에, 태스크가 상호의 실행에 영향을 주지 않는 경우는 이 방식이 적절하다라고 하는 것이 있습니다 (Web 페이지 서버의 경우 등). 이 방식의 큐잉은, 일시적으로 급증한 요구를 처리하는 경우 등은 편리합니다만, 평균해 처리 능력을 넘는 속도로 커멘드가 차례차례로 도착하면(자), 안 바운드 형식의 워크 큐가 커질 가능성이 있습니다.   </li>

<li><em>바운드 형식의 큐</em>. 바운드 형식의 큐 (<A HREF="../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent 안의 클래스"><CODE>ArrayBlockingQueue</CODE></A>  등)는, 한정된 maximumPoolSizes 로 사용하면(자) 자원 부족을 회피할 수 있습니다만, 조정과 제어가 어려워질 가능성이 있습니다. 큐 사이즈와 최대 풀 사이즈는 서로 트레이드 오프의 관계가 되는 일이 있습니다. 큰 큐와 작은 풀을 사용하면(자), CPU 사용율, OS 자원량, 및 콘테키스트스잇팅의 오버헤드는 최소화됩니다만, throughput는 큰폭으로 저하할 가능성이 있습니다. 태스크가 빈번하게 블록 하는 경우는 (입출력이 제한되는 경우 등), 허가하고 있는 thread수보다 많은 thread에 대해서, 시스템이 시간을 스케줄 할 수가 있습니다. 작은 큐를 사용하면(자), 일반적으로 필요한 풀 사이즈는 커집니다. 이것에 의해, CPU 가 보다 Busy가 됩니다만, 과대한 스케줄 설정의 오버헤드가 발생하는 일이 있어, throughput도 저하합니다.   </li>

 </ol>

 </dd>

<dt>거부된 태스크</dt>

<dd> executor 가 종료 하고 있는 경우, 또는 executor 가 최대 thread수와 워크 큐 용량의 양쪽 모두로 유한의 경계를 사용해, 한편 포화 상태인 경우,<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)"><CODE>execute(java.lang.Runnable)</CODE></A>  메소드로 송신된 새로운 태스크는 거부됩니다. <em></em>어느 쪽의 경우도,<tt>execute</tt> 메소드는,<A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스"><CODE>RejectedExecutionHandler</CODE></A>  의 <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html#rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)"><CODE>RejectedExecutionHandler.rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)</CODE></A>  메소드를 호출합니다. 사전 정의된 4 개의 핸들러 정책가 준비되어 있습니다.

 <ol>

<li> 디폴트 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 중의 클래스"><CODE>ThreadPoolExecutor.AbortPolicy</CODE></A>  에서는, 거부되면(자), 핸들러는 실행시 <A HREF="../../../java/util/concurrent/RejectedExecutionException.html" title="java.util.concurrent 중의 클래스"><CODE>RejectedExecutionException</CODE></A>  를 throw 합니다.  </li>

<li> <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="java.util.concurrent 안의 클래스"><CODE>ThreadPoolExecutor.CallerRunsPolicy</CODE></A>  에서는,<tt>execute</tt> 자체를 호출하는 thread가 태스크를 실행합니다. 이것에 의해, 단순한 피드백 제어 기구가 제공되어 결과적으로 새로운 태스크의 송신 레이트가 저하합니다.  </li>

<li> <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="java.util.concurrent 안의 클래스"><CODE>ThreadPoolExecutor.DiscardPolicy</CODE></A>  에서는, 실행할 수 없는 태스크가 단지 삭제됩니다.   </li>

<li><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="java.util.concurrent 안의 클래스"><CODE>ThreadPoolExecutor.DiscardOldestPolicy</CODE></A>  에서는, executor 가 종료 하고 있지 않는 경우는, 워크 큐의 선두에 있는 태스크가 삭제되어 실행이 재시행됩니다 (한번 더 실패할 가능성이 있어, 그 경우는 이 처리가 반복해진다).  </li>

 </ol>

다른 종류 <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 중의 인터페이스"><CODE>RejectedExecutionHandler</CODE></A>  클래스를 정의 및 사용할 수도 있습니다. 그 경우, 특정의 용량 또는 큐잉 정책에서만 동작하도록(듯이) 정책가 설계되고 있을 때는, 특히 주의가 필요합니다.  </dd>

<dt>훅 메소드</dt>

<dd>이 클래스는,<tt>protected</tt> 의 오버라이드(override) 가능한 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#beforeExecute(java.lang.Thread, java.lang.Runnable)"><CODE>beforeExecute(java.lang.Thread, java.lang.Runnable)</CODE></A>  메소드와 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable, java.lang.Throwable)"><CODE>afterExecute(java.lang.Runnable, java.lang.Throwable)</CODE></A>  메소드를 제공하고 있습니다. 이러한 메소드는, 각 태스크를 실행하는 전후에 불려 갑니다. 이러한 메소드는, 실행 환경을 조작하기 위해서 사용할 수 있습니다 (ThreadLocal 의 재초기화, 통계 정보의 수집, 로그 엔트리의 추가 등). 또, executor 가 완전하게 종료하면(자) 실행할 필요가 있는 특별한 처리를 실행하도록(듯이),<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#terminated()"><CODE>terminated()</CODE></A>  메소드를 오버라이드(override) 할 수가 있습니다.

 <p>훅 또는 콜백 메소드가 예외를 throw 하면(자), 내부의 워크스 레드는 실패해 강제 종료합니다. </dd>

<dt>큐의 보수</dt>

<dd> <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getQueue()"><CODE>getQueue()</CODE></A>  메소드를 사용하면(자), 감시나 디버그의 목적으로 워크 큐에 액세스 할 수 있습니다. 그 외의 목적으로 이 메소드를 사용하지 않는 것이 강하고 추천 되고 있습니다. 제공되는 2 개의 메소드 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#remove(java.lang.Runnable)"><CODE>remove(java.lang.Runnable)</CODE></A>  및 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#purge()"><CODE>purge()</CODE></A>  는, 큐에 들어가 있는 대량의 태스크가 삭제될 때, 기억 영역의 재생을 지원하기 위해서 이용할 수 있습니다. </dd>

<dt>finalize</dt>

<dd> 풀이 프로그램으로 참조되지 않게 되어, 한편 남아 있는 thread가 없어지면(자), 그 풀에서 자동적으로 <tt>shutdown</tt> 가 실행됩니다. 사용자가 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdown()"><CODE>shutdown()</CODE></A>  의 호출을 잊었을 때에도, 참조되어 있지 않은 풀이 재생되도록(듯이) 하는 경우는, 미사용의 thread가 최종적으로 종료하도록(듯이) 설정할 필요가 있습니다. 거기에는, 적절한 킵얼라이브 시간을 설정하거나 제로 코어 thread의 하한을 사용하거나<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#allowCoreThreadTimeOut(boolean)"><CODE>allowCoreThreadTimeOut(boolean)</CODE></A>  를 설정하거나 합니다.   </dd> </dl>

 <p> <b>확장 기능의 예</b>. 이 클래스의 대부분의 확장 기능은, 1 개(살) 이상의 protected 훅 메소드를 오버라이드(override) 합니다. 예를 들어, 다음의 예는, 단순한 일시정지 및 재개의 기능을 추가하는 서브 클래스입니다.

 <pre>
 class PausableThreadPoolExecutor extends ThreadPoolExecutor {
   private boolean isPaused;
   private ReentrantLock pauseLock = new ReentrantLock();
   private Condition unpaused = pauseLock.newCondition();

   public PausableThreadPoolExecutor(...) { super(...); }

   protected void beforeExecute(Thread t, Runnable r) {
     super.beforeExecute(t, r);
     pauseLock.lock();
     try {
       while (isPaused) unpaused.await();
     } catch (InterruptedException ie) {
       t.interrupt();
     } finally {
       pauseLock.unlock();
     }
   }

   public void pause() {
     pauseLock.lock();
     try {
       isPaused = true;
     } finally {
       pauseLock.unlock();
     }
   }

   public void resume() {
     pauseLock.lock();
     try {
       isPaused = false;
       unpaused.signalAll();
     } finally {
       pauseLock.unlock();
     }
   }
 }
 </pre>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.AbortPolicy</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>RejectedExecutionException</tt> 를 throw 하는 거부된 태스크의 핸들러입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.CallerRunsPolicy</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor 가 종료 하고 있지 않는 경우에,<tt>execute</tt> 메소드의 호출로 거부된 태스크를 직접 실행한다, 거부된 태스크의 핸들러입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.DiscardOldestPolicy</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor 가 종료 하고 있지 않는 경우에, 가장 낡은 미처리의 요구를 파기해 <tt>execute</tt> 를 재시행한다, 거부된 태스크의 핸들러입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.DiscardPolicy</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;거부된 태스크를 통지없이 파기하는 거부된 태스크의 핸들러입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue)">ThreadPoolExecutor</A> </B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 초기 파라미터, 및 디폴트의 thread 팩토리라고 거부된 실행 핸들러를 사용해, 새로운 <tt>ThreadPoolExecutor</tt> 를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.RejectedExecutionHandler)">ThreadPoolExecutor</A> </B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue,
                   <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> &nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 초기 파라미터, 및 디폴트의 thread 팩토리를 사용해, 새로운 <tt>ThreadPoolExecutor</tt> 를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory)">ThreadPoolExecutor</A> </B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue,
                   <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> &nbsp;threadFactory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 초기 파라미터, 및 디폴트의 거부된 실행 핸들러를 사용해, 새로운 <tt>ThreadPoolExecutor</tt> 를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)">ThreadPoolExecutor</A> </B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue,
                   <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> &nbsp;threadFactory,
                   <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> &nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 초기 파라미터를 사용해, 새로운 <tt>ThreadPoolExecutor</tt> 를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable, java.lang.Throwable)">afterExecute</A> </B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;r,
             <A HREF="../../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Runnable 의 실행 완료시에 불려 가는 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#allowCoreThreadTimeOut(boolean)">allowCoreThreadTimeOut</A> </B>(boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 풀에서, 킵얼라이브 시간내에 도착한 태스크가 없으면 코어 thread가 타임 아웃 및 종료하는 것이 허가되어 새로운 태스크가 도착했을 때는 필요에 따라서 코어 thread를 옮겨놓을 수 있을지 어떨지를 제어하는 정책를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#allowsCoreThreadTimeOut()">allowsCoreThreadTimeOut</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 풀에서, keepAlive 시간내에 도착한 태스크가 없으면 코어 thread가 타임 아웃 및 종료하는 것이 허가되어 새로운 태스크가 도착했을 때는 필요에 따라서 코어 thread를 옮겨놓을 수 있는 경우는, true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#awaitTermination(long, java.util.concurrent.TimeUnit)">awaitTermination</A> </B>(long&nbsp;timeout,
                 <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;종료 요구 후에 모든 태스크가 실행을 완료하고 있었는지, 타임 아웃이 발생하는지, 현재의 thread로 인터럽트가 발생하는지, 그 어느쪽이든가 최초로 발생할 때까지 블록 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#beforeExecute(java.lang.Thread, java.lang.Runnable)">beforeExecute</A> </B>(<A HREF="../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;t,
              <A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 thread로 지정된 Runnable 를 실행하기 전에 불려 가는 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)">execute</A> </B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;command)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;장래가 있는 시점에서 지정된 태스크를 실행합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#finalize()">finalize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 executor 가 참조되지 않게 되었을 때에 <tt>shutdown</tt> 를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getActiveCount()">getActiveCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;액티브하게 태스크를 실행하고 있는 thread의 대략의 수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCompletedTaskCount()">getCompletedTaskCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지금까지 실행이 완료한 태스크의 대략의 총수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()">getCorePoolSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread의 코어수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime(java.util.concurrent.TimeUnit)">getKeepAliveTime</A> </B>(<A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;코어 풀 사이즈를 넘는 thread가 종료전에 IDLE 상태에 머물 수가 있는, thread의 킵얼라이브 시간을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getLargestPoolSize()">getLargestPoolSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;풀내에 동시에 존재한 최대 thread수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize()">getMaximumPoolSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread의 최대 허용수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getPoolSize()">getPoolSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;풀내의 현재의 thread수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 내의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getQueue()">getQueue</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 executor 로 사용하는 태스크 큐를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 내의 인터페이스">RejectedExecutionHandler</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getRejectedExecutionHandler()">getRejectedExecutionHandler</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;실행 가능하지 않은 태스크의 현재의 핸들러를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getTaskCount()">getTaskCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지금까지 실행이 스케줄 된 태스크의 대략의 총수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 내의 인터페이스">ThreadFactory</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getThreadFactory()">getThreadFactory</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 thread의 작성에 사용하는 thread 팩토리를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#isShutdown()">isShutdown</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 executor 가 종료 하고 있었을 경우,<tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#isTerminated()">isTerminated</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;종료에 이어 모든 태스크가 완료하고 있었을 경우,<tt>true</tt> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#isTerminating()">isTerminating</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>shutdown</tt> 또는 <tt>shutdownNow</tt> 의 나중에 이 executor 가 종료 처리중이지만, 완전하게 종료하고 있지 않는 경우는, true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartAllCoreThreads()">prestartAllCoreThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 코어 thread를 기동해, IDLE 상태로 처리 대기로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartCoreThread()">prestartCoreThread</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;코어 thread를 기동해, IDLE 상태로 처리 대기로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#purge()">purge</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;삭제된 모든 <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 안의 인터페이스"><CODE>Future</CODE></A>  태스크를 워크 큐로부터 삭제하려고 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#remove(java.lang.Runnable)">remove</A> </B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;task)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor 의 내부 큐에 이 태스크가 존재하는 경우는 삭제하기 위해(때문에), 그 태스크가 아직 개시되어 있지 않은 경우는 실행되지 않습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize(int)">setCorePoolSize</A> </B>(int&nbsp;corePoolSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread의 코어수를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime(long, java.util.concurrent.TimeUnit)">setKeepAliveTime</A> </B>(long&nbsp;time,
                 <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread가 종료전에 IDLE 상태에 머물 수가 있는 제한 시간을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize(int)">setMaximumPoolSize</A> </B>(int&nbsp;maximumPoolSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread의 최대 허용수를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)">setRejectedExecutionHandler</A> </B>(<A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> &nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;실행 가능하지 않은 태스크의 새로운 핸들러를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setThreadFactory(java.util.concurrent.ThreadFactory)">setThreadFactory</A> </B>(<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> &nbsp;threadFactory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 thread의 작성에 사용하는 thread 팩토리를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdown()">shutdown</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;순서 올바르게 종료을 개시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdownNow()">shutdownNow</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;실행중의 액티브한 태스크 모든 정지를 시도해 대기중의 태스크의 처리를 정지해, 실행을 대기하고 있던 태스크의 리스트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#terminated()">terminated</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor 가 종료되었을 때에 불려 가는 메소드입니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.concurrent.AbstractExecutorService"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.util.concurrent. <A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="java.util.concurrent 안의 클래스">AbstractExecutorService</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAll(java.util.Collection)">invokeAll</A> , <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAll(java.util.Collection, long, java.util.concurrent.TimeUnit)">invokeAll</A> , <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAny(java.util.Collection)">invokeAny</A> , <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAny(java.util.Collection, long, java.util.concurrent.TimeUnit)">invokeAny</A> , <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#newTaskFor(java.util.concurrent.Callable)">newTaskFor</A> , <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#newTaskFor(java.lang.Runnable, T)">newTaskFor</A> , <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#submit(java.util.concurrent.Callable)">submit</A> , <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#submit(java.lang.Runnable)">submit</A> , <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#submit(java.lang.Runnable, T)">submit</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue)"><!-- --></A> <H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue)</PRE>
<DL>
<DD>지정된 초기 파라미터, 및 디폴트의 thread 팩토리라고 거부된 실행 핸들러를 사용해, 새로운 <tt>ThreadPoolExecutor</tt> 를 작성합니다. 이 범용 생성자 은 아니고,<A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 안의 클래스"><CODE>Executors</CODE></A>  팩토리 메소드의 어느쪽이든을 사용하는 편이 편리한 경우가 있습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>corePoolSize</CODE> - 풀내 로 유지하는 thread의 수 (IDLE 상태의 thread도 포함한다)<DD><CODE>maximumPoolSize</CODE> - 풀내에서 가능한 thread의 최대수<DD><CODE>keepAliveTime</CODE> - thread의 수가 코어보다 많은 경우, 이것은 초과한 IDLE 상태의 thread가 종료전에 새로운 태스크를 대기하는 최대 시간<DD><CODE>unit</CODE> - keepAliveTime 인수의 시간 단위<DD><CODE>workQueue</CODE> - 태스크의 실행전에, 그 태스크를 보관 유지하기 위해서 사용하는 큐. 이 큐는,<tt>execute</tt> 메소드로 송신된 <tt>Runnable</tt> 태스크만을 보관 유지한다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - corePoolSize 또는 keepAliveTime 가 제로보다 작은 경우, maximumPoolSize 가 제로 이하의 경우, 또는 corePoolSize 가 maximumPoolSize 보다 큰 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>workQueue</tt> 가 null 의 경우</DL>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory)"><!-- --></A> <H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue,
                          <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> &nbsp;threadFactory)</PRE>
<DL>
<DD>지정된 초기 파라미터, 및 디폴트의 거부된 실행 핸들러를 사용해, 새로운 <tt>ThreadPoolExecutor</tt> 를 작성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>corePoolSize</CODE> - 풀내 로 유지하는 thread의 수 (IDLE 상태의 thread도 포함한다)<DD><CODE>maximumPoolSize</CODE> - 풀내에서 가능한 thread의 최대수<DD><CODE>keepAliveTime</CODE> - thread의 수가 코어보다 많은 경우, 이것은 초과한 IDLE 상태의 thread가 종료전에 새로운 태스크를 대기하는 최대 시간<DD><CODE>unit</CODE> - keepAliveTime 인수의 시간 단위<DD><CODE>workQueue</CODE> - 태스크의 실행전에, 그 태스크를 보관 유지하기 위해서 사용하는 큐. 이 큐는,<tt>execute</tt> 메소드로 송신된 <tt>Runnable</tt> 태스크만을 보관 유지하는<DD><CODE>threadFactory</CODE> - executor 가 새로운 thread를 작성할 경우에 사용하는 팩토리
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - corePoolSize 또는 keepAliveTime 가 제로보다 작은 경우, maximumPoolSize 가 제로 이하의 경우, 또는 corePoolSize 가 maximumPoolSize 보다 큰 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>workQueue</tt> 또는 <tt>threadFactory</tt> 가 null 의 경우</DL>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.RejectedExecutionHandler)"><!-- --></A> <H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue,
                          <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> &nbsp;handler)</PRE>
<DL>
<DD>지정된 초기 파라미터, 및 디폴트의 thread 팩토리를 사용해, 새로운 <tt>ThreadPoolExecutor</tt> 를 작성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>corePoolSize</CODE> - 풀내 로 유지하는 thread의 수 (IDLE 상태의 thread도 포함한다)<DD><CODE>maximumPoolSize</CODE> - 풀내에서 가능한 thread의 최대수<DD><CODE>keepAliveTime</CODE> - thread의 수가 코어보다 많은 경우, 이것은 초과한 IDLE 상태의 thread가 종료전에 새로운 태스크를 대기하는 최대 시간<DD><CODE>unit</CODE> - keepAliveTime 인수의 시간 단위<DD><CODE>workQueue</CODE> - 태스크의 실행전에, 그 태스크를 보관 유지하기 위해서 사용하는 큐. 이 큐는,<tt>execute</tt> 메소드로 송신된 <tt>Runnable</tt> 태스크만을 보관 유지하는<DD><CODE>handler</CODE> - thread의 경계에 이르러, 큐의 용량에 이르렀기 때문에, 실행이 블록 되었을 때에 사용되는 핸들러
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - corePoolSize 또는 keepAliveTime 가 제로보다 작은 경우, maximumPoolSize 가 제로 이하의 경우, 또는 corePoolSize 가 maximumPoolSize 보다 큰 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>workQueue</tt> 또는 <tt>handler</tt> 가 null 의 경우</DL>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)"><!-- --></A> <H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue,
                          <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> &nbsp;threadFactory,
                          <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> &nbsp;handler)</PRE>
<DL>
<DD>지정된 초기 파라미터를 사용해, 새로운 <tt>ThreadPoolExecutor</tt> 를 작성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>corePoolSize</CODE> - 아이돌이어도 풀내에 유지되는 thread의 수<DD><CODE>maximumPoolSize</CODE> - 풀내에서 가능한 thread의 최대수<DD><CODE>keepAliveTime</CODE> - thread의 수가 코어보다 많은 경우, 이것은 초과한 IDLE 상태의 thread가 새로운 태스크를 대기하고 나서 종료할 때까지의 최대 시간<DD><CODE>unit</CODE> - keepAliveTime 인수의 시간 단위<DD><CODE>workQueue</CODE> - 태스크가 초과할 때까지 보관 유지하기 위해서 사용하는 큐. 이 큐는,<tt>execute</tt> 메소드로 송신된 <tt>Runnable</tt> 태스크만을 보관 유지하는<DD><CODE>threadFactory</CODE> - executor 가 새로운 thread를 작성할 경우에 사용되는 팩토리<DD><CODE>handler</CODE> - thread의 경계 및 큐의 용량에 이르렀기 때문에, 실행이 블록 되었을 때에 사용하는 핸들러
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - corePoolSize 또는 keepAliveTime 가 제로보다 작은 경우, maximumPoolSize 가 제로 이하의 경우, 또는 corePoolSize 가 maximumPoolSize 보다 큰 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>workQueue</tt>,<tt>threadFactory</tt>, 또는 <tt>handler</tt> 가 null 의 경우</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="execute(java.lang.Runnable)"><!-- --></A> <H3>
execute</H3>
<PRE>
public void <B>execute</B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;command)</PRE>
<DL>
<DD>장래가 있는 시점에서 지정된 태스크를 실행합니다. 태스크는, 새로운 thread 또는 기존의 풀 된 thread로 실행됩니다.

이 executor 가 종료 했기 때문에, 또는 용량에 이르렀기 때문에, 태스크를 송신해 실행할 수 없는 경우, 태스크는 현재의 <tt>RejectedExecutionHandler</tt> 로 처리됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>command</CODE> - 실행하는 태스크
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/concurrent/RejectedExecutionException.html" title="java.util.concurrent 안의 클래스">RejectedExecutionException</A> </CODE> - <tt>RejectedExecutionHandler</tt> 의 판단으로, 태스크의 실행을 받아들일 수가 없는 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 커멘드가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="shutdown()"><!-- --></A> <H3>
shutdown</H3>
<PRE>
public void <B>shutdown</B>()</PRE>
<DL>
<DD>순서 올바르게 종료을 개시합니다. 이전에 송신된 태스크가 실행됩니다만, 신규 태스크는 받아들여지지 않습니다. 종료 후에 호출을 실행해도, 효과는 없습니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재하는 상황으로 이 ExecutorService 의 종료을 실행하면(자), 호출 측에는 변경을 허가하지 않는 thread를 조작할 수 있는 경우. 이것은,<A HREF="../../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A> <tt>("modifyThread")</tt> 를 보관 유지하지 않는지, 시큐리티 매니저의 <tt>checkAccess</tt> 메소드가 액세스를 거부하기 위해(때문에)이다</DL>
</DD>
</DL>
<HR>

<A NAME="shutdownNow()"><!-- --></A> <H3>
shutdownNow</H3>
<PRE>
public <A HREF="../../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt; <B>shutdownNow</B>()</PRE>
<DL>
<DD>실행중의 액티브한 태스크 모든 정지를 시도해 대기중의 태스크의 처리를 정지해, 실행을 대기하고 있던 태스크의 리스트를 돌려줍니다. 이러한 태스크는, 이 메소드로부터 돌아올 때, 태스크 큐로부터 드레인 (삭제) 됩니다.

 <p>실행중의 액티브한 태스크 처리를 정지하기 위해서 최선의 노력을 하는 것 이상의 보증은 없습니다. 이 구현에서는,<A HREF="../../../java/lang/Thread.html#interrupt()"><CODE>Thread.interrupt()</CODE></A>  를 개입시켜 태스크를 취소하기 (위해)때문에, 인터럽트에 대한 응답에 실패한 태스크는 종료하지 않게 될 가능성이 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>실행이 개시되지 않았던 태스크의 리스트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재하는 상황으로 이 ExecutorService 의 종료을 실행하면(자), 호출 측에는 변경을 허가하지 않는 thread를 조작할 수 있는 경우. 이것은,<A HREF="../../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A> <tt>("modifyThread")</tt> 를 보관 유지하지 않는지, 시큐리티 매니저의 <tt>checkAccess</tt> 메소드가 액세스를 거부하기 위해(때문에)이다</DL>
</DD>
</DL>
<HR>

<A NAME="isShutdown()"><!-- --></A> <H3>
isShutdown</H3>
<PRE>
public boolean <B>isShutdown</B>()</PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../java/util/concurrent/ExecutorService.html#isShutdown()">ExecutorService</A> </CODE> 의 기술:</B></DD>
<DD>이 executor 가 종료 하고 있었을 경우,<tt>true</tt> 를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 executor 가 종료 하고 있었을 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="isTerminating()"><!-- --></A> <H3>
isTerminating</H3>
<PRE>
public boolean <B>isTerminating</B>()</PRE>
<DL>
<DD><tt>shutdown</tt> 또는 <tt>shutdownNow</tt> 의 나중에 이 executor 가 종료 처리중이지만, 완전하게 종료하고 있지 않는 경우는, true 를 돌려줍니다. 이 메소드는 디버그에 편리한 일이 있습니다. 종료 후에 충분히 시간이 흐르고 나서 보고된 반환값 <tt>true</tt> 는, 송신된 태스크가 무시되었는지 인터럽트가 억제되었기 때문에, 이 executor 가 적절히 종료되지 않는 것을 나타낼 가능성이 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>종료중이지만 종료하고 있지 않는 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="isTerminated()"><!-- --></A> <H3>
isTerminated</H3>
<PRE>
public boolean <B>isTerminated</B>()</PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../java/util/concurrent/ExecutorService.html#isTerminated()">ExecutorService</A> </CODE> 의 기술:</B></DD>
<DD>종료에 이어 모든 태스크가 완료하고 있었을 경우,<tt>true</tt> 를 돌려줍니다. <tt>shutdown</tt> 또는 <tt>shutdownNow</tt> 중 한쪽이 <tt>isTerminated</tt> 의 전에 불려 갔을 경우를 제외해,<tt>isTerminated</tt> 가 <tt>true</tt> 가 될 것은 없습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>종료에 이어 모든 태스크가 완료하고 있었을 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="awaitTermination(long, java.util.concurrent.TimeUnit)"><!-- --></A> <H3>
awaitTermination</H3>
<PRE>
public boolean <B>awaitTermination</B>(long&nbsp;timeout,
                                <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)
                         throws <A HREF="../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../java/util/concurrent/ExecutorService.html#awaitTermination(long, java.util.concurrent.TimeUnit)">ExecutorService</A> </CODE> 의 기술:</B></DD>
<DD>종료 요구 후에 모든 태스크가 실행을 완료하고 있었는지, 타임 아웃이 발생하는지, 현재의 thread로 인터럽트가 발생하는지, 그 어느쪽이든가 최초로 발생할 때까지 블록 합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>timeout</CODE> - 대기하는 최장 시간<DD><CODE>unit</CODE> - timeout 인수의 시간 단위
<DT><B>반환값:</B><DD>이 executor 가 종료되었을 경우는 <tt>true</tt>, 종료전에 타임 아웃이 경과했을 경우는 <tt>false</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 대기중에 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="finalize()"><!-- --></A> <H3>
finalize</H3>
<PRE>
protected void <B>finalize</B>()</PRE>
<DL>
<DD>이 executor 가 참조되지 않게 되었을 때에 <tt>shutdown</tt> 를 호출합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#finalize()">finalize</A> </CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setThreadFactory(java.util.concurrent.ThreadFactory)"><!-- --></A> <H3>
setThreadFactory</H3>
<PRE>
public void <B>setThreadFactory</B>(<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> &nbsp;threadFactory)</PRE>
<DL>
<DD>새로운 thread의 작성에 사용하는 thread 팩토리를 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>threadFactory</CODE> - 새로운 thread 팩토리
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - threadFactory 가 null 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getThreadFactory()"><CODE>getThreadFactory()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getThreadFactory()"><!-- --></A> <H3>
getThreadFactory</H3>
<PRE>
public <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 내의 인터페이스">ThreadFactory</A>  <B>getThreadFactory</B>()</PRE>
<DL>
<DD>새로운 thread의 작성에 사용하는 thread 팩토리를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 thread 팩토리<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setThreadFactory(java.util.concurrent.ThreadFactory)"><CODE>setThreadFactory(java.util.concurrent.ThreadFactory)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)"><!-- --></A> <H3>
setRejectedExecutionHandler</H3>
<PRE>
public void <B>setRejectedExecutionHandler</B>(<A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> &nbsp;handler)</PRE>
<DL>
<DD>실행 가능하지 않은 태스크의 새로운 핸들러를 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>handler</CODE> - 새로운 핸들러
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 핸들러가 null 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getRejectedExecutionHandler()"><CODE>getRejectedExecutionHandler()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRejectedExecutionHandler()"><!-- --></A> <H3>
getRejectedExecutionHandler</H3>
<PRE>
public <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 내의 인터페이스">RejectedExecutionHandler</A>  <B>getRejectedExecutionHandler</B>()</PRE>
<DL>
<DD>실행 가능하지 않은 태스크의 현재의 핸들러를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 핸들러<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)"><CODE>setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setCorePoolSize(int)"><!-- --></A> <H3>
setCorePoolSize</H3>
<PRE>
public void <B>setCorePoolSize</B>(int&nbsp;corePoolSize)</PRE>
<DL>
<DD>thread의 코어수를 설정합니다. 이것은, 생성자 으로 설정되는 모든 값을 오버라이드(override) 합니다. 새로운 값이 현재의 값보다 작은 경우, 초과하는 기존의 thread는, 다음의 아이돌시에 종료합니다. 큰 경우는, 필요에 따라서 새로운 thread가 기동해, 큐에 들어가 있는 태스크가 실행됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>corePoolSize</CODE> - 새로운 코어 사이즈
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>corePoolSize</tt> 가 제로보다 작은 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()"><CODE>getCorePoolSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getCorePoolSize()"><!-- --></A> <H3>
getCorePoolSize</H3>
<PRE>
public int <B>getCorePoolSize</B>()</PRE>
<DL>
<DD>thread의 코어수를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 코어수<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize(int)"><CODE>setCorePoolSize(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="prestartCoreThread()"><!-- --></A> <H3>
prestartCoreThread</H3>
<PRE>
public boolean <B>prestartCoreThread</B>()</PRE>
<DL>
<DD>코어 thread를 기동해, IDLE 상태로 처리 대기로 합니다. 이것은, 새로운 태스크가 실행될 때 마셔 코어 thread를 기동하는 디폴트 정책를 오버라이드(override) 합니다. 모든 코어 thread가 벌써 기동이 끝난 상태인 경우는,<tt>false</tt> 를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>thread가 기동되었을 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="prestartAllCoreThreads()"><!-- --></A> <H3>
prestartAllCoreThreads</H3>
<PRE>
public int <B>prestartAllCoreThreads</B>()</PRE>
<DL>
<DD>모든 코어 thread를 기동해, IDLE 상태로 처리 대기로 합니다. 이것은, 새로운 태스크가 실행될 때 마셔 코어 thread를 기동하는 디폴트 정책를 오버라이드(override) 합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>기동된 thread의 수</DL>
</DD>
</DL>
<HR>

<A NAME="allowsCoreThreadTimeOut()"><!-- --></A> <H3>
allowsCoreThreadTimeOut</H3>
<PRE>
public boolean <B>allowsCoreThreadTimeOut</B>()</PRE>
<DL>
<DD>이 풀에서, keepAlive 시간내에 도착한 태스크가 없으면 코어 thread가 타임 아웃 및 종료하는 것이 허가되어 새로운 태스크가 도착했을 때는 필요에 따라서 코어 thread를 옮겨놓을 수 있는 경우는, true 를 돌려줍니다. true 의 경우는, 코어 thread 이외에 적용되는 것과 같은 킵얼라이브 정책가 코어 thread에도 적용됩니다. false 의 경우는 (디폴트), 착신하는 태스크가 없기 위해(때문에) 코어 thread가 종료할 것은 없습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>코어 thread로 타임 아웃이 허가되고 있는 경우는 <tt>true</tt>, 그렇지 않은 경우는 <tt>false</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="allowCoreThreadTimeOut(boolean)"><!-- --></A> <H3>
allowCoreThreadTimeOut</H3>
<PRE>
public void <B>allowCoreThreadTimeOut</B>(boolean&nbsp;value)</PRE>
<DL>
<DD>이 풀에서, 킵얼라이브 시간내에 도착한 태스크가 없으면 코어 thread가 타임 아웃 및 종료하는 것이 허가되어 새로운 태스크가 도착했을 때는 필요에 따라서 코어 thread를 옮겨놓을 수 있을지 어떨지를 제어하는 정책를 설정합니다. false 의 경우는, 착신하는 태스크가 없기 위해(때문에) 코어 thread가 종료할 것은 없습니다. true 의 경우는, 코어 thread 이외에 적용되는 것과 같은 킵얼라이브 정책가 코어 thread에도 적용됩니다. 연속적으로 thread를 옮겨놓을 수 없게 하기 위한(해),<tt>true</tt> 로 설정할 때는, 킵얼라이브 시간을 제로보다 크게 할 필요가 있습니다. 일반적으로은, 이 메소드를 호출하고 나서, 풀을 액티브하게 사용해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>value</CODE> - 타임 아웃 하는 경우는 <tt>true</tt>, 그렇지 않은 경우는 <tt>false</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 치가 <tt>true</tt> 로, 현재의 킵얼라이브 시간이 제로 이하의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setMaximumPoolSize(int)"><!-- --></A> <H3>
setMaximumPoolSize</H3>
<PRE>
public void <B>setMaximumPoolSize</B>(int&nbsp;maximumPoolSize)</PRE>
<DL>
<DD>thread의 최대 허용수를 설정합니다. 이것은, 생성자 으로 설정되는 모든 값을 오버라이드(override) 합니다. 새로운 값이 현재의 값보다 작은 경우, 초과하는 기존의 thread는, 다음의 아이돌시에 종료합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>maximumPoolSize</CODE> - 새로운 최대치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 새로운 최대치가 제로 이하의 경우, 또는 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()">core pool size</A>  보다 작은 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize()"><CODE>getMaximumPoolSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumPoolSize()"><!-- --></A> <H3>
getMaximumPoolSize</H3>
<PRE>
public int <B>getMaximumPoolSize</B>()</PRE>
<DL>
<DD>thread의 최대 허용수를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 최대 허용수<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize(int)"><CODE>setMaximumPoolSize(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setKeepAliveTime(long, java.util.concurrent.TimeUnit)"><!-- --></A> <H3>
setKeepAliveTime</H3>
<PRE>
public void <B>setKeepAliveTime</B>(long&nbsp;time,
                             <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</PRE>
<DL>
<DD>thread가 종료전에 IDLE 상태에 머물 수가 있는 제한 시간을 설정합니다. 현재 풀내에 코어수이상의 thread가 있는 경우는, 태스크를 처리하지 않고 이 시간만 대기하면(자), 초과한 thread는 종료합니다. 이것은, 생성자 으로 설정되는 모든 값을 오버라이드(override) 합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>time</CODE> - 대기하는 시간. time 치가 제로의 경우는, 태스크를 실행하자마자 초과한 thread가 종료하는<DD><CODE>unit</CODE> - time 인수의 시간 단위
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - time 가 제로보다 작은 경우, 또는 time 가 제로로 allowsCoreThreadTimeOut 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime(java.util.concurrent.TimeUnit)"><CODE>getKeepAliveTime(java.util.concurrent.TimeUnit)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getKeepAliveTime(java.util.concurrent.TimeUnit)"><!-- --></A> <H3>
getKeepAliveTime</H3>
<PRE>
public long <B>getKeepAliveTime</B>(<A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</PRE>
<DL>
<DD>코어 풀 사이즈를 넘는 thread가 종료전에 IDLE 상태에 머물 수가 있는, thread의 킵얼라이브 시간을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>unit</CODE> - 반환값으로 지정하는 시간 단위
<DT><B>반환값:</B><DD>제한 시간<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime(long, java.util.concurrent.TimeUnit)"><CODE>setKeepAliveTime(long, java.util.concurrent.TimeUnit)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getQueue()"><!-- --></A> <H3>
getQueue</H3>
<PRE>
public <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 내의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt; <B>getQueue</B>()</PRE>
<DL>
<DD>이 executor 로 사용하는 태스크 큐를 돌려줍니다. 태스크 큐에의 액세스는, 디버그 및 감시를 주된 목적으로 하고 있습니다. 이 큐는, 액티브하게 사용되고 있을 가능성이 있습니다. 태스크 큐를 꺼내도, 큐에 들어가 있는 태스크의 실행은 방해할 수 없습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>태스크 큐</DL>
</DD>
</DL>
<HR>

<A NAME="remove(java.lang.Runnable)"><!-- --></A> <H3>
remove</H3>
<PRE>
public boolean <B>remove</B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;task)</PRE>
<DL>
<DD>executor 의 내부 큐에 이 태스크가 존재하는 경우는 삭제하기 위해(때문에), 그 태스크가 아직 개시되어 있지 않은 경우는 실행되지 않습니다.

 <p> 이 메소드는 취소해 방식의 일부로서 편리한 일이 있습니다. 내부 큐에 배치되기 전에 다른 형식에 변환된 태스크는, 삭제에 실패할 가능성이 있습니다. 예를 들어,<tt>submit</tt> 를 사용해 들어가는 태스크는,<tt>Future</tt> 상태를 유지하는 형식에 변환되는 일이 있습니다. 다만, 이 경우는,<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#purge()"><CODE>purge()</CODE></A>  메소드를 사용해, 삭제된 Future 를 삭제할 수가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>task</CODE> - 삭제하는 태스크
<DT><B>반환값:</B><DD>태스크가 삭제되었을 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="purge()"><!-- --></A> <H3>
purge</H3>
<PRE>
public void <B>purge</B>()</PRE>
<DL>
<DD>삭제된 모든 <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 안의 인터페이스"><CODE>Future</CODE></A>  태스크를 워크 큐로부터 삭제하려고 합니다. 이 메소드는, 기능에 그 외의 영향이 없는, 기억 영역의 재생 오퍼레이션으로서 편리한 일이 있습니다. 삭제된 태스크가 실행될 것은 없습니다만, 워크스 레드가 액티브하게 삭제할 때까지 워크 큐내에 축적되는 경우가 있습니다. 이 메소드를 호출하면(자), 즉시 삭제하려고 합니다. 다만, 그 외의 thread에 의한 간섭이 존재하는 경우는, 이 메소드는 태스크의 삭제에 실패하는 일이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPoolSize()"><!-- --></A> <H3>
getPoolSize</H3>
<PRE>
public int <B>getPoolSize</B>()</PRE>
<DL>
<DD>풀내의 현재의 thread수를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>thread수</DL>
</DD>
</DL>
<HR>

<A NAME="getActiveCount()"><!-- --></A> <H3>
getActiveCount</H3>
<PRE>
public int <B>getActiveCount</B>()</PRE>
<DL>
<DD>액티브하게 태스크를 실행하고 있는 thread의 대략의 수를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>thread수</DL>
</DD>
</DL>
<HR>

<A NAME="getLargestPoolSize()"><!-- --></A> <H3>
getLargestPoolSize</H3>
<PRE>
public int <B>getLargestPoolSize</B>()</PRE>
<DL>
<DD>풀내에 동시에 존재한 최대 thread수를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>thread수</DL>
</DD>
</DL>
<HR>

<A NAME="getTaskCount()"><!-- --></A> <H3>
getTaskCount</H3>
<PRE>
public long <B>getTaskCount</B>()</PRE>
<DL>
<DD>지금까지 실행이 스케줄 된 태스크의 대략의 총수를 돌려줍니다. 태스크 및 thread 상태는, 계산중에 동적으로 변화하는 일이 있기 (위해)때문에, 반환값은 근사에 지나지 않습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>태스크수</DL>
</DD>
</DL>
<HR>

<A NAME="getCompletedTaskCount()"><!-- --></A> <H3>
getCompletedTaskCount</H3>
<PRE>
public long <B>getCompletedTaskCount</B>()</PRE>
<DL>
<DD>지금까지 실행이 완료한 태스크의 대략의 총수를 돌려줍니다. 태스크 및 thread 상태는, 계산중에 동적으로 변화하는 일이 있기 (위해)때문에, 반환값은 근사에 지나지 않습니다만, 연속해 호출해도 감소하지 않습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>태스크수</DL>
</DD>
</DL>
<HR>

<A NAME="beforeExecute(java.lang.Thread, java.lang.Runnable)"><!-- --></A> <H3>
beforeExecute</H3>
<PRE>
protected void <B>beforeExecute</B>(<A HREF="../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;t,
                             <A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;r)</PRE>
<DL>
<DD>지정된 thread로 지정된 Runnable 를 실행하기 전에 불려 가는 메소드입니다. 이 메소드는, 태스크 <tt>r</tt> 를 실행하는 thread <tt>t</tt> 에 의해 불려 가 ThreadLocal 의 재초기화나 로깅의 실행에 사용되는 경우가 있습니다.

 <p>이 구현은 처리를 실시하지 않습니다만, 서브 클래스에서 커스터마이즈 하는 것은 가능합니다. 주:복수의 오버라이드(override)를 적절히 상자로 하기 (위해)때문에, 일반적으로은, 서브 클래스에서는 이 메소드의 최후로 <tt>super.beforeExecute</tt> 를 호출하도록 해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>t</CODE> - 태스크 r 를 실행하는 thread<DD><CODE>r</CODE> - 실행되는 태스크</DL>
</DD>
</DL>
<HR>

<A NAME="afterExecute(java.lang.Runnable, java.lang.Throwable)"><!-- --></A> <H3>
afterExecute</H3>
<PRE>
protected void <B>afterExecute</B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;r,
                            <A HREF="../../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;t)</PRE>
<DL>
<DD>지정된 Runnable 의 실행 완료시에 불려 가는 메소드입니다. 이 메소드는 태스크를 실행한 thread에 의해 불려 갑니다. null 가 아닌 경우, Throwable 는, 실행이 강제 종료되는 원인이 된 캐치 되지 않는 <tt>RuntimeException</tt> 또는 <tt>Error</tt> 입니다.

 <p><b>주:</b> 액션이 명시적으로, 또는 <tt>submit</tt> 등의 메소드에 의해, 태스크 (<A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 안의 클래스"><CODE>FutureTask</CODE></A>  등) 내에 들어가는 경우, 이러한 태스크 객체는 계산의 예외를 캐치 해 유지합니다. 그 때문에, 이상종료(ABEND) 할 것은 없고, 내부 예외는 이 메소드에게 건네지지 않습니다. <em></em>

 <p>이 구현은 처리를 실시하지 않습니다만, 서브 클래스에서 커스터마이즈 하는 것은 가능합니다. 주:복수의 오버라이드(override)를 적절히 상자로 하기 (위해)때문에, 일반적으로, 서브 클래스에서는 이 메소드의 최초로 <tt>super.afterExecute</tt> 를 호출하도록 해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>r</CODE> - 완료한 Runnable<DD><CODE>t</CODE> - 종료의 원인이 된 예외, 또는 실행이 정상적으로 완료했을 경우는 null</DL>
</DD>
</DL>
<HR>

<A NAME="terminated()"><!-- --></A> <H3>
terminated</H3>
<PRE>
protected void <B>terminated</B>()</PRE>
<DL>
<DD>executor 가 종료되었을 때에 불려 가는 메소드입니다. 디폴트의 구현은 처리를 실시하지 않습니다. 주:복수의 오버라이드(override)를 적절히 상자로 하기 (위해)때문에, 일반적으로, 서브 클래스에서는 이 메소드내에서 <tt>super.terminated</tt> 를 호출하도록 해 주세요.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ThreadPoolExecutor.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?java/util/concurrent/ThreadPoolExecutor.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="ThreadPoolExecutor.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
