<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:56:50 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Math (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Math (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Math.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/Long.html" title="java.lang 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/NegativeArraySizeException.html" title="java.lang 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Math.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Math.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang</FONT>
<BR>
클래스 Math</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.lang.Math</B>
</PRE>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public final class <B>Math</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
<code>Math</code> 클래스는, 지수함수, 대수관계, 평방근, 및 삼각함수라고 하는 기본적인 수치 처리를 실행하기 위한 메소드를 포함하고 있습니다.
 
 <p><code>StrictMath</code> 클래스의 일부의 수치 메소드와는 달라,<code>Math</code> 클래스의 등가 함수의 모든 구현은, 비트대  비트의 같은 결과를 돌려주도록(듯이)는 정의되고 있지 않습니다. 이 완만함에 의해, 엄밀한 재현성이 요구되지 않는 구현에 대해 퍼포먼스의 향상이 가능하게 됩니다.
 
 <p>많은 <code>Math</code> 메소드는 디폴트로,<code>StrictMath</code> 의 등가 메소드에 그러한 구현을 사용하기 위해서 단지 호출합니다. 코드 제네레이터는, 플랫폼 고유의 네이티브 라이브러리 또는 마이크로 프로세서의 명령이 있는 경우는 적극적으로 사용해, 고성능인 <code>Math</code> 메소드의 구현을 제공합니다. 그러한 고성능인 구현에서도 <code>Math</code> 의 스펙에 준거할 필요가 있습니다.
 
 <p>구현 스펙의 품질은, 2 개의 프로퍼티, 반환되는 결과의 정확함, 및 메소드의 단조성과 관계가 있습니다. 부동 소수점 <code>Math</code> 메소드의 정확함은,<i>ulp</i> (최신 위치의 단위)로 계측 됩니다. 부동 소수점 형식이 지정되었을 경우, 특정의 실수치의 ulp 는 그 수치를 둘러싸고 있는 2 개의 부동 소수점치의 거리가 됩니다. 메소드의 정확성을, 특정의 인수에 관해서는 아니고 전체적으로 논하는 경우에 나타나는 ulp 수는, 모든 인수에 있어서의 최대 오차가 됩니다. 메소드가 돌려주는 에러가 항상 0.5 ulp 미만의 경우, 그 메소드는 실제의 결과에 가장 가까운 부동 소수점수(실수)를 항상 돌려줍니다.  이런 종류의 메소드는 「올바르게 말 수 있다」라고 있습니다. 일반적으로은, 올바르게 말 수 있었던 메소드를 사용하는 것이 부동 소수점 근사치를 얻는 최선의 방법입니다만, 다수의 부동 소수점 메소드를 올바르게 마는 것은, 실제적이지는 않습니다. 그 대신에 <code>Math</code> 클래스의 경우, 1 또는 2 ulp 보다 큰 에러가 특정의 메소드로 허가됩니다. 비공식에는 1 ulp 의 에러에서는, 정확한 결과가 표현 가능한 수치의 경우에 정확한 결과가 돌려주어집니다. 그렇지 않은 경우, 정확한 결과를 둘러싸는 2 개의 부동 소수점치중 한쪽이 돌려주어질 가능성이 있습니다. 정확한 결과의 절대치가 큰 경우, 괄호의 한편의 단 점이 무한한 가능성이 있습니다. 개별의 인수의 정확함에 가세해 메소드가 다른 인수간의 적절한 관계도 중요합니다. 이 때문에, 0.5 ulp 보다 큰 에러를 보관 유지하는 메소드는, 「반단조」인 것이 요구됩니다. 수학 함수가 비증가인 경우는 항상, 부동 소수점 근사치도 비증가가 됩니다. 1 ulp 의 정확성을 보관 유지하는 근사치 모든 것이, 자동적으로 단조 요건을 채우는 것은 아닙니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#E">E</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;자연대수의 바닥 <code>e</code> 에 가장 가까운 <i>double</i> 치입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#PI">PI</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;원주와 그 직경의 비 <i>pi</i> 에 가장 가까운 <code>double</code> 치입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#abs(double)">abs</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>double</code> 치의 절대치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#abs(float)">abs</A> </B>(float&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>float</code> 치의 절대치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#abs(int)">abs</A> </B>(int&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>int</code> 치의 절대치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#abs(long)">abs</A> </B>(long&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>long</code> 치의 절대치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#acos(double)">acos</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 값의 역여현 (아크 코사인)을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#asin(double)">asin</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 값의 역정현 (아크 싸인)을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#atan(double)">atan</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 값의 역탄젠트 (arctangent)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#atan2(double, double)">atan2</A> </B>(double&nbsp;y,
      double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;극좌표 (r, &nbsp;<i>theta</i>)에의 구형 좌표 (<code>x</code>, &nbsp;<code>y</code>)의 변환으로부터 각도 <i>theta</i> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#cbrt(double)">cbrt</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>double</code> 치의 입방근을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#ceil(double)">ceil</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인수의 값이상으로, 계산상의 정수로 동일한, 최소의 (부의 무한대에 가장 가깝다) <code>double</code> 치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#copySign(double, double)">copySign</A> </B>(double&nbsp;magnitude,
         double&nbsp;sign)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 번째의 부동 소수점 인수의 부호를 붙인, 최초의 부동 소수점 인수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#copySign(float, float)">copySign</A> </B>(float&nbsp;magnitude,
         float&nbsp;sign)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 번째의 부동 소수점 인수의 부호를 붙인, 최초의 부동 소수점 인수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#cos(double)">cos</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 각도의 여현 (코사인)을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#cosh(double)">cosh</A> </B>(double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>double</code> 치의 쌍곡선 여현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#exp(double)">exp</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;나-수 <i>e</i> 를 <code>double</code> 치로 누승한 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#expm1(double)">expm1</A> </B>(double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>e</i><sup>x</sup>&nbsp;-1 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#floor(double)">floor</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인수의 값이하로, 계산상의 정수로 동일한, 최대의 (정의 무한대에 가장 가깝다) <code>double</code> 치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#getExponent(double)">getExponent</A> </B>(double&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>double</code> 의 표현으로 사용되는 불편 지수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#getExponent(float)">getExponent</A> </B>(float&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>float</code> 의 표현으로 사용되는 불편 지수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#hypot(double, double)">hypot</A> </B>(double&nbsp;x,
      double&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;중간의 오버플로우나 언더 플로우(underflow)없이 sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)가 돌려주어집니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#IEEEremainder(double, double)">IEEEremainder</A> </B>(double&nbsp;f1,
              double&nbsp;f2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IEEE 754 표준에 따라, 2 개의 인수에 대해 잉여를 계산합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#log(double)">log</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>double</code> 치의 자연대수치 (바닥은 <i>e</i>)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#log10(double)">log10</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>double</code> 치의 10 을 바닥으로 하는 대수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#log1p(double)">log1p</A> </B>(double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인수와 1 의 합계의 자연대수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#max(double, double)">max</A> </B>(double&nbsp;a,
    double&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 개의 <code>double</code> 치의 쳐 큰 편을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#max(float, float)">max</A> </B>(float&nbsp;a,
    float&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 개의 <code>float</code> 치의 쳐 큰 편을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#max(int, int)">max</A> </B>(int&nbsp;a,
    int&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 개의 <code>int</code> 치의 쳐 큰 편을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#max(long, long)">max</A> </B>(long&nbsp;a,
    long&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 개의 <code>long</code> 치의 쳐 큰 편을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#min(double, double)">min</A> </B>(double&nbsp;a,
    double&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 개의 <code>double</code> 치의 쳐 작은 편을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#min(float, float)">min</A> </B>(float&nbsp;a,
    float&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 개의 <code>float</code> 치의 쳐 작은 편을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#min(int, int)">min</A> </B>(int&nbsp;a,
    int&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 개의 <code>int</code> 치의 쳐 작은 편을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#min(long, long)">min</A> </B>(long&nbsp;a,
    long&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 개의 <code>long</code> 치의 쳐 작은 편을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#nextAfter(double, double)">nextAfter</A> </B>(double&nbsp;start,
          double&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 번째의 인수의 방향으로, 최초의 인수에 인접하는 부동 소수점치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#nextAfter(float, double)">nextAfter</A> </B>(float&nbsp;start,
          double&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 번째의 인수의 방향으로, 최초의 인수에 인접하는 부동 소수점치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#nextUp(double)">nextUp</A> </B>(double&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;정의 무한대 방향으로 <code>d</code> 에 인접하는 부동 소수점치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#nextUp(float)">nextUp</A> </B>(float&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;정의 무한대 방향으로 <code>f</code> 에 인접하는 부동 소수점치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#pow(double, double)">pow</A> </B>(double&nbsp;a,
    double&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 번째의 인수를, 2 번째의 인수로 누승한 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#random()">random</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>0.0</code> 이상으로,<code>1.0</code> 보다 작은 정의 부호가 붙은 <code>double</code> 치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#rint(double)">rint</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인수의 값에 가장 근처, 계산상의 정수에 동일한 <code>double</code> 치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#round(double)">round</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인수에 가장 가까운 <code>long</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#round(float)">round</A> </B>(float&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인수에 가장 가까운 <code>int</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#scalb(double, int)">scalb</A> </B>(double&nbsp;d,
      int&nbsp;scaleFactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double 치 세트의 멤버에게 단일의 올바르게 말 수 있었던 부동 소수점을 거는 것에 의해 실행되는 경우와 같게,<code>d</code> &times; 2<sup><code>scaleFactor</code></sup> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#scalb(float, int)">scalb</A> </B>(float&nbsp;f,
      int&nbsp;scaleFactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float 치 세트의 멤버에게 단일의 올바르게 말 수 있었던 부동 소수점을 거는 것에 의해 실행되는 경우와 같게,<code>d</code> &times; 2<sup><code>scaleFactor</code></sup> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#signum(double)">signum</A> </B>(double&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인수의 부호 요소를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#signum(float)">signum</A> </B>(float&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인수의 부호 요소를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#sin(double)">sin</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 각도의 정현 (싸인)을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#sinh(double)">sinh</A> </B>(double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>double</code> 치의 쌍곡선 정현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#sqrt(double)">sqrt</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>double</code> 치의 올바르게 만 정의 평방근을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#tan(double)">tan</A> </B>(double&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 각도의 탄젠트 (탄젠트)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#tanh(double)">tanh</A> </B>(double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>double</code> 치의 쌍곡선 탄젠트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#toDegrees(double)">toDegrees</A> </B>(double&nbsp;angrad)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;라디안으로 계측 한 각도를, 상당할 때로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#toRadians(double)">toRadians</A> </B>(double&nbsp;angdeg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;번으로 계측 한 각도를, 상당하는 라디안으로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#ulp(double)">ulp</A> </B>(double&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인수의 ulp 의 사이즈를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Math.html#ulp(float)">ulp</A> </B>(float&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인수의 ulp 의 사이즈를 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="E"><!-- --></A> <H3>
E</H3>
<PRE>
public static final double <B>E</B></PRE>
<DL>
<DD>자연대수의 바닥 <code>e</code> 에 가장 가까운 <i>double</i> 치입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#java.lang.Math.E">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="PI"><!-- --></A> <H3>
PI</H3>
<PRE>
public static final double <B>PI</B></PRE>
<DL>
<DD>원주와 그 직경의 비 <i>pi</i> 에 가장 가까운 <code>double</code> 치입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#java.lang.Math.PI">정수 필드치</A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="sin(double)"><!-- --></A> <H3>
sin</H3>
<PRE>
public static double <B>sin</B>(double&nbsp;a)</PRE>
<DL>
<DD>지정된 각도의 정현 (싸인)을 돌려줍니다. 특례로서:
<ul><li>인수가 NaN 또는 무한대의 경우, 결과는 NaN 가 됩니다.
<li>인수가 제로의 경우, 결과는 제로에 인수와 같은 부호를 매긴 값이 됩니다. </ul>
 
 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다. 결과는 반 단조로운 것에 한정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 라디안으로 나타낸 각도
<DT><B>반환값:</B><DD>인수의 정현 (싸인)</DL>
</DD>
</DL>
<HR>

<A NAME="cos(double)"><!-- --></A> <H3>
cos</H3>
<PRE>
public static double <B>cos</B>(double&nbsp;a)</PRE>
<DL>
<DD>지정된 각도의 여현 (코사인)을 돌려줍니다. 특례로서:
<ul><li>인수가 NaN 또는 무한대의 경우, 결과는 NaN 가 됩니다. </ul>
 
 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다. 결과는 반 단조로운 것에 한정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 라디안으로 나타낸 각도
<DT><B>반환값:</B><DD>인수의 여현 (코사인)</DL>
</DD>
</DL>
<HR>

<A NAME="tan(double)"><!-- --></A> <H3>
tan</H3>
<PRE>
public static double <B>tan</B>(double&nbsp;a)</PRE>
<DL>
<DD>지정된 각도의 탄젠트 (탄젠트)를 돌려줍니다. 특례로서:
<ul><li>인수가 NaN 또는 무한대의 경우, 결과는 NaN 가 됩니다.
<li>인수가 제로의 경우, 결과는 제로에 인수와 같은 부호를 매긴 값이 됩니다. </ul>
 
 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다. 결과는 반 단조로운 것에 한정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 라디안으로 나타낸 각도
<DT><B>반환값:</B><DD>인수의 탄젠트 (탄젠트)</DL>
</DD>
</DL>
<HR>

<A NAME="asin(double)"><!-- --></A> <H3>
asin</H3>
<PRE>
public static double <B>asin</B>(double&nbsp;a)</PRE>
<DL>
<DD>지정된 값의 역정현 (아크 싸인)을 돌려줍니다. 반환되는 각도의 범위는,-<i>pi</i>/2 ~ <i>pi</i>/2 의 범위입니다. 특례로서
<ul><li>인수가 NaN 또는 그 절대치가 1 을 넘는 경우, 결과는 NaN 가 됩니다.
<li>인수가 제로의 경우, 결과는 제로에 인수와 같은 부호를 매긴 값이 됩니다. </ul>
 
 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다. 결과는 반 단조로운 것에 한정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 이 값의 역정현 (아크 싸인)이 반환된다
<DT><B>반환값:</B><DD>인수의 역정현 (아크 싸인)</DL>
</DD>
</DL>
<HR>

<A NAME="acos(double)"><!-- --></A> <H3>
acos</H3>
<PRE>
public static double <B>acos</B>(double&nbsp;a)</PRE>
<DL>
<DD>지정된 값의 역여현 (아크 코사인)을 돌려줍니다. 반환되는 각도의 범위는, 0.0 ~ <i>pi</i> 입니다. 특례로서
<ul><li>인수가 NaN 또는 그 절대치가 1 을 넘는 경우, 결과는 NaN 가 됩니다. </ul>
 
 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다. 결과는 반 단조로운 것에 한정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 이 값의 역여현 (아크 코사인)이 반환된다
<DT><B>반환값:</B><DD>인수의 역여현 (아크 코사인)</DL>
</DD>
</DL>
<HR>

<A NAME="atan(double)"><!-- --></A> <H3>
atan</H3>
<PRE>
public static double <B>atan</B>(double&nbsp;a)</PRE>
<DL>
<DD>지정된 값의 역탄젠트 (arctangent)를 돌려줍니다. 반환되는 각도의 범위는,-<i>pi</i>/2 ~ <i>pi</i>/2 의 범위입니다. 특례로서
<ul><li>인수가 NaN 의 경우, NaN 가 돌려주어집니다.
<li>인수가 제로의 경우, 결과는 제로에 인수와 같은 부호를 매긴 값이 됩니다. </ul>
 
 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다. 결과는 반 단조로운 것에 한정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 이 값의 역탄젠트 (arctangent)가 반환된다
<DT><B>반환값:</B><DD>인수의 역탄젠트 (arctangent)</DL>
</DD>
</DL>
<HR>

<A NAME="toRadians(double)"><!-- --></A> <H3>
toRadians</H3>
<PRE>
public static double <B>toRadians</B>(double&nbsp;angdeg)</PRE>
<DL>
<DD>번으로 계측 한 각도를, 상당하는 라디안으로 변환합니다. 일반적으로, 번으로부터 라디안에의 변환은 정확하지는 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>angdeg</CODE> - 도로 계측 한 각도
<DT><B>반환값:</B><DD>라디안으로 나타낸, 각도 <code>angdeg</code> 의 계측치<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toDegrees(double)"><!-- --></A> <H3>
toDegrees</H3>
<PRE>
public static double <B>toDegrees</B>(double&nbsp;angrad)</PRE>
<DL>
<DD>라디안으로 계측 한 각도를, 상당할 때로 변환합니다. 일반적으로, 라디안으로부터 번에의 변환은 정확하지는 않습니다.  사용자는,<code>cos(toRadians(90.0))</code> 가 정확하게 <code>0.0</code> 에 대응하는 것을 기대할 수 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>angrad</CODE> - 라디안으로 나타낸 각도
<DT><B>반환값:</B><DD>도로 나타낸, 각도 <code>angrad</code> 의 계측치<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="exp(double)"><!-- --></A> <H3>
exp</H3>
<PRE>
public static double <B>exp</B>(double&nbsp;a)</PRE>
<DL>
<DD>나-수 <i>e</i> 를 <code>double</code> 치로 누승한 값을 돌려줍니다. 특례로서:
<ul><li>인수가 NaN 의 경우는, NaN 를 돌려줍니다.
<li>인수가 정의 무한대의 경우는, 정의 무한대가 돌려주어집니다.
<li>인수가 부의 무한대의 경우는, 정의 제로가 돌려주어집니다. </ul>
 
 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다. 결과는 반 단조로운 것에 한정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - <i>e</i> 로 설정한 지수
<DT><B>반환값:</B><DD><i>e</i><sup><code>a</code></sup> 의 값<i> 
e</i> 는 자연대수의 바닥</DL>
</DD>
</DL>
<HR>

<A NAME="log(double)"><!-- --></A> <H3>
log</H3>
<PRE>
public static double <B>log</B>(double&nbsp;a)</PRE>
<DL>
<DD>지정된 <code>double</code> 치의 자연대수치 (바닥은 <i>e</i>)를 돌려줍니다. 특례로서:
<ul><li>인수가 NaN 또는 제로보다 작은 경우, NaN 가 돌려주어집니다.
<li>인수가 정의 무한대의 경우는, 정의 무한대가 돌려주어집니다.
<li>인수가 정의 제로 또는 부의 제로의 경우는, 부의 무한대가 돌려주어집니다. </ul>
 
 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다. 결과는 반 단조로운 것에 한정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치
<DT><B>반환값:</B><DD>ln&nbsp;<code>a</code> 의 값. <code>a</code> 의 자연대수</DL>
</DD>
</DL>
<HR>

<A NAME="log10(double)"><!-- --></A> <H3>
log10</H3>
<PRE>
public static double <B>log10</B>(double&nbsp;a)</PRE>
<DL>
<DD><code>double</code> 치의 10 을 바닥으로 하는 대수를 돌려줍니다. 특례로서:

<ul><li>인수가 NaN 또는 제로보다 작은 경우, NaN 가 돌려주어집니다.
<li>인수가 정의 무한대의 경우는, 정의 무한대가 돌려주어집니다.
<li>인수가 정의 제로 또는 부의 제로의 경우는, 부의 무한대가 돌려주어집니다.
<li> 인수가 정수 <i>n</i> 의 10<sup><i>n</i></sup> 에 동일한 경우, 결과는 <i>n</i> 가 됩니다.
 </ul>
 
 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다. 결과는 반 단조로운 것에 한정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치
<DT><B>반환값:</B><DD><code>a</code> 의 10 을 바닥으로 하는 대수<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="sqrt(double)"><!-- --></A> <H3>
sqrt</H3>
<PRE>
public static double <B>sqrt</B>(double&nbsp;a)</PRE>
<DL>
<DD><code>double</code> 치의 올바르게 만 정의 평방근을 돌려줍니다. 특례로서:
<ul><li>인수가 NaN 또는 제로보다 작은 경우, NaN 가 돌려주어집니다.  
<li>인수가 정의 무한대의 경우는, 정의 무한대가 돌려주어집니다.  
<li>인수가 정의 제로 또는 부의 제로의 경우는, 인수와 같은 값이 돌려주어집니다. </ul>
그렇지 않은 경우는, 인수치의 진정한 수학의 평방근에 가장 가까운 <code>double</code> 치가 돌려주어집니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치
<DT><B>반환값:</B><DD><code>a</code> 정의 평방근
인수가 NaN 일까 제로보다 작은 경우는, 결과도 NaN</DL>
</DD>
</DL>
<HR>

<A NAME="cbrt(double)"><!-- --></A> <H3>
cbrt</H3>
<PRE>
public static double <B>cbrt</B>(double&nbsp;a)</PRE>
<DL>
<DD><code>double</code> 치의 입방근을 돌려줍니다. 정의 유한치 <code>x</code> 의 경우,<code>cbrt(-x) == -cbrt(x)</code>.  즉, 0 보다 작은 값의 입방근은, 값의 절대치의 입방근을 부로 한 것입니다.
 
특례로서: 

 <ul>
 
<li>인수가 NaN 의 경우, NaN 가 돌려주어집니다.

<li>인수가 무한대의 경우, 결과는 인수와 같은 부호를 붙인 무한대가 됩니다.

<li>인수가 제로의 경우, 결과는 제로에 인수와 같은 부호를 매긴 값이 됩니다.
 
 </ul>

 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치
<DT><B>반환값:</B><DD><code>a</code> 의 입방근<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="IEEEremainder(double, double)"><!-- --></A> <H3>
IEEEremainder</H3>
<PRE>
public static double <B>IEEEremainder</B>(double&nbsp;f1,
                                   double&nbsp;f2)</PRE>
<DL>
<DD>IEEE 754 표준에 따라, 2 개의 인수에 대해 잉여를 계산합니다. 잉여의 값은, 계산상은 <code>f1&nbsp;-&nbsp;f2</code>&nbsp;&times;&nbsp;<i>n</i> 에 동일해집니다.  여기서,<i>n</i> 는 <code>f1/f2</code> 의 상의 정확한 값에 가장 가까운 정수입니다. <code> f1/f2</code> 에 같은 정도로 근사 하는 정수가 2 개 존재하는 경우,<i>n</i> 에는 짝수가 선택됩니다. 잉여가 제로가 되는 경우, 그 부호는 1 번째의 인수의 부호와 같게 됩니다. 특례로서:
<ul><li>어느 쪽인가의 인수가 NaN, 1 번째의 인수가 무한대, 2 번째의 인수가 정의 제로 또는 부의 제로의 경우는, NaN 가 돌려주어집니다.
<li>1 번째의 인수가 유한해 2 번째의 인수가 무한대의 경우는, 1 번째의 인수와 같은 값이 돌려주어집니다. </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>f1</CODE> - 피제수<DD><CODE>f2</CODE> - 제수
<DT><B>반환값:</B><DD><code>f1</code> 를 <code>f2</code> 로 제산했을 때의 잉여</DL>
</DD>
</DL>
<HR>

<A NAME="ceil(double)"><!-- --></A> <H3>
ceil</H3>
<PRE>
public static double <B>ceil</B>(double&nbsp;a)</PRE>
<DL>
<DD>인수의 값이상으로, 계산상의 정수로 동일한, 최소의 (부의 무한대에 가장 가깝다) <code>double</code> 치를 돌려줍니다. 특례로서:
<ul><li>인수가 벌써 계산상의 정수로 동일한 경우는, 인수와 같은 값이 돌려주어집니다. <li>인수가 NaN, 무한대, 정의 제로, 또는 부의 제로의 경우는, 인수와 같은 값이 돌려주어집니다. <li>인수가 제로보다 작고,-1. 0 보다 큰 경우는, 부의 제로가 돌려주어집니다. </ul> <code>Math.ceil(x)</code> 의 값은 <code>-Math.floor(-x)</code> 와 완전히 같은 점에 주의해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치
<DT><B>반환값:</B><DD>인수의 값이상으로, 계산상의 정수로 동일한, 최소의 (부의 무한대에 가장 가깝다) 부동 소수점치</DL>
</DD>
</DL>
<HR>

<A NAME="floor(double)"><!-- --></A> <H3>
floor</H3>
<PRE>
public static double <B>floor</B>(double&nbsp;a)</PRE>
<DL>
<DD>인수의 값이하로, 계산상의 정수로 동일한, 최대의 (정의 무한대에 가장 가깝다) <code>double</code> 치를 돌려줍니다. 특례로서:
<ul><li>인수가 벌써 계산상의 정수로 동일한 경우는, 인수와 같은 값이 돌려주어집니다. <li>인수가 NaN, 무한대, 정의 제로, 또는 부의 제로의 경우는, 인수와 같은 값이 돌려주어집니다. </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치
<DT><B>반환값:</B><DD>인수의 값이상으로, 계산상의 정수로 동일한, 최대의 (정의 무한대에 가장 가깝다) 부동 소수점치</DL>
</DD>
</DL>
<HR>

<A NAME="rint(double)"><!-- --></A> <H3>
rint</H3>
<PRE>
public static double <B>rint</B>(double&nbsp;a)</PRE>
<DL>
<DD>인수의 값에 가장 근처, 계산상의 정수에 동일한 <code>double</code> 치를 돌려줍니다. 2 개의 <code>double</code> 치의 정수가 같은 정도로 근사 하고 있는 경우, 결과는 짝수의 정수치가 됩니다. 특례로서:
<ul><li>인수가 벌써 계산상의 정수로 동일한 경우는, 인수와 같은 값이 돌려주어집니다.  
<li>인수가 NaN, 무한대, 정의 제로, 또는 부의 제로의 경우는, 인수와 같은 값이 돌려주어집니다. </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - <code>double</code> 치
<DT><B>반환값:</B><DD>계산상의 정수에 동일한 <code>a</code> 에 가장 가까운 부동 소수점치</DL>
</DD>
</DL>
<HR>

<A NAME="atan2(double, double)"><!-- --></A> <H3>
atan2</H3>
<PRE>
public static double <B>atan2</B>(double&nbsp;y,
                           double&nbsp;x)</PRE>
<DL>
<DD>극좌표 (r, &nbsp;<i>theta</i>)에의 구형 좌표 (<code>x</code>, &nbsp;<code>y</code>)의 변환으로부터 각도 <i>theta</i> 를 돌려줍니다. 이 메소드는,<code>y/x</code> 의 역탄젠트 (arctangent)를 -<i>pi</i> ~ <i>pi</i> 의 범위에서 계산해, 위상 theta (시타)를 요구합니다. 특례로서:
<ul><li>어느 쪽인가의 인수가 NaN 의 경우, 결과는 NaN 가 됩니다.  
<li>1 번째의 인수가 정의 제로로 2 번째의 인수가 정, 또는 1 번째의 인수가 정의 유한해 2 번째의 인수가 정의 무한대의 경우, 결과는 정의 제로가 됩니다.  
<li>1 번째의 인수가 부의 제로로 2 번째의 인수가 정, 또는 1 번째의 인수가 부의 유한해 2 번째의 인수가 정의 무한대의 경우, 결과는 부의 제로가 됩니다.  
<li>1 번째의 인수가 정의 제로로 2 번째의 인수가 부, 또는 1 번째의 인수가 정의 유한해 2 번째의 인수가 부의 무한대의 경우, 결과는 <i>pi</i> 에 가장 근사의 <code>double</code> 치가 됩니다.  
<li>1 번째의 인수가 부의 제로로 2 번째의 인수가 부, 또는 1 번째의 인수가 부의 유한해 2 번째의 인수가 부의 무한대의 경우, 결과는 -<i>pi</i> 에 가장 근사의 <code>double</code> 치가 됩니다.  
<li>1 번째의 인수가 정으로 2 번째의 인수가 정 또는 부의 제로, 또는 1 번째의 인수가 정의 무한대에 2 번째의 인수가 유한의 경우, 결과는 <i>pi</i>/2 에 가장 근사의 <code>double</code> 치가 됩니다.  
<li>1 번째의 인수가 부로 2 번째의 인수가 정 또는 부의 제로, 또는 1 번째의 인수가 부의 무한대에 2 번째의 인수가 유한의 경우, 결과는 -<i>pi</i>/2 에 가장 근사의 <code>double</code> 치가 됩니다.  
<li>어느 쪽의 인수도 정의 무한대의 경우, 결과는 <i>pi</i>/4 에 가장 근사의 <code>double</code> 치가 됩니다.  
<li>1 번째의 인수가 정의 무한대에 2 번째의 인수가 부의 무한대의 경우, 결과는 3*<i>pi</i>/4 에 가장 근사의 <code>double</code> 치가 됩니다.  
<li>1 번째의 인수가 부의 무한대에 2 번째의 인수가 정의 무한대의 경우, 결과는 -<i>pi</i>/4 에 가장 근사의 <code>double</code> 치가 됩니다.  
<li>어느 쪽의 인수도 부의 무한대의 경우, 결과는 -3*<i>pi</i>/4 에 가장 근사의 <code>double</code> 치가 됩니다. </ul>
 
 <p>계산 결과는, 정확한 결과의 2 ulp 이내가 아니면 안됩니다. 결과는 반 단조로운 것에 한정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>y</CODE> - 종좌표<DD><CODE>x</CODE> - 횡좌표
<DT><B>반환값:</B><DD>직교좌표 (데카르트 좌표) 상의점 (<i>x</i>, &nbsp;<i>y</i>)에 대응하는 극좌표상의 점 (<i>r</i>, &nbsp;<i>theta</i>)의 <i>theta</i> (시타) 성분</DL>
</DD>
</DL>
<HR>

<A NAME="pow(double, double)"><!-- --></A> <H3>
pow</H3>
<PRE>
public static double <B>pow</B>(double&nbsp;a,
                         double&nbsp;b)</PRE>
<DL>
<DD>1 번째의 인수를, 2 번째의 인수로 누승한 값을 돌려줍니다. 특례로서:

<ul><li>2 번째의 인수가 정의 제로 또는 부의 제로의 경우는, 결과는 1.0 이 됩니다.  
<li>2 번째의 인수가 1.0 의 경우는, 결과는 1 번째의 인수와 같은 값이 됩니다.
<li>2 번째의 인수가 NaN 의 경우는, 결과는 NaN 가 됩니다.  
<li>1 번째의 인수가 NaN 로 2 번째의 인수가 제로가 아닌 경우, 결과는 NaN 가 됩니다.  

<li>조건
 <ul>
<li>최초의 인수의 절대치가 1 보다 크고, 2 번째의 인수가 정의 무한대의 경우
<li>최초의 인수의 절대치가 1 보다 작고, 2 번째의 인수가 부의 무한대의 경우
 </ul>
결과는 정의 무한대가 된다 

<li>조건 
 <ul>
<li>최초의 인수의 절대치가 1 보다 크고, 2 번째의 인수가 부의 무한대의 경우 
<li>최초의 인수의 절대치가 1 보다 작고, 2 번째의 인수가 정의 무한대의 경우
 </ul>
결과는 정의 제로가 된다 

<li>1 번째의 인수의 절대치가 1 으로 2 번째의 인수가 무한대의 경우는, 결과는 NaN 가 된다 

<li>조건 
 <ul>
<li>최초의 인수가 정의 제로, 한편 2 번째의 인수가 제로보다 큰 경우
<li>최초의 인수가 정의 무한대로, 한편 2 번째의 인수가 제로보다 작은 경우
 </ul>
결과는 정의 제로가 된다 

<li>조건 
 <ul>
<li>최초의 인수가 정의 제로로, 한편 2 번째의 인수가 제로보다 작은 경우
<li>최초의 인수가 정의 무한대로, 한편 2 번째의 인수가 제로보다 큰 경우
 </ul>
결과는 정의 무한대가 된다

<li>조건 
 <ul>
<li>최초의 인수가 부의 제로, 한편 2 번째의 인수가 제로보다 크지만 유한의 홀수의 정수가 아닌 경우
<li>최초의 인수가 부의 무한대이며, 한편 2 번째의 인수가 제로보다 작지만 유한의 홀수의 정수가 아닌 경우
 </ul>
결과는 정의 제로가 된다 

<li>조건 
 <ul>
<li>최초의 인수가 부의 제로이며, 한편 2 번째의 인수가 유한의 홀수의 정수의 경우
<li>최초의 인수가 부의 무한대이며, 한편 2 번째의 인수가 부의 유한의 홀수의 정수의 경우
 </ul>
결과는 부의 제로가 된다 

<li>조건
 <ul>
<li>최초의 인수가 부의 제로이며, 한편 2 번째의 인수가 제로보다 작지만 유한의 홀수의 정수가 아닌 경우
<li>최초의 인수가 부의 무한대이며, 한편 2 번째의 인수가 제로보다 크지만 유한의 홀수의 정수가 아닌 경우
 </ul>
결과는 정의 무한대가 된다 

<li>조건 
 <ul>
<li>최초의 인수가 부의 제로이며, 한편 2 번째의 인수가 유한의 홀수의 정수의 경우
<li>최초의 인수가 부의 무한대이며, 한편 2 번째의 인수가 정의 유한의 홀수의 정수의 경우
 </ul>
결과는 부의 무한대가 된다 

<li>최초의 인수가 유한해 제로보다 작은 경우
 <ul>
<li> 2 번째의 인수가 유한의 짝수의 정수의 경우, 결과는 최초의 인수의 절대치를 2 번째의 인수로 누승한 값에 동일해진다

<li>2 번째의 인수가 유한의 홀수의 정수의 경우, 결과는 최초의 인수의 절대치를 2 번째의 인수로 누승한 값의 0 보다 작은 값에 동일해진다

<li>2 번째의 인수가 유한하고, 한편 정수가 아닌 경우, 결과는 NaN 가 된다
 </ul>

<li>어느 쪽의 인수도 정수의 경우, 결과가 실제 <code>double</code> 치로서 정확하게 나타내지는 경우는 1 번째의 인수를 2 번째의 인수로 누승한 계산치와 완전히 같은 결과가 된다</ul>
 
 <p>(상기의 설명에 대해서는,<A HREF="../../java/lang/Math.html#ceil(double)"><CODE><tt>ceil</tt></CODE></A>  메소드에 의한 고정 소수점, 또는 같은 것입니다만,<A HREF="../../java/lang/Math.html#floor(double)"><CODE><tt>floor</tt></CODE></A>  메소드에 의한 고정 소수점의 경우에 한정해, 부동 소수점치는 정수로서 생각합니다. 그 메소드를 적용한 결과와 같은 경우에 한정해, 값은 인수가 1 개의 메소드의 고정 소수점이 됩니다.

 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다. 결과는 반 단조로운 것에 한정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 베이스<DD><CODE>b</CODE> - 지수
<DT><B>반환값:</B><DD><code>a<sup>b</sup></code> 치</DL>
</DD>
</DL>
<HR>

<A NAME="round(float)"><!-- --></A> <H3>
round</H3>
<PRE>
public static int <B>round</B>(float&nbsp;a)</PRE>
<DL>
<DD>인수에 가장 가까운 <code>int</code> 를 돌려줍니다. 결과는 1/2 을 더해 floor 메소드로 취해 <code>int</code> 에 캐스트 해 정수에 말 수 있습니다. 즉, 다음의 식의 값에 동일해집니다. &nbsp;<p><pre>(int) Math.floor(a + 0.5f)</pre>
 <p>
특례로서:
<ul><li>인수가 NaN 의 경우는, 결과는 0 이 됩니다.
<li>인수가 부의 무한대인 경우, 또는 <code>Integer.MIN_VALUE</code> 이하의 임의의 값인 경우, 결과는 <code>Integer.MIN_VALUE</code> 의 값에 동일해집니다.  
<li>인수가 정의 무한대인 경우, 또는 <code>Integer.MAX_VALUE</code> 이상의 임의의 값인 경우, 결과는 <code>Integer.MAX_VALUE</code> 의 값에 동일해집니다. </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 정수에 마는 부동 소수점치
<DT><B>반환값:</B><DD>인수를 가장 가까운 <code>int</code> 치에 만 값<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Integer.html#MAX_VALUE"><CODE>Integer.MAX_VALUE</CODE></A> , 
<A HREF="../../java/lang/Integer.html#MIN_VALUE"><CODE>Integer.MIN_VALUE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="round(double)"><!-- --></A> <H3>
round</H3>
<PRE>
public static long <B>round</B>(double&nbsp;a)</PRE>
<DL>
<DD>인수에 가장 가까운 <code>long</code> 를 돌려줍니다. 결과는 1/2 을 더해 floor 메소드로 취해 <code>int</code> 에 캐스트 해 정수에 말 수 있습니다. 즉, 다음의 식의 값에 동일해집니다. &nbsp;<p><pre>(long) Math.floor(a + 0.5d)</pre>
 <p>
특례로서:
<ul><li>인수가 NaN 의 경우는, 결과는 0 이 됩니다.
<li>인수가 부의 무한대인 경우, 또는 <code>Long.MIN_VALUE</code> 이하의 임의의 값인 경우, 결과는 <code>Long.MIN_VALUE</code> 의 값에 동일해집니다.  
<li>인수가 정의 무한대인 경우, 또는 <code>Long.MAX_VALUE</code> 이상의 임의의 값인 경우, 결과는 <code>Long.MAX_VALUE</code> 의 값에 동일해집니다. </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - <code>long</code> 에 마는 부동 소수점치
<DT><B>반환값:</B><DD>인수를 가장 가까운 <code>long</code> 치에 만 값<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Long.html#MAX_VALUE"><CODE>Long.MAX_VALUE</CODE></A> , 
<A HREF="../../java/lang/Long.html#MIN_VALUE"><CODE>Long.MIN_VALUE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="random()"><!-- --></A> <H3>
random</H3>
<PRE>
public static double <B>random</B>()</PRE>
<DL>
<DD><code>0.0</code> 이상으로,<code>1.0</code> 보다 작은 정의 부호가 붙은 <code>double</code> 치를 돌려줍니다. 반환값은, 이 범위로부터의 일님 분포에 의해 의사 난수적으로 선택됩니다.  
 
 <p>최초로 이 메소드가 불려 갔을 때에, 메소드는 단일의 새로운 의사 난수 제네레이터를 작성합니다. 이것은, 다음의 식과 완전히 같습니다.
 <blockquote><pre>new java.util.Random</pre></blockquote> This
이 새로운 의사 난수 제네레이터는, 이후 이 메소드에의 모든 호출에 사용됩니다. 다른 장소에서는 사용되지 않습니다.
 
 <p>이 메소드는, 복수의 thread를 올바르게 사용할 수 있도록(듯이) 적절히 동기 됩니다. 그러나, 다수의 thread로 의사 난수를 고빈도로 발생할 필요가 있는 경우는, thread 독자적인 의사 난수 제네레이터를 준비해 각 thread의 컨텐션을 줄여도 괜찮습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD><code>double</code> 의 의사 난수. 범위는,<code>0.0</code> 이상 <code>1.0</code> 미만<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Random.html#nextDouble()"><CODE>Random.nextDouble()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="abs(int)"><!-- --></A> <H3>
abs</H3>
<PRE>
public static int <B>abs</B>(int&nbsp;a)</PRE>
<DL>
<DD><code>int</code> 치의 절대치를 돌려줍니다. 인수가 부가 아닌 경우는 인수 그 자체를 돌려줍니다. 부 때는, 그 정부를 반대로 한 값을 돌려줍니다.  
 
 <p>인수가 <code>Integer.MIN_VALUE</code> 의 값 (<code>int</code> 의 최소치)과 동일한 경우는, 결과도 같은 값 (0 보다 작은 값)이 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 속성치를 결정하는 인수
<DT><B>반환값:</B><DD>인수의 절대치<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Integer.html#MIN_VALUE"><CODE>Integer.MIN_VALUE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="abs(long)"><!-- --></A> <H3>
abs</H3>
<PRE>
public static long <B>abs</B>(long&nbsp;a)</PRE>
<DL>
<DD><code>long</code> 치의 절대치를 돌려줍니다. 인수가 부가 아닌 경우는 인수 그 자체를 돌려줍니다. 부 때는, 그 정부를 반대로 한 값을 돌려줍니다.  
 
 <p>인수가 <code>Long.MIN_VALUE</code> 의 값 (<code>long</code> 의 최소치)과 동일한 경우는, 결과도 같은 값 (0 보다 작은 값)이 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 속성치를 결정하는 인수
<DT><B>반환값:</B><DD>인수의 절대치<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Long.html#MIN_VALUE"><CODE>Long.MIN_VALUE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="abs(float)"><!-- --></A> <H3>
abs</H3>
<PRE>
public static float <B>abs</B>(float&nbsp;a)</PRE>
<DL>
<DD><code>float</code> 치의 절대치를 돌려줍니다. 인수가 부가 아닌 경우는 인수 그 자체를 돌려줍니다. 부 때는, 그 정부를 반대로 한 값을 돌려줍니다. 특례로서:
<ul><li>인수가 정의 제로 또는 부의 제로의 경우는, 정의 제로를 돌려줍니다.  
<li>인수가 무한대의 경우는, 정의 무한대치를 돌려줍니다.  
<li>인수가 NaN 의 경우는, NaN 를 돌려줍니다. </ul>
즉, 다음의 식의 값에 동일해집니다. &nbsp;<p><pre>Float.intBitsToFloat(0x7fffffff & Float.floatToIntBits(a))</pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 속성치를 결정하는 인수
<DT><B>반환값:</B><DD>인수의 절대치</DL>
</DD>
</DL>
<HR>

<A NAME="abs(double)"><!-- --></A> <H3>
abs</H3>
<PRE>
public static double <B>abs</B>(double&nbsp;a)</PRE>
<DL>
<DD><code>double</code> 치의 절대치를 돌려줍니다. 인수가 부가 아닌 경우는 인수 그 자체를 돌려줍니다. 부 때는, 그 정부를 반대로 한 값을 돌려줍니다. 특례로서:
<ul><li>인수가 정의 제로 또는 부의 제로의 경우는, 정의 제로를 돌려줍니다.  
<li>인수가 무한대의 경우는, 정의 무한대치를 돌려줍니다.  
<li>인수가 NaN 의 경우는, NaN 를 돌려줍니다. </ul>
즉, 다음의 식의 값에 동일해집니다. &nbsp;<p><code>Double.longBitsToDouble((Double.doubleToLongBits(a) &lt;&lt;1) &gt;&gt;&gt;1)</code>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 속성치를 결정하는 인수
<DT><B>반환값:</B><DD>인수의 절대치</DL>
</DD>
</DL>
<HR>

<A NAME="max(int, int)"><!-- --></A> <H3>
max</H3>
<PRE>
public static int <B>max</B>(int&nbsp;a,
                      int&nbsp;b)</PRE>
<DL>
<DD>2 개의 <code>int</code> 치의 쳐 큰 편을 돌려줍니다. 즉, 결과는 <code>Integer.MAX_VALUE</code> 의 값에 가까운 편의 인수가 됩니다. 인수의 값이 같은 경우는 같은 값을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 인수<DD><CODE>b</CODE> - 별의 인수
<DT><B>반환값:</B><DD><code>a</code> 와 <code>b</code> 의 어느 쪽인지 큰 (분)편<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Long.html#MAX_VALUE"><CODE>Long.MAX_VALUE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="max(long, long)"><!-- --></A> <H3>
max</H3>
<PRE>
public static long <B>max</B>(long&nbsp;a,
                       long&nbsp;b)</PRE>
<DL>
<DD>2 개의 <code>long</code> 치의 쳐 큰 편을 돌려줍니다. 즉, 결과는 <code>Long.MAX_VALUE</code> 의 값에 가까운 편의 인수가 됩니다. 인수의 값이 같은 경우는 같은 값을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 인수<DD><CODE>b</CODE> - 별의 인수
<DT><B>반환값:</B><DD><code>a</code> 와 <code>b</code> 의 어느 쪽인지 큰 (분)편<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Long.html#MAX_VALUE"><CODE>Long.MAX_VALUE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="max(float, float)"><!-- --></A> <H3>
max</H3>
<PRE>
public static float <B>max</B>(float&nbsp;a,
                        float&nbsp;b)</PRE>
<DL>
<DD>2 개의 <code>float</code> 치의 쳐 큰 편을 돌려줍니다. 즉, 결과는 정의 무한대에 가까운 편의 인수가 됩니다. 인수의 값이 같은 경우는 같은 값을 돌려줍니다. 어느 쪽인가의치가 NaN 의 경우는 NaN 를 돌려줍니다. 수치 비교 연산자와는 달라, 이 메소드는 부의 제로가 엄밀하게는 정의 제로보다 작다고 봅니다. 한편의 인수가 정의 제로로 이제(벌써) 한편이 부의 제로의 경우는, 정의 제로를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 인수<DD><CODE>b</CODE> - 별의 인수
<DT><B>반환값:</B><DD><code>a</code> 와 <code>b</code> 의 어느 쪽인지 큰 (분)편</DL>
</DD>
</DL>
<HR>

<A NAME="max(double, double)"><!-- --></A> <H3>
max</H3>
<PRE>
public static double <B>max</B>(double&nbsp;a,
                         double&nbsp;b)</PRE>
<DL>
<DD>2 개의 <code>double</code> 치의 쳐 큰 편을 돌려줍니다. 즉, 결과는 정의 무한대에 가까운 편의 인수가 됩니다. 인수의 값이 같은 경우는 같은 값을 돌려줍니다. 어느 쪽인가의치가 NaN 의 경우는 NaN 를 돌려줍니다. 수치 비교 연산자와는 달라, 이 메소드는 부의 제로가 엄밀하게는 정의 제로보다 작다고 봅니다. 한편의 인수가 정의 제로로 이제(벌써) 한편이 부의 제로의 경우는, 정의 제로를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 인수<DD><CODE>b</CODE> - 별의 인수
<DT><B>반환값:</B><DD><code>a</code> 와 <code>b</code> 의 어느 쪽인지 큰 (분)편</DL>
</DD>
</DL>
<HR>

<A NAME="min(int, int)"><!-- --></A> <H3>
min</H3>
<PRE>
public static int <B>min</B>(int&nbsp;a,
                      int&nbsp;b)</PRE>
<DL>
<DD>2 개의 <code>int</code> 치의 쳐 작은 편을 돌려줍니다. 즉, 결과는 <code>Integer.MIN_VALUE</code> 의 값에 가까운 편의 인수가 됩니다. 인수의 값이 같은 경우는 같은 값을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 인수<DD><CODE>b</CODE> - 별의 인수
<DT><B>반환값:</B><DD><code>a</code> 와 <code>b</code> 의 어느 쪽인지 작은 (분)편<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Long.html#MIN_VALUE"><CODE>Long.MIN_VALUE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="min(long, long)"><!-- --></A> <H3>
min</H3>
<PRE>
public static long <B>min</B>(long&nbsp;a,
                       long&nbsp;b)</PRE>
<DL>
<DD>2 개의 <code>long</code> 치의 쳐 작은 편을 돌려줍니다. 즉, 결과는 <code>Long.MIN_VALUE</code> 의 값에 가까운 편의 인수가 됩니다. 인수의 값이 같은 경우는 같은 값을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 인수<DD><CODE>b</CODE> - 별의 인수
<DT><B>반환값:</B><DD><code>a</code> 와 <code>b</code> 의 어느 쪽인지 작은 (분)편<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Long.html#MIN_VALUE"><CODE>Long.MIN_VALUE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="min(float, float)"><!-- --></A> <H3>
min</H3>
<PRE>
public static float <B>min</B>(float&nbsp;a,
                        float&nbsp;b)</PRE>
<DL>
<DD>2 개의 <code>float</code> 치의 쳐 작은 편을 돌려줍니다. 즉, 결과는 부의 무한대에 가까운 편의 값이 됩니다. 인수의 값이 같은 경우는 같은 값을 돌려줍니다. 어느 쪽인가의치가 NaN 의 경우는 NaN 를 돌려줍니다. 수치 비교 연산자와는 달라, 이 메소드는 부의 제로가 엄밀하게는 정의 제로보다 작다고 봅니다. 한편의 인수가 정의 제로로 이제(벌써) 한편이 부의 제로의 경우는, 부의 제로를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 인수<DD><CODE>b</CODE> - 별의 인수
<DT><B>반환값:</B><DD><code>a</code> 와 <code>b</code> 의 어느 쪽인지 작은 (분)편</DL>
</DD>
</DL>
<HR>

<A NAME="min(double, double)"><!-- --></A> <H3>
min</H3>
<PRE>
public static double <B>min</B>(double&nbsp;a,
                         double&nbsp;b)</PRE>
<DL>
<DD>2 개의 <code>double</code> 치의 쳐 작은 편을 돌려줍니다. 즉, 결과는 부의 무한대에 가까운 편의 값이 됩니다. 인수의 값이 같은 경우는 같은 값을 돌려줍니다. 어느 쪽인가의치가 NaN 의 경우는 NaN 를 돌려줍니다. 수치 비교 연산자와는 달라, 이 메소드는 부의 제로가 엄밀하게는 정의 제로보다 작다고 봅니다. 한편의 인수가 정의 제로로 이제(벌써) 한편이 부의 제로의 경우는, 부의 제로를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 인수<DD><CODE>b</CODE> - 별의 인수
<DT><B>반환값:</B><DD><code>a</code> 와 <code>b</code> 의 어느 쪽인지 작은 (분)편</DL>
</DD>
</DL>
<HR>

<A NAME="ulp(double)"><!-- --></A> <H3>
ulp</H3>
<PRE>
public static double <B>ulp</B>(double&nbsp;d)</PRE>
<DL>
<DD>인수의 ulp 의 사이즈를 돌려줍니다. <code>double</code> 치의 ulp 는, 이 부동 소수점치와 절대치로 다음에 큰 <code>double</code> 치와의 사이의 정의 거리입니다. <i>x</i> 가 NaN 이외의 경우,<code>ulp(-<i>x</i>) == ulp(<i>x</i>)</code> 입니다.
 
 <p>특례로서:
 <ul>
<li> 인수가 NaN 의 경우, NaN 가 반환된다
<li> 인수가 정 또는 부의 무한대의 경우는, 결과는 정의 무한대가 된다
<li> 인수가 정 또는 부의 제로의 경우는, 결과는 <code>Double.MIN_VALUE</code> 가 된다
<li> 인수가 &plusmn;<code>Double.MAX_VALUE</code> 의 경우, 결과는 2<sup>971</sup> 에 동일해진다
 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>d</CODE> - ulp 가 반환되는 부동 소수점치
<DT><B>반환값:</B><DD>인수의 ulp 의 사이즈<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="ulp(float)"><!-- --></A> <H3>
ulp</H3>
<PRE>
public static float <B>ulp</B>(float&nbsp;f)</PRE>
<DL>
<DD>인수의 ulp 의 사이즈를 돌려줍니다. <code>float</code> 치의 ulp 는, 이 부동 소수점치와 절대치로 다음에 큰 <code>float</code> 치와의 사이의 정의 거리입니다. <i>x</i> 가 NaN 이외의 경우,<code>ulp(-<i>x</i>) == ulp(<i>x</i>)</code> 입니다.
 
 <p>특례로서:
 <ul>
<li> 인수가 NaN 의 경우, NaN 가 반환된다
<li> 인수가 정 또는 부의 무한대의 경우는, 결과는 정의 무한대가 된다
<li> 인수가 정 또는 부의 제로의 경우는, 결과는 <code>Float.MIN_VALUE</code> 가 된다
<li> 인수가 &plusmn;<code>Float.MAX_VALUE</code> 의 경우, 결과는 2<sup>104</sup> 에 동일해진다
 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>f</CODE> - ulp 가 반환되는 부동 소수점치
<DT><B>반환값:</B><DD>인수의 ulp 의 사이즈<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="signum(double)"><!-- --></A> <H3>
signum</H3>
<PRE>
public static double <B>signum</B>(double&nbsp;d)</PRE>
<DL>
<DD>인수의 부호 요소를 돌려줍니다.  인수가 제로의 경우는 제로, 인수가 제로보다 큰 경우는 1.0, 인수가 제로보다 작은 경우는 -1. 0 입니다.

 <p>특례로서:
 <ul>
<li> 인수가 NaN 의 경우, NaN 가 돌려주어집니다.
<li> 인수가 정의 제로 또는 부의 제로의 경우는, 인수와 같은 값이 돌려주어집니다.
 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>d</CODE> - 부호가 반환되는 부동 소수점치
<DT><B>반환값:</B><DD>인수의 부호 요소<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="signum(float)"><!-- --></A> <H3>
signum</H3>
<PRE>
public static float <B>signum</B>(float&nbsp;f)</PRE>
<DL>
<DD>인수의 부호 요소를 돌려줍니다.  인수가 제로의 경우는 제로, 인수가 제로보다 큰 경우는 1, 인수가 제로보다 작은 경우는 -1 입니다.

 <p>특례로서:
 <ul>
<li> 인수가 NaN 의 경우, NaN 가 돌려주어집니다.
<li> 인수가 정의 제로 또는 부의 제로의 경우는, 인수와 같은 값이 돌려주어집니다.
 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>f</CODE> - 부호가 반환되는 부동 소수점치
<DT><B>반환값:</B><DD>인수의 부호 요소<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="sinh(double)"><!-- --></A> <H3>
sinh</H3>
<PRE>
public static double <B>sinh</B>(double&nbsp;x)</PRE>
<DL>
<DD><code>double</code> 치의 쌍곡선 정현을 돌려줍니다. <i>x</i> 의 쌍곡선 정현은 (<i>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></i>)/2 으로 나타내집니다.  여기서,<i>e</i> 는 <A HREF="../../java/lang/Math.html#E">Euler's number</A>  입니다.

 <p>특례로서:
 <ul>

<li>인수가 NaN 의 경우, NaN 가 돌려주어집니다.

<li>인수가 무한대의 경우, 결과는 인수와 같은 부호를 붙인 무한대가 된다

<li>인수가 제로의 경우, 결과는 제로에 인수와 같은 부호를 매긴 값이 됩니다.

 </ul>

 <p>계산 결과는, 정확한 결과의 2.5 ulp 이내가 아니면 안됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 쌍곡선 정현이 반환되는 숫자
<DT><B>반환값:</B><DD><code>x</code> 의 쌍곡선 정현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cosh(double)"><!-- --></A> <H3>
cosh</H3>
<PRE>
public static double <B>cosh</B>(double&nbsp;x)</PRE>
<DL>
<DD><code>double</code> 치의 쌍곡선 여현을 돌려줍니다. <i>x</i> 의 쌍곡선 여현은 (<i>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></i>)/2 으로 나타내집니다.  여기서,<i>e</i> 는 <A HREF="../../java/lang/Math.html#E">Euler's number</A>  입니다.

 <p>특례로서:
 <ul>

<li>인수가 NaN 의 경우, NaN 가 돌려주어집니다.

<li>인수가 무한대의 경우는, 정의 무한대치가 반환된다

<li>인수가 제로의 경우,<code>1.0</code> 이 된다

 </ul>

 <p>계산 결과는, 정확한 결과의 2.5 ulp 이내가 아니면 안됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 쌍곡선 여현이 반환되는 숫자
<DT><B>반환값:</B><DD><code>x</code> 의 쌍곡선 여현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="tanh(double)"><!-- --></A> <H3>
tanh</H3>
<PRE>
public static double <B>tanh</B>(double&nbsp;x)</PRE>
<DL>
<DD><code>double</code> 치의 쌍곡선 탄젠트를 돌려줍니다. <i>x</i> 의 쌍곡선 탄젠트는 (<i>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></i>)/(<i>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></i>)로 나타내집니다.  즉,<A HREF="../../java/lang/Math.html#sinh(double)">sinh(<i>x</i>)</A> /<A HREF="../../java/lang/Math.html#cosh(double)">cosh(<i>x</i>)</A> . 정확한 tanh 의 절대치는 항상 1 미만입니다.

 <p>특례로서:
 <ul>

<li>인수가 NaN 의 경우, NaN 가 돌려주어집니다.

<li>인수가 제로의 경우, 결과는 제로에 인수와 같은 부호를 매긴 값이 됩니다.

<li>인수가 정의 무한대의 경우, 결과는 <code>+1. 0</code> 이 된다

<li>인수가 부의 무한대의 경우, 결과는 <code>-1. 0</code> 이 된다
  
 </ul>

 <p>계산 결과는, 정확한 결과의 2.5 ulp 이내가 아니면 안됩니다. 유한 입력의 <code>tanh</code> 의 결과는, 1 이하의 절대치를 가지지 않으면 안됩니다. &plusmn; 1 의 제한치의 ulp 의 1/2 이내인 경우, 올바르게 부호를 붙일 수 있었던 &plusmn;<code>1.0</code> 이 돌려주어집니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 쌍곡선 탄젠트가 반환되는 숫자
<DT><B>반환값:</B><DD><code>x</code> 의 쌍곡선 탄젠트<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hypot(double, double)"><!-- --></A> <H3>
hypot</H3>
<PRE>
public static double <B>hypot</B>(double&nbsp;x,
                           double&nbsp;y)</PRE>
<DL>
<DD>중간의 오버플로우나 언더 플로우(underflow)없이 sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)가 돌려주어집니다.

 <p>특례로서:
 <ul>

<li> 어느 쪽인가의 인수가 무한대의 경우는, 결과는 정의 무한대치가 된다

<li> 어느 쪽인가의 인수가 NaN 이며, 한편 어느 쪽의 인수도 무한대가 아닌 경우, 결과는 NaN 가 된다

 </ul>

 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다. 1 개의 파라미터가 일정한 경우, 결과는 이제(벌써) 한편의 파라미터로 반 단조로운 것에 한정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 치<DD><CODE>y</CODE> - 치
<DT><B>반환값:</B><DD>중간의 오버플로우나 언더 플로우(underflow)가 없는 sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="expm1(double)"><!-- --></A> <H3>
expm1</H3>
<PRE>
public static double <B>expm1</B>(double&nbsp;x)</PRE>
<DL>
<DD><i>e</i><sup>x</sup>&nbsp;-1 를 돌려줍니다.  0 에 가까운 <i>x</i> 의 값의 경우,<code>expm1(x)</code>&nbsp;+&nbsp;1 의 정확한 합계는,<code>exp(x)</code> 보다 <i>e</i><sup>x</sup> 의 진정한 결과에 꽤 근처 됩니다.

 <p>특례로서:
 <ul>
<li>인수가 NaN 의 경우는, NaN 를 돌려줍니다.

<li>인수가 정의 무한대의 경우는, 정의 무한대가 돌려주어집니다.

<li>인수가 부의 무한대의 경우, 결과는 -1. 0 이 된다

<li>인수가 제로의 경우, 결과는 제로에 인수와 같은 부호를 매긴 값이 됩니다.

 </ul>

 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다. 결과는 반 단조로운 것에 한정합니다. 유한 입력의 <code>expm1</code> 의 결과는,<code>-1. 0</code> 이상이 아니면 안됩니다. <i>e</i><sup><code>x</code></sup>&nbsp;-&nbsp; 의 정확한 결과가 제한치 -1 의 1/2 ulp 이내인 경우,<code>-1. 0</code> 이 돌려주어집니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - <i>e</i><sup><code>x</code></sup>&nbsp;-1 의 계산으로 설정한 <i>e</i> 의 지수
<DT><B>반환값:</B><DD>치 <i>e</i><sup><code>x</code></sup>&nbsp;-&nbsp;1<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="log1p(double)"><!-- --></A> <H3>
log1p</H3>
<PRE>
public static double <B>log1p</B>(double&nbsp;x)</PRE>
<DL>
<DD>인수와 1 의 합계의 자연대수를 돌려줍니다. <code> x</code> 의 값이 작은 경우,<code>log1p(x)</code> 의 결과는,<code>log(1.0+x)</code> 의 부동 소수점 평가보다 ln(1 + <code>x</code>)의 진정한 결과에 꽤 근처 됩니다.

 <p>특례로서:

 <ul>

<li>인수가 NaN 또는 -1 보다 작은 경우, 결과는 NaN 가 된다

<li>인수가 정의 무한대의 경우는, 정의 무한대가 돌려주어집니다.

<li>인수가 0 보다 작은 값의 경우, 결과는 부의 무한대가 된다

<li>인수가 제로의 경우, 결과는 제로에 인수와 같은 부호를 매긴 값이 됩니다.

 </ul>

 <p>계산 결과는, 정확한 결과의 1 ulp 이내가 아니면 안됩니다. 결과는 반 단조로운 것에 한정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 치
<DT><B>반환값:</B><DD>ln(<code>x</code>&nbsp;+&nbsp;1)의 값. <code> x</code>&nbsp;+&nbsp;1 의 자연대수<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copySign(double, double)"><!-- --></A> <H3>
copySign</H3>
<PRE>
public static double <B>copySign</B>(double&nbsp;magnitude,
                              double&nbsp;sign)</PRE>
<DL>
<DD>2 번째의 부동 소수점 인수의 부호를 붙인, 최초의 부동 소수점 인수를 돌려줍니다. <A HREF="../../java/lang/StrictMath.html#copySign(double, double)"><CODE>StrictMath.copySign</CODE></A>  메소드와는 달라, 이 메소드는, 정의 값으로 해서 다루어지기 위해서(때문에) NaN <code>sign</code> 인수를 필요로 하지 않습니다. 구현은, 퍼포먼스를 향상시키기 위해서(때문에), 일부의 NaN 인수를 정으로서 취급해, 그 외의 NaN 인수를 부로서 취급하도록(듯이) 허가됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>magnitude</CODE> - 결과의 절대치를 제공하는 파라미터<DD><CODE>sign</CODE> - 결과의 부호를 제공하는 파라미터
<DT><B>반환값:</B><DD><code>magnitude</code> 의 절대치와 <code>sign</code> 의 부호를 가지는 값<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copySign(float, float)"><!-- --></A> <H3>
copySign</H3>
<PRE>
public static float <B>copySign</B>(float&nbsp;magnitude,
                             float&nbsp;sign)</PRE>
<DL>
<DD>2 번째의 부동 소수점 인수의 부호를 붙인, 최초의 부동 소수점 인수를 돌려줍니다. <A HREF="../../java/lang/StrictMath.html#copySign(float, float)"><CODE>StrictMath.copySign</CODE></A>  메소드와는 달라, 이 메소드는, 정의 값으로 해서 다루어지기 위해서(때문에) NaN <code>sign</code> 인수를 필요로 하지 않습니다. 구현은, 퍼포먼스를 향상시키기 위해서(때문에), 일부의 NaN 인수를 정으로서 취급해, 그 외의 NaN 인수를 부로서 취급하도록(듯이) 허가됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>magnitude</CODE> - 결과의 절대치를 제공하는 파라미터<DD><CODE>sign</CODE> - 결과의 부호를 제공하는 파라미터
<DT><B>반환값:</B><DD><code>magnitude</code> 의 절대치와 <code>sign</code> 의 부호를 가지는 값<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getExponent(float)"><!-- --></A> <H3>
getExponent</H3>
<PRE>
public static int <B>getExponent</B>(float&nbsp;f)</PRE>
<DL>
<DD><code>float</code> 의 표현으로 사용되는 불편 지수를 돌려줍니다. 특례로서:

 <ul>
<li>인수가 NaN 또는 무한의 경우, 결과는 <A HREF="../../java/lang/Float.html#MAX_EXPONENT"><CODE>Float.MAX_EXPONENT</CODE></A>  + 1 이 됩니다.  
<li>인수가 제로 또는 비정규의 경우, 결과는 <A HREF="../../java/lang/Float.html#MIN_EXPONENT"><CODE>Float.MIN_EXPONENT</CODE></A>  -1 가 됩니다.
 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>f</CODE> - <code>float</code> 치
<DT><B>반환값:</B><DD>인수의 불편 지수<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getExponent(double)"><!-- --></A> <H3>
getExponent</H3>
<PRE>
public static int <B>getExponent</B>(double&nbsp;d)</PRE>
<DL>
<DD><code>double</code> 의 표현으로 사용되는 불편 지수를 돌려줍니다. 특례로서:

 <ul>
<li>인수가 NaN 또는 무한의 경우, 결과는 <A HREF="../../java/lang/Double.html#MAX_EXPONENT"><CODE>Double.MAX_EXPONENT</CODE></A>  + 1 이 됩니다.
<li>인수가 제로 또는 비정규의 경우, 결과는 <A HREF="../../java/lang/Double.html#MIN_EXPONENT"><CODE>Double.MIN_EXPONENT</CODE></A>  -1 가 됩니다.
 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>d</CODE> - <code>double</code> 치
<DT><B>반환값:</B><DD>인수의 불편 지수<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="nextAfter(double, double)"><!-- --></A> <H3>
nextAfter</H3>
<PRE>
public static double <B>nextAfter</B>(double&nbsp;start,
                               double&nbsp;direction)</PRE>
<DL>
<DD>2 번째의 인수의 방향으로, 최초의 인수에 인접하는 부동 소수점치를 돌려줍니다. 양쪽 모두의 인수가 동일하다고 보여지는 경우는, 2 번째의 인수가 돌려주어집니다.

 <p>
특례로서:
 <ul>
<li> 어느 쪽인가의 인수가 NaN 의 경우, NaN 가 돌려주어집니다.

<li> 양쪽 모두의 인수가 부호 첨부 제로의 경우, 양쪽 모두의 인수가 동일하다고 보여지는 경우는 2 번째의 인수가 반환된다고 하는 요건대로,<code>direction</code> 가 변경되지 않고 돌려주어집니다.

<li> <code>start</code> 가 &plusmn;<A HREF="../../java/lang/Double.html#MIN_VALUE"><CODE>Double.MIN_VALUE</CODE></A>  이며,<code>direction</code> 가 결과에 작은 절대치가 포함되는 것 같은 값을 가지는 경우,<code>start</code> 와 같은 부호를 가지는 제로가 돌려주어집니다.

<li> <code>start</code> 가 무한하고,<code>direction</code> 가 결과에 작은 절대치가 포함되는 것 같은 값을 가지는 경우,<code>start</code> 와 같은 부호를 가지는 <A HREF="../../java/lang/Double.html#MAX_VALUE"><CODE>Double.MAX_VALUE</CODE></A>  가 돌려주어집니다.

<li> <code>start</code> 가 &plusmn; <A HREF="../../java/lang/Double.html#MAX_VALUE"><CODE>Double.MAX_VALUE</CODE></A>  와 동일하고,<code>direction</code> 가 결과에 큰 절대치가 포함되는 것 같은 값을 가지는 경우,<code>start</code> 와 같은 부호를 가지는 무한대가 돌려주어집니다.
 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>start</CODE> - 개시 부동 소수점치<DD><CODE>direction</CODE> - <code>start</code> 의 이웃이나 <code>start</code> 의 어느 쪽이 반환되는지를 나타내는 값
<DT><B>반환값:</B><DD><code>direction</code> 의 방향으로 <code>start</code> 에 인접하는 부동 소수점치<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="nextAfter(float, double)"><!-- --></A> <H3>
nextAfter</H3>
<PRE>
public static float <B>nextAfter</B>(float&nbsp;start,
                              double&nbsp;direction)</PRE>
<DL>
<DD>2 번째의 인수의 방향으로, 최초의 인수에 인접하는 부동 소수점치를 돌려줍니다. 양쪽 모두의 인수가 동일하다고 보여지는 경우는, 2 번째의 인수에 동일한 값이 돌려주어집니다.

 <p>
특례로서:
 <ul>
<li> 어느 쪽인가의 인수가 NaN 의 경우, NaN 가 돌려주어집니다.

<li> 양쪽 모두의 부호 첨부 제로로 보여지는 경우는,<code>direction</code> 에 동일한 값이 돌려주어집니다.

<li> <code>start</code> 가 &plusmn;<A HREF="../../java/lang/Float.html#MIN_VALUE"><CODE>Float.MIN_VALUE</CODE></A>  이며,<code>direction</code> 가 결과에 작은 절대치가 포함되는 것 같은 값을 가지는 경우,<code>start</code> 와 같은 부호를 가지는 제로가 돌려주어집니다.

<li> <code>start</code> 가 무한하고,<code>direction</code> 가 결과에 작은 절대치가 포함되는 것 같은 값을 가지는 경우,<code>start</code> 와 같은 부호를 가지는 <A HREF="../../java/lang/Float.html#MAX_VALUE"><CODE>Float.MAX_VALUE</CODE></A>  가 돌려주어집니다.

<li> <code>start</code> 가 &plusmn; <A HREF="../../java/lang/Float.html#MAX_VALUE"><CODE>Float.MAX_VALUE</CODE></A>  와 동일하고,<code>direction</code> 가 결과에 큰 절대치가 포함되는 것 같은 값을 가지는 경우,<code>start</code> 와 같은 부호를 가지는 무한대가 돌려주어집니다.
 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>start</CODE> - 개시 부동 소수점치<DD><CODE>direction</CODE> - <code>start</code> 의 이웃이나 <code>start</code> 의 어느 쪽이 반환되는지를 나타내는 값
<DT><B>반환값:</B><DD><code>direction</code> 의 방향으로 <code>start</code> 에 인접하는 부동 소수점치<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="nextUp(double)"><!-- --></A> <H3>
nextUp</H3>
<PRE>
public static double <B>nextUp</B>(double&nbsp;d)</PRE>
<DL>
<DD>정의 무한대 방향으로 <code>d</code> 에 인접하는 부동 소수점치를 돌려줍니다. 이 메소드는 의미상은 <code>nextAfter(d, Double.POSITIVE_INFINITY)</code> 와 같습니다. 다만,<code>nextUp</code> 구현은, 거기에 동일한 <code>nextAfter</code> 호출보다 고속으로 실행할 수 있는 일도 있습니다.

 <p>특례로서:
 <ul>
<li> 인수가 NaN 의 경우는, NaN 를 돌려줍니다.

<li> 인수가 정의 무한대의 경우는, 정의 무한대가 돌려주어집니다.

<li> 인수가 제로의 경우,<A HREF="../../java/lang/Double.html#MIN_VALUE"><CODE>Double.MIN_VALUE</CODE></A>  가 됩니다.

 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>d</CODE> - 개시 부동 소수점치
<DT><B>반환값:</B><DD>정의 무한대에 가까운 편의, 인접하는 부동 소수점치<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="nextUp(float)"><!-- --></A> <H3>
nextUp</H3>
<PRE>
public static float <B>nextUp</B>(float&nbsp;f)</PRE>
<DL>
<DD>정의 무한대 방향으로 <code>f</code> 에 인접하는 부동 소수점치를 돌려줍니다. 이 메소드는 의미상은 <code>nextAfter(f, Float.POSITIVE_INFINITY)</code> 와 같습니다. 다만,<code>nextUp</code> 구현은, 거기에 동일한 <code>nextAfter</code> 호출보다 고속으로 실행할 수 있는 일도 있습니다.

 <p>특례로서:
 <ul>
<li> 인수가 NaN 의 경우는, NaN 를 돌려줍니다.

<li> 인수가 정의 무한대의 경우는, 정의 무한대가 돌려주어집니다.

<li> 인수가 제로의 경우,<A HREF="../../java/lang/Float.html#MIN_VALUE"><CODE>Float.MIN_VALUE</CODE></A>  가 됩니다.

 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>f</CODE> - 개시 부동 소수점치
<DT><B>반환값:</B><DD>정의 무한대에 가까운 편의, 인접하는 부동 소수점치<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="scalb(double, int)"><!-- --></A> <H3>
scalb</H3>
<PRE>
public static double <B>scalb</B>(double&nbsp;d,
                           int&nbsp;scaleFactor)</PRE>
<DL>
<DD>double 치 세트의 멤버에게 단일의 올바르게 말 수 있었던 부동 소수점을 거는 것에 의해 실행되는 경우와 같게,<code>d</code> &times; 2<sup><code>scaleFactor</code></sup> 를 돌려줍니다. 부동 소수점치 세트에 대해서는, 「Java 언어 스펙」을 참조해 주세요. 결과의 지수가 <A HREF="../../java/lang/Double.html#MIN_EXPONENT"><CODE>Double.MIN_EXPONENT</CODE></A>  로부터 <A HREF="../../java/lang/Double.html#MAX_EXPONENT"><CODE>Double.MAX_EXPONENT</CODE></A>  의 사이의 경우, 답은 정확하게 계산됩니다. 결과의 지수가 <code>Double.MAX_EXPONENT</code> 보다 커지는 경우, 무한대가 돌려주어집니다. 결과가 비정규의 경우는, 정밀도가 없어질 가능성이 있습니다. 즉,<code>scalb(x, n)</code> 가 비정규의 경우,<code>scalb(scalb(x, n), -n)</code> 는 <i>x</i> 와 동일하지 않을 가능성이 있습니다. 결과가 NaN 이외의 경우, 그 결과는 <code>d</code> 와 같은 부호를 가집니다.

<p>
특례로서:
 <ul>
<li> 최초의 인수가 NaN 의 경우는, NaN 가 돌려주어집니다.
<li> 최초의 인수가 무한대의 경우는, 같은 부호의 무한대치가 돌려주어집니다.
<li> 최초의 인수가 제로의 경우는, 같은 부호의 제로가 돌려주어집니다.
 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>d</CODE> - 2 의 누승에 의해 슬캘링 되는 수<DD><CODE>scaleFactor</CODE> - <code>d</code> 를 슬캘링 하기 위해서 사용되는 2 의 누승
<DT><B>반환값:</B><DD><code>d</code> &times; 2<sup><code>scaleFactor</code></sup><DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="scalb(float, int)"><!-- --></A> <H3>
scalb</H3>
<PRE>
public static float <B>scalb</B>(float&nbsp;f,
                          int&nbsp;scaleFactor)</PRE>
<DL>
<DD>float 치 세트의 멤버에게 단일의 올바르게 말 수 있었던 부동 소수점을 거는 것에 의해 실행되는 경우와 같게,<code>d</code> &times; 2<sup><code>scaleFactor</code></sup> 를 돌려줍니다. 부동 소수점치 세트에 대해서는, 「Java 언어 스펙」을 참조해 주세요. 결과의 지수가 <A HREF="../../java/lang/Float.html#MIN_EXPONENT"><CODE>Float.MIN_EXPONENT</CODE></A>  로부터 <A HREF="../../java/lang/Float.html#MAX_EXPONENT"><CODE>Float.MAX_EXPONENT</CODE></A>  의 사이의 경우, 답은 정확하게 계산됩니다. 결과의 지수가 <code>Float.MAX_EXPONENT</code> 보다 커지는 경우, 무한대가 돌려주어집니다. 결과가 비정규의 경우는, 정밀도가 없어질 가능성이 있습니다. 즉,<code>scalb(x, n)</code> 가 비정규의 경우,<code>scalb(scalb(x, n), -n)</code> 는 <i>x</i> 와 동일하지 않을 가능성이 있습니다. 결과가 NaN 이외의 경우, 그 결과는 <code>f</code> 와 같은 부호를 가집니다.

<p>
특례로서:
 <ul>
<li> 최초의 인수가 NaN 의 경우는, NaN 가 돌려주어집니다.
<li> 최초의 인수가 무한대의 경우는, 같은 부호의 무한대치가 돌려주어집니다.
<li> 최초의 인수가 제로의 경우는, 같은 부호의 제로가 돌려주어집니다.
 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>f</CODE> - 2 의 누승에 의해 슬캘링 되는 수<DD><CODE>scaleFactor</CODE> - <code>f</code> 를 슬캘링 하기 위해서 사용되는 2 의 누승
<DT><B>반환값:</B><DD><code>f</code> &times; 2<sup><code>scaleFactor</code></sup><DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Math.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/lang/Long.html" title="java.lang 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/NegativeArraySizeException.html" title="java.lang 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/lang/Math.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Math.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
