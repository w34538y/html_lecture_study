<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:47:08 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
java.util.concurrent.atomic (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="java.util.concurrent.atomic (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/atomic/package-summary.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
패키지 java.util.concurrent.atomic
</H2>
단일의 변수에 대한 락 프리로 thread 세이프인 프로그래밍을 지원하는 클래스의 소규모의 툴 킷입니다.
<P>
<B>참조처:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>설명</B></A> 
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicBoolean.html" title="java.util.concurrent.atomic 안의 클래스">AtomicBoolean</A> </B></TD>
<TD>원자적인 갱신이 가능한 <code>boolean</code> 치입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicInteger.html" title="java.util.concurrent.atomic 안의 클래스">AtomicInteger</A> </B></TD>
<TD>원자적인 갱신이 가능한 <code>int</code> 치입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicIntegerArray.html" title="java.util.concurrent.atomic 안의 클래스">AtomicIntegerArray</A> </B></TD>
<TD>요소의 원자적인 갱신이 가능한 <code>int</code> 배열입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicIntegerFieldUpdater.html" title="java.util.concurrent.atomic 안의 클래스">AtomicIntegerFieldUpdater&lt;T&gt;</A> </B></TD>
<TD>지정된 클래스의 지정된 <code>volatile int</code> 필드의 원자 갱신이 가능한, 리플렉션 베이스의 유틸리티입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicLong.html" title="java.util.concurrent.atomic 안의 클래스">AtomicLong</A> </B></TD>
<TD>원자적인 갱신이 가능한 <code>long</code> 치입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicLongArray.html" title="java.util.concurrent.atomic 안의 클래스">AtomicLongArray</A> </B></TD>
<TD>요소의 원자적인 갱신이 가능한 <code>long</code> 배열입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicLongFieldUpdater.html" title="java.util.concurrent.atomic 안의 클래스">AtomicLongFieldUpdater&lt;T&gt;</A> </B></TD>
<TD>지정된 클래스의 지정된 <code>volatile long</code> 필드의 원자 갱신이 가능한, 리플렉션 베이스의 유틸리티입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicMarkableReference.html" title="java.util.concurrent.atomic 안의 클래스">AtomicMarkableReference&lt;V&gt;</A> </B></TD>
<TD><code>AtomicMarkableReference</code> 는, 원자적으로 갱신 가능한 마크 비트와 함께, 객체 참조를 관리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicReference.html" title="java.util.concurrent.atomic 안의 클래스">AtomicReference&lt;V&gt;</A> </B></TD>
<TD>원자적인 갱신이 가능한 객체 참조입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicReferenceArray.html" title="java.util.concurrent.atomic 안의 클래스">AtomicReferenceArray&lt;E&gt;</A> </B></TD>
<TD>요소를 원자적으로 갱신 가능한 객체 참조의 배열입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicReferenceFieldUpdater.html" title="java.util.concurrent.atomic 안의 클래스">AtomicReferenceFieldUpdater&lt;T, V&gt;</A> </B></TD>
<TD>지정된 클래스의 지정된 <code>volatile</code> 참조 필드의 원자 갱신이 가능한, 리플렉션 베이스의 유틸리티입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicStampedReference.html" title="java.util.concurrent.atomic 안의 클래스">AtomicStampedReference&lt;V&gt;</A> </B></TD>
<TD><code>AtomicStampedReference</code> 는, 원자적으로 갱신 가능한 정수 「스탬프」와(과) 함께, 객체 참조를 관리합니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A> <H2>
패키지 java.util.concurrent.atomic 의 설명
</H2>

<P>
단일의 변수에 대한 락 프리로 thread 세이프인 프로그래밍을 지원하는 클래스의 소규모의 툴 킷입니다. 기본적으로, 이 패키지내의 클래스는 <tt>volatile</tt> 치, 필드, 및 배열 요소의 개념을, 원자적인 조건부 갱신 조작도 제공하는 클래스에까지 확장합니다. 서식은 다음과 같습니다.

<pre>
boolean compareAndSet(expectedValue, updateValue);
</pre>

<p> 이 메소드 (클래스가 다르면(자) 인수의 형태도 다르다)가 <tt>expectedValue</tt> 를 현재 보관 유지하고 있는 경우, 변수를 <tt>updateValue</tt> 에 원자적으로 설정해, 성공하면(자) <tt>true</tt> 를 돌려줍니다. 이 패키지내의 클래스에는, 값을 취득하거나 무조건으로 설정하는 메소드, 및 이하로 설명하는 약한 조건부 원자 갱신 조작 <tt> weakCompareAndSet</tt> 도 포함됩니다.

<p> 이러한 메소드 스펙에 근거하는 구현에 의해, 최신의 프로세서로 사용 가능한 고효율의 머신 레벨 원자 명령을 사용하는 것이 가능하게 됩니다. 다만, 일부의 플랫폼에서는, 이것을 지원하는 것으로, 하등의 내부 락이 수반할 가능성이 있습니다. 이 때문에, 메소드로 비블로킹이 엄밀하게 보증되는 것은 아닙니다. thread는, 조작을 실행하기 전에 일시적으로 블록을 실행하는 일이 있습니다.

<p> <A HREF="../../../../java/util/concurrent/atomic/AtomicBoolean.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicBoolean</CODE></A> ,<A HREF="../../../../java/util/concurrent/atomic/AtomicInteger.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicInteger</CODE></A> ,<A HREF="../../../../java/util/concurrent/atomic/AtomicLong.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicLong</CODE></A> , 및 <A HREF="../../../../java/util/concurrent/atomic/AtomicReference.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicReference</CODE></A>  클래스의 인스턴스는, 각각 대응하는 형태의 단일의 변수에 액세스 및 갱신을 제공합니다. 각 클래스는, 그 형태에 대응한 유틸리티 메소드도 제공합니다. 예를 들어,<tt>AtomicLong</tt> 및 <tt>AtomicInteger</tt> 클래스는, 원자 증분 메소드를 제공합니다. 어느 어플리케이션이, 다음과 같이 일련 번호를 생성한다고 합니다.

<pre>
class Sequencer {
private final AtomicLong sequenceNumber
= new AtomicLong(0);
public long next() {
return sequenceNumber.getAndIncrement();
  }
}
</pre>

<p>일반적으로, 원자 액세스 및 원자 갱신의 메모리 효과는,<a href="http://java.sun.com/docs/books/jls/">「Java 언어 스펙 제 3 판 (17.4 메모리 모델)」</a>의 휘발성 규칙에 따릅니다.

<ul>

<li> <tt>get</tt> 는,<tt>volatile</tt> 변수의 읽기로 메모리 효과를 보관 유지합니다.

<li> <tt>set</tt> 는,<tt>volatile</tt> 변수의 기입 (할당하고)으로 메모리 효과를 보관 유지합니다.

<li> <tt>lazySet</tt> 는,<tt>volatile</tt> 변수의 기입 (할당하고)으로 메모리 효과를 보관 유지합니다. 다만, 이것은 (이전은 아니고) 이후의, 그 자체에 일반적으로의 비 <tt>volatile</tt> 기입으로 나란해질 수 있는 바꾸고의 제약을 부과하지 않는 메모리 조작에 의한 늘어놓고 바꾸고를 허가합니다. 그 외의 사용 문맥에서는,<tt>lazySet</tt> 는, null 대입 시에 가베지 컬렉션을 위해서(때문에), 두 번 다시 액세스 될리가 없는 참조를 적용하는 일이 있습니다.

<li><tt>weakCompareAndSet</tt> 는, 변수를 원자적으로 읽어내, 조건부로 기입합니다만, happens-before 의 순서부는 작성하지 않기 때문에,<tt>weakCompareAndSet</tt> 의 타겟 이외의 변수의 이전 또는 이후의 읽기와 기입에 대한 보증은 제공하지 않습니다.

<li> <tt>compareAndSet</tt>, 및 다른 모든 읽기 및 갱신 조작 (<tt>getAndIncrement</tt> 등)은,<tt>volatile</tt> 변수의 읽기와 기입의 양쪽 모두로 메모리 효과를 보관 유지한다
</ul>

<p>이 패키지에는, 단일의 값을 나타내는 클래스에 가세해 선택한 클래스내의 선택한 <tt>volatile</tt> 필드에 대한 <tt>compareAndSet</tt> 조작의 취득에 사용 가능한 <em>Updater</em> 클래스가 포함됩니다. <A HREF="../../../../java/util/concurrent/atomic/AtomicReferenceFieldUpdater.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicReferenceFieldUpdater</CODE></A> ,<A HREF="../../../../java/util/concurrent/atomic/AtomicIntegerFieldUpdater.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicIntegerFieldUpdater</CODE></A> , 및 <A HREF="../../../../java/util/concurrent/atomic/AtomicLongFieldUpdater.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicLongFieldUpdater</CODE></A>  는, 관련하는 필드형에의 액세스를 제공하는 리플렉션 베이스의 유틸리티입니다. 이것들은 주로, 동일 노드의 복수의 <tt>volatile</tt> 필드 (트리 노드의 링크등)가 독립해 원자 갱신의 대상이 되는 원자 데이터 구조로 사용됩니다. 이러한 클래스를 사용하면(자), 원자 갱신의 사용 방법 및 사용하는 타이밍에 관한 유연성이 높아집니다. 다만, 리플렉션 베이스의 설정이 취급하기 어려운, 사용하기 어려운, 보증이 약해지는 등의 희생을 지불할 필요가 있습니다.

<p><A HREF="../../../../java/util/concurrent/atomic/AtomicIntegerArray.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicIntegerArray</CODE></A> ,<A HREF="../../../../java/util/concurrent/atomic/AtomicLongArray.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicLongArray</CODE></A> , 및 <A HREF="../../../../java/util/concurrent/atomic/AtomicReferenceArray.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicReferenceArray</CODE></A>  클래스는, 이러한 형태의 배열에 대한 원자 조작 지원를 한층 더 확장합니다. 이러한 클래스는, 일반의 배열에서는 지원되지 않는, 배열 요소에 대한 <tt>volatile</tt> 액세스 시멘틱스를 제공하는 점에서도 주목할 만합니다.

<a name="Spurious">
<p>원자 클래스는, 적용성이 제한되고 있는 <tt>weakCompareAndSet</tt> 메소드도 지원합니다. 플랫폼에 따라서는, 일반적으로의 사용에서는 약한 버젼 쪽이 <tt>compareAndSet</tt> 보다 효과적인 경우가 있습니다만, 지정된 <tt>weakCompareAndSet</tt> 메소드 호출이 외관상에서도 (즉, 명확한 이유없이) <tt>false</tt> 를 돌려주는 일이 있는 점이 다릅니다. </a> <tt>false</tt> 가 의미하는 것은, 필요에 따라서 조작을 재시행할 수 있는 것 뿐입니다. 이것은, 변수가 <tt>expectedValue</tt> 를 보관 유지해, 이 변수의 설정을 시도하는 것 외의 thread가 존재하지 않는 경우에, 호출을 반복해 실행하는 것으로 최종적인 성공이 보증되는 것에 기초를 두고 있습니다. 그러한 외관상의 실패는, 예상되는 값과 현재의 값이 동일한지 어떤지 (와)는 관계가 없는, 메모리 경합 효과가 원인의 경우가 있습니다. 또,<tt>weakCompareAndSet</tt> 는, 일반적으로은 동기 제어용으로 필요한 순서부의 보증을 제공하지 않습니다. 다만, 이 메소드는, 그러한 갱신이 프로그램의 그 외의 happens-before 의 순서부에 관계없는 경우는, 카운터와 통계 정보를 갱신할 때에 편리합니다. thread로 <tt>weakCompareAndSet</tt> 에 의한 원자 변수에의 갱신이 인식되었을 때,<tt>weakCompareAndSet</tt> 의 전에 발생한 것 외의 변수에의 갱신도 인식된다고는 할 수 없습니다. 이것은, 퍼포먼스 통계 데이터를 갱신하는 경우 등은 용인할 수 있는 일도 있습니다만, 대부분은 그렇지는 않습니다.

<p> <A HREF="../../../../java/util/concurrent/atomic/AtomicMarkableReference.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicMarkableReference</CODE></A>  클래스는, 단일의 boolean 치를 참조와 관련짓습니다. 예를 들어, 데이터 구조의 내부에서 이 비트를 사용해, 참조중의 객체가 논리적으로 삭제가 끝난 상태인 것을 나타낼 수 있습니다. <A HREF="../../../../java/util/concurrent/atomic/AtomicStampedReference.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicStampedReference</CODE></A>  클래스는, 정수치를 참조에 관련짓습니다. 이것은, 일련의 갱신에 대응하는 버젼 번호를 나타내는 경우 등에 사용할 수 있습니다.

<p> 원자 클래스는, 비블록 데이터 구조 및 관련하는 기반 클래스를 구현하기 위한 기본 단위로서 주로 설계되고 있습니다. 일반적으로,<tt>compareAndSet</tt> 메소드는 락의 대체가 아닙니다. 이것은, 객체의 위기인 갱신이 「단일의」변수로 한정되는 경우에만 적용됩니다.

<p> 원자 클래스는,<tt>java.lang.Integer</tt> 및 관련 클래스에 대한 범용의 대체 클래스가 아닙니다. 이 클래스는,<tt>hashCode</tt> 나 <tt>compareTo</tt> 등의 메소드를 정의하지 않습니다 (원자 변수에서는 변경이 상정되고 있기 (위해)때문에, 해시 테이블 키로서는 바람직한 선택사항은 아니기 때문에). 또, 클래스는 목적의 어플리케이션으로 공통되어 유용한 형태에 대해서 제공됩니다. 예를 들어,<tt>byte</tt> 를 나타내는 원자 클래스는 존재하지 않습니다. 이러한 사용 빈도의 적은 케이스에서는,<tt>AtomicInteger</tt> 를 사용해 <tt>byte</tt> 치를 보관 유지해, 필요에 따라서 캐스트 할 수 있습니다. 또,<tt>Float.floatToIntBits</tt> 나 <tt>Float.intBitstoFloat</tt> 변환을 사용해 float 를 보관 유지하거나<tt>Double.doubleToLongBits</tt> 나 <tt>Double.longBitsToDouble</tt> 변환을 사용해 double 를 보관 유지하거나 할 수 있습니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?java/util/concurrent/atomic/package-summary.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
