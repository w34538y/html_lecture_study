<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 19:57:29 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Socket (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Socket (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Socket.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/net/ServerSocket.html" title="java.net 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/net/SocketAddress.html" title="java.net 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/net/Socket.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Socket.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.net</FONT>
<BR>
클래스 Socket</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.net.Socket</B>
</PRE>
<DL>
<DT><B>직계의 기존의 서브 클래스:</B> <DD><A HREF="../../javax/net/ssl/SSLSocket.html" title="javax.net.ssl 내의 클래스">SSLSocket</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>Socket</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
이 클래스는, 클라이언트 소켓 (단지 「소켓」이라고도 불린다)을 구현합니다. 소켓이란, 2 개의 머신간에 통신을 실시할 때의 단 점입니다.  &nbsp;<p>
소켓의 실제의 처리는,<code>SocketImpl</code> 클래스의 인스턴스에 의해 실행됩니다. 어플리케이션은, 소켓 구현을 작성하는 소켓 팩토리를 변경하는 것으로, 로컬 방화벽(fire wall)에 적절한 소켓을 작성하도록(듯이) 자신을 구성할 수가 있습니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)"><CODE>setSocketImplFactory(java.net.SocketImplFactory)</CODE></A> , 
<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스"><CODE>SocketImpl</CODE></A> , 
<A HREF="../../java/nio/channels/SocketChannel.html" title="java.nio.channels 안의 클래스"><CODE>SocketChannel</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket()">Socket</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;시스템으로 디폴트가 되어 있는 타입의 SocketImpl 를 사용해, 접속되어 있지 않은 소켓을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.net.InetAddress, int)">Socket</A> </B>(<A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
       int&nbsp;port)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림 소켓을 작성해, 지정된 IP 주소의 지정된 포트 번호에 접속합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.net.InetAddress, int, boolean)">Socket</A> </B>(<A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;host,
       int&nbsp;port,
       boolean&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>UDP 전송은 아니고 DatagramSocket 를 사용해 주세요. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.net.InetAddress, int, java.net.InetAddress, int)">Socket</A> </B>(<A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
       int&nbsp;port,
       <A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;localAddr,
       int&nbsp;localPort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓을 작성해, 지정된 원격 포트상의 지정된 원격 주소에 접속합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.net.Proxy)">Socket</A> </B>(<A HREF="../../java/net/Proxy.html" title="java.net 안의 클래스">Proxy</A> &nbsp;proxy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;접속되어 있지 않은 소켓을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.net.SocketImpl)">Socket</A> </B>(<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스">SocketImpl</A> &nbsp;impl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자가 지정한 SocketImpl 를 사용해, 접속되어 있지 않은 소켓을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.lang.String, int)">Socket</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
       int&nbsp;port)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림 소켓을 작성해, 지정된 호스트상의 지정된 포트 번호에 접속합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.lang.String, int, boolean)">Socket</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
       int&nbsp;port,
       boolean&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>UDP 전송은 아니고 DatagramSocket 를 사용해 주세요. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.lang.String, int, java.net.InetAddress, int)">Socket</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
       int&nbsp;port,
       <A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;localAddr,
       int&nbsp;localPort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓을 작성해, 지정된 원격 포트상의 지정된 원격 호스트에게 접속합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#bind(java.net.SocketAddress)">bind</A> </B>(<A HREF="../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;bindpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓을 로컬 주소에 바인드 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#close()">close</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓을 닫습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#connect(java.net.SocketAddress)">connect</A> </B>(<A HREF="../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;endpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓을 서버에 접속합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#connect(java.net.SocketAddress, int)">connect</A> </B>(<A HREF="../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;endpoint,
        int&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 타임 아웃치를 사용해, 이 소켓을 서버에 접속합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/nio/channels/SocketChannel.html" title="java.nio.channels 내의 클래스">SocketChannel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getChannel()">getChannel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓에 관련하는 고유 <A HREF="../../java/nio/channels/SocketChannel.html" title="java.nio.channels 중의 클래스"><CODE>SocketChannel</CODE></A>  객체를 돌려줍니다 (존재하는 경우). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/InetAddress.html" title="java.net 내의 클래스">InetAddress</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getInetAddress()">getInetAddress</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓의 접속처의 주소를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getInputStream()">getInputStream</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 입력 스트림을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getKeepAlive()">getKeepAlive</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_KEEPALIVE 가 유효한가 어떤가를 조사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/InetAddress.html" title="java.net 내의 클래스">InetAddress</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getLocalAddress()">getLocalAddress</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓의 바인드처의 로컬 주소를 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getLocalPort()">getLocalPort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 바인드처의 로컬 포트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/SocketAddress.html" title="java.net 내의 클래스">SocketAddress</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getLocalSocketAddress()">getLocalSocketAddress</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓이 바인드 되고 있는 단 점의 주소를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getOOBInline()">getOOBInline</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OOBINLINE 가 유효한가 어떤가를 조사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getOutputStream()">getOutputStream</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 출력 스트림을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getPort()">getPort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 접속처의 원격 포트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getReceiveBufferSize()">getReceiveBufferSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <tt>Socket</tt> 로 사용되는 SO_RCVBUF 옵션의 값을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/SocketAddress.html" title="java.net 내의 클래스">SocketAddress</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getRemoteSocketAddress()">getRemoteSocketAddress</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓이 접속되고 있는 단 점의 주소를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getReuseAddress()">getReuseAddress</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_REUSEADDR 가 유효한가 어떤가를 조사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getSendBufferSize()">getSendBufferSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <tt>Socket</tt> 로 사용되는 SO_SNDBUF 옵션의 값을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getSoLinger()">getSoLinger</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_LINGER 의 설정을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getSoTimeout()">getSoTimeout</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_TIMEOUT 의 설정을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getTcpNoDelay()">getTcpNoDelay</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCP_NODELAY 가 유효한가 어떤가를 조사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getTrafficClass()">getTrafficClass</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓으로부터 송신되는 패킷의 IP 헤더의 트래픽 클래스 또는 서비스 타입을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#isBound()">isBound</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓의 바인딩 상태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#isClosed()">isClosed</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓이 닫은 상태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#isConnected()">isConnected</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓의 접속 상태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#isInputShutdown()">isInputShutdown</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓 접속의 read측의 반이 닫고 있는지 어떤지를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#isOutputShutdown()">isOutputShutdown</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓 접속의 기입측의 반이 닫고 있는지 어떤지를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#sendUrgentData(int)">sendUrgentData</A> </B>(int&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓상에서 1 바이트의 긴급 데이터를 송신합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setKeepAlive(boolean)">setKeepAlive</A> </B>(boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_KEEPALIVE 를 유효 또는 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setOOBInline(boolean)">setOOBInline</A> </B>(boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OOBINLINE (TCP 긴급 데이터의 수신)를 유효 또는 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setPerformancePreferences(int, int, int)">setPerformancePreferences</A> </B>(int&nbsp;connectionTime,
                          int&nbsp;latency,
                          int&nbsp;bandwidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 퍼포먼스 설정을 실시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setReceiveBufferSize(int)">setReceiveBufferSize</A> </B>(int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <tt>Socket</tt> 의 SO_RCVBUF 옵션이 지정된 값으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setReuseAddress(boolean)">setReuseAddress</A> </B>(boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_REUSEADDR 소켓 옵션을 유효 또는 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setSendBufferSize(int)">setSendBufferSize</A> </B>(int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <tt>Socket</tt> 의 SO_SNDBUF 옵션이 지정된 값으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)">setSocketImplFactory</A> </B>(<A HREF="../../java/net/SocketImplFactory.html" title="java.net 안의 인터페이스">SocketImplFactory</A> &nbsp;fac)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;어플리케이션의 클라이언트 소켓 구현 팩토리를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setSoLinger(boolean, int)">setSoLinger</A> </B>(boolean&nbsp;on,
            int&nbsp;linger)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 지연 시간 (초)을 사용해 SO_LINGER 를 유효 또는 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setSoTimeout(int)">setSoTimeout</A> </B>(int&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 타임 아웃 (밀리 세컨드)을 사용해 SO_TIMEOUT 를 유효 또는 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setTcpNoDelay(boolean)">setTcpNoDelay</A> </B>(boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCP_NODELAY 을 유효 또는 무효로 합니다 (Nagle 의 알고리즘의 유효, 무효의 변환). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setTrafficClass(int)">setTrafficClass</A> </B>(int&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓으로부터 송신되는 패킷의 IP 헤더의 트래픽 클래스 또는 서비스 타입의 8중창을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#shutdownInput()">shutdownInput</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 입력 스트림을 「스트림의 마지막」으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#shutdownOutput()">shutdownOutput</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 출력 스트림을 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓을 <code>String</code> 로 변환합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Socket()"><!-- --></A> <H3>
Socket</H3>
<PRE>
public <B>Socket</B>()</PRE>
<DL>
<DD>시스템으로 디폴트가 되어 있는 타입의 SocketImpl 를 사용해, 접속되어 있지 않은 소켓을 작성합니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
</DL>
</DL>
<HR>

<A NAME="Socket(java.net.Proxy)"><!-- --></A> <H3>
Socket</H3>
<PRE>
public <B>Socket</B>(<A HREF="../../java/net/Proxy.html" title="java.net 안의 클래스">Proxy</A> &nbsp;proxy)</PRE>
<DL>
<DD>접속되어 있지 않은 소켓을 작성합니다. 다른 설정에 관계없이 사용해야 할 프록시 타입이 존재하는 경우는, 그 타입을 지정합니다.  &nbsp;<P>
시큐리티 매니저가 존재하는 경우, 그 <code>checkAccess</code> 메소드가, 프록시의 호스트 주소와 포트 번호를 인수로 지정해 불려 갑니다. 이 결과, SecurityException 가 throw 되는 일이 있습니다.  &nbsp;<P>
례: 
<UL> <LI><code>Socket s = new Socket(Proxy.NO_PROXY);</code> 는, 다른 프록시 구성을 무시해 프레인인 소켓을 작성한다. </LI>
<LI><code>Socket s = new Socket(new Proxy(Proxy.Type.SOCKS, new InetSocketAddress("socks.mydom.com", 1080)));</code> 는, 지정된 SOCKS 프록시 서버-경유로 접속하는 소켓을 작성한다. </LI>
 </UL>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>proxy</CODE> - 어떠한 종류의 프록시 처리를 사용해야할 것인가를 지정한 <A HREF="../../java/net/Proxy.html" title="java.net 동안의 클래스"><CODE>Proxy</CODE></A>  객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 프록시의 형태가 무효인 경우, 또는 프록시가 <code>null</code> 의 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 프록시에 접속하는 권한이 거부되었을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/ProxySelector.html" title="java.net 내의 클래스"><CODE>ProxySelector</CODE></A> , 
<A HREF="../../java/net/Proxy.html" title="java.net 안의 클래스"><CODE>Proxy</CODE></A> </DL>
</DL>
<HR>

<A NAME="Socket(java.net.SocketImpl)"><!-- --></A> <H3>
Socket</H3>
<PRE>
protected <B>Socket</B>(<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스">SocketImpl</A> &nbsp;impl)
          throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>사용자가 지정한 SocketImpl 를 사용해, 접속되어 있지 않은 소켓을 작성합니다.  &nbsp;<P>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>impl</CODE> - 서브 클래스가 Socket 상에서 사용하는 <B>SocketImpl</B> 의 인스턴스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
</DL>
</DL>
<HR>

<A NAME="Socket(java.lang.String, int)"><!-- --></A> <H3>
Socket</H3>
<PRE>
public <B>Socket</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
              int&nbsp;port)
       throws <A HREF="../../java/net/UnknownHostException.html" title="java.net 내의 클래스">UnknownHostException</A> ,
              <A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </PRE>
<DL>
<DD>스트림 소켓을 작성해, 지정된 호스트상의 지정된 포트 번호에 접속합니다.  &nbsp;<p>
지정된 호스트가 <tt>null</tt> 의 경우, 그것은, 주소를 <tt><A HREF="../../java/net/InetAddress.html#getByName(java.lang.String)"><CODE>InetAddress.getByName</CODE></A> (null)</tt> 와 지정하는 것이라고 등가가 됩니다. 즉, 그것은, 루프백 인터페이스의 주소를 지정하는 것이라고 등가가 됩니다.  </p>
 <p>
어플리케이션으로 서버 소켓 팩토리를 지정하고 있는 경우는, 그 팩토리의 <code>createSocketImpl</code> 메소드가 불려 가 실제의 소켓이 작성됩니다. 그렇지 않은 경우는 「프레인인」소켓이 작성됩니다.  &nbsp;<p>
시큐리티 매니저가 존재하는 경우, 그 <code>checkAccess</code> 메소드가, 호스트 주소와 <code>port</code> 를 인수로 지정해 불려 갑니다. 이 결과, SecurityException 가 throw 되는 일이 있습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>host</CODE> - 호스트명. 루프백 주소의 경우는 <code>null</code><DD><CODE>port</CODE> - 포트 번호
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/UnknownHostException.html" title="java.net 안의 클래스">UnknownHostException</A> </CODE> - 호스트의 IP 주소를 결정할 수 없었던 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 생성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <code>checkConnect</code> 메소드가 이 조작을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)"><CODE>setSocketImplFactory(java.net.SocketImplFactory)</CODE></A> , 
<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스"><CODE>SocketImpl</CODE></A> , 
<A HREF="../../java/net/SocketImplFactory.html#createSocketImpl()"><CODE>SocketImplFactory.createSocketImpl()</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)"><CODE>SecurityManager.checkConnect(java.lang.String, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Socket(java.net.InetAddress, int)"><!-- --></A> <H3>
Socket</H3>
<PRE>
public <B>Socket</B>(<A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
              int&nbsp;port)
       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>스트림 소켓을 작성해, 지정된 IP 주소의 지정된 포트 번호에 접속합니다.  &nbsp;<p>
어플리케이션으로 서버 소켓 팩토리를 지정하고 있는 경우는, 그 팩토리의 <code>createSocketImpl</code> 메소드가 불려 가 실제의 소켓이 작성됩니다. 그렇지 않은 경우는 「프레인인」소켓이 작성됩니다.  &nbsp;<p>
시큐리티 매니저가 존재하는 경우, 그 <code>checkAccess</code> 메소드가, 호스트 주소와 <code>port</code> 를 인수로 지정해 불려 갑니다. 이 결과, SecurityException 가 throw 되는 일이 있습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>address</CODE> - IP 주소<DD><CODE>port</CODE> - 포트 번호
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 생성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <code>checkConnect</code> 메소드가 이 조작을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)"><CODE>setSocketImplFactory(java.net.SocketImplFactory)</CODE></A> , 
<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스"><CODE>SocketImpl</CODE></A> , 
<A HREF="../../java/net/SocketImplFactory.html#createSocketImpl()"><CODE>SocketImplFactory.createSocketImpl()</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)"><CODE>SecurityManager.checkConnect(java.lang.String, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Socket(java.lang.String, int, java.net.InetAddress, int)"><!-- --></A> <H3>
Socket</H3>
<PRE>
public <B>Socket</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
              int&nbsp;port,
              <A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;localAddr,
              int&nbsp;localPort)
       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>소켓을 작성해, 지정된 원격 포트상의 지정된 원격 호스트에게 접속합니다. 게다가 이 소켓은, 지정된 로컬 주소와 로컬 포트에 바인드 됩니다.  &nbsp;<p>
지정된 호스트가 <tt>null</tt> 의 경우, 그것은, 주소를 <tt><A HREF="../../java/net/InetAddress.html#getByName(java.lang.String)"><CODE>InetAddress.getByName</CODE></A> (null)</tt> 와 지정하는 것이라고 등가가 됩니다. 즉, 그것은, 루프백 인터페이스의 주소를 지정하는 것이라고 등가가 됩니다.  </p>
 <p>
시큐리티 매니저가 존재하는 경우, 그 <code>checkAccess</code> 메소드가, 호스트 주소와 <code>port</code> 를 인수로 지정해 불려 갑니다. 이 결과, SecurityException 가 throw 되는 일이 있습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>host</CODE> - 원격 호스트의 이름. 루프백 주소의 경우는 <code>null</code><DD><CODE>port</CODE> - 원격 포트<DD><CODE>localAddr</CODE> - 소켓의 바인드처의 로컬 주소<DD><CODE>localPort</CODE> - 소켓의 바인드처의 로컬 포트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 생성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <code>checkConnect</code> 메소드가 이 조작을 허가하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)"><CODE>SecurityManager.checkConnect(java.lang.String, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Socket(java.net.InetAddress, int, java.net.InetAddress, int)"><!-- --></A> <H3>
Socket</H3>
<PRE>
public <B>Socket</B>(<A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
              int&nbsp;port,
              <A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;localAddr,
              int&nbsp;localPort)
       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>소켓을 작성해, 지정된 원격 포트상의 지정된 원격 주소에 접속합니다. 게다가 이 소켓은, 지정된 로컬 주소와 로컬 포트에 바인드 됩니다.  &nbsp;<p>
시큐리티 매니저가 존재하는 경우, 그 <code>checkAccess</code> 메소드가, 호스트 주소와 <code>port</code> 를 인수로 지정해 불려 갑니다. 이 결과, SecurityException 가 throw 되는 일이 있습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>address</CODE> - 원격 주소<DD><CODE>port</CODE> - 원격 포트<DD><CODE>localAddr</CODE> - 소켓의 바인드처의 로컬 주소<DD><CODE>localPort</CODE> - 소켓의 바인드처의 로컬 포트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 생성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <code>checkConnect</code> 메소드가 이 조작을 허가하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)"><CODE>SecurityManager.checkConnect(java.lang.String, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Socket(java.lang.String, int, boolean)"><!-- --></A> <H3>
Socket</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public <B>Socket</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
                         int&nbsp;port,
                         boolean&nbsp;stream)
       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>UDP 전송은 아니고 DatagramSocket 를 사용해 주세요. </I>
<P>
<DD>스트림 소켓을 작성해, 지정된 호스트상의 지정된 포트 번호에 접속합니다.  &nbsp;<p>
지정된 호스트가 <tt>null</tt> 의 경우, 그것은, 주소를 <tt><A HREF="../../java/net/InetAddress.html#getByName(java.lang.String)"><CODE>InetAddress.getByName</CODE></A> (null)</tt> 와 지정하는 것이라고 등가가 됩니다. 즉, 그것은, 루프백 인터페이스의 주소를 지정하는 것이라고 등가가 됩니다.  </p>
 <p>
stream 인수가 <code>true</code> 의 경우, 이것은 스트림 소켓을 작성합니다. stream 인수가 <code>false</code> 의 경우, 이것은 데이터 그램 소켓을 작성합니다.  &nbsp;<p>
어플리케이션으로 서버 소켓 팩토리를 지정하고 있는 경우는, 그 팩토리의 <code>createSocketImpl</code> 메소드가 불려 가 실제의 소켓이 작성됩니다. 그렇지 않은 경우는 「프레인인」소켓이 작성됩니다.  &nbsp;<p>
시큐리티 매니저가 존재하는 경우, 그 <code>checkAccess</code> 메소드가, 호스트 주소와 <code>port</code> 를 인수로 지정해 불려 갑니다. 이 결과, SecurityException 가 throw 되는 일이 있습니다.  &nbsp;<p>
UDP 소켓을 사용하는 경우, TCP/IP 에 관련하는 소켓 옵션은 적용되지 않습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>host</CODE> - 호스트명. 루프백 주소의 경우는 <code>null</code><DD><CODE>port</CODE> - 포트 번호<DD><CODE>stream</CODE> - 이것이 스트림 소켓, 데이터 그램 소켓의 머지않아인지를 나타내는 <code>boolean</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 생성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <code>checkConnect</code> 메소드가 이 조작을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)"><CODE>setSocketImplFactory(java.net.SocketImplFactory)</CODE></A> , 
<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스"><CODE>SocketImpl</CODE></A> , 
<A HREF="../../java/net/SocketImplFactory.html#createSocketImpl()"><CODE>SocketImplFactory.createSocketImpl()</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)"><CODE>SecurityManager.checkConnect(java.lang.String, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Socket(java.net.InetAddress, int, boolean)"><!-- --></A> <H3>
Socket</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public <B>Socket</B>(<A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;host,
                         int&nbsp;port,
                         boolean&nbsp;stream)
       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>UDP 전송은 아니고 DatagramSocket 를 사용해 주세요. </I>
<P>
<DD>소켓을 작성해, 지정된 IP 주소에 있는 지정된 포트 번호에 접속합니다.  &nbsp;<p>
stream 인수가 <code>true</code> 의 경우, 이것은 스트림 소켓을 작성합니다. stream 인수가 <code>false</code> 의 경우, 이것은 데이터 그램 소켓을 작성합니다.  &nbsp;<p>
어플리케이션으로 서버 소켓 팩토리를 지정하고 있는 경우는, 그 팩토리의 <code>createSocketImpl</code> 메소드가 불려 가 실제의 소켓이 작성됩니다. 그렇지 않은 경우는 「프레인인」소켓이 작성됩니다.
 
 <p>시큐리티 매니저가 존재하는 경우, 그 <code>checkAccess</code> 메소드가,<code>host.getHostAddress()</code> 와 <code>port</code> 를 인수로 지정해 불려 갑니다. 이 결과, SecurityException 가 throw 되는 일이 있습니다.  &nbsp;<p>
UDP 소켓을 사용하는 경우, TCP/IP 에 관련하는 소켓 옵션은 적용되지 않습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>host</CODE> - IP 주소<DD><CODE>port</CODE> - 포트 번호<DD><CODE>stream</CODE> - <code>true</code> 의 경우는 스트림 소켓을 작성해, 그 이외의 경우는 데이터 그램 소켓을 작성한다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 생성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <code>checkConnect</code> 메소드가 이 조작을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)"><CODE>setSocketImplFactory(java.net.SocketImplFactory)</CODE></A> , 
<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스"><CODE>SocketImpl</CODE></A> , 
<A HREF="../../java/net/SocketImplFactory.html#createSocketImpl()"><CODE>SocketImplFactory.createSocketImpl()</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)"><CODE>SecurityManager.checkConnect(java.lang.String, int)</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="connect(java.net.SocketAddress)"><!-- --></A> <H3>
connect</H3>
<PRE>
public void <B>connect</B>(<A HREF="../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;endpoint)
             throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 소켓을 서버에 접속합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>endpoint</CODE> - <code>SocketAddress</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 접속시에 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/nio/channels/IllegalBlockingModeException.html" title="java.nio.channels 안의 클래스">IllegalBlockingModeException</A> </CODE> - 이 소켓에 관련하는 채널이 존재해, 그 채널이 비블록 모드인 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 단 점이 null 인지, 이 소켓에 의해 지원되어 있지 않은 SocketAddress 서브 클래스인 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="connect(java.net.SocketAddress, int)"><!-- --></A> <H3>
connect</H3>
<PRE>
public void <B>connect</B>(<A HREF="../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;endpoint,
                    int&nbsp;timeout)
             throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>지정된 타임 아웃치를 사용해, 이 소켓을 서버에 접속합니다. 타임 아웃 0 은 무한의 타임 아웃으로서 해석됩니다. 그 후, 접속이 확립될까 에러가 발생할 때까지, 접속이 블록 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>endpoint</CODE> - <code>SocketAddress</code><DD><CODE>timeout</CODE> - 사용하는 타임 아웃치 (밀리 세컨드)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 접속시에 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/net/SocketTimeoutException.html" title="java.net 안의 클래스">SocketTimeoutException</A> </CODE> - 접속하기 전에 타임 아웃이 지났을 경우
<DD><CODE><A HREF="../../java/nio/channels/IllegalBlockingModeException.html" title="java.nio.channels 안의 클래스">IllegalBlockingModeException</A> </CODE> - 이 소켓에 관련하는 채널이 존재해, 그 채널이 비블록 모드인 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 단 점이 null 인지, 이 소켓에 의해 지원되어 있지 않은 SocketAddress 서브 클래스인 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="bind(java.net.SocketAddress)"><!-- --></A> <H3>
bind</H3>
<PRE>
public void <B>bind</B>(<A HREF="../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;bindpoint)
          throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>소켓을 로컬 주소에 바인드 합니다.  &nbsp;<P>
주소가 <code>null</code> 의 경우는, 시스템에 의해 일시적인 포트와 유효한 로컬 주소가 선택되어 소켓이 바인드 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>bindpoint</CODE> - 바인드처의 <code>SocketAddress</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 바인드 조작에 실패했을 경우, 혹은 소켓이 벌써 바인드 되고 있는 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - bindpoint 가, 이 소켓에 의해 지원되어 있지 않은 SocketAddress 서브 클래스인 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#isBound()"><CODE>isBound()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getInetAddress()"><!-- --></A> <H3>
getInetAddress</H3>
<PRE>
public <A HREF="../../java/net/InetAddress.html" title="java.net 내의 클래스">InetAddress</A>  <B>getInetAddress</B>()</PRE>
<DL>
<DD>소켓의 접속처의 주소를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓의 접속처의 원격 IP 주소. 소켓이 접속되어 있지 않은 경우는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getLocalAddress()"><!-- --></A> <H3>
getLocalAddress</H3>
<PRE>
public <A HREF="../../java/net/InetAddress.html" title="java.net 내의 클래스">InetAddress</A>  <B>getLocalAddress</B>()</PRE>
<DL>
<DD>소켓의 바인드처의 로컬 주소를 가져옵니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>소켓의 바인드처의 로컬 주소. 소켓이 아직 바인드되어 있지 않은 경우는 <code>InetAddress.anyLocalAddress()</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPort()"><!-- --></A> <H3>
getPort</H3>
<PRE>
public int <B>getPort</B>()</PRE>
<DL>
<DD>이 소켓의 접속처의 원격 포트를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓의 접속처의 원격 포트 번호. 소켓이 아직 접속되어 있지 않은 경우는 0</DL>
</DD>
</DL>
<HR>

<A NAME="getLocalPort()"><!-- --></A> <H3>
getLocalPort</H3>
<PRE>
public int <B>getLocalPort</B>()</PRE>
<DL>
<DD>이 소켓의 바인드처의 로컬 포트를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓의 바인드처의 로컬 포트 번호. 소켓이 아직 바인드되어 있지 않은 경우는 -1</DL>
</DD>
</DL>
<HR>

<A NAME="getRemoteSocketAddress()"><!-- --></A> <H3>
getRemoteSocketAddress</H3>
<PRE>
public <A HREF="../../java/net/SocketAddress.html" title="java.net 내의 클래스">SocketAddress</A>  <B>getRemoteSocketAddress</B>()</PRE>
<DL>
<DD>이 소켓이 접속되고 있는 단 점의 주소를 돌려줍니다. 소켓이 접속되어 있지 않은 경우는 <code>null</code> 를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓의 원격단점을 나타내는 <code>SocketAddress</code>. 소켓이 아직 접속되어 있지 않은 경우는 <code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getInetAddress()"><CODE>getInetAddress()</CODE></A> , 
<A HREF="../../java/net/Socket.html#getPort()"><CODE>getPort()</CODE></A> , 
<A HREF="../../java/net/Socket.html#connect(java.net.SocketAddress, int)"><CODE>connect(SocketAddress, int)</CODE></A> , 
<A HREF="../../java/net/Socket.html#connect(java.net.SocketAddress)"><CODE>connect(SocketAddress)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getLocalSocketAddress()"><!-- --></A> <H3>
getLocalSocketAddress</H3>
<PRE>
public <A HREF="../../java/net/SocketAddress.html" title="java.net 내의 클래스">SocketAddress</A>  <B>getLocalSocketAddress</B>()</PRE>
<DL>
<DD>이 소켓이 바인드 되고 있는 단 점의 주소를 돌려줍니다. 소켓이 바인드되어 있지 않은 경우는 <code>null</code> 를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓의 로컬단점을 나타내는 <code>SocketAddress</code>. 소켓이 아직 바인드되어 있지 않은 경우는 <code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getLocalAddress()"><CODE>getLocalAddress()</CODE></A> , 
<A HREF="../../java/net/Socket.html#getLocalPort()"><CODE>getLocalPort()</CODE></A> , 
<A HREF="../../java/net/Socket.html#bind(java.net.SocketAddress)"><CODE>bind(SocketAddress)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getChannel()"><!-- --></A> <H3>
getChannel</H3>
<PRE>
public <A HREF="../../java/nio/channels/SocketChannel.html" title="java.nio.channels 내의 클래스">SocketChannel</A>  <B>getChannel</B>()</PRE>
<DL>
<DD>이 소켓에 관련하는 고유 <A HREF="../../java/nio/channels/SocketChannel.html" title="java.nio.channels 중의 클래스"><CODE>SocketChannel</CODE></A>  객체를 돌려줍니다 (존재하는 경우).

 <p> 채널 자체가 <A HREF="../../java/nio/channels/SocketChannel.html#open()"><CODE>SocketChannel.open</CODE></A>  또는 <A HREF="../../java/nio/channels/ServerSocketChannel.html#accept()"><CODE>ServerSocketChannel.accept</CODE></A>  메소드를 사용해 작성되었을 경우에만, 소켓에 채널이 존재합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓에 관련지을 수 있었던 소켓 채널. 이 소켓이 채널용으로 작성된 것이 아닌 경우는 <tt>null</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInputStream()"><!-- --></A> <H3>
getInputStream</H3>
<PRE>
public <A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A>  <B>getInputStream</B>()
                           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 소켓의 입력 스트림을 돌려줍니다.

 <p> 이 소켓에 채널을 관련지을 수 있고 있는 경우, 결과적으로 얻을 수 있는 입력 스트림은, 그 조작의 모든 것을 채널에 위양 합니다. 그 채널이 비블록 모드인 경우, 입력 스트림의 <tt>read</tt> 조작이 <A HREF="../../java/nio/channels/IllegalBlockingModeException.html" title="java.nio.channels 안의 클래스"><CODE>IllegalBlockingModeException</CODE></A>  를 throw 합니다.

 <p>이상한 상황하에서는, 원격 호스트나 네트워크 소프트웨어에 의해 사용하고 있는 접속이 해제될 가능성이 있습니다 (TCP 접속의 경우이면 접속이 리셋 되는 등). 접속의 해제가 네트워크 소프트웨어에 의해 검출되었을 경우, 반환된 입력 스트림에 대해서 다음 일이 들어맞읍니다.

 <ul>

<li><p>네트워크 소프트웨어가 소켓에 의해 버퍼링 된 바이트를 파기할 가능성이 있다. 네트워크 소프트웨어에 의해 파기되어 있지 않은 바이트는,<A HREF="../../java/io/InputStream.html#read()"><CODE>read</CODE></A>  를 사용해 읽어낼 수가 있다.

<li><p>소켓상에 버퍼링 된 바이트가 1 개나 존재하지 않는지, 버퍼링 된 모든 바이트가 <A HREF="../../java/io/InputStream.html#read()"><CODE>read</CODE></A>  에 의해 소비되어 버렸을 경우, 후속의 <A HREF="../../java/io/InputStream.html#read()"><CODE>read</CODE></A>  호출은 모두,<A HREF="../../java/io/IOException.html" title="java.io 안의 클래스"><CODE>IOException</CODE></A>  를 throw 한다.  

<li><p>소켓상에 버퍼링 된 바이트가 1 개나 존재하지 않고,<A HREF="../../java/net/Socket.html#close()"><CODE>close</CODE></A>  를 사용해 소켓이 클로즈 되었을 경우,<A HREF="../../java/io/InputStream.html#available()"><CODE>available</CODE></A>  가 <code>0</code> 을 돌려준다.

 </ul>

 <p> 반환된 <A HREF="../../java/io/InputStream.html" title="java.io 동안의 클래스"><CODE>InputStream</CODE></A>  를 클로즈 하면(자), 관련지을 수 있었던 소켓이 클로즈 합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓으로부터 바이트를 읽어들이기 위한 입력 스트림
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입력 스트림의 작성시에 입출력 에러가 발생했을 경우, 소켓이 클로즈 되고 있는 경우, 소켓이 접속되어 있지 않은 경우, 또는 <A HREF="../../java/net/Socket.html#shutdownInput()"><CODE>shutdownInput()</CODE></A>  를 사용해 소켓의 입력이 종료 되었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getOutputStream()"><!-- --></A> <H3>
getOutputStream</H3>
<PRE>
public <A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A>  <B>getOutputStream</B>()
                             throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 소켓의 출력 스트림을 돌려줍니다.

 <p> 이 소켓에 채널을 관련지을 수 있고 있는 경우, 결과적으로 얻을 수 있는 출력 스트림은, 그 조작의 모든 것을 채널에 위양 합니다. 채널이 비블록 모드인 경우, 출력 스트림의 <tt>write</tt> 조작이 <A HREF="../../java/nio/channels/IllegalBlockingModeException.html" title="java.nio.channels 안의 클래스"><CODE>IllegalBlockingModeException</CODE></A>  를 throw 합니다.

 <p> 반환된 <A HREF="../../java/io/OutputStream.html" title="java.io 동안의 클래스"><CODE>OutputStream</CODE></A>  를 클로즈 하면(자), 관련지을 수 있었던 소켓이 클로즈 합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓에 바이트를 기입하기 위한 출력 스트림
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 출력 스트림의 작성중에 입출력 에러가 발생했을 경우, 또는 소켓이 접속되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="setTcpNoDelay(boolean)"><!-- --></A> <H3>
setTcpNoDelay</H3>
<PRE>
public void <B>setTcpNoDelay</B>(boolean&nbsp;on)
                   throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>TCP_NODELAY 를 유효 또는 무효로 합니다 (Nagle 의 알고리즘의 유효, 무효의 변환).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>on</CODE> - TCP_NODELAY 를 유효하게 하는 경우는 <code>true</code>, 무효로 하는 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getTcpNoDelay()"><CODE>getTcpNoDelay()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTcpNoDelay()"><!-- --></A> <H3>
getTcpNoDelay</H3>
<PRE>
public boolean <B>getTcpNoDelay</B>()
                      throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>TCP_NODELAY 가 유효한가 어떤가를 조사합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>TCP_NODELAY 가 유효한가 어떤가를 나타내는 <code>boolean</code> 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setTcpNoDelay(boolean)"><CODE>setTcpNoDelay(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSoLinger(boolean, int)"><!-- --></A> <H3>
setSoLinger</H3>
<PRE>
public void <B>setSoLinger</B>(boolean&nbsp;on,
                        int&nbsp;linger)
                 throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>지정된 지연 시간 (초)을 사용해 SO_LINGER 를 유효 또는 무효로 합니다. 타임 아웃의 최대치는 플랫폼에 고유합니다.

설정은 소켓을 닫는 경우에만 영향을 줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>on</CODE> - 지연 시간을 유효하게 할지 어떨지를 지정<DD><CODE>linger</CODE> - on 가 true 의 경우는, 지연 시간
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지연 시간의 값이 부의 수치인 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getSoLinger()"><CODE>getSoLinger()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSoLinger()"><!-- --></A> <H3>
getSoLinger</H3>
<PRE>
public int <B>getSoLinger</B>()
                throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_LINGER 의 설정을 돌려줍니다. 반환값 -1 은, 이 옵션이 무효가 되어 있는 것을 의미합니다.

설정은 소켓을 닫는 경우에만 영향을 줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>SO_LINGER 의 설정
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSoLinger(boolean, int)"><CODE>setSoLinger(boolean, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sendUrgentData(int)"><!-- --></A> <H3>
sendUrgentData</H3>
<PRE>
public void <B>sendUrgentData</B>(int&nbsp;data)
                    throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 소켓상에서 1 바이트의 긴급 데이터를 송신합니다. 송신되는 바이트는, 데이터 파라미터의 최하정도의 8 비트입니다. 이 긴급 바이트는, 소켓의 OutputStream 에의 선행하는 모든 기입의 뒤, OutputStream 에의 후속의 모든 기입전에 송신됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>data</CODE> - 송신하는 데이터의 바이트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 데이터 송신시에 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOOBInline(boolean)"><!-- --></A> <H3>
setOOBInline</H3>
<PRE>
public void <B>setOOBInline</B>(boolean&nbsp;on)
                  throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>OOBINLINE (TCP 긴급 데이터의 수신)를 유효 또는 무효로 합니다.

디폴트에서는 이 옵션은 무효가 되어 있어, 소켓상에서 수신된 TCP 긴급 데이터는 아무 통지도 없게 파기됩니다. 사용자가 긴급 데이터의 수신을 바라고 있는 경우는, 이 옵션을 유효하게 해 주세요. 유효하게 했을 경우, 긴급 데이터는 일반적으로 데이터와 함께 인 라인으로 수신됩니다.  &nbsp;<p>
수신 긴급 데이터의 처리에 관해서는, 한정된 지원 밖에 제공되어 있지 않은 것에 주의해 주세요. 특히, 고위 레벨의 프로토콜이 제공되어 있지 않은 경우, 수신하는 긴급 데이터의 통지는 제공되지 않고, 일반적으로 데이터와 긴급 데이터를 구별하는 기능은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>on</CODE> - OOBINLINE 를 유효하게 하는 경우는 <code>true</code>, 무효로 하는 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getOOBInline()"><CODE>getOOBInline()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getOOBInline()"><!-- --></A> <H3>
getOOBInline</H3>
<PRE>
public boolean <B>getOOBInline</B>()
                     throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>OOBINLINE 가 유효한가 어떤가를 조사합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>OOBINLINE 가 유효한가 어떤가를 나타내는 <code>boolean</code> 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setOOBInline(boolean)"><CODE>setOOBInline(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSoTimeout(int)"><!-- --></A> <H3>
setSoTimeout</H3>
<PRE>
public void <B>setSoTimeout</B>(int&nbsp;timeout)
                  throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>지정된 타임 아웃 (밀리 세컨드)을 사용해 SO_TIMEOUT 를 유효 또는 무효로 합니다. 이 옵션을 0 이외의 타임 아웃으로 설정하면(자), 이 Socket 에 관련지을 수 있었던 InputStream 의 read() 호출이, 그 시간동안만 블록 됩니다. 타임 아웃의 기한이 지나면(자), Socket 가 아직 유효해도 <B>java.net.SocketTimeoutException</B> 가 발행됩니다. 이 옵션은, 블록 처리에 들어가기 전에 유효하게 해 둘 필요가 있습니다. <B></B>타임 아웃은 0 보다 큰 값을 지정합니다.
타임 아웃 0 은 무한의 타임 아웃으로서 해석됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>timeout</CODE> - 밀리 세컨드로 나타내지는, 지정된 타임 아웃
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK 1.1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getSoTimeout()"><CODE>getSoTimeout()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSoTimeout()"><!-- --></A> <H3>
getSoTimeout</H3>
<PRE>
public int <B>getSoTimeout</B>()
                 throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_TIMEOUT 의 설정을 돌려줍니다. 이 옵션이 무효 (타임 아웃이 무한)의 경우는 0 을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>SO_TIMEOUT 의 설정
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSoTimeout(int)"><CODE>setSoTimeout(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSendBufferSize(int)"><!-- --></A> <H3>
setSendBufferSize</H3>
<PRE>
public void <B>setSendBufferSize</B>(int&nbsp;size)
                       throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>이 <tt>Socket</tt> 의 SO_SNDBUF 옵션이 지정된 값으로 설정합니다. SO_SNDBUF 옵션은, 사용하는 네트워크 입출력 버퍼로 설정하는 사이즈의 힌트로서 플랫폼의 네트워크 코드가 사용합니다.

 <p>SO_SNDBUF 는 힌트이므로, 어플리케이션으로 버퍼의 사이즈 설정을 조사할 필요가 있는 경우는,<A HREF="../../java/net/Socket.html#getSendBufferSize()"><CODE>getSendBufferSize()</CODE></A>  를 호출해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>size</CODE> - 송신 버퍼 사이즈의 설정 사이즈. 이 값은 0 보다 크지 않으면 안됩니다.
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 치가 0 또는 0 보다 작은 값인 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getSendBufferSize()"><CODE>getSendBufferSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSendBufferSize()"><!-- --></A> <H3>
getSendBufferSize</H3>
<PRE>
public int <B>getSendBufferSize</B>()
                      throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>이 <tt>Socket</tt> 로 사용되는 SO_SNDBUF 옵션의 값을 가져옵니다. 이것은, 이 <tt>Socket</tt> 로 출력용으로서 플랫폼이 사용하는 버퍼의 사이즈입니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 <tt>Socket</tt> 의 SO_SNDBUF 옵션의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSendBufferSize(int)"><CODE>setSendBufferSize(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setReceiveBufferSize(int)"><!-- --></A> <H3>
setReceiveBufferSize</H3>
<PRE>
public void <B>setReceiveBufferSize</B>(int&nbsp;size)
                          throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>이 <tt>Socket</tt> 의 SO_RCVBUF 옵션이 지정된 값으로 설정합니다. SO_RCVBUF 옵션은, 사용하는 네트워크 입출력 버퍼로 설정하는 사이즈의 힌트로서 플랫폼의 네트워크 코드가 사용합니다.

 <p>수신 버퍼의 사이즈를 늘리면(자), 대규모 접속에서의 네트워크 입출력의 퍼포먼스를 올릴 수가 있습니다. 한편, 사이즈를 줄이면(자), 수신 데이터의 백 로그를 줄일 수가 있습니다.  

 <p>SO_RCVBUF 는 힌트이므로, 어플리케이션으로 버퍼의 사이즈 설정을 조사할 필요가 있는 경우는,<A HREF="../../java/net/Socket.html#getReceiveBufferSize()"><CODE>getReceiveBufferSize()</CODE></A>  를 호출해 주세요.

 <p>SO_RCVBUF 의 값은, 원격 피어에 통지되는 TCP 수신 윈도우의 설정에도 사용됩니다. 일반적으로, 소켓이 접속되고 있는 한, 이 윈도우 사이즈는 언제라도 변경할 수 있습니다. 다만, 64K 를 넘는 수신 윈도우를 요구하는 경우는, 소켓을 원격 피어에 접속하기<B>전</B>으로 변경을 요구할 필요가 있습니다. 다음의 2 개의 경우에 주의해 주세요. <p>
 <ol>
<li>ServerSocket 로부터 받아들인 소켓의 경우, ServerSocket 를 로컬 주소에 바인드 하기 전에,<A HREF="../../java/net/ServerSocket.html#setReceiveBufferSize(int)"><CODE>ServerSocket.setReceiveBufferSize(int)</CODE></A>  를 호출해 이것을 실행할 필요가 있습니다. <p></li>
<li>클라이언트 소켓의 경우, 소켓을 그 원격 피어에 접속하기 전에, setReceiveBufferSize()를 호출할 필요가 있습니다. <p></li></ol>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>size</CODE> - 수신 버퍼 사이즈의 설정 사이즈. 이 값은 0 보다 크지 않으면 안됩니다.
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 치가 0 또는 0 보다 작은 값인 경우
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getReceiveBufferSize()"><CODE>getReceiveBufferSize()</CODE></A> , 
<A HREF="../../java/net/ServerSocket.html#setReceiveBufferSize(int)"><CODE>ServerSocket.setReceiveBufferSize(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getReceiveBufferSize()"><!-- --></A> <H3>
getReceiveBufferSize</H3>
<PRE>
public int <B>getReceiveBufferSize</B>()
                         throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>이 <tt>Socket</tt> 로 사용되는 SO_RCVBUF 옵션의 값을 가져옵니다. 이것은, 이 <tt>Socket</tt> 로 입력용으로서 플랫폼이 사용하는 버퍼의 사이즈입니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 <tt>Socket</tt> 의 SO_RCVBUF 옵션의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setReceiveBufferSize(int)"><CODE>setReceiveBufferSize(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setKeepAlive(boolean)"><!-- --></A> <H3>
setKeepAlive</H3>
<PRE>
public void <B>setKeepAlive</B>(boolean&nbsp;on)
                  throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_KEEPALIVE 를 유효 또는 무효로 합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>on</CODE> - 소켓을 온대로 해 둘지 어떨지를 지정
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getKeepAlive()"><CODE>getKeepAlive()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getKeepAlive()"><!-- --></A> <H3>
getKeepAlive</H3>
<PRE>
public boolean <B>getKeepAlive</B>()
                     throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_KEEPALIVE 가 유효한가 어떤가를 조사합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>SO_KEEPALIVE 가 유효한가 어떤가를 나타내는 <code>boolean</code> 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setKeepAlive(boolean)"><CODE>setKeepAlive(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setTrafficClass(int)"><!-- --></A> <H3>
setTrafficClass</H3>
<PRE>
public void <B>setTrafficClass</B>(int&nbsp;tc)
                     throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>이 소켓으로부터 송신되는 패킷의 IP 헤더의 트래픽 클래스 또는 서비스 타입의 8중창을 설정합니다. 사용하는 네트워크 구현이 이 값을 무시하는 일이 있으므로, 어플리케이션에서는 이 값을 힌트라고 생각해 주세요.

 <P> tc 의 범위는 <code>0 <= tc <= 255</code> 가<B>아니면 안됩니다</B>. 그렇지 않은 경우는, IllegalArgumentException 가 throw 됩니다. &nbsp;<p>주:&nbsp;<p> IP (Internet Protocol) 버젼 4 의 경우, RFC 1349 로 설명되고 있도록(듯이), 이 값은 우선도의 높은 octet 와 TOS 필드로 구성됩니다. TOS 필드는, 다음과 같이 비트 단위의 논리합에 의해 작성되는 비트 세트입니다. &nbsp;<p>
 <UL>
<LI><CODE>IPTOS_LOWCOST (0x02)</CODE></LI>
<LI><CODE>IPTOS_RELIABILITY (0x04)</CODE></LI>
<LI><CODE>IPTOS_THROUGHPUT (0x08)</CODE></LI>
<LI><CODE>IPTOS_LOWDELAY (0x10)</CODE></LI>
 </UL>
최하정도 비트는, MBZ (0 이 아니면 안된다) 비트에 대응하므로, 항상 무시됩니다.  &nbsp;<p>
우선 필드에 비트를 설정하면(자), 조작이 허가되지 않는 것을 나타내는 SocketException 가 되는 일이 있습니다.  &nbsp;<p>
RFC 1122 의 섹션 4.2. 4.2 에 나타나고 있도록(듯이), 준거한 TCP 구현은, 접속의 수명이 있는 동안은 어플리케이션이 TOS 필드를 변경할 수 있도록(듯이) 해야 합니다 (다만, 반드시 그렇게 할 필요는 없다). 따라서, TCP 접속의 확립 후에 서비스 타입 필드를 변경할 수 있을지 어떨지는, 사용하는 플랫폼내의 구현에 의해 정해집니다. 어플리케이션은, 접속 후에 TOS 필드를 변경할 수 있으면(자) 가정해야 하지는 않습니다.  &nbsp;<p>
IP (Internet Protocol) 버젼 6 의 경우,<code>tc</code> 는 IP 헤더의 sin6_flowinfo 필드에 포함되는 값입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tc</CODE> - 비트 세트의 <code>int</code> 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 트래픽 클래스 또는 서비스 타입의 설정시에 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getTrafficClass()"><CODE>getTrafficClass()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTrafficClass()"><!-- --></A> <H3>
getTrafficClass</H3>
<PRE>
public int <B>getTrafficClass</B>()
                    throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>이 소켓으로부터 송신되는 패킷의 IP 헤더의 트래픽 클래스 또는 서비스 타입을 가져옵니다. &nbsp;<p>
사용하는 네트워크 구현이,<A HREF="../../java/net/Socket.html#setTrafficClass(int)"><CODE>setTrafficClass(int)</CODE></A>  를 사용해 설정된 트래픽 클래스 또는 서비스 타입을 무시하는 일이 있으므로, 이 Socket 로 <A HREF="../../java/net/Socket.html#setTrafficClass(int)"><CODE>setTrafficClass(int)</CODE></A>  메소드를 사용해 이전으로 설정된 값과는 다른 값이 이 메소드로부터 반환되는 일이 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>벌써 설정되어 있는 트래픽 클래스 또는 서비스형
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 트래픽 클래스 또는 서비스 타입의 값을 취득할 때에 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setTrafficClass(int)"><CODE>setTrafficClass(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setReuseAddress(boolean)"><!-- --></A> <H3>
setReuseAddress</H3>
<PRE>
public void <B>setReuseAddress</B>(boolean&nbsp;on)
                     throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_REUSEADDR 소켓 옵션을 유효 또는 무효로 합니다.  &nbsp;<p>
TCP 접속을 클로즈 하는 경우, 접속 클로즈 후의 일정기간, 그 접속이 타임 아웃 상태 (일반적으로,<tt>TIME_WAIT</tt> 상태 또는 <tt>2MSL</tt> 대기 상태로 불린다)에 머무를 가능성이 있습니다. 주지의 소켓 주소 또는 포트를 사용하는 어플리케이션의 경우, 소켓 주소 또는 포트에 관련하는 접속이 타임 아웃 상태에 있으면(자), 소켓을 필요한 <tt>SocketAddress</tt> 에 바인드 할 수 없는 것이 있습니다.  &nbsp;<p>
<A HREF="../../java/net/Socket.html#bind(java.net.SocketAddress)"><CODE>bind(SocketAddress)</CODE></A>  를 사용해 소켓을 바인드 하기 전에 <tt>SO_REUSEADDR</tt> 를 유효하게 하면(자), 이전의 접속이 타임 아웃 상태에서도 소켓을 바인드 할 수가 있습니다.  &nbsp;<p>
<tt>Socket</tt> 가 작성되면(자),<tt>SO_REUSEADDR</tt> 의 초기설정은 무효가 됩니다.  &nbsp;<p>
소켓이 바인드 되었다 (<A HREF="../../java/net/Socket.html#isBound()"><CODE>isBound()</CODE></A>  를 참조) 나중에 <tt>SO_REUSEADDR</tt> 를 유효 또는 무효로 하는 경우의 동작은 정의되고 있지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>on</CODE> - 소켓 옵션을 유효하게 할까 무효로 하는지를 지정
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - <tt>SO_RESUEADDR</tt> 소켓 옵션의 유효화 또는 무효화시에 에러가 발생했을 경우, 또는 소켓이 클로즈 되고 있는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getReuseAddress()"><CODE>getReuseAddress()</CODE></A> , 
<A HREF="../../java/net/Socket.html#bind(java.net.SocketAddress)"><CODE>bind(SocketAddress)</CODE></A> , 
<A HREF="../../java/net/Socket.html#isClosed()"><CODE>isClosed()</CODE></A> , 
<A HREF="../../java/net/Socket.html#isBound()"><CODE>isBound()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getReuseAddress()"><!-- --></A> <H3>
getReuseAddress</H3>
<PRE>
public boolean <B>getReuseAddress</B>()
                        throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_REUSEADDR 가 유효한가 어떤가를 조사합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>SO_REUSEADDR 가 유효한가 어떤가를 나타내는 <code>boolean</code> 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 사용하고 있는 프로토콜로 에러 (TCP 에러등)가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setReuseAddress(boolean)"><CODE>setReuseAddress(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A> <H3>
close</H3>
<PRE>
public void <B>close</B>()
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 소켓을 닫습니다.  &nbsp;<p>
현재 이 소켓의 입출력 조작으로 블록 떠날 수 있어 모든 thread가 <A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스"><CODE>SocketException</CODE></A>  를 throw 합니다.  &nbsp;<p>
소켓이 닫혀지면(자), 그 후의 네트워크에 그 소켓을 사용할 수 없습니다 (즉, 재접속 또는 재바인드는 할 수 없다). 새로운 소켓을 작성할 필요가 있습니다.

 <p> 이 소켓을 클로즈 하면(자), 이 소켓 <A HREF="../../java/io/InputStream.html" title="java.io 중의 클래스"><CODE>InputStream</CODE></A>  와 <A HREF="../../java/io/OutputStream.html" title="java.io 안의 클래스"><CODE>OutputStream</CODE></A>  도 클로즈 됩니다.

 <p> 이 소켓에 관련하는 채널이 존재하는 경우는, 그 채널도 닫혀집니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 이 소켓을 닫을 때 입출력 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#isClosed()"><CODE>isClosed()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="shutdownInput()"><!-- --></A> <H3>
shutdownInput</H3>
<PRE>
public void <B>shutdownInput</B>()
                   throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 소켓의 입력 스트림을 「스트림의 마지막」으로 설정합니다. 소켓의 입력 스트림 측에 송신된 데이터는 모두, 확인된 뒤 아무 통지도 없게 파기됩니다.  &nbsp;<p>
소켓으로 shutdownInput()를 호출한 뒤에 소켓의 입력 스트림로부터 읽어들이면(자), 스트림은 EOF 를 돌려줍니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 이 소켓을 정지할 경우에 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#shutdownOutput()"><CODE>shutdownOutput()</CODE></A> , 
<A HREF="../../java/net/Socket.html#close()"><CODE>close()</CODE></A> , 
<A HREF="../../java/net/Socket.html#setSoLinger(boolean, int)"><CODE>setSoLinger(boolean, int)</CODE></A> , 
<A HREF="../../java/net/Socket.html#isInputShutdown()"><CODE>isInputShutdown()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="shutdownOutput()"><!-- --></A> <H3>
shutdownOutput</H3>
<PRE>
public void <B>shutdownOutput</B>()
                    throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 소켓의 출력 스트림을 무효로 합니다. TCP 소켓의 경우, 그때까지 기입해진 데이터의 모든 것이, TCP 의 일반적으로의 접속 종료 순서에 따라 송신됩니다.

소켓으로 shutdownOutput()를 호출한 뒤에 소켓의 출력 스트림에 기입하면(자), 스트림은 IOException 를 throw 합니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 이 소켓을 정지할 경우에 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#shutdownInput()"><CODE>shutdownInput()</CODE></A> , 
<A HREF="../../java/net/Socket.html#close()"><CODE>close()</CODE></A> , 
<A HREF="../../java/net/Socket.html#setSoLinger(boolean, int)"><CODE>setSoLinger(boolean, int)</CODE></A> , 
<A HREF="../../java/net/Socket.html#isOutputShutdown()"><CODE>isOutputShutdown()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 소켓을 <code>String</code> 로 변환합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓의 캐릭터 라인 표현</DL>
</DD>
</DL>
<HR>

<A NAME="isConnected()"><!-- --></A> <H3>
isConnected</H3>
<PRE>
public boolean <B>isConnected</B>()</PRE>
<DL>
<DD>소켓의 접속 상태를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>소켓이 서버에 정상적으로 접속되고 있는 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isBound()"><!-- --></A> <H3>
isBound</H3>
<PRE>
public boolean <B>isBound</B>()</PRE>
<DL>
<DD>소켓의 바인딩 상태를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>소켓이 정상적으로 주소에 바인드 되고 있는 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#bind(java.net.SocketAddress)"><CODE>bind(java.net.SocketAddress)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isClosed()"><!-- --></A> <H3>
isClosed</H3>
<PRE>
public boolean <B>isClosed</B>()</PRE>
<DL>
<DD>소켓이 닫은 상태를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>소켓이 닫았을 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#close()"><CODE>close()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isInputShutdown()"><!-- --></A> <H3>
isInputShutdown</H3>
<PRE>
public boolean <B>isInputShutdown</B>()</PRE>
<DL>
<DD>소켓 접속의 read측의 반이 닫고 있는지 어떤지를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>소켓의 입력이 정지했을 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#shutdownInput()"><CODE>shutdownInput()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isOutputShutdown()"><!-- --></A> <H3>
isOutputShutdown</H3>
<PRE>
public boolean <B>isOutputShutdown</B>()</PRE>
<DL>
<DD>소켓 접속의 기입측의 반이 닫고 있는지 어떤지를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>소켓의 출력이 정지했을 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#shutdownOutput()"><CODE>shutdownOutput()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSocketImplFactory(java.net.SocketImplFactory)"><!-- --></A> <H3>
setSocketImplFactory</H3>
<PRE>
public static void <B>setSocketImplFactory</B>(<A HREF="../../java/net/SocketImplFactory.html" title="java.net 안의 인터페이스">SocketImplFactory</A> &nbsp;fac)
                                 throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>어플리케이션의 클라이언트 소켓 구현 팩토리를 설정합니다. 팩토리를 지정할 수 있는 것은 한 번 뿐입니다.  &nbsp;<p>
어플리케이션으로 새로운 클라이언트 소켓을 작성하면(자), 소켓 구현 팩토리의 <code>createSocketImpl</code> 메소드가 불려 가 실제의 소켓이 작성됩니다.  &nbsp;<p>
이 메소드에 <code>null</code> 를 건네주어도, 팩토리가 벌써 설정되어 있지 않은 한, 그것은 무조작이 됩니다. <p>시큐리티 매니저가 존재하는 경우, 이 메소드는 최초로 시큐리티 매니저의 <code>checkSetFactory</code> 메소드를 호출하는 것으로, 이 조작이 허가되고 있는 것을 확인합니다. 이 결과, SecurityException 가 throw 되는 일이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>fac</CODE> - 목적의 팩토리
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓 팩토리의 설정중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 팩토리가 벌써 정의되고 있는 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해, 그 <code>checkSetFactory</code> 메소드가 이 조작을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/SocketImplFactory.html#createSocketImpl()"><CODE>SocketImplFactory.createSocketImpl()</CODE></A> , 
<A HREF="../../java/lang/SecurityManager.html#checkSetFactory()"><CODE>SecurityManager.checkSetFactory()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPerformancePreferences(int, int, int)"><!-- --></A> <H3>
setPerformancePreferences</H3>
<PRE>
public void <B>setPerformancePreferences</B>(int&nbsp;connectionTime,
                                      int&nbsp;latency,
                                      int&nbsp;bandwidth)</PRE>
<DL>
<DD>이 소켓의 퍼포먼스 설정을 실시합니다.

 <p> 소켓은 디폴트로, TCP/IP 프로토콜을 사용합니다. 구현에 따라서는, TCP/IP 와는 다른 퍼포먼스 특성을 가지는 대체 프로토콜을 제공하는 일도 있습니다. 어플리케이션은, 이 메소드를 사용하는 것으로, 구현으로 이용 가능한 프로토콜의 선택시에, 이러한 균형의 취하는 방법을 나타내는 독자적인 설정을 표현할 수 있습니다.   

 <p> 퍼포먼스 설정은, 접속 시간의 짧음, 응답 시간의 속도, 및 대역폭의 넓이의 상대적인 중요도를 나타내는 3 개의 정수치에 의해 기술됩니다. 이러한 정수의 절대치는 중요하지는 않습니다. 어느 특정의 프로토콜을 선택하기 위해서, 이러한 값이 단순하게 비교됩니다만, 그 때, 값이 크면보다 강한 설정을 나타냅니다. 0 보다 작은 값은 정의 값보다 낮은 우선 순위를 나타냅니다. 예를 들어, 어플리케이션이 응답 시간의 속도나 대역폭의 넓이보다 접속 시간의 짧음을 우선하는 경우에는, 값 <tt>(1, 0, 0)</tt> 을 지정해 이 메소드를 호출할 수가 있습니다. 어플리케이션이 응답 시간의 속도보다 대역폭의 넓이를 우선해, 접속 시간의 짧음보다 대기 시간의 짧음을 우선하는 경우에는, 값 <tt>(0, 1, 2)</tt> 을 지정해 이 메소드를 호출할 수가 있습니다.

 <p> 이 소켓의 접속 후에 이 메소드를 호출해도, 무슨 효과도 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>connectionTime</CODE> - 접속 시간의 짧음의 상대적인 중요도를 나타내는 <tt>int</tt><DD><CODE>latency</CODE> - 응답 시간의 속도의 상대적인 중요도를 나타내는 <tt>int</tt><DD><CODE>bandwidth</CODE> - 대역폭의 넓이의 상대적인 중요도를 나타내는 <tt>int</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Socket.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/net/ServerSocket.html" title="java.net 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/net/SocketAddress.html" title="java.net 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?java/net/Socket.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Socket.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
