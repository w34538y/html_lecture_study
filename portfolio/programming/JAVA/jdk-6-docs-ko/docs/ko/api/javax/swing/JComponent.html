<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:10:54 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
JComponent (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JComponent (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JComponent.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/swing/JComboBox.KeySelectionManager.html" title="javax.swing 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/swing/JComponent.AccessibleJComponent.html" title="javax.swing 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/swing/JComponent.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="JComponent.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.swing</FONT>
<BR>
클래스 JComponent</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">java.awt.Component</A> 
      <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">java.awt.Container</A> 
          <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.swing.JComponent</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 내의 인터페이스">ImageObserver</A> , <A HREF="../../java/awt/MenuContainer.html" title="java.awt 안의 인터페이스">MenuContainer</A> , <A HREF="../../java/io/Serializable.html" title="java.io 안의 인터페이스">Serializable</A> </DD>
</DL>
<DL>
<DT><B>직계의 기존의 서브 클래스:</B> <DD><A HREF="../../javax/swing/AbstractButton.html" title="javax.swing 내의 클래스">AbstractButton</A> , <A HREF="../../javax/swing/plaf/basic/BasicInternalFrameTitlePane.html" title="javax.swing.plaf.basic 안의 클래스">BasicInternalFrameTitlePane</A> , <A HREF="../../javax/swing/Box.html" title="javax.swing 안의 클래스">Box</A> , <A HREF="../../javax/swing/Box.Filler.html" title="javax.swing 안의 클래스">Box.Filler</A> , <A HREF="../../javax/swing/JColorChooser.html" title="javax.swing 안의 클래스">JColorChooser</A> , <A HREF="../../javax/swing/JComboBox.html" title="javax.swing 안의 클래스">JComboBox</A> , <A HREF="../../javax/swing/JFileChooser.html" title="javax.swing 안의 클래스">JFileChooser</A> , <A HREF="../../javax/swing/JInternalFrame.html" title="javax.swing 안의 클래스">JInternalFrame</A> , <A HREF="../../javax/swing/JInternalFrame.JDesktopIcon.html" title="javax.swing 안의 클래스">JInternalFrame.JDesktopIcon</A> , <A HREF="../../javax/swing/JLabel.html" title="javax.swing 안의 클래스">JLabel</A> , <A HREF="../../javax/swing/JLayeredPane.html" title="javax.swing 안의 클래스">JLayeredPane</A> , <A HREF="../../javax/swing/JList.html" title="javax.swing 안의 클래스">JList</A> , <A HREF="../../javax/swing/JMenuBar.html" title="javax.swing 안의 클래스">JMenuBar</A> , <A HREF="../../javax/swing/JOptionPane.html" title="javax.swing 안의 클래스">JOptionPane</A> , <A HREF="../../javax/swing/JPanel.html" title="javax.swing 안의 클래스">JPanel</A> , <A HREF="../../javax/swing/JPopupMenu.html" title="javax.swing 안의 클래스">JPopupMenu</A> , <A HREF="../../javax/swing/JProgressBar.html" title="javax.swing 안의 클래스">JProgressBar</A> , <A HREF="../../javax/swing/JRootPane.html" title="javax.swing 안의 클래스">JRootPane</A> , <A HREF="../../javax/swing/JScrollBar.html" title="javax.swing 안의 클래스">JScrollBar</A> , <A HREF="../../javax/swing/JScrollPane.html" title="javax.swing 안의 클래스">JScrollPane</A> , <A HREF="../../javax/swing/JSeparator.html" title="javax.swing 안의 클래스">JSeparator</A> , <A HREF="../../javax/swing/JSlider.html" title="javax.swing 안의 클래스">JSlider</A> , <A HREF="../../javax/swing/JSpinner.html" title="javax.swing 안의 클래스">JSpinner</A> , <A HREF="../../javax/swing/JSplitPane.html" title="javax.swing 안의 클래스">JSplitPane</A> , <A HREF="../../javax/swing/JTabbedPane.html" title="javax.swing 안의 클래스">JTabbedPane</A> , <A HREF="../../javax/swing/JTable.html" title="javax.swing 안의 클래스">JTable</A> , <A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 안의 클래스">JTableHeader</A> , <A HREF="../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> , <A HREF="../../javax/swing/JToolBar.html" title="javax.swing 안의 클래스">JToolBar</A> , <A HREF="../../javax/swing/JToolTip.html" title="javax.swing 안의 클래스">JToolTip</A> , <A HREF="../../javax/swing/JTree.html" title="javax.swing 안의 클래스">JTree</A> , <A HREF="../../javax/swing/JViewport.html" title="javax.swing 안의 클래스">JViewport</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>JComponent</B><DT>extends <A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> <DT>implements <A HREF="../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
톱 레벨의 컨테이너를 제외한 모든 Swing 컴퍼넌트의 base class입니다. <code>JComponent</code> 로부터 상속하는 컴퍼넌트를 사용하려면 , 루트가 톱 레벨의 Swing 컨테이너인 포함 관계의 계층에 컴퍼넌트를 자리 매김을 할 필요가 있습니다. <code>JFrame</code>,<code>JDialog</code>,<code>JApplet</code> 등의 톱 레벨의 Swing 컨테이너는, 다른 Swing 컴퍼넌트가 그것 자신을 draw하기 위한 장소를 제공하는 특수한 컴퍼넌트입니다. 포함 관계의 계층에 대해서는, 「The Java Tutorial」의<a  href="http://java.sun.com/docs/books/tutorial/uiswing/overview/hierarchy.html">「Swing Components and the Containment Hierarchy」</a>를 참조해 주세요.

 <p>
<code>JComponent</code> 클래스는 이하의 기능을 제공합니다.
 <ul>
<li>Swing 아키텍쳐(architecture)를 사용하는, 표준 컴퍼넌트 및 커스텀 컴퍼넌트 양쪽 모두의 base class.
<li>프로그래머가 지정, 또는 옵션으로 사용자가 실행시에 선택할 수 있는 「플러그 인 가능한 Look & Feel (L&F)」. 각 컴퍼넌트의 Look & Feel 는 「UI 위양」, 즉 <A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A>  로부터 파생하는 객체로 제공됩니다. 상세한 것에 대하여는, 「The Java Tutorial」의<a  href="http://java.sun.com/docs/books/tutorial/uiswing/misc/plaf.html">「How to Set the Look and Feel」</a>를 참조해 주세요.
<li>포괄적인 키스트로크(keystroke) 처리. 상세한 것에 대하여는, 「The Swing Connection」의<a  href="http://java.sun.com/products/jfc/tsc/special_report/kestrel/keybindings.html">「Keyboard Bindings in Swing」</a>를 참조해 주세요.
<li>툴팁의 지원. 툴팁는 커서가 컴퍼넌트상에 있을 때 표시되는 짧은 설명. 자세한 것은, 「The Java Tutorial」의<a  href="http://java.sun.com/docs/books/tutorial/uiswing/components/tooltip.html">「How to Use Tool Tips」</a>를 참조해 주세요.
<li>접근성? 지원. <code> JComponent</code> 는 인터페이스 <code>Accessible</code> 에 모든 메소드를 포함합니다만, 인터페이스를 실제로는 구현하지 않습니다. 구현은 <code>JComponent</code> 를 확장하는 개개의 클래스에 의존합니다.
<li>컴퍼넌트 고유의 프로퍼티의 지원. <A HREF="../../javax/swing/JComponent.html#putClientProperty(java.lang.Object, java.lang.Object)"><CODE>putClientProperty(java.lang.Object, java.lang.Object)</CODE></A>  와 <A HREF="../../javax/swing/JComponent.html#getClientProperty(java.lang.Object)"><CODE>getClientProperty(java.lang.Object)</CODE></A>  의 메소드의 경우, 이름과 객체의 페어를 <code>JComponent</code> 로부터 파생하는 어느 객체에도 관련지을 수가 있습니다.
<li>더블 버퍼링과 경계의 지원에 대응하고 있는, 페인트를 위한 인프라스트럭쳐(infrastructure). 상세한 것에 대하여는, 「The Java Tutorial」의<a  href="http://java.sun.com/docs/books/tutorial/uiswing/overview/draw.html">「Painting」라고</a> <a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/border.html">「How to Use Borders」</a>를 참조해 주세요. <em></em>
 </ul>
상기의 기능의 상세한 것에 대하여는,<a href="package-summary.html#package_description">「Swing package description」와「</a> The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/components/jcomponent.html">「The JComponent Class」</a>를 참조해 주세요.  &nbsp;<p>
<code>JComponent</code> 와 그 서브 클래스는, 특정의 프로퍼티의 디폴트 값를 문서화합니다. 예를 들어,<code>JTable</code> 는 디폴트의 행의 높이를 16 으로서 문서화합니다. <code> ComponentUI</code> 를 가지는 <code>JComponent</code> 의 각 서브 클래스는,<code>ComponentUI</code> 를 그 생성자 의 일부로서 생성합니다. 각 <code>ComponentUI</code> 에서는, 특수한 Look & Feel 를 제공하기 위해서, 생성원의 <code>JComponent</code> 로 프로퍼티을 다시 설정하는 일이 있습니다. 예를 들어, 커스텀의 Look & Feel 에서는,<code>JTable</code> 의 행의 높이를 24 로 할 필요가 있습니다. 문서화 된 디폴트는,<code>ComponentUI</code> 를 인스톨 하기 전의 프로퍼티의 값입니다. 특정의 프로퍼티에 특정의 값이 필요한 경우는, 그것을 명시적으로 설정해 주세요.  &nbsp;<p>
릴리스 1.4 에서는, 포커스 하부조직이 재구축 되었습니다. 상세한 것에 대하여는, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">「How to Use the Focus Subsystem」</a>를 참조해 주세요. <em></em> &nbsp;<p>
<strong>경고:</strong> Swing 는 thread에 대해서 안전하지는 않습니다. 자세한 것은,<a  href="package-summary.html#threading">「Swing's Threading Policy」</a>를 참조해 주세요.  &nbsp;<p>
<strong>경고:</strong> 이 클래스의 직렬화 된 객체는, 향후의 Swing 릴리스와 호환은 아니게 될 예정입니다. 현재의 직렬화의 지원는, 단기간의 운용이나, 같은 버젼의 Swing 를 실행하는 어플리케이션간의 RMI 에 적절하고 있습니다. JDK Version 1.4 이후, 모든 JavaBeans<sup><font size="-2">&trade;</font></sup> 의 장기간의 운용 지원는,<code>java.beans</code> 패키지에 추가되고 있습니다. 자세한 것은,<A HREF="../../java/beans/XMLEncoder.html" title="java.beans 안의 클래스"><CODE>XMLEncoder</CODE></A>  를 참조해 주세요.
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 내의 클래스"><CODE>KeyStroke</CODE></A> , 
<A HREF="../../javax/swing/Action.html" title="javax.swing 안의 인터페이스"><CODE>Action</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setBorder(javax.swing.border.Border)"><CODE>setBorder(javax.swing.border.Border)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)"><CODE>registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)</CODE></A> , 
<A HREF="../../javax/swing/JOptionPane.html" title="javax.swing 안의 클래스"><CODE>JOptionPane</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setDebugGraphicsOptions(int)"><CODE>setDebugGraphicsOptions(int)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setToolTipText(java.lang.String)"><CODE>setToolTipText(java.lang.String)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setAutoscrolls(boolean)"><CODE>setAutoscrolls(boolean)</CODE></A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.AccessibleJComponent.html" title="javax.swing 안의 클래스">JComponent.AccessibleJComponent</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;접근성?의 디폴트 지원를 제공하기 위해서 사용하는 JComponen 의 내부 클래스입니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_java.awt.Container"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Container.html" title="java.awt 안의 클래스">Container</A>  로부터 상속된 상자의 클래스/인터페이스</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Container.AccessibleAWTContainer.html" title="java.awt 안의 클래스">Container.AccessibleAWTContainer</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<A NAME="nested_classes_inherited_from_class_java.awt.Component"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A>  로부터 상속된 상자의 클래스/인터페이스</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.AccessibleAWTComponent.html" title="java.awt 안의 클래스">Component.AccessibleAWTComponent</A> , <A HREF="../../java/awt/Component.BaselineResizeBehavior.html" title="java.awt 안의 열거형">Component.BaselineResizeBehavior</A> , <A HREF="../../java/awt/Component.BltBufferStrategy.html" title="java.awt 안의 클래스">Component.BltBufferStrategy</A> , <A HREF="../../java/awt/Component.FlipBufferStrategy.html" title="java.awt 안의 클래스">Component.FlipBufferStrategy</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/accessibility/AccessibleContext.html" title="javax.accessibility 내의 클래스">AccessibleContext</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#accessibleContext">accessibleContext</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JComponent</code> 에 관련지을 수 있었던 <code>AccessibleContext</code> 입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/event/EventListenerList.html" title="javax.swing.event 내의 클래스">EventListenerList</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#listenerList">listenerList</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 이벤트 청취자 리스트입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#TOOL_TIP_TEXT_KEY">TOOL_TIP_TEXT_KEY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;커서가 컴퍼넌트상에 있을 때 표시되는 코멘트입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 내의 클래스">ComponentUI</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#ui">ui</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 Look & Feel 위양입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#UNDEFINED_CONDITION">UNDEFINED_CONDITION</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;몇개의 API 로 사용되는 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#WHEN_ANCESTOR_OF_FOCUSED_COMPONENT">WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>registerKeyboardAction()</code> 로 사용되는 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#WHEN_FOCUSED">WHEN_FOCUSED</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>registerKeyboardAction</code> 로 사용되는 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#WHEN_IN_FOCUSED_WINDOW">WHEN_IN_FOCUSED_WINDOW</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>registerKeyboardAction()</code> 로 사용되는 정수입니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.Component"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.html#BOTTOM_ALIGNMENT">BOTTOM_ALIGNMENT</A> , <A HREF="../../java/awt/Component.html#CENTER_ALIGNMENT">CENTER_ALIGNMENT</A> , <A HREF="../../java/awt/Component.html#LEFT_ALIGNMENT">LEFT_ALIGNMENT</A> , <A HREF="../../java/awt/Component.html#RIGHT_ALIGNMENT">RIGHT_ALIGNMENT</A> , <A HREF="../../java/awt/Component.html#TOP_ALIGNMENT">TOP_ALIGNMENT</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.image.ImageObserver"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.awt.image. <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/image/ImageObserver.html#ABORT">ABORT</A> , <A HREF="../../java/awt/image/ImageObserver.html#ALLBITS">ALLBITS</A> , <A HREF="../../java/awt/image/ImageObserver.html#ERROR">ERROR</A> , <A HREF="../../java/awt/image/ImageObserver.html#FRAMEBITS">FRAMEBITS</A> , <A HREF="../../java/awt/image/ImageObserver.html#HEIGHT">HEIGHT</A> , <A HREF="../../java/awt/image/ImageObserver.html#PROPERTIES">PROPERTIES</A> , <A HREF="../../java/awt/image/ImageObserver.html#SOMEBITS">SOMEBITS</A> , <A HREF="../../java/awt/image/ImageObserver.html#WIDTH">WIDTH</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#JComponent()">JComponent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트의 <code>JComponent</code> 생성자 입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#addAncestorListener(javax.swing.event.AncestorListener)">addAncestorListener</A> </B>(<A HREF="../../javax/swing/event/AncestorListener.html" title="javax.swing.event 안의 인터페이스">AncestorListener</A> &nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>listener</code> 를 등록해, 컴퍼넌트 또는 게다가 위객체가 이동하든가, 혹은 가시 또는 불가시가 될 때 그 청취자가 <code>AncestorEvent</code> 를 받아들이도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#addNotify()">addNotify</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트에 현재친컴퍼넌트가 있는 것을, 이 컴퍼넌트에 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#addVetoableChangeListener(java.beans.VetoableChangeListener)">addVetoableChangeListener</A> </B>(<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 안의 인터페이스">VetoableChangeListener</A> &nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>VetoableChangeListener</code> 를 청취자 리스트에 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#computeVisibleRect(java.awt.Rectangle)">computeVisibleRect</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;visibleRect)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Component</code> 의 「가시 구형」을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#contains(int, int)">contains</A> </B>(int&nbsp;x,
         int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;마우스 처리를 위해서(때문에), 이 컴퍼넌트의 정확한 형상을 정의할 기회를 UI 위양에 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/JToolTip.html" title="javax.swing 내의 클래스">JToolTip</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#createToolTip()">createToolTip</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;툴팁를 표시하기 위해서 사용되는 <code>JToolTip</code> 의 인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#disable()">disable</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK version 1.1 이후는,<code>java.awt.Component.setEnabled(boolean)</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#enable()">enable</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK version 1.1 이후는,<code>java.awt.Component.setEnabled(boolean)</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#firePropertyChange(java.lang.String, boolean, boolean)">firePropertyChange</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                   boolean&nbsp;oldValue,
                   boolean&nbsp;newValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean 형 프로퍼티에 대한 바운드 프로퍼티의 변경의 보고를 지원합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#firePropertyChange(java.lang.String, char, char)">firePropertyChange</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                   char&nbsp;oldValue,
                   char&nbsp;newValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바운드 프로퍼티의 변경을 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#firePropertyChange(java.lang.String, int, int)">firePropertyChange</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                   int&nbsp;oldValue,
                   int&nbsp;newValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;정수형 프로퍼티에 대한 바운드 프로퍼티의 변경의 보고를 지원합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#fireVetoableChange(java.lang.String, java.lang.Object, java.lang.Object)">fireVetoableChange</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                   <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;oldValue,
                   <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;newValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;제약 프로퍼티의 변경의 보고를 지원합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/accessibility/AccessibleContext.html" title="javax.accessibility 내의 클래스">AccessibleContext</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getAccessibleContext()">getAccessibleContext</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JComponent</code> 에 관련한 <code>AccessibleContext</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/event/ActionListener.html" title="java.awt.event 내의 인터페이스">ActionListener</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getActionForKeyStroke(javax.swing.KeyStroke)">getActionForKeyStroke</A> </B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 키스트로크(keystroke)에 대해서 등록되어 있는 액션을 실행하는 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/ActionMap.html" title="javax.swing 내의 클래스">ActionMap</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getActionMap()">getActionMap</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;특정의 <code>KeyStroke</code> 바인딩에 대해서 트리거하는 <code>Action</code> 의 지정에 사용되는 <code>ActionMap</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getAlignmentX()">getAlignmentX</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Container.getAlignmentX</code> 를 오버라이드(override) 해, 수직의 배치 방법을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getAlignmentY()">getAlignmentY</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Container.getAlignmentY</code> 를 오버라이드(override) 해, 수평의 배치 방법을 돌려주도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/event/AncestorListener.html" title="javax.swing.event 내의 인터페이스">AncestorListener</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getAncestorListeners()">getAncestorListeners</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트에 등록되어 모든 상위 청취자의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getAutoscrolls()">getAutoscrolls</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>autoscrolls</code> 프로퍼티을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getBaseline(int, int)">getBaseline</A> </B>(int&nbsp;width,
            int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baseline를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.BaselineResizeBehavior.html" title="java.awt 내의 열거형">Component.BaselineResizeBehavior</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getBaselineResizeBehavior()">getBaselineResizeBehavior</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 사이즈가 변화하는 것에 따라 baseline가 변화하는 방법의 열거를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/border/Border.html" title="javax.swing.border 내의 인터페이스">Border</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getBorder()">getBorder</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getBounds(java.awt.Rectangle)">getBounds</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;rv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 경계를 「반환값」<code>rv</code> 에 포함해,<code>rv</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getClientProperty(java.lang.Object)">getClientProperty</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 키를 가지는 프로퍼티의 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getComponentGraphics(java.awt.Graphics)">getComponentGraphics</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트를 페인트 하기 위해서 사용되는 그래픽스 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/JPopupMenu.html" title="javax.swing 내의 클래스">JPopupMenu</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getComponentPopupMenu()">getComponentPopupMenu</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트에 할당할 수 있었던 <code>JPopupMenu</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getConditionForKeyStroke(javax.swing.KeyStroke)">getConditionForKeyStroke</A> </B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;등록되어 있는 액션이, 지정된 키스트로크(keystroke)에 반응해 발생할지 어떨지를 결정하는 조건을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getDebugGraphicsOptions()">getDebugGraphicsOptions</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그라픽스데밧깅 상태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/util/Locale.html" title="java.util 내의 클래스">Locale</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getDefaultLocale()">getDefaultLocale</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 각 JComponent 의 로케일 프로퍼티을 생성시에 초기화하기 위해서 사용하는 디폴트 로케일을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/FontMetrics.html" title="java.awt 내의 클래스">FontMetrics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getFontMetrics(java.awt.Font)">getFontMetrics</A> </B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>Font</code> 의 <code>FontMetrics</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getGraphics()">getGraphics</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 그래픽스 문맥을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getHeight()">getHeight</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 현재의 높이를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getInheritsPopupMenu()">getInheritsPopupMenu</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPopupMenu 가 부모로부터 상속될 것인 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/InputMap.html" title="javax.swing 내의 클래스">InputMap</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getInputMap()">getInputMap</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트가 포커스를 취득했을 때에 사용하는 <code>InputMap</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/InputMap.html" title="javax.swing 내의 클래스">InputMap</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getInputMap(int)">getInputMap</A> </B>(int&nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>condition</code> 로 사용되고 있는 <code>InputMap</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 내의 클래스">InputVerifier</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getInputVerifier()">getInputVerifier</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 입력 검증자를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Insets.html" title="java.awt 내의 클래스">Insets</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getInsets()">getInsets</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트로 경계가 설정되어 있는 경우는 경계의 인 세트를 돌려주어, 그렇지 않은 경우는 <code>super.getInsets</code> 를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Insets.html" title="java.awt 내의 클래스">Insets</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getInsets(java.awt.Insets)">getInsets</A> </B>(<A HREF="../../java/awt/Insets.html" title="java.awt 안의 클래스">Insets</A> &nbsp;insets)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 인 세트치를 포함하는 <code>Insets</code> 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../java/util/EventListener.html" title="java.util 내의 인터페이스">EventListener</A> &gt; 
<BR>
T[]</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getListeners(java.lang.Class)">getListeners</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;T&gt;&nbsp;listenerType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JComponent</code> 에 <code><em>Foo</em>Listener</code> 로서 현재 등록되어 모든 객체의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Point.html" title="java.awt 내의 클래스">Point</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getLocation(java.awt.Point)">getLocation</A> </B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;rv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 원점의 x, y 좌표를 「반환값」<code>rv</code> 에 포함해,<code>rv</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getMaximumSize()">getMaximumSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;최대 사이즈가 <code>null</code> 이외의 값으로 설정되어 있는 경우는 그 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getMinimumSize()">getMinimumSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;최소 사이즈가 <code>null</code> 이외의 값으로 설정되어 있는 경우는 그 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getNextFocusableComponent()">getNextFocusableComponent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK Version 1.4 이후는,<code>FocusTraversalPolicy</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Point.html" title="java.awt 내의 클래스">Point</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getPopupLocation(java.awt.event.MouseEvent)">getPopupLocation</A> </B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 좌표계에 pop-up menu를 표시하는데 적절한 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getPreferredSize()">getPreferredSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>preferredSize</code> 가 <code>null</code> 이외의 값으로 설정되어 있는 경우에 그 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 내의 클래스">KeyStroke</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getRegisteredKeyStrokes()">getRegisteredKeyStrokes</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;등록되어 있는 액션을 개시하는 <code>KeyStroke</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/JRootPane.html" title="javax.swing 내의 클래스">JRootPane</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getRootPane()">getRootPane</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 <code>JRootPane</code> 상위 컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getSize(java.awt.Dimension)">getSize</A> </B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;rv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 폭과 높이를 「반환값」<code>rv</code> 에 포함해,<code>rv</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Point.html" title="java.awt 내의 클래스">Point</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getToolTipLocation(java.awt.event.MouseEvent)">getToolTipLocation</A> </B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 좌표계에 있어서의 툴팁의 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getToolTipText()">getToolTipText</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>setToolTipText</code> 로 설정되어 있는 툴팁의 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getToolTipText(java.awt.event.MouseEvent)">getToolTipText</A> </B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>event</i> 의 툴팁로서 사용되는 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getTopLevelAncestor()">getTopLevelAncestor</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 톱 레벨의 상위 객체 (포함처의 Window 또는 Applet)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 내의 클래스">TransferHandler</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getTransferHandler()">getTransferHandler</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>transferHandler</code> 프로퍼티을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getUIClassID()">getUIClassID</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 Look & Feel 를 정의하는 <code>swing.plaf.ComponentUI</code> 클래스의 이름을 검색하기 위해서 사용하는 <code>UIDefaults</code> 키를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getVerifyInputWhenFocusTarget()">getVerifyInputWhenFocusTarget</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 포커스를 요구하기 전에, 현재의 포커스를 가지는 컴퍼넌트에 입력 검증자를 호출할지 어떨지를 나타내는 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 내의 인터페이스">VetoableChangeListener</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getVetoableChangeListeners()">getVetoableChangeListeners</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트에 등록되어 모든 거부 가능 변경 청취자의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getVisibleRect()">getVisibleRect</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이것은 이 메소드의 반환값입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getWidth()">getWidth</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 현재의 폭을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getX()">getX</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 원점의 현재의 x 좌표를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getY()">getY</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 원점의 현재의 y 좌표를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#grabFocus()">grabFocus</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 입력초점을 취득해, 이 컴퍼넌트의 최상정도 클래스의 윈도우에 포커스를 설정하는 것을 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isDoubleBuffered()">isDoubleBuffered</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 버퍼를 사용해 페인트 할지 어떨지를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isLightweightComponent(java.awt.Component)">isLightweightComponent</A> </B>(<A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A> &nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 경량의 경우, 즉 네이티브의 윈도우 시스템 피어를 가지지 않는 경우에 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isManagingFocus()">isManagingFocus</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>1.4 이후는 <code>Component.setFocusTraversalKeys(int, Set)</code> 와 <code>Container.setFocusCycleRoot(boolean)</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isOpaque()">isOpaque</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 완전하게 불투명한 경우에 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isOptimizedDrawingEnabled()">isOptimizedDrawingEnabled</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 그 아이를 타일링 하는 경우, 즉 아이가 오버랩 하지 않는 것이 보증되는 경우에 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isPaintingForPrint()">isPaintingForPrint</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트상의 현재의 페인트 조작이 다른 <code>print</code> 조작의 일부인 경우는 <code>true</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isPaintingTile()">isPaintingTile</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트가 현재 타일을 페인트 하고 있는 경우에 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isRequestFocusEnabled()">isRequestFocusEnabled</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JComponent</code> 가 포커스를 취득하는 경우는 <code>true</code> 를 돌려주어, 그렇지 않은 경우는 <code>false</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isValidateRoot()">isValidateRoot</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메소드가 true 를 돌려주는 경우, 이 컴퍼넌트의 하위 컴퍼넌트에 의해 <code>revalidate</code> 가 불려 가면(자), 이 루트로 시작되는 트리 전체가 검증됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paint(java.awt.Graphics)">paint</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메소드는 Swing 에 의해 불려 가 컴퍼넌트를 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paintBorder(java.awt.Graphics)">paintBorder</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 경계를 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paintChildren(java.awt.Graphics)">paintChildren</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 아이를 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paintComponent(java.awt.Graphics)">paintComponent</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UI 위양이 <code>null</code> 가 아닌 경우에, UI 위양의 페인트 메소드를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paintImmediately(int, int, int, int)">paintImmediately</A> </B>(int&nbsp;x,
                 int&nbsp;y,
                 int&nbsp;w,
                 int&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 지정된 영역, 및 그 영역과 오버랩 하는 모든 하위 컴퍼넌트를 곧바로 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paintImmediately(java.awt.Rectangle)">paintImmediately</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 영역을 곧바로 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paramString()">paramString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JComponent</code> 의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#print(java.awt.Graphics)">print</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트를 지정의 <code>Graphics</code> 에 인쇄하려면 , 이 메소드를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#printAll(java.awt.Graphics)">printAll</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트를 인쇄하려면 , 이 메소드를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#printBorder(java.awt.Graphics)">printBorder</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 경계를 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#printChildren(java.awt.Graphics)">printChildren</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 아이를 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#printComponent(java.awt.Graphics)">printComponent</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메소드는 인쇄 조작중에 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#processComponentKeyEvent(java.awt.event.KeyEvent)">processComponentKeyEvent</A> </B>(<A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트 자체가 인식하는 키 이벤트를 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#processKeyBinding(javax.swing.KeyStroke, java.awt.event.KeyEvent, int, boolean)">processKeyBinding</A> </B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;ks,
                  <A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e,
                  int&nbsp;condition,
                  boolean&nbsp;pressed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>KeyEvent</code> <code>e</code> 의 결과로서 <code>ks</code> 의 키 바인드를 처리하기 위해서 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#processKeyEvent(java.awt.event.KeyEvent)">processKeyEvent</A> </B>(<A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이벤트를 처리하는 <code>processKeyEvent</code> 를 오버라이드(override) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#processMouseEvent(java.awt.event.MouseEvent)">processMouseEvent</A> </B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트로 발생하는 마우스 이벤트를, 등록되어 모든 <code>MouseListener</code> 객체에 발송 하는 것으로써, 마우스 이벤트를 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#processMouseMotionEvent(java.awt.event.MouseEvent)">processMouseMotionEvent</A> </B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MouseEvent.MOUSE_DRAGGED 등의 마우스 모션 이벤트를 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#putClientProperty(java.lang.Object, java.lang.Object)">putClientProperty</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key,
                  <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;임의의 키와 값을 조합한 클라이언트 프로퍼티을 이 컴퍼넌트에 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, javax.swing.KeyStroke, int)">registerKeyboardAction</A> </B>(<A HREF="../../java/awt/event/ActionListener.html" title="java.awt.event 안의 인터페이스">ActionListener</A> &nbsp;anAction,
                       <A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke,
                       int&nbsp;aCondition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메소드는 현재 사용되고 있지 않습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)">registerKeyboardAction</A> </B>(<A HREF="../../java/awt/event/ActionListener.html" title="java.awt.event 안의 인터페이스">ActionListener</A> &nbsp;anAction,
                       <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;aCommand,
                       <A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke,
                       int&nbsp;aCondition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메소드는 현재 사용되고 있지 않습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#removeAncestorListener(javax.swing.event.AncestorListener)">removeAncestorListener</A> </B>(<A HREF="../../javax/swing/event/AncestorListener.html" title="javax.swing.event 안의 인터페이스">AncestorListener</A> &nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>listener</code> 의 등록을 해제해, 그 청취자가 <code>AncestorEvent</code> 를 받지 않게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#removeNotify()">removeNotify</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트에 친컴퍼넌트가 없어진 것을, 이 컴퍼넌트에 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#removeVetoableChangeListener(java.beans.VetoableChangeListener)">removeVetoableChangeListener</A> </B>(<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 안의 인터페이스">VetoableChangeListener</A> &nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>VetoableChangeListener</code> 를 청취자 리스트로부터 삭제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#repaint(long, int, int, int, int)">repaint</A> </B>(long&nbsp;tm,
        int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트가 표시되고 있는 경우에, 지정된 영역을 더티 리젼 리스트에 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#repaint(java.awt.Rectangle)">repaint</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트가 표시되고 있는 경우에, 지정된 영역을 더티 리젼 리스트에 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#requestDefaultFocus()">requestDefaultFocus</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>1.4 이후는 <code>FocusTraversalPolicy.getDefaultComponent(Container). requestFocus()</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#requestFocus()">requestFocus</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Component</code> 가 입력초점을 취득하는 것을 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#requestFocus(boolean)">requestFocus</A> </B>(boolean&nbsp;temporary)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Component</code> 가 입력초점을 취득하는 것을 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#requestFocusInWindow()">requestFocusInWindow</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Component</code> 가 입력초점을 취득하는 것을 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#requestFocusInWindow(boolean)">requestFocusInWindow</A> </B>(boolean&nbsp;temporary)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Component</code> 가 입력초점을 취득하는 것을 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#resetKeyboardActions()">resetKeyboardActions</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 제 1 층의 <code>InputMap</code> 와 <code>ActionMap</code> 의 바인딩을 모두 등록 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#reshape(int, int, int, int)">reshape</A> </B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;w,
        int&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK 5 이후는,<code>Component.setBounds(int, int, int, int)</code> 로 옮겨졌습니다.

 <p>
이 컴퍼넌트를 이동해, 사이즈 변경합니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#revalidate()">revalidate</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지연 자동 레이아웃을 지원합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#scrollRectToVisible(java.awt.Rectangle)">scrollRectToVisible</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;aRect)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scrollRectToVisible()</code> 메세지를 <code>JComponent</code> 의 부모에게 전송 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setActionMap(javax.swing.ActionMap)">setActionMap</A> </B>(<A HREF="../../javax/swing/ActionMap.html" title="javax.swing 안의 클래스">ActionMap</A> &nbsp;am)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ActionMap</code> 를 <code>am</code> 로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setAlignmentX(float)">setAlignmentX</A> </B>(float&nbsp;alignmentX)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;수직의 배치 방법을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setAlignmentY(float)">setAlignmentY</A> </B>(float&nbsp;alignmentY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;수평의 배치 방법을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setAutoscrolls(boolean)">setAutoscrolls</A> </B>(boolean&nbsp;autoscrolls)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>autoscrolls</code> 프로퍼티을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setBackground(java.awt.Color)">setBackground</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 백그라운드 칼라를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setBorder(javax.swing.border.Border)">setBorder</A> </B>(<A HREF="../../javax/swing/border/Border.html" title="javax.swing.border 안의 인터페이스">Border</A> &nbsp;border)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 경계를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setComponentPopupMenu(javax.swing.JPopupMenu)">setComponentPopupMenu</A> </B>(<A HREF="../../javax/swing/JPopupMenu.html" title="javax.swing 안의 클래스">JPopupMenu</A> &nbsp;popup)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JComponent</code> 의 <code>JPopupMenu</code> 를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setDebugGraphicsOptions(int)">setDebugGraphicsOptions</A> </B>(int&nbsp;debugOptions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트, 또는 그 아이의 어떤 것인가로 실행되는 모든 그래픽 조작에 대한 진단 정보를 유효화 또는 무효화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setDefaultLocale(java.util.Locale)">setDefaultLocale</A> </B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 각 JComponent 의 로케일 프로퍼티을 생성시에 초기화하기 위해서 사용하는 디폴트 로케일을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setDoubleBuffered(boolean)">setDoubleBuffered</A> </B>(boolean&nbsp;aFlag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 버퍼를 사용해 페인트 할지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setEnabled(boolean)">setEnabled</A> </B>(boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 유효한지 어떤지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setFocusTraversalKeys(int, java.util.Set)">setFocusTraversalKeys</A> </B>(int&nbsp;id,
                      <A HREF="../../java/util/Set.html" title="java.util 안의 인터페이스">Set</A> &lt;?  extends <A HREF="../../java/awt/AWTKeyStroke.html" title="java.awt 내의 클래스">AWTKeyStroke</A> &gt;&nbsp;keystrokes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 지정된 traversal 조작에 대한 포커스 traversal 키를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setFont(java.awt.Font)">setFont</A> </B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 폰트를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setForeground(java.awt.Color)">setForeground</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;fg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 foreground 칼라를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setInheritsPopupMenu(boolean)">setInheritsPopupMenu</A> </B>(boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트에 <code>JPopupMenu</code> 를 할당할 수 있지 않은 경우에 <code>getComponentPopupMenu</code> 가 부모에게 위양 될지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setInputMap(int, javax.swing.InputMap)">setInputMap</A> </B>(int&nbsp;condition,
            <A HREF="../../javax/swing/InputMap.html" title="javax.swing 안의 클래스">InputMap</A> &nbsp;map)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;조건 <code>condition</code> 로 사용하는 <code>InputMap</code> 를 <code>map</code> 로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setInputVerifier(javax.swing.InputVerifier)">setInputVerifier</A> </B>(<A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 안의 클래스">InputVerifier</A> &nbsp;inputVerifier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 입력 검증자를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setMaximumSize(java.awt.Dimension)">setMaximumSize</A> </B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;maximumSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 최대 사이즈를 정수치로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setMinimumSize(java.awt.Dimension)">setMinimumSize</A> </B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;minimumSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 최소 사이즈를 정수치로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setNextFocusableComponent(java.awt.Component)">setNextFocusableComponent</A> </B>(<A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A> &nbsp;aComponent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK Version 1.4 이후는,<code>FocusTraversalPolicy</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setOpaque(boolean)">setOpaque</A> </B>(boolean&nbsp;isOpaque)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true 의 경우, 컴퍼넌트는 그 경계내의 모든 픽셀을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setPreferredSize(java.awt.Dimension)">setPreferredSize</A> </B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;preferredSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 적절한 사이즈를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setRequestFocusEnabled(boolean)">setRequestFocusEnabled</A> </B>(boolean&nbsp;requestFocusEnabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JComponent</code> 가 포커스를 취득할지 어떨지에 대한 힌트를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setToolTipText(java.lang.String)">setToolTipText</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;text)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;툴팁에 표시하는 텍스트를 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setTransferHandler(javax.swing.TransferHandler)">setTransferHandler</A> </B>(<A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 안의 클래스">TransferHandler</A> &nbsp;newHandler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>transferHandler</code> 프로퍼티을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setUI(javax.swing.plaf.ComponentUI)">setUI</A> </B>(<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스">ComponentUI</A> &nbsp;newUI)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 Look & Feel 의 위양을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setVerifyInputWhenFocusTarget(boolean)">setVerifyInputWhenFocusTarget</A> </B>(boolean&nbsp;verifyInputWhenFocusTarget)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 포커스를 요구하기 전에, 현재의 포커스를 가지는 컴퍼넌트에 입력 검증자를 호출할지 어떨지를 나타내는 값을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setVisible(boolean)">setVisible</A> </B>(boolean&nbsp;aFlag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트를 가시 또는 불가시로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#unregisterKeyboardAction(javax.swing.KeyStroke)">unregisterKeyboardAction</A> </B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메소드는 현재 사용되고 있지 않습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#update(java.awt.Graphics)">update</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>paint</code> 를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#updateUI()">updateUI</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 Look & Feel 로부터의 값에 UI 프로퍼티을 리셋 합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Container"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Container.html" title="java.awt 안의 클래스">Container</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Container.html#add(java.awt.Component)">add</A> , <A HREF="../../java/awt/Container.html#add(java.awt.Component, int)">add</A> , <A HREF="../../java/awt/Container.html#add(java.awt.Component, java.lang.Object)">add</A> , <A HREF="../../java/awt/Container.html#add(java.awt.Component, java.lang.Object, int)">add</A> , <A HREF="../../java/awt/Container.html#add(java.lang.String, java.awt.Component)">add</A> , <A HREF="../../java/awt/Container.html#addContainerListener(java.awt.event.ContainerListener)">addContainerListener</A> , <A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)">addImpl</A> , <A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.beans.PropertyChangeListener)">addPropertyChangeListener</A> , <A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">addPropertyChangeListener</A> , <A HREF="../../java/awt/Container.html#applyComponentOrientation(java.awt.ComponentOrientation)">applyComponentOrientation</A> , <A HREF="../../java/awt/Container.html#areFocusTraversalKeysSet(int)">areFocusTraversalKeysSet</A> , <A HREF="../../java/awt/Container.html#countComponents()">countComponents</A> , <A HREF="../../java/awt/Container.html#deliverEvent(java.awt.Event)">deliverEvent</A> , <A HREF="../../java/awt/Container.html#doLayout()">doLayout</A> , <A HREF="../../java/awt/Container.html#findComponentAt(int, int)">findComponentAt</A> , <A HREF="../../java/awt/Container.html#findComponentAt(java.awt.Point)">findComponentAt</A> , <A HREF="../../java/awt/Container.html#getComponent(int)">getComponent</A> , <A HREF="../../java/awt/Container.html#getComponentAt(int, int)">getComponentAt</A> , <A HREF="../../java/awt/Container.html#getComponentAt(java.awt.Point)">getComponentAt</A> , <A HREF="../../java/awt/Container.html#getComponentCount()">getComponentCount</A> , <A HREF="../../java/awt/Container.html#getComponents()">getComponents</A> , <A HREF="../../java/awt/Container.html#getComponentZOrder(java.awt.Component)">getComponentZOrder</A> , <A HREF="../../java/awt/Container.html#getContainerListeners()">getContainerListeners</A> , <A HREF="../../java/awt/Container.html#getFocusTraversalKeys(int)">getFocusTraversalKeys</A> , <A HREF="../../java/awt/Container.html#getFocusTraversalPolicy()">getFocusTraversalPolicy</A> , <A HREF="../../java/awt/Container.html#getLayout()">getLayout</A> , <A HREF="../../java/awt/Container.html#getMousePosition(boolean)">getMousePosition</A> , <A HREF="../../java/awt/Container.html#insets()">insets</A> , <A HREF="../../java/awt/Container.html#invalidate()">invalidate</A> , <A HREF="../../java/awt/Container.html#isAncestorOf(java.awt.Component)">isAncestorOf</A> , <A HREF="../../java/awt/Container.html#isFocusCycleRoot()">isFocusCycleRoot</A> , <A HREF="../../java/awt/Container.html#isFocusCycleRoot(java.awt.Container)">isFocusCycleRoot</A> , <A HREF="../../java/awt/Container.html#isFocusTraversalPolicyProvider()">isFocusTraversalPolicyProvider</A> , <A HREF="../../java/awt/Container.html#isFocusTraversalPolicySet()">isFocusTraversalPolicySet</A> , <A HREF="../../java/awt/Container.html#layout()">layout</A> , <A HREF="../../java/awt/Container.html#list(java.io.PrintStream, int)">list</A> , <A HREF="../../java/awt/Container.html#list(java.io.PrintWriter, int)">list</A> , <A HREF="../../java/awt/Container.html#locate(int, int)">locate</A> , <A HREF="../../java/awt/Container.html#minimumSize()">minimumSize</A> , <A HREF="../../java/awt/Container.html#paintComponents(java.awt.Graphics)">paintComponents</A> , <A HREF="../../java/awt/Container.html#preferredSize()">preferredSize</A> , <A HREF="../../java/awt/Container.html#printComponents(java.awt.Graphics)">printComponents</A> , <A HREF="../../java/awt/Container.html#processContainerEvent(java.awt.event.ContainerEvent)">processContainerEvent</A> , <A HREF="../../java/awt/Container.html#processEvent(java.awt.AWTEvent)">processEvent</A> , <A HREF="../../java/awt/Container.html#remove(java.awt.Component)">remove</A> , <A HREF="../../java/awt/Container.html#remove(int)">remove</A> , <A HREF="../../java/awt/Container.html#removeAll()">removeAll</A> , <A HREF="../../java/awt/Container.html#removeContainerListener(java.awt.event.ContainerListener)">removeContainerListener</A> , <A HREF="../../java/awt/Container.html#setComponentZOrder(java.awt.Component, int)">setComponentZOrder</A> , <A HREF="../../java/awt/Container.html#setFocusCycleRoot(boolean)">setFocusCycleRoot</A> , <A HREF="../../java/awt/Container.html#setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)">setFocusTraversalPolicy</A> , <A HREF="../../java/awt/Container.html#setFocusTraversalPolicyProvider(boolean)">setFocusTraversalPolicyProvider</A> , <A HREF="../../java/awt/Container.html#setLayout(java.awt.LayoutManager)">setLayout</A> , <A HREF="../../java/awt/Container.html#transferFocusBackward()">transferFocusBackward</A> , <A HREF="../../java/awt/Container.html#transferFocusDownCycle()">transferFocusDownCycle</A> , <A HREF="../../java/awt/Container.html#validate()">validate</A> , <A HREF="../../java/awt/Container.html#validateTree()">validateTree</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Component"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.html#action(java.awt.Event, java.lang.Object)">action</A> , <A HREF="../../java/awt/Component.html#add(java.awt.PopupMenu)">add</A> , <A HREF="../../java/awt/Component.html#addComponentListener(java.awt.event.ComponentListener)">addComponentListener</A> , <A HREF="../../java/awt/Component.html#addFocusListener(java.awt.event.FocusListener)">addFocusListener</A> , <A HREF="../../java/awt/Component.html#addHierarchyBoundsListener(java.awt.event.HierarchyBoundsListener)">addHierarchyBoundsListener</A> , <A HREF="../../java/awt/Component.html#addHierarchyListener(java.awt.event.HierarchyListener)">addHierarchyListener</A> , <A HREF="../../java/awt/Component.html#addInputMethodListener(java.awt.event.InputMethodListener)">addInputMethodListener</A> , <A HREF="../../java/awt/Component.html#addKeyListener(java.awt.event.KeyListener)">addKeyListener</A> , <A HREF="../../java/awt/Component.html#addMouseListener(java.awt.event.MouseListener)">addMouseListener</A> , <A HREF="../../java/awt/Component.html#addMouseMotionListener(java.awt.event.MouseMotionListener)">addMouseMotionListener</A> , <A HREF="../../java/awt/Component.html#addMouseWheelListener(java.awt.event.MouseWheelListener)">addMouseWheelListener</A> , <A HREF="../../java/awt/Component.html#bounds()">bounds</A> , <A HREF="../../java/awt/Component.html#checkImage(java.awt.Image, java.awt.image.ImageObserver)">checkImage</A> , <A HREF="../../java/awt/Component.html#checkImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">checkImage</A> , <A HREF="../../java/awt/Component.html#coalesceEvents(java.awt.AWTEvent, java.awt.AWTEvent)">coalesceEvents</A> , <A HREF="../../java/awt/Component.html#contains(java.awt.Point)">contains</A> , <A HREF="../../java/awt/Component.html#createImage(java.awt.image.ImageProducer)">createImage</A> , <A HREF="../../java/awt/Component.html#createImage(int, int)">createImage</A> , <A HREF="../../java/awt/Component.html#createVolatileImage(int, int)">createVolatileImage</A> , <A HREF="../../java/awt/Component.html#createVolatileImage(int, int, java.awt.ImageCapabilities)">createVolatileImage</A> , <A HREF="../../java/awt/Component.html#disableEvents(long)">disableEvents</A> , <A HREF="../../java/awt/Component.html#dispatchEvent(java.awt.AWTEvent)">dispatchEvent</A> , <A HREF="../../java/awt/Component.html#enable(boolean)">enable</A> , <A HREF="../../java/awt/Component.html#enableEvents(long)">enableEvents</A> , <A HREF="../../java/awt/Component.html#enableInputMethods(boolean)">enableInputMethods</A> , <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, byte, byte)">firePropertyChange</A> , <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, double, double)">firePropertyChange</A> , <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, float, float)">firePropertyChange</A> , <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, long, long)">firePropertyChange</A> , <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, java.lang.Object, java.lang.Object)">firePropertyChange</A> , <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, short, short)">firePropertyChange</A> , <A HREF="../../java/awt/Component.html#getBackground()">getBackground</A> , <A HREF="../../java/awt/Component.html#getBounds()">getBounds</A> , <A HREF="../../java/awt/Component.html#getColorModel()">getColorModel</A> , <A HREF="../../java/awt/Component.html#getComponentListeners()">getComponentListeners</A> , <A HREF="../../java/awt/Component.html#getComponentOrientation()">getComponentOrientation</A> , <A HREF="../../java/awt/Component.html#getCursor()">getCursor</A> , <A HREF="../../java/awt/Component.html#getDropTarget()">getDropTarget</A> , <A HREF="../../java/awt/Component.html#getFocusCycleRootAncestor()">getFocusCycleRootAncestor</A> , <A HREF="../../java/awt/Component.html#getFocusListeners()">getFocusListeners</A> , <A HREF="../../java/awt/Component.html#getFocusTraversalKeysEnabled()">getFocusTraversalKeysEnabled</A> , <A HREF="../../java/awt/Component.html#getFont()">getFont</A> , <A HREF="../../java/awt/Component.html#getForeground()">getForeground</A> , <A HREF="../../java/awt/Component.html#getGraphicsConfiguration()">getGraphicsConfiguration</A> , <A HREF="../../java/awt/Component.html#getHierarchyBoundsListeners()">getHierarchyBoundsListeners</A> , <A HREF="../../java/awt/Component.html#getHierarchyListeners()">getHierarchyListeners</A> , <A HREF="../../java/awt/Component.html#getIgnoreRepaint()">getIgnoreRepaint</A> , <A HREF="../../java/awt/Component.html#getInputContext()">getInputContext</A> , <A HREF="../../java/awt/Component.html#getInputMethodListeners()">getInputMethodListeners</A> , <A HREF="../../java/awt/Component.html#getInputMethodRequests()">getInputMethodRequests</A> , <A HREF="../../java/awt/Component.html#getKeyListeners()">getKeyListeners</A> , <A HREF="../../java/awt/Component.html#getLocale()">getLocale</A> , <A HREF="../../java/awt/Component.html#getLocation()">getLocation</A> , <A HREF="../../java/awt/Component.html#getLocationOnScreen()">getLocationOnScreen</A> , <A HREF="../../java/awt/Component.html#getMouseListeners()">getMouseListeners</A> , <A HREF="../../java/awt/Component.html#getMouseMotionListeners()">getMouseMotionListeners</A> , <A HREF="../../java/awt/Component.html#getMousePosition()">getMousePosition</A> , <A HREF="../../java/awt/Component.html#getMouseWheelListeners()">getMouseWheelListeners</A> , <A HREF="../../java/awt/Component.html#getName()">getName</A> , <A HREF="../../java/awt/Component.html#getParent()">getParent</A> , <A HREF="../../java/awt/Component.html#getPeer()">getPeer</A> , <A HREF="../../java/awt/Component.html#getPropertyChangeListeners()">getPropertyChangeListeners</A> , <A HREF="../../java/awt/Component.html#getPropertyChangeListeners(java.lang.String)">getPropertyChangeListeners</A> , <A HREF="../../java/awt/Component.html#getSize()">getSize</A> , <A HREF="../../java/awt/Component.html#getToolkit()">getToolkit</A> , <A HREF="../../java/awt/Component.html#getTreeLock()">getTreeLock</A> , <A HREF="../../java/awt/Component.html#gotFocus(java.awt.Event, java.lang.Object)">gotFocus</A> , <A HREF="../../java/awt/Component.html#handleEvent(java.awt.Event)">handleEvent</A> , <A HREF="../../java/awt/Component.html#hasFocus()">hasFocus</A> , <A HREF="../../java/awt/Component.html#hide()">hide</A> , <A HREF="../../java/awt/Component.html#imageUpdate(java.awt.Image, int, int, int, int, int)">imageUpdate</A> , <A HREF="../../java/awt/Component.html#inside(int, int)">inside</A> , <A HREF="../../java/awt/Component.html#isBackgroundSet()">isBackgroundSet</A> , <A HREF="../../java/awt/Component.html#isCursorSet()">isCursorSet</A> , <A HREF="../../java/awt/Component.html#isDisplayable()">isDisplayable</A> , <A HREF="../../java/awt/Component.html#isEnabled()">isEnabled</A> , <A HREF="../../java/awt/Component.html#isFocusable()">isFocusable</A> , <A HREF="../../java/awt/Component.html#isFocusOwner()">isFocusOwner</A> , <A HREF="../../java/awt/Component.html#isFocusTraversable()">isFocusTraversable</A> , <A HREF="../../java/awt/Component.html#isFontSet()">isFontSet</A> , <A HREF="../../java/awt/Component.html#isForegroundSet()">isForegroundSet</A> , <A HREF="../../java/awt/Component.html#isLightweight()">isLightweight</A> , <A HREF="../../java/awt/Component.html#isMaximumSizeSet()">isMaximumSizeSet</A> , <A HREF="../../java/awt/Component.html#isMinimumSizeSet()">isMinimumSizeSet</A> , <A HREF="../../java/awt/Component.html#isPreferredSizeSet()">isPreferredSizeSet</A> , <A HREF="../../java/awt/Component.html#isShowing()">isShowing</A> , <A HREF="../../java/awt/Component.html#isValid()">isValid</A> , <A HREF="../../java/awt/Component.html#isVisible()">isVisible</A> , <A HREF="../../java/awt/Component.html#keyDown(java.awt.Event, int)">keyDown</A> , <A HREF="../../java/awt/Component.html#keyUp(java.awt.Event, int)">keyUp</A> , <A HREF="../../java/awt/Component.html#list()">list</A> , <A HREF="../../java/awt/Component.html#list(java.io.PrintStream)">list</A> , <A HREF="../../java/awt/Component.html#list(java.io.PrintWriter)">list</A> , <A HREF="../../java/awt/Component.html#location()">location</A> , <A HREF="../../java/awt/Component.html#lostFocus(java.awt.Event, java.lang.Object)">lostFocus</A> , <A HREF="../../java/awt/Component.html#mouseDown(java.awt.Event, int, int)">mouseDown</A> , <A HREF="../../java/awt/Component.html#mouseDrag(java.awt.Event, int, int)">mouseDrag</A> , <A HREF="../../java/awt/Component.html#mouseEnter(java.awt.Event, int, int)">mouseEnter</A> , <A HREF="../../java/awt/Component.html#mouseExit(java.awt.Event, int, int)">mouseExit</A> , <A HREF="../../java/awt/Component.html#mouseMove(java.awt.Event, int, int)">mouseMove</A> , <A HREF="../../java/awt/Component.html#mouseUp(java.awt.Event, int, int)">mouseUp</A> , <A HREF="../../java/awt/Component.html#move(int, int)">move</A> , <A HREF="../../java/awt/Component.html#nextFocus()">nextFocus</A> , <A HREF="../../java/awt/Component.html#paintAll(java.awt.Graphics)">paintAll</A> , <A HREF="../../java/awt/Component.html#postEvent(java.awt.Event)">postEvent</A> , <A HREF="../../java/awt/Component.html#prepareImage(java.awt.Image, java.awt.image.ImageObserver)">prepareImage</A> , <A HREF="../../java/awt/Component.html#prepareImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">prepareImage</A> , <A HREF="../../java/awt/Component.html#processComponentEvent(java.awt.event.ComponentEvent)">processComponentEvent</A> , <A HREF="../../java/awt/Component.html#processFocusEvent(java.awt.event.FocusEvent)">processFocusEvent</A> , <A HREF="../../java/awt/Component.html#processHierarchyBoundsEvent(java.awt.event.HierarchyEvent)">processHierarchyBoundsEvent</A> , <A HREF="../../java/awt/Component.html#processHierarchyEvent(java.awt.event.HierarchyEvent)">processHierarchyEvent</A> , <A HREF="../../java/awt/Component.html#processInputMethodEvent(java.awt.event.InputMethodEvent)">processInputMethodEvent</A> , <A HREF="../../java/awt/Component.html#processMouseWheelEvent(java.awt.event.MouseWheelEvent)">processMouseWheelEvent</A> , <A HREF="../../java/awt/Component.html#remove(java.awt.MenuComponent)">remove</A> , <A HREF="../../java/awt/Component.html#removeComponentListener(java.awt.event.ComponentListener)">removeComponentListener</A> , <A HREF="../../java/awt/Component.html#removeFocusListener(java.awt.event.FocusListener)">removeFocusListener</A> , <A HREF="../../java/awt/Component.html#removeHierarchyBoundsListener(java.awt.event.HierarchyBoundsListener)">removeHierarchyBoundsListener</A> , <A HREF="../../java/awt/Component.html#removeHierarchyListener(java.awt.event.HierarchyListener)">removeHierarchyListener</A> , <A HREF="../../java/awt/Component.html#removeInputMethodListener(java.awt.event.InputMethodListener)">removeInputMethodListener</A> , <A HREF="../../java/awt/Component.html#removeKeyListener(java.awt.event.KeyListener)">removeKeyListener</A> , <A HREF="../../java/awt/Component.html#removeMouseListener(java.awt.event.MouseListener)">removeMouseListener</A> , <A HREF="../../java/awt/Component.html#removeMouseMotionListener(java.awt.event.MouseMotionListener)">removeMouseMotionListener</A> , <A HREF="../../java/awt/Component.html#removeMouseWheelListener(java.awt.event.MouseWheelListener)">removeMouseWheelListener</A> , <A HREF="../../java/awt/Component.html#removePropertyChangeListener(java.beans.PropertyChangeListener)">removePropertyChangeListener</A> , <A HREF="../../java/awt/Component.html#removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">removePropertyChangeListener</A> , <A HREF="../../java/awt/Component.html#repaint()">repaint</A> , <A HREF="../../java/awt/Component.html#repaint(int, int, int, int)">repaint</A> , <A HREF="../../java/awt/Component.html#repaint(long)">repaint</A> , <A HREF="../../java/awt/Component.html#resize(java.awt.Dimension)">resize</A> , <A HREF="../../java/awt/Component.html#resize(int, int)">resize</A> , <A HREF="../../java/awt/Component.html#setBounds(int, int, int, int)">setBounds</A> , <A HREF="../../java/awt/Component.html#setBounds(java.awt.Rectangle)">setBounds</A> , <A HREF="../../java/awt/Component.html#setComponentOrientation(java.awt.ComponentOrientation)">setComponentOrientation</A> , <A HREF="../../java/awt/Component.html#setCursor(java.awt.Cursor)">setCursor</A> , <A HREF="../../java/awt/Component.html#setDropTarget(java.awt.dnd.DropTarget)">setDropTarget</A> , <A HREF="../../java/awt/Component.html#setFocusable(boolean)">setFocusable</A> , <A HREF="../../java/awt/Component.html#setFocusTraversalKeysEnabled(boolean)">setFocusTraversalKeysEnabled</A> , <A HREF="../../java/awt/Component.html#setIgnoreRepaint(boolean)">setIgnoreRepaint</A> , <A HREF="../../java/awt/Component.html#setLocale(java.util.Locale)">setLocale</A> , <A HREF="../../java/awt/Component.html#setLocation(int, int)">setLocation</A> , <A HREF="../../java/awt/Component.html#setLocation(java.awt.Point)">setLocation</A> , <A HREF="../../java/awt/Component.html#setName(java.lang.String)">setName</A> , <A HREF="../../java/awt/Component.html#setSize(java.awt.Dimension)">setSize</A> , <A HREF="../../java/awt/Component.html#setSize(int, int)">setSize</A> , <A HREF="../../java/awt/Component.html#show()">show</A> , <A HREF="../../java/awt/Component.html#show(boolean)">show</A> , <A HREF="../../java/awt/Component.html#size()">size</A> , <A HREF="../../java/awt/Component.html#toString()">toString</A> , <A HREF="../../java/awt/Component.html#transferFocus()">transferFocus</A> , <A HREF="../../java/awt/Component.html#transferFocusUpCycle()">transferFocusUpCycle</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ui"><!-- --></A> <H3>
ui</H3>
<PRE>
protected transient <A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 내의 클래스">ComponentUI</A>  <B>ui</B></PRE>
<DL>
<DD>이 컴퍼넌트의 Look & Feel 위양입니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="listenerList"><!-- --></A> <H3>
listenerList</H3>
<PRE>
protected <A HREF="../../javax/swing/event/EventListenerList.html" title="javax.swing.event 내의 클래스">EventListenerList</A>  <B>listenerList</B></PRE>
<DL>
<DD>이 컴퍼넌트의 이벤트 청취자 리스트입니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="WHEN_FOCUSED"><!-- --></A> <H3>
WHEN_FOCUSED</H3>
<PRE>
public static final int <B>WHEN_FOCUSED</B></PRE>
<DL>
<DD><code>registerKeyboardAction</code> 로 사용되는 정수입니다. 컴퍼넌트에 포커스가 설정되었을 때에 커멘드를 호출하는 것을 나타냅니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JComponent.WHEN_FOCUSED">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="WHEN_ANCESTOR_OF_FOCUSED_COMPONENT"><!-- --></A> <H3>
WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</H3>
<PRE>
public static final int <B>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</B></PRE>
<DL>
<DD><code>registerKeyboardAction()</code> 로 사용되는 정수입니다. 수신측 컴퍼넌트가 포커스를 가지는 컴퍼넌트의 상위인지, 그 자체가 포커스를 가지는 컴퍼넌트인 경우에, 커멘드를 호출하는 것을 나타냅니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="WHEN_IN_FOCUSED_WINDOW"><!-- --></A> <H3>
WHEN_IN_FOCUSED_WINDOW</H3>
<PRE>
public static final int <B>WHEN_IN_FOCUSED_WINDOW</B></PRE>
<DL>
<DD><code>registerKeyboardAction()</code> 로 사용되는 정수입니다. 수신측 컴퍼넌트가 포커스를 가지는 윈도우내에 있는지, 그 자체가 포커스를 가지는 컴퍼넌트인 경우에, 커멘드를 호출하는 것을 나타냅니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JComponent.WHEN_IN_FOCUSED_WINDOW">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="UNDEFINED_CONDITION"><!-- --></A> <H3>
UNDEFINED_CONDITION</H3>
<PRE>
public static final int <B>UNDEFINED_CONDITION</B></PRE>
<DL>
<DD>몇개의 API 로 사용되는 정수입니다. 조건이 정의되어 있지 않은 것을 나타냅니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JComponent.UNDEFINED_CONDITION">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TOOL_TIP_TEXT_KEY"><!-- --></A> <H3>
TOOL_TIP_TEXT_KEY</H3>
<PRE>
public static final <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>TOOL_TIP_TEXT_KEY</B></PRE>
<DL>
<DD>커서가 컴퍼넌트상에 있을 때 표시되는 코멘트입니다. 「값힌트」, 「부유 헬프」, 또는 「부유 라벨」이라고도 불립니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JComponent.TOOL_TIP_TEXT_KEY">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="accessibleContext"><!-- --></A> <H3>
accessibleContext</H3>
<PRE>
protected <A HREF="../../javax/accessibility/AccessibleContext.html" title="javax.accessibility 내의 클래스">AccessibleContext</A>  <B>accessibleContext</B></PRE>
<DL>
<DD>이 <code>JComponent</code> 에 관련지을 수 있었던 <code>AccessibleContext</code> 입니다.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="JComponent()"><!-- --></A> <H3>
JComponent</H3>
<PRE>
public <B>JComponent</B>()</PRE>
<DL>
<DD>디폴트의 <code>JComponent</code> 생성자 입니다. 이 생성자 에서는,<code>Container</code> 생성자  호출전의 초기화는 거의 실행되지 않습니다. 예를 들어 초기 레이아웃 매니저는 <code>null</code> 입니다. 컴퍼넌트의 로케일 프로퍼티은 <code>JComponent.getDefaultLocale</code> 로 반환된 값으로 설정합니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getDefaultLocale()"><CODE>getDefaultLocale()</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setInheritsPopupMenu(boolean)"><!-- --></A> <H3>
setInheritsPopupMenu</H3>
<PRE>
public void <B>setInheritsPopupMenu</B>(boolean&nbsp;value)</PRE>
<DL>
<DD>이 컴퍼넌트에 <code>JPopupMenu</code> 를 할당할 수 있지 않은 경우에 <code>getComponentPopupMenu</code> 가 부모에게 위양 될지 어떨지를 설정합니다.  &nbsp;<p>
이 메소드의 디폴트 값는 false 입니다만, 다수의 <code>JComponent</code> 로서 구현되는 일부의 <code>JComponent</code> 서브 클래스에서는 이 메소드를 true 로 설정합니다.  &nbsp;<p>
이것은 바운드 프로퍼티입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>value</CODE> - JPopupMenu 가 상속될지 어떨지<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setComponentPopupMenu(javax.swing.JPopupMenu)"><CODE>setComponentPopupMenu(javax.swing.JPopupMenu)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getInheritsPopupMenu()"><!-- --></A> <H3>
getInheritsPopupMenu</H3>
<PRE>
public boolean <B>getInheritsPopupMenu</B>()</PRE>
<DL>
<DD>JPopupMenu 가 부모로부터 상속될 것인 경우는 true 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setComponentPopupMenu(javax.swing.JPopupMenu)"><CODE>setComponentPopupMenu(javax.swing.JPopupMenu)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setComponentPopupMenu(javax.swing.JPopupMenu)"><!-- --></A> <H3>
setComponentPopupMenu</H3>
<PRE>
public void <B>setComponentPopupMenu</B>(<A HREF="../../javax/swing/JPopupMenu.html" title="javax.swing 안의 클래스">JPopupMenu</A> &nbsp;popup)</PRE>
<DL>
<DD>이 <code>JComponent</code> 의 <code>JPopupMenu</code> 를 설정합니다. 이 UI 는,<code>JPopupMenu</code> 가 적절한 타이밍에 표시되도록(듯이), 바인딩을 등록하거나 필요한 청취자를 추가하거나 합니다. <code>JPopupMenu</code> 가 언제 표시될까는, Look & Feel 에 따라서 달라, 마우스 이벤트로 표시되는 일도 있으면, 키 바인딩이 유효하게 될 수도 있습니다.  &nbsp;<p>
<code>popup</code> 가 null 로,<code>getInheritsPopupMenu</code> 가 true 를 돌려주는 경우는,<code>getComponentPopupMenu</code> 이 부모에게 위양 됩니다. 이것에 의해, 모든 아이 컴퍼넌트에 부모의 pop-up menu를 상속시킬 수가 있습니다.  &nbsp;<p>
이것은 바운드 프로퍼티입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>popup</CODE> - 이 컴퍼넌트에 할당할 수 있는 pop-up.  null 의 경우도 있는<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getComponentPopupMenu()"><CODE>getComponentPopupMenu()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getComponentPopupMenu()"><!-- --></A> <H3>
getComponentPopupMenu</H3>
<PRE>
public <A HREF="../../javax/swing/JPopupMenu.html" title="javax.swing 내의 클래스">JPopupMenu</A>  <B>getComponentPopupMenu</B>()</PRE>
<DL>
<DD>이 컴퍼넌트에 할당할 수 있었던 <code>JPopupMenu</code> 를 돌려줍니다. 이 컴퍼넌트에 <code>JPopupMenu</code> 를 할당할 수 있지 않고,<code>getInheritsPopupMenu</code> 가 true 의 경우는,<code>getParent(). getComponentPopupMenu()</code> 이 돌려주어집니다 (부모가 유효하다 것으로 한다).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트에 할당할 수 있었던 <code>JPopupMenu</code>,
pop-up를 할당할 수 있지 않은 경우는 <code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setComponentPopupMenu(javax.swing.JPopupMenu)"><CODE>setComponentPopupMenu(javax.swing.JPopupMenu)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="updateUI()"><!-- --></A> <H3>
updateUI</H3>
<PRE>
public void <B>updateUI</B>()</PRE>
<DL>
<DD>현재의 Look & Feel 로부터의 값에 UI 프로퍼티을 리셋 합니다. <code>JComponent</code> 의 서브 클래스는, 다음과 같이 이 메소드를 오버라이드(override) 할 필요가 있습니다.
 <pre>
   public void updateUI() {
      setUI((SliderUI) UIManager.getUI(this);
   }
  </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setUI(javax.swing.plaf.ComponentUI)"><CODE>setUI(javax.swing.plaf.ComponentUI)</CODE></A> , 
<A HREF="../../javax/swing/UIManager.html#getLookAndFeel()"><CODE>UIManager.getLookAndFeel()</CODE></A> , 
<A HREF="../../javax/swing/UIManager.html#getUI(javax.swing.JComponent)"><CODE>UIManager.getUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setUI(javax.swing.plaf.ComponentUI)"><!-- --></A> <H3>
setUI</H3>
<PRE>
protected void <B>setUI</B>(<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스">ComponentUI</A> &nbsp;newUI)</PRE>
<DL>
<DD>이 컴퍼넌트의 Look & Feel 의 위양을 설정합니다. 일반적으로,<code>JComponent</code> 의 서브 클래스는 이 메소드를 오버라이드(override) 해 인수의 형태를 네로우 변환할 필요가 있습니다. 다음에 <code>JSlider</code> 의 예를 나타냅니다.
 <pre>
 public void setUI(SliderUI newUI) {
     super.setUI(newUI);
 }
  </pre>
 <p>
또,<code>JComponent</code> 의 서브 클래스는 올바른 형태를 돌려주는 <code>getUI</code> 메소드를 제공할 필요가 있습니다. 다음에 예를 나타냅니다.
 <pre>
 public SliderUI getUI() {
     return (SliderUI) ui;
 }
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newUI</CODE> - 신규의 UI 위양<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#updateUI()"><CODE>updateUI()</CODE></A> , 
<A HREF="../../javax/swing/UIManager.html#getLookAndFeel()"><CODE>UIManager.getLookAndFeel()</CODE></A> , 
<A HREF="../../javax/swing/UIManager.html#getUI(javax.swing.JComponent)"><CODE>UIManager.getUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getUIClassID()"><!-- --></A> <H3>
getUIClassID</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getUIClassID</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 Look & Feel 를 정의하는 <code>swing.plaf.ComponentUI</code> 클래스의 이름을 검색하기 위해서 사용하는 <code>UIDefaults</code> 키를 돌려줍니다. 대부분의 어플리케이션은, 이 메소드를 호출할 필요는 없습니다. 플러그 인 가능한 Look & Feel 를 지원하는 <code>JComponent</code> 의 서브 클래스는, 이 메소드를 오버라이드(override) 해,<code>UIDefaults</code> 키를 돌려줍니다. 이 키는, Look & Feel 를 정의하는 <code>ComponentUI</code> 서브 클래스에 맵 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>ComponentUI</code> 서브 클래스의 <code>UIDefaults</code> 키<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/UIDefaults.html#getUI(javax.swing.JComponent)"><CODE>UIDefaults.getUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getComponentGraphics(java.awt.Graphics)"><!-- --></A> <H3>
getComponentGraphics</H3>
<PRE>
protected <A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A>  <B>getComponentGraphics</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>이 컴퍼넌트를 페인트 하기 위해서 사용되는 그래픽스 객체를 돌려줍니다. <code>DebugGraphics</code> 가 온의 경우, 필요한 때에 신규 <code>DebugGraphics</code> 객체를 생성합니다. 그렇지 않은 경우, 단순하게 지정된 그래픽스 객체의 foreground와 폰트를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 오리지날의 <code>Graphics</code> 객체
<DT><B>반환값:</B><DD>이 컴퍼넌트를 위해서(때문에) 설정된 <code>Graphics</code> 객체</DL>
</DD>
</DL>
<HR>

<A NAME="paintComponent(java.awt.Graphics)"><!-- --></A> <H3>
paintComponent</H3>
<PRE>
protected void <B>paintComponent</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>UI 위양이 <code>null</code> 가 아닌 경우에, UI 위양의 페인트 메소드를 호출합니다. 위양에는 <code>Graphics</code> 객체의 카피를 건네주어, 나머지의 페인트 코드에 대해서 취소할 수 없는 변경을 하지 않게 보호합니다 (예를 들어 <code>Graphics.translate</code> 등).  &nbsp;<p>
이 메소드를 서브 클래스에서 오버라이드(override) 하는 경우는, 건네받은 <code>Graphics</code> 의 객체에는 영속적인 변경은 실시하지 않게 합니다. 예를 들어 <code>Rectangle</code> 클립이나 변환은 변경하지 않습니다. 이러한 변경이 필요한 경우는, 건네받은 <code>Graphics</code> 로부터 새로운 <code>Graphics</code> 를 생성해, 그것을 변경하는 편이 용이합니다. 한층 더 상위 객체의 구현을 실시하지 않는 경우는, 불투명 프로퍼티에 주의할 필요가 있습니다. 즉 이 컴퍼넌트가 불투명한 경우는, 백그라운드에는 불투명하지 않은 색을 사용할 필요가 있습니다. 불투명 프로퍼티을 무시하면 화면이 보기 나뻐집니다.  &nbsp;<p>
건네받은 <code>Graphics</code> 객체에는, 인스톨 되고 있는 변환 이외의 변환이 포함되어 있는 일이 있습니다. 이 경우, 다른 변환을 누적적으로 적용하면(자), 예기치 않은 결과가 생길 가능성이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 보호 대상의 <code>Graphics</code> 객체<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#paint(java.awt.Graphics)"><CODE>paint(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="paintChildren(java.awt.Graphics)"><!-- --></A> <H3>
paintChildren</H3>
<PRE>
protected void <B>paintChildren</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>이 컴퍼넌트의 아이를 그립니다. <code>shouldUseBuffer</code> 가 true 의 경우, 컴퍼넌트의 상위 객체는 버퍼를 가지지 않고, 컴퍼넌트의 아이는 각각 독자적인 버퍼를 가질 때 버퍼를 사용할 수 있습니다. 그렇지 않은 경우, 상위 객체가 버퍼를 현재 사용중이며, 아이는 draw를 위한 버퍼를 사용할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 문맥<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#paint(java.awt.Graphics)"><CODE>paint(java.awt.Graphics)</CODE></A> , 
<A HREF="../../java/awt/Container.html#paint(java.awt.Graphics)"><CODE>Container.paint(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="paintBorder(java.awt.Graphics)"><!-- --></A> <H3>
paintBorder</H3>
<PRE>
protected void <B>paintBorder</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>컴퍼넌트의 경계를 그립니다.  &nbsp;<p>
이 메소드를 서브 클래스에서 오버라이드(override) 하는 경우는, 건네받은 <code>Graphics</code> 의 객체에는 영속적인 변경은 실시하지 않게 합니다. 예를 들어 <code>Rectangle</code> 클립이나 변환은 변경하지 않습니다. 이러한 변경이 필요한 경우는, 건네받은 <code>Graphics</code> 로부터 새로운 <code>Graphics</code> 를 생성해, 그것을 변경하는 편이 용이합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 문맥<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#paint(java.awt.Graphics)"><CODE>paint(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setBorder(javax.swing.border.Border)"><CODE>setBorder(javax.swing.border.Border)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="update(java.awt.Graphics)"><!-- --></A> <H3>
update</H3>
<PRE>
public void <B>update</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD><code>paint</code> 를 호출합니다. 백그라운드의 클리어는 실시하지 않고,<code>paintComponent</code> 에 의해 불려 가는 <code>ComponentUI.update</code> 를 참조합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#update(java.awt.Graphics)">update</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 문맥<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#paint(java.awt.Graphics)"><CODE>paint(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#paintComponent(java.awt.Graphics)"><CODE>paintComponent(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="paint(java.awt.Graphics)"><!-- --></A> <H3>
paint</H3>
<PRE>
public void <B>paint</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>이 메소드는 Swing 에 의해 불려 가 컴퍼넌트를 draw 합니다. 어플리케이션으로부터는 <code>paint</code> 를 직접 호출하지 않게 합니다. 대신에 <code>repaint</code> 메소드를 사용해 컴퍼넌트의 재draw를 스케줄 할 필요가 있습니다.  &nbsp;<p>
이 메소드는, 실제로는 페인트 작업을 3 개의 protected 메소드에 위양 합니다. 그것들은,<code>paintComponent</code>,<code>paintBorder</code>, 및 <code>paintChildren</code> 입니다. 이러한 메소드는, 여기에 늘어놓을 수 있었던 차례로 불려 가 아이가 컴퍼넌트상에 표시되도록(듯이) 합니다. 일반적으로, 컴퍼넌트와 그 아이는, 경계에 할당할 수 있었던 인 세트 영역에는 페인트 하지 않습니다. 서브 클래스는, 일반적으로대로 이 메소드를 오버라이드(override) 할 수 있습니다. UI (Look & Feel) 위양의 <code>paint</code> 메소드를 특수화 하는 서브 클래스는,<code>paintComponent</code> 를 오버라이드(override) 할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#paint(java.awt.Graphics)">paint</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 문맥<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#paintComponent(java.awt.Graphics)"><CODE>paintComponent(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#paintBorder(java.awt.Graphics)"><CODE>paintBorder(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#paintChildren(java.awt.Graphics)"><CODE>paintChildren(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#getComponentGraphics(java.awt.Graphics)"><CODE>getComponentGraphics(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#repaint(long, int, int, int, int)"><CODE>repaint(long, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="printAll(java.awt.Graphics)"><!-- --></A> <H3>
printAll</H3>
<PRE>
public void <B>printAll</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>컴퍼넌트를 인쇄하려면 , 이 메소드를 호출합니다. 이 메소드는 컴퍼넌트의 <code>print</code> 를 호출합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#printAll(java.awt.Graphics)">printAll</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 문맥<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#print(java.awt.Graphics)"><CODE>print(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#printComponent(java.awt.Graphics)"><CODE>printComponent(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#printBorder(java.awt.Graphics)"><CODE>printBorder(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#printChildren(java.awt.Graphics)"><CODE>printChildren(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="print(java.awt.Graphics)"><!-- --></A> <H3>
print</H3>
<PRE>
public void <B>print</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>컴퍼넌트를 지정의 <code>Graphics</code> 에 인쇄하려면 , 이 메소드를 호출합니다. 이 메소드는 <code>printComponent</code>,<code>printBorder</code> 및 <code>printChildren</code> 를 호출합니다. 인쇄의 외관을 커스터마이즈 하는 경우는, 이 메소드는 아니고, 전술의 메소드의 어느쪽이든을 오버라이드(override) 하는 것을 추천합니다. 다만, 슈퍼 클래스의 동작을 호출하기 전에 상태를 준비하는 경우는, 이 메소드를 오버라이드(override) 해도 괜찮습니다. 예를 들어, 인쇄전에 컴퍼넌트의 백그라운드의 색을 변경하는 경우는, 다음과 같이 지정할 수 있습니다.
 <pre>
     public void print(Graphics g) {
         Color orig = getBackground();
         setBackground(Color.WHITE);

         // wrap in try/finally so that we always restore the state
         try {
             super.print(g);
         } finally {
             setBackground(orig);
         }
     }
 </pre>
 <p>
또, 다른 객체에 페인트를 위양 하는 컴퍼넌트의 경우는, 컴퍼넌트가 인쇄 조작중일지 어떨지를 페인트중에 조회할 수 있습니다. 이 기능은,<code>isPaintingForPrint</code> 메소드가 제공합니다. 이 메소드에 의해, 반환값은 draw 직전에 <code>true</code>, draw 직후에 <code>false</code> 로 변경됩니다. 변경이 있을 때마다, 이 컴퍼넌트상에서,<code>paintingForPrint</code> 라는 이름으로 프로퍼티 변경 이벤트가 트리거됩니다.  &nbsp;<p>
이 메소드는, 더블 버퍼를 사용하지 않게 컴퍼넌트 상태를 설정합니다. 페인트는, 건네받은 <code>Graphics</code> 상에서 직접 실행됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#print(java.awt.Graphics)">print</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 문맥<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#printComponent(java.awt.Graphics)"><CODE>printComponent(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#printBorder(java.awt.Graphics)"><CODE>printBorder(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#printChildren(java.awt.Graphics)"><CODE>printChildren(java.awt.Graphics)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#isPaintingForPrint()"><CODE>isPaintingForPrint()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="printComponent(java.awt.Graphics)"><!-- --></A> <H3>
printComponent</H3>
<PRE>
protected void <B>printComponent</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>이 메소드는 인쇄 조작중에 불려 갑니다. 컴퍼넌트의 <code>paintComponent</code> 를 호출하기 위해서(때문에) 구현되고 있습니다. 인쇄시에 특정의 페인트 동작을 추가하는 경우는, 이 메소드를 오버라이드(override) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 문맥<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#print(java.awt.Graphics)"><CODE>print(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="printChildren(java.awt.Graphics)"><!-- --></A> <H3>
printChildren</H3>
<PRE>
protected void <B>printChildren</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>이 컴퍼넌트의 아이를 그립니다. 컴퍼넌트의 <code>paintChildren</code> 를 호출하기 위해서(때문에) 구현되고 있습니다. 페인트 하는 아이와는 다른 아이를 인쇄하는 경우는, 이 메소드를 오버라이드(override) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 문맥<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#print(java.awt.Graphics)"><CODE>print(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="printBorder(java.awt.Graphics)"><!-- --></A> <H3>
printBorder</H3>
<PRE>
protected void <B>printBorder</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>컴퍼넌트의 경계를 그립니다. 컴퍼넌트의 <code>paintBorder</code> 를 호출하기 위해서(때문에) 구현되고 있습니다. 페인트 하는 경계와는 다른 경계를 출력하고 싶을 때는, 이 메소드를 오버라이드(override) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 문맥<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#print(java.awt.Graphics)"><CODE>print(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isPaintingTile()"><!-- --></A> <H3>
isPaintingTile</H3>
<PRE>
public boolean <B>isPaintingTile</B>()</PRE>
<DL>
<DD>컴퍼넌트가 현재 타일을 페인트 하고 있는 경우에 true 를 돌려줍니다. 이 메소드가 true 를 돌려주는 경우, 다른 타일을 위해서(때문에) paint 가 다시 불려 갑니다. 이 메소드는, 타일을 페인트 하고 있지 않는 경우, 또는 마지막 타일이 페인트 되고 있는 경우에 false 를 돌려줍니다. 이 메소드를 사용하면(자), 타일의 사이에 필요할 가능성이 있는 몇개의 상태를 유지할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>컴퍼넌트가 현재 타일을 인쇄하고 있는 경우는 true, 그렇지 않은 경우는 false</DL>
</DD>
</DL>
<HR>

<A NAME="isPaintingForPrint()"><!-- --></A> <H3>
isPaintingForPrint</H3>
<PRE>
public final boolean <B>isPaintingForPrint</B>()</PRE>
<DL>
<DD>이 컴퍼넌트상의 현재의 페인트 조작이 다른 <code>print</code> 조작의 일부인 경우는 <code>true</code> 를 돌려줍니다. 이 메소드는, 인쇄 내용과 화면에 표시하는 내용을 커스터마이즈 하는 경우에 사용합니다.  &nbsp;<p>
이 프로퍼티의 값의 변화는, 이 컴퍼넌트상에서 <code>paintingForPrint</code> 라는 이름의 프로퍼티 변경 이벤트를 대기하는 것으로 검출할 수 있습니다.  &nbsp;<p>
주:이 메소드는, 다른 고레벨 Swing 인쇄 API 에 의해 제공되는 메소드에 대해서 추가 기능을 제공합니다. 다만, 엄밀하게 페인트만을 취급합니다. 보다 고레벨의 인쇄 프로세스에 관한 정보를 제공하는 것은 아닙니다. 예를 들어,<A HREF="../../javax/swing/JTable.html#print()"><CODE>JTable.print()</CODE></A>  조작을 실행해도, 컴퍼넌트 전체가 연속적으로 draw 되는 결과가 된다고는 할 수 없습니다. 이 메소드의 반환값은, 조작중으로 여러 차례 변경될 가능성이 있습니다. 인쇄 프로세스의 진행중에, 화면에 컴퍼넌트가 페인트 될 가능성도 있습니다. 이러한 경우로, 겉(표)가 인쇄 프로세스의 일부로서 페인트 되고 있을 때 한, 이 메소드의 반환값은 <code>true</code> 가 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트상의 현재의 페인트 조작이
다른 인쇄 조작의 일부인 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#print(java.awt.Graphics)"><CODE>print(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isManagingFocus()"><!-- --></A> <H3>
isManagingFocus</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public boolean <B>isManagingFocus</B>()</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>1.4 이후는 <code>Component.setFocusTraversalKeys(int, Set)</code> 와 <code>Container.setFocusCycleRoot(boolean)</code> 로 옮겨졌습니다. </I>
<P>
<DD>릴리스 1.4 에서는, 포커스 하부조직이 재구축 되었습니다. 상세한 것에 대하여는, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">「How to Use the Focus Subsystem」</a>를 참조해 주세요. <em></em> &nbsp;<p>
이 <code>JComponent</code> 의 포커스 traversal 키를 CTRL+TAB 와 CTRL+SHIFT+TAB 로 변경합니다. 또, 포커스 traversal 사이클 계산시에,<code>SortingFocusTraversalPolicy</code> 를 이 JComponent 의 하위 클래스라고 보지 않게 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#setFocusTraversalKeys(int, java.util.Set)"><CODE>Component.setFocusTraversalKeys(int, java.util.Set<?  extends java.awt.AWTKeyStroke>)</CODE></A> , 
<A HREF="../../javax/swing/SortingFocusTraversalPolicy.html" title="javax.swing 안의 클래스"><CODE>SortingFocusTraversalPolicy</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setNextFocusableComponent(java.awt.Component)"><!-- --></A> <H3>
setNextFocusableComponent</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public void <B>setNextFocusableComponent</B>(<A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A> &nbsp;aComponent)</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK Version 1.4 이후는,<code>FocusTraversalPolicy</code> 로 옮겨졌습니다. </I>
<P>
<DD>릴리스 1.4 에서는, 포커스 하부조직이 재구축 되었습니다. 상세한 것에 대하여는, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">「How to Use the Focus Subsystem」</a>를 참조해 주세요. <em></em> &nbsp;<p>
이 <code>JComponent</code> 의 포커스 traversal 사이클에 대한 디폴트의 <code>FocusTraversalPolicy</code> 를, 지정된 <code>Component</code> 를 사이클의 다음의 <code>Component</code> 로서 무조건 설정해, 오버라이드(override) 합니다. 이 <code>JComponent</code> 는, 사이클내의 지정된 <code>Component</code> 의 전의 <code>Component</code> 로서 설정됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aComponent</CODE> - 포커스 traversal 사이클내의 이 <code>JComponent</code>
에 따르는 <code>Component</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getNextFocusableComponent()"><CODE>getNextFocusableComponent()</CODE></A> , 
<A HREF="../../java/awt/FocusTraversalPolicy.html" title="java.awt 안의 클래스"><CODE>FocusTraversalPolicy</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getNextFocusableComponent()"><!-- --></A> <H3>
getNextFocusableComponent</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public <A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A>  <B>getNextFocusableComponent</B>()</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK Version 1.4 이후는,<code>FocusTraversalPolicy</code> 로 옮겨졌습니다. </I>
<P>
<DD>릴리스 1.4 에서는, 포커스 하부조직이 재구축 되었습니다. 상세한 것에 대하여는, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">「How to Use the Focus Subsystem」</a>를 참조해 주세요. <em></em> &nbsp;<p>
전의 호출로, 이 <code>JComponent</code> 의 <code>setNextFocusableComponent(Component)</code> 로 설정된 <code>Component</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>포커스 traversal 사이클내의 이 <code>JComponent</code>
에 따르는 <code>Component</code>, 명시적으로 지정되고 있는 것이
없는 경우는 <code>null</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setNextFocusableComponent(java.awt.Component)"><CODE>setNextFocusableComponent(java.awt.Component)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRequestFocusEnabled(boolean)"><!-- --></A> <H3>
setRequestFocusEnabled</H3>
<PRE>
public void <B>setRequestFocusEnabled</B>(boolean&nbsp;requestFocusEnabled)</PRE>
<DL>
<DD>이 <code>JComponent</code> 가 포커스를 취득할지 어떨지에 대한 힌트를 제공합니다. 단순한 힌트이며, 이 프로퍼티을 고려해 포커스를 요구할지 어떨지는 컨슈머(consumer)측에서 결정합니다. 이것은 주로 마우스 조작으로 고려되어 키보드 조작에서는 그다지 고려되지 않습니다. 예를 들어 Look & Feel 는, 마우스 조작의 포커스 요구전에, 이 프로퍼티이 true 화도인지를 확인할 수 있습니다. <code>JComponent</code> 상에서의 마우스 클릭으로 포커스를 취득시키지 않고 , 키보드로 <code>JComponent</code> 의 횡단(traverse)을 가능하게 하는 경우에 사용됩니다. 이 <code>JComponent</code> 에 대해서 전혀 포커스를 설정하지 않게 하기 위해서는,<code>setFocusable</code> 메소드를 사용합니다.  &nbsp;<p>
상세한 것에 대하여는, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html"> 「How to Use the Focus Subsystem」</a>를 참조해 주세요. <em></em>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>requestFocusEnabled</CODE> - 이 <code>JComponent</code> 에
포커스를 설정 가능하게 할지 어떨지를 나타내는<DT><B>관련 항목:</B><DD><a href="../../java/awt/doc-files/FocusSpec.html">Focus Specification</a> , 
<A HREF="../../java/awt/Component.html#setFocusable(boolean)"><CODE>Component.setFocusable(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isRequestFocusEnabled()"><!-- --></A> <H3>
isRequestFocusEnabled</H3>
<PRE>
public boolean <B>isRequestFocusEnabled</B>()</PRE>
<DL>
<DD>이 <code>JComponent</code> 가 포커스를 취득하는 경우는 <code>true</code> 를 돌려주어, 그렇지 않은 경우는 <code>false</code> 를 돌려줍니다.  &nbsp;<p>
상세한 것에 대하여는, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html"> 「How to Use the Focus Subsystem」</a>를 참조해 주세요. <em></em>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트가 포커스를 취득하는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setRequestFocusEnabled(boolean)"><CODE>setRequestFocusEnabled(boolean)</CODE></A> , 
<a href="../../java/awt/doc-files/FocusSpec.html">Focus Specification</a> , 
<A HREF="../../java/awt/Component.html#isFocusable()"><CODE>Component.isFocusable()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestFocus()"><!-- --></A> <H3>
requestFocus</H3>
<PRE>
public void <B>requestFocus</B>()</PRE>
<DL>
<DD>이 <code>Component</code> 가 입력초점을 취득하는 것을 요구합니다. 이 메소드의 상세한 것에 대하여는,<A HREF="../../java/awt/Component.html#requestFocus()"><CODE>Component.requestFocus()</CODE></A>  를 참조해 주세요.  &nbsp;<p>
이 메소드의 동작은 플랫폼에 의존하고 있기 (위해)때문에, 이 메소드를 사용하는 것은 추천 되지 않습니다. 대신에 <A HREF="../../javax/swing/JComponent.html#requestFocusInWindow()"><CODE>requestFocusInWindow()</CODE></A>  를 사용하는 것을 추천합니다. 포커스의 상세한 것에 대하여는, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html"> 「How to Use the Focus Subsystem」</a>를 참조해 주세요. <em></em>
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#requestFocus()">requestFocus</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A> , 
<A HREF="../../java/awt/Component.html#requestFocusInWindow(boolean)"><CODE>Component.requestFocusInWindow(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestFocus(boolean)"><!-- --></A> <H3>
requestFocus</H3>
<PRE>
public boolean <B>requestFocus</B>(boolean&nbsp;temporary)</PRE>
<DL>
<DD>이 <code>Component</code> 가 입력초점을 취득하는 것을 요구합니다. 이 메소드의 상세한 것에 대하여는,<A HREF="../../java/awt/Component.html#requestFocus(boolean)"><CODE>Component.requestFocus(boolean)</CODE></A>  를 참조해 주세요.  &nbsp;<p>
이 메소드의 동작은 플랫폼에 의존하고 있기 (위해)때문에, 이 메소드를 사용하는 것은 추천 되지 않습니다. 대신에 <A HREF="../../javax/swing/JComponent.html#requestFocusInWindow(boolean)"><CODE>requestFocusInWindow(boolean)</CODE></A>  를 사용하는 것을 추천합니다. 포커스의 상세한 것에 대하여는, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html"> 「How to Use the Focus Subsystem」</a>를 참조해 주세요. <em></em>
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#requestFocus(boolean)">requestFocus</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>temporary</CODE> - 포커스의 변경이 일시적인 것인가 어떤가를 나타내는 boolean 치
<DT><B>반환값:</B><DD>포커스 변경 요구가 확실히 에러가 되는 경우는 <code>false</code>,
성공할 가능성이 있는 경우는 <code>true</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A> , 
<A HREF="../../java/awt/Component.html#requestFocusInWindow(boolean)"><CODE>Component.requestFocusInWindow(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestFocusInWindow()"><!-- --></A> <H3>
requestFocusInWindow</H3>
<PRE>
public boolean <B>requestFocusInWindow</B>()</PRE>
<DL>
<DD>이 <code>Component</code> 가 입력초점을 취득하는 것을 요구합니다. 이 메소드의 상세한 것에 대하여는,<A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A>  를 참조해 주세요.  &nbsp;<p>
포커스의 상세한 것에 대하여는, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html"> 「How to Use the Focus Subsystem」</a>를 참조해 주세요. <em></em>
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#requestFocusInWindow()">requestFocusInWindow</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>포커스 변경 요구가 확실히 에러가 되는 경우는 <code>false</code>,
성공할 가능성이 있는 경우는 <code>true</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A> , 
<A HREF="../../java/awt/Component.html#requestFocusInWindow(boolean)"><CODE>Component.requestFocusInWindow(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestFocusInWindow(boolean)"><!-- --></A> <H3>
requestFocusInWindow</H3>
<PRE>
protected boolean <B>requestFocusInWindow</B>(boolean&nbsp;temporary)</PRE>
<DL>
<DD>이 <code>Component</code> 가 입력초점을 취득하는 것을 요구합니다. 이 메소드의 상세한 것에 대하여는,<A HREF="../../java/awt/Component.html#requestFocusInWindow(boolean)"><CODE>Component.requestFocusInWindow(boolean)</CODE></A>  를 참조해 주세요.  &nbsp;<p>
포커스의 상세한 것에 대하여는, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html"> 「How to Use the Focus Subsystem」</a>를 참조해 주세요. <em></em>
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#requestFocusInWindow(boolean)">requestFocusInWindow</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>temporary</CODE> - 포커스의 변경이 일시적인 것인가 어떤가를 나타내는 boolean 치
<DT><B>반환값:</B><DD>포커스 변경 요구가 확실히 에러가 되는 경우는 <code>false</code>,
성공할 가능성이 있는 경우는 <code>true</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A> , 
<A HREF="../../java/awt/Component.html#requestFocusInWindow(boolean)"><CODE>Component.requestFocusInWindow(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="grabFocus()"><!-- --></A> <H3>
grabFocus</H3>
<PRE>
public void <B>grabFocus</B>()</PRE>
<DL>
<DD>이 컴퍼넌트가 입력초점을 취득해, 이 컴퍼넌트의 최상정도 클래스의 윈도우에 포커스를 설정하는 것을 요구합니다. 이 요구를 허가하기 위해서는, 이 컴퍼넌트가 가시, 표시 가능해 포커스 가능하지 않으면 안됩니다.  &nbsp;<p>
이 메소드는 포커스 구현에서의 사용을 상정하고 있습니다. 클라이언트 코드에서는 이 메소드는 아니고,<code>requestFocusInWindow()</code> 를 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#requestFocusInWindow()"><CODE>requestFocusInWindow()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setVerifyInputWhenFocusTarget(boolean)"><!-- --></A> <H3>
setVerifyInputWhenFocusTarget</H3>
<PRE>
public void <B>setVerifyInputWhenFocusTarget</B>(boolean&nbsp;verifyInputWhenFocusTarget)</PRE>
<DL>
<DD>이 컴퍼넌트가 포커스를 요구하기 전에, 현재의 포커스를 가지는 컴퍼넌트에 입력 검증자를 호출할지 어떨지를 나타내는 값을 설정합니다. 디폴트는 true 입니다. 현재의 포커스를 가지는 컴퍼넌트에의 입력이, 그 컴퍼넌트의 입력 검증자로 건네받지 않은 경우에서도 액티브하게 할 필요가 있는 「취소」버튼 또는 스크롤 바등의 컴퍼넌트는, false 로 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>verifyInputWhenFocusTarget</CODE> - <code>verifyInputWhenFocusTarget</code> 프로퍼티의
값<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 내의 클래스"><CODE>InputVerifier</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setInputVerifier(javax.swing.InputVerifier)"><CODE>setInputVerifier(javax.swing.InputVerifier)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#getInputVerifier()"><CODE>getInputVerifier()</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#getVerifyInputWhenFocusTarget()"><CODE>getVerifyInputWhenFocusTarget()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getVerifyInputWhenFocusTarget()"><!-- --></A> <H3>
getVerifyInputWhenFocusTarget</H3>
<PRE>
public boolean <B>getVerifyInputWhenFocusTarget</B>()</PRE>
<DL>
<DD>이 컴퍼넌트가 포커스를 요구하기 전에, 현재의 포커스를 가지는 컴퍼넌트에 입력 검증자를 호출할지 어떨지를 나타내는 값을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>verifyInputWhenFocusTarget</code> 프로퍼티의 값<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 내의 클래스"><CODE>InputVerifier</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setInputVerifier(javax.swing.InputVerifier)"><CODE>setInputVerifier(javax.swing.InputVerifier)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#getInputVerifier()"><CODE>getInputVerifier()</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setVerifyInputWhenFocusTarget(boolean)"><CODE>setVerifyInputWhenFocusTarget(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getFontMetrics(java.awt.Font)"><!-- --></A> <H3>
getFontMetrics</H3>
<PRE>
public <A HREF="../../java/awt/FontMetrics.html" title="java.awt 내의 클래스">FontMetrics</A>  <B>getFontMetrics</B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font)</PRE>
<DL>
<DD>지정된 <code>Font</code> 의 <code>FontMetrics</code> 를 돌려줍니다.  폰트메트릭스를 취득하는 폰트
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getFontMetrics(java.awt.Font)">getFontMetrics</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>font</CODE> - 폰트메트릭스를 취득하는 폰트
<DT><B>반환값:</B><DD><code>font</code> 의 폰트메트릭스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>font</code> 가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#getFont()"><CODE>Component.getFont()</CODE></A> , 
<A HREF="../../java/awt/Component.html#getPeer()"><CODE>Component.getPeer()</CODE></A> , 
<CODE>ComponentPeer.getFontMetrics(Font)</CODE>, 
<A HREF="../../java/awt/Toolkit.html#getFontMetrics(java.awt.Font)"><CODE>Toolkit.getFontMetrics(Font)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPreferredSize(java.awt.Dimension)"><!-- --></A> <H3>
setPreferredSize</H3>
<PRE>
public void <B>setPreferredSize</B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;preferredSize)</PRE>
<DL>
<DD>이 컴퍼넌트의 적절한 사이즈를 설정합니다. <code>preferredSize</code> 가 <code>null</code> 의 경우, UI 로 적절한 사이즈를 요구합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setPreferredSize(java.awt.Dimension)">setPreferredSize</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>preferredSize</CODE> - 새로운 추천 사이즈, 또는 null<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#getPreferredSize()"><CODE>Component.getPreferredSize()</CODE></A> , 
<A HREF="../../java/awt/Component.html#isPreferredSizeSet()"><CODE>Component.isPreferredSizeSet()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPreferredSize()"><!-- --></A> <H3>
getPreferredSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getPreferredSize</B>()</PRE>
<DL>
<DD><code>preferredSize</code> 가 <code>null</code> 이외의 값으로 설정되어 있는 경우에 그 값을 돌려줍니다. UI 위양의 <code>getPreferredSize()</code> 메소드가 <code>null</code> 이외의 값을 돌려주는 경우는, 그 값을 돌려줍니다.  그렇지 않은 경우는 컴퍼넌트 레이아웃 매니저에 따릅니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getPreferredSize()">getPreferredSize</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>preferredSize</code> 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setPreferredSize(java.awt.Dimension)"><CODE>setPreferredSize(java.awt.Dimension)</CODE></A> , 
<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setMaximumSize(java.awt.Dimension)"><!-- --></A> <H3>
setMaximumSize</H3>
<PRE>
public void <B>setMaximumSize</B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;maximumSize)</PRE>
<DL>
<DD>이 컴퍼넌트의 최대 사이즈를 정수치로 설정합니다. <code>getMaximumSize</code> 의 이후의 호출로, 항상 이 값을 돌려줍니다. 그 계산을 위해서(때문에) 컴퍼넌트의 UI 가 요구될 것은 없습니다. 최대 사이즈를 <code>null</code> 로 설정하면(자), 디폴트의 동작하러 돌아옵니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setMaximumSize(java.awt.Dimension)">setMaximumSize</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>maximumSize</CODE> - 요구되는 최대 허가 사이즈를 보관 유지하는 <code>Dimension</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getMaximumSize()"><CODE>getMaximumSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumSize()"><!-- --></A> <H3>
getMaximumSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getMaximumSize</B>()</PRE>
<DL>
<DD>최대 사이즈가 <code>null</code> 이외의 값으로 설정되어 있는 경우는 그 값을 돌려줍니다. UI 위양의 <code>getMaximumSize</code> 메소드가 <code>null</code> 이외의 값을 돌려주는 경우는, 그 값을 돌려줍니다.  그렇지 않은 경우는 컴퍼넌트 레이아웃 매니저에 따릅니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getMaximumSize()">getMaximumSize</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>maximumSize</code> 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setMaximumSize(java.awt.Dimension)"><CODE>setMaximumSize(java.awt.Dimension)</CODE></A> , 
<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setMinimumSize(java.awt.Dimension)"><!-- --></A> <H3>
setMinimumSize</H3>
<PRE>
public void <B>setMinimumSize</B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;minimumSize)</PRE>
<DL>
<DD>이 컴퍼넌트의 최소 사이즈를 정수치로 설정합니다. <code>getMinimumSize</code> 의 이후의 호출로, 항상 이 값을 돌려줍니다. 그 계산을 위해서(때문에) 컴퍼넌트의 UI 가 요구될 것은 없습니다. 최소 사이즈를 <code>null</code> 로 설정하면(자), 디폴트의 동작하러 돌아옵니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setMinimumSize(java.awt.Dimension)">setMinimumSize</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>minimumSize</CODE> - 이 컴퍼넌트의 새로운 최소 사이즈<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getMinimumSize()"><CODE>getMinimumSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMinimumSize()"><!-- --></A> <H3>
getMinimumSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getMinimumSize</B>()</PRE>
<DL>
<DD>최소 사이즈가 <code>null</code> 이외의 값으로 설정되어 있는 경우는 그 값을 돌려줍니다. UI 위양의 <code>getMinimumSize</code> 메소드가 <code>null</code> 이외의 값을 돌려주는 경우는, 그 값을 돌려줍니다.  그렇지 않은 경우는 컴퍼넌트 레이아웃 매니저에 따릅니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getMinimumSize()">getMinimumSize</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>minimumSize</code> 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setMinimumSize(java.awt.Dimension)"><CODE>setMinimumSize(java.awt.Dimension)</CODE></A> , 
<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="contains(int, int)"><!-- --></A> <H3>
contains</H3>
<PRE>
public boolean <B>contains</B>(int&nbsp;x,
                        int&nbsp;y)</PRE>
<DL>
<DD>마우스 처리를 위해서(때문에), 이 컴퍼넌트의 정확한 형상을 정의할 기회를 UI 위양에 제공합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#contains(int, int)">contains</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 점의 <i>x</i> 좌표<DD><CODE>y</CODE> - 점의 <i>y</i> 좌표
<DT><B>반환값:</B><DD>이 컴퍼넌트가 논리적으로 x 와 y 를 포함한 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#contains(int, int)"><CODE>Component.contains(int, int)</CODE></A> , 
<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setBorder(javax.swing.border.Border)"><!-- --></A> <H3>
setBorder</H3>
<PRE>
public void <B>setBorder</B>(<A HREF="../../javax/swing/border/Border.html" title="javax.swing.border 안의 인터페이스">Border</A> &nbsp;border)</PRE>
<DL>
<DD>이 컴퍼넌트의 경계를 설정합니다. <code>Border</code> 객체는, 컴퍼넌트의 인 세트를 정의해 (컴퍼넌트로 직접 설정되어 있는 인 세트를 오버라이드(override) 한다), 임의로 그러한 인 세트의 경계내의 경계 장식을 draw 합니다. Swing 컴퍼넌트로 장식 영역 및 비장식 영역 (마진 및 패딩등)의 양쪽 모두를 생성하려면 , 인 세트는 아니고 경계를 사용할 필요가 있습니다. 단일의 컴퍼넌트내에서 복수의 경계를 상자로 하려면 , 복합 경계를 사용할 수 있습니다.  &nbsp;<p>
기술적으로는 <code>JComponent</code> 를 상속하는 어느 객체에도 경계를 설정할 수 있습니다만, 표준의 Swing 컴퍼넌트의 Look & Feel 의 구현의 상당수는, 사용자 설정의 경계에서는 올바르게 동작하지 않습니다. 일반적으로,<code>JPanel</code> 또는 <code>JLabel</code> 이외의 표준의 Swing 컴퍼넌트로 경계를 설정할 때는, 컴퍼넌트를 <code>JPanel</code> 에 넣어,<code>JPanel</code> 로 경계를 설정하는 것을 추천합니다.  &nbsp;<p>
이것은 바운드 프로퍼티입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>border</CODE> - 이 컴퍼넌트로 draw 되는 경계<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/border/Border.html" title="javax.swing.border 내의 인터페이스"><CODE>Border</CODE></A> , 
<A HREF="../../javax/swing/border/CompoundBorder.html" title="javax.swing.border 안의 클래스"><CODE>CompoundBorder</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBorder()"><!-- --></A> <H3>
getBorder</H3>
<PRE>
public <A HREF="../../javax/swing/border/Border.html" title="javax.swing.border 내의 인터페이스">Border</A>  <B>getBorder</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 경계를 돌려줍니다. 경계가 현재 설정되어 있지 않은 경우는 <code>null</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트의 경계 객체<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setBorder(javax.swing.border.Border)"><CODE>setBorder(javax.swing.border.Border)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getInsets()"><!-- --></A> <H3>
getInsets</H3>
<PRE>
public <A HREF="../../java/awt/Insets.html" title="java.awt 내의 클래스">Insets</A>  <B>getInsets</B>()</PRE>
<DL>
<DD>이 컴퍼넌트로 경계가 설정되어 있는 경우는 경계의 인 세트를 돌려주어, 그렇지 않은 경우는 <code>super.getInsets</code> 를 호출합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getInsets()">getInsets</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>인 세트 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setBorder(javax.swing.border.Border)"><CODE>setBorder(javax.swing.border.Border)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getInsets(java.awt.Insets)"><!-- --></A> <H3>
getInsets</H3>
<PRE>
public <A HREF="../../java/awt/Insets.html" title="java.awt 내의 클래스">Insets</A>  <B>getInsets</B>(<A HREF="../../java/awt/Insets.html" title="java.awt 안의 클래스">Insets</A> &nbsp;insets)</PRE>
<DL>
<DD>이 컴퍼넌트의 인 세트치를 포함하는 <code>Insets</code> 객체를 돌려줍니다. 건네받은 <code>Insets</code> 객체는, 가능한 경우에 재사용됩니다. 그러나, 메소드를 호출할 때마다 같은 객체가 반환된다고는 할 수 없습니다. 이 객체내의 모든 기존의 값은 덧쓰기됩니다. <code>insets</code> 가 null 의 경우, 새로운 값을 할당할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>insets</CODE> - 재사용할 수 있는 <code>Insets</code> 객체
<DT><B>반환값:</B><DD><code>Insets</code> 객체<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getInsets()"><CODE>getInsets()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAlignmentY()"><!-- --></A> <H3>
getAlignmentY</H3>
<PRE>
public float <B>getAlignmentY</B>()</PRE>
<DL>
<DD><code>Container.getAlignmentY</code> 를 오버라이드(override) 해, 수평의 배치 방법을 돌려주도록(듯이) 합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getAlignmentY()">getAlignmentY</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>alignmentY</code> 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setAlignmentY(float)"><CODE>setAlignmentY(float)</CODE></A> , 
<A HREF="../../java/awt/Component.html#getAlignmentY()"><CODE>Component.getAlignmentY()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setAlignmentY(float)"><!-- --></A> <H3>
setAlignmentY</H3>
<PRE>
public void <B>setAlignmentY</B>(float&nbsp;alignmentY)</PRE>
<DL>
<DD>수평의 배치 방법을 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>alignmentY</CODE> - 새로운 수평의 배치 방법<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getAlignmentY()"><CODE>getAlignmentY()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAlignmentX()"><!-- --></A> <H3>
getAlignmentX</H3>
<PRE>
public float <B>getAlignmentX</B>()</PRE>
<DL>
<DD><code>Container.getAlignmentX</code> 를 오버라이드(override) 해, 수직의 배치 방법을 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getAlignmentX()">getAlignmentX</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>alignmentX</code> 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setAlignmentX(float)"><CODE>setAlignmentX(float)</CODE></A> , 
<A HREF="../../java/awt/Component.html#getAlignmentX()"><CODE>Component.getAlignmentX()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setAlignmentX(float)"><!-- --></A> <H3>
setAlignmentX</H3>
<PRE>
public void <B>setAlignmentX</B>(float&nbsp;alignmentX)</PRE>
<DL>
<DD>수직의 배치 방법을 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>alignmentX</CODE> - 새로운 수직의 배치 방법<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getAlignmentX()"><CODE>getAlignmentX()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setInputVerifier(javax.swing.InputVerifier)"><!-- --></A> <H3>
setInputVerifier</H3>
<PRE>
public void <B>setInputVerifier</B>(<A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 안의 클래스">InputVerifier</A> &nbsp;inputVerifier)</PRE>
<DL>
<DD>이 컴퍼넌트의 입력 검증자를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inputVerifier</CODE> - 새로운 입력 검증자<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 내의 클래스"><CODE>InputVerifier</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getInputVerifier()"><!-- --></A> <H3>
getInputVerifier</H3>
<PRE>
public <A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 내의 클래스">InputVerifier</A>  <B>getInputVerifier</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 입력 검증자를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>inputVerifier</code> 프로퍼티<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 내의 클래스"><CODE>InputVerifier</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getGraphics()"><!-- --></A> <H3>
getGraphics</H3>
<PRE>
public <A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A>  <B>getGraphics</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 그래픽스 문맥을 돌려줍니다.  그래픽스 문맥을 사용하면(자), 컴퍼넌트를 draw 할 수 있습니다. 이 메소드를 사용하면(자),<code>Graphics</code> 객체를 취득해, 그 객체로 처리를 호출해 컴퍼넌트를 draw 할 수 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getGraphics()">getGraphics</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트의 그래픽스 문맥<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#paint(java.awt.Graphics)"><CODE>Component.paint(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDebugGraphicsOptions(int)"><!-- --></A> <H3>
setDebugGraphicsOptions</H3>
<PRE>
public void <B>setDebugGraphicsOptions</B>(int&nbsp;debugOptions)</PRE>
<DL>
<DD>이 컴퍼넌트, 또는 그 아이의 어떤 것인가로 실행되는 모든 그래픽 조작에 대한 진단 정보를 유효화 또는 무효화합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>debugOptions</CODE> - 컴퍼넌트가 정보를 표시하는 방법을 지정하는 옵션.
                다음의 언젠가
 <ul>
<li>DebugGraphics.LOG_OPTION - 텍스트 메세지를 출력한다
<li>DebugGraphics.FLASH_OPTION - draw를 몇차례 점멸시킨다
<li>DebugGraphics.BUFFERED_OPTION - View 의 오프 스크린 버퍼로 실행된 처리를 표시하는 <code>ExternalWindow</code> 를 작성한다
<li>DebugGraphics.NONE_OPTION -  디버그를 무효로 한다
<li>값이 제로의 경우는 디버그 옵션을 변경하지 않는다
 </ul>
<code>debugOptions</code> 는, 현재의 값에 대한 비트 단위의 논리합입니다. </DL>
</DD>
</DL>
<HR>

<A NAME="getDebugGraphicsOptions()"><!-- --></A> <H3>
getDebugGraphicsOptions</H3>
<PRE>
public int <B>getDebugGraphicsOptions</B>()</PRE>
<DL>
<DD>그라픽스데밧깅 상태를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>다음에 드는 각 옵션의 비트 단위의 논리합.
 <ul>
<li>DebugGraphics.LOG_OPTION - 텍스트 메세지를 출력한다
<li>DebugGraphics.FLASH_OPTION - draw를 몇차례 점멸시킨다
<li>DebugGraphics.BUFFERED_OPTION - View 의 오프 스크린 버퍼로 실행된 처리를 표시하는 <code>ExternalWindow</code> 를 작성한다
<li>DebugGraphics.NONE_OPTION -  디버그를 무효로 한다
<li>값이 제로의 경우는 디버그 옵션을 변경하지 않는다
 </ul><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setDebugGraphicsOptions(int)"><CODE>setDebugGraphicsOptions(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)"><!-- --></A> <H3>
registerKeyboardAction</H3>
<PRE>
public void <B>registerKeyboardAction</B>(<A HREF="../../java/awt/event/ActionListener.html" title="java.awt.event 안의 인터페이스">ActionListener</A> &nbsp;anAction,
                                   <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;aCommand,
                                   <A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke,
                                   int&nbsp;aCondition)</PRE>
<DL>
<DD>이 메소드는 현재 사용되고 있지 않습니다. 유사한 동작에는 <code>getActionMap()</code> 와 <code>getInputMap()</code> 의 메소드를 조합해 사용해 주세요. 예를 들어,<code>KeyStroke</code> 의 <code>aKeyStroke</code> 를 <code>Action</code> 의 <code>anAction</code> 에 바인드 하려면 , 다음의 메소드를 사용합니다.
 <pre>
   component.getInputMap(). put(aKeyStroke, aCommand);
   component.getActionMap(). put(aCommmand, anAction);
 </pre>
상기의 예는,<code>WHEN_FOCUSED</code> 에 적절한 바인딩을 실행하면(자) 가정한 것입니다. 다른 포커스 상태의 바인딩을 등록하려면 , 정수값을 받는 <code>getInputMap</code> 메소드를 사용합니다.  &nbsp;<p>
새로운 키보드 액션을 등록합니다. <code> anAction</code> 는,<code>aKeyStroke</code> 와 일치하는 키 이벤트가 발생해,<code>aCondition</code> 가 확인되었을 경우에 불려 갑니다. <code>KeyStroke</code> 객체는, 키보드의 키와 1 개 이상의 수식 키 (alt, shift, ctrl, meta)의 특정의 편성을 정의합니다.  &nbsp;<p>
<code>aCommand</code> 는, 지정되고 있으면, 보내지는 이벤트로 설정됩니다.  &nbsp;<p>
<code>aCondition</code> 는 다음의 머지않아인가입니다.
 <blockquote>
 <DL>
<DT>WHEN_FOCUSED
<DD>액션은, 컴퍼넌트가 포커스를 가지는 경우에 키스트로크(keystroke)가 발생했을 때만 불려 간다
<DT>WHEN_IN_FOCUSED_WINDOW
<DD>액션은, 컴퍼넌트가 포커스를 가지는지, 또는 포커스를 가지는 윈도우내에 있는 경우에 키스트로크(keystroke)가 발생했을 때에만 불려 간다. 컴퍼넌트는 윈도우의 직접적인 하위일 필요는 없고, 윈도우의 포함 관계의 계층의 어디에 있어도 상관없다. 즉, 윈도우내의<em>어느</em>컴퍼넌트가 포커스를 가지고 있어도, 이 컴퍼넌트에 등록되어 있는 액션은 불려 간다
<DT>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT
<DD>액션은, 컴퍼넌트가 포커스를 가지는지, 또는 포커스를 가지는 컴퍼넌트의 상위 객체인 경우에 키스트로크(keystroke)가 발생했을 때만 불려 간다
 </DL>
 </blockquote>
 <p>
키스트로크(keystroke)와 조건의 편성에 의해, (KeyStroke 클래스를 사용해) 지정된 키스트로크(keystroke)와 수식 키의 편성에 대한 하이레벨의 (의미상의) 액션 이벤트를 정의할 수 있어 포커스를 가지는 컴퍼넌트의 부모 또는 아이, 혹은 컴퍼넌트 자체를 향할 수가 있습니다. 즉, 어떠한 컴퍼넌트의 계층 구조에 대해도, 임의의 키의 편성을 계층내의 적절한 컴퍼넌트에 직접 이끌 수가 있어 특정의 메소드를 호출할 수가 있습니다 (일반적으로은 어댑터 객체를 개입시킨다).  &nbsp;<p>
액션이 벌써 같은 charCode 및 같은 수식 키로 수신측 컨테이너에 등록되어 있는 경우,<code>anAction</code> 는 그 액션을 옮겨놓습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>anAction</CODE> - 등록하는 <code>Action</code><DD><CODE>aCommand</CODE> - 보내지는 이벤트로 설정되는 커멘드<DD><CODE>aKeyStroke</CODE> - 액션을 바인드 하는 <code>KeyStroke</code><DD><CODE>aCondition</CODE> - 채울 필요가 있는 조건. 상기 참조<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 내의 클래스"><CODE>KeyStroke</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="registerKeyboardAction(java.awt.event.ActionListener, javax.swing.KeyStroke, int)"><!-- --></A> <H3>
registerKeyboardAction</H3>
<PRE>
public void <B>registerKeyboardAction</B>(<A HREF="../../java/awt/event/ActionListener.html" title="java.awt.event 안의 인터페이스">ActionListener</A> &nbsp;anAction,
                                   <A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke,
                                   int&nbsp;aCondition)</PRE>
<DL>
<DD>이 메소드는 현재 사용되고 있지 않습니다. 유사한 동작에는 <code>getActionMap()</code> 와 <code>getInputMap()</code> 의 메소드를 조합해 사용해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="unregisterKeyboardAction(javax.swing.KeyStroke)"><!-- --></A> <H3>
unregisterKeyboardAction</H3>
<PRE>
public void <B>unregisterKeyboardAction</B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke)</PRE>
<DL>
<DD>이 메소드는 현재 사용되고 있지 않습니다. 기존의 바인딩의 등록을 해제하는데는,<code>ActionMap</code> 또는 <code>InputMap</code> 로부터 바인딩을 삭제하는지, 또는 <code>InputMap</code> 에 더미 바인딩을 설정합니다. <code>InputMap</code> 로부터 바인딩을 삭제하면(자), 부모의 <code>InputMap</code> 의 바인딩을 액티브하게 할 수 있습니다.  그에 대해,<code>InputMap</code> 에 더미 바인딩을 배치하면(자), 지금까지 발생한 바인딩을 효과적으로 무효로 합니다.  &nbsp;<p>
키보드 액션을 등록 해제합니다. 이 해제에 의해,<code>InputMap</code> 와 같이 <code>ActionMap</code> (존재하는 경우)의 바인딩도 삭제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRegisteredKeyStrokes()"><!-- --></A> <H3>
getRegisteredKeyStrokes</H3>
<PRE>
public <A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 내의 클래스">KeyStroke</A> [] <B>getRegisteredKeyStrokes</B>()</PRE>
<DL>
<DD>등록되어 있는 액션을 개시하는 <code>KeyStroke</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>KeyStroke</code> 객체의 배열<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)"><CODE>registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getConditionForKeyStroke(javax.swing.KeyStroke)"><!-- --></A> <H3>
getConditionForKeyStroke</H3>
<PRE>
public int <B>getConditionForKeyStroke</B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke)</PRE>
<DL>
<DD>등록되어 있는 액션이, 지정된 키스트로크(keystroke)에 반응해 발생할지 어떨지를 결정하는 조건을 돌려줍니다.  &nbsp;<p>
Java 2 플랫폼 v1. 3 의 경우,<code>KeyStroke</code> 를 복수의 조건과 관련지을 수가 있습니다. 예를 들어, 1 개의 키스트로크(keystroke)를 2 개의 조건 <code> WHEN_FOCUSED</code> 와 <code>WHEN_IN_FOCUSED_WINDOW</code> 에 바인드 할 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>액션과 키스트로크(keystroke)의 조건</DL>
</DD>
</DL>
<HR>

<A NAME="getActionForKeyStroke(javax.swing.KeyStroke)"><!-- --></A> <H3>
getActionForKeyStroke</H3>
<PRE>
public <A HREF="../../java/awt/event/ActionListener.html" title="java.awt.event 내의 인터페이스">ActionListener</A>  <B>getActionForKeyStroke</B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke)</PRE>
<DL>
<DD>지정된 키스트로크(keystroke)에 대해서 등록되어 있는 액션을 실행하는 객체를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>키스트로크(keystroke)가 발생했을 때에 불려 가는 <code>ActionListener</code> 객체</DL>
</DD>
</DL>
<HR>

<A NAME="resetKeyboardActions()"><!-- --></A> <H3>
resetKeyboardActions</H3>
<PRE>
public void <B>resetKeyboardActions</B>()</PRE>
<DL>
<DD>제 1 층의 <code>InputMap</code> 와 <code>ActionMap</code> 의 바인딩을 모두 등록 해제합니다. 이 방법은, 어느 로컬 바인딩을 삭제하는 경우에도 효과적이며, 부모의 <code>InputMap</code> 및 <code>ActionMap</code> (UI 는 일반적으로 제 2 층에서 정의)에 정의된 바인딩을 지속시킬 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setInputMap(int, javax.swing.InputMap)"><!-- --></A> <H3>
setInputMap</H3>
<PRE>
public final void <B>setInputMap</B>(int&nbsp;condition,
                              <A HREF="../../javax/swing/InputMap.html" title="javax.swing 안의 클래스">InputMap</A> &nbsp;map)</PRE>
<DL>
<DD>조건 <code>condition</code> 로 사용하는 <code>InputMap</code> 를 <code>map</code> 로 설정합니다. <code>null</code> 치는 UI 로부터의 것이어도 바인딩을 사용하지 않는 것을 나타냅니다. UI <code>InputMap</code> 가 존재하는 경우, 재인스톨은 하지 않습니다. <code> condition</code> 의 값은 다음의 어느 쪽인가에 됩니다.
 <ul>
<li><code>WHEN_IN_FOCUSED_WINDOW</code>
<li><code>WHEN_FOCUSED</code>
<li><code>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</code>
 </ul>
<code>condition</code> 가 <code>WHEN_IN_FOCUSED_WINDOW</code> 이며,<code>map</code> 가 <code>ComponentInputMap</code> 가 아닌 경우,<code>IllegalArgumentException</code> 가 throw 됩니다. 같이<code>condition</code> 가 상기의 것이 아닌 경우,<code>IllegalArgumentException</code> 가 throw 됩니다. 전술의 값의 언젠가
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상기의 값의 어느쪽이든<DD><CODE>map</CODE> - 지정의 조건에 대해서 사용되는 <code>InputMap</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>condition</code> 가 <code>WHEN_IN_FOCUSED_WINDOW</code> 이며,<code>map</code> 가 <code>ComponentInputMap</code> 의 인스턴스가 아닌 경우, 또는 <code>condition</code> 가 상기로 지정된 값이 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInputMap(int)"><!-- --></A> <H3>
getInputMap</H3>
<PRE>
public final <A HREF="../../javax/swing/InputMap.html" title="javax.swing 내의 클래스">InputMap</A>  <B>getInputMap</B>(int&nbsp;condition)</PRE>
<DL>
<DD><code>condition</code> 로 사용되고 있는 <code>InputMap</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - WHEN_IN_FOCUSED_WINDOW, WHEN_FOCUSED, WHEN_ANCESTOR_OF_FOCUSED_COMPONENT  가운데 1 개
<DT><B>반환값:</B><DD>지정된 <code>condition</code> 에 대한 <code>InputMap</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInputMap()"><!-- --></A> <H3>
getInputMap</H3>
<PRE>
public final <A HREF="../../javax/swing/InputMap.html" title="javax.swing 내의 클래스">InputMap</A>  <B>getInputMap</B>()</PRE>
<DL>
<DD>컴퍼넌트가 포커스를 취득했을 때에 사용하는 <code>InputMap</code> 를 돌려줍니다. 이것은 <code>getInputMap(WHEN_FOCUSED)</code> 의 편리한 메소드입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>컴퍼넌트가 포커스를 취득했을 때에 사용하는 <code>InputMap</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setActionMap(javax.swing.ActionMap)"><!-- --></A> <H3>
setActionMap</H3>
<PRE>
public final void <B>setActionMap</B>(<A HREF="../../javax/swing/ActionMap.html" title="javax.swing 안의 클래스">ActionMap</A> &nbsp;am)</PRE>
<DL>
<DD><code>ActionMap</code> 를 <code>am</code> 로 설정합니다. UI 가 존재하는 경우에서도,<code>am</code> 의 부모를 UI 로부터의 <code>ActionMap</code> 로서는 설정하지 않습니다.  이 처리는 호출해 옆에서 실시합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>am</CODE> - 새로운 <code>ActionMap</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getActionMap()"><!-- --></A> <H3>
getActionMap</H3>
<PRE>
public final <A HREF="../../javax/swing/ActionMap.html" title="javax.swing 내의 클래스">ActionMap</A>  <B>getActionMap</B>()</PRE>
<DL>
<DD>특정의 <code>KeyStroke</code> 바인딩에 대해서 트리거하는 <code>Action</code> 의 지정에 사용되는 <code>ActionMap</code> 를 돌려줍니다. 외가 설정되어 있지 않으면, 반환되는 <code>ActionMap</code> 는, 그 부모와 같은 UI 의 <code>ActionMap</code> 를 가집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>키 또는 액션의 바인딩을 포함한 <code>ActionMap</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getBaseline(int, int)"><!-- --></A> <H3>
getBaseline</H3>
<PRE>
public int <B>getBaseline</B>(int&nbsp;width,
                       int&nbsp;height)</PRE>
<DL>
<DD>baseline를 돌려줍니다. baseline는, 컴퍼넌트의 상단으로부터 측정됩니다. 이 메소드는, 주로 <code>LayoutManager</code> 가 그 baseline에 따라 컴퍼넌트를 배치하기 위해서 사용합니다. 반환값이 0 보다 작은 경우, 이 컴퍼넌트의 baseline는 적절하지는 않습니다. <code>LayoutManager</code> 는, 그 baseline상에 이 컴퍼넌트를 배치하지 않습니다.  &nbsp;<p>
이 메소드는, 같은 이름의 <code>ComponentUI</code> 메소드를 호출합니다. 이 컴퍼넌트가 <code>ComponentUI</code> 를 가지고 있지 않은 경우는 -1 이 돌려주어집니다. 반환값이 0 이상의 경우, 컴퍼넌트의 baseline는 최소 사이즈 이상의 임의의 사이즈에 대해서 유효하고,<code>getBaselineResizeBehavior</code> 를 사용해 사이즈에 의한 baseline의 변화를 특정할 수가 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getBaseline(int, int)">getBaseline</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>width</CODE> - baseline를 취득하는 폭<DD><CODE>height</CODE> - baseline를 취득하는 높이
<DT><B>반환값:</B><DD>baseline 또는 0 보다 작은 값 (적절한 baseline가
존재하지 않는다)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 폭 또는 높이가 0 보다 작은 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getBaselineResizeBehavior()"><CODE>getBaselineResizeBehavior()</CODE></A> , 
<A HREF="../../java/awt/FontMetrics.html" title="java.awt 안의 클래스"><CODE>FontMetrics</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBaselineResizeBehavior()"><!-- --></A> <H3>
getBaselineResizeBehavior</H3>
<PRE>
public <A HREF="../../java/awt/Component.BaselineResizeBehavior.html" title="java.awt 내의 열거형">Component.BaselineResizeBehavior</A>  <B>getBaselineResizeBehavior</B>()</PRE>
<DL>
<DD>컴퍼넌트의 사이즈가 변화하는 것에 따라 baseline가 변화하는 방법의 열거를 돌려줍니다. 이 메소드는, 주로 레이아웃 매니저와 GUI 빌더로 사용됩니다.  &nbsp;<p>
이 메소드는, 같은 이름의 <code>ComponentUI</code> 메소드를 호출합니다. 이 컴퍼넌트가 <code>ComponentUI</code> 를 가지고 있지 않은 경우는 <code>BaselineResizeBehavior.OTHER</code> 가 돌려주어집니다. 서브 클래스는 <code>null</code> 를 돌려주지 않습니다. baseline를 계산할 수 없는 경우는,<code>BaselineResizeBehavior.OTHER</code> 를 돌려줍니다. 호출측은, 우선 <code>getBaseline</code> 를 사용해 baseline를 요구합니다. 그리고, 반환값이 0 이상의 경우는 이 메소드를 사용합니다. <code>getBaseline</code> 가 0 보다 작은 값을 돌려주는 경우에서도, 이 메소드가 <code>BaselineResizeBehavior.OTHER</code> 이외의 값을 돌려주는 것은 허용 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getBaselineResizeBehavior()">getBaselineResizeBehavior</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>컴퍼넌트의 사이즈가 변화하는 것에 따라 baseline가 변화하는 방법의
열거<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getBaseline(int, int)"><CODE>getBaseline(int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestDefaultFocus()"><!-- --></A> <H3>
requestDefaultFocus</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public boolean <B>requestDefaultFocus</B>()</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>1.4 이후는 <code>FocusTraversalPolicy.getDefaultComponent(Container). requestFocus()</code> 로 옮겨졌습니다. </I>
<P>
<DD>릴리스 1.4 에서는, 포커스 하부조직이 재구축 되었습니다. 상세한 것에 대하여는, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">「How to Use the Focus Subsystem」</a>를 참조해 주세요. <em></em> &nbsp;<p>
이 <code>JComponent</code> 의 <code>FocusTraversalPolicy</code> 의 디폴트 <code>Component</code> 에의 포커스를 요구합니다. 이 <code>JComponent</code> 가 포커스 사이클 루트의 경우, 그 <code>FocusTraversalPolicy</code> 가 사용됩니다. 그렇지 않은 경우는, 이 <code>JComponent</code> 의 포커스 사이클 루트 클래스의 <code>FocusTraversalPolicy</code> 가 사용됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/FocusTraversalPolicy.html#getDefaultComponent(java.awt.Container)"><CODE>FocusTraversalPolicy.getDefaultComponent(java.awt.Container)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setVisible(boolean)"><!-- --></A> <H3>
setVisible</H3>
<PRE>
public void <B>setVisible</B>(boolean&nbsp;aFlag)</PRE>
<DL>
<DD>컴퍼넌트를 가시 또는 불가시로 합니다. <code>Component.setVisible</code> 를 오버라이드(override) 합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setVisible(boolean)">setVisible</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aFlag</CODE> - 컴퍼넌트를 가시로 하는 경우는 true, 불가시로 하는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#isVisible()"><CODE>Component.isVisible()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnabled(boolean)"><!-- --></A> <H3>
setEnabled</H3>
<PRE>
public void <B>setEnabled</B>(boolean&nbsp;enabled)</PRE>
<DL>
<DD>이 컴퍼넌트가 유효한지 어떤지를 설정합니다. 유효한 컴퍼넌트는 사용자의 입력에 반응할 수 있습니다만, 무효인 컴퍼넌트는 사용자의 입력에 반응할 수 없습니다. 컴퍼넌트에 따라서는, 자신이 무효인 경우로 표시를 변경해, 입력을 납득할 수 없는 것을 나타내는 피드백을 사용자에게 제공할 수 있습니다. <p>주:컴퍼넌트를 무효화해도 아이는 무효화되지 않습니다.

 <p>주:경량화 컴퍼넌트를 무효화해도 MouseEvent 는 수신됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setEnabled(boolean)">setEnabled</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>enabled</CODE> - 이 컴퍼넌트를 유효화하는 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#isEnabled()"><CODE>Component.isEnabled()</CODE></A> , 
<A HREF="../../java/awt/Component.html#isLightweight()"><CODE>Component.isLightweight()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setForeground(java.awt.Color)"><!-- --></A> <H3>
setForeground</H3>
<PRE>
public void <B>setForeground</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;fg)</PRE>
<DL>
<DD>이 컴퍼넌트의 foreground 칼라를 설정합니다. 이 프로퍼티을 받아들일 수 있을지 어떨지는 Look & Feel 나름이며, 무시되는 일도 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setForeground(java.awt.Color)">setForeground</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>fg</CODE> - 요구하는 foreground <code>Color</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#getForeground()"><CODE>Component.getForeground()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setBackground(java.awt.Color)"><!-- --></A> <H3>
setBackground</H3>
<PRE>
public void <B>setBackground</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bg)</PRE>
<DL>
<DD>이 컴퍼넌트의 백그라운드 칼라를 설정합니다. 백그라운드 칼라는, 컴퍼넌트가 불투명한 경우에게만,<code>JComponent</code> 또는 <code>ComponentUI</code> 의 구현의 서브 클래스에 의해서만 사용됩니다. <code>JComponent</code> 의 직접적인 서브 클래스는, 이 프로퍼티을 받아들이기 위해서(때문에) <code>paintComponent</code> 를 오버라이드(override) 할 필요가 있습니다.  &nbsp;<p>
이 프로퍼티을 받아들일 수 있을지 어떨지는 Look & Feel 나름이며, 무시되는 일도 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setBackground(java.awt.Color)">setBackground</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>bg</CODE> - 요구하는 백그라운드 <code>Color</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#getBackground()"><CODE>Component.getBackground()</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setOpaque(boolean)"><CODE>setOpaque(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setFont(java.awt.Font)"><!-- --></A> <H3>
setFont</H3>
<PRE>
public void <B>setFont</B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font)</PRE>
<DL>
<DD>이 컴퍼넌트의 폰트를 설정합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#setFont(java.awt.Font)">setFont</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>font</CODE> - 이 컴퍼넌트로 지정하는 <code>Font</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#getFont()"><CODE>Component.getFont()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultLocale()"><!-- --></A> <H3>
getDefaultLocale</H3>
<PRE>
public static <A HREF="../../java/util/Locale.html" title="java.util 내의 클래스">Locale</A>  <B>getDefaultLocale</B>()</PRE>
<DL>
<DD>각 JComponent 의 로케일 프로퍼티을 생성시에 초기화하기 위해서 사용하는 디폴트 로케일을 돌려줍니다.

디폴트 로케일에는 「AppContext」스코프가 있어, 애플릿 (그리고 잠재적으로는 단독의 VM 로 실행되는 복수의 경량 어플리케이션)이 독자적인 설정을 가질 수가 있습니다. 어느 애플릿이 디폴트 로케일을 변경해도, 다른 애플릿 (또는 브라우저)에는 영향을 주지 않기 때문에, 안전하게 변경할 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>디폴트의 <code>Locale</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setDefaultLocale(java.util.Locale)"><CODE>setDefaultLocale(java.util.Locale)</CODE></A> , 
<A HREF="../../java/awt/Component.html#getLocale()"><CODE>Component.getLocale()</CODE></A> , 
<A HREF="../../java/awt/Component.html#setLocale(java.util.Locale)"><CODE>Component.setLocale(java.util.Locale)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultLocale(java.util.Locale)"><!-- --></A> <H3>
setDefaultLocale</H3>
<PRE>
public static void <B>setDefaultLocale</B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;l)</PRE>
<DL>
<DD>각 JComponent 의 로케일 프로퍼티을 생성시에 초기화하기 위해서 사용하는 디폴트 로케일을 설정합니다. 초기치는 VM 의 디폴트 로케일입니다.

디폴트 로케일에는 「AppContext」스코프가 있어, 애플릿 (그리고 잠재적으로는 단독의 VM 로 실행되는 복수의 경량 어플리케이션)이 독자적인 설정을 가질 수가 있습니다. 어느 애플릿이 디폴트 로케일을 변경해도, 다른 애플릿 (또는 브라우저)에는 영향을 주지 않기 때문에, 안전하게 변경할 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>l</CODE> - 새로운 컴퍼넌트로 지정하는 디폴트 <code>Locale</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getDefaultLocale()"><CODE>getDefaultLocale()</CODE></A> , 
<A HREF="../../java/awt/Component.html#getLocale()"><CODE>Component.getLocale()</CODE></A> , 
<A HREF="../../java/awt/Component.html#setLocale(java.util.Locale)"><CODE>Component.setLocale(java.util.Locale)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="processComponentKeyEvent(java.awt.event.KeyEvent)"><!-- --></A> <H3>
processComponentKeyEvent</H3>
<PRE>
protected void <B>processComponentKeyEvent</B>(<A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e)</PRE>
<DL>
<DD>컴퍼넌트 자체가 인식하는 키 이벤트를 처리합니다. 이 메소드는, 포커스 매니저 및 관련하는 모든 청취자에게, 이벤트를 횡령할 기회가 주어진 뒤에 불려 갑니다. 이 메소드는, 이벤트가 아직 사용되어 있지 않은 경우에만 불려 갑니다. 이 메소드는, 키보드 UI 논리에 우선해 불려 갑니다.  &nbsp;<p>
이 메소드의 구현은 아무것도 실시하지 않습니다. 일반적으로, 서브 클래스는 그것들 자체가 키 이벤트를 처리하는 경우에 이 메소드를 오버라이드(override) 합니다. 처리된 이벤트는 파기됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="processKeyEvent(java.awt.event.KeyEvent)"><!-- --></A> <H3>
processKeyEvent</H3>
<PRE>
protected void <B>processKeyEvent</B>(<A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e)</PRE>
<DL>
<DD>이벤트를 처리하는 <code>processKeyEvent</code> 를 오버라이드(override) 합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#processKeyEvent(java.awt.event.KeyEvent)">processKeyEvent</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 키 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 내의 클래스"><CODE>KeyEvent</CODE></A> , 
<A HREF="../../java/awt/event/KeyListener.html" title="java.awt.event 안의 인터페이스"><CODE>KeyListener</CODE></A> , 
<A HREF="../../java/awt/KeyboardFocusManager.html" title="java.awt 안의 클래스"><CODE>KeyboardFocusManager</CODE></A> , 
<A HREF="../../java/awt/DefaultKeyboardFocusManager.html" title="java.awt 안의 클래스"><CODE>DefaultKeyboardFocusManager</CODE></A> , 
<A HREF="../../java/awt/Component.html#processEvent(java.awt.AWTEvent)"><CODE>Component.processEvent(java.awt.AWTEvent)</CODE></A> , 
<A HREF="../../java/awt/Component.html#dispatchEvent(java.awt.AWTEvent)"><CODE>Component.dispatchEvent(java.awt.AWTEvent)</CODE></A> , 
<A HREF="../../java/awt/Component.html#addKeyListener(java.awt.event.KeyListener)"><CODE>Component.addKeyListener(java.awt.event.KeyListener)</CODE></A> , 
<A HREF="../../java/awt/Component.html#enableEvents(long)"><CODE>Component.enableEvents(long)</CODE></A> , 
<A HREF="../../java/awt/Component.html#isShowing()"><CODE>Component.isShowing()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="processKeyBinding(javax.swing.KeyStroke, java.awt.event.KeyEvent, int, boolean)"><!-- --></A> <H3>
processKeyBinding</H3>
<PRE>
protected boolean <B>processKeyBinding</B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;ks,
                                    <A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e,
                                    int&nbsp;condition,
                                    boolean&nbsp;pressed)</PRE>
<DL>
<DD><code>KeyEvent</code> <code>e</code> 의 결과로서 <code>ks</code> 의 키 바인드를 처리하기 위해서 불려 갑니다. 이 메소드는 적절한 <code>InputMap</code>, 그 바인딩,<code>ActionMap</code> 의 액션을 취득해, (액션이 발견되어, 컴퍼넌트가 유효한 경우) 액션을 통지하기 위해서 <code>notifyAction</code> 를 호출합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ks</CODE> - 조회하는 <code>KeyStroke</code><DD><CODE>e</CODE> - <code>KeyEvent</code><DD><CODE>condition</CODE> - 다음의 값의 언젠가.
 <ul>
<li>JComponent.WHEN_FOCUSED
<li>JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT
<li>JComponent.WHEN_IN_FOCUSED_WINDOW
 </ul><DD><CODE>pressed</CODE> - 키가 밀리고 있는 경우는 true
<DT><B>반환값:</B><DD>액션에 바인딩이 있어, 액션이 유효했던 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setToolTipText(java.lang.String)"><!-- --></A> <H3>
setToolTipText</H3>
<PRE>
public void <B>setToolTipText</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;text)</PRE>
<DL>
<DD>툴팁에 표시하는 텍스트를 등록합니다. 이 텍스트는, 커서가 컴퍼넌트상에 있을 때 표시됩니다.  &nbsp;<p>
자세한 것은, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/components/tooltip.html">「How to Use Tool Tips」</a>를 참조해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>text</CODE> - 표시하는 캐릭터 라인. 텍스트가 <code>null</code> 의 경우,
이 컴퍼넌트의 툴팁는 오프<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#TOOL_TIP_TEXT_KEY"><CODE>TOOL_TIP_TEXT_KEY</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getToolTipText()"><!-- --></A> <H3>
getToolTipText</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getToolTipText</B>()</PRE>
<DL>
<DD><code>setToolTipText</code> 로 설정되어 있는 툴팁의 캐릭터 라인을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>툴팁의 텍스트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#TOOL_TIP_TEXT_KEY"><CODE>TOOL_TIP_TEXT_KEY</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getToolTipText(java.awt.event.MouseEvent)"><!-- --></A> <H3>
getToolTipText</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getToolTipText</B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</PRE>
<DL>
<DD><i>event</i> 의 툴팁로서 사용되는 캐릭터 라인을 돌려줍니다. 디폴트에서는,<code>setToolTipText</code> 를 사용해 설정된 임의의 캐릭터 라인을 돌려줍니다. 컴퍼넌트가 보다 포괄적인 API 를 제공해 다른 위치에서 다른 툴팁를 지원하는 경우, 이 메소드는 오버라이드(override) 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getToolTipLocation(java.awt.event.MouseEvent)"><!-- --></A> <H3>
getToolTipLocation</H3>
<PRE>
public <A HREF="../../java/awt/Point.html" title="java.awt 내의 클래스">Point</A>  <B>getToolTipLocation</B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</PRE>
<DL>
<DD>이 컴퍼넌트의 좌표계에 있어서의 툴팁의 위치를 돌려줍니다. <code>null</code> 가 반환되는 경우는, Swing 가 위치를 선택합니다. 디폴트 구현은 <code>null</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>event</CODE> - <code>ToolTipManager</code> 에 툴팁를 표시시키는 <code>MouseEvent</code>
<DT><B>반환값:</B><DD>항상 <code>null</code> 를 돌려준다</DL>
</DD>
</DL>
<HR>

<A NAME="getPopupLocation(java.awt.event.MouseEvent)"><!-- --></A> <H3>
getPopupLocation</H3>
<PRE>
public <A HREF="../../java/awt/Point.html" title="java.awt 내의 클래스">Point</A>  <B>getPopupLocation</B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</PRE>
<DL>
<DD>이 컴퍼넌트의 좌표계에 pop-up menu를 표시하는데 적절한 위치를 돌려줍니다. 이 프로퍼티을 받아들일 수 있을지 어떨지는 Look & Feel 나름이며, 무시되는 일도 있습니다. <code>null</code> 의 경우는, Look & Feel 에 의해 적절한 위치가 선택됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>event</CODE> - pop-up의 표시를 트리거한 <code>MouseEvent</code>,
마우스 이벤트의 결과로서 pop-up가 표시되지 않는 경우는
<code>null</code>
<DT><B>반환값:</B><DD><code>JPopupMenu</code> 가 표시되는 위치, 또는 <code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="createToolTip()"><!-- --></A> <H3>
createToolTip</H3>
<PRE>
public <A HREF="../../javax/swing/JToolTip.html" title="javax.swing 내의 클래스">JToolTip</A>  <B>createToolTip</B>()</PRE>
<DL>
<DD>툴팁를 표시하기 위해서 사용되는 <code>JToolTip</code> 의 인스턴스를 돌려줍니다. 일반적으로 컴퍼넌트는 이 메소드를 오버라이드(override) 하지 않습니다만, 이 메소드는 복수의 툴팁를 따로 따로 표시하기 위해서 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 툴팁 표시에 사용되는 <code>JToolTip</code></DL>
</DD>
</DL>
<HR>

<A NAME="scrollRectToVisible(java.awt.Rectangle)"><!-- --></A> <H3>
scrollRectToVisible</H3>
<PRE>
public void <B>scrollRectToVisible</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;aRect)</PRE>
<DL>
<DD><code>scrollRectToVisible()</code> 메세지를 <code>JComponent</code> 의 부모에게 전송 합니다. 이 요구를 처리할 수 있는 <code>JViewport</code> 등의 컴퍼넌트는, 이 메소드를 오버라이드(override) 해 스크롤을 실행합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aRect</CODE> - 가시 <code>Rectangle</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JViewport.html" title="javax.swing 내의 클래스"><CODE>JViewport</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setAutoscrolls(boolean)"><!-- --></A> <H3>
setAutoscrolls</H3>
<PRE>
public void <B>setAutoscrolls</B>(boolean&nbsp;autoscrolls)</PRE>
<DL>
<DD><code>autoscrolls</code> 프로퍼티을 설정합니다. <code>true</code> 의 경우, 마우스가 컴퍼넌트의 경계외에 드래그 되어 마우스의 버튼을 누른 채로 정지되면(자), 마우스 드래그 이벤트가 합성되어 생성됩니다. 합성 이벤트에서는, 컴퍼넌트의 경계를 넘어 드래그가 실행되었을 경우, 그 방향에의 드래그가 재개된 것처럼 가장합니다. 오토 스크롤을 지원하는 컴퍼넌트는, 마우스 이벤트 위치를 포함한 구형을 지정해 <code>scrollRectToVisible</code> 를 호출해,<code>mouseDragged</code> 이벤트를 처리할 필요가 있습니다. 항목 선택을 지원해,<code>JScrollPane</code> 에 표시되는 모든 Swing 컴퍼넌트 (<code>JTable</code>,<code>JList</code>,<code>JTree</code>,<code>JTextArea</code>, 및 <code>JEditorPane</code>)는, 이 방법에서의 마우스 드래그 이벤트 처리를 구현제입니다. 다른 컴퍼넌트로 오토 스크롤을 유효화하기 위해서(때문에)는,<code>scrollRectToVisible</code> 을 호출하는 마우스 모션 청취자를 추가합니다. <code>JPanel</code>,<code>myPanel</code> 에서의 예를 듭니다.
 <pre>
 MouseMotionListener doScrollRectToVisible = new MouseMotionAdapter() {
     public void mouseDragged(MouseEvent e) {
        Rectangle r = new Rectangle(e.getX(), e.getY(), 1, 1);
        ((JPanel) e.getSource()). scrollRectToVisible(r);
    }
 };
 myPanel.addMouseMotionListener(doScrollRectToVisible);
 </pre>
<code>autoScrolls</code> 프로퍼티의 디폴트 값는 <code>false</code> 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>autoscrolls</CODE> - true 의 경우는, mouse button를 누른채로 컴퍼넌트의 경계의 밖까지
마우스를 드래그 하면(자), 합성 마우스 드래그 이벤트가 생성된다.
false 의 경우는
생성되지 않는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getAutoscrolls()"><CODE>getAutoscrolls()</CODE></A> , 
<A HREF="../../javax/swing/JViewport.html" title="javax.swing 안의 클래스"><CODE>JViewport</CODE></A> , 
<A HREF="../../javax/swing/JScrollPane.html" title="javax.swing 안의 클래스"><CODE>JScrollPane</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAutoscrolls()"><!-- --></A> <H3>
getAutoscrolls</H3>
<PRE>
public boolean <B>getAutoscrolls</B>()</PRE>
<DL>
<DD><code>autoscrolls</code> 프로퍼티을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>autoscrolls</code> 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JViewport.html" title="javax.swing 내의 클래스"><CODE>JViewport</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setAutoscrolls(boolean)"><CODE>setAutoscrolls(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setTransferHandler(javax.swing.TransferHandler)"><!-- --></A> <H3>
setTransferHandler</H3>
<PRE>
public void <B>setTransferHandler</B>(<A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 안의 클래스">TransferHandler</A> &nbsp;newHandler)</PRE>
<DL>
<DD><code>transferHandler</code> 프로퍼티을 설정합니다. 컴퍼넌트가 데이터 전송 처리를 지원하고 있지 않는 경우는 <code>null</code> 가 돌려주어집니다.  &nbsp;<p>
<code>newHandler</code> 가 <code>null</code> 는 아니고, 시스템 프로퍼티 <code>suppressSwingDropSupport</code> 가 true 가 아닌 경우는,<code>JComponent</code> 의 <code>DropTarget</code> 를 인스톨 합니다. 이 시스템 프로퍼티의 디폴트는 false 이며,<code>DropTarget</code> 가 추가됩니다.  &nbsp;<p>
자세한 것은, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/dnd.html">「How to Use Drag and Drop and Data Transfer」</a>를 참조해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newHandler</CODE> - 컴퍼넌트와의 사이에 데이터를 전송 한다
방법<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 내의 클래스"><CODE>TransferHandler</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#getTransferHandler()"><CODE>getTransferHandler()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTransferHandler()"><!-- --></A> <H3>
getTransferHandler</H3>
<PRE>
public <A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 내의 클래스">TransferHandler</A>  <B>getTransferHandler</B>()</PRE>
<DL>
<DD><code>transferHandler</code> 프로퍼티을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>transferHandler</code> 프로퍼티의 값<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 내의 클래스"><CODE>TransferHandler</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setTransferHandler(javax.swing.TransferHandler)"><CODE>setTransferHandler(javax.swing.TransferHandler)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="processMouseEvent(java.awt.event.MouseEvent)"><!-- --></A> <H3>
processMouseEvent</H3>
<PRE>
protected void <B>processMouseEvent</B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;e)</PRE>
<DL>
<DD>이 컴퍼넌트로 발생하는 마우스 이벤트를, 등록되어 모든 <code>MouseListener</code> 객체에 발송 하는 것으로써, 마우스 이벤트를 처리합니다.  이 메소드의 상세한 것에 대하여는,<A HREF="../../java/awt/Component.html#processMouseEvent(java.awt.event.MouseEvent)"><CODE>Component.processMouseEvent(MouseEvent)</CODE></A>  를 참조해 주세요.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#processMouseEvent(java.awt.event.MouseEvent)">processMouseEvent</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 마우스 이벤트<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#processMouseEvent(java.awt.event.MouseEvent)"><CODE>Component.processMouseEvent(java.awt.event.MouseEvent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="processMouseMotionEvent(java.awt.event.MouseEvent)"><!-- --></A> <H3>
processMouseMotionEvent</H3>
<PRE>
protected void <B>processMouseMotionEvent</B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;e)</PRE>
<DL>
<DD>MouseEvent.MOUSE_DRAGGED 등의 마우스 모션 이벤트를 처리합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#processMouseMotionEvent(java.awt.event.MouseEvent)">processMouseMotionEvent</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - <code>MouseEvent</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 내의 클래스"><CODE>MouseEvent</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="enable()"><!-- --></A> <H3>
enable</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public void <B>enable</B>()</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK version 1.1 이후는,<code>java.awt.Component.setEnabled(boolean)</code> 로 옮겨졌습니다. </I>
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#enable()">enable</A> </CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="disable()"><!-- --></A> <H3>
disable</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public void <B>disable</B>()</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK version 1.1 이후는,<code>java.awt.Component.setEnabled(boolean)</code> 로 옮겨졌습니다. </I>
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#disable()">disable</A> </CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAccessibleContext()"><!-- --></A> <H3>
getAccessibleContext</H3>
<PRE>
public <A HREF="../../javax/accessibility/AccessibleContext.html" title="javax.accessibility 내의 클래스">AccessibleContext</A>  <B>getAccessibleContext</B>()</PRE>
<DL>
<DD><code>JComponent</code> 에 관련한 <code>AccessibleContext</code> 를 돌려줍니다. 이 base class에 의한 메소드 구현에서는 null 가 돌려주어집니다. <code>JComponent</code> 를 확장하는 클래스는, 이 메소드를 구현해, 서브 클래스에 관련지을 수 있었던 <code>AccessibleContext</code> 를 돌려주도록(듯이) 합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getAccessibleContext()">getAccessibleContext</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>JComponent</code> 의 <code>AccessibleContext</code></DL>
</DD>
</DL>
<HR>

<A NAME="getClientProperty(java.lang.Object)"><!-- --></A> <H3>
getClientProperty</H3>
<PRE>
public final <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getClientProperty</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key)</PRE>
<DL>
<DD>지정된 키를 가지는 프로퍼티의 값을 돌려줍니다. <code>putClientProperty</code> 로 추가된 프로퍼티만이 <code>null</code> 이외의 값을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 조회용의 키
<DT><B>반환값:</B><DD>이 프로퍼티의 값 또는 <code>null</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#putClientProperty(java.lang.Object, java.lang.Object)"><CODE>putClientProperty(java.lang.Object, java.lang.Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="putClientProperty(java.lang.Object, java.lang.Object)"><!-- --></A> <H3>
putClientProperty</H3>
<PRE>
public final void <B>putClientProperty</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key,
                                    <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;value)</PRE>
<DL>
<DD>임의의 키와 값을 조합한 클라이언트 프로퍼티을 이 컴퍼넌트에 추가합니다.  &nbsp;<p>
<code>get/putClientProperty</code> 메소드는, 인스턴스마다의 작은 해시 테이블에의 액세스를 제공합니다. 호출측은, getClientProperty 와 putClientProperty 를 사용해, 다른 모듈에 의해 생성된 컴퍼넌트에 주석을 붙입니다. 예를 들어, 레이아웃 매니저는 이 방법으로 아이마다의 제약을 포함하는 경우가 있습니다. 다음에 예를 나타냅니다.
 <pre>
 componentA.putClientProperty("to the left of", componentB);
 </pre>
값이 <code>null</code> 의 경우, 이 메소드는 그 프로퍼티을 삭제합니다. 클라이언트 프로퍼티에의 변경은,<code>PropertyChange</code> 이벤트로 보고됩니다. (PropertyChange 이벤트용의) 프로퍼티의 이름은,<code>key.toString()</code> 입니다.  &nbsp;<p>
<code>clientProperty</code> 의 사전는, JComponent 에의 대규모 확장 기능을 지원하는 것이 아닙니다. 또 새로운 컴퍼넌트를 설계할 때의 서브 클래스화의 대체라고 해도 사용할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 새로운 클라이언트 프로퍼티 키<DD><CODE>value</CODE> - 새로운 클라이언트 프로퍼티치. <code>null</code> 의 경우, 이 메소드는 프로퍼티을 삭제<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getClientProperty(java.lang.Object)"><CODE>getClientProperty(java.lang.Object)</CODE></A> , 
<A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.beans.PropertyChangeListener)"><CODE>Container.addPropertyChangeListener(java.beans.PropertyChangeListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setFocusTraversalKeys(int, java.util.Set)"><!-- --></A> <H3>
setFocusTraversalKeys</H3>
<PRE>
public void <B>setFocusTraversalKeys</B>(int&nbsp;id,
                                  <A HREF="../../java/util/Set.html" title="java.util 안의 인터페이스">Set</A> &lt;?  extends <A HREF="../../java/awt/AWTKeyStroke.html" title="java.awt 내의 클래스">AWTKeyStroke</A> &gt;&nbsp;keystrokes)</PRE>
<DL>
<DD>이 컴퍼넌트의 지정된 traversal 조작에 대한 포커스 traversal 키를 설정합니다. 이 메소드의 상세한 것에 대하여는,<A HREF="../../java/awt/Component.html#setFocusTraversalKeys(int, java.util.Set)"><CODE>Component.setFocusTraversalKeys(int, java.util.Set<?  extends java.awt.AWTKeyStroke>)</CODE></A>  를 참조해 주세요.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#setFocusTraversalKeys(int, java.util.Set)">setFocusTraversalKeys</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>id</CODE> - KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, 또는 KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS 의 어떤 것이나<DD><CODE>keystrokes</CODE> - 지정된 조작에 대한 AWTKeyStroke 세트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - id 가 KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, 또는 KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS 의 어떤 것도 아닌 경우, 키스트로크(keystroke)가 null 의 경우, 키스트로크(keystroke)의 객체의 어떤 것인가가 AWTKeyStroke 가 아닌 경우, 키스트로크(keystroke)의 어떤 것인가가 KEY_TYPED 이벤트를 나타내지 않은 경우, 또는 키스트로크(keystroke)의 어떤 것인가가 이 컴퍼넌트의 다른 포커스 traversal 조작에 맵 되고 있는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#FORWARD_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</CODE></A> , 
<A HREF="../../java/awt/KeyboardFocusManager.html#BACKWARD_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</CODE></A> , 
<A HREF="../../java/awt/KeyboardFocusManager.html#UP_CYCLE_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isLightweightComponent(java.awt.Component)"><!-- --></A> <H3>
isLightweightComponent</H3>
<PRE>
public static boolean <B>isLightweightComponent</B>(<A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A> &nbsp;c)</PRE>
<DL>
<DD>이 컴퍼넌트가 경량의 경우, 즉 네이티브의 윈도우 시스템 피어를 가지지 않는 경우에 true 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트가 경량의 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="reshape(int, int, int, int)"><!-- --></A> <H3>
reshape</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public void <B>reshape</B>(int&nbsp;x,
                               int&nbsp;y,
                               int&nbsp;w,
                               int&nbsp;h)</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>JDK 5 이후는,<code>Component.setBounds(int, int, int, int)</code> 로 옮겨졌습니다.

 <p>
이 컴퍼넌트를 이동해, 사이즈 변경합니다. </I>
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#reshape(int, int, int, int)">reshape</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 새로운 수평 방향의 위치<DD><CODE>y</CODE> - 새로운 수직 방향의 위치<DD><CODE>w</CODE> - 신규폭<DD><CODE>h</CODE> - 신규 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#setBounds(int, int, int, int)"><CODE>Component.setBounds(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBounds(java.awt.Rectangle)"><!-- --></A> <H3>
getBounds</H3>
<PRE>
public <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getBounds</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;rv)</PRE>
<DL>
<DD>이 컴퍼넌트의 경계를 「반환값」<code>rv</code> 에 포함해,<code>rv</code> 를 돌려줍니다. <code>rv</code> 가 <code>null</code> 의 경우, 새로운 <code>Rectangle</code> 를 할당할 수 있습니다. 이 버젼의 <code>getBounds</code> 는, 호출측이 heap로 새로운 <code>Rectangle</code> 객체를 할당하고 싶지 않은 경우에 편리합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getBounds(java.awt.Rectangle)">getBounds</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rv</CODE> - 컴퍼넌트의 경계가 포함된 반환값
<DT><B>반환값:</B><DD><code>rv</code>. <code>rv</code> 가 <code>null</code> 의 경우는 새롭게 작성된 <code>Rectangle</code> 와 컴퍼넌트의 경계를 돌려준다</DL>
</DD>
</DL>
<HR>

<A NAME="getSize(java.awt.Dimension)"><!-- --></A> <H3>
getSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getSize</B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;rv)</PRE>
<DL>
<DD>이 컴퍼넌트의 폭과 높이를 「반환값」<code>rv</code> 에 포함해,<code>rv</code> 를 돌려줍니다. <code>rv</code> 가 <code>null</code> 의 경우, 새로운 <code>Dimension</code> 객체를 할당할 수 있습니다. 이 버젼의 <code>getSize</code> 는, 호출측이 heap로 새로운 <code>Dimension</code> 객체를 할당하고 싶지 않은 경우에 편리합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getSize(java.awt.Dimension)">getSize</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rv</CODE> - 컴퍼넌트의 사이즈가 포함된 반환값
<DT><B>반환값:</B><DD><code>rv</code></DL>
</DD>
</DL>
<HR>

<A NAME="getLocation(java.awt.Point)"><!-- --></A> <H3>
getLocation</H3>
<PRE>
public <A HREF="../../java/awt/Point.html" title="java.awt 내의 클래스">Point</A>  <B>getLocation</B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;rv)</PRE>
<DL>
<DD>이 컴퍼넌트의 원점의 x, y 좌표를 「반환값」<code>rv</code> 에 포함해,<code>rv</code> 를 돌려줍니다. <code>rv</code> 가 <code>null</code> 의 경우, 새로운 <code>Point</code> 를 할당할 수 있습니다. 이 버젼의 <code>getLocation</code> 는, 호출측이 heap로 새로운 <code>Point</code> 객체를 할당하고 싶지 않은 경우에 편리합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getLocation(java.awt.Point)">getLocation</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rv</CODE> - 컴퍼넌트의 위치가 포함된 반환값
<DT><B>반환값:</B><DD><code>rv</code></DL>
</DD>
</DL>
<HR>

<A NAME="getX()"><!-- --></A> <H3>
getX</H3>
<PRE>
public int <B>getX</B>()</PRE>
<DL>
<DD>컴퍼넌트의 원점의 현재의 x 좌표를 돌려줍니다. 이 메소드는, heap 할당이 발생하지 않기 때문에,<code>component.getBounds(). x</code> 또는 <code>component.getLocation(). x</code> 보다 적절합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getX()">getX</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>컴퍼넌트의 원점의 현재의 x 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="getY()"><!-- --></A> <H3>
getY</H3>
<PRE>
public int <B>getY</B>()</PRE>
<DL>
<DD>컴퍼넌트의 원점의 현재의 y 좌표를 돌려줍니다. 이 메소드는, heap 할당이 발생하지 않기 때문에,<code>component.getBounds(). y</code> 또는 <code>component.getLocation(). y</code> 보다 적절합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getY()">getY</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>컴퍼넌트의 원점의 현재의 y 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="getWidth()"><!-- --></A> <H3>
getWidth</H3>
<PRE>
public int <B>getWidth</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 현재의 폭을 돌려줍니다. 이 메소드는, heap의 할당이 발생하지 않기 때문에,<code>component.getBounds(). width</code> 또는 <code>component.getSize(). width</code> 보다 적절합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getWidth()">getWidth</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트의 현재의 폭</DL>
</DD>
</DL>
<HR>

<A NAME="getHeight()"><!-- --></A> <H3>
getHeight</H3>
<PRE>
public int <B>getHeight</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 현재의 높이를 돌려줍니다. 이 메소드는, heap의 할당이 발생하지 않기 때문에,<code>component.getBounds(). height</code> 또는 <code>component.getSize(). height</code> 보다 적절합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getHeight()">getHeight</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트의 현재의 높이</DL>
</DD>
</DL>
<HR>

<A NAME="isOpaque()"><!-- --></A> <H3>
isOpaque</H3>
<PRE>
public boolean <B>isOpaque</B>()</PRE>
<DL>
<DD>이 컴퍼넌트가 완전하게 불투명한 경우에 true 를 돌려줍니다.  &nbsp;<p>
불투명한 컴퍼넌트는 그 구형 경계내의 모든 픽셀을 그립니다. 불투명하지 않는 컴퍼넌트는 그 픽셀의 부분집합만을 페인트 하는지, 전혀 페인트 하지 않기 때문에, 그 아래의 픽셀을 틈이 날 수 있어 표시됩니다. 그 때문에, 모든 픽셀을 페인트 하지 않는 컴퍼넌트는 어느 정도의 투명도가 있습니다.  &nbsp;<p>
항상 그 내용을 완전하게 페인트 하는 서브 클래스는, 이 메소드를 오버라이드(override) 해, true 를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#isOpaque()">isOpaque</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트가 완전하게 불투명한 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setOpaque(boolean)"><CODE>setOpaque(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setOpaque(boolean)"><!-- --></A> <H3>
setOpaque</H3>
<PRE>
public void <B>setOpaque</B>(boolean&nbsp;isOpaque)</PRE>
<DL>
<DD>true 의 경우, 컴퍼넌트는 그 경계내의 모든 픽셀을 그립니다. false 의 경우, 컴퍼넌트는 픽셀의 일부 또는 전부를 페인트 하지 않기 때문에, 그 아래의 픽셀을 틈이 날 수 있어 표시됩니다.  &nbsp;<p>
<code>JComponent</code> 에 대한 이 프로퍼티의 디폴트 값는, false 입니다. 다만, 가장 표준적인 <code>JComponent</code> 의 서브 클래스 (<code>JButton</code> 및 <code>JTree</code> 등)에 대한 이 프로퍼티의 디폴트 값는, Look & Feel 에 의존합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>isOpaque</CODE> - 이 컴퍼넌트가 불투명한 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#isOpaque()"><CODE>isOpaque()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="computeVisibleRect(java.awt.Rectangle)"><!-- --></A> <H3>
computeVisibleRect</H3>
<PRE>
public void <B>computeVisibleRect</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;visibleRect)</PRE>
<DL>
<DD><code>Component</code> 의 「가시 구형」을 돌려줍니다.  이것은, 이 컴퍼넌트와 그 모든 상위 객체의 가시 구형의 공통 부분입니다. 반환값은,<code>visibleRect</code> 에 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>visibleRect</CODE> - 이 컴퍼넌트와 그 모든 상위 객체의 가시 구형의 공통 부분으로서 요구되는 <code>Rectangle</code>. 이것은 이 메소드의 반환값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getVisibleRect()"><CODE>getVisibleRect()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getVisibleRect()"><!-- --></A> <H3>
getVisibleRect</H3>
<PRE>
public <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getVisibleRect</B>()</PRE>
<DL>
<DD>이것은 이 메소드의 반환값입니다.  <code>Component</code> 의 「가시 구형」을 돌려줍니다.  이것은, 이 컴퍼넌트의 가시 구형,<code>new Rectangle(0, 0, getWidth(), getHeight())</code>, 및 그 모든 상위 객체의 가시 구형의 공통 부분입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>가시 구형</DL>
</DD>
</DL>
<HR>

<A NAME="firePropertyChange(java.lang.String, boolean, boolean)"><!-- --></A> <H3>
firePropertyChange</H3>
<PRE>
public void <B>firePropertyChange</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                               boolean&nbsp;oldValue,
                               boolean&nbsp;newValue)</PRE>
<DL>
<DD>boolean 형 프로퍼티에 대한 바운드 프로퍼티의 변경의 보고를 지원합니다. 이 메소드는, 바운드 프로퍼티이 변경되었을 때에 불려 가 등록되어 모든 PropertyChangeListener 에, 대응하는 PropertyChangeEvent 를 보냅니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, boolean, boolean)">firePropertyChange</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>propertyName</CODE> - 치가 변경된 프로퍼티<DD><CODE>oldValue</CODE> - 프로퍼티의 이전의 값<DD><CODE>newValue</CODE> - 프로퍼티의 새로운 값</DL>
</DD>
</DL>
<HR>

<A NAME="firePropertyChange(java.lang.String, int, int)"><!-- --></A> <H3>
firePropertyChange</H3>
<PRE>
public void <B>firePropertyChange</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                               int&nbsp;oldValue,
                               int&nbsp;newValue)</PRE>
<DL>
<DD>정수형 프로퍼티에 대한 바운드 프로퍼티의 변경의 보고를 지원합니다. 이 메소드는, 바운드 프로퍼티이 변경되었을 때에 불려 가 등록되어 모든 PropertyChangeListener 에, 대응하는 PropertyChangeEvent 를 보냅니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, int, int)">firePropertyChange</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>propertyName</CODE> - 치가 변경된 프로퍼티<DD><CODE>oldValue</CODE> - 프로퍼티의 이전의 값<DD><CODE>newValue</CODE> - 프로퍼티의 새로운 값</DL>
</DD>
</DL>
<HR>

<A NAME="firePropertyChange(java.lang.String, char, char)"><!-- --></A> <H3>
firePropertyChange</H3>
<PRE>
public void <B>firePropertyChange</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                               char&nbsp;oldValue,
                               char&nbsp;newValue)</PRE>
<DL>
<DD><B>클래스 <CODE><A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, char, char)">Component</A> </CODE> 의 기술:</B></DD>
<DD>바운드 프로퍼티의 변경을 통지합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, char, char)">firePropertyChange</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>propertyName</CODE> - 변경된 프로퍼티의
프로그램상의 이름<DD><CODE>oldValue</CODE> - 프로퍼티의 변경전의 값 (char)<DD><CODE>newValue</CODE> - 프로퍼티의 변경 후의 값 (char)<DT><B>관련 항목:</B><DD><CODE>#firePropertyChange(java.lang.String, java.lang.Object,</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="fireVetoableChange(java.lang.String, java.lang.Object, java.lang.Object)"><!-- --></A> <H3>
fireVetoableChange</H3>
<PRE>
protected void <B>fireVetoableChange</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                                  <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;oldValue,
                                  <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;newValue)
                           throws <A HREF="../../java/beans/PropertyVetoException.html" title="java.beans 내의 클래스">PropertyVetoException</A> </PRE>
<DL>
<DD>제약 프로퍼티의 변경의 보고를 지원합니다. 이 메소드는, 제약 프로퍼티이 변경되었을 때에 불려 가 등록되어 모든 <code>VetoableChangeListeners</code> 에 대응하는 <code>PropertyChangeEvent</code> 를 송신합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>propertyName</CODE> - 대기하고 있던 프로퍼티의 이름<DD><CODE>oldValue</CODE> - 프로퍼티의 변경전의 값<DD><CODE>newValue</CODE> - 프로퍼티의 변경 후의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/beans/PropertyVetoException.html" title="java.beans 안의 클래스">PropertyVetoException</A> </CODE> - 프로퍼티을 설정하려고 해 수신 측에야는 거부되었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="addVetoableChangeListener(java.beans.VetoableChangeListener)"><!-- --></A> <H3>
addVetoableChangeListener</H3>
<PRE>
public void <B>addVetoableChangeListener</B>(<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 안의 인터페이스">VetoableChangeListener</A> &nbsp;listener)</PRE>
<DL>
<DD><code>VetoableChangeListener</code> 를 청취자 리스트에 추가합니다. 청취자는, 모든 프로퍼티에 대해서 등록됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listener</CODE> - 추가되는 <code>VetoableChangeListener</code></DL>
</DD>
</DL>
<HR>

<A NAME="removeVetoableChangeListener(java.beans.VetoableChangeListener)"><!-- --></A> <H3>
removeVetoableChangeListener</H3>
<PRE>
public void <B>removeVetoableChangeListener</B>(<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 안의 인터페이스">VetoableChangeListener</A> &nbsp;listener)</PRE>
<DL>
<DD><code>VetoableChangeListener</code> 를 청취자 리스트로부터 삭제합니다. 모든 프로퍼티에 등록된 <code>VetoableChangeListener</code> 를 삭제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listener</CODE> - 삭제되는 <code>VetoableChangeListener</code></DL>
</DD>
</DL>
<HR>

<A NAME="getVetoableChangeListeners()"><!-- --></A> <H3>
getVetoableChangeListeners</H3>
<PRE>
public <A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 내의 인터페이스">VetoableChangeListener</A> [] <B>getVetoableChangeListeners</B>()</PRE>
<DL>
<DD>이 컴퍼넌트에 등록되어 모든 거부 가능 변경 청취자의 배열을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>컴퍼넌트의 모든 <code>VetoableChangeListener</code>, 또는

거부 가능 변경 청취자가 현재 등록되지 않은 경우는 빈 상태(empty)의 배열<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#addVetoableChangeListener(java.beans.VetoableChangeListener)"><CODE>addVetoableChangeListener(java.beans.VetoableChangeListener)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#removeVetoableChangeListener(java.beans.VetoableChangeListener)"><CODE>removeVetoableChangeListener(java.beans.VetoableChangeListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTopLevelAncestor()"><!-- --></A> <H3>
getTopLevelAncestor</H3>
<PRE>
public <A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A>  <B>getTopLevelAncestor</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 톱 레벨의 상위 객체 (포함처의 Window 또는 Applet)를 돌려줍니다. 이 컴퍼넌트가 어느 컨테이너에도 추가되어 있지 않은 경우는 null 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트가 포함되는 톱 레벨의 <code>Container</code>.
                어느 컨테이너에도 포함되지 않는 경우는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="addAncestorListener(javax.swing.event.AncestorListener)"><!-- --></A> <H3>
addAncestorListener</H3>
<PRE>
public void <B>addAncestorListener</B>(<A HREF="../../javax/swing/event/AncestorListener.html" title="javax.swing.event 안의 인터페이스">AncestorListener</A> &nbsp;listener)</PRE>
<DL>
<DD><code>listener</code> 를 등록해, 컴퍼넌트 또는 게다가 위객체가 이동하든가, 혹은 가시 또는 불가시가 될 때 그 청취자가 <code>AncestorEvent</code> 를 받아들이도록(듯이) 합니다. 이벤트는, 컴퍼넌트 또는 게다가 위객체가 포함 관계의 계층에 추가되는지, 또는 삭제될 때도 송신됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listener</CODE> - 등록하는 <code>AncestorListener</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/AncestorEvent.html" title="javax.swing.event 내의 클래스"><CODE>AncestorEvent</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="removeAncestorListener(javax.swing.event.AncestorListener)"><!-- --></A> <H3>
removeAncestorListener</H3>
<PRE>
public void <B>removeAncestorListener</B>(<A HREF="../../javax/swing/event/AncestorListener.html" title="javax.swing.event 안의 인터페이스">AncestorListener</A> &nbsp;listener)</PRE>
<DL>
<DD><code>listener</code> 의 등록을 해제해, 그 청취자가 <code>AncestorEvent</code> 를 받지 않게 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listener</CODE> - 삭제하는 <code>AncestorListener</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#addAncestorListener(javax.swing.event.AncestorListener)"><CODE>addAncestorListener(javax.swing.event.AncestorListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAncestorListeners()"><!-- --></A> <H3>
getAncestorListeners</H3>
<PRE>
public <A HREF="../../javax/swing/event/AncestorListener.html" title="javax.swing.event 내의 인터페이스">AncestorListener</A> [] <B>getAncestorListeners</B>()</PRE>
<DL>
<DD>이 컴퍼넌트에 등록되어 모든 상위 청취자의 배열을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>컴퍼넌트의 모든 <code>AncestorListener</code>, 
상위 청취자가 현재 등록되지 않은 경우는 빈 상태(empty)의 배열<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#addAncestorListener(javax.swing.event.AncestorListener)"><CODE>addAncestorListener(javax.swing.event.AncestorListener)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#removeAncestorListener(javax.swing.event.AncestorListener)"><CODE>removeAncestorListener(javax.swing.event.AncestorListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getListeners(java.lang.Class)"><!-- --></A> <H3>
getListeners</H3>
<PRE>
public &lt;T extends <A HREF="../../java/util/EventListener.html" title="java.util 내의 인터페이스">EventListener</A> &gt; T[] <B>getListeners</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;T&gt;&nbsp;listenerType)</PRE>
<DL>
<DD>이 <code>JComponent</code> 에 <code><em>Foo</em>Listener</code> 로서 현재 등록되어 모든 객체의 배열을 돌려줍니다. <code><em>Foo</em>Listener</code> 는,<code>add<em>Foo</em>Listener</code> 메소드를 사용해 등록합니다.

 <p>
 
<code><em>Foo</em>Listener.class</code> 라고 하는 클래스 리터럴을 사용해,<code>listenerType</code> 인수를 지정할 수 있습니다. 예를 들어, 이 마우스 청취자에 대한 <code>JComponent</code> <code>c</code> 의 조회는 다음의 코드로 실시합니다.
 <pre>MouseListener[] mls = (MouseListener[])(c.getListeners(MouseListener.class));</pre>
이러한 청취자가 없는 경우는 빈 상태(empty)의 배열을 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getListeners(java.lang.Class)">getListeners</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listenerType</CODE> - 요구되는 청취자의 형태. <code>java.util.EventListener</code> 의 하위 인터페이스를 지정
<DT><B>반환값:</B><DD>컴퍼넌트에 <code><em>Foo</em>Listener</code> 로서 등록되어 모든 객체의 배열. 청취자가 등록되지 않은 경우는 빈 상태(empty)의 배열을 돌려준다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <code>listenerType</code> 가
<code>java.util.EventListener</code> 를 구현하는 클래스 또는 인터페이스를 지정하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getVetoableChangeListeners()"><CODE>getVetoableChangeListeners()</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#getAncestorListeners()"><CODE>getAncestorListeners()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="addNotify()"><!-- --></A> <H3>
addNotify</H3>
<PRE>
public void <B>addNotify</B>()</PRE>
<DL>
<DD>이 컴퍼넌트에 현재친컴퍼넌트가 있는 것을, 이 컴퍼넌트에 통지합니다. 이 메소드가 불려 가면(자), 친컴퍼넌트의 체인이 <code>KeyboardAction</code> 이벤트 청취자로 설정됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#addNotify()">addNotify</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)"><CODE>registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="removeNotify()"><!-- --></A> <H3>
removeNotify</H3>
<PRE>
public void <B>removeNotify</B>()</PRE>
<DL>
<DD>이 컴퍼넌트에 친컴퍼넌트가 없어진 것을, 이 컴퍼넌트에 통지합니다. 이 메소드가 불려 가면(자), 친컴퍼넌트의 체인으로 설정된 <code>KeyboardAction</code> 가 삭제됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#removeNotify()">removeNotify</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)"><CODE>registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="repaint(long, int, int, int, int)"><!-- --></A> <H3>
repaint</H3>
<PRE>
public void <B>repaint</B>(long&nbsp;tm,
                    int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height)</PRE>
<DL>
<DD>컴퍼넌트가 표시되고 있는 경우에, 지정된 영역을 더티 리젼 리스트에 추가합니다. 컴퍼넌트는, 현재 보류 떠날 수 있어 모든 이벤트가 발송 된 뒤에 재페인트 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#repaint(long, int, int, int, int)">repaint</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tm</CODE> - 이 파라미터는 사용되지 않습니다<DD><CODE>x</CODE> - 더티 리젼의 x 좌표<DD><CODE>y</CODE> - 더티 리젼의 y 좌표<DD><CODE>width</CODE> - 더티 리젼의 폭<DD><CODE>height</CODE> - 더티 리젼의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#isShowing()"><CODE>Component.isShowing()</CODE></A> , 
<A HREF="../../javax/swing/RepaintManager.html#addDirtyRegion(javax.swing.JComponent, int, int, int, int)"><CODE>RepaintManager.addDirtyRegion(javax.swing.JComponent, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="repaint(java.awt.Rectangle)"><!-- --></A> <H3>
repaint</H3>
<PRE>
public void <B>repaint</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;r)</PRE>
<DL>
<DD>컴퍼넌트가 표시되고 있는 경우에, 지정된 영역을 더티 리젼 리스트에 추가합니다. 컴퍼넌트는, 현재 보류 떠날 수 있어 모든 이벤트가 발송 된 뒤에 재페인트 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>r</CODE> - 더티 리젼을 포함한 <code>Rectangle</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#isShowing()"><CODE>Component.isShowing()</CODE></A> , 
<A HREF="../../javax/swing/RepaintManager.html#addDirtyRegion(javax.swing.JComponent, int, int, int, int)"><CODE>RepaintManager.addDirtyRegion(javax.swing.JComponent, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="revalidate()"><!-- --></A> <H3>
revalidate</H3>
<PRE>
public void <B>revalidate</B>()</PRE>
<DL>
<DD>지연 자동 레이아웃을 지원합니다.  &nbsp;<p> 
<code>invalidate</code> 를 호출해, 다음에 이 컴퍼넌트의 <code>validateRoot</code> 를, 검증될 필요가 있는 컴퍼넌트의 리스트에 추가합니다. 검증은, 현재 보류 떠날 수 있어 모든 이벤트가 발송 된 뒤에 행해집니다. 즉, 이 메소드가 불려 간 뒤, 이 컴퍼넌트의 포함 관계의 계층의 상위에서 최초로 발견된 validateRoot 가 검증됩니다. 디폴트에서는,<code>JRootPane</code>,<code>JScrollPane</code>, 및 <code>JTextField</code> 이 <code>isValidateRoot</code> 로부터 true 를 돌려줍니다.  &nbsp;<p>
이 메소드는, 이 컴퍼넌트의 사이즈, 위치, 또는 내부 레이아웃에 영향을 주는 프로퍼티치의 변경이 있었을 때에, 컴퍼넌트에 대해서 자동적으로 불려 갑니다. 이 자동적인 갱신은, 프로그램이, 일반적으로, GUI 의 내용을 갱신하기 위해서 <code>validate</code> 를 호출할 필요가 없다고 하는 점으로써 AWT 와는 다릅니다.  &nbsp;<p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#invalidate()"><CODE>Component.invalidate()</CODE></A> , 
<A HREF="../../java/awt/Container.html#validate()"><CODE>Container.validate()</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#isValidateRoot()"><CODE>isValidateRoot()</CODE></A> , 
<A HREF="../../javax/swing/RepaintManager.html#addInvalidComponent(javax.swing.JComponent)"><CODE>RepaintManager.addInvalidComponent(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isValidateRoot()"><!-- --></A> <H3>
isValidateRoot</H3>
<PRE>
public boolean <B>isValidateRoot</B>()</PRE>
<DL>
<DD>이 메소드가 true 를 돌려주는 경우, 이 컴퍼넌트의 하위 컴퍼넌트에 의해 <code>revalidate</code> 가 불려 가면(자), 이 루트로 시작되는 트리 전체가 검증됩니다. 디폴트에서는 false 를 돌려줍니다. <code>JScrollPane</code> 는 이 메소드를 오버라이드(override) 해, true 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>항상 false 를 돌려주는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#revalidate()"><CODE>revalidate()</CODE></A> , 
<A HREF="../../java/awt/Component.html#invalidate()"><CODE>Component.invalidate()</CODE></A> , 
<A HREF="../../java/awt/Container.html#validate()"><CODE>Container.validate()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isOptimizedDrawingEnabled()"><!-- --></A> <H3>
isOptimizedDrawingEnabled</H3>
<PRE>
public boolean <B>isOptimizedDrawingEnabled</B>()</PRE>
<DL>
<DD>이 컴퍼넌트가 그 아이를 타일링 하는 경우, 즉 아이가 오버랩 하지 않는 것이 보증되는 경우에 true 를 돌려줍니다. 일반적으로는, 재페인트 시스템 쪽이 꽤 효율적입니다. <code>JLayeredPane</code> 등, 이 보증을 할 수 없는 <code>JComponent</code> 의 서브 클래스는, 이 메소드를 오버라이드(override) 해 false 를 돌려줄 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>항상 true 를 돌려준다</DL>
</DD>
</DL>
<HR>

<A NAME="paintImmediately(int, int, int, int)"><!-- --></A> <H3>
paintImmediately</H3>
<PRE>
public void <B>paintImmediately</B>(int&nbsp;x,
                             int&nbsp;y,
                             int&nbsp;w,
                             int&nbsp;h)</PRE>
<DL>
<DD>이 컴퍼넌트의 지정된 영역, 및 그 영역과 오버랩 하는 모든 하위 컴퍼넌트를 곧바로 그립니다.  &nbsp;<p>
이 메소드를 호출할 필요는 거의 없습니다. 대부분의 경우, 실제의 페인트를 늦추어 장황한 요구를 단일의 paint 호출해에 집약할 수가 있는 repaint 를 호출하는 편이 보다 효율적입니다. 이 메소드는, 현재의 이벤트가 발송 되고 있을 때 표시를 갱신할 필요가 있는 경우에는 편리합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 페인트 영역의 x 좌표<DD><CODE>y</CODE> - 페인트 영역의 y 좌표<DD><CODE>w</CODE> - 페인트 영역의 폭<DD><CODE>h</CODE> - 페인트 영역의 높이<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#repaint(long, int, int, int, int)"><CODE>repaint(long, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="paintImmediately(java.awt.Rectangle)"><!-- --></A> <H3>
paintImmediately</H3>
<PRE>
public void <B>paintImmediately</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;r)</PRE>
<DL>
<DD>지정된 영역을 곧바로 그립니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>r</CODE> - 페인트 하는 영역을 포함한 <code>Rectangle</code></DL>
</DD>
</DL>
<HR>

<A NAME="setDoubleBuffered(boolean)"><!-- --></A> <H3>
setDoubleBuffered</H3>
<PRE>
public void <B>setDoubleBuffered</B>(boolean&nbsp;aFlag)</PRE>
<DL>
<DD>이 컴퍼넌트가 버퍼를 사용해 페인트 할지 어떨지를 설정합니다. true 로 설정되어 있는 경우, 이 컴퍼넌트로부터의 모든 draw는 오프 스크린 draw 버퍼로 행해집니다. 그리고 오프 스크린 draw 버퍼가 화면에 카피됩니다. <code>Component</code> 가 버퍼링 되고 있어 게다가 위객체도 버퍼링 되고 있는 경우, 상위 객체의 버퍼가 사용됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aFlag</CODE> - true 의 경우, 이 컴퍼넌트로 더블 버퍼를 사용하도록(듯이) 설정</DL>
</DD>
</DL>
<HR>

<A NAME="isDoubleBuffered()"><!-- --></A> <H3>
isDoubleBuffered</H3>
<PRE>
public boolean <B>isDoubleBuffered</B>()</PRE>
<DL>
<DD>이 컴퍼넌트가 버퍼를 사용해 페인트 할지 어떨지를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#isDoubleBuffered()">isDoubleBuffered</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트가 더블 버퍼를 사용하는 경우는 true, 그렇지 않은 경우는 false</DL>
</DD>
</DL>
<HR>

<A NAME="getRootPane()"><!-- --></A> <H3>
getRootPane</H3>
<PRE>
public <A HREF="../../javax/swing/JRootPane.html" title="javax.swing 내의 클래스">JRootPane</A>  <B>getRootPane</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 <code>JRootPane</code> 상위 컴퍼넌트를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트를 포함하는 <code>JRootPane</code>.
                <code>JRootPane</code> 가 발견되지 않는 경우는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="paramString()"><!-- --></A> <H3>
paramString</H3>
<PRE>
protected <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>paramString</B>()</PRE>
<DL>
<DD>이 <code>JComponent</code> 의 캐릭터 라인 표현을 돌려줍니다. 이 메소드는 디버그 전용이며, 반환되는 캐릭터 라인의 내용 및 형식은 구현에 따라서 다릅니다. 반환되는 캐릭터 라인은 빈 상태(empty)의 경우가 있습니다만,<code>null</code> 로는 되지 않습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#paramString()">paramString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>JComponent</code> 의 캐릭터 라인 표현</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JComponent.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/swing/JComboBox.KeySelectionManager.html" title="javax.swing 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/swing/JComponent.AccessibleJComponent.html" title="javax.swing 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/swing/JComponent.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="JComponent.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
