<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:32:51 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
LookAndFeel (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="LookAndFeel (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LookAndFeel.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/swing/MenuElement.html" title="javax.swing 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/swing/LookAndFeel.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="LookAndFeel.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.swing</FONT>
<BR>
클래스 LookAndFeel</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.swing.LookAndFeel</B>
</PRE>
<DL>
<DT><B>직계의 기존의 서브 클래스:</B> <DD><A HREF="../../javax/swing/plaf/basic/BasicLookAndFeel.html" title="javax.swing.plaf.basic 내의 클래스">BasicLookAndFeel</A> , <A HREF="../../javax/swing/plaf/multi/MultiLookAndFeel.html" title="javax.swing.plaf.multi 안의 클래스">MultiLookAndFeel</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>LookAndFeel</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
<code>LookAndFeel</code> 는, 그 이름이 가리키는 대로, Look & Feel 를 캡슐화합니다. Look & Feel 의 인스톨시 이외에, 개발자가 직접 <code>LookAndFeel</code> 와 정보를 교환하는 것은, 거의 없습니다. 일반적으로은, 개발자가 Look & Feel 를 커스터마이즈 하는 경우에게만, 이 클래스에 주의할 필요가 있습니다.  &nbsp;<p>
Swing 의 구축 기반에서는, 각 <code>JComponent</code> 서브 클래스가 특정의 <code>ComponentUI</code> 서브 클래스의 구현을 가지고 있습니다. <code>ComponentUI</code> 는, 일반적으로, 「UI」, 「컴퍼넌트 UI」, 「Look & Feel 의 위양」 등으로 불립니다. <code>ComponentUI</code> 서브 클래스는, 컴퍼넌트의 특정의 기능의 Look & Feel 를 제공합니다. 예를 들어,<code>JTree</code> 는,<code>ComponentUI</code> 서브 클래스 <code>TreeUI</code> 의 구현을 필요로 합니다. 특정의 <code>ComponentUI</code> 서브 클래스의 구현은,<code>LookAndFeel</code> 에 의해 제공됩니다. 각 <code>JComponent</code> 서브 클래스는,<code>JComponent</code> 메소드 <code>getUIClassID</code> 를 사용해, 필요한 <code>ComponentUI</code> 서브 클래스를 식별합니다.  &nbsp;<p>
각 <code>LookAndFeel</code> 구현은,<code>getDefaults</code> 로부터 반환되는,<code>UIDefaults</code> 객체내에 각 Swing UI 클래스 ID 의 값을 지정하는 것으로써, 적절한 <code>ComponentUI</code> 서브 클래스의 구현을 제공할 필요가 있습니다. 예를 들어,<code>BasicLookAndFeel</code> 는,<code>BasicTreeUI</code> 를 <code>TreeUI</code> 의 구상 구현으로서 사용합니다. 이 때문에,<code>BasicLookAndFeel</code> 는,<code>getDefaults</code> 로부터 반환되는 <code>UIDefaults</code> 내에 키와 값의 페어 <code>"TreeUI"-"javax.swing.plaf.basic.BasicTreeUI"</code> 를 지정합니다. <code>ComponentUI</code> 서브 클래스의 구현을 취득하는 방법에 대해서는,<A HREF="../../javax/swing/UIDefaults.html#getUI(javax.swing.JComponent)"><CODE>UIDefaults.getUI(JComponent)</CODE></A>  를 참조해 주세요.  &nbsp;<p>
<code>LookAndFeel</code> 가 인스톨 될 때,<code>UIManager</code> 는 모든 UI 클래스 ID 의 엔트리가 존재할지 어떨지를 확인하지 않습니다. 이 때문에, 현재의 Look & Feel 로 특정의 UI 클래스 ID 의 값이 지정되지 않고,<code>JComponent</code> 서브 클래스의 인스턴스가 작성되고 있는 경우, 랜덤 예외가 발생합니다.

<h2>Look & Feel 의 추천 사항</h2>

<code>UIManager</code> 에 기재되어 있는 대로, 각 <code>LookAndFeel</code> 에, 개발자나 시스템의 디폴트에 의해 계층화 된 디폴트세트를 제공할 기회가 주어집니다. 일부의 Swing 컴퍼넌트는, 특정의 디폴트세트를 제공하기 위해서 Look & Feel 를 요구합니다. 이것들에 대해서는, 특정의 디폴트를 필요로 하는 개개의 클래스에 문서화 되고 있습니다.

<h3><a name="#defaultRecommendation">ComponentUI 와 디폴트</a> </h2>

일반적으로, 모든 <code>ComponentUI</code> 는, 자신이 Look & Feel 를 제공하는 <code>JComponent</code> 상에 다양한 프로퍼티을 설정할 필요가 있습니다. 이 처리는, 일반적으로,<code>ComponentUI</code> 가 <code>JComponent</code> 상에 인스톨 될 때 행해집니다. 프로퍼티의 설정은, 개발자가 프로퍼티을 설정하고 있지 않는 경우에게만 행해져야 합니다. 값이 비프리미티브(primitive)인 경우는, 현재의 값이 <code>null</code> 인지,<code>UIResource</code> 를 구현하고 있는 경우에게만,<code>JComponent</code> 상에서 <code>ComponentUI</code> 가 프로퍼티을 변경하도록 해 주세요. 현재의 값이 <code>null</code> 인지,<code>UIResource</code> 를 구현하고 있는 경우는, 개발자가 프로퍼티을 설정해 있습니다. 이 때문에, UI 를 자유롭게 변경할 수 있습니다. 예를 들어,<code>BasicButtonUI.installDefaults</code> 는,<code>button.getFont()</code> 의 반환값이 <code>null</code> 인지,<code>UIResource</code> 를 구현하고 있는 경우에게만,<code>JButton</code> 의 폰트를 변경합니다. 한편,<code>button.getFont()</code> 의 반환값이 <code>null 이외</code> 로,<code>UIResource</code> 를 구현하고 있지 않는 경우,<code>BasicButtonUI.installDefaults</code> 는 <code>JButton</code> 의 폰트를 변경하지 않습니다.  &nbsp;<p>
값이 프리미티브(primitive)인 경우, 예를 들어<code>불투명</code> 인 경우는,<code>installProperty</code> 메소드가 불려 갈 것입니다. <code>installProperty</code> 는, 개발자가 값을 변경하고 있지 않는 경우에게만, 대응하는 프로퍼티을 변경합니다.  &nbsp;<p>
<code>ComponentUI</code> 구현은, 추천 가이드 라인에 따라 필요한 체크를 실시해, 프로퍼티을 인스톨 할 경우에, 이 클래스가 제공하는 다양한 인스톨 메소드를 사용합니다.  &nbsp;<p>
<h3><a name="exceptions"></a> 예외</h3>

변경되는 프로퍼티의 값이 <code>null</code> 또는 <code>UIResource</code> 인 경우,<code>LookAndFeel</code> 가 제공하는 모든 인스톨 메소드는, 디폴트 값에 액세스 할 필요가 있습니다. 예를 들어, 폰트의 인스톨에서는, 다음의 처리를 합니다.
 <pre>
   JComponent c;
   Font font = c.getFont();
   if (font == null || (font instanceof UIResource)) {
       c.setFont(UIManager.getFont("fontKey"));
   }
 </pre>
폰트가 <code>null</code> 또는 <code>UIResource</code> 인 경우,<code>fontKey</code> 라고 하는 키에 의해, 디폴트 테이블이 조회됩니다. <code>UIDefault</code> 의 취득 메소드는 모두,<code>null</code> 를 건네받았을 경우에 <code>NullPointerException</code> 를 throw 합니다. 이 때문에, 특히 기재가 없는 한, 현재의 값이 <code>null</code> 또는 <code>UIResource</code> 로, 디폴트 키로서 <code>null</code> 가 지정되었을 경우,<code>LookAndFeel</code> 의 개개의 인스톨 메소드는 <code>NullPointerException</code> 를 throw 합니다. 또, 특히 지정이 없는 한,<code>null</code> 컴퍼넌트가 건네받았을 경우, 이것들 모든 <code>인스톨</code> 메소드는 <code>NullPointerException</code> 를 throw 합니다.
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#LookAndFeel()">LookAndFeel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/UIDefaults.html" title="javax.swing 내의 클래스">UIDefaults</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#getDefaults()">getDefaults</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Look & Feel 의 디폴트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#getDescription()">getDescription</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 「The CDE/Motif Look and Feel」 등, 이 Look & Feel 의 구현에 대한 1 행의 설명을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#getDesktopPropertyValue(java.lang.String, java.lang.Object)">getDesktopPropertyValue</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;systemPropertyName,
                        <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;fallbackValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Toolkit.getDefaultToolkit(). getDesktopProperty()</code> 를 호출해, 지정된 시스템 데스크탑 프로퍼티의 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/Icon.html" title="javax.swing 내의 인터페이스">Icon</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#getDisabledIcon(javax.swing.JComponent, javax.swing.Icon)">getDisabledIcon</A> </B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;component,
                <A HREF="../../javax/swing/Icon.html" title="javax.swing 안의 인터페이스">Icon</A> &nbsp;icon)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;무효인 상태의 <code>Icon</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/Icon.html" title="javax.swing 내의 인터페이스">Icon</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#getDisabledSelectedIcon(javax.swing.JComponent, javax.swing.Icon)">getDisabledSelectedIcon</A> </B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;component,
                        <A HREF="../../javax/swing/Icon.html" title="javax.swing 안의 인터페이스">Icon</A> &nbsp;icon)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;무효로, 한편 선택되고 있는 컴퍼넌트에 의해 사용되는 <code>Icon</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#getID()">getID</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 Look & Feel 를 식별하는 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/LayoutStyle.html" title="javax.swing 내의 클래스">LayoutStyle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#getLayoutStyle()">getLayoutStyle</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 Look & Feel 의 <code>LayoutStyle</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#getName()">getName</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 「CDE/Motif」 등, 이 Look & Feel 를 식별하는 짧은 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#getSupportsWindowDecorations()">getSupportsWindowDecorations</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>LookAndFeel</code> 가 돌려주는 <code>RootPaneUI</code> 인스턴스가 <code>JRootPane</code> 에서의 <code>윈도우</code> 장식의 제공을 지원하는 경우,<code>true</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#initialize()">initialize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Look & Feel 를 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#installBorder(javax.swing.JComponent, java.lang.String)">installBorder</A> </B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;defaultBorderName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 경계의 프로퍼티에 디폴트 값를 설정하는 편리한 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#installColors(javax.swing.JComponent, java.lang.String, java.lang.String)">installColors</A> </B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;defaultBgName,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;defaultFgName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 foreground 칼라 및 백그라운드 칼라의 프로퍼티에 디폴트 값를 설정하는 편리한 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#installColorsAndFont(javax.swing.JComponent, java.lang.String, java.lang.String, java.lang.String)">installColorsAndFont</A> </B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c,
                     <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;defaultBgName,
                     <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;defaultFgName,
                     <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;defaultFontName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 foreground, 백그라운드, 및 폰트의 프로퍼티에 디폴트 값를 설정하는 편리한 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#installProperty(javax.swing.JComponent, java.lang.String, java.lang.Object)">installProperty</A> </B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c,
                <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;propertyValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;개발자가 아직 프로퍼티을 설정하고 있지 않는 경우에, 지정된 이름과 값으로 프로퍼티을 컴퍼넌트에 인스톨 하는 편리한 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#isNativeLookAndFeel()">isNativeLookAndFeel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본의 플랫폼에 「네이티브인」Look & Feel 가 있어, 현재의 Look & Feel 가 그 구현인 경우에 <code>true</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#isSupportedLookAndFeel()">isSupportedLookAndFeel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기본의 플랫폼이 이 Look & Feel 를 지원한다, 또는 허용 하는 경우에 <code>true</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#loadKeyBindings(javax.swing.InputMap, java.lang.Object[])">loadKeyBindings</A> </B>(<A HREF="../../javax/swing/InputMap.html" title="javax.swing 안의 클래스">InputMap</A> &nbsp;retMap,
                <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 바인딩으로 <code>InputMap</code> 를 생성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../javax/swing/ComponentInputMap.html" title="javax.swing 내의 클래스">ComponentInputMap</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#makeComponentInputMap(javax.swing.JComponent, java.lang.Object[])">makeComponentInputMap</A> </B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c,
                      <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>keys</code> 로부터 <code>ComponentInputMapUIResource</code> 를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#makeIcon(java.lang.Class, java.lang.String)">makeIcon</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;baseClass,
         <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;gifFile)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이미지를 로드하는 <code>UIDefault.LazyValue</code> 를 작성해, 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../javax/swing/InputMap.html" title="javax.swing 내의 클래스">InputMap</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#makeInputMap(java.lang.Object[])">makeInputMap</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>keys</code> 로부터 <code>InputMapUIResource</code> 를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../javax/swing/text/JTextComponent.KeyBinding.html" title="javax.swing.text 내의 클래스">JTextComponent.KeyBinding</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#makeKeyBindings(java.lang.Object[])">makeKeyBindings</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;keyBindingList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>KeyBinding</code> 의 배열을 구축하는 편리한 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#provideErrorFeedback(java.awt.Component)">provideErrorFeedback</A> </B>(<A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A> &nbsp;component)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;포커스를 가지는, 편집 불가능한 <code>JTextField</code> 에 붙이기를 실시하는 등, 사용자가 무효인 조작을 하려고 했을 때에 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 객체의 프로퍼티을 표시 및 식별하는 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#uninitialize()">uninitialize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Look & Feel 의 초기화를 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/LookAndFeel.html#uninstallBorder(javax.swing.JComponent)">uninstallBorder</A> </B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;경계를 언인스톨하는 편리한 메소드입니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="LookAndFeel()"><!-- --></A> <H3>
LookAndFeel</H3>
<PRE>
public <B>LookAndFeel</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="installColors(javax.swing.JComponent, java.lang.String, java.lang.String)"><!-- --></A> <H3>
installColors</H3>
<PRE>
public static void <B>installColors</B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c,
                                 <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;defaultBgName,
                                 <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;defaultFgName)</PRE>
<DL>
<DD>컴퍼넌트의 foreground 칼라 및 백그라운드 칼라의 프로퍼티에 디폴트 값를 설정하는 편리한 메소드입니다. 각 프로퍼티이 설정되는 것은, 현재가가 <code>null</code> 또는 <code>UIResource</code> 의 경우 뿐입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 색을 설정하는 컴퍼넌트<DD><CODE>defaultBgName</CODE> - 백그라운드의 키<DD><CODE>defaultFgName</CODE> - foreground의 키
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <a href="#exceptions">「예외」</a>에 기재되어 있는 대로<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/LookAndFeel.html#installColorsAndFont(javax.swing.JComponent, java.lang.String, java.lang.String, java.lang.String)"><CODE>installColorsAndFont(javax.swing.JComponent, java.lang.String, java.lang.String, java.lang.String)</CODE></A> , 
<A HREF="../../javax/swing/UIManager.html#getColor(java.lang.Object)"><CODE>UIManager.getColor(java.lang.Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="installColorsAndFont(javax.swing.JComponent, java.lang.String, java.lang.String, java.lang.String)"><!-- --></A> <H3>
installColorsAndFont</H3>
<PRE>
public static void <B>installColorsAndFont</B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c,
                                        <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;defaultBgName,
                                        <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;defaultFgName,
                                        <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;defaultFontName)</PRE>
<DL>
<DD>컴퍼넌트의 foreground, 백그라운드, 및 폰트의 프로퍼티에 디폴트 값를 설정하는 편리한 메소드입니다. 각 프로퍼티이 설정되는 것은, 현재가가 <code>null</code> 또는 <code>UIResource</code> 의 경우 뿐입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 색과 폰트를 설정하는 컴퍼넌트<DD><CODE>defaultBgName</CODE> - 백그라운드의 키<DD><CODE>defaultFgName</CODE> - foreground의 키<DD><CODE>defaultFontName</CODE> - 폰트의 키
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <a href="#exceptions">「예외」</a>에 기재되어 있는 대로<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/LookAndFeel.html#installColors(javax.swing.JComponent, java.lang.String, java.lang.String)"><CODE>installColors(javax.swing.JComponent, java.lang.String, java.lang.String)</CODE></A> , 
<A HREF="../../javax/swing/UIManager.html#getColor(java.lang.Object)"><CODE>UIManager.getColor(java.lang.Object)</CODE></A> , 
<A HREF="../../javax/swing/UIManager.html#getFont(java.lang.Object)"><CODE>UIManager.getFont(java.lang.Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="installBorder(javax.swing.JComponent, java.lang.String)"><!-- --></A> <H3>
installBorder</H3>
<PRE>
public static void <B>installBorder</B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c,
                                 <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;defaultBorderName)</PRE>
<DL>
<DD>컴퍼넌트의 경계의 프로퍼티에 디폴트 값를 설정하는 편리한 메소드입니다. 경계가 설정되는 것은, 경계가 <code>null</code> 인지,<code>UIResource</code> 의 인스턴스인 경우만입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 경계를 설정하는 컴퍼넌트<DD><CODE>defaultBorderName</CODE> - 경계를 지정하는 키
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <a href="#exceptions">「예외」</a>에 기재되어 있는 대로</DL>
</DD>
</DL>
<HR>

<A NAME="uninstallBorder(javax.swing.JComponent)"><!-- --></A> <H3>
uninstallBorder</H3>
<PRE>
public static void <B>uninstallBorder</B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</PRE>
<DL>
<DD>경계를 언인스톨하는 편리한 메소드입니다. 컴퍼넌트의 경계가 <code>UIResource</code> 인 경우,<code>null</code> 로 설정됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 경계를 언인스톨하는 컴퍼넌트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>c</code> 가 <code>null</code> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="installProperty(javax.swing.JComponent, java.lang.String, java.lang.Object)"><!-- --></A> <H3>
installProperty</H3>
<PRE>
public static void <B>installProperty</B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c,
                                   <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                                   <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;propertyValue)</PRE>
<DL>
<DD>개발자가 아직 프로퍼티을 설정하고 있지 않는 경우에, 지정된 이름과 값으로 프로퍼티을 컴퍼넌트에 인스톨 하는 편리한 메소드입니다. 이 메소드는, 원시형 (boolean, int 등)의 프로퍼티의 디폴트 값를 지정할 필요가 있지만, 클라이언트에 의해 설정된 값은 덧쓰기하지 않는 UI 위양의 인스턴스에 의해 사용됩니다. 원시형의 프로퍼티치는 <code>UIResource</code> 마커로 랩 할 수 없기 때문에, 이 메소드는 비공개 상태를 사용해 프로퍼티이 클라이언트에 의해 설정되어 있는지 어떤지를 판단합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 프로퍼티의 설정 대상의 컴퍼넌트<DD><CODE>propertyName</CODE> - 설정하는 프로퍼티의 이름<DD><CODE>propertyValue</CODE> - 프로퍼티의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 프로퍼티이 이 메소드를 사용해 설정할 수 있는 것이 아닌 경우
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 개발자가 프로퍼티치를 설정하고 있지 않고, 형태가 프로퍼티의 형태와 일치하지 않는 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>c</code> 가 <code>null</code> 인지, 개발자가 이름 첨부 프로퍼티을 설정하고 있지 않고,<code>propertyValue</code> 가 <code>null</code> 인 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeKeyBindings(java.lang.Object[])"><!-- --></A> <H3>
makeKeyBindings</H3>
<PRE>
public static <A HREF="../../javax/swing/text/JTextComponent.KeyBinding.html" title="javax.swing.text 내의 클래스">JTextComponent.KeyBinding</A> [] <B>makeKeyBindings</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;keyBindingList)</PRE>
<DL>
<DD><code>KeyBinding</code> 의 배열을 구축하는 편리한 메소드입니다. 이 메소드는 비추천이 아닙니다만, 개발자가 키 바인딩을 지정할 때는, 이 메소드는 아니고,<code>ActionMap</code> 와 <code>InputMap</code> 를 사용하도록 해 주세요.  &nbsp;<p>
이 메소드는,<code>keyBindingList</code> 의 교대로 되는<code>키와 액션</code>의 페어마다의,<code>KeyBinding</code> 의 배열을 돌려줍니다. <code>키</code> 는,<code>KeyStroke.getKeyStroke</code> 메소드로 지정된 형식의 <code>String</code>, 또는 <code>KeyStroke</code> 입니다. 키와 액션의 페어의 <code>액션</code> 부분은,<code>Action</code> 의 이름에 대응하는 <code>String</code> 가 되어 있습니다.  &nbsp;<p>
다음에, 6 조의 교대로 되는 <code>키와 액션</code> 의 페어로부터 1 개의 <code>KeyBinding</code> 배열을 작성하는 예를 나타냅니다.
 <pre>
        JTextComponent.KeyBinding[] multilineBindings = makeKeyBindings( new Object[] {
          "UP", DefaultEditorKit.upAction,
        "DOWN", DefaultEditorKit.downAction,
     "PAGE_UP", DefaultEditorKit.pageUpAction,
   "PAGE_DOWN", DefaultEditorKit.pageDownAction,
       "ENTER", DefaultEditorKit.insertBreakAction,
         "TAB", DefaultEditorKit.insertTabAction
  });
 </pre>
<code>keyBindingList 의</code>길이가 홀수의 경우, 마지막 요소는 무시됩니다.  &nbsp;<p>
<code>키와 액션</code> 의 페어의 <code>키</code> 부분 또는 <code>액션</code> 부분에 <code>null</code> 치를 지정하면(자), 대응하는 값 <code>null</code> 를 가지는 <code>KeyBinding</code> 가 작성됩니다. Swing 의 그 외의 부분에서는,<code>KeyBinding</code> 를 구성하는 값으로 해서 <code>null 이외</code> 가 요구되므로,<code>키와 액션</code> 의 페어의 <code>키</code> 부분에도 <code>액션</code> 부분에도,<code>null</code> 를 지정하지 않게 해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>keyBindingList</CODE> - <code>키와 액션</code> 의 페어의 배열
<DT><B>반환값:</B><DD><code>KeyBinding</code> 의 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>keyBindingList</code> 가 <code>null</code> 의 경우
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 페어의 <code>키</code> 부분이 <code>KeyStroke</code> 도 <code>String</code> 도 아닌 경우, 또는 페어의 <code>액션</code> 부분이 <code>String</code> 가 아닌 경우<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/ActionMap.html" title="javax.swing 내의 클래스"><CODE>ActionMap</CODE></A> , 
<A HREF="../../javax/swing/InputMap.html" title="javax.swing 안의 클래스"><CODE>InputMap</CODE></A> , 
<A HREF="../../javax/swing/KeyStroke.html#getKeyStroke(char)"><CODE>KeyStroke.getKeyStroke(char)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="makeInputMap(java.lang.Object[])"><!-- --></A> <H3>
makeInputMap</H3>
<PRE>
public static <A HREF="../../javax/swing/InputMap.html" title="javax.swing 내의 클래스">InputMap</A>  <B>makeInputMap</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;keys)</PRE>
<DL>
<DD><code>keys</code> 로부터 <code>InputMapUIResource</code> 를 작성합니다. 이것은,<code>loadKeyBindings(map, keys)</code> 를 호출해,<code>InputMapUIResource</code> 를 돌려주는 것으로 새로운 <code>InputMapUIResource</code> 를 작성하는 편리한 메소드입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>keys</CODE> - 교대로 되는 <code>키스트로크(keystroke)과 액션 키</code> 의 페어 (<A HREF="../../javax/swing/LookAndFeel.html#loadKeyBindings(javax.swing.InputMap, java.lang.Object[])"><CODE>loadKeyBindings(javax.swing.InputMap, java.lang.Object[])</CODE></A>  의 설명 대로)
<DT><B>반환값:</B><DD>신규 작성된 <code>InputMapUIResource</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/LookAndFeel.html#loadKeyBindings(javax.swing.InputMap, java.lang.Object[])"><CODE>loadKeyBindings(javax.swing.InputMap, java.lang.Object[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="makeComponentInputMap(javax.swing.JComponent, java.lang.Object[])"><!-- --></A> <H3>
makeComponentInputMap</H3>
<PRE>
public static <A HREF="../../javax/swing/ComponentInputMap.html" title="javax.swing 내의 클래스">ComponentInputMap</A>  <B>makeComponentInputMap</B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c,
                                                      <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;keys)</PRE>
<DL>
<DD><code>keys</code> 로부터 <code>ComponentInputMapUIResource</code> 를 작성합니다. 이것은,<code>loadKeyBindings(map, keys)</code> 를 호출해,<code>ComponentInputMapUIResource</code> 를 돌려주는 것으로 새로운 <code>ComponentInputMapUIResource</code> 를 작성하는 편리한 메소드입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - <code>ComponentInputMapUIResource</code> 의 작성에 사용하는 컴퍼넌트<DD><CODE>keys</CODE> - 교대로 되는 <code>키스트로크(keystroke)과 액션 키</code> 의 페어 (<A HREF="../../javax/swing/LookAndFeel.html#loadKeyBindings(javax.swing.InputMap, java.lang.Object[])"><CODE>loadKeyBindings(javax.swing.InputMap, java.lang.Object[])</CODE></A>  의 설명 대로)
<DT><B>반환값:</B><DD>신규 작성된 <code>InputMapUIResource</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>c</code> 가 <code>null</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/LookAndFeel.html#loadKeyBindings(javax.swing.InputMap, java.lang.Object[])"><CODE>loadKeyBindings(javax.swing.InputMap, java.lang.Object[])</CODE></A> , 
<A HREF="../../javax/swing/plaf/ComponentInputMapUIResource.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentInputMapUIResource</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="loadKeyBindings(javax.swing.InputMap, java.lang.Object[])"><!-- --></A> <H3>
loadKeyBindings</H3>
<PRE>
public static void <B>loadKeyBindings</B>(<A HREF="../../javax/swing/InputMap.html" title="javax.swing 안의 클래스">InputMap</A> &nbsp;retMap,
                                   <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;keys)</PRE>
<DL>
<DD>지정된 바인딩으로 <code>InputMap</code> 를 생성합니다. 바인딩은, 교대로 되는 <code>키스트로크(keystroke)와 액션 키</code> 의 페어의 리스트로서 지정됩니다. <code>키스트로크(keystroke)</code> 는,<code>KeyStroke</code> 의 인스턴스인가, 바인딩의 <code>KeyStroke</code> 를 나타내는 <code>String</code> 가 됩니다. 특정의 형식에 대해서는,<code>KeyStroke.getKeyStroke(String)</code> 를 참조해 주세요. 페어의 <code>액션 키</code> 부분은,<code>KeyStroke</code> 의 <code>InputMap</code> 내의 등록을 마친 키가 되어 있습니다.  &nbsp;<p>
다음에, 2 조의 <code>키와 액션</code> 의 페어를 사용해,<code>InputMap</code> 를 로드하는 예를 나타냅니다.
 <pre>
   LookAndFeel.loadKeyBindings(inputMap, new Object[] {
     "control X", "cut",
     "control V", "paste"
   });
 </pre>
 <p>
바인딩 (<code>키</code>)의 리스트로서 <code>null</code> 를 지정했을 경우,<code>retMap</code> 는 변경되지 않습니다.  &nbsp;<p>
<code>액션 키</code> 로서 <code>null</code> 를 지정했을 경우,<code>InputMap</code> 로부터 <code>키스트로크(keystroke)</code> 의 엔트리가 삭제됩니다. <code>키스트로크(keystroke)</code> <code>null</code> 는 무시됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>retMap</CODE> - <code>키와 액션</code> 의 페어를 추가하는 <code>InputMap</code><DD><CODE>keys</CODE> - <code>retMap</code> 에 추가하는 바인딩
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>keys</code> 가 <code>null 이외</code> 로, 빈 상태(empty)이 아니고, 한편 <code>retMap</code> 가 <code>null</code> 인 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/KeyStroke.html#getKeyStroke(java.lang.String)"><CODE>KeyStroke.getKeyStroke(String)</CODE></A> , 
<A HREF="../../javax/swing/InputMap.html" title="javax.swing 안의 클래스"><CODE>InputMap</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="makeIcon(java.lang.Class, java.lang.String)"><!-- --></A> <H3>
makeIcon</H3>
<PRE>
public static <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>makeIcon</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;baseClass,
                              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;gifFile)</PRE>
<DL>
<DD>이미지를 로드하는 <code>UIDefault.LazyValue</code> 를 작성해, 돌려줍니다. 반환값은,<code>UIDefaults.LazyValue</code> 의 구현이 됩니다. 반환된 객체상에서 <code>createValue</code> 가 불려 가면(자), 이미지가 로드 됩니다. <code>null 이외</code> 의 이미지는,<code>UIResource</code> 를 구현하는 <code>Icon</code> 에 랩 됩니다. 이미지의 로드는,<code>Class.getResourceAsStream(gifFile)</code> 를 사용해 행해집니다.  &nbsp;<p>
이 메소드는, 인수의 체크를 실시하지 않습니다. <code>null 이외</code> 의 값을 지정하는 것을 강하게 추천합니다. 그렇게 하지 않으면 반환된 객체상에서 <code>createValue</code> 를 호출했을 때, 예외가 발생할 가능성이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>baseClass</CODE> - 자원의 로드에 사용하는 <code>Class</code><DD><CODE>gifFile</CODE> - 이미지를 로드하는 패스
<DT><B>반환값:</B><DD><code>UIDefaults.LazyValue</code>. 해결시에,<code>LazyValue</code> 는 지정된 이미지를 로드하는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/UIDefaults.LazyValue.html" title="javax.swing 내의 인터페이스"><CODE>UIDefaults.LazyValue</CODE></A> , 
<A HREF="../../javax/swing/Icon.html" title="javax.swing 안의 인터페이스"><CODE>Icon</CODE></A> , 
<A HREF="../../java/lang/Class.html#getResourceAsStream(java.lang.String)"><CODE>Class.getResourceAsStream(String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getLayoutStyle()"><!-- --></A> <H3>
getLayoutStyle</H3>
<PRE>
public <A HREF="../../javax/swing/LayoutStyle.html" title="javax.swing 내의 클래스">LayoutStyle</A>  <B>getLayoutStyle</B>()</PRE>
<DL>
<DD>이 Look & Feel 의 <code>LayoutStyle</code> 를 돌려줍니다. 반환값은 <code>null</code> 이외입니다.  &nbsp;<p>
일반적으로, Look & Feel 의 <code>LayoutStyle</code> 는 사용하지 않습니다. 대신에,<code>LayoutStyle</code> 메소드 <code>getInstance</code> 를 사용합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 Look & Feel 의 <code>LayoutStyle</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/LayoutStyle.html#getInstance()"><CODE>LayoutStyle.getInstance()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="provideErrorFeedback(java.awt.Component)"><!-- --></A> <H3>
provideErrorFeedback</H3>
<PRE>
public void <B>provideErrorFeedback</B>(<A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A> &nbsp;component)</PRE>
<DL>
<DD>포커스를 가지는, 편집 불가능한 <code>JTextField</code> 에 붙이기를 실시하는 등, 사용자가 무효인 조작을 하려고 했을 때에 불려 갑니다. 디폴트의 구현에서는, beep음을 울립니다. 다른 동작을 실시하는 경우는, 디폴트의 구현을 서브 클래스에 의해 오버라이드(override) 해, 다른 피드백을 지정할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>component</CODE> - 에러가 발생한 <code>Component</code>. <code>null</code> 도 가능 (이 경우, 에러 조건은 <code>Component</code> 와 직접 관련지을 수 없다)<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDesktopPropertyValue(java.lang.String, java.lang.Object)"><!-- --></A> <H3>
getDesktopPropertyValue</H3>
<PRE>
public static <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getDesktopPropertyValue</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;systemPropertyName,
                                             <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;fallbackValue)</PRE>
<DL>
<DD><code>Toolkit.getDefaultToolkit(). getDesktopProperty()</code> 를 호출해, 지정된 시스템 데스크탑 프로퍼티의 값을 돌려줍니다. 지정된 프로퍼티의 값이 <code>null</code> 의 경우,<code>fallbackValue</code> 가 돌려주어집니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>systemPropertyName</CODE> - 조회하는 시스템 데스크탑 프로퍼티의 이름<DD><CODE>fallbackValue</CODE> - 시스템치가 null 의 경우, 값으로 해서 돌아오는 객체
<DT><B>반환값:</B><DD>데스크탑 프로퍼티의 현재의 값<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Toolkit.html#getDesktopProperty(java.lang.String)"><CODE>Toolkit.getDesktopProperty(java.lang.String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDisabledIcon(javax.swing.JComponent, javax.swing.Icon)"><!-- --></A> <H3>
getDisabledIcon</H3>
<PRE>
public <A HREF="../../javax/swing/Icon.html" title="javax.swing 내의 인터페이스">Icon</A>  <B>getDisabledIcon</B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;component,
                            <A HREF="../../javax/swing/Icon.html" title="javax.swing 안의 인터페이스">Icon</A> &nbsp;icon)</PRE>
<DL>
<DD>무효인 상태의 <code>Icon</code> 를 돌려줍니다. 이 메소드는, 무효인 상태의 <code>Icon</code> 가 지정되어 있지 않은 경우에, 그것을 생성하기 위해서 사용됩니다. 예를 들어,<code>JButton</code> 를 작성해,<code>setIcon</code> 에 의해 <code>Icon</code> 만을 지정했을 경우 이 메소드가 불려 가 무효인 상태의 <code>Icon</code> 가 작성됩니다. <code>icon</code> 로서 <code>null</code> 가 건네받았을 경우, 이 메소드는 <code>null</code> 를 돌려줍니다.  &nbsp;<p>
Look & Feel 에 따라서는, 무효인 상태의 <code>Icon</code> 가 draw 되지 않고, 무시되는 일이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>component</CODE> - <code>Icon</code> 를 표시하는 <code>JComponent</code>. <code>null</code> 도 가능<DD><CODE>icon</CODE> - 무효인 아이콘을 생성하는 <code>Icon</code>
<DT><B>반환값:</B><DD>무효인 <code>Icon</code>. 적절한 <code>Icon</code> 를 생성할 수 없는 경우는 <code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDisabledSelectedIcon(javax.swing.JComponent, javax.swing.Icon)"><!-- --></A> <H3>
getDisabledSelectedIcon</H3>
<PRE>
public <A HREF="../../javax/swing/Icon.html" title="javax.swing 내의 인터페이스">Icon</A>  <B>getDisabledSelectedIcon</B>(<A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;component,
                                    <A HREF="../../javax/swing/Icon.html" title="javax.swing 안의 인터페이스">Icon</A> &nbsp;icon)</PRE>
<DL>
<DD>무효로, 한편 선택되고 있는 컴퍼넌트에 의해 사용되는 <code>Icon</code> 를 돌려줍니다. 이 메소드는, 무효로, 한편 선택되고 있는 상태의 컴퍼넌트에 대해서, 이 상태의 특정의 <code>Icon</code> 가 설정되어 있지 않은 경우에,<code>Icon</code> 를 생성하기 위해서 사용합니다. 예를 들어,<code>JButton</code> 를 작성해,<code>setIcon</code> 에 의해 <code>Icon</code> 만을 지정했을 경우, 이 메소드가 불려 가 무효로 한편 선택되고 있는 <code>Icon</code> 가 생성됩니다. <code>icon</code> 로서 <code>null</code> 가 건네받았을 경우, 이 메소드는 <code>null</code> 를 돌려줍니다.  &nbsp;<p>
Look & Feel 에 따라서는, 선택된 무효인 상태의 <code>Icon</code> 가 draw 되지 않고, 무시되는 일이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>component</CODE> - <code>Icon</code> 를 표시하는 <code>JComponent</code>. <code>null</code> 도 가능<DD><CODE>icon</CODE> - 선택된 무효인 상태의 아이콘을 생성하는 <code>Icon</code>
<DT><B>반환값:</B><DD>선택된 무효인 상태의 아이콘. 적절한 <code>Icon</code> 를 생성할 수 없는 경우는 <code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getName()"><!-- --></A> <H3>
getName</H3>
<PRE>
public abstract <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getName</B>()</PRE>
<DL>
<DD>「CDE/Motif」 등, 이 Look & Feel 를 식별하는 짧은 캐릭터 라인을 돌려줍니다. 이 캐릭터 라인은, 메뉴 항목에 적절하고 있습니다. Look & Feel 는, 각각 다른 이름을 가지고 있습니다. 예를 들어, 몇 개의 컴퍼넌트의 draw 방법을 변경하는 MotifLookAndFeel 의 서브 클래스는, 「CDE/Motif My Way」 등으로 불립니다. 이러한 이름은, 사용자가 이름의 리스트로부터 L&F 를 선택할 경우에 편리합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 Look & Feel 를 식별하는 짧은 식별자</DL>
</DD>
</DL>
<HR>

<A NAME="getID()"><!-- --></A> <H3>
getID</H3>
<PRE>
public abstract <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getID</B>()</PRE>
<DL>
<DD>이 Look & Feel 를 식별하는 캐릭터 라인을 돌려줍니다. 이 캐릭터 라인은, 유명한 Look & Feel 의 구현을 인식하는 어플리케이션/서비스로 사용됩니다. 현재, 유명한 것으로 해 「Motif」, 「Windows」, 「Mac」, 「Metal」 등입니다. Look & Feel 로 기본적인 변경을 더하지 않는 유명한 슈퍼 클래스로부터 파생한 LookAndFeel 는, 이 메소드를 오버라이드(override) 해서는 안되는 것에 주의해 주세요.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 Look & Feel 를 식별하는 식별자</DL>
</DD>
</DL>
<HR>

<A NAME="getDescription()"><!-- --></A> <H3>
getDescription</H3>
<PRE>
public abstract <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getDescription</B>()</PRE>
<DL>
<DD>「The CDE/Motif Look and Feel」 등, 이 Look & Feel 의 구현에 대한 1 행의 설명을 돌려줍니다. 이것은 사용자용의 캐릭터 라인으로, 윈도우의 타이틀이나 툴팁 메세지 등에 사용됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 Look & Feel 의 짧은 설명</DL>
</DD>
</DL>
<HR>

<A NAME="getSupportsWindowDecorations()"><!-- --></A> <H3>
getSupportsWindowDecorations</H3>
<PRE>
public boolean <B>getSupportsWindowDecorations</B>()</PRE>
<DL>
<DD><code>LookAndFeel</code> 가 돌려주는 <code>RootPaneUI</code> 인스턴스가 <code>JRootPane</code> 에서의 <code>윈도우</code> 장식의 제공을 지원하는 경우,<code>true</code> 를 돌려줍니다.  &nbsp;<p>
디폴트의 구현은 <code>false</code> 를 돌려줍니다. <code>윈도우</code> 장식을 지원하는 서브 클래스는, 이 구현을 오버라이드(override) 해,<code>true</code> 를 돌려주도록(듯이) 합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 Look & Feel 에 의해 작성된 <code>RootPaneUI</code> 인스턴스가 클라이언트측의 장식을 지원하는 경우,<code>true</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JDialog.html#setDefaultLookAndFeelDecorated(boolean)"><CODE>JDialog.setDefaultLookAndFeelDecorated(boolean)</CODE></A> , 
<A HREF="../../javax/swing/JFrame.html#setDefaultLookAndFeelDecorated(boolean)"><CODE>JFrame.setDefaultLookAndFeelDecorated(boolean)</CODE></A> , 
<A HREF="../../javax/swing/JRootPane.html#setWindowDecorationStyle(int)"><CODE>JRootPane.setWindowDecorationStyle(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isNativeLookAndFeel()"><!-- --></A> <H3>
isNativeLookAndFeel</H3>
<PRE>
public abstract boolean <B>isNativeLookAndFeel</B>()</PRE>
<DL>
<DD>기본의 플랫폼에 「네이티브인」Look & Feel 가 있어, 현재의 Look & Feel 가 그 구현인 경우에 <code>true</code> 를 돌려줍니다. 예를 들어, 기본의 플랫폼이 CDE 를 실행하는 Solaris 인 경우, CDE/Motif 의 Look & Feel 의 구현이 <code>true</code> 를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 Look & Feel 가 기본의 플랫폼의 Look & Feel 를 나타내는 경우,<code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="isSupportedLookAndFeel()"><!-- --></A> <H3>
isSupportedLookAndFeel</H3>
<PRE>
public abstract boolean <B>isSupportedLookAndFeel</B>()</PRE>
<DL>
<DD>기본의 플랫폼이 이 Look & Feel 를 지원한다, 또는 허용 하는 경우에 <code>true</code> 를 돌려줍니다. Look & Feel 가 특수한 자원이나, 현재의 플랫폼에 대해서 정의되어 있지 않은 법적 계약에 의존하는 경우, 이 메소드는 <code>false</code> 를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이것이 지원되고 있는 Look & Feel 인 경우,<code>true</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/UIManager.html#setLookAndFeel(javax.swing.LookAndFeel)"><CODE>UIManager.setLookAndFeel(javax.swing.LookAndFeel)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="initialize()"><!-- --></A> <H3>
initialize</H3>
<PRE>
public void <B>initialize</B>()</PRE>
<DL>
<DD>Look & Feel 를 초기화합니다. 이 메소드는 public 메소드입니다만, 항상, 임의의 Look & Feel 가 현재의 Look & Feel 로서 인스톨 되었을 때에,<code>UIManager</code> 에 의해 불려 가도록 해 주세요. 이 메소드는,<code>UIManager</code> 가 <code>getDefaults</code> 를 호출하기 전에 불려 갑니다. 이 메소드는, Look & Feel 의 모든 초기화를 실행하기 위한 메소드입니다. 서브 클래스는, static 초기화자는 아니고, 이 메소드로 필요한 1 회나 의리의 설정을 모두 실행합니다.  Look & Feel 클래스의 객체는,<code>isSupportedLookAndFeel()</code> 가 <code>false</code> 를 돌려주는 것을 확인하기 위해서만 로드 되는 경우가 있기 때문입니다.
<P>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/LookAndFeel.html#uninitialize()"><CODE>uninitialize()</CODE></A> , 
<A HREF="../../javax/swing/UIManager.html#setLookAndFeel(javax.swing.LookAndFeel)"><CODE>UIManager.setLookAndFeel(javax.swing.LookAndFeel)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="uninitialize()"><!-- --></A> <H3>
uninitialize</H3>
<PRE>
public void <B>uninitialize</B>()</PRE>
<DL>
<DD>Look & Feel 의 초기화를 해제합니다. 이 메소드는 public 메소드입니다만, 항상, Look & Feel 가 언인스톨되었을 때에,<code>UIManager</code> 에 의해 불려 가도록 해 주세요. 예를 들어,<code>UIManager.setLookAndFeel</code> 는, Look & Feel 의 변경시에 이 메소드를 호출합니다.  &nbsp;<p>
서브 클래스는, 이 메소드로 몇개의 자원을 해제할 수 있습니다.
<P>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/LookAndFeel.html#initialize()"><CODE>initialize()</CODE></A> , 
<A HREF="../../javax/swing/UIManager.html#setLookAndFeel(javax.swing.LookAndFeel)"><CODE>UIManager.setLookAndFeel(javax.swing.LookAndFeel)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDefaults()"><!-- --></A> <H3>
getDefaults</H3>
<PRE>
public <A HREF="../../javax/swing/UIDefaults.html" title="javax.swing 내의 클래스">UIDefaults</A>  <B>getDefaults</B>()</PRE>
<DL>
<DD>Look & Feel 의 디폴트를 돌려줍니다. 이 메소드는 public 메소드입니다만, 항상, 임의의 Look & Feel 가 현재의 Look & Feel 로서 설정되어<code>initialize</code> 가 불려 간 뒤,<code>UIManager</code> 에 의해 불려 가도록 해 주세요.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>Look & Feel 의 디폴트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/LookAndFeel.html#initialize()"><CODE>initialize()</CODE></A> , 
<A HREF="../../javax/swing/LookAndFeel.html#uninitialize()"><CODE>uninitialize()</CODE></A> , 
<A HREF="../../javax/swing/UIManager.html#setLookAndFeel(javax.swing.LookAndFeel)"><CODE>UIManager.setLookAndFeel(javax.swing.LookAndFeel)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 객체의 프로퍼티을 표시 및 식별하는 캐릭터 라인을 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 객체의 캐릭터 라인 표현</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LookAndFeel.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/swing/MenuElement.html" title="javax.swing 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/swing/LookAndFeel.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="LookAndFeel.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
