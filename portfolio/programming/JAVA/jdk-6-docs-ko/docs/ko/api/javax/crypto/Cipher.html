<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:01:30 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
Cipher (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Cipher (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Cipher.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/crypto/CipherInputStream.html" title="javax.crypto 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/crypto/Cipher.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Cipher.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.crypto</FONT>
<BR>
클래스 Cipher</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.crypto.Cipher</B>
</PRE>
<DL>
<DT><B>직계의 기존의 서브 클래스:</B> <DD><A HREF="../../javax/crypto/NullCipher.html" title="javax.crypto 내의 클래스">NullCipher</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>Cipher</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
이 클래스는, 암호화 및 복호화의 암호 기능을 제공합니다. 이것은, JCE (Java Cryptographic Extension) 시스템의 코어 부분을 구성합니다.

 <p>Cipher 객체를 생성하려면 , 어플리케이션은 Cipher 의 <code>getInstance</code> 메소드를 호출해, 요구된 「변환」의 이름을 건네줍니다. 필요에 따라서, 프로바이더의 이름을 지정할 수가 있습니다.

 <p>「변환」은, 지정된 입력에 대해서 실행해, 어떠한 출력을 생성하는 조작 (또는 조작세트)을 설명하는 캐릭터 라인입니다. 변환에는, 암호화 알고리즘 (<i>DES</i> 등)의 이름이 반드시 포함됩니다. 거기에 피드백 모드 및 패딩 방식이 계속되는 경우도 있습니다.

 <p> 변환은, 다음의 서식에서 기술됩니다. <p>

 <ul>
<li>"<i>algorithm/mode/padding</i>" 또는<p>
<li>"<i>algorithm</i>"
 </ul>

 <P> 후자의 경우, 모드 및 패딩 방식에는, 프로바이더 고유의 디폴트 값가 사용됩니다. 예를 들어, 이하는 유효한 변환입니다. <p>

 <pre>
Cipher c = Cipher.getInstance("<i>DES/CBC/PKCS5Padding</i>");
 </pre>

<code>CFB</code> 나 <code>OFB<code> 등의 모드를 사용하면(자), 블록 암호는, 암호의 실제의 블록 사이즈보다 작은 단위로 데이터를 암호화할 수 있습니다. 이러한 모드를 요구하는 경우, 「<code>DES/CFB8/NoPadding</code>」 및 「<code>DES/OFB32/PKCS5Padding</code>」변환에 나타나도록(듯이), 이 수치를 모드명에 추가하는 것으로써, 한 번에 처리하는 비트수를 옵션으로 지정할 수 있습니다. 수치를 지정하지 않는 경우, 프로바이더 고유의 디폴트가 사용됩니다(예를 들어, SunJCE 프로바이더에서는 DES 에 디폴트의 64 비트가 사용된다). 따라서, CFB8 나 OFB8 등의 8 비트 모드를 사용하는 것으로, 블록 암호를 바이트 지향의 스트림 암호로 변환할 수 있습니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/crypto/KeyGenerator.html" title="javax.crypto 내의 클래스"><CODE>KeyGenerator</CODE></A> , 
<A HREF="../../javax/crypto/SecretKey.html" title="javax.crypto 안의 인터페이스"><CODE>SecretKey</CODE></A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#DECRYPT_MODE">DECRYPT_MODE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;암호를 복호화 모드에 초기화하는데 사용하는 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#ENCRYPT_MODE">ENCRYPT_MODE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;암호를 암호화 모드에 초기화하는데 사용하는 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#PRIVATE_KEY">PRIVATE_KEY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;랩 해제되는 열쇠가 「비공개키」인 것을 나타내는데 사용하는 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#PUBLIC_KEY">PUBLIC_KEY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;랩 해제되는 열쇠가 「공개키」인 것을 나타내는데 사용하는 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#SECRET_KEY">SECRET_KEY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;랩 해제되는 열쇠가 「비밀열쇠」인 것을 나타내는데 사용하는 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#UNWRAP_MODE">UNWRAP_MODE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;암호를 열쇠 랩핑 해제 모드에 초기화하는데 사용하는 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#WRAP_MODE">WRAP_MODE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;암호를 열쇠 랩핑 모드에 초기화하는데 사용하는 정수입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#Cipher(javax.crypto.CipherSpi, java.security.Provider, java.lang.String)">Cipher</A> </B>(<A HREF="../../javax/crypto/CipherSpi.html" title="javax.crypto 안의 클래스">CipherSpi</A> &nbsp;cipherSpi,
       <A HREF="../../java/security/Provider.html" title="java.security 안의 클래스">Provider</A> &nbsp;provider,
       <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;transformation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cipher 객체를 생성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#doFinal()">doFinal</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 종료합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#doFinal(byte[])">doFinal</A> </B>(byte[]&nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#doFinal(byte[], int)">doFinal</A> </B>(byte[]&nbsp;output,
        int&nbsp;outputOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 종료합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#doFinal(byte[], int, int)">doFinal</A> </B>(byte[]&nbsp;input,
        int&nbsp;inputOffset,
        int&nbsp;inputLen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#doFinal(byte[], int, int, byte[])">doFinal</A> </B>(byte[]&nbsp;input,
        int&nbsp;inputOffset,
        int&nbsp;inputLen,
        byte[]&nbsp;output)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#doFinal(byte[], int, int, byte[], int)">doFinal</A> </B>(byte[]&nbsp;input,
        int&nbsp;inputOffset,
        int&nbsp;inputLen,
        byte[]&nbsp;output,
        int&nbsp;outputOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#doFinal(java.nio.ByteBuffer, java.nio.ByteBuffer)">doFinal</A> </B>(<A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;input,
        <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;output)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getAlgorithm()">getAlgorithm</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Cipher</code> 객체의 알고리즘명을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getBlockSize()">getBlockSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;블록 사이즈를 돌려줍니다 (바이트 단위). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/crypto/ExemptionMechanism.html" title="javax.crypto 내의 클래스">ExemptionMechanism</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getExemptionMechanism()">getExemptionMechanism</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 암호로 사용되는 Exemption Mechanism 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../javax/crypto/Cipher.html" title="javax.crypto 내의 클래스">Cipher</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getInstance(java.lang.String)">getInstance</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;transformation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 변환을 구현하는 <code>Cipher</code> 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../javax/crypto/Cipher.html" title="javax.crypto 내의 클래스">Cipher</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getInstance(java.lang.String, java.security.Provider)">getInstance</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;transformation,
            <A HREF="../../java/security/Provider.html" title="java.security 안의 클래스">Provider</A> &nbsp;provider)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 변환을 구현하는 <code>Cipher</code> 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../javax/crypto/Cipher.html" title="javax.crypto 내의 클래스">Cipher</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getInstance(java.lang.String, java.lang.String)">getInstance</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;transformation,
            <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;provider)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 변환을 구현하는 <code>Cipher</code> 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getIV()">getIV</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 버퍼의 초기화 벡터 (IV)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getMaxAllowedKeyLength(java.lang.String)">getMaxAllowedKeyLength</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;transformation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인스톨 되고 있는 JCE 관할 정책 파일에 따라, 지정된 변환의 열쇠의 최대 길이을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/security/spec/AlgorithmParameterSpec.html" title="java.security.spec 내의 인터페이스">AlgorithmParameterSpec</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getMaxAllowedParameterSpec(java.lang.String)">getMaxAllowedParameterSpec</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;transformation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;관할 정책 파일에 따라, 최대의 암호 파라미터치를 포함한 AlgorithmParameterSpec 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getOutputSize(int)">getOutputSize</A> </B>(int&nbsp;inputLen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;입력의 길이 <code>inputLen</code> (바이트 단위)를 지정해, 다음의 <code>update</code> 또는 <code>doFinal</code> 조작의 결과를 보관 유지하기 위해서 필요한 출력 버퍼의 길이를 바이트수로 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/security/AlgorithmParameters.html" title="java.security 내의 클래스">AlgorithmParameters</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getParameters()">getParameters</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 암호로 사용되는 파라미터를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/security/Provider.html" title="java.security 내의 클래스">Provider</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#getProvider()">getProvider</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Cipher</code> 객체의 프로바이더를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.cert.Certificate)">init</A> </B>(int&nbsp;opmode,
     <A HREF="../../java/security/cert/Certificate.html" title="java.security.cert 안의 클래스">Certificate</A> &nbsp;certificate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 암호를, 검증 조작을 위해서(때문에) 지정된 공개키로 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.cert.Certificate, java.security.SecureRandom)">init</A> </B>(int&nbsp;opmode,
     <A HREF="../../java/security/cert/Certificate.html" title="java.security.cert 안의 클래스">Certificate</A> &nbsp;certificate,
     <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 암호를, 검증 조작을 위해서(때문에) 지정된 공개키 및 random number generation의 원을 사용해 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.Key)">init</A> </B>(int&nbsp;opmode,
     <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열쇠를 사용해 이 암호를 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.Key, java.security.AlgorithmParameters)">init</A> </B>(int&nbsp;opmode,
     <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
     <A HREF="../../java/security/AlgorithmParameters.html" title="java.security 안의 클래스">AlgorithmParameters</A> &nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열쇠와 알고리즘 파라미터세트를 사용해 이 암호를 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.Key, java.security.spec.AlgorithmParameterSpec)">init</A> </B>(int&nbsp;opmode,
     <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
     <A HREF="../../java/security/spec/AlgorithmParameterSpec.html" title="java.security.spec 안의 인터페이스">AlgorithmParameterSpec</A> &nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열쇠와 알고리즘 파라미터세트를 사용해 이 암호를 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.Key, java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom)">init</A> </B>(int&nbsp;opmode,
     <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
     <A HREF="../../java/security/spec/AlgorithmParameterSpec.html" title="java.security.spec 안의 인터페이스">AlgorithmParameterSpec</A> &nbsp;params,
     <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열쇠, 알고리즘 파라미터세트, 및 random number generation의 원을 사용해 이 암호를 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.Key, java.security.AlgorithmParameters, java.security.SecureRandom)">init</A> </B>(int&nbsp;opmode,
     <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
     <A HREF="../../java/security/AlgorithmParameters.html" title="java.security 안의 클래스">AlgorithmParameters</A> &nbsp;params,
     <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열쇠, 알고리즘 파라미터세트, 및 random number generation의 원을 사용해 이 암호를 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#init(int, java.security.Key, java.security.SecureRandom)">init</A> </B>(int&nbsp;opmode,
     <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
     <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열쇠와 random number generation의 원을 사용해 이 암호를 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/security/Key.html" title="java.security 내의 인터페이스">Key</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#unwrap(byte[], java.lang.String, int)">unwrap</A> </B>(byte[]&nbsp;wrappedKey,
       <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;wrappedKeyAlgorithm,
       int&nbsp;wrappedKeyType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;전에 랩 된 열쇠를 랩 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#update(byte[])">update</A> </B>(byte[]&nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#update(byte[], int, int)">update</A> </B>(byte[]&nbsp;input,
       int&nbsp;inputOffset,
       int&nbsp;inputLen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#update(byte[], int, int, byte[])">update</A> </B>(byte[]&nbsp;input,
       int&nbsp;inputOffset,
       int&nbsp;inputLen,
       byte[]&nbsp;output)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#update(byte[], int, int, byte[], int)">update</A> </B>(byte[]&nbsp;input,
       int&nbsp;inputOffset,
       int&nbsp;inputLen,
       byte[]&nbsp;output,
       int&nbsp;outputOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#update(java.nio.ByteBuffer, java.nio.ByteBuffer)">update</A> </B>(<A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;input,
       <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;output)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/Cipher.html#wrap(java.security.Key)">wrap</A> </B>(<A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열쇠를 랩 합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ENCRYPT_MODE"><!-- --></A> <H3>
ENCRYPT_MODE</H3>
<PRE>
public static final int <B>ENCRYPT_MODE</B></PRE>
<DL>
<DD>암호를 암호화 모드에 초기화하는데 사용하는 정수입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.ENCRYPT_MODE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="DECRYPT_MODE"><!-- --></A> <H3>
DECRYPT_MODE</H3>
<PRE>
public static final int <B>DECRYPT_MODE</B></PRE>
<DL>
<DD>암호를 복호화 모드에 초기화하는데 사용하는 정수입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.DECRYPT_MODE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="WRAP_MODE"><!-- --></A> <H3>
WRAP_MODE</H3>
<PRE>
public static final int <B>WRAP_MODE</B></PRE>
<DL>
<DD>암호를 열쇠 랩핑 모드에 초기화하는데 사용하는 정수입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.WRAP_MODE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="UNWRAP_MODE"><!-- --></A> <H3>
UNWRAP_MODE</H3>
<PRE>
public static final int <B>UNWRAP_MODE</B></PRE>
<DL>
<DD>암호를 열쇠 랩핑 해제 모드에 초기화하는데 사용하는 정수입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.UNWRAP_MODE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="PUBLIC_KEY"><!-- --></A> <H3>
PUBLIC_KEY</H3>
<PRE>
public static final int <B>PUBLIC_KEY</B></PRE>
<DL>
<DD>랩 해제되는 열쇠가 「공개키」인 것을 나타내는데 사용하는 정수입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.PUBLIC_KEY">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="PRIVATE_KEY"><!-- --></A> <H3>
PRIVATE_KEY</H3>
<PRE>
public static final int <B>PRIVATE_KEY</B></PRE>
<DL>
<DD>랩 해제되는 열쇠가 「비공개키」인 것을 나타내는데 사용하는 정수입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.PRIVATE_KEY">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="SECRET_KEY"><!-- --></A> <H3>
SECRET_KEY</H3>
<PRE>
public static final int <B>SECRET_KEY</B></PRE>
<DL>
<DD>랩 해제되는 열쇠가 「비밀열쇠」인 것을 나타내는데 사용하는 정수입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.crypto.Cipher.SECRET_KEY">정수 필드치</A> </DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Cipher(javax.crypto.CipherSpi, java.security.Provider, java.lang.String)"><!-- --></A> <H3>
Cipher</H3>
<PRE>
protected <B>Cipher</B>(<A HREF="../../javax/crypto/CipherSpi.html" title="javax.crypto 안의 클래스">CipherSpi</A> &nbsp;cipherSpi,
                 <A HREF="../../java/security/Provider.html" title="java.security 안의 클래스">Provider</A> &nbsp;provider,
                 <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;transformation)</PRE>
<DL>
<DD>Cipher 객체를 생성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>cipherSpi</CODE> - delegate<DD><CODE>provider</CODE> - 프로바이더<DD><CODE>transformation</CODE> - 변환</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getInstance(java.lang.String)"><!-- --></A> <H3>
getInstance</H3>
<PRE>
public static final <A HREF="../../javax/crypto/Cipher.html" title="javax.crypto 내의 클래스">Cipher</A>  <B>getInstance</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;transformation)
                                throws <A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 내의 클래스">NoSuchAlgorithmException</A> ,
                                       <A HREF="../../javax/crypto/NoSuchPaddingException.html" title="javax.crypto 안의 클래스">NoSuchPaddingException</A> </PRE>
<DL>
<DD>지정된 변환을 구현하는 <code>Cipher</code> 객체를 돌려줍니다.

 <p> 이 메소드는, 최우선의 프로바이더로부터 순서에, 등록을 마친 시큐리티 프로바이더의 리스트를 횡단(traverse) 합니다. 지정된 알고리즘을 지원하는 최초의 프로바이더로부터의 CipherSpi 구현을 캡슐화하는 새로운 Cipher 객체가 돌려주어집니다.

 <p> 등록이 끝난 프로바이더의 리스트는,<A HREF="../../java/security/Security.html#getProviders()"><CODE>Security.getProviders()</CODE></A>  메소드 경유로 취득할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>transformation</CODE> - 변환의 이름. 예를 들어,<i>DES/CBC/PKCS5Padding</i>.
표준의 변환명에 대해서는, 「<a href=    "../../../technotes/guides/security/crypto/CryptoSpec.html#AppA">Java 암호화 아키텍쳐(architecture) 레퍼런스 가이드</a>」의 부록 A 를 참조
<DT><B>반환값:</B><DD>요구된 변환을 구현하는 암호
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 안의 클래스">NoSuchAlgorithmException</A> </CODE> - <code>transformation</code> 가 null, 빈 상태(empty), 또는 무효인 형식의 경우. 혹은, 지정된 알고리즘의 CipherSpi 구현을 지원하는 프로바이더가 존재하지 않는 경우
<DD><CODE><A HREF="../../javax/crypto/NoSuchPaddingException.html" title="javax.crypto 안의 클래스">NoSuchPaddingException</A> </CODE> - 사용할 수 없는 패딩 방식이 <code>transformation</code> 에 포함되어 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/security/Provider.html" title="java.security 내의 클래스"><CODE>Provider</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getInstance(java.lang.String, java.lang.String)"><!-- --></A> <H3>
getInstance</H3>
<PRE>
public static final <A HREF="../../javax/crypto/Cipher.html" title="javax.crypto 내의 클래스">Cipher</A>  <B>getInstance</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;transformation,
                                       <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;provider)
                                throws <A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 내의 클래스">NoSuchAlgorithmException</A> ,
                                       <A HREF="../../java/security/NoSuchProviderException.html" title="java.security 안의 클래스">NoSuchProviderException</A> ,
                                       <A HREF="../../javax/crypto/NoSuchPaddingException.html" title="javax.crypto 안의 클래스">NoSuchPaddingException</A> </PRE>
<DL>
<DD>지정된 변환을 구현하는 <code>Cipher</code> 객체를 돌려줍니다.

 <p> 지정된 프로바이더로부터의 CipherSpi 구현을 캡슐화하는 새로운 Cipher 객체가 돌려주어집니다. 지정한 프로바이더는, 시큐리티 프로바이더 리스트에 등록할 필요가 있습니다.

 <p> 등록이 끝난 프로바이더의 리스트는,<A HREF="../../java/security/Security.html#getProviders()"><CODE>Security.getProviders()</CODE></A>  메소드 경유로 취득할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>transformation</CODE> - 변환의 이름. 예를 들어,<i>DES/CBC/PKCS5Padding</i>.
표준의 변환명에 대해서는, 「<a href=    "../../../technotes/guides/security/crypto/CryptoSpec.html#AppA">Java 암호화 아키텍쳐(architecture) 레퍼런스 가이드</a>」의 부록 A 를 참조<DD><CODE>provider</CODE> - 프로바이더명
<DT><B>반환값:</B><DD>요구된 변환을 구현하는 암호
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 안의 클래스">NoSuchAlgorithmException</A> </CODE> - <code>transformation</code> 가 null, 빈 상태(empty), 또는 무효인 형식의 경우. 혹은, 지정된 알고리즘의 CipherSpi 구현이, 지정된 프로바이더로부터 사용할 수 없는 경우
<DD><CODE><A HREF="../../java/security/NoSuchProviderException.html" title="java.security 안의 클래스">NoSuchProviderException</A> </CODE> - 지정한 프로바이더가 시큐리티 프로바이더 리스트에 등록되지 않은 경우
<DD><CODE><A HREF="../../javax/crypto/NoSuchPaddingException.html" title="javax.crypto 안의 클래스">NoSuchPaddingException</A> </CODE> - 사용할 수 없는 패딩 방식이 <code>transformation</code> 에 포함되어 있는 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>provider</code> 가 null 또는 빈 상태(empty)의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/security/Provider.html" title="java.security 내의 클래스"><CODE>Provider</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getInstance(java.lang.String, java.security.Provider)"><!-- --></A> <H3>
getInstance</H3>
<PRE>
public static final <A HREF="../../javax/crypto/Cipher.html" title="javax.crypto 내의 클래스">Cipher</A>  <B>getInstance</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;transformation,
                                       <A HREF="../../java/security/Provider.html" title="java.security 안의 클래스">Provider</A> &nbsp;provider)
                                throws <A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 내의 클래스">NoSuchAlgorithmException</A> ,
                                       <A HREF="../../javax/crypto/NoSuchPaddingException.html" title="javax.crypto 안의 클래스">NoSuchPaddingException</A> </PRE>
<DL>
<DD>지정된 변환을 구현하는 <code>Cipher</code> 객체를 돌려줍니다.

 <p> 지정된 Provider 객체로부터의 CipherSpi 구현을 캡슐화하는 새로운 Cipher 객체가 돌려주어집니다. 지정한 Provider 객체는, 프로바이더 리스트에 등록할 필요는 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>transformation</CODE> - 변환의 이름. 예를 들어,<i>DES/CBC/PKCS5Padding</i>.
표준의 변환명에 대해서는, 「<a href=    "../../../technotes/guides/security/crypto/CryptoSpec.html#AppA">Java 암호화 아키텍쳐(architecture) 레퍼런스 가이드</a>」의 부록 A 를 참조<DD><CODE>provider</CODE> - 프로바이더
<DT><B>반환값:</B><DD>요구된 변환을 구현하는 암호
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 안의 클래스">NoSuchAlgorithmException</A> </CODE> - <code>transformation</code> 가 null, 빈 상태(empty), 또는 무효인 형식의 경우. 혹은, 지정된 알고리즘의 CipherSpi 구현이, 지정된 Provider 객체로부터 사용할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/NoSuchPaddingException.html" title="javax.crypto 안의 클래스">NoSuchPaddingException</A> </CODE> - 사용할 수 없는 패딩 방식이 <code>transformation</code> 에 포함되어 있는 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>provider</code> 가 null 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/security/Provider.html" title="java.security 내의 클래스"><CODE>Provider</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getProvider()"><!-- --></A> <H3>
getProvider</H3>
<PRE>
public final <A HREF="../../java/security/Provider.html" title="java.security 내의 클래스">Provider</A>  <B>getProvider</B>()</PRE>
<DL>
<DD>이 <code>Cipher</code> 객체의 프로바이더를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>Cipher</code> 객체의 프로바이더</DL>
</DD>
</DL>
<HR>

<A NAME="getAlgorithm()"><!-- --></A> <H3>
getAlgorithm</H3>
<PRE>
public final <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getAlgorithm</B>()</PRE>
<DL>
<DD>이 <code>Cipher</code> 객체의 알고리즘명을 돌려줍니다.

 <p>이것은, 이 <code>Cipher</code> 객체를 생성한 <code>getInstance</code> 호출의 어떤 것인가로 지정된 이름과 같습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>Cipher</code> 객체의 알고리즘명</DL>
</DD>
</DL>
<HR>

<A NAME="getBlockSize()"><!-- --></A> <H3>
getBlockSize</H3>
<PRE>
public final int <B>getBlockSize</B>()</PRE>
<DL>
<DD>블록 사이즈를 돌려줍니다 (바이트 단위).
<P>
<DD><DL>

<DT><B>반환값:</B><DD>블록 사이즈 (바이트 단위). 기본이 되는 알고리즘이 블록 암호가 아닌 경우는 0</DL>
</DD>
</DL>
<HR>

<A NAME="getOutputSize(int)"><!-- --></A> <H3>
getOutputSize</H3>
<PRE>
public final int <B>getOutputSize</B>(int&nbsp;inputLen)</PRE>
<DL>
<DD>입력의 길이 <code>inputLen</code> (바이트 단위)를 지정해, 다음의 <code>update</code> 또는 <code>doFinal</code> 조작의 결과를 보관 유지하기 위해서 필요한 출력 버퍼의 길이를 바이트수로 돌려줍니다.

 <p>이 호출에서는, 이전의 <code>update</code> 호출의 처리되어 있지 않은 (버퍼에 있다) 데이터를 고려해, 패딩 합니다.

 <p>다음의 <code>update</code> 또는 <code>doFinal</code> 호출의 실제의 출력 길이은, 이 메소드가 돌려주는 길이보다 작은 일이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inputLen</CODE> - 입력 길이 (바이트 단위)
<DT><B>반환값:</B><DD>필요한 출력 버퍼 사이즈 (바이트 단위)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 ( 아직 초기화되어 있지 않은 등)</DL>
</DD>
</DL>
<HR>

<A NAME="getIV()"><!-- --></A> <H3>
getIV</H3>
<PRE>
public final byte[] <B>getIV</B>()</PRE>
<DL>
<DD>새로운 버퍼의 초기화 벡터 (IV)를 돌려줍니다.

 <p>이것은, 랜덤 IV 가 작성되었을 경우, 혹은 IV 가 사용자 지정의 패스워드로부터 파생하는 패스워드 베이스의 암호화 또는 복호화의 문맥에 대해 도움이 됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>새로운 버퍼내의 초기화 벡터. 기본이 되는 알고리즘이 IV 를 사용하지 않는 경우, 또는 IV 가 설정되어 있지 않은 경우는 null</DL>
</DD>
</DL>
<HR>

<A NAME="getParameters()"><!-- --></A> <H3>
getParameters</H3>
<PRE>
public final <A HREF="../../java/security/AlgorithmParameters.html" title="java.security 내의 클래스">AlgorithmParameters</A>  <B>getParameters</B>()</PRE>
<DL>
<DD>이 암호로 사용되는 파라미터를 돌려줍니다.

 <p>반환되는 파라미터는, 이 암호를 초기화하는데 사용한 것과 같은 경우가 있습니다. 또는, 반환되는 파라미터에는, 이 암호에 알고리즘 파라미터가 필요해, 한편 알고리즘 파라미터로 초기화되지 않았던 경우에, 기본이 되는 암호 구현으로 사용되는 디폴트와 랜덤의 파라미터치의 편성이 포함되는 일도 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 암호로 사용되는 파라미터. 이 암호로 파라미터를 사용하지 않는 경우는 null</DL>
</DD>
</DL>
<HR>

<A NAME="getExemptionMechanism()"><!-- --></A> <H3>
getExemptionMechanism</H3>
<PRE>
public final <A HREF="../../javax/crypto/ExemptionMechanism.html" title="javax.crypto 내의 클래스">ExemptionMechanism</A>  <B>getExemptionMechanism</B>()</PRE>
<DL>
<DD>이 암호로 사용되는 Exemption Mechanism 객체를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 암호로 사용되는 Exemption Mechanism 객체. 이 암호로 Exemption Mechanism를 사용하지 않는 경우는 null</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.Key)"><!-- --></A> <H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key)
                throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> </PRE>
<DL>
<DD>열쇠를 사용해 이 암호를 초기화합니다.

 <p>이 암호는,<code>opmode</code> 의 값에 따라, 암호화, 복호화, 열쇠 랩핑, 또는 열쇠 랩핑 해제의 4 개의 조작의 1 개에 맞추어 초기화됩니다.

 <p>이 암호가, 지정된 <code>key</code> 로부터 파생할 수 없는 알고리즘 파라미터를 필요로 하는 경우, 기본이 되는 암호 구현은, 암호화 또는 열쇠 랩핑용으로 초기화되고 있으면, 프로바이더 고유의 디폴트 또는 랜덤치를 사용해 필요한 파라미터 자체를 생성해, 복호화 또는 열쇠 랩핑 해제용으로 초기화되고 있으면,<code>InvalidKeyException</code> 를 발생시킵니다. 생성된 파라미터는,<A HREF="../../javax/crypto/Cipher.html#getParameters()"><CODE>getParameters</CODE></A>  또는 <A HREF="../../javax/crypto/Cipher.html#getIV()"><CODE>getIV</CODE></A>  (파라미터가 IV 의 경우)를 사용해 꺼낼 수가 있습니다.

 <p>이 암호 (기본이 되는 피드백 또는 패딩 방식을 포함한다)가 난수 바이트를 필요로 하는 경우 (파라미터 생성을 위해 등)는, random number generation의 원으로서 최우선의 순위로 인스톨 되고 있는 프로바이더 <A HREF="../../java/security/SecureRandom.html" title="java.security 중의 클래스"><CODE><code>SecureRandom</code></CODE></A>  의 구현을 사용해 가져옵니다. SecureRandom 를 제공하는 프로바이더가 1 개나 인스톨되어 있지 않은 경우는, 시스템이 제공하는 random number generation의 원이 사용됩니다.

 <p>Cipher 객체를 초기화하면(자), 그때까지 획득한 상태가 모두 없어지는 것에 유의해 주세요. 즉, Cipher 를 초기화하는 것은, 그 Cipher 의 신규 인스턴스를 작성해 초기화하는 것으로 등가입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>opmode</CODE> - 이 암호의 조작 모드 (<code>ENCRYPT_MODE</code>,<code>DECRYPT_MODE</code>,<code>WRAP_MODE</code>, 또는 <code>UNWRAP_MODE</code> 의 어떤 것이나)<DD><CODE>key</CODE> - 키
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - 지정된 열쇠가 이 암호의 초기화에 올바르지 않은 경우, 이 암호가 복호화용으로 초기화되어 지정된 열쇠로부터 판정할 수가 없는 알고리즘 파라미터를 필요로 하는 경우, 또는 지정된 열쇠의 사이즈가 최대 허용열쇠 사이즈 (설정되어 있는 관할 정책 파일에 의해 결정)를 넘는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.Key, java.security.SecureRandom)"><!-- --></A> <H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
                       <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)
                throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> </PRE>
<DL>
<DD>열쇠와 random number generation의 원을 사용해 이 암호를 초기화합니다.

 <p>이 암호는,<code>opmode</code> 의 값에 따라, 암호화, 복호화, 열쇠 랩핑, 또는 열쇠 랩핑 해제의 4 개의 조작의 1 개에 맞추어 초기화됩니다.

 <p>이 암호가, 지정된 <code>key</code> 로부터 파생할 수 없는 알고리즘 파라미터를 필요로 하는 경우, 기본이 되는 암호 구현은, 암호화 또는 열쇠 랩핑용으로 초기화되고 있으면, 프로바이더 고유의 디폴트 또는 랜덤치를 사용해 필요한 파라미터 자체를 생성해, 복호화 또는 열쇠 랩핑 해제용으로 초기화되고 있으면,<code>InvalidKeyException</code> 를 발생시킵니다. 생성된 파라미터는,<A HREF="../../javax/crypto/Cipher.html#getParameters()"><CODE>getParameters</CODE></A>  또는 <A HREF="../../javax/crypto/Cipher.html#getIV()"><CODE>getIV</CODE></A>  (파라미터가 IV 의 경우)를 사용해 꺼낼 수가 있습니다.

 <p>이 암호 (기본이 되는 피드백 또는 패딩 방식을 포함한다)가 난수 바이트를 필요로 하는 경우 (파라미터 생성을 위해 등)는,<code>random</code> 로부터 가져옵니다.

 <p>Cipher 객체를 초기화하면(자), 그때까지 획득한 상태가 모두 없어지는 것에 유의해 주세요. 즉, Cipher 를 초기화하는 것은, 그 Cipher 의 신규 인스턴스를 작성해 초기화하는 것으로 등가입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>opmode</CODE> - 이 암호의 조작 모드 (<code>ENCRYPT_MODE</code>,<code>DECRYPT_MODE</code>,<code>WRAP_MODE</code>, 또는 <code>UNWRAP_MODE</code> 의 어떤 것이나)<DD><CODE>key</CODE> - 암호화열쇠<DD><CODE>random</CODE> - random number generation의 원
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - 지정된 열쇠가 이 암호의 초기화에 올바르지 않은 경우, 이 암호가 복호화용으로 초기화되어 지정된 열쇠로부터 판정할 수가 없는 알고리즘 파라미터를 필요로 하는 경우, 또는 지정된 열쇠의 사이즈가 최대 허용열쇠 사이즈 (설정되어 있는 관할 정책 파일에 의해 결정)를 넘는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.Key, java.security.spec.AlgorithmParameterSpec)"><!-- --></A> <H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
                       <A HREF="../../java/security/spec/AlgorithmParameterSpec.html" title="java.security.spec 안의 인터페이스">AlgorithmParameterSpec</A> &nbsp;params)
                throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> ,
                       <A HREF="../../java/security/InvalidAlgorithmParameterException.html" title="java.security 안의 클래스">InvalidAlgorithmParameterException</A> </PRE>
<DL>
<DD>열쇠와 알고리즘 파라미터세트를 사용해 이 암호를 초기화합니다.

 <p>이 암호는,<code>opmode</code> 의 값에 따라, 암호화, 복호화, 열쇠 랩핑, 또는 열쇠 랩핑 해제의 4 개의 조작의 1 개에 맞추어 초기화됩니다.

 <p>이 암호가 알고리즘 파라미터를 필요로 해,<code>params</code> 가 null 의 경우, 기본이 되는 암호 구현은, 암호화 또는 열쇠 랩핑용으로 초기화되고 있으면, 프로바이더 고유의 디폴트 또는 랜덤치를 사용해 필요한 파라미터 자체를 생성해, 복호화 또는 열쇠 랩핑 해제용으로 초기화되고 있으면,<code>InvalidAlgorithmParameterException</code> 를 발생시킵니다. 생성된 파라미터는,<A HREF="../../javax/crypto/Cipher.html#getParameters()"><CODE>getParameters</CODE></A>  또는 <A HREF="../../javax/crypto/Cipher.html#getIV()"><CODE>getIV</CODE></A>  (파라미터가 IV 의 경우)를 사용해 꺼낼 수가 있습니다.

 <p>이 암호 (기본이 되는 피드백 또는 패딩 방식을 포함한다)가 난수 바이트를 필요로 하는 경우 (파라미터 생성을 위해 등)는, random number generation의 원으로서 최우선의 순위로 인스톨 되고 있는 프로바이더 <A HREF="../../java/security/SecureRandom.html" title="java.security 중의 클래스"><CODE><code>SecureRandom</code></CODE></A>  의 구현을 사용해 가져옵니다. SecureRandom 를 제공하는 프로바이더가 1 개나 인스톨되어 있지 않은 경우는, 시스템이 제공하는 random number generation의 원이 사용됩니다.

 <p>Cipher 객체를 초기화하면(자), 그때까지 획득한 상태가 모두 없어지는 것에 유의해 주세요. 즉, Cipher 를 초기화하는 것은, 그 Cipher 의 신규 인스턴스를 작성해 초기화하는 것으로 등가입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>opmode</CODE> - 이 암호의 조작 모드 (<code>ENCRYPT_MODE</code>,<code>DECRYPT_MODE</code>,<code>WRAP_MODE</code>, 또는 <code>UNWRAP_MODE</code> 의 어떤 것이나)<DD><CODE>key</CODE> - 암호화열쇠<DD><CODE>params</CODE> - 알고리즘 파라미터
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - 지정된 열쇠가 이 암호의 초기화에 올바르지 않은 경우, 또는 지정된 열쇠의 사이즈가 최대 허용열쇠 사이즈 (설정되어 있는 관할 정책 파일에 의해 결정)를 넘는 경우
<DD><CODE><A HREF="../../java/security/InvalidAlgorithmParameterException.html" title="java.security 안의 클래스">InvalidAlgorithmParameterException</A> </CODE> - 지정된 알고리즘 파라미터가 이 암호에 올바르지 않은 경우, 이 암호가 복호화용으로 초기화되어 알고리즘 파라미터를 필요로 해,<code>params</code> 가 null 의 경우, 또는 지정된 알고리즘 파라미터가 유효한 제한 (설정되어 있는 관할 정책 파일에 의해 결정)을 넘는 암호화 강도를 나타내는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.Key, java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom)"><!-- --></A> <H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
                       <A HREF="../../java/security/spec/AlgorithmParameterSpec.html" title="java.security.spec 안의 인터페이스">AlgorithmParameterSpec</A> &nbsp;params,
                       <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)
                throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> ,
                       <A HREF="../../java/security/InvalidAlgorithmParameterException.html" title="java.security 안의 클래스">InvalidAlgorithmParameterException</A> </PRE>
<DL>
<DD>열쇠, 알고리즘 파라미터세트, 및 random number generation의 원을 사용해 이 암호를 초기화합니다.

 <p>이 암호는,<code>opmode</code> 의 값에 따라, 암호화, 복호화, 열쇠 랩핑, 또는 열쇠 랩핑 해제의 4 개의 조작의 1 개에 맞추어 초기화됩니다.

 <p>이 암호가 알고리즘 파라미터를 필요로 해,<code>params</code> 가 null 의 경우, 기본이 되는 암호 구현은, 암호화 또는 열쇠 랩핑용으로 초기화되고 있으면, 프로바이더 고유의 디폴트 또는 랜덤치를 사용해 필요한 파라미터 자체를 생성해, 복호화 또는 열쇠 랩핑 해제용으로 초기화되고 있으면,<code>InvalidAlgorithmParameterException</code> 를 발생시킵니다. 생성된 파라미터는,<A HREF="../../javax/crypto/Cipher.html#getParameters()"><CODE>getParameters</CODE></A>  또는 <A HREF="../../javax/crypto/Cipher.html#getIV()"><CODE>getIV</CODE></A>  (파라미터가 IV 의 경우)를 사용해 꺼낼 수가 있습니다.

 <p>이 암호 (기본이 되는 피드백 또는 패딩 방식을 포함한다)가 난수 바이트를 필요로 하는 경우 (파라미터 생성을 위해 등)는,<code>random</code> 로부터 가져옵니다.

 <p>Cipher 객체를 초기화하면(자), 그때까지 획득한 상태가 모두 없어지는 것에 유의해 주세요. 즉, Cipher 를 초기화하는 것은, 그 Cipher 의 신규 인스턴스를 작성해 초기화하는 것으로 등가입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>opmode</CODE> - 이 암호의 조작 모드 (<code>ENCRYPT_MODE</code>,<code>DECRYPT_MODE</code>,<code>WRAP_MODE</code>, 또는 <code>UNWRAP_MODE</code> 의 어떤 것이나)<DD><CODE>key</CODE> - 암호화열쇠<DD><CODE>params</CODE> - 알고리즘 파라미터<DD><CODE>random</CODE> - random number generation의 원
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - 지정된 열쇠가 이 암호의 초기화에 올바르지 않은 경우, 또는 지정된 열쇠의 사이즈가 최대 허용열쇠 사이즈 (설정되어 있는 관할 정책 파일에 의해 결정)를 넘는 경우
<DD><CODE><A HREF="../../java/security/InvalidAlgorithmParameterException.html" title="java.security 안의 클래스">InvalidAlgorithmParameterException</A> </CODE> - 지정된 알고리즘 파라미터가 이 암호에 올바르지 않은 경우, 이 암호가 복호화용으로 초기화되어 알고리즘 파라미터를 필요로 해,<code>params</code> 가 null 의 경우, 또는 지정된 알고리즘 파라미터가 유효한 제한 (설정되어 있는 관할 정책 파일에 의해 결정)을 넘는 암호화 강도를 나타내는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.Key, java.security.AlgorithmParameters)"><!-- --></A> <H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
                       <A HREF="../../java/security/AlgorithmParameters.html" title="java.security 안의 클래스">AlgorithmParameters</A> &nbsp;params)
                throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> ,
                       <A HREF="../../java/security/InvalidAlgorithmParameterException.html" title="java.security 안의 클래스">InvalidAlgorithmParameterException</A> </PRE>
<DL>
<DD>열쇠와 알고리즘 파라미터세트를 사용해 이 암호를 초기화합니다.

 <p>이 암호는,<code>opmode</code> 의 값에 따라, 암호화, 복호화, 열쇠 랩핑, 또는 열쇠 랩핑 해제의 4 개의 조작의 1 개에 맞추어 초기화됩니다.

 <p>이 암호가 알고리즘 파라미터를 필요로 해,<code>params</code> 가 null 의 경우, 기본이 되는 암호 구현은, 암호화 또는 열쇠 랩핑용으로 초기화되고 있으면, 프로바이더 고유의 디폴트 또는 랜덤치를 사용해 필요한 파라미터 자체를 생성해, 복호화 또는 열쇠 랩핑 해제용으로 초기화되고 있으면,<code>InvalidAlgorithmParameterException</code> 를 발생시킵니다. 생성된 파라미터는,<A HREF="../../javax/crypto/Cipher.html#getParameters()"><CODE>getParameters</CODE></A>  또는 <A HREF="../../javax/crypto/Cipher.html#getIV()"><CODE>getIV</CODE></A>  (파라미터가 IV 의 경우)를 사용해 꺼낼 수가 있습니다.

 <p>이 암호 (기본이 되는 피드백 또는 패딩 방식을 포함한다)가 난수 바이트를 필요로 하는 경우 (파라미터 생성을 위해 등)는, random number generation의 원으로서 최우선의 순위로 인스톨 되고 있는 프로바이더 <A HREF="../../java/security/SecureRandom.html" title="java.security 중의 클래스"><CODE><code>SecureRandom</code></CODE></A>  의 구현을 사용해 가져옵니다. SecureRandom 를 제공하는 프로바이더가 1 개나 인스톨되어 있지 않은 경우는, 시스템이 제공하는 random number generation의 원이 사용됩니다.

 <p>Cipher 객체를 초기화하면(자), 그때까지 획득한 상태가 모두 없어지는 것에 유의해 주세요. 즉, Cipher 를 초기화하는 것은, 그 Cipher 의 신규 인스턴스를 작성해 초기화하는 것으로 등가입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>opmode</CODE> - 이 암호의 조작 모드 (<code>ENCRYPT_MODE</code>,<code>DECRYPT_MODE</code>,<code>WRAP_MODE</code>, 또는 <code>UNWRAP_MODE</code> 의 어떤 것이나)<DD><CODE>key</CODE> - 암호화열쇠<DD><CODE>params</CODE> - 알고리즘 파라미터
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - 지정된 열쇠가 이 암호의 초기화에 올바르지 않은 경우, 또는 지정된 열쇠의 사이즈가 최대 허용열쇠 사이즈 (설정되어 있는 관할 정책 파일에 의해 결정)를 넘는 경우
<DD><CODE><A HREF="../../java/security/InvalidAlgorithmParameterException.html" title="java.security 안의 클래스">InvalidAlgorithmParameterException</A> </CODE> - 지정된 알고리즘 파라미터가 이 암호에 올바르지 않은 경우, 이 암호가 복호화용으로 초기화되어 알고리즘 파라미터를 필요로 해,<code>params</code> 가 null 의 경우, 또는 지정된 알고리즘 파라미터가 유효한 제한 (설정되어 있는 관할 정책 파일에 의해 결정)을 넘는 암호화 강도를 나타내는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.Key, java.security.AlgorithmParameters, java.security.SecureRandom)"><!-- --></A> <H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
                       <A HREF="../../java/security/AlgorithmParameters.html" title="java.security 안의 클래스">AlgorithmParameters</A> &nbsp;params,
                       <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)
                throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> ,
                       <A HREF="../../java/security/InvalidAlgorithmParameterException.html" title="java.security 안의 클래스">InvalidAlgorithmParameterException</A> </PRE>
<DL>
<DD>열쇠, 알고리즘 파라미터세트, 및 random number generation의 원을 사용해 이 암호를 초기화합니다.

 <p>이 암호는,<code>opmode</code> 의 값에 따라, 암호화, 복호화, 열쇠 랩핑, 또는 열쇠 랩핑 해제의 4 개의 조작의 1 개에 맞추어 초기화됩니다.

 <p>이 암호가 알고리즘 파라미터를 필요로 해,<code>params</code> 가 null 의 경우, 기본이 되는 암호 구현은, 암호화 또는 열쇠 랩핑용으로 초기화되고 있으면, 프로바이더 고유의 디폴트 또는 랜덤치를 사용해 필요한 파라미터 자체를 생성해, 복호화 또는 열쇠 랩핑 해제용으로 초기화되고 있으면,<code>InvalidAlgorithmParameterException</code> 를 발생시킵니다. 생성된 파라미터는,<A HREF="../../javax/crypto/Cipher.html#getParameters()"><CODE>getParameters</CODE></A>  또는 <A HREF="../../javax/crypto/Cipher.html#getIV()"><CODE>getIV</CODE></A>  (파라미터가 IV 의 경우)를 사용해 꺼낼 수가 있습니다.

 <p>이 암호 (기본이 되는 피드백 또는 패딩 방식을 포함한다)가 난수 바이트를 필요로 하는 경우 (파라미터 생성을 위해 등)는,<code>random</code> 로부터 가져옵니다.

 <p>Cipher 객체를 초기화하면(자), 그때까지 획득한 상태가 모두 없어지는 것에 유의해 주세요. 즉, Cipher 를 초기화하는 것은, 그 Cipher 의 신규 인스턴스를 작성해 초기화하는 것으로 등가입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>opmode</CODE> - 이 암호의 조작 모드 (<code>ENCRYPT_MODE</code>,<code>DECRYPT_MODE</code>,<code>WRAP_MODE</code>, 또는 <code>UNWRAP_MODE</code> 의 어떤 것이나)<DD><CODE>key</CODE> - 암호화열쇠<DD><CODE>params</CODE> - 알고리즘 파라미터<DD><CODE>random</CODE> - random number generation의 원
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - 지정된 열쇠가 이 암호의 초기화에 올바르지 않은 경우, 또는 지정된 열쇠의 사이즈가 최대 허용열쇠 사이즈 (설정되어 있는 관할 정책 파일에 의해 결정)를 넘는 경우
<DD><CODE><A HREF="../../java/security/InvalidAlgorithmParameterException.html" title="java.security 안의 클래스">InvalidAlgorithmParameterException</A> </CODE> - 지정된 알고리즘 파라미터가 이 암호에 올바르지 않은 경우, 이 암호가 복호화용으로 초기화되어 알고리즘 파라미터를 필요로 해,<code>params</code> 가 null 의 경우, 또는 지정된 알고리즘 파라미터가 유효한 제한 (설정되어 있는 관할 정책 파일에 의해 결정)을 넘는 암호화 강도를 나타내는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.cert.Certificate)"><!-- --></A> <H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       <A HREF="../../java/security/cert/Certificate.html" title="java.security.cert 안의 클래스">Certificate</A> &nbsp;certificate)
                throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> </PRE>
<DL>
<DD>이 암호를, 검증 조작을 위해서(때문에) 지정된 공개키로 초기화합니다. &nbsp;<p> 이 암호는,<code>opmode</code> 의 값에 따라, 암호화, 복호화, 열쇠 랩핑, 또는 열쇠 랩핑 해제의 4 개의 조작의 1 개에 맞추어 초기화됩니다.

 <p>증명서의 종류가 X. 509 로, 중요와 마크 된 <i>key usage</i> 확장 영역이 있어,<i>key usage</i> 확장 영역의 값에 의해 증명서의 공개키와 거기에 대응하는 비공개키가 <code>opmode</code> 의 값으로 나타내지는 조작에 사용되지 않는 것으로 있는 경우는,<code>InvalidKeyException</code> 가 throw 됩니다.

 <p> 이 암호가, 지정된 증명서의 공개키로부터 파생할 수 없는 알고리즘 파라미터를 필요로 하는 경우, 기본이 되는 암호 구현은, 암호화 또는 열쇠 랩핑용으로 초기화되고 있으면, 프로바이더 고유의 디폴트 또는 랜덤치를 사용해 필요한 파라미터 자체를 생성해, 복호화 또는 열쇠 랩핑 해제용으로 초기화되고 있으면,<code>InvalidKeyException</code> 를 발생시킵니다. 생성된 파라미터는,<A HREF="../../javax/crypto/Cipher.html#getParameters()"><CODE>getParameters</CODE></A>  또는 <A HREF="../../javax/crypto/Cipher.html#getIV()"><CODE>getIV</CODE></A>  (파라미터가 IV 의 경우)를 사용해 꺼낼 수가 있습니다.

 <p>이 암호 (기본이 되는 피드백 또는 패딩 방식을 포함한다)가 난수 바이트를 필요로 하는 경우 (파라미터 생성을 위해 등)는, random number generation의 원으로서 최우선의 순위로 인스톨 되고 있는 프로바이더의 <code>SecureRandom</code> 의 구현을 사용해 가져옵니다. SecureRandom 를 제공하는 프로바이더가 1 개나 인스톨되어 있지 않은 경우는, 시스템이 제공하는 random number generation의 원이 사용됩니다.

 <p>Cipher 객체를 초기화하면(자), 그때까지 획득한 상태가 모두 없어지는 것에 유의해 주세요. 즉, Cipher 를 초기화하는 것은, 그 Cipher 의 신규 인스턴스를 작성해 초기화하는 것으로 등가입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>opmode</CODE> - 이 암호의 조작 모드 (<code>ENCRYPT_MODE</code>,<code>DECRYPT_MODE</code>,<code>WRAP_MODE</code>, 또는 <code>UNWRAP_MODE</code> 의 어떤 것이나)<DD><CODE>certificate</CODE> - 증명서
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - 지정된 증명서의 공개키가 이 암호의 초기화에 올바르지 않은 경우, 이 암호가 복호화열쇠 또는 랩핑 해제열쇠용으로 초기화되어 지정된 증명서의 공개키로부터 판정할 수가 없는 알고리즘 파라미터를 필요로 하는 경우, 또는 지정된 증명서의 공개키의 사이즈가 최대 허용열쇠 사이즈 (설정되어 있는 관할 정책 파일에 의해 결정)를 넘는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="init(int, java.security.cert.Certificate, java.security.SecureRandom)"><!-- --></A> <H3>
init</H3>
<PRE>
public final void <B>init</B>(int&nbsp;opmode,
                       <A HREF="../../java/security/cert/Certificate.html" title="java.security.cert 안의 클래스">Certificate</A> &nbsp;certificate,
                       <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)
                throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> </PRE>
<DL>
<DD>이 암호를, 검증 조작을 위해서(때문에) 지정된 공개키 및 random number generation의 원을 사용해 초기화합니다.

 <p>이 암호는,<code>opmode</code> 의 값에 따라, 암호화, 복호화, 열쇠 랩핑, 또는 열쇠 랩핑 해제의 4 개의 조작의 1 개에 맞추어 초기화됩니다.

 <p>증명서의 종류가 X. 509 로, 중요와 마크 된 <i>key usage</i> 확장 영역이 있어,<i>key usage</i> 확장 영역의 값에 의해 증명서의 공개키와 거기에 대응하는 비공개키가 <code>opmode</code> 의 값으로 나타내지는 조작에 사용되지 않는 것으로 있는 경우는,<code>InvalidKeyException</code> 가 throw 됩니다.

 <p>이 암호가, 지정된 <code>certificate</code> 의 공개키로부터 파생할 수 없는 알고리즘 파라미터를 필요로 하는 경우, 기본이 되는 암호 구현은, 암호화 또는 열쇠 랩핑용으로 초기화되고 있으면, 프로바이더 고유의 디폴트 또는 랜덤치를 사용해 필요한 파라미터 자체를 생성해, 복호화 또는 열쇠 랩핑 해제용으로 초기화되고 있으면,<code>InvalidKeyException</code> 를 발생시킵니다. 생성된 파라미터는,<A HREF="../../javax/crypto/Cipher.html#getParameters()"><CODE>getParameters</CODE></A>  또는 <A HREF="../../javax/crypto/Cipher.html#getIV()"><CODE>getIV</CODE></A>  (파라미터가 IV 의 경우)를 사용해 꺼낼 수가 있습니다.

 <p>이 암호 (기본이 되는 피드백 또는 패딩 방식을 포함한다)가 난수 바이트를 필요로 하는 경우 (파라미터 생성을 위해 등)는,<code>random</code> 로부터 가져옵니다.

 <p>Cipher 객체를 초기화하면(자), 그때까지 획득한 상태가 모두 없어지는 것에 유의해 주세요. 즉, Cipher 를 초기화하는 것은, 그 Cipher 의 신규 인스턴스를 작성해 초기화하는 것으로 등가입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>opmode</CODE> - 이 암호의 조작 모드 (<code>ENCRYPT_MODE</code>,<code>DECRYPT_MODE</code>,<code>WRAP_MODE</code>, 또는 <code>UNWRAP_MODE</code> 의 어떤 것이나)<DD><CODE>certificate</CODE> - 증명서<DD><CODE>random</CODE> - random number generation의 원
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - 지정된 증명서의 공개키가 이 암호의 초기화에 올바르지 않은 경우, 이 암호가 복호화열쇠 또는 랩핑 해제열쇠용으로 초기화되어 지정된 증명서의 공개키로부터 판정할 수가 없는 알고리즘 파라미터를 필요로 하는 경우, 또는 지정된 증명서의 공개키의 사이즈가 최대 허용열쇠 사이즈 (설정되어 있는 관할 정책 파일에 의해 결정)를 넘는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="update(byte[])"><!-- --></A> <H3>
update</H3>
<PRE>
public final byte[] <B>update</B>(byte[]&nbsp;input)</PRE>
<DL>
<DD>복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다.

 <p><code>input</code> 버퍼내의 바이트가 처리되어 결과가 새로운 버퍼에 포함됩니다.

 <p><code>input</code> 의 길이가 제로의 경우, 이 메소드는 <code>null</code> 를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 버퍼
<DT><B>반환값:</B><DD>결과가 들어간 새로운 버퍼. 기본이 되는 암호가 블록 암호이며, 입력 데이터가 단인가 지나 새로운 블록이 되지 않는 경우는 null
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)</DL>
</DD>
</DL>
<HR>

<A NAME="update(byte[], int, int)"><!-- --></A> <H3>
update</H3>
<PRE>
public final byte[] <B>update</B>(byte[]&nbsp;input,
                           int&nbsp;inputOffset,
                           int&nbsp;inputLen)</PRE>
<DL>
<DD>복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다.

 <p><code>inputOffset</code> 로부터 시작되는,<code>input</code> 버퍼내의 최초의 <code>inputLen</code> 바이트가 처리되어 결과가 새로운 버퍼에 포함됩니다.

 <p><code>inputLen</code> 가 제로의 경우, 이 메소드는 <code>null</code> 를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 버퍼<DD><CODE>inputOffset</CODE> - 입력을 개시하는 <code>input</code> 내의 오프셋(offset)<DD><CODE>inputLen</CODE> - 입력 길이
<DT><B>반환값:</B><DD>결과가 들어간 새로운 버퍼. 기본이 되는 암호가 블록 암호이며, 입력 데이터가 단인가 지나 새로운 블록이 되지 않는 경우는 null
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)</DL>
</DD>
</DL>
<HR>

<A NAME="update(byte[], int, int, byte[])"><!-- --></A> <H3>
update</H3>
<PRE>
public final int <B>update</B>(byte[]&nbsp;input,
                        int&nbsp;inputOffset,
                        int&nbsp;inputLen,
                        byte[]&nbsp;output)
                 throws <A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 내의 클래스">ShortBufferException</A> </PRE>
<DL>
<DD>복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다.

 <p><code>inputOffset</code> 로부터 시작되는,<code>input</code> 버퍼내의 최초의 <code>inputLen</code> 바이트가 처리되어 결과가 <code>output</code> 버퍼에 포함됩니다.

 <p><code>output</code> 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우는,<code>ShortBufferException</code> 가 throw 됩니다. 이 경우, 보다 큰 출력 버퍼를 사용해 이 호출을 반복합니다. <A HREF="../../javax/crypto/Cipher.html#getOutputSize(int)"><CODE>getOutputSize</CODE></A>  를 사용해, 필요한 출력 버퍼의 사이즈를 판정합니다.

 <p><code>inputLen</code> 가 0 의 경우, 이 메소드는 길이 제로를 돌려줍니다.

 <p>주:이 메소드는 카피에 대해서 안전한 필요가 있습니다. 즉,<code>input</code> 및 <code>output</code> 버퍼는 같은 바이트 배열을 참조할 수가 있어 결과가 출력 버퍼에 카피될 때 미처리의 입력 데이터가 덧쓰기되지 않는 것이 필요합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 버퍼<DD><CODE>inputOffset</CODE> - 입력을 개시하는 <code>input</code> 내의 오프셋(offset)<DD><CODE>inputLen</CODE> - 입력 길이<DD><CODE>output</CODE> - 결과를 포함하는 버퍼
<DT><B>반환값:</B><DD><code>output</code> 에 포함된 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 안의 클래스">ShortBufferException</A> </CODE> - 지정된 출력 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="update(byte[], int, int, byte[], int)"><!-- --></A> <H3>
update</H3>
<PRE>
public final int <B>update</B>(byte[]&nbsp;input,
                        int&nbsp;inputOffset,
                        int&nbsp;inputLen,
                        byte[]&nbsp;output,
                        int&nbsp;outputOffset)
                 throws <A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 내의 클래스">ShortBufferException</A> </PRE>
<DL>
<DD>복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다.

 <p><code>inputOffset</code> 로부터 시작되는,<code>input</code> 버퍼내의 최초의 <code>inputLen</code> 바이트가 처리되어 결과는 <code>output</code> 버퍼의 <code>outputOffset</code> 로부터 시작되는 위치에 포함됩니다.

 <p><code>output</code> 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우는,<code>ShortBufferException</code> 가 throw 됩니다. 이 경우, 보다 큰 출력 버퍼를 사용해 이 호출을 반복합니다. <A HREF="../../javax/crypto/Cipher.html#getOutputSize(int)"><CODE>getOutputSize</CODE></A>  를 사용해, 필요한 출력 버퍼의 사이즈를 판정합니다.

 <p><code>inputLen</code> 가 0 의 경우, 이 메소드는 길이 제로를 돌려줍니다.

 <p>주:이 메소드는 카피에 대해서 안전한 필요가 있습니다. 즉,<code>input</code> 및 <code>output</code> 버퍼는 같은 바이트 배열을 참조할 수가 있어 결과가 출력 버퍼에 카피될 때 미처리의 입력 데이터가 덧쓰기되지 않는 것이 필요합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 버퍼<DD><CODE>inputOffset</CODE> - 입력을 개시하는 <code>input</code> 내의 오프셋(offset)<DD><CODE>inputLen</CODE> - 입력 길이<DD><CODE>output</CODE> - 결과를 포함하는 버퍼<DD><CODE>outputOffset</CODE> - 결과가 포함되는 <code>output</code> 내의 오프셋(offset)
<DT><B>반환값:</B><DD><code>output</code> 에 포함된 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 안의 클래스">ShortBufferException</A> </CODE> - 지정된 출력 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="update(java.nio.ByteBuffer, java.nio.ByteBuffer)"><!-- --></A> <H3>
update</H3>
<PRE>
public final int <B>update</B>(<A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;input,
                        <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;output)
                 throws <A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 내의 클래스">ShortBufferException</A> </PRE>
<DL>
<DD>복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다.

 <p><code>input.position()</code> 로부터 시작되는 모든 <code>input.remaining()</code> 바이트가 처리됩니다. 결과는 출력 버퍼에 포함됩니다. 종료시에, 입력 버퍼의 위치는 리밋트에 동일해집니다만, 리밋트는 변경되지 않습니다. 출력 버퍼의 위치는 n 만 증가합니다. n 는, 이 메소드가 돌려주는 값입니다. 출력 버퍼의 리밋트는 변경되지 않습니다.

 <p><code>output.remaining()</code> 바이트가 결과를 보관 유지하는데 불충분한 경우는,<code>ShortBufferException</code> 가 throw 됩니다. 이 경우, 보다 큰 출력 버퍼를 사용해 이 호출을 반복합니다. <A HREF="../../javax/crypto/Cipher.html#getOutputSize(int)"><CODE>getOutputSize</CODE></A>  를 사용해, 필요한 출력 버퍼의 사이즈를 판정합니다.

 <p>주:이 메소드는 카피에 대해서 안전한 필요가 있습니다. 즉,<code>input</code> 및 <code>output</code> 버퍼는 같은 메모리 블록을 참조할 수가 있어 결과가 출력 버퍼에 카피될 때 미처리의 입력 데이터가 덧쓰기되지 않는 것이 필요합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 ByteBuffer<DD><CODE>output</CODE> - 출력 ByteByffer
<DT><B>반환값:</B><DD><code>output</code> 에 포함된 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 입력과 출력이 같은 객체인 경우
<DD><CODE><A HREF="../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - 출력 버퍼가 읽어내 전용의 경우
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 안의 클래스">ShortBufferException</A> </CODE> - 출력 버퍼내에 남아 있는 용량이 부족한 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="doFinal()"><!-- --></A> <H3>
doFinal</H3>
<PRE>
public final byte[] <B>doFinal</B>()
                     throws <A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 내의 클래스">IllegalBlockSizeException</A> ,
                            <A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </PRE>
<DL>
<DD>복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 종료합니다.

 <p>입력 데이터는 전의 <code>update</code> 조작중에 버퍼에 넣어져, 패딩 (요구되었을 경우)이 적용되고 있는 경우가 있습니다. 결과는 새로운 버퍼에 포함됩니다.

 <p>종료시에, 이 메소드는 이 암호 객체를 앞에 두고 <code>init</code> 를 호출해 초기화되었을 때 상태에 리셋 합니다. 즉, 객체는 리셋 되어, 한층 더 데이터를 암호화 또는 복호화 하기 위해서 사용할 수 있습니다 (<code>init</code> 의 호출로 지정된 조작 모드에 의해 다르다).

 <p>주:예외가 throw 되는 경우, 이 암호 객체는 리셋 하지 않으면 재차 사용할 수 없는 경우가 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>결과가 들어간 새로운 버퍼
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> </CODE> - 이 암호가 블록 암호이며, 패딩이 요구되지 않고 (암호화 모드의 경우만), 이 암호로 처리된 데이터의 입력 길이의 합계가 블록 사이즈의 배수가 아닌 경우. 또는, 이 암호화 알고리즘이, 지정된 입력 데이터를 처리할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </CODE> - 이 암호가 복호화 모드이며, 패딩 (또는 패딩 해제)이 요구되었지만, 복호화 된 데이터가 적절한 패딩 바이트로 바인드 되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="doFinal(byte[], int)"><!-- --></A> <H3>
doFinal</H3>
<PRE>
public final int <B>doFinal</B>(byte[]&nbsp;output,
                         int&nbsp;outputOffset)
                  throws <A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 내의 클래스">IllegalBlockSizeException</A> ,
                         <A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 안의 클래스">ShortBufferException</A> ,
                         <A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </PRE>
<DL>
<DD>복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 종료합니다.

 <p>입력 데이터는 전의 <code>update</code> 조작중에 버퍼에 넣어져, 패딩 (요구되었을 경우)이 적용되고 있는 경우가 있습니다. 결과는,<code>outputOffset</code> 로부터 시작되는 <code>output</code> 버퍼에 포함됩니다.

 <p><code>output</code> 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우는,<code>ShortBufferException</code> 가 throw 됩니다. 이 경우, 보다 큰 출력 버퍼를 사용해 이 호출을 반복합니다. <A HREF="../../javax/crypto/Cipher.html#getOutputSize(int)"><CODE>getOutputSize</CODE></A>  를 사용해, 필요한 출력 버퍼의 사이즈를 판정합니다.

 <p>종료시에, 이 메소드는 이 암호 객체를 앞에 두고 <code>init</code> 를 호출해 초기화되었을 때 상태에 리셋 합니다. 즉, 객체는 리셋 되어, 한층 더 데이터를 암호화 또는 복호화 하기 위해서 사용할 수 있습니다 (<code>init</code> 의 호출로 지정된 조작 모드에 의해 다르다).

 <p>주:예외가 throw 되는 경우, 이 암호 객체는 리셋 하지 않으면 재차 사용할 수 없는 경우가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>output</CODE> - 결과를 포함하는 버퍼<DD><CODE>outputOffset</CODE> - 결과가 포함되는 <code>output</code> 내의 오프셋(offset)
<DT><B>반환값:</B><DD><code>output</code> 에 포함된 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> </CODE> - 이 암호가 블록 암호이며, 패딩이 요구되지 않고 (암호화 모드의 경우만), 이 암호로 처리된 데이터의 입력 길이의 합계가 블록 사이즈의 배수가 아닌 경우. 또는, 이 암호화 알고리즘이, 지정된 입력 데이터를 처리할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 안의 클래스">ShortBufferException</A> </CODE> - 지정된 출력 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </CODE> - 이 암호가 복호화 모드이며, 패딩 (또는 패딩 해제)이 요구되었지만, 복호화 된 데이터가 적절한 패딩 바이트로 바인드 되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="doFinal(byte[])"><!-- --></A> <H3>
doFinal</H3>
<PRE>
public final byte[] <B>doFinal</B>(byte[]&nbsp;input)
                     throws <A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 내의 클래스">IllegalBlockSizeException</A> ,
                            <A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </PRE>
<DL>
<DD>단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. 데이터는, 이 암호가 초기화된 방법에 따라, 암호화 또는 복호화 됩니다.

 <p><code>input</code> 버퍼내의 바이트, 및 전의 <code>update</code> 조작중에 버퍼에 넣어진 가능성이 있는 모든 입력 바이트가 처리되어 패딩 (요구되었을 경우)이 적용됩니다. 결과는 새로운 버퍼에 포함됩니다.

 <p>종료시에, 이 메소드는 이 암호 객체를 앞에 두고 <code>init</code> 를 호출해 초기화되었을 때 상태에 리셋 합니다. 즉, 객체는 리셋 되어, 한층 더 데이터를 암호화 또는 복호화 하기 위해서 사용할 수 있습니다 (<code>init</code> 의 호출로 지정된 조작 모드에 의해 다르다).

 <p>주:예외가 throw 되는 경우, 이 암호 객체는 리셋 하지 않으면 재차 사용할 수 없는 경우가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 버퍼
<DT><B>반환값:</B><DD>결과가 들어간 새로운 버퍼
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> </CODE> - 이 암호가 블록 암호이며, 패딩이 요구되지 않고 (암호화 모드의 경우만), 이 암호로 처리된 데이터의 입력 길이의 합계가 블록 사이즈의 배수가 아닌 경우. 또는, 이 암호화 알고리즘이, 지정된 입력 데이터를 처리할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </CODE> - 이 암호가 복호화 모드이며, 패딩 (또는 패딩 해제)이 요구되었지만, 복호화 된 데이터가 적절한 패딩 바이트로 바인드 되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="doFinal(byte[], int, int)"><!-- --></A> <H3>
doFinal</H3>
<PRE>
public final byte[] <B>doFinal</B>(byte[]&nbsp;input,
                            int&nbsp;inputOffset,
                            int&nbsp;inputLen)
                     throws <A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 내의 클래스">IllegalBlockSizeException</A> ,
                            <A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </PRE>
<DL>
<DD>단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. 데이터는, 이 암호가 초기화된 방법에 따라, 암호화 또는 복호화 됩니다.

 <p><code>inputOffset</code> 로부터 시작되는 <code>input</code> 버퍼내의 최초의 <code>inputLen</code> 바이트, 및 전의 <code>update</code> 조작으로 버퍼에 넣어진 가능성이 있는 모든 입력 바이트가 처리되어 패딩 (요구되었을 경우)이 적용됩니다. 결과는 새로운 버퍼에 포함됩니다.

 <p>종료시에, 이 메소드는 이 암호 객체를 앞에 두고 <code>init</code> 를 호출해 초기화되었을 때 상태에 리셋 합니다. 즉, 객체는 리셋 되어, 한층 더 데이터를 암호화 또는 복호화 하기 위해서 사용할 수 있습니다 (<code>init</code> 의 호출로 지정된 조작 모드에 의해 다르다).

 <p>주:예외가 throw 되는 경우, 이 암호 객체는 리셋 하지 않으면 재차 사용할 수 없는 경우가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 버퍼<DD><CODE>inputOffset</CODE> - 입력을 개시하는 <code>input</code> 내의 오프셋(offset)<DD><CODE>inputLen</CODE> - 입력 길이
<DT><B>반환값:</B><DD>결과가 들어간 새로운 버퍼
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> </CODE> - 이 암호가 블록 암호이며, 패딩이 요구되지 않고 (암호화 모드의 경우만), 이 암호로 처리된 데이터의 입력 길이의 합계가 블록 사이즈의 배수가 아닌 경우. 또는, 이 암호화 알고리즘이, 지정된 입력 데이터를 처리할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </CODE> - 이 암호가 복호화 모드이며, 패딩 (또는 패딩 해제)이 요구되었지만, 복호화 된 데이터가 적절한 패딩 바이트로 바인드 되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="doFinal(byte[], int, int, byte[])"><!-- --></A> <H3>
doFinal</H3>
<PRE>
public final int <B>doFinal</B>(byte[]&nbsp;input,
                         int&nbsp;inputOffset,
                         int&nbsp;inputLen,
                         byte[]&nbsp;output)
                  throws <A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 내의 클래스">ShortBufferException</A> ,
                         <A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> ,
                         <A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </PRE>
<DL>
<DD>단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. 데이터는, 이 암호가 초기화된 방법에 따라, 암호화 또는 복호화 됩니다.

 <p><code>inputOffset</code> 로부터 시작되는 <code>input</code> 버퍼내의 최초의 <code>inputLen</code> 바이트, 및 전의 <code>update</code> 조작으로 버퍼에 넣어진 가능성이 있는 모든 입력 바이트가 처리되어 패딩 (요구되었을 경우)이 적용됩니다. 결과는 <code>output</code> 버퍼에 포함됩니다.

 <p><code>output</code> 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우는,<code>ShortBufferException</code> 가 throw 됩니다. 이 경우, 보다 큰 출력 버퍼를 사용해 이 호출을 반복합니다. <A HREF="../../javax/crypto/Cipher.html#getOutputSize(int)"><CODE>getOutputSize</CODE></A>  를 사용해, 필요한 출력 버퍼의 사이즈를 판정합니다.

 <p>종료시에, 이 메소드는 이 암호 객체를 앞에 두고 <code>init</code> 를 호출해 초기화되었을 때 상태에 리셋 합니다. 즉, 객체는 리셋 되어, 한층 더 데이터를 암호화 또는 복호화 하기 위해서 사용할 수 있습니다 (<code>init</code> 의 호출로 지정된 조작 모드에 의해 다르다).

 <p>주:예외가 throw 되는 경우, 이 암호 객체는 리셋 하지 않으면 재차 사용할 수 없는 경우가 있습니다.

 <p>주:이 메소드는 카피에 대해서 안전한 필요가 있습니다. 즉,<code>input</code> 및 <code>output</code> 버퍼는 같은 바이트 배열을 참조할 수가 있어 결과가 출력 버퍼에 카피될 때 미처리의 입력 데이터가 덧쓰기되지 않는 것이 필요합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 버퍼<DD><CODE>inputOffset</CODE> - 입력을 개시하는 <code>input</code> 내의 오프셋(offset)<DD><CODE>inputLen</CODE> - 입력 길이<DD><CODE>output</CODE> - 결과를 포함하는 버퍼
<DT><B>반환값:</B><DD><code>output</code> 에 포함된 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> </CODE> - 이 암호가 블록 암호이며, 패딩이 요구되지 않고 (암호화 모드의 경우만), 이 암호로 처리된 데이터의 입력 길이의 합계가 블록 사이즈의 배수가 아닌 경우. 또는, 이 암호화 알고리즘이, 지정된 입력 데이터를 처리할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 안의 클래스">ShortBufferException</A> </CODE> - 지정된 출력 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </CODE> - 이 암호가 복호화 모드이며, 패딩 (또는 패딩 해제)이 요구되었지만, 복호화 된 데이터가 적절한 패딩 바이트로 바인드 되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="doFinal(byte[], int, int, byte[], int)"><!-- --></A> <H3>
doFinal</H3>
<PRE>
public final int <B>doFinal</B>(byte[]&nbsp;input,
                         int&nbsp;inputOffset,
                         int&nbsp;inputLen,
                         byte[]&nbsp;output,
                         int&nbsp;outputOffset)
                  throws <A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 내의 클래스">ShortBufferException</A> ,
                         <A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> ,
                         <A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </PRE>
<DL>
<DD>단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. 데이터는, 이 암호가 초기화된 방법에 따라, 암호화 또는 복호화 됩니다.

 <p><code>inputOffset</code> 로부터 시작되는 <code>input</code> 버퍼내의 최초의 <code>inputLen</code> 바이트, 및 전의 <code>update</code> 조작으로 버퍼에 넣어진 가능성이 있는 모든 입력 바이트가 처리되어 패딩 (요구되었을 경우)이 적용됩니다. 결과는,<code>outputOffset</code> 로부터 시작되는 <code>output</code> 버퍼에 포함됩니다.

 <p><code>output</code> 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우는,<code>ShortBufferException</code> 가 throw 됩니다. 이 경우, 보다 큰 출력 버퍼를 사용해 이 호출을 반복합니다. <A HREF="../../javax/crypto/Cipher.html#getOutputSize(int)"><CODE>getOutputSize</CODE></A>  를 사용해, 필요한 출력 버퍼의 사이즈를 판정합니다.

 <p>종료시에, 이 메소드는 이 암호 객체를 앞에 두고 <code>init</code> 를 호출해 초기화되었을 때 상태에 리셋 합니다. 즉, 객체는 리셋 되어, 한층 더 데이터를 암호화 또는 복호화 하기 위해서 사용할 수 있습니다 (<code>init</code> 의 호출로 지정된 조작 모드에 의해 다르다).

 <p>주:예외가 throw 되는 경우, 이 암호 객체는 리셋 하지 않으면 재차 사용할 수 없는 경우가 있습니다.

 <p>주:이 메소드는 카피에 대해서 안전한 필요가 있습니다. 즉,<code>input</code> 및 <code>output</code> 버퍼는 같은 바이트 배열을 참조할 수가 있어 결과가 출력 버퍼에 카피될 때 미처리의 입력 데이터가 덧쓰기되지 않는 것이 필요합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 버퍼<DD><CODE>inputOffset</CODE> - 입력을 개시하는 <code>input</code> 내의 오프셋(offset)<DD><CODE>inputLen</CODE> - 입력 길이<DD><CODE>output</CODE> - 결과를 포함하는 버퍼<DD><CODE>outputOffset</CODE> - 결과가 포함되는 <code>output</code> 내의 오프셋(offset)
<DT><B>반환값:</B><DD><code>output</code> 에 포함된 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> </CODE> - 이 암호가 블록 암호이며, 패딩이 요구되지 않고 (암호화 모드의 경우만), 이 암호로 처리된 데이터의 입력 길이의 합계가 블록 사이즈의 배수가 아닌 경우. 또는, 이 암호화 알고리즘이, 지정된 입력 데이터를 처리할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 안의 클래스">ShortBufferException</A> </CODE> - 지정된 출력 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </CODE> - 이 암호가 복호화 모드이며, 패딩 (또는 패딩 해제)이 요구되었지만, 복호화 된 데이터가 적절한 패딩 바이트로 바인드 되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="doFinal(java.nio.ByteBuffer, java.nio.ByteBuffer)"><!-- --></A> <H3>
doFinal</H3>
<PRE>
public final int <B>doFinal</B>(<A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;input,
                         <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;output)
                  throws <A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 내의 클래스">ShortBufferException</A> ,
                         <A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> ,
                         <A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </PRE>
<DL>
<DD>단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. 데이터는, 이 암호가 초기화된 방법에 따라, 암호화 또는 복호화 됩니다.

 <p><code>input.position()</code> 로부터 시작되는 모든 <code>input.remaining()</code> 바이트가 처리됩니다. 결과는 출력 버퍼에 포함됩니다. 종료시에, 입력 버퍼의 위치는 리밋트에 동일해집니다만, 리밋트는 변경되지 않습니다. 출력 버퍼의 위치는 n 만 증가합니다. n 는, 이 메소드가 돌려주는 값입니다. 출력 버퍼의 리밋트는 변경되지 않습니다.

 <p><code>output.remaining()</code> 바이트가 결과를 보관 유지하는데 불충분한 경우는,<code>ShortBufferException</code> 가 throw 됩니다. 이 경우, 보다 큰 출력 버퍼를 사용해 이 호출을 반복합니다. <A HREF="../../javax/crypto/Cipher.html#getOutputSize(int)"><CODE>getOutputSize</CODE></A>  를 사용해, 필요한 출력 버퍼의 사이즈를 판정합니다.

 <p>종료시에, 이 메소드는 이 암호 객체를 앞에 두고 <code>init</code> 를 호출해 초기화되었을 때 상태에 리셋 합니다. 즉, 객체는 리셋 되어, 한층 더 데이터를 암호화 또는 복호화 하기 위해서 사용할 수 있습니다 (<code>init</code> 의 호출로 지정된 조작 모드에 의해 다르다).

 <p>주:예외가 throw 되는 경우, 이 암호 객체는 리셋 하지 않으면 재차 사용할 수 없는 경우가 있습니다.

 <p>주:이 메소드는 카피에 대해서 안전한 필요가 있습니다. 즉,<code>input</code> 및 <code>output</code> 버퍼는 같은 바이트 배열을 참조할 수가 있어 결과가 출력 버퍼에 카피될 때 미처리의 입력 데이터가 덧쓰기되지 않는 것이 필요합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 ByteBuffer<DD><CODE>output</CODE> - 출력 ByteBuffer
<DT><B>반환값:</B><DD><code>output</code> 에 포함된 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 입력과 출력이 같은 객체인 경우
<DD><CODE><A HREF="../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - 출력 버퍼가 읽어내 전용의 경우
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> </CODE> - 이 암호가 블록 암호이며, 패딩이 요구되지 않고 (암호화 모드의 경우만), 이 암호로 처리된 데이터의 입력 길이의 합계가 블록 사이즈의 배수가 아닌 경우. 또는, 이 암호화 알고리즘이, 지정된 입력 데이터를 처리할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 안의 클래스">ShortBufferException</A> </CODE> - 출력 버퍼내에 남아 있는 용량이 부족한 경우
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </CODE> - 이 암호가 복호화 모드이며, 패딩 (또는 패딩 해제)이 요구되었지만, 복호화 된 데이터가 적절한 패딩 바이트로 바인드 되지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="wrap(java.security.Key)"><!-- --></A> <H3>
wrap</H3>
<PRE>
public final byte[] <B>wrap</B>(<A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key)
                  throws <A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 내의 클래스">IllegalBlockSizeException</A> ,
                         <A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </PRE>
<DL>
<DD>열쇠를 랩 합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 랩 되는 열쇠
<DT><B>반환값:</B><DD>랩 된 열쇠
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> </CODE> - 이 암호가 블록 암호이며, 패딩이 요구되지 않고, 랩 되는 열쇠의 인코딩의 길이가 블록 사이즈의 배수가 아닌 경우
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - 이 암호를 사용해 열쇠를 랩 하는 것이 불가능한가 안전하지 않은 경우 (하드웨어 보호된 열쇠가 소프트웨어만의 암호에게 건네지는 경우 등)</DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(byte[], java.lang.String, int)"><!-- --></A> <H3>
unwrap</H3>
<PRE>
public final <A HREF="../../java/security/Key.html" title="java.security 내의 인터페이스">Key</A>  <B>unwrap</B>(byte[]&nbsp;wrappedKey,
                        <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;wrappedKeyAlgorithm,
                        int&nbsp;wrappedKeyType)
                 throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> ,
                        <A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 안의 클래스">NoSuchAlgorithmException</A> </PRE>
<DL>
<DD>전에 랩 된 열쇠를 랩 해제합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>wrappedKey</CODE> - 랩이 해제되는 열쇠<DD><CODE>wrappedKeyAlgorithm</CODE> - 랩 된 열쇠에 관련한 알고리즘<DD><CODE>wrappedKeyType</CODE> - 랩 된 열쇠의 타입. <code>SECRET_KEY</code>,<code>PRIVATE_KEY</code>, 또는 <code>PUBLIC_KEY</code> 의 어떤 것인가일 필요가 있다
<DT><B>반환값:</B><DD>랩 해제된 열쇠
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 이 암호가 잘못한 상태에 있는 경우 (초기화되어 있지 않은 등)
<DD><CODE><A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 안의 클래스">NoSuchAlgorithmException</A> </CODE> - 인스톨 되고 있는 어느 프로바이더도 <code>wrappedKeyAlgorithm</code> 의 타입 <code>wrappedKeyType</code> 의 열쇠를 작성할 수 없는 경우
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - <code>wrappedKey</code> 가 <code>wrappedKeyAlgorithm</code> 의 <code>wrappedKeyType</code> 타입의 랩 된 열쇠를 나타내지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getMaxAllowedKeyLength(java.lang.String)"><!-- --></A> <H3>
getMaxAllowedKeyLength</H3>
<PRE>
public static final int <B>getMaxAllowedKeyLength</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;transformation)
                                        throws <A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 내의 클래스">NoSuchAlgorithmException</A> </PRE>
<DL>
<DD>인스톨 되고 있는 JCE 관할 정책 파일에 따라, 지정된 변환의 열쇠의 최대 길이을 돌려줍니다. 강도가 무제한의 JCE 관할 정책 파일이 인스톨 되고 있는 경우는, Integer.MAX_VALUE 가 돌려주어집니다. JCE 관할 정책 파일의 열쇠의 디폴트 사이즈에 대해서는, 「<a href=    "../../../technotes/guides/security/crypto/CryptoSpec.html#AppE">Java 암호화 아키텍쳐(architecture) 레퍼런스 가이드</a>」의 부록 E 를 참조해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>transformation</CODE> - 암호 변환
<DT><B>반환값:</B><DD>비트 단위의 열쇠의 최대 길이 또는 Integer.MAX_VALUE
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>transformation</code> 가 null 의 경우
<DD><CODE><A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 안의 클래스">NoSuchAlgorithmException</A> </CODE> - <code>transformation</code> 가 유효한 변환이 아닌 경우. 즉, 「algorithm」또는 「algorithm/mode/padding」의 형식이 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMaxAllowedParameterSpec(java.lang.String)"><!-- --></A> <H3>
getMaxAllowedParameterSpec</H3>
<PRE>
public static final <A HREF="../../java/security/spec/AlgorithmParameterSpec.html" title="java.security.spec 내의 인터페이스">AlgorithmParameterSpec</A>  <B>getMaxAllowedParameterSpec</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;transformation)
                                                               throws <A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 내의 클래스">NoSuchAlgorithmException</A> </PRE>
<DL>
<DD>관할 정책 파일에 따라, 최대의 암호 파라미터치를 포함한 AlgorithmParameterSpec 객체를 돌려줍니다. 강도가 무제한의 JCE 관할 정책 파일이 인스톨 되고 있는 경우, 또는 지정된 변환의 파라미터의 최대 리밋트가 정책 파일에 존재하지 않는 경우, null 가 돌려주어집니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>transformation</CODE> - 암호 변환
<DT><B>반환값:</B><DD>최대치를 보관 유지하는 AlgorithmParameterSpec 또는 null
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>transformation</code> 가 null 의 경우
<DD><CODE><A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 안의 클래스">NoSuchAlgorithmException</A> </CODE> - <code>transformation</code> 가 유효한 변환이 아닌 경우. 즉, 「algorithm」또는 「algorithm/mode/padding」의 형식이 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Cipher.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/crypto/CipherInputStream.html" title="javax.crypto 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/crypto/Cipher.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="Cipher.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
