<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:47:12 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
javax.management.remote.rmi (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="javax.management.remote.rmi (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../javax/management/remote/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../../javax/management/timer/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?javax/management/remote/rmi/package-summary.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
패키지 javax.management.remote.rmi
</H2>
RMI 연결기는, RMI 를 사용해 클라이언트 요구를 원격 MBean 서버에 전송 하는, JMX 원격 API용의 연결기입니다.
<P>
<B>참조처:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>설명</B></A> 
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>인터페이스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/management/remote/rmi/RMIConnection.html" title="javax.management.remote.rmi 안의 인터페이스">RMIConnection</A> </B></TD>
<TD>클라이언트로부터 서버측의 MBeanServer 구현에 MBeanServer 요구를 송신하기 위해서 사용되는 RMI 객체입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/management/remote/rmi/RMIServer.html" title="javax.management.remote.rmi 안의 인터페이스">RMIServer</A> </B></TD>
<TD>RMI 연결기와의 접속의 확립에 사용되는 RMI 객체입니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/management/remote/rmi/RMIConnectionImpl.html" title="javax.management.remote.rmi 안의 클래스">RMIConnectionImpl</A> </B></TD>
<TD><A HREF="../../../../javax/management/remote/rmi/RMIConnection.html" title="javax.management.remote.rmi 안의 인터페이스"><CODE>RMIConnection</CODE></A>  인터페이스의 구현입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/management/remote/rmi/RMIConnectionImpl_Stub.html" title="javax.management.remote.rmi 안의 클래스">RMIConnectionImpl_Stub</A> </B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/management/remote/rmi/RMIConnector.html" title="javax.management.remote.rmi 안의 클래스">RMIConnector</A> </B></TD>
<TD>원격 RMI 연결기에의 접속입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/management/remote/rmi/RMIConnectorServer.html" title="javax.management.remote.rmi 안의 클래스">RMIConnectorServer</A> </B></TD>
<TD>원격 클라이언트로부터의 RMI 베이스의 접속을 작성하는 JMX API 연결기 서버입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/management/remote/rmi/RMIIIOPServerImpl.html" title="javax.management.remote.rmi 안의 클래스">RMIIIOPServerImpl</A> </B></TD>
<TD>IIOP 로부터 export 되어 IIOP 로부터 export 된 RMI 객체로서 클라이언트 접속을 작성하는 <A HREF="../../../../javax/management/remote/rmi/RMIServerImpl.html" title="javax.management.remote.rmi 동안의 클래스"><CODE>RMIServerImpl</CODE></A>  입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/management/remote/rmi/RMIJRMPServerImpl.html" title="javax.management.remote.rmi 안의 클래스">RMIJRMPServerImpl</A> </B></TD>
<TD>JRMP 로부터 export 되어 JRMP 로부터 export 된 RMI 객체로서 클라이언트 접속을 작성하는 <A HREF="../../../../javax/management/remote/rmi/RMIServer.html" title="javax.management.remote.rmi 동안의 인터페이스"><CODE>RMIServer</CODE></A>  객체입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/management/remote/rmi/RMIServerImpl.html" title="javax.management.remote.rmi 안의 클래스">RMIServerImpl</A> </B></TD>
<TD>연결기 서버를 나타내는 RMI 객체입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/management/remote/rmi/RMIServerImpl_Stub.html" title="javax.management.remote.rmi 안의 클래스">RMIServerImpl_Stub</A> </B></TD>
<TD>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A> <H2>
패키지 javax.management.remote.rmi 의 설명
</H2>

<P>
<p>RMI 연결기는, RMI 를 사용해 클라이언트 요구를 원격 MBean 서버에 전송 하는, JMX 원격 API용의 연결기입니다. 이 패키지에서는, RMI 연결기의 사용자가, 클라이언트측 및 서버측에서 직접 참조할 필요가 있는 클래스를 정의합니다. 사용자가 직접 참조하지 않는 클래스도 정의합니다만, 이러한 클래스는, RMI 연결기의 구현이 다른 경우도 상호 운용할 수 있도록(듯이) 정의할 필요가 있습니다. </p>

 <p>RMI 연결기는, RMI 의 JRMP 및 IIOP 트랜스폴트를 지원합니다. </p>

 <p>JMX 원격 API 의 대부분의 연결기와 같게, RMI 도 주소로서 <A HREF="../../../../javax/management/remote/JMXServiceURL.html" title="javax.management.remote 안의 클래스"><CODE>JMXServiceURL</CODE></A> 를 가지고 있는 것이 보통입니다. 이 주소의 프로토콜 부분은, 디폴트의 RMI 트랜스폴트 (JRMP)를 사용하는 연결기의 경우 <code>rmi</code>, RMI/IIOP 를 사용하는 연결기의 경우 <code>iiop</code> 가 됩니다. </p>

 <p>RMI 연결기 주소에는, 다음의 2 개의 형식이 있습니다. </p>

    <ul>
      <li>
        JNDI 형식. URL 디렉토리는, 연결기의 RMI Stub 검색 위치를 나타낸다. 이 RMI Stub는 연결기 서버에의 액세스를 제공하는 <CODE>javax.management.remote.rmi.RMIServerRMIServer</CODE> 형 Java 객체이다. 이 주소 형식을 사용해, URL 내의 외부 디렉토리 엔트리로부터 RMI Stub가 취득된다. 외부 디렉토리는, @link javax.naming JNDI 에 의해 인식되는 디렉토리의 어떤 것인가로, 일반적으로은 RMI 레지스트리, LDAP, 또는 COS

      <li>
        encode 형식. URL 디렉토리에는, 연결기 서버와의 접속에 필요한 정보가 포함된다. RMI/JRMP를 사용하는 경우, 매입 개행 문자없이 BASE64 encode 처리된, 서버 객체의 직렬화가 끝난 RMI Stub. RMI/IIOP를 사용하는 경우, 서버 객체의 CORBA IOR
    </ul>
    
 <p>주소의 자세한 것은 이하로 설명합니다. </p>


<h3>RMI 연결기 서버의 작성</h3>

 <p>일반적으로, RMI 연결기 서버를 작성하려면 ,<CODE>javax.management.remote.JMXConnectorServerFactory#newJMXConnectorServerJMXConnectorServerFactory.newJMXConnectorServer</CODE> 메소드에 RMI 연결기 주소를 지정합니다. 연결기 서버의 접속처 MBean 서버도, 이 메소드의 파라미터로서 지정할 수 있습니다. 다른 방법으로서 연결기 서버를 MBean 로서 MBean 서버에 등록하는 방법도 있습니다. </p>

 <p>RMI 연결기 서버는,<CODE>javax.management.remote.rmi.RMIConnectorServerRMIConnectorServer</CODE> 의 인스턴스를 조회해도 작성할 수 있습니다.  이 조회는, 명시적으로 행해도 MBean 서버의 <code>createMBean</code>메소드를 개입시켜 행해도 괜찮습니다. </p>

<h4>RMI 트랜스폴트의 선택</h4>

 <p>RMI 트랜스폴트 (JRMP 또는 IIOP)를 선택하려면 , 연결기 서버의 작성시에,<code>serviceURL</code>의 <code><em>protocol</em></code> 부분에 <code>rmi</code> 또는 <code>iiop</code>를 지정합니다. <A HREF="../../../../javax/management/remote/rmi/RMIServerImpl.html" title="javax.management.remote.rmi 안의 클래스"><CODE>RMIServerImpl</CODE></A> 의 적절한 서브 클래스를 인스턴스화해,<code>RMIConnectorServer</code>생성자 으로 지정하는 것에 의해, 특별한 연결기 서버를 작성할 수도 있습니다. </p>


<h4><a name="servergen">서버에 의해 생성된 연결기 주소</a> </h4>

 <p>지정한 <code>serviceURL</code> 의 URL 패스가 빈 상태(empty)의 경우(옵션의 호스트와 포트에 계속되는 부분), 또는 <code>serviceURL</code>를 지정하지 않았던 경우, 연결기 서버에 의해, 클라이언트가 접속을 위해서(때문에) 사용할 수 있는 새로운 <code>JMXServiceURL</code>가 작성됩니다. </p>

    <ul>

<li><p>다음과 같은 <code>serviceURL</code> 의 경우:</p>

        <pre>
        <code>service:jmx:rmi://<em>host</em>:<em>port</em></code>      
        </pre>

        <p>연결기 서버는 <CODE>javax.management.remote.rmi.RMIJRMPServerImplRMIJRMPServerImpl</CODE> 를 생성한다. 다음과 같은 <code>JMXServiceURL</code> 가 반환된다:</p>

        <pre>
        <code>service:jmx:rmi://<em>host</em>:<em>port</em>/stub/<em>XXXX</em></code>   
        </pre>

        <p>여기서 <code><em>XXXX</em></code> 는, 개행 문자없이 BASE64 encode 처리된, 생성된 객체의 직렬화 형식의 Stub입니다. </p>

<li><p>다음과 같은 <code>serviceURL</code> 의 경우:</p>

        <pre>
        <code>service:jmx:iiop://<em>host</em>:<em>port</em></code>     
        </pre>
        
        <p>연결기 서버는 <CODE>javax.management.remote.rmi.RMIIIOPServerImplRMIIIOPServerImpl</CODE> 를 생성한다. 다음과 같은 <code>JMXServiceURL</code> 가 반환된다:</p>

        <pre>
        <code>service:jmx:iiop://<em>host</em>:<em>port</em>/ior/IOR:<em>XXXX</em></code>       
        </pre>

        <p><code>IOR:<em>XXXX</em></code> 는, 생성된 객체의 IOR(Interoperable Object Reference)의 표준 CORBA encode</p>

<li><p><code>serviceURL</code> 가 존재하지 않는 경우, 사용자 지정의 <code>RMIServerImpl</code>가 필요하게 된다. 이 객체상의 <A HREF="../../../../javax/management/remote/rmi/RMIServerImpl.html#toStub()"><CODE>toStub</CODE></A>  메소드가 <A HREF="../../../../javax/rmi/CORBA/Stub.html" title="javax.rmi.CORBA 안의 클래스"><CODE>Stub</CODE></A>  의 인스턴스를 돌려주는 경우, 연결기 서버는 상기의 <code>iiop</code>형식을 사용해 <code>JMXServiceURL</code> 를 생성한다. 그 외의 경우,<code>rmi</code>형식을 사용해 <code>JMXServiceURL</code> 를 생성한다</p>

    </ul>

 <p>사용자 지정의 <code>serviceURL</code> 내의 <code><em>host</em></code>는 옵션입니다. 존재하는 경우, 생성된 <code>JMXServiceURL</code>에 카피됩니다만, 존재하지 않는 경우는 무시됩니다. 존재하지 않는 경우, 생성된 <code>JXMServiceURL</code>는 로컬 호스트명을 가집니다. </p>

 <p>사용자 지정의 <code>serviceURL</code> 내의 <code><em>port</em></code>도 옵션입니다. 존재하는 경우, 생성된 <code>JMXServiceURL</code>에 카피됩니다.  존재하지 않는 경우, 생성된 <code>JMXServiceURL</code> 는 포트를 가지지 않습니다. <code>rmi</code>프로토콜을 사용하는 <code>serviceURL</code> 에서는,<code><em>port</em></code>가 존재하는 경우, 생성된 원격 객체가 export 되는 포트를 나타냅니다. 그 이외의 영향은 없습니다. </p>

 <p>사용자가 <code>JMXServiceURL</code> 는 아니고 <code>RMIServerImpl</code>을 지정했을 경우, 생성된 <code>JMXServiceURL</code> 의 <code><em>host</em></code>부분에 로컬 호스트명이 들어갑니다. <code><em>port</em></code> 부분은 없습니다. </p>


<h4><a name="directory">디렉토리 엔트리에 근거하는 연결기 주소</a> </h4>

 <p>연결기 서버의 작성시로 지정되는 <code>serviceURL</code> 주소에는, 생성된 주소 (상기) 대신에, 지정 또는 생성된 <code>RMIServer</code>Stub의 포함처가 되는 「디렉토리 주소」를 지정할 수도 있습니다. 이 경우, 클라이언트에서도 서버로도, 이 디렉토리 주소가 사용됩니다. </p>

 <p>이 경우,<code>serviceURL</code> 는 다음의 몇개의 형식을 취합니다. </p>

    <pre>
    <code>service:jmx:rmi://<em>host</em>:<em>port</em>/jndi/<em>jndi-name</em></code>
    <code>service:jmx:iiop://<em>host</em>:<em>port</em>/jndi/<em>jndi-name</em></code>
    </pre>

 <p><code><em>jndi-name</em></code> 는,<A HREF="../../../../javax/naming/InitialContext.html#bind(java.lang.String, java.lang.Object)"><CODE>javax.naming.InitialContext.bind</CODE></A> 로 지정 가능한 캐릭터 라인입니다. </p>

 <p>여기에서도,<code><em>host</em></code> 와 <code>:<em>port</em></code>는 생략 가능합니다. </p>

 <p>연결기 서버는, 프로토콜 (<code>rmi</code> 또는 <code>iiop</code>)에 근거해 <code>RMIServerImpl</code>를 생성합니다.  <code>rmi</code> 의 경우,<code><em>port</em></code>가 지정되고 있으면 사용됩니다. 연결기 서버는, 기동시에,<A HREF="../../../../javax/management/remote/rmi/RMIServerImpl.html#toStub()"><CODE>toStub</CODE></A> 메소드를 사용해 이 객체로부터 Stub를 파생해, 지정된 <code><em>jndi-name</em></code>를 사용해 객체를 포함합니다. 예의 같게, JNDI API.  에 의해 정의된 프로퍼티이 조회됩니다. </p>

 <p>예를 들어, 다음과 같은 <code>JMXServiceURL</code> 의 경우:

      <pre>
      <code>service:jmx:rmi://ignoredhost/jndi/rmi://myhost/myname</code>
      </pre>

연결기 서버는 <code>RMIJRMPServerImpl</code> 를 생성해, 아래와 같이 JNDI명을 사용해 그 Stub를 포함합니다.

      <pre>
      <code>rmi://myhost/myname</code>
      </pre>

이것은, 호스트 <code>myhost</code> 의 디폴트 포트로 실행되고 있는 RMI 레지스트리내의 엔트리 <code>myname</code>입니다. RMI 레지스트리는, 로컬 호스트로부터의 접속을 허가할 뿐입니다. 따라서, 이 경우,<code>myhost</code>는, 연결기 서버가 실행되고 있는 호스트의 이름이 됩니다. </p>

 <p>이 <code>JMXServiceURL</code> 에서는, 최초의 <code>rmi:</code>로 RMI 연결기, 2 번째의 <code>rmi:</code>로 RMI 레지스트리가 지정되고 있습니다. </p>

 <p>이제(벌써) 1 개(살)예를 듭니다.  다음과 같은 <code>JMXServiceURL</code> 의 경우:

      <pre>
      <code>service:jmx:iiop://ignoredhost/jndi/ldap://dirhost:9999/cn=this, ou=that</code>
      </pre>

연결기 서버는 <code>RMIIIOPServerImpl</code> 를 생성해, 아래와 같이 JNDI명을 사용해 그 Stub를 포함합니다.

      <pre>
      <code>ldap://dirhost:9999/cn=this, ou=that</code>
      </pre>

이것은, 호스트 <code>dirhost</code> 의 포트 9999 로 실행되고 있는 LDAP 디렉토리내의 엔트리 <code>cn=this, ou=that</code> 입니다. </p>

 <p>다음과 같은 <code>JMXServiceURL</code> 의 경우:

      <pre>
      <code>service:jmx:iiop://ignoredhost/jndi/cn=this, ou=that</code>
      </pre>

연결기 서버는 <code>RMIIIOPServerImpl</code> 를 생성해, 아래와 같이 JNDI명을 사용해 그 Stub를 포함합니다.

      <pre>
      <code>cn=this, ou=that</code>
      </pre>

이 경우, JNDI API 를 적절히 구성해, 사용하는 디렉토리의 정보를 지정할 필요가 있습니다. </p>

 <p>이러한 예에서는, 연결기 서버, 연결기 클라이언트 모두, 호스트명 <code>ignoredhost</code>를 사용하지 않습니다. 이 호스트명은 생략 가능합니다.  다음의 예를 참조해 주세요. </p>

      <pre>
      <code>service:jmx:iiop:///jndi/cn=this, ou=that</code>
      </pre>

 <p>그런데도, 연결기 서버가 실행되고 있는 호스트의 이름을 사용하는 것을 추천합니다. 일반적으로, 이 호스트명은, 디렉토리 호스트명과는 다릅니다. </p>


<h4>연결기 서버 속성</h4>

 <p>디폴트의 JRMP 트랜스폴트의 사용시는,<code>RMIConnectorServer</code> 생성자 의 <code>environment</code>의 <code>jmx.remote.rmi.client.socket.factory</code> 및 <code>jmx.remote.rmi.server.socket.factory</code>속성을 사용해, RMI 소켓 팩토리를 지정할 수 있습니다. 이러한 속성의 값은, 각각 <A HREF="../../../../java/rmi/server/RMIClientSocketFactory.html" title="java.rmi.server 안의 인터페이스"><CODE>RMIClientSocketFactory</CODE></A>  형 또는 <A HREF="../../../../java/rmi/server/RMIServerSocketFactory.html" title="java.rmi.server 안의 인터페이스"><CODE>RMIServerSocketFactory</CODE></A> 형이 아니면 안됩니다. 이러한 팩토리는, 연결기에 관련지을 수 있었던 RMI 객체를 작성할 때 사용됩니다. </p>

<h3>RMI 연결기 클라이언트의 작성</h3>

 <p>일반적으로, RMI 연결기 클라이언트의 구축에는,<A HREF="../../../../javax/management/remote/JMXConnectorFactory.html" title="javax.management.remote 안의 클래스"><CODE>JMXConnectorFactory</CODE></A>  와 프로토콜 <code>rmi</code>또는 <code>iiop</code> 를 가지는 <code>JMXServiceURL</code> 를 사용합니다. </p>

 <p><code>JMXServiceURL</code> 가 서버로 생성되었을 경우 (상기의<a href="#servergen">「서버에 의해 생성된 연결기 주소」</a>를 참조), 클라이언트는, 이 URL를 직접 또는 간접적으로 서버로부터 취득할 필요가 있습니다. 일반적으로, 서버는,<code>JMXServiceURL</code>를 사용 가능하게 하기 위한(해), 이 URL 를 파일 또는 검색 서비스에 포함합니다. </p>

 <p><code>JMXServiceURL</code> 가 디렉토리 구문을 사용하는 경우 (상기의<a href="#directory">「디렉토리 엔트리에 근거하는 연결기 주소」</a>를 참조), 이것은 클라이언트에 제공됩니다.  또는, 클라이언트와 서버의 양쪽 모두가 어느 디렉토리 엔트리를 사용해야할 것인가를 인식하고 있습니다. 예를 들어, Whatsit 에이전트의 연결기 서버는, 호스트 <code>myhost</code> 상의 RMI 레지스트리에 포함되고 있는 엔트리 <code>whatsit-agent-connector</code>를 사용한다고 합니다.  이 경우, 클라이언트와 서버의 양쪽 모두가 아래와 같은 적절한 <code>JMXServiceURL</code>를 인식할 수 있습니다. </p>

    <pre>
    <code>service:jmx:rmi:///jndi/rmi://myhost/whatsit-agent-connector</code>
    </pre>

 <p>RMI Stub의 형태가 <A HREF="../../../../javax/management/remote/rmi/RMIServer.html" title="javax.management.remote.rmi 안의 인터페이스"><CODE>RMIServer</CODE></A> 인 경우는,<A HREF="../../../../javax/management/remote/rmi/RMIConnector.html" title="javax.management.remote.rmi 안의 클래스"><CODE>RMIConnector</CODE></A> 의 적절한 생성자 을 사용해 직접 RMI 접속을 구축할 수 있습니다. </p>


<h3>RMI/IIOP 연결기의 ORB 의 지정</h3>

 <p>IIOP 트랜스폴트를 사용하는 경우, 클라이언트와 서버는, 속성 <code>java.naming.corba.orb</code>를 사용해, 사용하는 ORB 를 지정할 수 있습니다. ORB 와의 접속은, 연결기 서버의 경우는 <A HREF="../../../../javax/management/remote/rmi/RMIConnectorServer.html#start()"><CODE>start</CODE></A> 실행시, 연결기 클라이언트의 경우는 <CODE>javax.management.remote.rmi.RMIConnector#connect(java.util.Map) connect</CODE> 실행시에 확립됩니다. <code>java.naming.corba.orb</code> 속성이 환경 Map에 포함되는 경우, IIOP Stub의 접속에는 이 속성치 (<A HREF="../../../../org/omg/CORBA/ORB.html" title="org.omg.CORBA 안의 클래스"><CODE>ORB</CODE></A> )가 사용됩니다. 그 이외의 경우,<CODE>org.omg.CORBA.ORBorg.omg.CORBA.ORB.init((String[]) null, (Properties) null)</CODE> 가 불려 가 새로운 org.omg.CORBA.ORB 가 작성됩니다. 이 ORB 는, 같은 JVM 내의 후속의 RMI 연결기 클라이언트 또는 서버로 재사용할 수 있습니다. </p>

 <p>같은 순서로 새로운 ORB 를 작성할 수도 있습니다.  지정된 <code>java.naming.corba.orb</code> 속성이 <A HREF="../../../../org/omg/CORBA/ORB.html" title="org.omg.CORBA 안의 클래스"><CODE>ORB</CODE></A>  를 포인트 하고 있지 않는 경우,<code><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스"><CODE>IllegalArgumentException</CODE></A> </code> 가 throw 됩니다. </p>

 <p>IIOP 원격 객체 (Stub 또는 서버)가 수동으로 작성되어 ORB 에 접속된 뒤 RMIConnector 및 RMIConnectorServer 에게 건네지는 경우, 여기서 설명한 기구는 적용되지 않습니다. </p>


<h3>코드의 동적 다운로드</h3>

 <p>RMI 연결기 클라이언트 또는 서버가 그 피어로부터 미지의 클래스의 인스턴스를 수신했을 경우, RMI 접속으로 코드의 동적 다운로드가 유효하게 되어 있을 때는, 피어에 의해 지정된 코드 베이스로부터 클래스를 다운로드할 수 있습니다. 상세한 것에 대하여는,<a     href="../../../../../technotes/guides/rmi/codebase.html">「Dynamic code downloading using Java RMI」</a>를 참조해 주세요. <em></em></p>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><a href="../../../../../technotes/guides/rmi/index.html">
	Java<sup><font size="-1">TM</font></sup> Remote Method	Invocation (RMI)
</a> , 
<a href="../../../../../technotes/guides/jndi/index.html">
	Java Naming and Directory Interface<sup><font 	size="-1">TM</font></sup> (JNDI)</a>, 
<a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045,
    section 6.8, "Base64 Content-Transfer-Encoding"</a> </DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../javax/management/remote/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../../javax/management/timer/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?javax/management/remote/rmi/package-summary.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
