<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:03:52 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
DocFlavor (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="DocFlavor (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/DocFlavor.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/print/Doc.html" title="javax.print 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/print/DocFlavor.BYTE_ARRAY.html" title="javax.print 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/print/DocFlavor.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="DocFlavor.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.print</FONT>
<BR>
클래스 DocFlavor</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.print.DocFlavor</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> , <A HREF="../../java/lang/Cloneable.html" title="java.lang 안의 인터페이스">Cloneable</A> </DD>
</DL>
<DL>
<DT><B>직계의 기존의 서브 클래스:</B> <DD><A HREF="../../javax/print/DocFlavor.BYTE_ARRAY.html" title="javax.print 내의 클래스">DocFlavor.BYTE_ARRAY</A> , <A HREF="../../javax/print/DocFlavor.CHAR_ARRAY.html" title="javax.print 안의 클래스">DocFlavor.CHAR_ARRAY</A> , <A HREF="../../javax/print/DocFlavor.INPUT_STREAM.html" title="javax.print 안의 클래스">DocFlavor.INPUT_STREAM</A> , <A HREF="../../javax/print/DocFlavor.READER.html" title="javax.print 안의 클래스">DocFlavor.READER</A> , <A HREF="../../javax/print/DocFlavor.SERVICE_FORMATTED.html" title="javax.print 안의 클래스">DocFlavor.SERVICE_FORMATTED</A> , <A HREF="../../javax/print/DocFlavor.STRING.html" title="javax.print 안의 클래스">DocFlavor.STRING</A> , <A HREF="../../javax/print/DocFlavor.URL.html" title="javax.print 안의 클래스">DocFlavor.URL</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>DocFlavor</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> , <A HREF="../../java/lang/Cloneable.html" title="java.lang 안의 인터페이스">Cloneable</A> </DL>
</PRE>

<P>
<code>DocFlavor</code> 클래스는, 인쇄 데이터 <A HREF="../../javax/print/DocPrintJob.html" title="javax.print 중의 인터페이스"><CODE>DocPrintJob</CODE></A>  에의 제공 형식을 지정하는 객체를 캡슐화합니다. 「Doc」는, 인쇄 데이터의 일부를 의미하는, 짧게 발음하기 쉬운 용어입니다. 인쇄 데이터 형식인 「doc 후레이바」는, 이하의 2 개로 구성됩니다.  
 <UL>
 <LI>
<B>MIME 타입. </B>이것은, 인쇄 데이터를 해석하는 방법을 지정하는 Multipurpose Internet Mail Extensions (MIME) 미디어 타입 (<A HREF="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</A>  및 <A HREF="http://www.ietf.org/rfc/rfc2046.txt">RFC 2046</A>  으로 정의)입니다. 텍스트 데이터의 캐릭터 세트는, IANA MIME 우선명 또는 표준명 (우선명이 지정되어 있지 않은 경우)으로 할 필요가 있습니다. 게다가 이전의 버젼의 Java 플랫폼에서 지원되어 아픈 구두인가의 이름도 인식 가능합니다. Java 플랫폼에서 지원되는 캐릭터 세트의 자세한 것은,<a href="../../java/lang/package-summary.html#charenc">「캐릭터 세트」</a>  를 참조해 주세요.  &nbsp;<P>
 <LI>
<B>표현 클래스명. </B>인감 도장쇄데이터의 출력원객체의 클래스의 완전한 이름(FQN)을 지정합니다.  이것은,<A HREF="../../java/lang/Class.html#getName()"><CODE><CODE>Class.getName()</CODE></CODE></A>  메소드에 의해 돌려주어집니다. 이 때문에,<CODE>byte[]</CODE> 의 클래스명은 <CODE>「[B」</CODE>,<CODE>char[]</CODE> 의 클래스명은 <CODE>「[C」</CODE> 가 됩니다.  
 </UL>
 <P>
<code>DocPrintJob</code> 는,<A HREF="../../javax/print/Doc.html" title="javax.print 안의 인터페이스"><CODE>Doc</CODE></A>  인터페이스를 사용해 인쇄 데이터를 가져옵니다. <code>DocPrintJob</code> 는,<code>Doc</code> 객체를 사용해, 클라이언트가 제공 가능한 doc 후레이바를 판별할 수 있습니다. 또,<code>DocPrintJob</code> 는,<code>Doc</code> 객체를 사용해, doc 후레이바의 표현 클래스의 인스턴스를 취득할 수도 있습니다. <code> DocPrintJob</code> 는, 이 인스턴스로부터 인감 도장쇄데이터를 가져옵니다.  &nbsp;<P>
 <HR>
<H3>클라이언트 형식의 인쇄 데이터</H3>
인쇄 데이터는, 클라이언트 형식의 인쇄 데이터와 서비스 형식의 인쇄 데이터의 2 개의 카테고리에 크게 나눌 수가 있습니다.  &nbsp;<P>
<B>클라이언트 형식의 인쇄 데이터</B>의 경우, 클라이언트는 인쇄 데이터 형식을 인식 또는 판별합니다. 예를 들어, 클라이언트는, JPEG 로 encode 된 이미지, HTML 코드의 URL, 또는 어떤 것인가의 인코딩의 plaintext 파일을 포함한 디스크 파일을 (외부 소스로부터 취득하는 등 해) 보관 유지할 수가 있어 인쇄 서비스에 데이터 형식을 기술하는 수단을 필요로 합니다.  &nbsp;<p>
doc 후레이바의 표현 클래스는, JPS <code>DocPrintJob</code> 의 안녕 제트입니다.  이 표현 클래스를 사용해, 클라이언트로부터 문자 또는 바이트 순서를 취득할 수 있습니다. doc 후레이바의 MIME 타입은, 문자 또는 바이트 순서의 해석 방법을 지정하는, 어떤 것인가의 표준 미디어 타입입니다. 표준 미디어 타입의 리스트에 대해서는, Internet Assigned Numbers Authority (IANA)의 <A   HREF="http://www.isi.edu/in-notes/iana/assignments/media-types/">「Media Types Directory」</A>  를 참조해 주세요. 인터페이스 <A HREF="../../javax/print/Doc.html" title="javax.print 내의 인터페이스"><CODE>Doc</CODE></A>  는,<code>Doc</code> 객체의 클라이언트가 클라이언트 형식의 인쇄 데이터를 추출할 때에 이용 가능한 2 개의 유틸리티 조작,<A HREF="../../javax/print/Doc.html#getReaderForText()"><CODE>getReaderForText</CODE></A>  및 <A HREF="../../javax/print/Doc.html#getStreamForBytes()"><CODE>getStreamForBytes()</CODE></A>  를 제공합니다.  &nbsp;<P>
일반적으로, 클라이언트 형식의 인쇄 데이터는, 다음의 어떤 것인가의 인쇄 데이터 표현 클래스가 됩니다 (다른 표현 클래스도 사용 가능).  
 <UL>
 <LI>
문자 배열 (<CODE>char[]</CODE>) -- 인쇄 데이터는, 배열내의 Unicde 문자로 구성되는 &nbsp;<P>
 <LI>
<code>String</code>  -- 인쇄 데이터는, 캐릭터 라인내의 Unicode 문자로 구성되는 &nbsp;<P>
 <LI>
문자 스트림 (<A HREF="../../java/io/Reader.html" title="java.io 안의 클래스"><CODE>java.io.Reader</CODE></A> ) -- 인쇄 데이터는, 스트림을 최초부터 끝까지 읽어들인 Unicode 문자로 구성되는 &nbsp;<P>
 <LI>
바이트 배열 (<CODE>byte[]</CODE>) -- 인쇄 데이터는, 배열내의 바이트로 구성된다. 바이트는, doc 후레이바의 MIME 타입으로 지정된 캐릭터 세트에 encode 된다. MIME 타입으로 캐릭터 세트가 지정되지 않는 경우, 디폴트의 캐릭터 세트인 US-ASCII 가 사용되는 &nbsp;<P>
 <LI>
바이트 스트림 (<A HREF="../../java/io/InputStream.html" title="java.io 안의 클래스"><CODE>java.io.InputStream</CODE></A> ) -- 인쇄 데이터는, 스트림을 최초부터 끝까지 읽어들인 바이트로 구성된다. 바이트는, doc 후레이바의 MIME 타입으로 지정된 캐릭터 세트에 encode 된다. MIME 타입으로 캐릭터 세트가 지정되지 않는 경우, 디폴트의 캐릭터 세트인 US-ASCII 가 사용된다 

 <LI>
Uniform Resource Locator (<A HREF="../../java/net/URL.html" title="java.net 안의 클래스"><CODE>URL</CODE></A> ) -- 인쇄 데이터는, URL 위치로부터 읽힌 바이트로 구성된다. 바이트는, doc 후레이바의 MIME 타입으로 지정된 캐릭터 세트에 encode 된다. MIME 타입으로 캐릭터 세트가 지정되지 않는 경우, 디폴트의 캐릭터 세트인 US-ASCII 가 사용되는 &nbsp;<P>
표현 클래스가 URL 의 경우, 클라이언트를 개좌도에, 인쇄 서비스 자체가, URL 주소의 문서에의 액세스 및 다운로드를 직접 실행합니다. 서비스의 형태는, 다른 환경에서 실행되는 네트워크 인쇄 서비스의 경우도 있습니다. 이 때문에, 클라이언트로부터는 가시이지만 프린터로부터는 가시가 아닌 제한된 URL 의 문서는, URL 인쇄 데이타후레이바를 사용해 인쇄하지 말아 주세요. 또, 클라이언트와는 별개에 액세스 가능한 URL 에서는 사용 불가능한 로컬 파일에 포함된 문서도, URL 인쇄 데이타후레이바를 사용해 인쇄하지 말아 주세요. HTTP 서버 또는 FTP 서버가 제공하고 있지 않는 파일이 그 예입니다. 이러한 파일을 인쇄하려면 , 클라이언트를 사용해, URL 또는 파일의 입력 스트림을 열어, 입력 스트림을 데이타후레이바로서 사용합니다.
 </UL>
 <p>
 <HR>
<h3>디폴트 및 플랫폼의 인코딩</h3>
 <P>
doc 후레이바의 MIME 타입에 <CODE>charset</CODE> 파라미터가 포함되지 않는 바이트 인쇄 데이터의 경우, Java Print Service 인스턴스는, US-ASCII 캐릭터 세트가 디폴트로 설정되어 있는 것이라고 판단 합니다. 이것은, 디폴트 캐릭터 세트를 US-ASCII 로 한다고 하는,<A HREF="http://www.ietf.org/rfc/rfc2046.txt">RFC 2046</A>  에 근거하는 동작입니다. US-ASCII 는 UTF-8 의 부분집합이기 (위해)때문에, 장래 RFC 에 의해 UTF-8 가 디폴트로서 승인되었을 경우, US-ASCII 가 호환성을 유지하면서 확장될 가능성이 있습니다.  &nbsp;<p>
또, 이것은, 바이트 스트림을 텍스트 데이터로서 해석하는 경우의 Java 실행시의 동작과는 다른 경우가 있습니다. 이 경우에는, 사용자의 로케일의 디폴트 인코딩이라고 판단되기 (위해)때문에입니다. 이 때문에, 로컬 인코딩의 파일을 Java Print Service 에 spool 하는 경우에는, 인코딩을 정확하게 지정하는 것이 중요합니다. 특히, 영어 로케일로 작업을 실시하는 개발자는, 스스로의 플랫폼 인코딩이 디폴트 MIME 캐릭터 세트에 대응하고 있으므로, 이 점을 의식할 필요가 있습니다. 경우에 따라서는, 플랫폼 데이터의 인코딩을 지정하지 않아도 동작하는 것이 있기 때문에입니다.  &nbsp;<p>
Java 가상 머신의 각 인스턴스는, 가상 머신의 기동시로 결정되는 디폴트 캐릭터 세트를 보관 유지합니다.  또, 일반적으로, 기본  operating system가 사용하는 로케일 및 캐릭터 세트에 의존합니다. 분산환경에서는, 2 개의 VM 가 같은 디폴트 인코딩을 공유하는 것은 보증되지 않습니다. 이 때문에, 플랫폼에서 encode 된 텍스트 데이터를, 호스트 플랫폼으로부터 Java Print Service 인스턴스에 스트림 처리하는 클라이언트는, 캐릭터 세트를 명시적으로 선언해, 디폴트에 의존하지 않게 할 필요가 있습니다.  &nbsp;<p>
우선되는 형식은, 인코딩의 정식적 IANA primary명입니다. 텍스트 데이터를 스트림 처리하는 어플리케이션은, 캐릭터 세트를 항상 MIME 타입으로 지정할 필요가 있습니다.  이 때문에, 호스트 플랫폼의 인코딩으로 보존된 데이터 (파일 등)에 관한, 플랫폼의 인코딩을 취득할 필요가 있습니다. 이것에 대응해, DocFlavor 의 MIME 타입에서의 사용에 적절한 CharSet 는,<A HREF="../../javax/print/DocFlavor.html#hostEncoding"><CODE><CODE>DocFlavor.hostEncoding</CODE></CODE></A>  로부터 취득할 수 있습니다.  이것은, 항상 primary IANA 명이라고 하는 것은 아닙니다만, 확실히 이 가상 머신에 의해 이해됩니다. 일반적인 후레이바의 경우, 정의 끝난 *HOST DocFlavors 를 사용할 수 있습니다.  &nbsp;<p>
 <p>
Java 플랫폼에서 지원되는 캐릭터 세트의 자세한 것은,<a href="../../java/lang/package-summary.html#charenc">「캐릭터 세트」</a>  를 참조해 주세요.  &nbsp;<p>
 <HR>
<h3>추천 되는 DocFlavor</h3>
 <P>
Java Print Service API 는, 강제적으로 지원되는 DocFlavor 를 정의하지 않습니다. 다만, Java Print Service 인스턴스가, 클라이언트 형식의 인쇄 데이터로 지원 가능한 MIME 타입의 예를 몇개인가 가리킵니다. DocFlavor 클래스 내부에서 상자가 된 클래스는, 이러한 샘플 doc 후레이바의 경우, 정의 끝난 static 정수 DocFlavor 객체를 선언합니다.  DocFlavor 클래스의 생성자 을 사용해, 임의의 doc 후레이바를 작성할 수 있습니다.  
 <UL>
<LI>서식 설정 끝난 텍스트 &nbsp;<P>
 <TABLE BORDER=1 CELLPADDING=0 CELLSPACING=0 SUMMARY="MIME-Types and their descriptions">
 <TR>
<TH>MIME 타입</TH><TH>설명</TH>
 </TR>
 <TR>
<TD><CODE>"text/plain"</CODE></TD>
<TD>디폴트 캐릭터 세트 (US-ASCII)의 plaintext</TD>
 </TR>
 <TR>
<TD><CODE>「text/plain; charset=<I>xxx</I>」</CODE></TD>
<TD>캐릭터 세트 <I>xxx</I> 의 plaintext</TD>
 </TR>
 <TR>
<TD><CODE>"text/html"</CODE></TD>
<TD>디폴트 캐릭터 세트 (US-ASCII)의 하이퍼 텍스트(hyper text) 마크업 언어</TD>
 </TR>
 <TR>
<TD><CODE>「text/html; charset=<I>xxx</I>」</CODE></TD>
<TD>캐릭터 세트 <I>xxx</I> 의 하이퍼 텍스트(hyper text) 마크업 언어</TD>
 </TR>
 </TABLE>
 <P>
일반적으로, 서식 설정 끝난 텍스트 인쇄 데이터는, 문자 지향의 표현 클래스 (문자 배열, String, Reader), 또는 바이트 지향의 표현 클래스 (바이트 배열, InputStream, URL)에서 제공됩니다.  &nbsp;<P>
<LI>서식 설정 끝난 페이지 기술 언어 (PDL) 문서
<P>
 <TABLE BORDER=1 CELLPADDING=0 CELLSPACING=0 SUMMARY="MIME-Types and their descriptions">
 <TR>
<TH>MIME 타입</TH><TH>설명</TH>
 </TR>
<TR>
<TD><CODE>「application/pdf」</CODE></TD>
<TD>Portable Document Format 문서</TD>
 </TR>
 <TR>
<TD><CODE>「application/postscript」</CODE></TD>
<TD>PostScript 문서</TD>
 </TR>
 <TR>
<TD><CODE>「application/vnd.hp-PCL」</CODE></TD>
<TD>Printer Control Language 문서</TD>
 </TR>
 </TABLE>
 <P>
일반적으로, 서식 설정 끝난 PDL 인쇄 데이터는, 바이트 지향의 표현 클래스 (바이트 배열, InputStream, URL)에서 제공됩니다.  &nbsp;<P>
<LI>서식 설정 끝난 이미지
<P>
 <TABLE BORDER=1 CELLPADDING=0 CELLSPACING=0 SUMMARY="MIME-Types and their descriptions">
 <TR>
<TH>MIME 타입</TH><TH>설명</TH>
 </TR>
 
 <TR>
<TD><CODE>「image/gif」</CODE></TD>
<TD>Graphics Interchange Format 이미지</TD>
 </TR>
 <TR>
<TD><CODE>「image/jpeg」</CODE></TD>
<TD>Joint Photographic Experts Group 이미지</TD>
 </TR>
 <TR>
<TD><CODE>「image/png」</CODE></TD>
<TD>Portable Network Graphics 이미지</TD>
 </TR>
 </TABLE>
 <P>
일반적으로, 서식 설정 끝난 이미지 인쇄 데이터는, 바이트 지향의 표현 클래스 (바이트 배열, InputStream, URL)에서 제공됩니다.  &nbsp;<P>
<LI>서식 설정의 autosense 인쇄 데이터
   <P>
 <TABLE BORDER=1 CELLPADDING=0 CELLSPACING=0 SUMMARY="MIME-Types and their descriptions">
 <TR>
<TH>MIME 타입</TH><TH>설명</TH>
 </TR>
 
 <TR>
<TD><CODE>「application/octet-stream」</CODE></TD>
<TD>인쇄 데이터 형식은 지정되지 않는다 (octet 스트림만)</TD>
 </TABLE>
 <P>
프린터가, 인쇄 데이터의 해석 방법을 판별합니다.  이 「자동 인식」의 동작은, 구현에 따라서 다릅니다. 일반적으로, 서식 설정 끝난 autosense 인쇄 데이터는, 바이트 지향의 표현 클래스 (바이트 배열, InputStream, URL)에서 제공됩니다.
 
 <P>
 <HR>
<H3>서비스 형식의 인쇄 데이터</H3>
 <P>
<B>서비스 형식의 인쇄 데이터</B>의 경우, Java Print Service 인스턴스가 인쇄 데이터 형식을 판별합니다. doc 후레이바의 표현 클래스가 가리키는 인터페이스 (draw 가능한 이미지 인터페이스나 Java 로 인쇄 가능한 인터페이스등)의 메소드가,<code>DocPrintJob</code> 에 의해 불려 가 인쇄하는 내용이 결정됩니다. doc 후레이바의 MIME 타입은, 특수한 값 <CODE>「application/x-java-jvm-local-objectref」</CODE> 가 됩니다.  이 값은, 표현 클래스로서 명명된 인터페이스를 구현하는 클라이언트가 Java 객체에의 참조를 제공하는 것을 나타냅니다. 이 MIME 타입은 단순한 플레이스홀더이며, 중요한 것은 인쇄 데이터 표현 클래스입니다.  &nbsp;<P>
서비스 형식의 인쇄 데이터의 경우, 인쇄 데이터 표현 클래스는 (다른 표현 클래스를 이용 가능한 경우에서도) 일반적으로다음의 어떤 것인가가 됩니다. DocFlavor 클래스 내부에서 상자가 된 클래스는, 이러한 샘플 doc 후레이바의 경우, 정의 끝난 static 정수 DocFlavor 객체를 선언합니다.  DocFlavor 클래스의 생성자 을 사용해, 임의의 doc 후레이바를 작성할 수 있습니다.  
 <UL>
 <LI>
draw 가능한 이미지 객체 -- 클라이언트는,<A HREF="../../java/awt/image/renderable/RenderableImage.html" title="java.awt.image.renderable 안의 인터페이스"><CODE>RenderableImage</CODE></A>  인터페이스를 구현하는 객체를 제공합니다. 프린터는 이 인터페이스내의 메소드를 호출해, 인쇄하는 이미지를 가져옵니다.  &nbsp;<P>
 <LI>
인쇄 가능한 객체 -- 클라이언트는,<A HREF="../../java/awt/print/Printable.html" title="java.awt.print 안의 인터페이스"><CODE>Printable</CODE></A>  인터페이스를 구현하는 객체를 제공합니다. 프린터는 이 인터페이스내의 메소드를 호출해, 인쇄하는 페이지를 페이지 마다 가져옵니다. 프린터는 페이지 마다 그래픽스 문맥을 제공해, 클라이언트에 의해 그래픽스 문맥에 draw 된 내용이 모두 인쇄됩니다.  &nbsp;<P>
 <LI>
페이징 가능한 객체 -- 클라이언트는,<A HREF="../../java/awt/print/Pageable.html" title="java.awt.print 안의 인터페이스"><CODE>Pageable</CODE></A>  인터페이스를 구현하는 객체를 제공합니다. 프린터는 이 인터페이스내의 메소드를 호출해, 인쇄하는 페이지를 페이지 마다 가져옵니다. 프린터는 페이지 마다 그래픽스 문맥을 제공해, 클라이언트에 의해 그래픽스 문맥에 draw 된 내용이 모두 인쇄됩니다.  
 </UL>
 <P>
 <HR>
 <P>
 <HR>
<H3>정의 끝난 doc 후레이바</H3>
Java Print Service 인스턴스에는, 다음의 인쇄 데이터 형식 및 인쇄 데이터 표현 클래스를 지원하는 것은<B>요구되고 있지 않습니다</B>. 실제, 이 클래스를 사용하는 개발자는, 이러한 정의가 끝난 doc 후레이바에 대응하는 문서형을 특정의 인쇄 서비스가 지원하고 있다고는<b>절대로 상정하지 말아 주세요</b>. 항상 인쇄 서비스에 조회를 행해, 지원하는 doc 후레이바를 판별해 주세요. 다만, 이러한 doc 후레이바를 지원하는 인쇄 서비스를 보관 유지하는 개발자는, 여기서 작성된 정의 끝난 단독 인스턴스를 참조하는 것을 추천합니다. <I></I>
 <UL>
 <LI>
바이트 스트림을 개입시켜 제공되는 plaintext 인쇄 데이터. 특히, 다음의 doc 후레이바의 지원가 추천 되고 있다<BR>&#183;&nbsp;&nbsp; <CODE>("text/plain", "java.io.InputStream")</CODE> <BR>&#183;&nbsp;&nbsp; <CODE>("text/plain; charset=us-ascii", "java.io.InputStream")</CODE> <BR>&#183;&nbsp;&nbsp; <CODE>("text/plain; charset=utf-8", "java.io.InputStream")</CODE> &nbsp;<P>
 <LI>
draw 가능한 이미지 객체. 특히, 다음의 doc 후레이바의 지원가 추천 되고 있다<BR>&#183;&nbsp;&nbsp;<CODE>("application/x-java-jvm-local-objectref", "java.awt.image.renderable.RenderableImage")</CODE>
 </UL>
 <P>
Java Print Service 인스턴스는, 상기의 필수 doc 후레이바에 가세해 임의의 doc 후레이바를 지원 가능합니다 (필수의 doc 후레이바인 만큼 한정하는 일도 가능).  &nbsp;<P>
상기의 doc 후레이바의 지원가 추천 되고 있기 (위해)때문에, 인쇄를 실시하는 클라이언트는, 프린터가 지원하는 doc 후레이바에 관계없이, 임의의 JPS 프린터에 인쇄 가능하다라고 판단해 서로 지장있습니다. 프린터가 클라이언트의 우선 doc 후레이바를 지원하지 않는 경우, 클라이언트는 적어도 plaintext는 인쇄할 수 있습니다.  또, 데이터를 draw 가능한 이미지로 변환하고 나서 이미지를 인쇄하는 일도 가능합니다.  &nbsp;<P>
각 Java Print Service 인스턴스는, 다음에 나타내는 plaintext 인쇄 데이터의 처리 요건도 채울 필요가 있습니다.  
 <UL>
 <LI>
복귀 문자와 개행 문자의 페어 (CR-LF)는, 「다음의 행의 제 1 열로 이동한다」일을 의미한다 
 <LI>
복귀 (CR) 문자는, 그 자체로 「다음의 행의 제 1 열로 이동한다」일을 의미한다 
 <LI>
개행 (LF) 문자는, 그 자체로 「다음의 행의 제 1 열로 이동한다」일을 의미한다 
 <LI>
 </UL>
 <P>
클라이언트는, 상기의 요건에 포함되지 않는, 모든 plaintext 인쇄 데이터의 서식 설정을 실행할 필요가 있습니다.  &nbsp;<P>
<H3>설계의 근거</H3>
 <P>
javax.print.data 패키지내의 DocFlavor 클래스는,<A HREF="../../java/awt/datatransfer/DataFlavor.html" title="java.awt.datatransfer 안의 클래스"><CODE>DataFlavor</CODE></A>  클래스에 유사하고 있습니다. Java Print Service (JPS) API 에서는,<code>DataFlavor</code> 클래스는 다음의 3 개의 이유로써 사용되지 않습니다.  이러한 이유는 모두, JSP API 를 공유 가능한 다른 인쇄 서비스 API 가, Java Platform, Standard Edition 의 모든 것을 포함하지 않는 Java 프로파일상에서 실행되는 경우가 있는 것에 유래하고 있습니다.
 <OL TYPE=1>
 <LI>
JPS API 는, AWT 를 지원하지 않는 Java 프로파일로 사용하도록(듯이) 설계되고 있는 &nbsp;<P>
 <LI>
<code>java.awt.datatransfer.DataFlavor</code> 클래스의 구현은, 등가인 데이타후레이바가 같은 직렬화 표현을 보관 유지하는 것을 보증하지 않는다. DocFlavor 를 서비스로 사용하는 것으로, 등가인 데이타후레이바가 같은 직렬화 표현을 보관 유지하는 것이 보증되는 &nbsp;<P>
 <LI>
<code>java.awt.datatransfer.DataFlavor</code> 클래스의 구현에는, 판독 가능한 이름이 직렬화 표현의 일부에 포함된다. 이것은, 서비스 일치 제약의 일부로서는 부적절하다
 </OL>
 <P>
DocFlavor 클래스의 직렬화 표현은, 다음에 나타내는 정규 형식의 MIME 타입 캐릭터 라인을 사용합니다. 이 때문에, 동일하지 않게 등가 (정규 형식이 같다)의 MIME 타입을 보관 유지하는 2 개의 doc 후레이바는, 동일하다고 볼 수가 있습니다.  
 <UL>
<LI> 미디어 타입, 미디어 subtype, 및 파라미터는 보관 유지되지만, 코멘트 및 공백 문자는 모두 파기된다 
<LI> 미디어 타입, 미디어 subtype, 및 파라미터명은, 소문자에 변환된다
<LI> 파라미터치는 원의 대문자/소문자를 보관 유지한다. 다만, 텍스트 미디어 타입의 캐릭터 세트 파라미터치는, 소문자에 변환된다 
<LI> 파라미터치를 둘러싸는 인용부호 문자는, 삭제된다
<LI> 파라미터치 내부의 인용 backslash 문자는, 삭제된다
<LI> 파라미터는, 파라미터명을 키로 해 승순에 배치된다 
 </UL>
 <P>
DocFlavor 클래스의 직렬화 표현에는, 표현 클래스 그 자체 (Class 객체)는 아니고, 표현 클래스의 완전 지정된 클래스명 (String 객체)도 포함됩니다. 클라이언트는, 이 클래스명을 이용하는 것으로, 표현 클래스를 로드하지 않아도, Java Print Service 인스턴스가 지원하는 doc 후레이바를 검증할 수 있습니다.  클라이언트의 사용 가능한 자원이 한정되어 있는 경우, 표현 클래스의 로드에서 문제가 발생하는 것이 많기 때문에, 이것은 유용한 방법입니다.  &nbsp;<P>
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../serialized-form.html#javax.print.DocFlavor">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.BYTE_ARRAY.html" title="javax.print 안의 클래스">DocFlavor.BYTE_ARRAY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.BYTE_ARRAY 클래스는, 사전 정의된 static 정수 DocFlavor 객체를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.CHAR_ARRAY.html" title="javax.print 안의 클래스">DocFlavor.CHAR_ARRAY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.CHAR_ARRAY 클래스는, 사전 정의된 static 정수 DocFlavor 객체를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.INPUT_STREAM.html" title="javax.print 안의 클래스">DocFlavor.INPUT_STREAM</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.INPUT_STREAM 클래스는, 사전 정의된 static 정수 DocFlavor 객체를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.READER.html" title="javax.print 안의 클래스">DocFlavor.READER</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.READER 클래스는, 사전 정의된 static 정수 DocFlavor 객체를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.SERVICE_FORMATTED.html" title="javax.print 안의 클래스">DocFlavor.SERVICE_FORMATTED</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.SERVICE_FORMATTED 클래스는, 정의 끝난 static 정수 DocFlavor 객체 (예, 서비스 형식의 인쇄 데이터용 doc 후레이바)를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.STRING.html" title="javax.print 안의 클래스">DocFlavor.STRING</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.STRING 클래스는, 정의 끝난 static 정수 DocFlavor 객체를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.URL.html" title="javax.print 안의 클래스">DocFlavor.URL</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.URL 클래스는, 사전 정의된 static 정수 DocFlavor 객체를 제공합니다. </TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#hostEncoding">hostEncoding</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;호스트  operating system의 인코딩을 나타내는 캐릭터 라인입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#DocFlavor(java.lang.String, java.lang.String)">DocFlavor</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;mimeType,
          <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;className)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 MIME 타입 및 표현 클래스명으로부터 신규 doc 후레이바객체를 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#equals(java.lang.Object)">equals</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 doc 후레이바객체가 지정된 객체에 동일한지 어떤지를 판별합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#getMediaSubtype()">getMediaSubtype</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 doc 후레이바객체의 미디어 subtype을 (MIME 타입으로부터) 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#getMediaType()">getMediaType</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 doc 후레이바객체의 미디어 타입을 (MIME 타입으로부터) 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#getMimeType()">getMimeType</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 doc 후레이바객체의 MIME 타입 캐릭터 라인을, 정규 형식에서 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#getParameter(java.lang.String)">getParameter</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;paramName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MIME 파라미터를 나타내는 <code>String</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#getRepresentationClassName()">getRepresentationClassName</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 doc 후레이바객체의 표현 클래스의 이름이 돌려주어집니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#hashCode()">hashCode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 doc 후레이바객체의 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>DocFlavor</code> 를 캐릭터 라인으로 변환합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="hostEncoding"><!-- --></A> <H3>
hostEncoding</H3>
<PRE>
public static final <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>hostEncoding</B></PRE>
<DL>
<DD>호스트  operating system의 인코딩을 나타내는 캐릭터 라인입니다. 이것은<a href="http://ietf.org/rfc/rfc2278.txt">「RFC&nbsp;2278:&nbsp;IANA Charset Registration Procedures」</a>에 기재된 규칙에 따릅니다.  다만, Java 플랫폼의 이전의 버젼과의 호환성을 유지하기 위해(때문에), 이력명이 반환되는 점이 다릅니다. <i></i>메소드로부터 반환되는 값은, 값을 돌려주는 가상 머신 및 DocFlavor 로 사용하는 경우에만 유효합니다. 이것은, 실행하는 VM 내의, 「HOST」가 정의 끝난 모든 DocFlavor 에 대응하는 캐릭터 세트입니다.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DocFlavor(java.lang.String, java.lang.String)"><!-- --></A> <H3>
DocFlavor</H3>
<PRE>
public <B>DocFlavor</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;mimeType,
                 <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;className)</PRE>
<DL>
<DD>지정된 MIME 타입 및 표현 클래스명으로부터 신규 doc 후레이바객체를 구축합니다. 지정된 MIME 타입은, 정규 형식에 변환되어 내부에 포함됩니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>mimeType</CODE> - MIME 미디어 타입 캐릭터 라인<DD><CODE>className</CODE> - 완전 지정의 표현 클래스명
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 미확인의 예외. <CODE>mimeType</CODE> 가 null 의 경우, 
     또는 <CODE>className</CODE> 가 null 의 경우, throw 된다
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 미확인의 예외. <CODE>mimeType</CODE> 가 
     MIME 미디어 타입 캐릭터 라인의 구문에 따르지 않는 경우에 throw 된다</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getMimeType()"><!-- --></A> <H3>
getMimeType</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getMimeType</B>()</PRE>
<DL>
<DD>이 doc 후레이바객체의 MIME 타입 캐릭터 라인을, 정규 형식에서 돌려줍니다. 각 파라미터치는, 인용부호로 둘러싸인다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>MIME 타입</DL>
</DD>
</DL>
<HR>

<A NAME="getMediaType()"><!-- --></A> <H3>
getMediaType</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getMediaType</B>()</PRE>
<DL>
<DD>이 doc 후레이바객체의 미디어 타입을 (MIME 타입으로부터) 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>미디어 타입</DL>
</DD>
</DL>
<HR>

<A NAME="getMediaSubtype()"><!-- --></A> <H3>
getMediaSubtype</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getMediaSubtype</B>()</PRE>
<DL>
<DD>이 doc 후레이바객체의 미디어 subtype을 (MIME 타입으로부터) 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>미디어 subtype</DL>
</DD>
</DL>
<HR>

<A NAME="getParameter(java.lang.String)"><!-- --></A> <H3>
getParameter</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getParameter</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;paramName)</PRE>
<DL>
<DD>MIME 파라미터를 나타내는 <code>String</code> 를 돌려줍니다. MIME 타입에는, 일반적으로 옵션의 파라미터를 포함할 수가 있습니다. 텍스트 타입의 캐릭터 세트는, 샘플로서 자주(잘) 사용됩니다. 이 메소드는, 지정된 파라미터의 값이 이 후레이바의 MIME 타입내로 지정되고 있는 경우에, 그 값을 돌려줍니다.  &nbsp;<p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>paramName</CODE> - 파라미터명. 매칭의 실행전에,
 이 이름은 내부에서 정규의 소문자 형식에
 변환된다
<DT><B>반환값:</B><DD>MIME 파라미터를 나타내는 캐릭터 라인. 또는,
 파라미터가 MIME 타입 캐릭터 라인에 존재하지 않는 경우는 null
<DT><B>예외:</B>
<DD><CODE>throws</CODE> - paramName 가 null 의 경우에 NullPointerException 가 throw 된다</DL>
</DD>
</DL>
<HR>

<A NAME="getRepresentationClassName()"><!-- --></A> <H3>
getRepresentationClassName</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getRepresentationClassName</B>()</PRE>
<DL>
<DD>이 doc 후레이바객체의 표현 클래스의 이름이 돌려주어집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>표현 클래스의 이름</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 <code>DocFlavor</code> 를 캐릭터 라인으로 변환합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>정규 형식에 근거하는 MIME 타입 캐릭터 라인. 각 파라미터치는,
          인용부호로 둘러싸인다.  
          표현 클래스명을 나타내기 위해서(때문에), 「class=」파라미터가 
          MIME 타입 캐릭터 라인에 추가된다</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>이 doc 후레이바객체의 해시 코드를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 객체의 해시 코드값<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#equals(java.lang.Object)"><CODE>Object.equals(java.lang.Object)</CODE></A> , 
<A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>이 doc 후레이바객체가 지정된 객체에 동일한지 어떤지를 판별합니다. 지정된 객체가 null 는 아니고,<code>DocFlavor</code> 의 인스턴스이며, 이 doc 후레이바객체의 MIME 타입과 등가인 MIME 타입을 보관 유지하는 (즉, MIME 타입이 같은 미디어 타입, 미디어 subtype, 및 파라미터를 보관 유지한다) 경우, 및 이 doc 후레이바객체와 같은 표현 클래스명을 보관 유지하는 경우, 2 개의 객체는 동일해집니다. 이 때문에, 2 개의 doc 후레이바객체의 MIME 타입이 코멘트를 제외해 동일한 경우, 이것들은 동일하다고 보여집니다. 다만, MIME 타입 「text/plain」 및 「text/plain; charset=US-ASCII」를 보관 유지하는 2 개의 doc 후레이바객체는, 같은 미디어 타입을 나타내는 경우에서도, 동일하다고는 보여지지 않습니다 (plaintext의 디폴트 캐릭터 세트가 US-ASCII 이기 (위해)때문에).
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 판정되는 객체
<DT><B>반환값:</B><DD>이 doc 후레이바객체가 <CODE>obj</CODE> 에 동일한 경우는 true,
          그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A> , 
<A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/DocFlavor.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/print/Doc.html" title="javax.print 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/print/DocFlavor.BYTE_ARRAY.html" title="javax.print 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/print/DocFlavor.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="DocFlavor.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
