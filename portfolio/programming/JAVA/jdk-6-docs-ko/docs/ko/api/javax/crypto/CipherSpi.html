<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:01:31 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
CipherSpi (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="CipherSpi (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/CipherSpi.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/crypto/CipherOutputStream.html" title="javax.crypto 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/crypto/EncryptedPrivateKeyInfo.html" title="javax.crypto 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/crypto/CipherSpi.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="CipherSpi.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.crypto</FONT>
<BR>
클래스 CipherSpi</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.crypto.CipherSpi</B>
</PRE>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>CipherSpi</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
이 클래스는,<code>Cipher</code> 클래스의 Service Provider Interface (<b>SPI</b>)를 정의합니다. 특정의 암호 알고리즘의 구현을 제공하는 각 암호화 서비스 프로바이더는, 이 클래스의 모든 추상 메소드를 구현할 필요가 있습니다.

 <p>이 <code>CipherSpi</code> 클래스의 인스턴스를 캡슐화하는 <code>Cipher</code> 의 인스턴스를 생성하려면 , 어플리케이션은 <A HREF="../../javax/crypto/Cipher.html" title="javax.crypto 안의 클래스"><CODE>Cipher</CODE></A>  엔진 클래스의 <A HREF="../../javax/crypto/Cipher.html#getInstance(java.lang.String)"><CODE>getInstance</CODE></A>  팩토리 메소드의 1 개를 호출해, 요구된 「변환」을 지정합니다. 어플리케이션은, 필요에 따라서, 프로바이더의 이름을 지정할 수도 있습니다.

 <p>「변환」이란, 출력을 생성하기 위해서, 지정된 입력에 대해서 실행하는 조작 (또는 일련의 조작)을 기술하는 캐릭터 라인입니다. 변환에는 항상 암호화 알고리즘명 (DES 등)이 포함되어 있어 피드백 모드와 패딩 방식이 나중에 계속되는 일이 있습니다.

 <p> 변환은, 다음의 서식에서 기술됩니다. <p>

 <ul>
<li>"<i>algorithm/mode/padding</i>" 또는<p>
<li>"<i>algorithm</i>"
 </ul>

 <P> 후자의 경우, 모드와 패딩 방식에 대해서는 프로바이더 고유의 디폴트 값가 사용됩니다. 유효한 변환의 예를 다음에 나타냅니다. <p>

 <pre>
Cipher c = Cipher.getInstance("<i>DES/CBC/PKCS5Padding</i>");
 </pre>

 <p>프로바이더는, 「알고리즘/모드/패딩」의 각 편성에 대해서 개별의 클래스를 제공하든가, 혹은 「알고리즘」, 「알고리즘/모드」, 또는 「알고리즘//패딩」 (이중 slash에 주의)에 대응하는 서브 변환을 나타내는 것보다 총칭 클래스를 제공할 수가 있습니다. 총칭 클래스를 제공하는 경우, 요구된 모드나 패딩은, 프로바이더의 <code>CipherSpi</code> 의 서브 클래스의 <A HREF="../../javax/crypto/CipherSpi.html#engineSetMode(java.lang.String)"><CODE>engineSetMode</CODE></A>  및 <A HREF="../../javax/crypto/CipherSpi.html#engineSetPadding(java.lang.String)"><CODE>engineSetPadding</CODE></A>  메소드를 호출하는,<code>Cipher</code> 의 <code>getInstance</code> 메소드에 의해 자동적으로 설정됩니다.
 
 <p>프로바이더의 마스터 클래스내의 <code>Cipher</code> 프로퍼티의 형식은, 다음의 어떤 것인가가 됩니다.
 
 <ul>
 
 <li>
 <pre>
// provider's subclass of "CipherSpi" implements "algName" with
// pluggable mode and padding
<code>Cipher. </code><i>algName</i>
 </pre>
 
 <li>
 <pre>
// provider's subclass of "CipherSpi" implements "algName" in the
// specified "mode", with pluggable padding
<code>Cipher. </code><i>algName/mode</i>
 </pre>
 
 <li>
 <pre>
// provider's subclass of "CipherSpi" implements "algName" with the
// specified "padding", with pluggable mode
<code>Cipher. </code><i>algName//padding</i>
 </pre>
 
 <li>
 <pre>
// provider's subclass of "CipherSpi" implements "algName" with the
// specified "mode" and "padding"
<code>Cipher. </code><i>algName/mode/padding</i>
 </pre>
 
 </ul>
 
 <p>예를 들어, 프로바이더는 DES/ECB/PKCS5Padding, DES/CBC/PKCS5Padding, DES/CFB/PKCS5Padding, 한층 더 DES/OFB/PKCS5Padding 를 각각 구현하는 <code>CipherSpi</code> 의 서브 클래스를 제공 가능합니다. 이 프로바이더는, 마스터 클래스내에 다음의 <code>Cipher</code> 프로퍼티을 보관 유지합니다. <p>
 
 <ul>
 
 <li>
 <pre>
<code>Cipher. </code><i>DES/ECB/PKCS5Padding</i>
 </pre>
 
 <li>
 <pre>
<code>Cipher. </code><i>DES/CBC/PKCS5Padding</i>
 </pre>
 
 <li>
 <pre>
<code>Cipher. </code><i>DES/CFB/PKCS5Padding</i>
 </pre>
 
 <li>
 <pre>
<code>Cipher. </code><i>DES/OFB/PKCS5Padding</i>
 </pre>
 
 </ul>
 
 <p>다른 프로바이더는, 상기의 각 모드에 대응한 클래스 (ECB, CBC, CFB, 및 OFB 용으로 각각 1 개의 클래스)를 구현할 수 있습니다. 또, PKCS5Padding 에 대응하는 1 개의 클래스, 및 <code>CipherSpi</code> 로부터 서브 클래스화 된 총칭 DES 클래스도 구현할 수 있습니다. 이 프로바이더는, 마스터 클래스내에 다음의 <code>Cipher</code> 프로퍼티을 보관 유지합니다. <p>
 
 <ul>
 
 <li>
 <pre>
<code>Cipher. </code><i>DES</i>
 </pre>
 
 </ul>
 
 <p>「algorithm」형식의 변환의 경우,<code>Cipher</code> 엔진 클래스의 <code>getInstance</code> 팩토리 메소드는, 다음의 규칙에 따라 프로바이더의 <code>CipherSpi</code> 구현을 인스턴스화합니다.
 
 <ol>
 <li>
프로바이더가, 지정된 「algorithm」에 대응하는 <code>CipherSpi</code> 의 서브 클래스를 등록이 끝난 상태인가 어떤가를 체크한다. &nbsp;<p>등록을 마친 경우, 이 클래스를 인스턴스화해, 이 모드 및 패딩 방식의 디폴트 값 (프로바이더에 의해 제공)를 사용 가능하게 합니다. &nbsp;<p>미등록의 경우, 예외 <code>NoSuchAlgorithmException</code> 를 throw 합니다.
 </ol>
 
 <p>「algorithm/mode/padding」형식의 변환의 경우,<code>Cipher</code> 엔진 클래스의 <code>getInstance</code> 팩토리 메소드는, 다음의 규칙에 따라 프로바이더의 <code>CipherSpi</code> 구현을 인스턴스화합니다.
 
 <ol>
 <li>
프로바이더가, 지정된 「algorithm/mode/padding」변환에 대응하는 <code>CipherSpi</code> 의 서브 클래스를 등록이 끝난 상태인가 어떤가를 체크한다. &nbsp;<p>등록을 마친 경우, 이 클래스를 인스턴스화합니다. &nbsp;<p>미등록의 경우, 다음의 스텝에 진행됩니다. <p>
 <li>
프로바이더가, 서브 변환 「algorithm/mode」에 대응하는 <code>CipherSpi</code> 의 서브 클래스를 등록이 끝난 상태인가 어떤가를 체크한다. &nbsp;<p>등록을 마친 경우, 이 클래스를 인스턴스화하고 나서, 신규 인스턴스에 대해 <code>engineSetPadding(padding)</code> 를 호출합니다. &nbsp;<p>미등록의 경우, 다음의 스텝에 진행됩니다. <p>
 <li>
프로바이더가, 서브 변환 「algorithm//padding」 (더블즈 러쉬에 주의)에 대응하는 <code>CipherSpi</code> 의 서브 클래스를 등록이 끝난 상태인가 어떤가를 체크한다. &nbsp;<p>등록을 마친 경우, 이 클래스를 인스턴스화하고 나서, 신규 인스턴스에 대해 <code>engineSetMode(mode)</code> 를 호출합니다. &nbsp;<p>미등록의 경우, 다음의 스텝에 진행됩니다. <p>
 <li>
프로바이더가, 서브 변환 「algorithm」에 대응하는 <code>CipherSpi</code> 의 서브 클래스를 등록이 끝난 상태인가 어떤가를 체크한다. &nbsp;<p>등록을 마친 경우, 이 클래스를 인스턴스화하고 나서, 신규 인스턴스에 대해 <code>engineSetMode(mode)</code> 및 <code>engineSetPadding(padding)</code> 를 호출합니다. &nbsp;<p>미등록의 경우, 예외 <code>NoSuchAlgorithmException</code> 를 throw 합니다.
 </ol>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/crypto/KeyGenerator.html" title="javax.crypto 내의 클래스"><CODE>KeyGenerator</CODE></A> , 
<A HREF="../../javax/crypto/SecretKey.html" title="javax.crypto 안의 인터페이스"><CODE>SecretKey</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#CipherSpi()">CipherSpi</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineDoFinal(byte[], int, int)">engineDoFinal</A> </B>(byte[]&nbsp;input,
              int&nbsp;inputOffset,
              int&nbsp;inputLen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineDoFinal(byte[], int, int, byte[], int)">engineDoFinal</A> </B>(byte[]&nbsp;input,
              int&nbsp;inputOffset,
              int&nbsp;inputLen,
              byte[]&nbsp;output,
              int&nbsp;outputOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineDoFinal(java.nio.ByteBuffer, java.nio.ByteBuffer)">engineDoFinal</A> </B>(<A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;input,
              <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;output)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineGetBlockSize()">engineGetBlockSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;블록 사이즈를 돌려줍니다 (바이트 단위). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineGetIV()">engineGetIV</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 버퍼의 초기화 벡터 (IV)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineGetKeySize(java.security.Key)">engineGetKeySize</A> </B>(<A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 열쇠 객체의 열쇠 사이즈를 비트 단위로 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineGetOutputSize(int)">engineGetOutputSize</A> </B>(int&nbsp;inputLen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;입력의 길이 <code>inputLen</code> (바이트 단위)를 지정해, 다음의 <code>update</code> 또는 <code>doFinal</code> 조작의 결과를 보관 유지하기 위해서 필요한 출력 버퍼의 길이를 바이트수로 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;<A HREF="../../java/security/AlgorithmParameters.html" title="java.security 내의 클래스">AlgorithmParameters</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineGetParameters()">engineGetParameters</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 암호로 사용되는 파라미터를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineInit(int, java.security.Key, java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom)">engineInit</A> </B>(int&nbsp;opmode,
           <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
           <A HREF="../../java/security/spec/AlgorithmParameterSpec.html" title="java.security.spec 안의 인터페이스">AlgorithmParameterSpec</A> &nbsp;params,
           <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열쇠, 알고리즘 파라미터세트, 및 random number generation의 원을 사용해 이 암호를 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineInit(int, java.security.Key, java.security.AlgorithmParameters, java.security.SecureRandom)">engineInit</A> </B>(int&nbsp;opmode,
           <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
           <A HREF="../../java/security/AlgorithmParameters.html" title="java.security 안의 클래스">AlgorithmParameters</A> &nbsp;params,
           <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열쇠, 알고리즘 파라미터세트, 및 random number generation의 원을 사용해 이 암호를 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineInit(int, java.security.Key, java.security.SecureRandom)">engineInit</A> </B>(int&nbsp;opmode,
           <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
           <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열쇠와 random number generation의 원을 사용해 이 암호를 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineSetMode(java.lang.String)">engineSetMode</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 암호의 모드를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineSetPadding(java.lang.String)">engineSetPadding</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;padding)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 암호의 패딩 기구를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/security/Key.html" title="java.security 내의 인터페이스">Key</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineUnwrap(byte[], java.lang.String, int)">engineUnwrap</A> </B>(byte[]&nbsp;wrappedKey,
             <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;wrappedKeyAlgorithm,
             int&nbsp;wrappedKeyType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;전에 랩 된 열쇠를 랩 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineUpdate(byte[], int, int)">engineUpdate</A> </B>(byte[]&nbsp;input,
             int&nbsp;inputOffset,
             int&nbsp;inputLen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineUpdate(byte[], int, int, byte[], int)">engineUpdate</A> </B>(byte[]&nbsp;input,
             int&nbsp;inputOffset,
             int&nbsp;inputLen,
             byte[]&nbsp;output,
             int&nbsp;outputOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineUpdate(java.nio.ByteBuffer, java.nio.ByteBuffer)">engineUpdate</A> </B>(<A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;input,
             <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;output)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/crypto/CipherSpi.html#engineWrap(java.security.Key)">engineWrap</A> </B>(<A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열쇠를 랩 합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="CipherSpi()"><!-- --></A> <H3>
CipherSpi</H3>
<PRE>
public <B>CipherSpi</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="engineSetMode(java.lang.String)"><!-- --></A> <H3>
engineSetMode</H3>
<PRE>
protected abstract void <B>engineSetMode</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;mode)
                               throws <A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 내의 클래스">NoSuchAlgorithmException</A> </PRE>
<DL>
<DD>이 암호의 모드를 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>mode</CODE> - 암호화 모드
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 안의 클래스">NoSuchAlgorithmException</A> </CODE> - 요구된 암호화 모드가 존재하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="engineSetPadding(java.lang.String)"><!-- --></A> <H3>
engineSetPadding</H3>
<PRE>
protected abstract void <B>engineSetPadding</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;padding)
                                  throws <A HREF="../../javax/crypto/NoSuchPaddingException.html" title="javax.crypto 내의 클래스">NoSuchPaddingException</A> </PRE>
<DL>
<DD>이 암호의 패딩 기구를 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>padding</CODE> - 패딩 기구
<DT><B>예외:</B>
<DD><CODE><A HREF="../../javax/crypto/NoSuchPaddingException.html" title="javax.crypto 안의 클래스">NoSuchPaddingException</A> </CODE> - 요구된 패딩 기구가 존재하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="engineGetBlockSize()"><!-- --></A> <H3>
engineGetBlockSize</H3>
<PRE>
protected abstract int <B>engineGetBlockSize</B>()</PRE>
<DL>
<DD>블록 사이즈를 돌려줍니다 (바이트 단위).
<P>
<DD><DL>

<DT><B>반환값:</B><DD>블록 사이즈 (바이트 단위). 기본이 되는 알고리즘이 블록 암호가 아닌 경우는 0</DL>
</DD>
</DL>
<HR>

<A NAME="engineGetOutputSize(int)"><!-- --></A> <H3>
engineGetOutputSize</H3>
<PRE>
protected abstract int <B>engineGetOutputSize</B>(int&nbsp;inputLen)</PRE>
<DL>
<DD>입력의 길이 <code>inputLen</code> (바이트 단위)를 지정해, 다음의 <code>update</code> 또는 <code>doFinal</code> 조작의 결과를 보관 유지하기 위해서 필요한 출력 버퍼의 길이를 바이트수로 돌려줍니다.
 
 <p>이 호출에서는, 이전의 <code>update</code> 호출의 처리되어 있지 않은 (버퍼에 있다) 데이터를 고려해, 패딩 합니다.

 <p>다음의 <code>update</code> 또는 <code>doFinal</code> 호출의 실제의 출력 길이은, 이 메소드가 돌려주는 길이보다 작은 일이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inputLen</CODE> - 입력 길이 (바이트 단위)
<DT><B>반환값:</B><DD>필요한 출력 버퍼 사이즈 (바이트 단위)</DL>
</DD>
</DL>
<HR>

<A NAME="engineGetIV()"><!-- --></A> <H3>
engineGetIV</H3>
<PRE>
protected abstract byte[] <B>engineGetIV</B>()</PRE>
<DL>
<DD>새로운 버퍼의 초기화 벡터 (IV)를 돌려줍니다.  

 <p> 이것은, IV 가 사용자 지정의 패스 프레이즈로부터 파생하는 패스워드 베이스의 암호화 또는 복호화의 문맥에 대해 도움이 됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>새로운 버퍼내의 초기화 벡터. 기본이 되는 알고리즘이 IV 를 사용하지 않는 경우, 또는 IV 가 설정되어 있지 않은 경우는 null</DL>
</DD>
</DL>
<HR>

<A NAME="engineGetParameters()"><!-- --></A> <H3>
engineGetParameters</H3>
<PRE>
protected abstract <A HREF="../../java/security/AlgorithmParameters.html" title="java.security 내의 클래스">AlgorithmParameters</A>  <B>engineGetParameters</B>()</PRE>
<DL>
<DD>이 암호로 사용되는 파라미터를 돌려줍니다.

 <p>반환되는 파라미터는, 이 암호를 초기화하는데 사용한 것과 같은 경우가 있습니다. 또는, 반환되는 파라미터에는, 이 암호에 알고리즘 파라미터가 필요해, 한편 알고리즘 파라미터로 초기화되지 않았던 경우에, 기본이 되는 암호 구현으로 사용되는 디폴트와 랜덤의 파라미터치의 편성이 포함되는 일도 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 암호로 사용되는 파라미터. 이 암호로 파라미터를 사용하지 않는 경우는 null</DL>
</DD>
</DL>
<HR>

<A NAME="engineInit(int, java.security.Key, java.security.SecureRandom)"><!-- --></A> <H3>
engineInit</H3>
<PRE>
protected abstract void <B>engineInit</B>(int&nbsp;opmode,
                                   <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
                                   <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)
                            throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> </PRE>
<DL>
<DD>열쇠와 random number generation의 원을 사용해 이 암호를 초기화합니다.

 <p>이 암호는,<code>opmode</code> 의 값에 따라, 암호화, 복호화, 열쇠 랩핑, 또는 열쇠 랩핑 해제의 4 개의 조작의 1 개에 맞추어 초기화됩니다.

 <p>이 암호가, 지정된 <code>key</code> 로부터 파생할 수 없는 알고리즘 파라미터를 필요로 하는 경우, 기본이 되는 암호 구현은, 암호화 또는 열쇠 랩핑용으로 초기화되고 있으면, 프로바이더 고유의 디폴트 또는 랜덤치를 사용해 필요한 파라미터 자체를 생성해, 복호화 또는 열쇠 랩핑 해제용으로 초기화되고 있으면,<code>InvalidKeyException</code> 를 발생시킵니다. 생성된 파라미터는,<A HREF="../../javax/crypto/CipherSpi.html#engineGetParameters()"><CODE>engineGetParameters</CODE></A>  또는 <A HREF="../../javax/crypto/CipherSpi.html#engineGetIV()"><CODE>engineGetIV</CODE></A>  (파라미터가 IV 의 경우)를 사용해 꺼낼 수가 있습니다.

 <p>이 암호 (기본이 되는 피드백 또는 패딩 방식을 포함한다)가 난수 바이트를 필요로 하는 경우 (파라미터 생성을 위해 등)는,<code>random</code> 로부터 가져옵니다.

 <p>Cipher 객체가 초기화되면(자), 이전에 취득한 상태는 모두 없어집니다. 즉, Cipher 를 초기화하는 것은, 그 Cipher 의 새로운 인스턴스를 작성해 초기화하는 것과 같습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>opmode</CODE> - 이 암호의 조작 모드 (<code>ENCRYPT_MODE</code>,<code>DECRYPT_MODE</code>,<code>WRAP_MODE</code>, 또는 <code>UNWRAP_MODE</code> 의 어떤 것이나)<DD><CODE>key</CODE> - 암호화열쇠<DD><CODE>random</CODE> - random number generation의 원
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - 지정된 열쇠가 이 암호의 초기화에 올바르지 않은 경우, 또는 이 암호가 복호화용으로 초기화되어 지정된 열쇠로부터 판정할 수가 없는 알고리즘 파라미터를 필요로 하는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="engineInit(int, java.security.Key, java.security.spec.AlgorithmParameterSpec, java.security.SecureRandom)"><!-- --></A> <H3>
engineInit</H3>
<PRE>
protected abstract void <B>engineInit</B>(int&nbsp;opmode,
                                   <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
                                   <A HREF="../../java/security/spec/AlgorithmParameterSpec.html" title="java.security.spec 안의 인터페이스">AlgorithmParameterSpec</A> &nbsp;params,
                                   <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)
                            throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> ,
                                   <A HREF="../../java/security/InvalidAlgorithmParameterException.html" title="java.security 안의 클래스">InvalidAlgorithmParameterException</A> </PRE>
<DL>
<DD>열쇠, 알고리즘 파라미터세트, 및 random number generation의 원을 사용해 이 암호를 초기화합니다.

 <p>이 암호는,<code>opmode</code> 의 값에 따라, 암호화, 복호화, 열쇠 랩핑, 또는 열쇠 랩핑 해제의 4 개의 조작의 1 개에 맞추어 초기화됩니다.

 <p>이 암호가 알고리즘 파라미터를 필요로 해,<code>params</code> 가 null 의 경우, 기본이 되는 암호 구현은, 암호화 또는 열쇠 랩핑용으로 초기화되고 있으면, 프로바이더 고유의 디폴트 또는 랜덤치를 사용해 필요한 파라미터 자체를 생성해, 복호화 또는 열쇠 랩핑 해제용으로 초기화되고 있으면,<code>InvalidAlgorithmParameterException</code> 를 발생시킵니다. 생성된 파라미터는,<A HREF="../../javax/crypto/CipherSpi.html#engineGetParameters()"><CODE>engineGetParameters</CODE></A>  또는 <A HREF="../../javax/crypto/CipherSpi.html#engineGetIV()"><CODE>engineGetIV</CODE></A>  (파라미터가 IV 의 경우)를 사용해 꺼낼 수가 있습니다.

 <p>이 암호 (기본이 되는 피드백 또는 패딩 방식을 포함한다)가 난수 바이트를 필요로 하는 경우 (파라미터 생성을 위해 등)는,<code>random</code> 로부터 가져옵니다.

 <p>Cipher 객체가 초기화되면(자), 이전에 취득한 상태는 모두 없어집니다. 즉, Cipher 를 초기화하는 것은, 그 Cipher 의 새로운 인스턴스를 작성해 초기화하는 것과 같습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>opmode</CODE> - 이 암호의 조작 모드 (<code>ENCRYPT_MODE</code>,<code>DECRYPT_MODE</code>,<code>WRAP_MODE</code>, 또는 <code>UNWRAP_MODE</code> 의 어떤 것이나)<DD><CODE>key</CODE> - 암호화열쇠<DD><CODE>params</CODE> - 알고리즘 파라미터<DD><CODE>random</CODE> - random number generation의 원
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - 지정된 열쇠가 이 암호의 초기화에 올바르지 않은 경우
<DD><CODE><A HREF="../../java/security/InvalidAlgorithmParameterException.html" title="java.security 안의 클래스">InvalidAlgorithmParameterException</A> </CODE> - 지정된 알고리즘 파라미터가 이 암호에 올바르지 않은 경우, 또는 이 암호가 복호화용으로 초기화되어 알고리즘 파라미터를 필요로 해,<code>params</code> 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="engineInit(int, java.security.Key, java.security.AlgorithmParameters, java.security.SecureRandom)"><!-- --></A> <H3>
engineInit</H3>
<PRE>
protected abstract void <B>engineInit</B>(int&nbsp;opmode,
                                   <A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key,
                                   <A HREF="../../java/security/AlgorithmParameters.html" title="java.security 안의 클래스">AlgorithmParameters</A> &nbsp;params,
                                   <A HREF="../../java/security/SecureRandom.html" title="java.security 안의 클래스">SecureRandom</A> &nbsp;random)
                            throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> ,
                                   <A HREF="../../java/security/InvalidAlgorithmParameterException.html" title="java.security 안의 클래스">InvalidAlgorithmParameterException</A> </PRE>
<DL>
<DD>열쇠, 알고리즘 파라미터세트, 및 random number generation의 원을 사용해 이 암호를 초기화합니다.

 <p>이 암호는,<code>opmode</code> 의 값에 따라, 암호화, 복호화, 열쇠 랩핑, 또는 열쇠 랩핑 해제의 4 개의 조작의 1 개에 맞추어 초기화됩니다.

 <p>이 암호가 알고리즘 파라미터를 필요로 해,<code>params</code> 가 null 의 경우, 기본이 되는 암호 구현은, 암호화 또는 열쇠 랩핑용으로 초기화되고 있으면, 프로바이더 고유의 디폴트 또는 랜덤치를 사용해 필요한 파라미터 자체를 생성해, 복호화 또는 열쇠 랩핑 해제용으로 초기화되고 있으면,<code>InvalidAlgorithmParameterException</code> 를 발생시킵니다. 생성된 파라미터는,<A HREF="../../javax/crypto/CipherSpi.html#engineGetParameters()"><CODE>engineGetParameters</CODE></A>  또는 <A HREF="../../javax/crypto/CipherSpi.html#engineGetIV()"><CODE>engineGetIV</CODE></A>  (파라미터가 IV 의 경우)를 사용해 꺼낼 수가 있습니다.

 <p>이 암호 (기본이 되는 피드백 또는 패딩 방식을 포함한다)가 난수 바이트를 필요로 하는 경우 (파라미터 생성을 위해 등)는,<code>random</code> 로부터 가져옵니다.

 <p>Cipher 객체가 초기화되면(자), 이전에 취득한 상태는 모두 없어집니다. 즉, Cipher 를 초기화하는 것은, 그 Cipher 의 새로운 인스턴스를 작성해 초기화하는 것과 같습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>opmode</CODE> - 이 암호의 조작 모드 (<code>ENCRYPT_MODE</code>,<code>DECRYPT_MODE</code>,<code>WRAP_MODE</code>, 또는 <code>UNWRAP_MODE</code> 의 어떤 것이나)<DD><CODE>key</CODE> - 암호화열쇠<DD><CODE>params</CODE> - 알고리즘 파라미터<DD><CODE>random</CODE> - random number generation의 원
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - 지정된 열쇠가 이 암호의 초기화에 올바르지 않은 경우
<DD><CODE><A HREF="../../java/security/InvalidAlgorithmParameterException.html" title="java.security 안의 클래스">InvalidAlgorithmParameterException</A> </CODE> - 지정된 알고리즘 파라미터가 이 암호에 올바르지 않은 경우, 또는 이 암호가 복호화용으로 초기화되어 알고리즘 파라미터를 필요로 해,<code>params</code> 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="engineUpdate(byte[], int, int)"><!-- --></A> <H3>
engineUpdate</H3>
<PRE>
protected abstract byte[] <B>engineUpdate</B>(byte[]&nbsp;input,
                                       int&nbsp;inputOffset,
                                       int&nbsp;inputLen)</PRE>
<DL>
<DD>복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다.

 <p><code>inputOffset</code> 로부터 시작되는,<code>input</code> 버퍼내의 최초의 <code>inputLen</code> 바이트가 처리되어 결과가 새로운 버퍼에 포함됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 버퍼<DD><CODE>inputOffset</CODE> - 입력을 개시하는 <code>input</code> 내의 오프셋(offset)<DD><CODE>inputLen</CODE> - 입력 길이
<DT><B>반환값:</B><DD>결과가 들어간 새로운 버퍼. 기본이 되는 암호가 블록 암호이며, 입력 데이터가 단인가 지나 새로운 블록이 되지 않는 경우는 null</DL>
</DD>
</DL>
<HR>

<A NAME="engineUpdate(byte[], int, int, byte[], int)"><!-- --></A> <H3>
engineUpdate</H3>
<PRE>
protected abstract int <B>engineUpdate</B>(byte[]&nbsp;input,
                                    int&nbsp;inputOffset,
                                    int&nbsp;inputLen,
                                    byte[]&nbsp;output,
                                    int&nbsp;outputOffset)
                             throws <A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 내의 클래스">ShortBufferException</A> </PRE>
<DL>
<DD>복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다.

 <p><code>inputOffset</code> 로부터 시작되는,<code>input</code> 버퍼- 안의 최초의 <code>inputLen</code> 바이트가 처리되어 결과는 <code>output</code> 버퍼의 <code>outputOffset</code> 로부터 시작되는 위치에 포함됩니다.

 <p><code>output</code> 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우는,<code>ShortBufferException</code> 가 throw 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 버퍼<DD><CODE>inputOffset</CODE> - 입력을 개시하는 <code>input</code> 내의 오프셋(offset)<DD><CODE>inputLen</CODE> - 입력 길이<DD><CODE>output</CODE> - 결과를 포함하는 버퍼<DD><CODE>outputOffset</CODE> - 결과가 포함되는 <code>output</code> 내의 오프셋(offset)
<DT><B>반환값:</B><DD><code>output</code> 에 포함된 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 안의 클래스">ShortBufferException</A> </CODE> - 지정된 출력 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="engineUpdate(java.nio.ByteBuffer, java.nio.ByteBuffer)"><!-- --></A> <H3>
engineUpdate</H3>
<PRE>
protected int <B>engineUpdate</B>(<A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;input,
                           <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;output)
                    throws <A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 내의 클래스">ShortBufferException</A> </PRE>
<DL>
<DD>복수의 부분으로부터 완성되는 암호화 또는 복호화 조작 (이 암호의 초기화 방법에 의해 다르다)을 계속해, 다른 데이터 부분을 처리합니다.

 <p><code>input.position()</code> 로부터 시작되는 모든 <code>input.remaining()</code> 바이트가 처리됩니다. 결과는 출력 버퍼에 포함됩니다. 종료시에, 입력 버퍼의 위치는 리밋트에 동일해집니다만, 리밋트는 변경되지 않습니다. 출력 버퍼의 위치는 n 만 증가합니다. n 는, 이 메소드가 돌려주는 값입니다. 출력 버퍼의 리밋트는 변경되지 않습니다.

 <p><code>output.remaining()</code> 바이트가 결과를 보관 유지하는데 불충분한 경우는,<code>ShortBufferException</code> 가 throw 됩니다.

 <p>ByteBuffer 를 바이트 배열보다 효율적으로 처리할 수 있는 경우, 이 메소드를 서브 클래스에서 오버라이드(override) 하는 것을 검토해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 ByteBuffer<DD><CODE>output</CODE> - 출력 ByteByffer
<DT><B>반환값:</B><DD><code>output</code> 에 포함된 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 안의 클래스">ShortBufferException</A> </CODE> - 출력 버퍼내에 남아 있는 용량이 부족한 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 어느 쪽의 파라미터도 <CODE>null</CODE> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="engineDoFinal(byte[], int, int)"><!-- --></A> <H3>
engineDoFinal</H3>
<PRE>
protected abstract byte[] <B>engineDoFinal</B>(byte[]&nbsp;input,
                                        int&nbsp;inputOffset,
                                        int&nbsp;inputLen)
                                 throws <A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 내의 클래스">IllegalBlockSizeException</A> ,
                                        <A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </PRE>
<DL>
<DD>단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. 데이터는, 이 암호가 초기화된 방법에 따라, 암호화 또는 복호화 됩니다.

 <p><code>inputOffset</code> 로부터 시작되는 <code>input</code> 버퍼내의 최초의 <code>inputLen</code> 바이트, 및 전의 <code>update</code> 조작으로 버퍼에 넣어진 가능성이 있는 모든 입력 바이트가 처리되어 패딩 (요구되었을 경우)이 적용됩니다. 결과는 새로운 버퍼에 포함됩니다.

 <p>종료시에, 이 메소드는 이 암호 객체를 앞에 두고 <code>engineInit</code> 를 호출해 초기화되었을 때 상태에 리셋 합니다. 즉, 객체는 리셋 되어, 한층 더 데이터를 암호화 또는 복호화 하기 위해서 사용할 수 있습니다 (<code>engineInit</code> 의 호출로 지정된 조작 모드에 의해 다르다).

 <p>주:예외가 throw 되는 경우, 이 암호 객체는 리셋 하지 않으면 재차 사용할 수 없는 경우가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 버퍼<DD><CODE>inputOffset</CODE> - 입력을 개시하는 <code>input</code> 내의 오프셋(offset)<DD><CODE>inputLen</CODE> - 입력 길이
<DT><B>반환값:</B><DD>결과가 들어간 새로운 버퍼
<DT><B>예외:</B>
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> </CODE> - 이 암호가 블록 암호이며, 패딩이 요구되지 않고 (암호화 모드의 경우만), 이 암호로 처리된 데이터의 입력 길이의 합계가 블록 사이즈의 배수가 아닌 경우. 또는, 이 암호화 알고리즘이, 지정된 입력 데이터를 처리할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </CODE> - 이 암호가 복호화 모드이며, 패딩 (또는 패딩 해제)이 요구되었지만, 복호화 된 데이터가 적절한 패딩 바이트로 바인드 되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="engineDoFinal(byte[], int, int, byte[], int)"><!-- --></A> <H3>
engineDoFinal</H3>
<PRE>
protected abstract int <B>engineDoFinal</B>(byte[]&nbsp;input,
                                     int&nbsp;inputOffset,
                                     int&nbsp;inputLen,
                                     byte[]&nbsp;output,
                                     int&nbsp;outputOffset)
                              throws <A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 내의 클래스">ShortBufferException</A> ,
                                     <A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> ,
                                     <A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </PRE>
<DL>
<DD>단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. 데이터는, 이 암호가 초기화된 방법에 따라, 암호화 또는 복호화 됩니다.

 <p><code>inputOffset</code> 로부터 시작되는 <code>input</code> 버퍼내의 최초의 <code>inputLen</code> 바이트, 및 전의 <code>update</code> 조작으로 버퍼에 넣어진 가능성이 있는 모든 입력 바이트가 처리되어 패딩 (요구되었을 경우)이 적용됩니다. 결과는,<code>outputOffset</code> 로부터 시작되는 <code>output</code> 버퍼에 포함됩니다.

 <p><code>output</code> 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우는,<code>ShortBufferException</code> 가 throw 됩니다.

 <p>종료시에, 이 메소드는 이 암호 객체를 앞에 두고 <code>engineInit</code> 를 호출해 초기화되었을 때 상태에 리셋 합니다. 즉, 객체는 리셋 되어, 한층 더 데이터를 암호화 또는 복호화 하기 위해서 사용할 수 있습니다 (<code>engineInit</code> 의 호출로 지정된 조작 모드에 의해 다르다).

 <p>주:예외가 throw 되는 경우, 이 암호 객체는 리셋 하지 않으면 재차 사용할 수 없는 경우가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 버퍼<DD><CODE>inputOffset</CODE> - 입력을 개시하는 <code>input</code> 내의 오프셋(offset)<DD><CODE>inputLen</CODE> - 입력 길이<DD><CODE>output</CODE> - 결과를 포함하는 버퍼<DD><CODE>outputOffset</CODE> - 결과가 포함되는 <code>output</code> 내의 오프셋(offset)
<DT><B>반환값:</B><DD><code>output</code> 에 포함된 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> </CODE> - 이 암호가 블록 암호이며, 패딩이 요구되지 않고 (암호화 모드의 경우만), 이 암호로 처리된 데이터의 입력 길이의 합계가 블록 사이즈의 배수가 아닌 경우. 또는, 이 암호화 알고리즘이, 지정된 입력 데이터를 처리할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 안의 클래스">ShortBufferException</A> </CODE> - 지정된 출력 버퍼가 너무 작아 결과를 보관 유지할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </CODE> - 이 암호가 복호화 모드이며, 패딩 (또는 패딩 해제)이 요구되었지만, 복호화 된 데이터가 적절한 패딩 바이트로 바인드 되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="engineDoFinal(java.nio.ByteBuffer, java.nio.ByteBuffer)"><!-- --></A> <H3>
engineDoFinal</H3>
<PRE>
protected int <B>engineDoFinal</B>(<A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;input,
                            <A HREF="../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;output)
                     throws <A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 내의 클래스">ShortBufferException</A> ,
                            <A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> ,
                            <A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </PRE>
<DL>
<DD>단일의 부분으로부터 완성되는 조작으로 데이터를 암호화 또는 복호화 하는지, 복수의 부분으로부터 완성되는 조작을 종료합니다. 데이터는, 이 암호가 초기화된 방법에 따라, 암호화 또는 복호화 됩니다.

 <p><code>input.position()</code> 로부터 시작되는 모든 <code>input.remaining()</code> 바이트가 처리됩니다. 결과는 출력 버퍼에 포함됩니다. 종료시에, 입력 버퍼의 위치는 리밋트에 동일해집니다만, 리밋트는 변경되지 않습니다. 출력 버퍼의 위치는 n 만 증가합니다. n 는, 이 메소드가 돌려주는 값입니다. 출력 버퍼의 리밋트는 변경되지 않습니다.

 <p><code>output.remaining()</code> 바이트가 결과를 보관 유지하는데 불충분한 경우는,<code>ShortBufferException</code> 가 throw 됩니다.

 <p>종료시에, 이 메소드는 이 암호 객체를 앞에 두고 <code>engineInit</code> 를 호출해 초기화되었을 때 상태에 리셋 합니다. 즉, 객체는 리셋 되어, 한층 더 데이터를 암호화 또는 복호화 하기 위해서 사용할 수 있습니다 (<code>engineInit</code> 의 호출로 지정된 조작 모드에 의해 다르다).

 <p>주:예외가 throw 되는 경우, 이 암호 객체는 리셋 하지 않으면 재차 사용할 수 없는 경우가 있습니다.

 <p>ByteBuffer 를 바이트 배열보다 효율적으로 처리할 수 있는 경우, 이 메소드를 서브 클래스에서 오버라이드(override) 하는 것을 검토해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 입력 ByteBuffer<DD><CODE>output</CODE> - 출력 ByteByffer
<DT><B>반환값:</B><DD><code>output</code> 에 포함된 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> </CODE> - 이 암호가 블록 암호이며, 패딩이 요구되지 않고 (암호화 모드의 경우만), 이 암호로 처리된 데이터의 입력 길이의 합계가 블록 사이즈의 배수가 아닌 경우. 또는, 이 암호화 알고리즘이, 지정된 입력 데이터를 처리할 수 없는 경우
<DD><CODE><A HREF="../../javax/crypto/ShortBufferException.html" title="javax.crypto 안의 클래스">ShortBufferException</A> </CODE> - 출력 버퍼내에 남아 있는 용량이 부족한 경우
<DD><CODE><A HREF="../../javax/crypto/BadPaddingException.html" title="javax.crypto 안의 클래스">BadPaddingException</A> </CODE> - 이 암호가 복호화 모드이며, 패딩 (또는 패딩 해제)이 요구되었지만, 복호화 된 데이터가 적절한 패딩 바이트로 바인드 되지 않는 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 어느 쪽의 파라미터도 <CODE>null</CODE> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="engineWrap(java.security.Key)"><!-- --></A> <H3>
engineWrap</H3>
<PRE>
protected byte[] <B>engineWrap</B>(<A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key)
                     throws <A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 내의 클래스">IllegalBlockSizeException</A> ,
                            <A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </PRE>
<DL>
<DD>열쇠를 랩 합니다.

 <p>이 구상 메소드는, 사전에 정의된 이 abstract 클래스에 추가된 것입니다. 하위 호환성을 위해서(때문에), 추상 메소드에는 할 수 없습니다. 열쇠를 랩 하기 위해서, 프로바이더에 의해 오버라이드(override) 되는 경우가 있습니다. 그러한 오버라이드(override)를 실시하면, 지정된 열쇠를 랩 할 수 없는 경우에, IllegalBlockSizeException 또는 InvalidKeyException (지정된 환경하)가 throw 됩니다. 이 메소드가 오버라이드(override) 되지 않는 경우는, 항상 UnsupportedOperationException 가 throw 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 랩 되는 열쇠
<DT><B>반환값:</B><DD>랩 된 열쇠
<DT><B>예외:</B>
<DD><CODE><A HREF="../../javax/crypto/IllegalBlockSizeException.html" title="javax.crypto 안의 클래스">IllegalBlockSizeException</A> </CODE> - 이 암호가 블록 암호이며, 패딩이 요구되지 않고, 랩 되는 열쇠의 인코딩의 길이가 블록 사이즈의 배수가 아닌 경우
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - 이 암호를 사용해 열쇠를 랩 하는 것이 불가능한가 안전하지 않은 경우 (하드웨어 보호된 열쇠가 소프트웨어만의 암호에게 건네지는 경우 등)</DL>
</DD>
</DL>
<HR>

<A NAME="engineUnwrap(byte[], java.lang.String, int)"><!-- --></A> <H3>
engineUnwrap</H3>
<PRE>
protected <A HREF="../../java/security/Key.html" title="java.security 내의 인터페이스">Key</A>  <B>engineUnwrap</B>(byte[]&nbsp;wrappedKey,
                           <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;wrappedKeyAlgorithm,
                           int&nbsp;wrappedKeyType)
                    throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> ,
                           <A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 안의 클래스">NoSuchAlgorithmException</A> </PRE>
<DL>
<DD>전에 랩 된 열쇠를 랩 해제합니다.

 <p>이 구상 메소드는, 사전에 정의된 이 abstract 클래스에 추가된 것입니다. 하위 호환성을 위해서(때문에), 추상 메소드에는 할 수 없습니다. 전에 랩 된 열쇠를 랩 해제하기 위해서, 프로바이더에 의해 오버라이드(override) 되는 경우가 있습니다. 그러한 오버라이드(override)를 실시하면, 지정된, 랩 되고 있는 열쇠를 랩 해제할 수 없는 경우에, InvalidKeyException 가 throw 됩니다. 이 메소드가 오버라이드(override) 되지 않는 경우는, 항상 UnsupportedOperationException 가 throw 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>wrappedKey</CODE> - 랩이 해제되는 열쇠<DD><CODE>wrappedKeyAlgorithm</CODE> - 랩 된 열쇠에 관련한 알고리즘<DD><CODE>wrappedKeyType</CODE> - 랩 된 열쇠의 타입. <code>SECRET_KEY</code>,<code>PRIVATE_KEY</code>, 또는 <code>PUBLIC_KEY</code> 의 어떤 것인가
<DT><B>반환값:</B><DD>랩 해제된 열쇠
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/NoSuchAlgorithmException.html" title="java.security 안의 클래스">NoSuchAlgorithmException</A> </CODE> - 인스톨 되고 있는 어느 프로바이더도 <code>wrappedKeyAlgorithm</code> 의 <code>wrappedKeyType</code> 타입의 열쇠를 작성할 수 없는 경우
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - <code>wrappedKey</code> 가 <code>wrappedKeyAlgorithm</code> 의 <code>wrappedKeyType</code> 타입의 랩 된 열쇠를 나타내지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="engineGetKeySize(java.security.Key)"><!-- --></A> <H3>
engineGetKeySize</H3>
<PRE>
protected int <B>engineGetKeySize</B>(<A HREF="../../java/security/Key.html" title="java.security 안의 인터페이스">Key</A> &nbsp;key)
                        throws <A HREF="../../java/security/InvalidKeyException.html" title="java.security 내의 클래스">InvalidKeyException</A> </PRE>
<DL>
<DD>지정된 열쇠 객체의 열쇠 사이즈를 비트 단위로 돌려줍니다. &nbsp;<p>이 구상 메소드는, 사전에 정의된 이 abstract 클래스에 추가된 것입니다. 프로바이더에 의해 오버라이드(override) 되지 않는 경우는,<code>UnsupportedOperationException</code> 를 throw 합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 열쇠 객체
<DT><B>반환값:</B><DD>지정된 열쇠 객체의 열쇠 사이즈
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/security/InvalidKeyException.html" title="java.security 안의 클래스">InvalidKeyException</A> </CODE> - <code>key</code> 가 무효인 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/CipherSpi.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/crypto/CipherOutputStream.html" title="javax.crypto 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/crypto/EncryptedPrivateKeyInfo.html" title="javax.crypto 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/crypto/CipherSpi.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="CipherSpi.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
