<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:03:47 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
SSLEngine (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SSLEngine (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SSLEngine.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/net/ssl/SSLContextSpi.html" title="javax.net.ssl 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/net/ssl/SSLEngine.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="SSLEngine.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.net.ssl</FONT>
<BR>
클래스 SSLEngine</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.net.ssl.SSLEngine</B>
</PRE>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>SSLEngine</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
Secure Sockets Layer (SSL)나 <A HREF="http://www.ietf.org/rfc/rfc2246.txt">IETF RFC 2246 의 Transport Layer Security (TLS)</A>  프로토콜을 사용해, 전송에 의존하는 일 없이 시큐어 통신을 유효하게 하는 클래스입니다.  &nbsp;<P>
시큐어 통신 모드에서는, 다음의 시큐리티 보호가 실시됩니다.  <UL>

        <LI> 무결성의 보호. <em></em>SSL/TLS 에 의해, 메세지를 도청에 의한 조작으로부터 보호한다

        <LI> 인증<em></em>.   대부분의 SSL/TLS 모드에서는, 피어 인증이 제공된다. 일반적으로은, 서버 인증을 한다. 서버로부터의 요구에 응해, 클라이언트 인증도 행해진다.

        <LI> 기밀성 (프라이버시의 보호)<em></em>. 대부분의 SSL/TLS 모드에서는, 클라이언트와 서버간에 송신되는 데이터가 암호화되어 데이터의 기밀성이 보호된다. 이 결과, 수동적인 도청에 의해, 금융정보나 개인정보등의 기밀성의 높은 데이터가 도청되는 것이 없다.

        </UL>

이러한 시큐리티 보호는, 「암호화 방식군」을 사용해 지정합니다.  암호화 방식군은, 지정된 SSL 접속으로 사용되는 암호화 알고리즘의 편성입니다. 협상을 실시하려면 , 2 개의 끝이 같은 암호화 방식군을 선택해, 그 암호화 방식군이 양쪽 모두의 환경에서 사용 가능하지 않으면 안됩니다. 공통의 암호화 방식군이 없는 경우는, SSL 접속을 확립하지 못하고, 데이터를 교환할 수 없습니다.  &nbsp;<P>
사용되는 암호화 방식군은, 「핸드 쉐이크」라고 불리는 협상 프로세스에 의해 확립됩니다. 핸드 쉐이크에서는, 세션의 작성 또는 참가를 합니다.  작성 또는 참가한 세션은, 무효가 될 때까지 다양한 접속을 보호합니다. 핸드 쉐이크가 완료하면(자),<A HREF="../../../javax/net/ssl/SSLEngine.html#getSession()"><CODE>getSession()</CODE></A>  메소드를 사용해 세션 속성에 액세스 할 수 있습니다.  &nbsp;<P>
<code>SSLSocket</code> 클래스도 거의 같은 시큐리티 기능을 제공합니다만, 모든 착신 및 발신 데이터는, 의도적으로 블록 모델을 사용하는 부하 <A HREF="../../../java/net/Socket.html" title="java.net 중의 클래스"><CODE>Socket</CODE></A>  에 의해 자동적으로 송신됩니다. 이 처리는 많은 어플리케이션에 대해서 적절합니다만, 이 모델은 대규모 서버에 필요한 확장성을 가져오지 않습니다.  &nbsp;<P>
<code>SSLEngine</code> 의 주된 특장으로서 전송 기구에 의존하는 일 없이 착신/송신 바이트 스트림을 조작할 수 있는 점을 들 수 있습니다. <code>SSLEngine</code> 사용자는, 피어에 있어서의 입출력 전송의 신뢰성을 확보할 필요가 있습니다. SSL/TLS 추상화 객체를 입출력 전송 기구로부터 떼어내는 것으로,<code>SSLEngine</code> 를 다양한 입출력으로 광범위하게 이용할 수가 있습니다.  예를 들어,<A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html#configureBlocking(boolean)"><CODE>비블록 입출력 (폴링)</CODE></A> ,<A HREF="../../../java/nio/channels/Selector.html" title="java.nio.channels 안의 클래스"><CODE>선택형비블록 입출력</CODE></A> 외,<A HREF="../../../java/net/Socket.html" title="java.net 안의 클래스"><CODE>Socket</CODE></A>  및 종래의 Input/OutputStream, 로컬 <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 중의 클래스"><CODE>ByteBuffers</CODE></A> , 바이트 배열,<A  HREF="http://www.jcp.org/en/jsr/detail?id=203">future asynchronous 입출력 모델</a>등의 입출력으로 이용 가능합니다.  &nbsp;<P>
상층부에서는,<code>SSLEngine</code> 는 다음과 같이 나타내집니다.

 <pre>
                   app data

                |           ^
                |     |     |
                v     |     |
           +----+-----|-----+----+
           |          |          |
           |       SSL|Engine    |
   wrap()  |          |          |  unwrap()
           | OUTBOUND | INBOUND  |
           |          |          |
           +----+-----|-----+----+
                |     |     ^
                |     |     |
                v           |

                   net data
 </pre>
어플리케이션 데이터 (별명 「plaintext」또는 「clear text」)는, 어플리케이션에 의해 생성 또는 소비되는 데이터입니다. 어플리케이션 데이터와 대가 되는 것으로서 네트워크 데이터가 있습니다.  네트워크 데이터는, 핸드 쉐이크나 암호화 데이터로 구성되어 입출력 기구를 개입시켜 전송 되는 데이터입니다. 착신 데이터는 피어로부터 수신되는 데이터, 송신 데이터는 피어에 송신되는 데이터입니다.  &nbsp;<P>
<code>SSLEngine</code> 의 문맥에서는, 시큐어 접속의 확립 및 제어 목적으로 교환되는 데이터를 「핸드 쉐이크 데이터」라고 총칭합니다. 핸드 쉐이크 데이터에는, SSL/TLS 메세지 alert, change_cipher_spec, handshake 등이 있습니다.  &nbsp;<P>
<code>SSLEngine</code> 는, 다음의 5 개의 단계를 더듬습니다.

 <OL>
<li> 작성 - <code>SSLEngine</code> 의 작성과 초기화는 완료했습니다만, 아직 사용되고는 있지 않습니다. 이 단계에서는, 어플리케이션에 의해,<code>SSLEngine</code> 고유의 모든 설정 (암호화 방식군의 유효화,<code>SSLEngine</code> 가 클라이언트 모드와 서버 모드의 어디에서 핸드 쉐이크를 실시할까 등)을 실시할 수가 있습니다. 핸드 쉐이크가 시작되면(자), 다음의 핸드 쉐이크로부터 클라이언트/서버 모드의 설정을 제외한 (아래와 같이 참조) 새로운 설정이 사용됩니다.

<li> 초기 핸드 쉐이크 - SSLSession 가 확립될 때까지, 2 개의 피어가 통신 파라미터를 교환하는 수속입니다. 이 단계에서는, 어플리케이션 데이터는 송신할 수 없습니다.

<li> 어플리케이션 데이터 - 통신 파라미터가 확립되어 핸드 쉐이크가 완료하면(자),<code>SSLEngine</code> 로부터 어플리케이션 데이터가 송신됩니다. 송신 어플리케이션 메세지는 암호화되어 데이터의 무결성이 확보됩니다.  착신 메세지에서는, 이 반대의 수속을 합니다.

<li>  재핸드 쉐이크 - 「어플리케이션 데이터」단계에서는, 어느 쪽측의 피어로부터에서도, 필요에 따라서 세션의 재협상을 요구할 수 있습니다. 어플리케이션 데이터에 새로운 핸드 쉐이크 데이터를 혼합할 수가 있습니다. 재핸드 쉐이크를 개시하기 전에, 어플리케이션은, SSL/TLS 통신 파라미터 (예: 유효한 암호화 방식군의 리스트)나, 클라이언트 인증을 사용할지 어떨지의 설정을 리셋 할 수 있습니다.  그러나, 클라이언트 모드와 서버 모드를 바꿀 수 없습니다. 전회와 같게, 핸드 쉐이크가 시작되고 나서 다음의 핸드 쉐이크까지, 새로운 <code>SSLEngine</code> 설정은 사용되지 않습니다.

<li>  종료 - 접속이 불필요하게 되었을 때, 어플리케이션은,<code>SSLEngine</code> 를 종료해, 피어와 송수신 하는 메세지가 남아 있는 경우는 송수신을 완료하고 나서, 부하의 전송 기구를 종료할 필요가 있습니다. 종료된 엔진은, 재사용할 수 없습니다. 새로운 <code>SSLEngine</code> 를 작성할 필요가 있습니다.
 </OL>
<code>SSLEngine</code> 를 작성하려면 , 초기화된 <code>SSLContext</code> 로부터 <A HREF="../../../javax/net/ssl/SSLContext.html#createSSLEngine()"><CODE>SSLContext.createSSLEngine()</CODE></A>  를 호출합니다. 모든 설정 파라미터의 설정을 완료하고 나서,<code>wrap()</code>,<code>unwrap()</code>, 또는 <code>beginHandshake()</code> 의 최초의 호출을 실시합니다. 이러한 메소드는 모두, 초기 핸드 쉐이크를 트리거합니다.  &nbsp;<P>
데이터는, 송신 데이터에 대해서 <A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>wrap()</CODE></A>  를 호출하거나 착신 데이터에 대해서 <A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>unwrap()</CODE></A>  를 호출하는 것에 의해, 엔진으로부터 전송 됩니다. <code>SSLEngine</code> 상태에 따라서는,<code>wrap()</code> 호출에 의해 소스 버퍼의 어플리케이션 데이터가 사용되어 행선지 버퍼에 네트워크 데이터가 써내지는 경우도 있습니다. 송신 데이터에는, 어플리케이션 데이터나 핸드 쉐이크 데이터가 포함됩니다. <code>unwrap()</code> 를 호출하면(자), 소스 버퍼가 체크되어 그 중의 데이터가 핸드 쉐이크 정보이면 핸드 쉐이크가 실시됩니다.  어플리케이션 데이터이면, 행선지 버퍼에 포함됩니다. 부하의 SSL/TLS 알고리즘 상태로부터, 데이터의 사용이나 생성의 타이밍을 판단할 수 있습니다.  &nbsp;<P>
<code>wrap()</code> 나 <code>unwrap()</code> 를 호출하면(자), 오퍼레이션 상태와 처리를 속행하는 경우의 엔진과의 교환의 내용 (옵션)을 나타내는 <code>SSLEngineResult</code> 가 돌려주어집니다.  &nbsp;<P>
<code>SSLEngine</code> 는, 완전한 SSL/TLS 패킷 밖에 사용 또는 생성하지 않습니다.  다음의 <code>wrap()</code> 또는 <code>unwrap()</code> 의 호출까지의 사이에, 어플리케이션 데이터를 내부에 포함할 것은 없습니다. 따라서, 생성되는 레코드중  제일 사이즈가 큰 것을 포함할 수 있도록(듯이), 입출력 <code>ByteBuffer</code> 의 사이즈를 결정할 필요가 있습니다. 적절한 버퍼 사이즈를 판정하려면 ,<A HREF="../../../javax/net/ssl/SSLSession.html#getPacketBufferSize()"><CODE>SSLSession.getPacketBufferSize()</CODE></A>  및 <A HREF="../../../javax/net/ssl/SSLSession.html#getApplicationBufferSize()"><CODE>SSLSession.getApplicationBufferSize()</CODE></A>  의 호출을 사용합니다. 송신 어플리케이션 데이터 버퍼의 사이즈는, 일반적으로, 고려할 필요는 없습니다. 데이터의 사용 및 생성에 적절한 버퍼 조건이 아닌 경우, 어플리케이션은  <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 안의 클래스"><CODE>SSLEngineResult</CODE></A>  에 의해 문제를 특정해, 수정한 뒤, 재차 호출을 시행하지 않으면 안됩니다.  &nbsp;<P>
예를 들어, 유효한 행선지 버퍼의 용량이 불충분하다라고 엔진이 판정했을 경우,<code>unwrap()</code> 는 <A HREF="../../../javax/net/ssl/SSLEngineResult.Status.html#BUFFER_OVERFLOW"><CODE>SSLEngineResult.Status.BUFFER_OVERFLOW</CODE></A>  의 결과를 돌려줍니다. 필요에 따라서, 어플리케이션으로 <A HREF="../../../javax/net/ssl/SSLSession.html#getApplicationBufferSize()"><CODE>SSLSession.getApplicationBufferSize()</CODE></A>  를 호출해, 그 값과 행선지 버퍼내의 유효한 용량을 비교해, 버퍼를 크게 하도록 해 주세요. 같이<code>unwrap()</code> 가 <A HREF="../../../javax/net/ssl/SSLEngineResult.Status.html#BUFFER_UNDERFLOW"><CODE>SSLEngineResult.Status.BUFFER_UNDERFLOW</CODE></A>  를 돌려주려고 했을 경우는, 어플리케이션으로 <A HREF="../../../javax/net/ssl/SSLSession.html#getPacketBufferSize()"><CODE>SSLSession.getPacketBufferSize()</CODE></A>  를 호출해, 레코드를 보관 유지하는데 충분한 용량을 소스 버퍼에 확보해 (또, 필요에 따라서 확장해), 보다 많은 착신 데이터를 취득하도록 해 주세요.

 <pre>
   SSLEngineResult r = engine.unwrap(src, dst);
   switch (r.getStatus()) {
   BUFFER_OVERFLOW:
       // Could attempt to drain the dst buffer of any already obtained
       // data, but we'll just increase it to the size needed.
       int appSize = engine.getSession(). getApplicationBufferSize();
       ByteBuffer b = ByteBuffer.allocate(appSize + dst.position());
       dst.flip();
       b.put(dst);
       dst = b;
       // retry the operation.
       break;
   BUFFER_UNDERFLOW:
       int netSize = engine.getSession(). getPacketBufferSize();
       // Resize buffer if needed.
       if (netSize > dst.capacity()) {
           ByteBuffer b = ByteBuffer.allocate(netSize);
           src.flip();
           b.put(src);
           src = b;
       }
       // Obtain more inbound network data for src,
       // then retry the operation.
       break;
   // other cases: CLOSED, OK.
   }
 </pre>

 <P>
<code>SSLSocket</code> 과는 달리, SSLEngine 의 모든 메소드는 비동기 메소드입니다. <code>SSLEngine</code> 구현을 위해서(때문에) 필요한 태스크는, 완료까지 꽤 시간이 걸리거나 완료전에 블록 될 가능성이 있습니다. 예를 들어, TrustManager 는, 원격 증명서 확인 서비스에의 접속이 요구되는 일이 있습니다.  또, KeyManager 는, 클라이언트 인증의 일환으로서 사용해야 할 증명서를 결정하도록(듯이) 사용자에게 요구하는 일이 있습니다. 게다가 암호화 서명을 작성해, 이것들을 검증하는 경우, 처리 시간이 꽤 길어져, 처리가 블록 된 것처럼 보이는 일이 있습니다.  &nbsp;<P>
<code>SSLEngine</code> 는, 블록 될 가능성이 있는 모든 오퍼레이션에 대해서,<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스"><CODE>Runnable</CODE></A>  위양 태스크를 생성합니다. <code>SSLEngineResult</code> 에 의해, 위양 태스크의 결과의 필요성이 나타났을 경우, 어플리케이션은 <A HREF="../../../javax/net/ssl/SSLEngine.html#getDelegatedTask()"><CODE>getDelegatedTask()</CODE></A>  를 호출해 미실행의 위양 태스크를 취득해, 그 <A HREF="../../../java/lang/Runnable.html#run()"><CODE>run()</CODE></A>  메소드를 호출할 필요가 있습니다.  호출에 사용되는 thread는, 계산방법에 따라서 다릅니다. 어플리케이션은, 모든 위양 태스크를 취득하면(자), 최초의 오퍼레이션을 재시행합니다.  &nbsp;<P>
어플리케이션은, 통신 세션의 종료시에 SSL/TLS 링크를 정상적으로 종료할 필요가 있습니다. SSL/TLS 프로토콜은 핸드 쉐이크 종료 메세지를 가지고 있어 이러한 메세지는,<code>SSLEngine</code> 가 해제되어 부하의 전송 기구가 종료하기 전에 피어에 송신되게 되어 있습니다. 통신 세션의 종료는, SSLException, 핸드 쉐이크 종료 메세지의 착신, 또는 임의의 종료 메소드에 의해 개시됩니다. 어느 경우에서도, 엔진으로부터 핸드 쉐이크 종료 메세지가 생성되어<code>SSLEngineResult</code> 상태가 CLOSED 가 되는지,<A HREF="../../../javax/net/ssl/SSLEngine.html#isOutboundDone()"><CODE>isOutboundDone()</CODE></A>  의 반환값이 true 가 될 때까지,<code>wrap()</code> 가 반복해 불려 갑니다. <code>wrap()</code> 메소드에 의해 취득된 데이터는 모두 피어에 송신됩니다.  &nbsp;<P>
어플리케이션으로부터 송신되는 데이터가 이제 없는 것을 엔진에 통지하려면 ,<A HREF="../../../javax/net/ssl/SSLEngine.html#closeOutbound()"><CODE>closeOutbound()</CODE></A>  를 사용합니다.  &nbsp;<P>
피어는, 고유의 핸드 쉐이크 종료 메세지를 송신하는 것으로, 종료의 의도를 통지합니다. 이 메세지가 로컬의 <code>SSLEngine</code> 의 <code>unwrap()</code> 호출에 의해 수신 및 처리되면(자), 어플리케이션은,<code>unwrap()</code> 를 호출해, 상태가 CLOSED 의 <code>SSLEngineResult</code> 를 검색합니다. 조건에 맞는 것이 발견되는지,<A HREF="../../../javax/net/ssl/SSLEngine.html#isInboundDone()"><CODE>isInboundDone()</CODE></A>  의 반환값이 true 이면, 종료가 확인됩니다.  피어가 통신 링크를 종료할 때, 어떠한 이유로써 정상적인 SSL/TLS 종료 메세지가 송신되지 않았던 경우, 어플리케이션은 스트림의 종료 위치를 검출해, 더 이상 처리해야 할 착신 메세지가 없는 것을,<A HREF="../../../javax/net/ssl/SSLEngine.html#closeInbound()"><CODE>closeInbound()</CODE></A>  를 개입시켜 엔진에 통지합니다. 어플리케이션에 따라서는, 피어로부터의 종료 메세지를 일반적으로대로 받는 설정이 되어 있는 일이 있습니다.  이러한 어플리케이션은, 스트림의 종료 위치는 아니고, 핸드 쉐이크 메세지에 의해 종료를 체크합니다.  &nbsp;<P>
암호화 방식군을 사용할 때는, 2 개의 그룹에 대해 이해할 필요가 있습니다.

 <UL>
        <LI> 지원되고 있는<em></em>암호화 방식군. SSL 구현으로 지원되는 모든 암호화 방식군. 이 리스트는,<A HREF="../../../javax/net/ssl/SSLEngine.html#getSupportedCipherSuites()"><CODE>getSupportedCipherSuites()</CODE></A>  를 사용해 보고된다.

        <LI> 사용 가능한<em></em>암호화 방식군. 지원되고 있는 암호화 방식군보다 적은 것이 있다. 이 그룹은,<A HREF="../../../javax/net/ssl/SSLEngine.html#setEnabledCipherSuites(java.lang.String[])"><CODE>setEnabledCipherSuites(String [])</CODE></A>  메소드를 사용해 설정해,<A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A>  메소드를 사용해 조회한다. 새로운 엔진에서는, 최소한의 추천 구성을 나타내는 디폴트의 암호화 방식군이 사용 가능하게 되어 있다.
 </UL>

디폴트의 구현으로 사용 가능하게 하는 암호화 방식군에서는, 서버를 인증해, 기밀성이 보증되지 않으면 안됩니다. 서버 인증을 하지 않고 기밀성이 보증되지 않는 암호화 방식군을 선택하는 경우는, 서버 인증을 하지 않고 비공개성이 보증되지 않는 (암호화되지 않는다) 통신이 사용되는 것에 2 개의 끝이 명시적으로 동의 할 필요가 있습니다.  &nbsp;<P>
각 SSL/TLS 접속에는 클라이언트와 서버가 1 대씩 필요합니다. 이 때문에, 각 끝으로 담당하는 롤을 결정할 필요가 있습니다. 이 선택 내용에 의해, 어느 쪽측으로부터 핸드 쉐이크 처리를 개시하는지, 또, 서로 어떠한 메세지를 송신할지가 정해집니다. 모드의 설정은,<A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A>  메소드로 실시합니다. 일단 초기 핸드 쉐이크가 개시되고 나서는, 재협상의 경우에서도,<code>SSLEngine</code> 의 모드를 클라이언트로부터 서버, 서버로부터 클라이언트로 전환할 수 없습니다.  &nbsp;<P>
위양 태스크는 별thread로 처리할 수가 있습니다. <code>SSLEngine</code> 가 작성되면(자), 현재 <A HREF="../../../java/security/AccessControlContext.html" title="java.security 중의 클래스"><CODE>AccessControlContext</CODE></A>  가 보존됩니다. 그 후, 모든 위양 태스크는 이 문맥으로 처리됩니다. 즉, 액세스 제어의 의사결정은 모두, 엔진의 작성시의 문맥으로 행해집니다.  &nbsp;<P>
 <HR>

<B>동시성 처리에 대해</B>:다음의 2 점에 주의해 주세요.

 <OL>
        <li><code>wrap()</code> 메소드와 <code>unwrap()</code> 메소드는, 병행 실행이 가능합니다.

        <li> SSL/TLS 프로토콜은 패킷을 차례로 이용합니다. 어플리케이션은, 생성된 패킷이 올바른 차례로 전달할 필요가 있습니다. 패킷의 도착 순서가 올바르지 않으면 예기치 않은 결과 또는 치명적인 결과를 부르는 일이 있습니다.  &nbsp;<P>
다음에 예를 나타냅니다.  &nbsp;<P>
        <pre>
                synchronized (outboundLock) {
                    sslEngine.wrap(src, dst);
                    outboundQueue.put(dst);
                }
        </pre>

        최종적인 패킷의 순서를 보증할 수가 없기 때문에, 결과적으로, 2 개의 thread가 같은 메소드 (<code>wrap()</code> 또는 <code>unwrap()</code>)를 병행해 호출할 수 없습니다.
 </OL>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLContext.html" title="javax.net.ssl 내의 클래스"><CODE>SSLContext</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html" title="javax.net.ssl 안의 클래스"><CODE>SSLSocket</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLServerSocket.html" title="javax.net.ssl 안의 클래스"><CODE>SSLServerSocket</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSession.html" title="javax.net.ssl 안의 인터페이스"><CODE>SSLSession</CODE></A> , 
<A HREF="../../../java/net/Socket.html" title="java.net 안의 클래스"><CODE>Socket</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#SSLEngine()">SSLEngine</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;내부 세션의 재사용에 관한 힌트를 제공하지 않는 <code>SSLEngine</code> 의 생성자 입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#SSLEngine(java.lang.String, int)">SSLEngine</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;peerHost,
          int&nbsp;peerPort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>SSLEngine</code> 용 생성자 입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#beginHandshake()">beginHandshake</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 SSLEngine 의 초기 핸드 쉐이크 또는 재협상의 핸드 쉐이크를 개시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#closeInbound()">closeInbound</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;더 이상 이 <code>SSLEngine</code> 에 송신되는 착신 네트워크 데이터가 없는 것을 나타내는 신호입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#closeOutbound()">closeOutbound</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;더 이상 이 <code>SSLEngine</code> 에 송신되는 송신 어플리케이션 데이터가 없는 것을 나타내는 신호입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getDelegatedTask()">getDelegatedTask</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>SSLEngine</code> 를 위해서(때문에) 위양 된 <code>Runnable</code> 태스크를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites()">getEnabledCipherSuites</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진으로 현재 사용 가능하게 되어 있는 SSL 암호화 방식군의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledProtocols()">getEnabledProtocols</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>SSLEngine</code> 로 현재 사용 가능하게 되어 있는 프로토콜의 버젼을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getEnableSessionCreation()">getEnableSessionCreation</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진으로 새로운 SSL 세션을 확립할 수 있는 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.HandshakeStatus.html" title="javax.net.ssl 내의 열거형">SSLEngineResult.HandshakeStatus</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getHandshakeStatus()">getHandshakeStatus</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>SSLEngine</code> 의 현재의 핸드 쉐이크 상태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getNeedClientAuth()">getNeedClientAuth</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진에 클라이언트 인증이 필수인<i></i>경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getPeerHost()">getPeerHost</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;피어의 호스트명을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getPeerPort()">getPeerPort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;피어의 포트 번호를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/net/ssl/SSLSession.html" title="javax.net.ssl 내의 인터페이스">SSLSession</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getSession()">getSession</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>SSLEngine</code> 로 사용중의 <code>SSLSession</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/net/ssl/SSLParameters.html" title="javax.net.ssl 내의 클래스">SSLParameters</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getSSLParameters()">getSSLParameters</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 SSLEngine 로 유효한 SSLParameters 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getSupportedCipherSuites()">getSupportedCipherSuites</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진으로 사용 가능하게 할 수 있는 암호화 방식군의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getSupportedProtocols()">getSupportedProtocols</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>SSLEngine</code> 로 사용할 수가 있는 프로토콜의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getUseClientMode()">getUseClientMode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;핸드 쉐이크시에 클라이언트 모드를 사용하도록(듯이) 엔진이 설정되어 있는 경우는 true</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getWantClientAuth()">getWantClientAuth</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진이 클라이언트 인증을 요구하는<i></i>경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#isInboundDone()">isInboundDone</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>unwrap(ByteBuffer, ByteBuffer)</CODE></A>  가 받아들이는 착신 데이터 메세지가 아직 있을지 어떨지를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#isOutboundDone()">isOutboundDone</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>wrap(ByteBuffer, ByteBuffer)</CODE></A>  가 생성하는 송신 데이터 메세지가 아직 있을지 어떨지를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#setEnabledCipherSuites(java.lang.String[])">setEnabledCipherSuites</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;suites)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진으로 사용 가능한 암호화 방식군을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#setEnabledProtocols(java.lang.String[])">setEnabledProtocols</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;protocols)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진으로 사용 가능한 프로토콜의 버젼을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#setEnableSessionCreation(boolean)">setEnableSessionCreation</A> </B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진으로 새로운 SSL 세션을 확립할 수 있을지 어떨지를 제어합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)">setNeedClientAuth</A> </B>(boolean&nbsp;need)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트 인증이 필수가 되는 것<i></i>같게 엔진을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#setSSLParameters(javax.net.ssl.SSLParameters)">setSSLParameters</A> </B>(<A HREF="../../../javax/net/ssl/SSLParameters.html" title="javax.net.ssl 안의 클래스">SSLParameters</A> &nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진에 SSLParameters 를 적용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)">setUseClientMode</A> </B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;핸드 쉐이크시, 엔진이 클라이언트 (또는 서버) 모드를 사용하도록(듯이) 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)">setWantClientAuth</A> </B>(boolean&nbsp;want)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트 인증을 요구<i></i>하도록(듯이) 엔진을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer)">unwrap</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
       <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL/TLS 네트워크 데이터를 plaintext의 어플리케이션 데이터 버퍼에 복호화 하려고 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[])">unwrap</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
       <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL/TLS 네트워크 데이터를 plaintext의 어플리케이션 데이터 버퍼의 순서에 복호화 하려고 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int)">unwrap</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
       <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts,
       int&nbsp;offset,
       int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL/TLS 네트워크 데이터를 plaintext의 어플리케이션 데이터 버퍼의 서브 순서에 복호화 하려고 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer[], java.nio.ByteBuffer)">wrap</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs,
     <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plaintext 바이트를 데이터 버퍼 순서로부터 SSL/TLS 네트워크 데이터에 encode 하려고 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer)">wrap</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs,
     int&nbsp;offset,
     int&nbsp;length,
     <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plaintext 바이트를 데이터 버퍼의 서브 순서로부터 SSL/TLS 네트워크 데이터에 encode 하려고 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)">wrap</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
     <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plaintext의 어플리케이션 데이터의 버퍼를 SSL/TLS 네트워크 데이터에 encode 하려고 합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SSLEngine()"><!-- --></A> <H3>
SSLEngine</H3>
<PRE>
protected <B>SSLEngine</B>()</PRE>
<DL>
<DD>내부 세션의 재사용에 관한 힌트를 제공하지 않는 <code>SSLEngine</code> 의 생성자 입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLContext.html#createSSLEngine()"><CODE>SSLContext.createSSLEngine()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSessionContext.html" title="javax.net.ssl 안의 인터페이스"><CODE>SSLSessionContext</CODE></A> </DL>
</DL>
<HR>

<A NAME="SSLEngine(java.lang.String, int)"><!-- --></A> <H3>
SSLEngine</H3>
<PRE>
protected <B>SSLEngine</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;peerHost,
                    int&nbsp;peerPort)</PRE>
<DL>
<DD><code>SSLEngine</code> 용 생성자 입니다.  &nbsp;<P>
<code>SSLEngine</code> 구현은, 내부 세션을 재사용하기 위한 힌트로서<code>peerHost</code> 파라미터와 <code>peerPort</code> 파라미터를 사용할 수 있습니다.  &nbsp;<P>
Kerberos 등, 원격 호스트명의 정보를 필요로 하는 암호화 방식군도 있습니다. 이 클래스의 구현은, 이 생성자 을 사용해 Kerberos 를 사용합니다.  &nbsp;<P>
파라미터는,<code>SSLEngine</code> 에 의한 인증을 받지 않습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>peerHost</CODE> - 피어의 호스트명<DD><CODE>peerPort</CODE> - 피어의 포트 번호<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLContext.html#createSSLEngine(java.lang.String, int)"><CODE>SSLContext.createSSLEngine(String, int)</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSessionContext.html" title="javax.net.ssl 안의 인터페이스"><CODE>SSLSessionContext</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getPeerHost()"><!-- --></A> <H3>
getPeerHost</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getPeerHost</B>()</PRE>
<DL>
<DD>피어의 호스트명을 돌려줍니다.  &nbsp;<P>
이 값은 인증되어 있지 않기 때문에, 실제로 사용할 수 없습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>피어의 호스트명. 사용할 수 있는 것이 없는 경우는 null. </DL>
</DD>
</DL>
<HR>

<A NAME="getPeerPort()"><!-- --></A> <H3>
getPeerPort</H3>
<PRE>
public int <B>getPeerPort</B>()</PRE>
<DL>
<DD>피어의 포트 번호를 돌려줍니다.  &nbsp;<P>
이 값은 인증되어 있지 않기 때문에, 실제로 사용할 수 없습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>피어의 포트 번호. 사용할 수 있는 것이 없는 경우는 -1. </DL>
</DD>
</DL>
<HR>

<A NAME="wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><!-- --></A> <H3>
wrap</H3>
<PRE>
public <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A>  <B>wrap</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
                            <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)
                     throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>plaintext의 어플리케이션 데이터의 버퍼를 SSL/TLS 네트워크 데이터에 encode 하려고 합니다.  &nbsp;<P>
이 메소드 호출의 동작은, 다음의 호출의 동작과 완전히 같습니다.
 <blockquote><pre>
 <A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer)"><CODE>engine.wrap(new ByteBuffer [] { src }, 0, 1, dst);</CODE></A> 
</pre></blockquote>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>src</CODE> - 송신 어플리케이션 데이터를 포함하는 <code>ByteBuffer</code><DD><CODE>dst</CODE> - 송신 네트워크 데이터를 포함하는 <code>ByteBuffer</code>
<DT><B>반환값:</B><DD>이 오퍼레이션의 결과를 설명하는 <code>SSLEngineResult</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - 데이터 처리중에 발생해,<code>SSLEngine</code> 의 이상종료(ABEND)의 원인이 된 문제.

                엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - ReadOnlyBufferException <code>dst</code> 버퍼가 읽어내 전용의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - IllegalArgumentException <code>src</code> 또는 <code>dst</code> 가 null 의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - IllegalStateException 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer)"><CODE>wrap(ByteBuffer [], int, int, ByteBuffer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="wrap(java.nio.ByteBuffer[], java.nio.ByteBuffer)"><!-- --></A> <H3>
wrap</H3>
<PRE>
public <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A>  <B>wrap</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs,
                            <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)
                     throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>plaintext 바이트를 데이터 버퍼 순서로부터 SSL/TLS 네트워크 데이터에 encode 하려고 합니다.  &nbsp;<P>
이 메소드 호출의 동작은, 다음의 호출의 동작과 완전히 같습니다.
 <blockquote><pre>
 <A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer)"><CODE>engine.wrap(srcs, 0, srcs.length, dst);</CODE></A> 
</pre></blockquote>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcs</CODE> - 송신 어플리케이션 데이터를 포함하는 <code>ByteBuffer</code> 의 배열<DD><CODE>dst</CODE> - 송신 네트워크 데이터를 포함하는 <code>ByteBuffer</code>
<DT><B>반환값:</B><DD>이 오퍼레이션의 결과를 설명하는 <code>SSLEngineResult</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - 데이터 처리중에 발생해,<code>SSLEngine</code> 의 이상종료(ABEND)의 원인이 된 문제.

                엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - ReadOnlyBufferException <code>dst</code> 버퍼가 읽어내 전용의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - IllegalArgumentException <code>src</code> 와 <code>dsts</code> 의 어느 쪽인지 한편이 null 의 경우, 또는 <code>srcs</code> 에 null 의 요소가 포함되는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - IllegalStateException 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer)"><CODE>wrap(ByteBuffer [], int, int, ByteBuffer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer)"><!-- --></A> <H3>
wrap</H3>
<PRE>
public abstract <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A>  <B>wrap</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs,
                                     int&nbsp;offset,
                                     int&nbsp;length,
                                     <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)
                              throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>plaintext 바이트를 데이터 버퍼의 서브 순서로부터 SSL/TLS 네트워크 데이터에 encode 하려고 합니다. 이 「수집」<i></i>오퍼레이션은, 1 회의 호출로, 단일의 바이트 순서를 1 개 이상의 지정의 버퍼 순서에 encode 할 수 있습니다. 랩 수집은, 일반적으로, 네트워크 프로토콜이나 파일 형식 (예를 들어, 데이터를 1 개 이상의 고정장의 헤더와 가변 길이의 본체로부터 완성되는 세그먼트(segment)에 그룹화 하는 것 같은 파일 형식)을 구현할 때에 편리합니다. 수집의 자세한 것은 <A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 안의 인터페이스"><CODE>GatheringByteChannel</CODE></A> , 수집 후의 동작의 자세한 것은 <A HREF="../../../java/nio/channels/GatheringByteChannel.html#write(java.nio.ByteBuffer[], int, int)"><CODE>GatheringByteChannel.write(ByteBuffer[], int, int)</CODE></A>  를 참조해 주세요.  &nbsp;<P>
SSLEngine 상태에 따라서는, 이 메소드는, 어플리케이션 데이터를 일절 사용하지 않고 네트워크 데이터를 생성하는 일이 있습니다.  예를 들어, 핸드 쉐이크 데이터가 이것에 해당합니다.  &nbsp;<P>
어플리케이션은, 네트워크 데이터를 피어에 안전하게 전송 할 필요가 있습니다.  또, 몇회인가의 wrap()의 호출에 의해 생성된 데이터를 생성순서에 전송 할 필요가 있습니다. 어플리케이션은, 이 메소드의 복수의 호출을 올바르고 동기화할 필요가 있습니다.  &nbsp;<P>
이 <code>SSLEngine</code> 가 아직 초기 핸드 쉐이크를 개시하고 있지 않는 경우, 이 메소드에 의해 초기 핸드 쉐이크가 자동적으로 개시됩니다.  &nbsp;<P>
이 메소드는, 단일의 SSL/TLS 패킷을 생성하려고 해, 가능한 한 많은 소스 데이터를 소비합니다.  그러나, 각 버퍼에 남아 있는 합계 바이트수이상을 소비할 것은 없습니다. 각 <code>ByteBuffer</code> 의 위치는, 소비 또는 생성된 데이터량에 맞추어 갱신됩니다. 상한/하한치는 바뀌지 않습니다.  &nbsp;<P>
<code>srcs</code> 및 <code>dst</code> 의 ByteBuffer 는, 부하에게 있는 각각 다른 메모리를 사용할 필요가 있습니다.  &nbsp;<P>
엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcs</CODE> - 송신 어플리케이션 데이터를 포함하는 <code>ByteBuffer</code> 의 배열<DD><CODE>offset</CODE> - offset 최초의 바이트의 취득처가 되는 버퍼 배열내의 오프셋(offset). <code>
                srcs.length</code> 이하의 제로 또는 정의 수<DD><CODE>length</CODE> - length 액세스 가능한 최대 버퍼수. <code>
                srcs.length</code>&nbsp;-&nbsp;<code>offset</code> 이하의 제로 또는 정의 수<DD><CODE>dst</CODE> - 송신 네트워크 데이터를 포함하는 <code>ByteBuffer</code>
<DT><B>반환값:</B><DD>이 오퍼레이션의 결과를 설명하는 <code>SSLEngineResult</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - 데이터 처리중에 발생해,<code>SSLEngine</code> 의 이상종료(ABEND)의 원인이 된 문제.

                엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - IndexOutOfBoundsException <code>offset</code> 파라미터와 <code>length</code> 파라미터의 전제 조건이 채워지지 않은 경우
<DD><CODE><A HREF="../../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - ReadOnlyBufferException <code>dst</code> 버퍼가 읽어내 전용의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - IllegalArgumentException <code>srcs</code> 와 <code>dst</code> 의 어느 쪽인지 한편이 null 의 경우, 또는 지정된 <code>srcs</code> 서브 순서에 null 의 요소가 포함되는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - IllegalStateException 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 내의 인터페이스"><CODE>GatheringByteChannel</CODE></A> , 
<CODE>java.nio.channels.GatheringByteChannel#write(</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><!-- --></A> <H3>
unwrap</H3>
<PRE>
public <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A>  <B>unwrap</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
                              <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)
                       throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>SSL/TLS 네트워크 데이터를 plaintext의 어플리케이션 데이터 버퍼에 복호화 하려고 합니다.  &nbsp;<P>
이 메소드 호출의 동작은, 다음의 호출의 동작과 완전히 같습니다.
 <blockquote><pre>
 <A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int)"><CODE>engine.unwrap(src, new ByteBuffer [] { dst }, 0, 1);</CODE></A> 
</pre></blockquote>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>src</CODE> - 착신 네트워크 데이터를 포함하는 <code>ByteBuffer</code><DD><CODE>dst</CODE> - 착신 어플리케이션 데이터를 포함하는 <code>ByteBuffer</code>
<DT><B>반환값:</B><DD>이 오퍼레이션의 결과를 설명하는 <code>SSLEngineResult</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - 데이터 처리중에 발생해,<code>SSLEngine</code> 의 이상종료(ABEND)의 원인이 된 문제.

                엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - ReadOnlyBufferException <code>dst</code> 버퍼가 읽어내 전용의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - IllegalArgumentException <code>src</code> 또는 <code>dst</code> 가 null 의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - IllegalStateException 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int)"><CODE>unwrap(ByteBuffer, ByteBuffer [], int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[])"><!-- --></A> <H3>
unwrap</H3>
<PRE>
public <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A>  <B>unwrap</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
                              <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts)
                       throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>SSL/TLS 네트워크 데이터를 plaintext의 어플리케이션 데이터 버퍼의 순서에 복호화 하려고 합니다.  &nbsp;<P>
이 메소드 호출의 동작은, 다음의 호출의 동작과 완전히 같습니다.
 <blockquote><pre>
 <A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int)"><CODE>engine.unwrap(src, dsts, 0, dsts.length);</CODE></A> 
</pre></blockquote>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>src</CODE> - 착신 네트워크 데이터를 포함하는 <code>ByteBuffer</code><DD><CODE>dsts</CODE> - 착신 어플리케이션 데이터를 포함하는 <code>ByteBuffer</code> 의 배열
<DT><B>반환값:</B><DD>이 오퍼레이션의 결과를 설명하는 <code>SSLEngineResult</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - 데이터 처리중에 발생해,<code>SSLEngine</code> 의 이상종료(ABEND)의 원인이 된 문제.

                엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - ReadOnlyBufferException 읽기 전용의 <code>dst</code> 버퍼가 존재하는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - IllegalArgumentException <code>srcs</code> 와 <code>dst</code> 의 어느 쪽인지 한편이 null 의 경우, 또는 <code>dsts</code> 에 null 의 요소가 포함되는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - IllegalStateException 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int)"><CODE>unwrap(ByteBuffer, ByteBuffer [], int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int)"><!-- --></A> <H3>
unwrap</H3>
<PRE>
public abstract <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A>  <B>unwrap</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
                                       <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts,
                                       int&nbsp;offset,
                                       int&nbsp;length)
                                throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>SSL/TLS 네트워크 데이터를 plaintext의 어플리케이션 데이터 버퍼의 서브 순서에 복호화 하려고 합니다. 이 「살포」<i></i>오퍼레이션은, 1 회의 호출로, 단일의 바이트 순서를 1 개 이상의 지정의 버퍼 순서에 복호화 할 수 있습니다. 분산하는 안 랩은, 일반적으로, 네트워크 프로토콜이나 파일 형식 (예를 들어, 데이터를 1 개 이상의 고정장의 헤더와 가변 길이의 본체로부터 완성되는 세그먼트(segment)에 그룹화 하는 것 같은 파일 형식)을 구현할 때에 편리합니다. 살포의 자세한 것은 <A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 안의 인터페이스"><CODE>ScatteringByteChannel</CODE></A> , 살포 후의 동작의 자세한 것은 <A HREF="../../../java/nio/channels/ScatteringByteChannel.html#read(java.nio.ByteBuffer[], int, int)"><CODE>ScatteringByteChannel.read(ByteBuffer[], int, int)</CODE></A>  를 참조해 주세요.  &nbsp;<P>
SSLEngine 상태에 따라서는, 이 메소드는, 어플리케이션 데이터를 일절 생성하지 않고 네트워크 데이터를 사용하는 일이 있습니다.  예를 들어, 핸드 쉐이크 데이터가 이것에 해당합니다.  &nbsp;<P>
어플리케이션은, 피어로부터 네트워크 데이터를 안전하게 취득할 필요가 있습니다.  또, 수신한 순서에 데이터의 랩을 해제 (unwrap() 호출) 할 필요가 있습니다. 어플리케이션은, 이 메소드의 복수의 호출을 올바르고 동기화할 필요가 있습니다.  &nbsp;<P>
이 <code>SSLEngine</code> 가 아직 초기 핸드 쉐이크를 개시하고 있지 않는 경우, 이 메소드에 의해 초기 핸드 쉐이크가 자동적으로 개시됩니다.  &nbsp;<P>
이 메소드는, 단일의 완전한 SSL/TLS 네트워크 패킷을 소비하려고 합니다만, 버퍼에 남아 있는 합계 바이트수이상을 소비할 것은 없습니다. 각 <code>ByteBuffer</code> 의 위치는, 소비 또는 생성된 데이터량에 맞추어 갱신됩니다. 상한/하한치는 바뀌지 않습니다.  &nbsp;<P>
<code>src</code> 및 <code>dsts</code> 의 ByteBuffer 는, 부하에게 있는 각각 다른 메모리를 사용할 필요가 있습니다.  &nbsp;<P>
이 호출의 결과, 착신 네트워크버퍼-가 변경되는 일이 있습니다. 이 때문에, 이차적인 목적으로 네트워크 데이터 패킷이 필요한 경우는, 이 메소드의 호출전에 데이터를 복제할 필요가 있습니다. 주:네트워크 데이터를 2 번째의 SSLEngine 로 사용할 수 없습니다.  각 SSLEngine 가, SSL/TLS 메세지에 영향을 미치는 일의의 랜덤인 상태를 가지고 있기 때문입니다.  &nbsp;<P>
엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>src</CODE> - 착신 네트워크 데이터를 포함하는 <code>ByteBuffer</code><DD><CODE>dsts</CODE> - 착신 어플리케이션 데이터를 포함하는 <code>ByteBuffer</code> 의 배열<DD><CODE>offset</CODE> - 최초의 바이트의 전송처가 되는 버퍼 배열내의 오프셋(offset). <code>dsts.length</code> 이하의 제로 또는 정의 수<DD><CODE>length</CODE> - length 액세스 가능한 최대 버퍼수. <code>
                dsts.length</code>&nbsp;-&nbsp;<code>offset</code> 이하의 제로 또는 정의 수
<DT><B>반환값:</B><DD>이 오퍼레이션의 결과를 설명하는 <code>SSLEngineResult</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - 데이터 처리중에 발생해,<code>SSLEngine</code> 의 이상종료(ABEND)의 원인이 된 문제.

                엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - IndexOutOfBoundsException <code>offset</code> 파라미터와 <code>length</code> 파라미터의 전제 조건이 채워지지 않은 경우
<DD><CODE><A HREF="../../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - ReadOnlyBufferException 읽기 전용의 <code>dst</code> 버퍼가 존재하는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - IllegalArgumentException <code>src</code> 와 <code>dsts</code> 의 어느 쪽인지 한편이 null 의 경우, 또는 지정된 <code>dsts</code> 서브 순서에 null 의 요소가 포함되는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - IllegalStateException 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 내의 인터페이스"><CODE>ScatteringByteChannel</CODE></A> , 
<CODE>java.nio.channels.ScatteringByteChannel#read(</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getDelegatedTask()"><!-- --></A> <H3>
getDelegatedTask</H3>
<PRE>
public abstract <A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A>  <B>getDelegatedTask</B>()</PRE>
<DL>
<DD>이 <code>SSLEngine</code> 를 위해서(때문에) 위양 된 <code>Runnable</code> 태스크를 돌려줍니다.  &nbsp;<P>
<code>SSLEngine</code> 오퍼레이션에 필요한 오퍼레이션의 결과가 블록 되거나 완료까지 상당한 시간이 걸리는 일이 있습니다. 이 메소드는, 미처리 <A HREF="../../../java/lang/Runnable.html" title="java.lang 중의 인터페이스"><CODE>Runnable</CODE></A>  오퍼레이션 (태스크)을 취득하기 위해서 사용됩니다. 각 태스크에는,<A HREF="../../../java/lang/Runnable.html#run()"><CODE>run</CODE></A>  오퍼레이션을 실행하는 thread (현재의 thread도 가능)를 할당할 필요가 있습니다. <code>run</code> 메소드가 종료한 뒤, 불필요하게 된 <code>Runnable</code> 객체는 폐기 가능합니다.  &nbsp;<P>
위양 된 태스크는,<code>AccessControlContext</code> 내에서, 이 객체가 작성되었을 때에 실행됩니다.  &nbsp;<P>
이 메소드의 호출은, 미처리의 태스크를 각각 1 회만 돌려줍니다.  &nbsp;<P>
위양 된 복수의 태스크를 병렬 실행할 수도 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>위양 된 <code>Runnable</code> 태스크.
                사용할 수 있는 것이 없는 경우는 null</DL>
</DD>
</DL>
<HR>

<A NAME="closeInbound()"><!-- --></A> <H3>
closeInbound</H3>
<PRE>
public abstract void <B>closeInbound</B>()
                           throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>더 이상 이 <code>SSLEngine</code> 에 송신되는 착신 네트워크 데이터가 없는 것을 나타내는 신호입니다.  &nbsp;<P>
어플리케이션이 <A HREF="../../../javax/net/ssl/SSLEngine.html#closeOutbound()"><CODE>closeOutbound()</CODE></A>  를 호출해 종료 처리를 개시했을 때, 피어의 대응하는 종료 메세지를 기다릴 필요가 없는 경우가 있습니다 (종료의 경고의 대기에 관한 자세한 것은, TLS 스펙의 섹션 7.2. 1(<A  HREF="http://www.ietf.org/rfc/rfc2246.txt">RFC 2246</A> )을 참조). 이 경우, 이 메소드의 호출은 불필요합니다.  &nbsp;<P>
이것에 대해서, 어플리케이션이 종료 처리를 개시하지 않았던 경우나, 상기의 상황에 들어맞지 않는 경우는, SSL/TLS 데이터 스트림의 종료 부분이 착신할 때마다 이 메소드를 호출할 필요가 있습니다. 이것에 의해, 착신측의 종료가 보증되어 피어가 SSL/TLS 종료 수속을 적절히 실행한 것을 확인해, 값의 절약해에 의한 공격의 가능성을 검출할 수가 있습니다.  &nbsp;<P>
이 메소드는, 나무등입니다. 착신측이 벌써 종료하고 있는 경우는, 아무것도 실시하지 않습니다.  &nbsp;<P>
나머지의 핸드 쉐이크 데이터를 플래시 하려면 ,<A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>wrap()</CODE></A>  를 호출합니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - SSLException 이 엔진이 피어로부터 적절한 SSL/TLS 종료 통지 메세지를 받아들이지 않은 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#isInboundDone()"><CODE>isInboundDone()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#isOutboundDone()"><CODE>isOutboundDone()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isInboundDone()"><!-- --></A> <H3>
isInboundDone</H3>
<PRE>
public abstract boolean <B>isInboundDone</B>()</PRE>
<DL>
<DD><A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>unwrap(ByteBuffer, ByteBuffer)</CODE></A>  가 받아들이는 착신 데이터 메세지가 아직 있을지 어떨지를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD><code>SSLEngine</code> 가 더 이상 네트워크 데이터를 사용하지 않는 경우 (바꾸어 말하면, 더 이상 어플리케이션 데이터를 생성하지 않는 경우)는 true<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#closeInbound()"><CODE>closeInbound()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="closeOutbound()"><!-- --></A> <H3>
closeOutbound</H3>
<PRE>
public abstract void <B>closeOutbound</B>()</PRE>
<DL>
<DD>더 이상 이 <code>SSLEngine</code> 에 송신되는 송신 어플리케이션 데이터가 없는 것을 나타내는 신호입니다.  &nbsp;<P>
이 메소드는, 나무등입니다. 송신측이 벌써 종료하고 있는 경우는, 아무것도 실시하지 않습니다.  &nbsp;<P>
나머지의 핸드 쉐이크 데이터를 플래시 하려면 ,<A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>wrap(ByteBuffer, ByteBuffer)</CODE></A>  를 호출합니다.
<P>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#isOutboundDone()"><CODE>isOutboundDone()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isOutboundDone()"><!-- --></A> <H3>
isOutboundDone</H3>
<PRE>
public abstract boolean <B>isOutboundDone</B>()</PRE>
<DL>
<DD><A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>wrap(ByteBuffer, ByteBuffer)</CODE></A>  가 생성하는 송신 데이터 메세지가 아직 있을지 어떨지를 돌려줍니다.  &nbsp;<P>
종료 단계에서,<code>SSLEngine</code> 는, 피어에 송신하는 핸드 쉐이크 종료 데이터를 생성합니다.  이 데이터를 생성하려면 ,<code>wrap()</code> 를 호출할 필요가 있습니다. 이 메소드의 반환값이 true 의 경우, 더 이상 송신 데이터는 생성되지 않습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD><code>SSLEngine</code> 가 더 이상 네트워크 데이터를 생성하지 않는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#closeOutbound()"><CODE>closeOutbound()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#closeInbound()"><CODE>closeInbound()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSupportedCipherSuites()"><!-- --></A> <H3>
getSupportedCipherSuites</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getSupportedCipherSuites</B>()</PRE>
<DL>
<DD>이 엔진으로 사용 가능하게 할 수 있는 암호화 방식군의 이름을 돌려줍니다. 일반적으로은, 그 일부만이 디폴트로 사용 가능하게 됩니다.  디폴트의 서비스 품질 요건을 채우지 않은 암호화 방식군은, 사용 불가가 됩니다. 이러한 암호화 방식군은, 특수한 어플리케이션으로 사용됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>암호화 방식군명의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setEnabledCipherSuites(java.lang.String[])"><CODE>setEnabledCipherSuites(String [])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getEnabledCipherSuites()"><!-- --></A> <H3>
getEnabledCipherSuites</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getEnabledCipherSuites</B>()</PRE>
<DL>
<DD>이 엔진으로 현재 사용 가능하게 되어 있는 SSL 암호화 방식군의 이름을 돌려줍니다. SSL 엔진이 최초로 작성되었을 때에, 사용 가능하게는 모든 암호화 방식군으로, 최소한의 서비스 품질이 보증됩니다. 환경에 따라서는, 이 값은 빈 상태(empty)의 경우도 있습니다.  &nbsp;<P>
암호화 방식군은, 비록 유효해도 사용되지 않는 것이 있습니다. 예를 들어, 피어가 암호화 방식군을 지원하지 않는 경우, 이 encode에 필요한 증명서나 비공개키를 사용할 수가 없는 경우, 또는, 익명의 암호화 방식군이 이용 가능해도 인증이 요구되는 경우 등입니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>암호화 방식군명의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getSupportedCipherSuites()"><CODE>getSupportedCipherSuites()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setEnabledCipherSuites(java.lang.String[])"><CODE>setEnabledCipherSuites(String [])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnabledCipherSuites(java.lang.String[])"><!-- --></A> <H3>
setEnabledCipherSuites</H3>
<PRE>
public abstract void <B>setEnabledCipherSuites</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;suites)</PRE>
<DL>
<DD>이 엔진으로 사용 가능한 암호화 방식군을 설정합니다.  &nbsp;<P>
<code>suites</code> 파라미터로 지정된 각 암호화 방식군은, getSupportedCipherSuites()로 리스트되어 있지 않으면 안됩니다.  그렇지 않은 경우, 메소드는 실패합니다. 이 메소드의 호출이 정상적으로 행해졌을 때,<code>suites</code> 파라미터에 리스트 된 암호화 방식군만, 사용할 수가 있습니다.  &nbsp;<P>
왜 특정의 암호화 방식군을 엔진으로 사용할 수가 없는 것처럼 붙어서는,<A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A>  를 참조해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>suites</CODE> - 사용 가능하게 하는 모든 암호화 방식군의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 파라미터로 지정된 암호화 방식군의 일부가 지원되지 않는 경우, 또는 파라미터가 null 의 경우. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getSupportedCipherSuites()"><CODE>getSupportedCipherSuites()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSupportedProtocols()"><!-- --></A> <H3>
getSupportedProtocols</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getSupportedProtocols</B>()</PRE>
<DL>
<DD>이 <code>SSLEngine</code> 로 사용할 수가 있는 프로토콜의 이름을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>지원되고 있는 프로토콜의 배열</DL>
</DD>
</DL>
<HR>

<A NAME="getEnabledProtocols()"><!-- --></A> <H3>
getEnabledProtocols</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getEnabledProtocols</B>()</PRE>
<DL>
<DD>이 <code>SSLEngine</code> 로 현재 사용 가능하게 되어 있는 프로토콜의 버젼을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>프로토콜의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#setEnabledProtocols(java.lang.String[])"><CODE>setEnabledProtocols(String [])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnabledProtocols(java.lang.String[])"><!-- --></A> <H3>
setEnabledProtocols</H3>
<PRE>
public abstract void <B>setEnabledProtocols</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;protocols)</PRE>
<DL>
<DD>이 엔진으로 사용 가능한 프로토콜의 버젼을 설정합니다.  &nbsp;<P>
프로토콜은, getSupportedProtocols()에 의해, 지원 대상으로 해 리스트되어 있지 않으면 안됩니다. 이 메소드의 호출이 정상적으로 행해졌을 때,<code>protocols</code> 파라미터에 리스트 된 프로토콜만, 사용할 수가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>protocols</CODE> - 사용 가능하게 하는 모든 프로토콜의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 파라미터로 지정된 프로토콜의 일부가 지원되지 않는 경우, 또는 파라미터가 null 의 경우. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledProtocols()"><CODE>getEnabledProtocols()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSession()"><!-- --></A> <H3>
getSession</H3>
<PRE>
public abstract <A HREF="../../../javax/net/ssl/SSLSession.html" title="javax.net.ssl 내의 인터페이스">SSLSession</A>  <B>getSession</B>()</PRE>
<DL>
<DD>이 <code>SSLEngine</code> 로 사용중의 <code>SSLSession</code> 를 돌려줍니다.  &nbsp;<P>
SSL 세션은 유효기간이 길고, 사용자에 따라서는 로그인 세션 전체에 대응하는 일도 있습니다. 세션에는, 세션내의 모든 접속으로 사용되는 암호화 방식군과 세션의 클라이언트와 서버의 식별 정보가 지정되고 있습니다.  &nbsp;<P>
이 메소드는,<A HREF="../../../javax/net/ssl/SSLSocket.html#getSession()"><CODE>SSLSocket.getSession()</CODE></A>  과는 달리, 핸드 쉐이크가 완료할 때까지 블록 되지 않습니다.  &nbsp;<P>
초기 핸드 쉐이크가 완료하면(자), 무효인 암호화 방식군 SSL_NULL_WITH_NULL_NULL 를 보고하는 세션 객체를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>SSLEngine</code> 의 <code>SSLSession</code><DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSession.html" title="javax.net.ssl 내의 인터페이스"><CODE>SSLSession</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="beginHandshake()"><!-- --></A> <H3>
beginHandshake</H3>
<PRE>
public abstract void <B>beginHandshake</B>()
                             throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>이 SSLEngine 의 초기 핸드 쉐이크 또는 재협상의 핸드 쉐이크를 개시합니다.  &nbsp;<P>
이 메소드는, 초기 핸드 쉐이크시에는 필요 없습니다.  핸드 쉐이크가 아직 개시되어 있지 않은 경우는,<code>wrap()</code> 메소드와 <code>unwrap()</code> 메소드에 의해 암묵적으로 이 메소드가 불려 가기 때문입니다.  &nbsp;<P>
피어도, 적절한 세션재협상의 핸드 쉐이크 메세지를 송신하는 것으로써, 이 <code>SSLEngine</code> 와의 세션의 재협상을 요구하는 일이 있습니다.  &nbsp;<P>
이 메소드는,<A HREF="../../../javax/net/ssl/SSLSocket.html#startHandshake()"><CODE>SSLSocket#startHandshake()</CODE></A>  메소드와는 달라, 핸드 쉐이크가 완료할 때까지 블록 되지 않습니다.  &nbsp;<P>
강제적으로 SSL/TLS 세션의 재협상을 실시하는 경우는, 현재의 세션을 무효로 하고 나서 이 메소드를 호출할 필요가 있습니다.  &nbsp;<P>
기존의 엔진상에서 복수의 핸드 쉐이크를 지원하지 않고,<code>SSLException</code> 를 throw 하는 프로토콜도 있습니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - SSLException <code>SSLEngine</code> 에 새롭고 핸드 쉐이크를 개시하도록(듯이) 통지하고 있을 때, 문제가 발생했을 경우.

                엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - IllegalStateException 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSession.html#invalidate()"><CODE>SSLSession.invalidate()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getHandshakeStatus()"><!-- --></A> <H3>
getHandshakeStatus</H3>
<PRE>
public abstract <A HREF="../../../javax/net/ssl/SSLEngineResult.HandshakeStatus.html" title="javax.net.ssl 내의 열거형">SSLEngineResult.HandshakeStatus</A>  <B>getHandshakeStatus</B>()</PRE>
<DL>
<DD>이 <code>SSLEngine</code> 의 현재의 핸드 쉐이크 상태를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 <code>SSLEngineResult.HandshakeStatus</code></DL>
</DD>
</DL>
<HR>

<A NAME="setUseClientMode(boolean)"><!-- --></A> <H3>
setUseClientMode</H3>
<PRE>
public abstract void <B>setUseClientMode</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>핸드 쉐이크시, 엔진이 클라이언트 (또는 서버) 모드를 사용하도록(듯이) 설정합니다.  &nbsp;<P>
이 메소드는, 모든 핸드 쉐이크의 전에 호출할 필요가 있습니다. 일단 핸드 쉐이크가 개시되면(자), 이 엔진의 수명이 다할 때까지, 현재의 모드를 리셋 할 수 없습니다.  &nbsp;<P>
일반적으로, 서버는 자신을 인증합니다만, 클라이언트는 반드시 그렇다고는 할 수 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>mode</CODE> - mode 핸드 쉐이크를 클라이언트 모드로 개시하는 경우는 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 최초의 핸드 쉐이크가 개시되고 나서 모드를 변경하려고 했을 경우. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getUseClientMode()"><CODE>getUseClientMode()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getUseClientMode()"><!-- --></A> <H3>
getUseClientMode</H3>
<PRE>
public abstract boolean <B>getUseClientMode</B>()</PRE>
<DL>
<DD>핸드 쉐이크시에 클라이언트 모드를 사용하도록(듯이) 엔진이 설정되어 있는 경우는 true
<P>
<DD><DL>

<DT><B>반환값:</B><DD>클라이언트 모드로 핸드 쉐이크를 실시하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setNeedClientAuth(boolean)"><!-- --></A> <H3>
setNeedClientAuth</H3>
<PRE>
public abstract void <B>setNeedClientAuth</B>(boolean&nbsp;need)</PRE>
<DL>
<DD>클라이언트 인증이 필수가 되는 것<i></i>같게 엔진을 설정합니다. 이 옵션은, 서버 모드의 엔진만으로 사용합니다.  &nbsp;<P>
엔진의 클라이언트 인증 설정은, 다음의 어느 쪽인가에 됩니다.
 <ul>
<li> 클라이언트 인증을 필수로 한다
<li> 클라이언트 인증을 요구한다
<li> 클라이언트 인증을 불필요하게 한다
 </ul>
 <P>
<A HREF="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A>  의 경우와는 달라, 이 옵션이 설정되어 있어, 한편 클라이언트 인증 정보가 제공되지 않는 경우는, 협상이 정지해, 엔진은, 종료 프로시저를 개시합니다. <i></i> &nbsp;<P>
이 메소드를 호출하면(자), 지금까지 이 메소드 또는 <A HREF="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A>  에 의해 설정된 내용이 오버라이드(override) 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>need</CODE> - 클라이언트 인증이 필수의 경우는 true, 클라이언트 인증이 불필요한 경우는 false. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getNeedClientAuth()"><CODE>getNeedClientAuth()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#getWantClientAuth()"><CODE>getWantClientAuth()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getNeedClientAuth()"><!-- --></A> <H3>
getNeedClientAuth</H3>
<PRE>
public abstract boolean <B>getNeedClientAuth</B>()</PRE>
<DL>
<DD>이 엔진에 클라이언트 인증이 필수인<i></i>경우는 true 를 돌려줍니다. 이 옵션은, 서버 모드의 엔진만으로 사용합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>클라이언트 인증이 필수의 경우는 true, 클라이언트 인증이 불필요한 경우는 false. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#getWantClientAuth()"><CODE>getWantClientAuth()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setWantClientAuth(boolean)"><!-- --></A> <H3>
setWantClientAuth</H3>
<PRE>
public abstract void <B>setWantClientAuth</B>(boolean&nbsp;want)</PRE>
<DL>
<DD>클라이언트 인증을 요구<i></i>하도록(듯이) 엔진을 설정합니다. 이 옵션은, 서버 모드의 엔진만으로 사용합니다.  &nbsp;<P>
엔진의 클라이언트 인증 설정은, 다음의 어느 쪽인가에 됩니다.
 <ul>
<li> 클라이언트 인증을 필수로 한다
<li> 클라이언트 인증을 요구한다
<li> 클라이언트 인증을 불필요하게 한다
 </ul>
 <P>
<A HREF="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>  와 달리, 이 옵션이 설정되어 있어, 한편 클라이언트 인증 정보가 제공되지 않는 경우에서도, 협상은 속행됩니다. <i></i> &nbsp;<P>
이 메소드를 호출하면(자), 지금까지 이 메소드 또는 <A HREF="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>  에 의해 설정된 내용이 오버라이드(override) 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>want</CODE> - 클라이언트 인증이 요구되었을 경우는 true, 클라이언트 인증이 불필요한 경우는 false. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getWantClientAuth()"><CODE>getWantClientAuth()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#getNeedClientAuth()"><CODE>getNeedClientAuth()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getWantClientAuth()"><!-- --></A> <H3>
getWantClientAuth</H3>
<PRE>
public abstract boolean <B>getWantClientAuth</B>()</PRE>
<DL>
<DD>이 엔진이 클라이언트 인증을 요구하는<i></i>경우는 true 를 돌려줍니다. 이 옵션은, 서버 모드의 엔진만으로 사용합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>클라이언트 인증이 요구되었을 경우는 true, 클라이언트 인증이 불필요한 경우는 false. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#getNeedClientAuth()"><CODE>getNeedClientAuth()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnableSessionCreation(boolean)"><!-- --></A> <H3>
setEnableSessionCreation</H3>
<PRE>
public abstract void <B>setEnableSessionCreation</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>이 엔진으로 새로운 SSL 세션을 확립할 수 있을지 어떨지를 제어합니다. 세션을 작성하지 못하고, 재개할 수 있는 기존의 세션이 없는 경우, 핸드 쉐이크는 성공하지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>flag</CODE> - 세션을 작성할 수 있는 경우는 true (디폴트).
                기존의 세션을 재개하는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getEnableSessionCreation()"><CODE>getEnableSessionCreation()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getEnableSessionCreation()"><!-- --></A> <H3>
getEnableSessionCreation</H3>
<PRE>
public abstract boolean <B>getEnableSessionCreation</B>()</PRE>
<DL>
<DD>이 엔진으로 새로운 SSL 세션을 확립할 수 있는 경우는 true 를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>세션을 작성할 수 있는 경우는 true (디폴트).
                기존의 세션을 재개하는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#setEnableSessionCreation(boolean)"><CODE>setEnableSessionCreation(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSSLParameters()"><!-- --></A> <H3>
getSSLParameters</H3>
<PRE>
public <A HREF="../../../javax/net/ssl/SSLParameters.html" title="javax.net.ssl 내의 클래스">SSLParameters</A>  <B>getSSLParameters</B>()</PRE>
<DL>
<DD>이 SSLEngine 로 유효한 SSLParameters 를 돌려줍니다. 반환되는 SSLParameters 의 암호화 방식군과 프로토콜은, 항상 null 이외입니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 SSLEngine 로 유효한 SSLParameters. <DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSSLParameters(javax.net.ssl.SSLParameters)"><!-- --></A> <H3>
setSSLParameters</H3>
<PRE>
public void <B>setSSLParameters</B>(<A HREF="../../../javax/net/ssl/SSLParameters.html" title="javax.net.ssl 안의 클래스">SSLParameters</A> &nbsp;params)</PRE>
<DL>
<DD>이 엔진에 SSLParameters 를 적용합니다.

 <p>이것은 다음 일을 의미합니다.
 <ul>
<li><code>params.getCipherSuites()</code> 가 null 이외의 경우, 그 값을 사용해 <code>setEnabledCipherSuites()</code> 가 불려 간다
<li><code>params.getProtocols()</code> 가 null 이외의 경우, 그 값을 사용해 <code>setEnabledProtocols()</code> 가 불려 간다
<li><code>params.getNeedClientAuth()</code> 또는 <code>params.getWantClientAuth()</code> 가 <code>true</code> 를 돌려주는 경우, 각각 <code>setNeedClientAuth(true)</code> 또는 <code>setWantClientAuth(true)</code> 가 불려 간다. 그렇지 않은 경우,<code>setWantClientAuth(false)</code> 가 불려 간다.
 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>params</CODE> - 파라미터
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - setEnabledCipherSuites() 또는 the setEnabledProtocols()의 호출해에 실패했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SSLEngine.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/net/ssl/SSLContextSpi.html" title="javax.net.ssl 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/net/ssl/SSLEngine.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="SSLEngine.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
