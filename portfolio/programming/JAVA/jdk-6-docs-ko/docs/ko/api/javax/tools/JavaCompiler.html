<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:44:07 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
JavaCompiler (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JavaCompiler (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JavaCompiler.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/tools/ForwardingJavaFileObject.html" title="javax.tools 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/tools/JavaCompiler.CompilationTask.html" title="javax.tools 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/tools/JavaCompiler.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="JavaCompiler.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.tools</FONT>
<BR>
인터페이스 JavaCompiler</H2>
<DL>
<DT><B>모든 슈퍼 인터페이스:</B> <DD><A HREF="../../javax/tools/OptionChecker.html" title="javax.tools 내의 인터페이스">OptionChecker</A> , <A HREF="../../javax/tools/Tool.html" title="javax.tools 안의 인터페이스">Tool</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public interface <B>JavaCompiler</B><DT>extends <A HREF="../../javax/tools/Tool.html" title="javax.tools 내의 인터페이스">Tool</A> , <A HREF="../../javax/tools/OptionChecker.html" title="javax.tools 안의 인터페이스">OptionChecker</A> </DL>
</PRE>

<P>
Java 프로그램으로부터 Java&trade; 프로그램 언어 컴파일러를 호출하는 인터페이스입니다.

 <p>컴파일러는, 컴파일중에 에러 메세지등의 진단 정보를 생성하는 일이 있습니다. 진단 청취자가 지정되고 있는 경우, 진단 정보는 이 청취자에게 제공됩니다. 청취자가 지정되어 있지 않은 경우, 진단 정보는 하등의 형식 (미지정)에서 포맷 되어 디폴트의 출력에 기입해집니다. 이 디폴트의 출력은, 특히 지정되어 있지 않으면 <code>System.err</code> 가 됩니다. 진단 청취자가 지정되고 있어도, 일부의 진단 정보가 <code>Diagnostic</code> 에 적합하지 않는 경우가 있습니다. 이 경우, 이 진단 정보는 디폴트의 출력에 기입해집니다.

 <p>컴파일러 툴에는, 표준 파일 관리자-가 관련지을 수 있고 있습니다. 이 파일 관리자-는, 컴파일러 툴의 네이티브의 (편입형의) 파일 관리자-입니다. 표준 파일 관리자-를 가져오려면 ,<A HREF="../../javax/tools/JavaCompiler.html#getStandardFileManager(javax.tools.DiagnosticListener, java.util.Locale, java.nio.charset.Charset)">getStandardFileManager</A>  를 호출합니다.

 <p>컴파일러 툴은, 추가 요건 (자세한 것은 아래와 같은 메소드를 참조)이 채워지고 있는 한은, 임의의 파일 관리자-로 기능할 필요가 있습니다. 파일 관리자-가 지정되지 않았던 경우, 컴파일러 툴은, 표준 파일 관리자- (예를 들어 <A HREF="../../javax/tools/JavaCompiler.html#getStandardFileManager(javax.tools.DiagnosticListener, java.util.Locale, java.nio.charset.Charset)">getStandardFileManager</A>  에 의해 반환되는 파일 관리자-)를 사용합니다.

 <p>이 인터페이스를 구현하는 인스턴스는, 「Java 언어 스펙」에 준거하고 있어, 한편 「Java 가상 머신 스펙」에 준거한 클래스 파일을 생성할 필요가 있습니다. 이러한 스펙의 버젼은,<A HREF="../../javax/tools/Tool.html" title="javax.tools 안의 인터페이스">Tool</A>  인터페이스에 정의되고 있습니다.   

게다가 이 인터페이스의 인스턴스 가운데,<A HREF="../../javax/lang/model/SourceVersion.html#RELEASE_6"><CODE>SourceVersion.RELEASE_6</CODE></A>  이상을 지원하는 것은,<A HREF="../../javax/annotation/processing/package-summary.html">주석 처리</a>도 지원할 필요가 있습니다.

 <p>컴파일러는,<A HREF="../../javax/tools/DiagnosticListener.html" title="javax.tools 안의 인터페이스">진단 청취자</a>와<A HREF="../../javax/tools/JavaFileManager.html" title="javax.tools 안의 인터페이스">파일 관리자-</a>의 2 개의 서비스에 의존하고 있습니다. 이 패키지에 포함되는 대부분의 클래스 및 인터페이스는 컴파일러 ( 및 툴 일반)의 API 를 정의하고 있습니다만,<A HREF="../../javax/tools/DiagnosticListener.html" title="javax.tools 안의 인터페이스">DiagnosticListener</A> ,<A HREF="../../javax/tools/JavaFileManager.html" title="javax.tools 안의 인터페이스">JavaFileManager</A> ,<A HREF="../../javax/tools/FileObject.html" title="javax.tools 안의 인터페이스">FileObject</A> , 및 <A HREF="../../javax/tools/JavaFileObject.html" title="javax.tools 안의 인터페이스">JavaFileObject</A>  의 각 인터페이스는 어플리케이션으로 사용하기 위한의 것이 아닙니다. 이러한 인터페이스는, 컴파일러용의 커스텀 서비스를 제공하는 목적으로 구현되어 사용됩니다. 따라서, 컴파일러의 SPI 를 정의합니다.

 <p>이 패키지에는, SPI 의 구현을 간편화해, 컴파일러의 동작을 커스터마이즈하기 위한 클래스 및 인터페이스가 다수 포함되어 있습니다.

 <dl>
<dt><A HREF="../../javax/tools/StandardJavaFileManager.html" title="javax.tools 안의 인터페이스"><CODE>StandardJavaFileManager</CODE></A> </dt>
   <dd>

이 인터페이스를 구현하는 모든 컴파일러는, 일반적으로 <A HREF="../../java/io/File.html" title="java.io 중의 클래스">파일</a>을 조작하는 표준 파일 관리자-를 제공합니다. StandardJavaFileManager 인터페이스는, 일반적으로 파일로부터 파일 객체를 작성하는 추가 메소드를 정의합니다.

 <p>표준 파일 관리자-에는, 다음의 2 개의 용도가 있습니다.

     <ul>
<li>컴파일러에 의한 파일의 읽기 및 기입을 커스터마이즈 할 경우에 기본 구축 블록으로서 사용</li>
<li>복수의 컴파일 태스크간에 공유</li>
     </ul>

 <p>파일 관리자-를 재사용하는 것으로, 파일 시스템의 스캔과 jar 파일의 읽기의 오버헤드가 잠재적으로 삭감될 가능성이 있습니다. 오버헤드가 삭감되지 않는 경우에서도, 표준 파일 관리자-는 복수의 컴파일 태스크를 차례차례 처리할 필요가 있습니다. 다음의 예의 같은 코딩 패턴을 추천합니다.

     <pre>
Files[] files1 = ...; // 최초의 컴파일 태스크의 입력
Files[] files2 = ...; // 2 번째의 컴파일 태스크의 입력

JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);

<code>Iterable&lt;?  extends JavaFileObject&gt;</code> compilationUnits1 =
fileManager.getJavaFileObjectsFromFiles(<A HREF="../../java/util/Arrays.html#asList(T...)">Arrays.asList</A> (files1));
compiler.getTask(null, fileManager, null, null, null, compilationUnits1). call();

<code>Iterable&lt;?  extends JavaFileObject&gt;</code> compilationUnits2 =
fileManager.getJavaFileObjects(files2); // 대체 메소드를 사용
// jar 파일의 캐쉬를 유효하게 하기 위한(해) 같은 파일 관리자-를 재사용
compiler.getTask(null, fileManager, null, null, null, compilationUnits2). call();

fileManager.close();</pre>

   </dd>

<dt><A HREF="../../javax/tools/DiagnosticCollector.html" title="javax.tools 안의 클래스"><CODE>DiagnosticCollector</CODE></A> </dt>
   <dd>
진단 정보를 수집해, 리스트화하기 위해서(때문에) 사용합니다. 다음에 예를 나타냅니다.
     <pre>
<code>Iterable&lt;?  extends JavaFileObject&gt;</code> compilationUnits = ...;
JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
<code>DiagnosticCollector&lt;JavaFileObject&gt; diagnostics = new DiagnosticCollector&lt;JavaFileObject&gt;();</code>
StandardJavaFileManager fileManager = compiler.getStandardFileManager(diagnostics, null, null);
compiler.getTask(null, fileManager, diagnostics, null, null, compilationUnits). call();

for (Diagnostic diagnostic :diagnostics.getDiagnostics())
System.out.format("Error on line %d in %d%n",
diagnostic.getLineNumber()
diagnostic.getSource(). toUri());

fileManager.close();</pre>
   </dd>

   <dt>
<A HREF="../../javax/tools/ForwardingJavaFileManager.html" title="javax.tools 안의 클래스"><CODE>ForwardingJavaFileManager</CODE></A> ,<A HREF="../../javax/tools/ForwardingFileObject.html" title="javax.tools 안의 클래스"><CODE>ForwardingFileObject</CODE></A> , 및 <A HREF="../../javax/tools/ForwardingJavaFileObject.html" title="javax.tools 안의 클래스"><CODE>ForwardingJavaFileObject</CODE></A> 
   </dt>
   <dd>

표준 파일 관리자-의 동작을 오버라이드(override) 하는 목적으로 서브 클래스화를 실시할 수 없습니다. 이것은, 표준 파일 관리자-가 생성자 의 호출에 의해 작성된 것은 아니고, 컴파일러로 메소드를 호출하는 것에 의해 작성된 것이기 때문입니다. 서브 클래스화 대신에, 전송 (또는 위양)을 사용할 필요가 있습니다. 이러한 클래스를 사용하면(자), 대부분의 호출을 간단하게 지정의 파일 관리자-또는 파일 객체에 전송 가능할 뿐만 아니라, 파일 관리자-의 동작을 커스터마이즈 할 수도 있습니다. 예를 들어,<A HREF="../../javax/tools/JavaFileManager.html#flush()">JavaFileManager.flush()</A>  의 호출을 모두 로그에 기록하려면 , 다음과 같이 합니다.

     <pre>
final <A HREF="../../java/util/logging/Logger.html" title="java.util.logging 내의 클래스">Logger</A>  logger = ...;
<code>Iterable&lt;?  extends JavaFileObject&gt;</code> compilationUnits = ...;
JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
StandardJavaFileManager stdFileManager = compiler.getStandardFileManager(null, null, null);
JavaFileManager fileManager = new ForwardingJavaFileManager(stdFileManager) {
public void flush() {
logger.entering(StandardJavaFileManager.class.getName(), "flush");
super.flush();
logger.exiting(StandardJavaFileManager.class.getName(), "flush");
           }
       };
compiler.getTask(null, fileManager, null, null, null, compilationUnits). call();</pre>
   </dd>

<dt><A HREF="../../javax/tools/SimpleJavaFileObject.html" title="javax.tools 안의 클래스"><CODE>SimpleJavaFileObject</CODE></A> </dt>
   <dd>

이 클래스는, 파일 객체를 작성할 때, 기본 단위로서 사용할 수 있는 기본 파일 객체 구현을 제공합니다. 예를 들어, 캐릭터 라인에 포함된 원시 코드를 나타내는 파일 객체를 정의하려면 , 다음과 같이 합니다.

     <pre>
       /**
* 캐릭터 라인에 포함된 소스를 나타내기 위해서(때문에) 사용하는 파일 객체.
<code>*</code>/
public class JavaSourceFromString extends SimpleJavaFileObject {
           /**
* 이 「파일」의 원시 코드.
<code>*</code>/
final String code;

           /**
* 새로운 JavaSourceFromString 를 구축.
* <code>@</code>param name 는 이 파일 객체로 나타내지는 컴파일 유니트의 이름
* <code>@</code>param code 는 이 파일 객체로 나타내지는 컴파일 유니트의 원시 코드
<code>*</code>/
JavaSourceFromString(String name, String code) {
super(<A HREF="../../java/net/URI.html#create(java.lang.String)">URI.create</A> ("string:///" + name.replace('. ', '/') + Kind.SOURCE.extension),
Kind.SOURCE);
this.code = code;
           }

<code>@</code>Override
public CharSequence getCharContent(boolean ignoreEncodingErrors) {
return code;
           }
       }</pre>
   </dd>
 </dl>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/tools/DiagnosticListener.html" title="javax.tools 내의 인터페이스"><CODE>DiagnosticListener</CODE></A> , 
<A HREF="../../javax/tools/Diagnostic.html" title="javax.tools 안의 인터페이스"><CODE>Diagnostic</CODE></A> , 
<A HREF="../../javax/tools/JavaFileManager.html" title="javax.tools 안의 인터페이스"><CODE>JavaFileManager</CODE></A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/tools/JavaCompiler.CompilationTask.html" title="javax.tools 안의 인터페이스">JavaCompiler.CompilationTask</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴파일 태스크의 장래를 나타내는 인터페이스입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/tools/StandardJavaFileManager.html" title="javax.tools 내의 인터페이스">StandardJavaFileManager</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/tools/JavaCompiler.html#getStandardFileManager(javax.tools.DiagnosticListener, java.util.Locale, java.nio.charset.Charset)">getStandardFileManager</A> </B>(<A HREF="../../javax/tools/DiagnosticListener.html" title="javax.tools 안의 인터페이스">DiagnosticListener</A> &lt;?  super <A HREF="../../javax/tools/JavaFileObject.html" title="javax.tools 내의 인터페이스">JavaFileObject</A> &gt;&nbsp;diagnosticListener,
                       <A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;locale,
                       <A HREF="../../java/nio/charset/Charset.html" title="java.nio.charset 안의 클래스">Charset</A> &nbsp;charset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 툴의 표준 파일 관리자-구현의 새로운 인스턴스를 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/tools/JavaCompiler.CompilationTask.html" title="javax.tools 내의 인터페이스">JavaCompiler.CompilationTask</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/tools/JavaCompiler.html#getTask(java.io.Writer, javax.tools.JavaFileManager, javax.tools.DiagnosticListener, java.lang.Iterable, java.lang.Iterable, java.lang.Iterable)">getTask</A> </B>(<A HREF="../../java/io/Writer.html" title="java.io 안의 클래스">Writer</A> &nbsp;out,
        <A HREF="../../javax/tools/JavaFileManager.html" title="javax.tools 안의 인터페이스">JavaFileManager</A> &nbsp;fileManager,
        <A HREF="../../javax/tools/DiagnosticListener.html" title="javax.tools 안의 인터페이스">DiagnosticListener</A> &lt;?  super <A HREF="../../javax/tools/JavaFileObject.html" title="javax.tools 내의 인터페이스">JavaFileObject</A> &gt;&nbsp;diagnosticListener,
        <A HREF="../../java/lang/Iterable.html" title="java.lang 안의 인터페이스">Iterable</A> &lt;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> &gt;&nbsp;options,
        <A HREF="../../java/lang/Iterable.html" title="java.lang 안의 인터페이스">Iterable</A> &lt;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> &gt;&nbsp;classes,
        <A HREF="../../java/lang/Iterable.html" title="java.lang 안의 인터페이스">Iterable</A> &lt;?  extends <A HREF="../../javax/tools/JavaFileObject.html" title="javax.tools 내의 인터페이스">JavaFileObject</A> &gt;&nbsp;compilationUnits)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정의 컴퍼넌트 및 인수를 가지는 컴파일 태스크의 장래를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.tools.Tool"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 javax.tools. <A HREF="../../javax/tools/Tool.html" title="javax.tools 안의 인터페이스">Tool</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javax/tools/Tool.html#getSourceVersions()">getSourceVersions</A> , <A HREF="../../javax/tools/Tool.html#run(java.io.InputStream, java.io.OutputStream, java.io.OutputStream, java.lang.String...)">run</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.tools.OptionChecker"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 javax.tools. <A HREF="../../javax/tools/OptionChecker.html" title="javax.tools 안의 인터페이스">OptionChecker</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javax/tools/OptionChecker.html#isSupportedOption(java.lang.String)">isSupportedOption</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getTask(java.io.Writer, javax.tools.JavaFileManager, javax.tools.DiagnosticListener, java.lang.Iterable, java.lang.Iterable, java.lang.Iterable)"><!-- --></A> <H3>
getTask</H3>
<PRE>
<A HREF="../../javax/tools/JavaCompiler.CompilationTask.html" title="javax.tools 안의 인터페이스">JavaCompiler.CompilationTask</A>  <B>getTask</B>(<A HREF="../../java/io/Writer.html" title="java.io 안의 클래스">Writer</A> &nbsp;out,
                                     <A HREF="../../javax/tools/JavaFileManager.html" title="javax.tools 안의 인터페이스">JavaFileManager</A> &nbsp;fileManager,
                                     <A HREF="../../javax/tools/DiagnosticListener.html" title="javax.tools 안의 인터페이스">DiagnosticListener</A> &lt;?  super <A HREF="../../javax/tools/JavaFileObject.html" title="javax.tools 내의 인터페이스">JavaFileObject</A> &gt;&nbsp;diagnosticListener,
                                     <A HREF="../../java/lang/Iterable.html" title="java.lang 안의 인터페이스">Iterable</A> &lt;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> &gt;&nbsp;options,
                                     <A HREF="../../java/lang/Iterable.html" title="java.lang 안의 인터페이스">Iterable</A> &lt;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> &gt;&nbsp;classes,
                                     <A HREF="../../java/lang/Iterable.html" title="java.lang 안의 인터페이스">Iterable</A> &lt;?  extends <A HREF="../../javax/tools/JavaFileObject.html" title="javax.tools 내의 인터페이스">JavaFileObject</A> &gt;&nbsp;compilationUnits)</PRE>
<DL>
<DD>지정의 컴퍼넌트 및 인수를 가지는 컴파일 태스크의 장래를 작성합니다. 컴파일은, CompilationTask 인터페이스에 기술되고 있는 대로 행해지지 않을 가능성이 있습니다.

 <p>파일 관리자-가 지정되고 있는 경우,<A HREF="../../javax/tools/StandardLocation.html" title="javax.tools 안의 열거형"><CODE>StandardLocation</CODE></A>  에 정의 떠날 수 있어 모든 장소를 처리할 수 없으면 안됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>out</CODE> - 컴파일러로부터의 추가 출력에 사용하는 Writer. <code>null</code> 의 경우는 <code>System.err</code> 를 사용<DD><CODE>fileManager</CODE> - 파일 관리자-. <code>null</code> 의 경우는 컴파일러의 표준 파일 관리자-를 사용<DD><CODE>diagnosticListener</CODE> - 진단 청취자. <code>null</code> 의 경우, 컴파일러의 디폴트의 메소드를 사용해 진단 정보를 보고<DD><CODE>options</CODE> - 컴파일러 옵션. <code>null</code> 의 경우, 옵션은 존재하지 않는<DD><CODE>classes</CODE> - 클래스명 (주석 처리용). <code>null</code> 의 경우, 클래스명은 존재하지 않는<DD><CODE>compilationUnits</CODE> - 컴파일 대상의 컴파일 유니트. <code>null</code> 의 경우, 컴파일 유니트는 존재하지 않는다
<DT><B>반환값:</B><DD>컴파일을 나타내는 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/RuntimeException.html" title="java.lang 안의 클래스">RuntimeException</A> </CODE> - 사용자 지정의 컴퍼넌트내에서, 회복 불가능한 에러가 발생했을 경우.
<A HREF="../../java/lang/Throwable.html#getCause()">cause</A>  는 사용자 코드내의 에러
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <A HREF="../../javax/tools/JavaFileObject.Kind.html#SOURCE">소스</a>와는 다른 종류의 컴파일 유니트가 지정되었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getStandardFileManager(javax.tools.DiagnosticListener, java.util.Locale, java.nio.charset.Charset)"><!-- --></A> <H3>
getStandardFileManager</H3>
<PRE>
<A HREF="../../javax/tools/StandardJavaFileManager.html" title="javax.tools 안의 인터페이스">StandardJavaFileManager</A>  <B>getStandardFileManager</B>(<A HREF="../../javax/tools/DiagnosticListener.html" title="javax.tools 안의 인터페이스">DiagnosticListener</A> &lt;?  super <A HREF="../../javax/tools/JavaFileObject.html" title="javax.tools 내의 인터페이스">JavaFileObject</A> &gt;&nbsp;diagnosticListener,
                                               <A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;locale,
                                               <A HREF="../../java/nio/charset/Charset.html" title="java.nio.charset 안의 클래스">Charset</A> &nbsp;charset)</PRE>
<DL>
<DD>이 툴의 표준 파일 관리자-구현의 새로운 인스턴스를 가져옵니다. 파일 관리자-는, 치명적이지 않는 진단 정보의 생성에, 지정의 진단 청취자를 사용합니다. 치명적 에러가 발생했을 경우, 적절한 예외에 의해 통지됩니다.

 <p>표준 파일 관리자-는,<code>flush</code> 또는 <code>close</code> 의 호출의 나중에 액세스 되면(자), 자동적으로 재기동합니다. 표준 파일 관리자-는, 그 외의 툴로부터 이용할 수 없으면 안됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>diagnosticListener</CODE> - 치명적이지 않은 진단 정보용의 진단 청취자. <code>null</code> 의 경우, 컴파일러의 디폴트의 메소드를 사용해 진단 정보를 보고<DD><CODE>locale</CODE> - 진단 정보의 포맷시에 적용되는 로케일. <code>null</code> 의 경우,<A HREF="../../java/util/Locale.html#getDefault()">디폴트의 로케일</a>이 적용되는<DD><CODE>charset</CODE> - 바이트의 디코드에 사용된 캐릭터 세트. <code>null</code> 의 경우, 플랫폼의 디폴트의 캐릭터 세트를 사용
<DT><B>반환값:</B><DD>표준 파일 관리자-</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JavaCompiler.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/tools/ForwardingJavaFileObject.html" title="javax.tools 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/tools/JavaCompiler.CompilationTask.html" title="javax.tools 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/tools/JavaCompiler.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="JavaCompiler.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드&nbsp;|&nbsp;생성자  &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
