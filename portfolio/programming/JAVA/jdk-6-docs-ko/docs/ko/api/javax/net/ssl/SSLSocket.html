<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:03:50 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
SSLSocket (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SSLSocket (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SSLSocket.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/net/ssl/SSLSessionContext.html" title="javax.net.ssl 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/net/ssl/SSLSocketFactory.html" title="javax.net.ssl 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/net/ssl/SSLSocket.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="SSLSocket.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.net.ssl</FONT>
<BR>
클래스 SSLSocket</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../java/net/Socket.html" title="java.net 내의 클래스">java.net.Socket</A> 
      <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.net.ssl.SSLSocket</B>
</PRE>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>SSLSocket</B><DT>extends <A HREF="../../../java/net/Socket.html" title="java.net 내의 클래스">Socket</A> </DL>
</PRE>

<P>
이 클래스는 <code>Socket</code> 를 확장해, Secure Sockets Layer (SSL)나 IETF Transport Layer Security (TLS)등의 프로토콜을 사용하는 시큐어 소켓을 제공합니다.  &nbsp;<P>
이러한 소켓은, 일반적으로의 스트림 소켓입니다만, TCP 등의 기본이 되는 네트워크 트랜스폴트 프로토콜상에 시큐리티 보호층을 추가합니다. 다음의 시큐리티 보호를 합니다.  <UL>

        <LI> 무결성의 보호. <em></em>SSL 가 메세지를 도청에 의한 조작으로부터 보호한다

        <LI> 인증<em></em>. 대부분의 SSL 모드에서는, 피어 인증이 제공된다. 일반적으로은, 서버 인증을 한다. 서버로부터의 요구에 응해, 클라이언트 인증도 행해진다.

        <LI> 기밀성 (프라이버시의 보호)<em></em>. 대부분의 SSL 모드에서는, 클라이언트와 서버간에 송신되는 데이터가 암호화되어 데이터의 기밀성이 보호된다. 이 결과, 수동적인 도청에 의해, 금융정보나 개인정보등의 기밀성의 높은 데이터가 도청되는 것이 없다

        </UL>

 <P>이러한 시큐리티 보호는, 「암호화 방식군」을 사용해 지정합니다.  암호화 방식군은, 지정된 SSL 접속으로 사용되는 암호화 알고리즘의 편성입니다. 협상을 실시하려면 , 2 개의 끝이 같은 암호화 방식군을 선택해, 그 암호화 방식군이 양쪽 모두의 환경에서 사용 가능하지 않으면 안됩니다. 공통의 암호화 방식군이 없는 경우는, SSL 접속을 확립하지 못하고, 데이터를 교환할 수 없습니다.

 <P> 사용되는 암호화 방식군은, 「핸드 쉐이크」라고 불리는 협상 프로세스에 의해 확립됩니다. 핸드 쉐이크에서는, 세션의 작성 또는 참가를 합니다.  작성 또는 참가한 세션은, 무효가 될 때까지 다양한 접속을 보호합니다. 핸드 쉐이크가 완료하면(자),<em>getSession</em> 메소드를 사용해 세션 속성에 액세스 할 수 있습니다. 접속의 최초의 핸드 쉐이크는, 다음의 몇개의 방법으로 개시할 수 있습니다.  <UL>

<LI> <code>startHandshake</code> 를 호출해, 핸드 쉐이크를 명시적으로 개시한다
<LI> 이 소켓에 대해서 어플리케이션 데이터의 읽어들여 또는 기입을 실시하면, 핸드 쉐이크가 암묵적으로 개시된다
<LI> <code>getSession</code> 를 호출하면(자), 유효한 세션이 현재 존재하지 않는 경우는 세션이 설정되어 핸드 쉐이크가 암묵적으로 개시된다
 </UL>

 <P>하등의 이유로써 핸드 쉐이크가 실패했을 경우,<code>SSLSocket</code> 가 닫아 통신할 수 없게 됩니다.

 <P>암호화 방식군을 사용할 때는, 2 개의 그룹에 대해 이해할 필요가 있습니다.  <UL>

        <LI> 지원되고 있는<em></em>암호화 방식군. SSL 구현으로 지원되는 모든 암호화 방식군. 이 리스트는,<em>getSupportedCipherSuites</em> 를 사용해 보고된다

        <LI> <em>사용 가능한</em>암호화 방식군. 지원되고 있는 암호화 방식군보다 적은 것이 있다. 이 그룹은,<em>setEnabledCipherSuites</em> 메소드를 사용해 설정해,<em>getEnabledCipherSuites</em> 메소드를 사용해 조회한다. 새로운 소켓에서는, 최소한의 추천 구성을 나타내는 디폴트의 암호화 방식군이 사용 가능하게 되어 있다

        </UL>

 <P> 디폴트의 구현으로 사용 가능하게 하는 암호화 방식군에서는, 서버를 인증해, 기밀성이 보증되지 않으면 안됩니다. 서버 인증을 하지 않고 기밀성이 보증되지 않는 암호화 방식군을 선택하는 경우는, 서버 인증을 하지 않고 비공개성이 보증되지 않는 (암호화되지 않는다) 통신이 사용되는 것에 2 개의 끝이 명시적으로 동의 할 필요가 있습니다.

 <P><code>SSLSocket</code> 가 최초로 작성될 때는, 핸드 쉐이크는 행해지지 않습니다. 이 때문에, 사용하는 암호화 방식군이나 소켓 모드 (클라이언트 모드 또는 서버 모드)등의 통신 설정은, 어플리케이션으로부터 실시합니다.  다만, 그 접속을 사용해 어플리케이션 데이터를 송신할 때는, 항상 시큐리티가 보증됩니다.

 <P> 핸드 쉐이크의 완료를 전하는 이벤트 통지를 수신하는 설정으로 할 수 있습니다. 이 경우, 2 개의 추가 클래스를 이용할 필요가 있습니다. <em>HandshakeCompletedEvent</em> 객체는, 이 API 의 사용자에 의해 등록된 <em>HandshakeCompletedListener</em> 인스턴스에게 건네집니다. <code> SSLSocket</code> 는,<code>SSLSocketFactory</code> 에 의해 작성됩니다.

이 외 ,<code>SSLServerSocket</code> 로부터의 접속을 받아들였을 경우에도 작성됩니다. <code></code>

 <P>SSL 소켓의 동작에는, 클라이언트 모드 또는 서버 모드가 있습니다. 핸드 쉐이크 프로세스를 개시하는 피어, 및 각 피어로부터 송신되는 메세지는, 모드에 의해 정해집니다. 다만, 접속에는, 클라이언트와 서버가 1 개씩 필요합니다.  이 요건을 채우지 않은 경우, 핸드 쉐이크는 올바르게 행해지지 않습니다. 최초의 핸드 쉐이크가 개시되고 나서는, 협상을 다시 하는 경우여도, 클라이언트 모드와 서버 모드를 바꿀 수 없습니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/net/Socket.html" title="java.net 내의 클래스"><CODE>Socket</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLServerSocket.html" title="javax.net.ssl 안의 클래스"><CODE>SSLServerSocket</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocketFactory.html" title="javax.net.ssl 안의 클래스"><CODE>SSLSocketFactory</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#SSLSocket()">SSLSocket</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스에서만 사용됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#SSLSocket(java.net.InetAddress, int)">SSLSocket</A> </B>(<A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
          int&nbsp;port)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스에서만 사용됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#SSLSocket(java.net.InetAddress, int, java.net.InetAddress, int)">SSLSocket</A> </B>(<A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
          int&nbsp;port,
          <A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;clientAddress,
          int&nbsp;clientPort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스에서만 사용됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#SSLSocket(java.lang.String, int)">SSLSocket</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
          int&nbsp;port)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스에서만 사용됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#SSLSocket(java.lang.String, int, java.net.InetAddress, int)">SSLSocket</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
          int&nbsp;port,
          <A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;clientAddress,
          int&nbsp;clientPort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스에서만 사용됩니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#addHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)">addHandshakeCompletedListener</A> </B>(<A HREF="../../../javax/net/ssl/HandshakeCompletedListener.html" title="javax.net.ssl 안의 인터페이스">HandshakeCompletedListener</A> &nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속의 SSL 핸드 쉐이크의 완료 통지를 받기 위한 이벤트 청취자를 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getEnabledCipherSuites()">getEnabledCipherSuites</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속으로 현재 사용 가능하게 되어 있는 SSL 암호화 방식군의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getEnabledProtocols()">getEnabledProtocols</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속에 대해서 현재 사용 가능하게 되어 있는 프로토콜의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getEnableSessionCreation()">getEnableSessionCreation</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓으로 새로운 SSL 세션을 확립할 수 있는 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getNeedClientAuth()">getNeedClientAuth</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓에 클라이언트 인증이 필수인<i></i>경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/net/ssl/SSLSession.html" title="javax.net.ssl 내의 인터페이스">SSLSession</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getSession()">getSession</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속으로 사용되고 있는 SSL 세션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/net/ssl/SSLParameters.html" title="javax.net.ssl 내의 클래스">SSLParameters</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getSSLParameters()">getSSLParameters</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 SSLSocket 로 유효한 SSLParameters 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getSupportedCipherSuites()">getSupportedCipherSuites</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속으로 사용 가능하게 할 수 있는 암호화 방식군의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getSupportedProtocols()">getSupportedProtocols</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL 접속으로 사용 가능하게 할 수 있는 프로토콜의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getUseClientMode()">getUseClientMode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;핸드 쉐이크시에 클라이언트 모드를 사용하도록(듯이) 소켓이 설정되어 있는 경우는 true. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getWantClientAuth()">getWantClientAuth</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓이 클라이언트 인증을 요구<i></i>하는 경우는, true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#removeHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)">removeHandshakeCompletedListener</A> </B>(<A HREF="../../../javax/net/ssl/HandshakeCompletedListener.html" title="javax.net.ssl 안의 인터페이스">HandshakeCompletedListener</A> &nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이전에 등록된 핸드 쉐이크 완료 청취자를 삭제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#setEnabledCipherSuites(java.lang.String[])">setEnabledCipherSuites</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;suites)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속으로 사용 가능한 암호화 방식군을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#setEnabledProtocols(java.lang.String[])">setEnabledProtocols</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;protocols)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속으로 사용 가능한 프로토콜의 버젼을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#setEnableSessionCreation(boolean)">setEnableSessionCreation</A> </B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓으로 새로운 SSL 세션을 확립할 수 있을지 어떨지를 제어합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)">setNeedClientAuth</A> </B>(boolean&nbsp;need)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트 인증을 요구<i></i>하도록(듯이) 소켓을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#setSSLParameters(javax.net.ssl.SSLParameters)">setSSLParameters</A> </B>(<A HREF="../../../javax/net/ssl/SSLParameters.html" title="javax.net.ssl 안의 클래스">SSLParameters</A> &nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓에 SSLParameters 를 적용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)">setUseClientMode</A> </B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;핸드 쉐이크시, 소켓이 클라이언트 (또는 서버) 모드를 사용하도록(듯이) 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)">setWantClientAuth</A> </B>(boolean&nbsp;want)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트 인증을 요구<i></i>하도록(듯이) 소켓을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#startHandshake()">startHandshake</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속상에서 SSL 핸드 쉐이크를 개시합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.net.Socket"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.net. <A HREF="../../../java/net/Socket.html" title="java.net 안의 클래스">Socket</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/net/Socket.html#bind(java.net.SocketAddress)">bind</A> , <A HREF="../../../java/net/Socket.html#close()">close</A> , <A HREF="../../../java/net/Socket.html#connect(java.net.SocketAddress)">connect</A> , <A HREF="../../../java/net/Socket.html#connect(java.net.SocketAddress, int)">connect</A> , <A HREF="../../../java/net/Socket.html#getChannel()">getChannel</A> , <A HREF="../../../java/net/Socket.html#getInetAddress()">getInetAddress</A> , <A HREF="../../../java/net/Socket.html#getInputStream()">getInputStream</A> , <A HREF="../../../java/net/Socket.html#getKeepAlive()">getKeepAlive</A> , <A HREF="../../../java/net/Socket.html#getLocalAddress()">getLocalAddress</A> , <A HREF="../../../java/net/Socket.html#getLocalPort()">getLocalPort</A> , <A HREF="../../../java/net/Socket.html#getLocalSocketAddress()">getLocalSocketAddress</A> , <A HREF="../../../java/net/Socket.html#getOOBInline()">getOOBInline</A> , <A HREF="../../../java/net/Socket.html#getOutputStream()">getOutputStream</A> , <A HREF="../../../java/net/Socket.html#getPort()">getPort</A> , <A HREF="../../../java/net/Socket.html#getReceiveBufferSize()">getReceiveBufferSize</A> , <A HREF="../../../java/net/Socket.html#getRemoteSocketAddress()">getRemoteSocketAddress</A> , <A HREF="../../../java/net/Socket.html#getReuseAddress()">getReuseAddress</A> , <A HREF="../../../java/net/Socket.html#getSendBufferSize()">getSendBufferSize</A> , <A HREF="../../../java/net/Socket.html#getSoLinger()">getSoLinger</A> , <A HREF="../../../java/net/Socket.html#getSoTimeout()">getSoTimeout</A> , <A HREF="../../../java/net/Socket.html#getTcpNoDelay()">getTcpNoDelay</A> , <A HREF="../../../java/net/Socket.html#getTrafficClass()">getTrafficClass</A> , <A HREF="../../../java/net/Socket.html#isBound()">isBound</A> , <A HREF="../../../java/net/Socket.html#isClosed()">isClosed</A> , <A HREF="../../../java/net/Socket.html#isConnected()">isConnected</A> , <A HREF="../../../java/net/Socket.html#isInputShutdown()">isInputShutdown</A> , <A HREF="../../../java/net/Socket.html#isOutputShutdown()">isOutputShutdown</A> , <A HREF="../../../java/net/Socket.html#sendUrgentData(int)">sendUrgentData</A> , <A HREF="../../../java/net/Socket.html#setKeepAlive(boolean)">setKeepAlive</A> , <A HREF="../../../java/net/Socket.html#setOOBInline(boolean)">setOOBInline</A> , <A HREF="../../../java/net/Socket.html#setPerformancePreferences(int, int, int)">setPerformancePreferences</A> , <A HREF="../../../java/net/Socket.html#setReceiveBufferSize(int)">setReceiveBufferSize</A> , <A HREF="../../../java/net/Socket.html#setReuseAddress(boolean)">setReuseAddress</A> , <A HREF="../../../java/net/Socket.html#setSendBufferSize(int)">setSendBufferSize</A> , <A HREF="../../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)">setSocketImplFactory</A> , <A HREF="../../../java/net/Socket.html#setSoLinger(boolean, int)">setSoLinger</A> , <A HREF="../../../java/net/Socket.html#setSoTimeout(int)">setSoTimeout</A> , <A HREF="../../../java/net/Socket.html#setTcpNoDelay(boolean)">setTcpNoDelay</A> , <A HREF="../../../java/net/Socket.html#setTrafficClass(int)">setTrafficClass</A> , <A HREF="../../../java/net/Socket.html#shutdownInput()">shutdownInput</A> , <A HREF="../../../java/net/Socket.html#shutdownOutput()">shutdownOutput</A> , <A HREF="../../../java/net/Socket.html#toString()">toString</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SSLSocket()"><!-- --></A> <H3>
SSLSocket</H3>
<PRE>
protected <B>SSLSocket</B>()</PRE>
<DL>
<DD>서브 클래스에서만 사용됩니다. 초기화되어 있지 않은 미접속의 TCP 소켓을 작성합니다.
<P>
</DL>
<HR>

<A NAME="SSLSocket(java.lang.String, int)"><!-- --></A> <H3>
SSLSocket</H3>
<PRE>
protected <B>SSLSocket</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
                    int&nbsp;port)
             throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                    <A HREF="../../../java/net/UnknownHostException.html" title="java.net 안의 클래스">UnknownHostException</A> </PRE>
<DL>
<DD>서브 클래스에서만 사용됩니다. 지정된 포트의 지명된 호스트에 대한 TCP 접속을 작성합니다. 이 소켓은, SSL 클라이언트로서 동작합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>host</CODE> - 접속하는 호스트의 이름<DD><CODE>port</CODE> - 서버의 포트 번호
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../../java/net/UnknownHostException.html" title="java.net 안의 클래스">UnknownHostException</A> </CODE> - 호스트가 불명의 경우</DL>
</DL>
<HR>

<A NAME="SSLSocket(java.net.InetAddress, int)"><!-- --></A> <H3>
SSLSocket</H3>
<PRE>
protected <B>SSLSocket</B>(<A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
                    int&nbsp;port)
             throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>서브 클래스에서만 사용됩니다. 지정된 주소와 포트의 서버에 대한 TCP 접속을 작성합니다. 이 소켓은, SSL 클라이언트로서 동작합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>address</CODE> - 서버의 호스트<DD><CODE>port</CODE> - 포트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우</DL>
</DL>
<HR>

<A NAME="SSLSocket(java.lang.String, int, java.net.InetAddress, int)"><!-- --></A> <H3>
SSLSocket</H3>
<PRE>
protected <B>SSLSocket</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
                    int&nbsp;port,
                    <A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;clientAddress,
                    int&nbsp;clientPort)
             throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> ,
                    <A HREF="../../../java/net/UnknownHostException.html" title="java.net 안의 클래스">UnknownHostException</A> </PRE>
<DL>
<DD>서브 클래스에서만 사용됩니다. 지정된 포트의 지명된 호스트에 대한 SSL 접속을 작성합니다.  접속의 클라이언트측은, 지정된 주소와 포트에 바인드 됩니다. 이 소켓은, SSL 클라이언트로서 동작합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>host</CODE> - 접속하는 호스트의 이름<DD><CODE>port</CODE> - 서버의 포트 번호<DD><CODE>clientAddress</CODE> - 클라이언트의 호스트<DD><CODE>clientPort</CODE> - 클라이언트의 포트 번호
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../../java/net/UnknownHostException.html" title="java.net 안의 클래스">UnknownHostException</A> </CODE> - 호스트가 불명의 경우</DL>
</DL>
<HR>

<A NAME="SSLSocket(java.net.InetAddress, int, java.net.InetAddress, int)"><!-- --></A> <H3>
SSLSocket</H3>
<PRE>
protected <B>SSLSocket</B>(<A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
                    int&nbsp;port,
                    <A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;clientAddress,
                    int&nbsp;clientPort)
             throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>서브 클래스에서만 사용됩니다. 지정된 주소와 TCP 포트의 서버에 대한 SSL 접속을 작성합니다.  접속의 클라이언트측은, 지정된 주소와 포트에 바인드 됩니다. 이 소켓은, SSL 클라이언트로서 동작합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>address</CODE> - 서버의 호스트<DD><CODE>port</CODE> - 포트<DD><CODE>clientAddress</CODE> - 클라이언트의 호스트<DD><CODE>clientPort</CODE> - 클라이언트의 포트 번호
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getSupportedCipherSuites()"><!-- --></A> <H3>
getSupportedCipherSuites</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getSupportedCipherSuites</B>()</PRE>
<DL>
<DD>이 접속으로 사용 가능하게 할 수 있는 암호화 방식군의 이름을 돌려줍니다. 일반적으로은, 그 일부만이 디폴트로 사용 가능하게 됩니다.  디폴트의 서비스 품질 요건을 채우지 않은 암호화 방식군은, 사용 불가가 됩니다. 이러한 암호화 방식군은, 특수한 어플리케이션으로 사용됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>암호화 방식군명의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setEnabledCipherSuites(java.lang.String[])"><CODE>setEnabledCipherSuites(String [])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getEnabledCipherSuites()"><!-- --></A> <H3>
getEnabledCipherSuites</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getEnabledCipherSuites</B>()</PRE>
<DL>
<DD>이 접속으로 현재 사용 가능하게 되어 있는 SSL 암호화 방식군의 이름을 돌려줍니다. SSL 소켓이 최초로 작성되었을 때에, 사용 가능하게는 모든 암호화 방식군으로, 최소한의 서비스 품질이 보증됩니다. 환경에 따라서는, 이 값은 빈 상태(empty)의 경우도 있습니다.  &nbsp;<P>
암호화 방식군은, 비록 유효해도 사용되지 않는 것이 있습니다. 예를 들어, 피어가 암호화 방식군을 지원하지 않는 경우, 이 encode에 필요한 증명서 ( 및 비공개키)를 사용할 수가 없는 경우, 또는, 익명의 암호화 방식군이 이용 가능해도 인증이 요구되는 경우 등입니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>암호화 방식군명의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getSupportedCipherSuites()"><CODE>getSupportedCipherSuites()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setEnabledCipherSuites(java.lang.String[])"><CODE>setEnabledCipherSuites(String [])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnabledCipherSuites(java.lang.String[])"><!-- --></A> <H3>
setEnabledCipherSuites</H3>
<PRE>
public abstract void <B>setEnabledCipherSuites</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;suites)</PRE>
<DL>
<DD>이 접속으로 사용 가능한 암호화 방식군을 설정합니다.  &nbsp;<P>
<code>suites</code> 파라미터로 지정된 각 암호화 방식군은, getSupportedCipherSuites()로 리스트되어 있지 않으면 안됩니다.  그렇지 않은 경우, 메소드는 실패합니다. 이 메소드의 호출이 정상적으로 행해졌을 때,<code>suites</code> 파라미터에 리스트 된 암호화 방식군만, 사용할 수가 있습니다.  &nbsp;<P>
왜 특정의 암호화 방식군을 접속으로 사용할 수가 없는 것처럼 붙어서는,<A HREF="../../../javax/net/ssl/SSLSocket.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A>  를 참조해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>suites</CODE> - 사용 가능하게 하는 모든 암호화 방식군의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 파라미터로 지정된 암호화 방식군의 일부가 지원되지 않는 경우, 또는 파라미터가 null 의 경우. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getSupportedCipherSuites()"><CODE>getSupportedCipherSuites()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSupportedProtocols()"><!-- --></A> <H3>
getSupportedProtocols</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getSupportedProtocols</B>()</PRE>
<DL>
<DD>SSL 접속으로 사용 가능하게 할 수 있는 프로토콜의 이름을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>지원되고 있는 프로토콜의 배열</DL>
</DD>
</DL>
<HR>

<A NAME="getEnabledProtocols()"><!-- --></A> <H3>
getEnabledProtocols</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getEnabledProtocols</B>()</PRE>
<DL>
<DD>이 접속에 대해서 현재 사용 가능하게 되어 있는 프로토콜의 이름을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>프로토콜의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#setEnabledProtocols(java.lang.String[])"><CODE>setEnabledProtocols(String [])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnabledProtocols(java.lang.String[])"><!-- --></A> <H3>
setEnabledProtocols</H3>
<PRE>
public abstract void <B>setEnabledProtocols</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;protocols)</PRE>
<DL>
<DD>이 접속으로 사용 가능한 프로토콜의 버젼을 설정합니다.  &nbsp;<P>
프로토콜은,<code>getSupportedProtocols()</code> 에 의해, 지원 대상으로 해 리스트되어 있지 않으면 안됩니다. 이 메소드의 호출이 정상적으로 행해졌을 때,<code>protocols</code> 파라미터에 리스트 된 프로토콜만, 사용할 수가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>protocols</CODE> - 사용 가능하게 하는 모든 프로토콜의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 파라미터로 지정된 프로토콜의 일부가 지원되지 않는 경우, 또는 파라미터가 null 의 경우. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getEnabledProtocols()"><CODE>getEnabledProtocols()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSession()"><!-- --></A> <H3>
getSession</H3>
<PRE>
public abstract <A HREF="../../../javax/net/ssl/SSLSession.html" title="javax.net.ssl 내의 인터페이스">SSLSession</A>  <B>getSession</B>()</PRE>
<DL>
<DD>이 접속으로 사용되고 있는 SSL 세션을 돌려줍니다. SSL 세션은 유효기간이 길고, 사용자에 따라서는 로그인 세션 전체에 대응하는 일도 있습니다. 세션에는, 세션내의 모든 접속으로 사용되는 암호화 방식군과 세션의 클라이언트와 서버의 식별 정보가 지정되고 있습니다.  &nbsp;<P>
이 메소드는, 필요에 따라서 초기 핸드 쉐이크를 개시해, 핸드 쉐이크가 확립했을 때에 블록을 해제합니다.  &nbsp;<P>
초기 핸드 쉐이크로 에러가 발생하면(자), 무효인 세션 객체가 돌려주어져 「SSL_NULL_WITH_NULL_NULL」라고 하는 무효인 암호화 방식군이 보고됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD><code>SSLSession</code></DL>
</DD>
</DL>
<HR>

<A NAME="addHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)"><!-- --></A> <H3>
addHandshakeCompletedListener</H3>
<PRE>
public abstract void <B>addHandshakeCompletedListener</B>(<A HREF="../../../javax/net/ssl/HandshakeCompletedListener.html" title="javax.net.ssl 안의 인터페이스">HandshakeCompletedListener</A> &nbsp;listener)</PRE>
<DL>
<DD>이 접속의 SSL 핸드 쉐이크의 완료 통지를 받기 위한 이벤트 청취자를 등록합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listener</CODE> - HandShakeCompleted 이벤트 청취자
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 인수가 null 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#startHandshake()"><CODE>startHandshake()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#removeHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)"><CODE>removeHandshakeCompletedListener(HandshakeCompletedListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="removeHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)"><!-- --></A> <H3>
removeHandshakeCompletedListener</H3>
<PRE>
public abstract void <B>removeHandshakeCompletedListener</B>(<A HREF="../../../javax/net/ssl/HandshakeCompletedListener.html" title="javax.net.ssl 안의 인터페이스">HandshakeCompletedListener</A> &nbsp;listener)</PRE>
<DL>
<DD>이전에 등록된 핸드 쉐이크 완료 청취자를 삭제합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listener</CODE> - HandShakeCompleted 이벤트 청취자
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 청취자가 등록되지 않은 경우, 또는 인수가 null 의 경우. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#addHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)"><CODE>addHandshakeCompletedListener(HandshakeCompletedListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="startHandshake()"><!-- --></A> <H3>
startHandshake</H3>
<PRE>
public abstract void <B>startHandshake</B>()
                             throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 접속상에서 SSL 핸드 쉐이크를 개시합니다. 예를 들어, 새로운 암호화열쇠를 사용할 때, 암호화 방식군을 변경할 때, 새로운 세션을 개시할 때 등에, SSL 핸드 쉐이크를 개시합니다. 완전한 재인식증을 강제적으로 실행하려면 , 핸드 쉐이크를 개시하기 전에, 현재의 세션을 무효로 할 필요가 있습니다.

 <P> 벌써 접속상에 송신된 데이터는, 이 핸드 쉐이크가 완료할 때까지는 그대로의 상태를 유지해, 핸드 쉐이크가 완료하면(자) 이벤트로부터 신호를 받습니다.

이 메소드는, 접속상의 최초의 핸드 쉐이크와 동시에 개시되어 핸드 쉐이크의 협상이 완료하면(자) 종료합니다. 기존의 소켓상에서의 복수의 핸드 쉐이크를 지원하지 않는 프로토콜은, IOException 를 throw 합니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 네트워크 레벨의 에러<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#addHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)"><CODE>addHandshakeCompletedListener(HandshakeCompletedListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setUseClientMode(boolean)"><!-- --></A> <H3>
setUseClientMode</H3>
<PRE>
public abstract void <B>setUseClientMode</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>핸드 쉐이크시, 소켓이 클라이언트 (또는 서버) 모드를 사용하도록(듯이) 설정합니다.  &nbsp;<P>
이 메소드는, 모든 핸드 쉐이크의 전에 호출할 필요가 있습니다. 일단 핸드 쉐이크가 개시되면(자), 이 소켓의 수명이 다할 때까지, 현재의 모드를 리셋 할 수 없습니다.  &nbsp;<P>
일반적으로, 서버는 자신을 인증합니다만, 클라이언트는 반드시 그렇다고는 할 수 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>mode</CODE> - 핸드 쉐이크를 클라이언트 모드로 개시하는 경우는 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 최초의 핸드 쉐이크가 개시되고 나서 모드를 변경하려고 했을 경우. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getUseClientMode()"><CODE>getUseClientMode()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getUseClientMode()"><!-- --></A> <H3>
getUseClientMode</H3>
<PRE>
public abstract boolean <B>getUseClientMode</B>()</PRE>
<DL>
<DD>핸드 쉐이크시에 클라이언트 모드를 사용하도록(듯이) 소켓이 설정되어 있는 경우는 true.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>클라이언트 모드로 핸드 쉐이크를 실시하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setNeedClientAuth(boolean)"><!-- --></A> <H3>
setNeedClientAuth</H3>
<PRE>
public abstract void <B>setNeedClientAuth</B>(boolean&nbsp;need)</PRE>
<DL>
<DD>클라이언트 인증을 요구<i></i>하도록(듯이) 소켓을 설정합니다. 이 옵션은, 서버 모드의 소켓만으로 사용합니다.  &nbsp;<P>
소켓의 클라이언트 인증 설정은, 다음의 어느 쪽인가에 됩니다.
 <ul>
<li> 클라이언트 인증을 필수로 한다
<li> 클라이언트 인증을 요구한다
<li> 클라이언트 인증을 불필요하게 한다
 </ul>
 <P>
<A HREF="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A>  와 달리, 이 옵션이 설정되어 있어, 한편 클라이언트 인증 정보가 제공되지 않는 경우는, 협상이 정지해, 접속이 절단 됩니다. <i></i> &nbsp;<P>
이 메소드를 호출하면(자), 지금까지 이 메소드 또는 <A HREF="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A>  에 의해 설정된 내용이 오버라이드(override) 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>need</CODE> - 클라이언트 인증이 필수의 경우는 true, 클라이언트 인증이 불필요한 경우는 false. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getNeedClientAuth()"><CODE>getNeedClientAuth()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#getWantClientAuth()"><CODE>getWantClientAuth()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getNeedClientAuth()"><!-- --></A> <H3>
getNeedClientAuth</H3>
<PRE>
public abstract boolean <B>getNeedClientAuth</B>()</PRE>
<DL>
<DD>이 소켓에 클라이언트 인증이 필수인<i></i>경우는 true 를 돌려줍니다. 이 옵션은, 서버 모드의 소켓만으로 사용합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>클라이언트 인증이 필수의 경우는 true, 클라이언트 인증이 불필요한 경우는 false. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#getWantClientAuth()"><CODE>getWantClientAuth()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setWantClientAuth(boolean)"><!-- --></A> <H3>
setWantClientAuth</H3>
<PRE>
public abstract void <B>setWantClientAuth</B>(boolean&nbsp;want)</PRE>
<DL>
<DD>클라이언트 인증을 요구<i></i>하도록(듯이) 소켓을 설정합니다. 이 옵션은, 서버 모드의 소켓만으로 사용합니다.  &nbsp;<P>
소켓의 클라이언트 인증 설정은, 다음의 어느 쪽인가에 됩니다.
 <ul>
<li> 클라이언트 인증을 필수로 한다
<li> 클라이언트 인증을 요구한다
<li> 클라이언트 인증을 불필요하게 한다
 </ul>
 <P>
<A HREF="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>  와 달리, 이 옵션이 설정되어 있어, 한편 클라이언트 인증 정보가 제공되지 않는 경우에서도, 협상은 속행됩니다. <i></i> &nbsp;<P>
이 메소드를 호출하면(자), 지금까지 이 메소드 또는 <A HREF="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>  에 의해 설정된 내용이 오버라이드(override) 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>want</CODE> - 클라이언트 인증이 요구되었을 경우는 true, 클라이언트 인증이 불필요한 경우는 false. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getWantClientAuth()"><CODE>getWantClientAuth()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#getNeedClientAuth()"><CODE>getNeedClientAuth()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getWantClientAuth()"><!-- --></A> <H3>
getWantClientAuth</H3>
<PRE>
public abstract boolean <B>getWantClientAuth</B>()</PRE>
<DL>
<DD>이 소켓이 클라이언트 인증을 요구<i></i>하는 경우는, true 를 돌려줍니다. 이 옵션은, 서버 모드의 소켓만으로 사용합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>클라이언트 인증이 요구되었을 경우는 true, 클라이언트 인증이 불필요한 경우는 false. <DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#getNeedClientAuth()"><CODE>getNeedClientAuth()</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A> , 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnableSessionCreation(boolean)"><!-- --></A> <H3>
setEnableSessionCreation</H3>
<PRE>
public abstract void <B>setEnableSessionCreation</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>이 소켓으로 새로운 SSL 세션을 확립할 수 있을지 어떨지를 제어합니다. 세션을 작성하지 못하고, 재개할 수 있는 기존의 세션이 없는 경우, 핸드 쉐이크는 성공하지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>flag</CODE> - 세션을 작성할 수 있는 경우는 true (디폴트). 기존의 세션을 재개하는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getEnableSessionCreation()"><CODE>getEnableSessionCreation()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getEnableSessionCreation()"><!-- --></A> <H3>
getEnableSessionCreation</H3>
<PRE>
public abstract boolean <B>getEnableSessionCreation</B>()</PRE>
<DL>
<DD>이 소켓으로 새로운 SSL 세션을 확립할 수 있는 경우는 true 를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>세션을 작성할 수 있는 경우는 true (디폴트). 기존의 세션을 재개하는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#setEnableSessionCreation(boolean)"><CODE>setEnableSessionCreation(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSSLParameters()"><!-- --></A> <H3>
getSSLParameters</H3>
<PRE>
public <A HREF="../../../javax/net/ssl/SSLParameters.html" title="javax.net.ssl 내의 클래스">SSLParameters</A>  <B>getSSLParameters</B>()</PRE>
<DL>
<DD>이 SSLSocket 로 유효한 SSLParameters 를 돌려줍니다. 반환되는 SSLParameters 의 암호화 방식군과 프로토콜은, 항상 null 이외입니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 SSLSocket 로 유효한 SSLParameters. <DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSSLParameters(javax.net.ssl.SSLParameters)"><!-- --></A> <H3>
setSSLParameters</H3>
<PRE>
public void <B>setSSLParameters</B>(<A HREF="../../../javax/net/ssl/SSLParameters.html" title="javax.net.ssl 안의 클래스">SSLParameters</A> &nbsp;params)</PRE>
<DL>
<DD>이 소켓에 SSLParameters 를 적용합니다.

 <p>이것은 다음 일을 의미합니다.
 <ul>
<li><code>params.getCipherSuites()</code> 가 null 이외의 경우, 그 값을 사용해 <code>setEnabledCipherSuites()</code> 가 불려 간다
<li><code>params.getProtocols()</code> 가 null 이외의 경우, 그 값을 사용해 <code>setEnabledProtocols()</code> 가 불려 간다
<li><code>params.getNeedClientAuth()</code> 또는 <code>params.getWantClientAuth()</code> 가 <code>true</code> 를 돌려주는 경우, 각각 <code>setNeedClientAuth(true)</code> 또는 <code>setWantClientAuth(true)</code> 가 불려 간다. 그렇지 않은 경우,<code>setWantClientAuth(false)</code> 가 불려 간다.
 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>params</CODE> - 파라미터
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - setEnabledCipherSuites() 또는 the setEnabledProtocols()의 호출해에 실패했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SSLSocket.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/net/ssl/SSLSessionContext.html" title="javax.net.ssl 내의 인터페이스"><B>전의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/net/ssl/SSLSocketFactory.html" title="javax.net.ssl 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/net/ssl/SSLSocket.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="SSLSocket.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
