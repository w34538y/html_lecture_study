<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:47:16 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
javax.sql.rowset.spi (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="javax.sql.rowset.spi (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../javax/sql/rowset/serial/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../../javax/swing/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?javax/sql/rowset/spi/package-summary.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
패키지 javax.sql.rowset.spi
</H2>
서드 파티의 벤더가 동기 프로바이더의 구현으로 사용해야 하는 표준 클래스 및 인터페이스입니다.
<P>
<B>참조처:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>설명</B></A> 
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>인터페이스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/SyncResolver.html" title="javax.sql.rowset.spi 안의 인터페이스">SyncResolver</A> </B></TD>
<TD>어플리케이션이, 수동의 의지결정 트리를 사용해 동기 경합이 발생했을 때의 대처 방법을 결정할 수 있도록(듯이) 하는 시스템를 정의합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/TransactionalWriter.html" title="javax.sql.rowset.spi 안의 인터페이스">TransactionalWriter</A> </B></TD>
<TD>보다 정밀한 트랜잭션(transaction) 제어를 할 수 있도록(듯이), 표준 <code>SyncProvider</code> abstract 클래스의 확장을 촉진하는 특별한 인터페이스입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/XmlReader.html" title="javax.sql.rowset.spi 안의 인터페이스">XmlReader</A> </B></TD>
<TD><code>SyncProvider</code> abstract 클래스의 확장을 촉진하는, XML 지향의 동기 제공자용의 특별한 인터페이스입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/XmlWriter.html" title="javax.sql.rowset.spi 안의 인터페이스">XmlWriter</A> </B></TD>
<TD><code>SyncProvider</code> abstract 클래스의 확장을 촉진하는, XML 지향의 동기 제공자용의 특별한 인터페이스입니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/SyncFactory.html" title="javax.sql.rowset.spi 안의 클래스">SyncFactory</A> </B></TD>
<TD>미접속의 <code>RowSet</code>객체에 의해 사용되는 <code>SyncProvider</code>인스턴스를 생성하는 서비스 프로바이더 인터페이스 (Service Provider Interface, SPI) 기구입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/SyncProvider.html" title="javax.sql.rowset.spi 안의 클래스">SyncProvider</A> </B></TD>
<TD>미접속의 <code>RowSet</code> 객체의 읽어내/기입 기능을 제공하는  동기기구입니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>예외의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/SyncFactoryException.html" title="javax.sql.rowset.spi 안의 클래스">SyncFactoryException</A> </B></TD>
<TD><code>SyncFactory</code> 기구의 에러를 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 안의 클래스">SyncProviderException</A> </B></TD>
<TD><code>SyncProvider</code> 기구로 발생한 에러를 나타냅니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A> <H2>
패키지 javax.sql.rowset.spi 의 설명
</H2>

<P>
서드 파티의 벤더가 동기 프로바이더의 구현으로 사용해야 하는 표준 클래스 및 인터페이스입니다. 이러한 클래스 및 인터페이스를 정리해, 「서비스 프로바이더 인터페이스 (Service Provider Interface, SPI)」라고 부릅니다. 사용 가능한 <code>SyncProvider</code> 구현의 일람이 기재된 JDBC Web 페이지에 벤더 고유의 구현을 추가해, 개발자에게 구현을 공개하고 싶은 경우는,<code>jdbc@sun.com</code> 까지 전자 메일에서 연락해 주십시오. <code>RowSet</code> 객체로 구현을 사용할 수 있도록(듯이) 하려면 , 그 구현을 <code>SyncFactory</code> 싱글 톤에 등록할 필요가 있습니다. 등록 순서와 명명 규칙의 자세한 설명에 대해서는,<code>SyncProvider</code> 의 클래스 코멘트를 참조해 주세요.
<P>
<h2>목차</h2>
<ul>
<li><a href="#pkgspec">1.0 패키지의 스펙</a> 
<li><a href="#arch">2.0 서비스 프로바이더 아키텍쳐(architecture)</a> 
<li><a href="#impl">3.0 구현 가이드</a> 
<li><a href="#resolving">4.0 동기 경합의 해결</a> 
<li><a href="#relspec">5.0 관련 스펙</a> 
<li><a href="#reldocs">6.0 관련 항목</a> 
</ul>

<h3><a name="pkgspec">1.0 패키지의 스펙</h3>
<P>
<code>javax.sql.rowset.spi</code> 패키지는, 다음의 클래스 및 인터페이스로 구성되어 있습니다.
<UL>
<LI><code>SyncFactory</code>
<LI><code>SyncProvider</code>
<LI><code>SyncFactoryException</code>
<LI><code>SyncProviderException</code>
<LI><code>SyncResolver</code>
<LI><code>XmlReader</code>
<LI><code>XmlWriter</code>
<LI><code>TransactionalWriter</code>
</UL>
이 SPI 에는,<code>javax.sql</code> 패키지내의 다음의 인터페이스도 포함되어 있습니다.
<UL>
<LI><code>RowSetReader</code>
<LI><code>RowSetWriter</code>
</UL>
<P>
<code>SyncProvider</code> 구현은, 미접속의 <code>RowSet</code> 객체가 데이터를 읽어들여, 변경을 더한 뒤 부하의 데이터 소스에 재차 기입할 수 있도록(듯이) 하는 수단을 제공합니다. 리더 객체 (<code>RowSetReader</code> 또는 <code>XMLReader</code>)는,<code>CachedRowSet</code> 의 <code>execute</code> 또는 <code>populate</code> 메소드가 불려 가면(자),<code>RowSet</code> 객체에 데이터를 읽어들입니다. 라이터 객체 (<code>RowSetWriter</code> 또는 <code>XMLWriter</code>)는,<code>CachedRowSet</code> 의 <code>acceptChanges</code> 메소드가 불려 가면(자), 부하의 데이터 소스로 변경된 데이터를 기입합니다.
<P>
<code>RowSet</code> 객체의 변경 내용을 데이터 소스에 기입하는 처리를 「동기」라고 부릅니다. <i></i>RowSet</code> 객체의 라이터가 사용하는 동기의 레벨은,<code>RowSet</code> 객체의 <code>SyncProvider</code> 구현에 의해 결정됩니다. 동기의 다양한 레벨을 「그레이드」라고 부릅니다. <i></i>
<P>
저그레이드의 동기는, 경합이 전혀 존재하지 않는지, 존재했다고 해도 적는다고 하는 오프티미스틱 (낙관적)인 상정한 기초로 행해집니다.  이 동기 모델을 「오프티미스틱 병행 모델」이라고 부릅니다. <i></i><code>RowSet</code> 객체내에서 변경된 데이터가 데이터 소스내에서도 변경되고 있는 경우는, 경합이 존재합니다. 오프티미스틱 병행 모델을 사용한다고 하는 것은, 경합이 존재하는 경우, 데이터 소스 또는 <code>RowSet</code> 객체에의 변경이 없어진다고 하는 것을 의미합니다.
<P>
이것에 대해서, 고그레이드의 동기 모델을 「염세적인 (비관적) 병행 모델」이라고 부릅니다.  이 모델에서는, 다른 사용자가 데이터 소스에 액세스 해 변경을 더할 가능성이 있다고 하는 상정한 기초로 동기 처리를 합니다. <i></i>염세적인 병행 모델에서는, 경합의 발생을 억제하기 (위해)때문에, 다양한 락 레벨이 설정됩니다.
<P>
최저 레벨의 동기로는,<code>RowSet</code> 객체에의 전변경 내용이, 단순하게 부하의 데이터 소스에 기입해집니다. 라이터는 경합의 체크를 실시하지 않습니다. 경합이 존재해, 데이터 소스의 값이 덧쓰기되었을 경우, 그 외의 사용자에 의한 데이터 소스의 변경은 없어집니다.  
<P>
<code>RIXMLProvider</code> 구현은, 최저 레벨의 동기를 사용해,<code>RowSet</code> 의 변경을 단순하게 데이터 소스에 기입합니다.  이것은, 일반적으로, XML 데이터 소스가, 데이터의 무결성을 확보하기 위한 트랜잭션(transaction) 기술을 지원하고 있지 않기 때문입니다. 그러나, XML 베이스의 동기를 가능하게 하는 수단을 제공하려고 하고 있는 표준화 그룹도 존재합니다. 상세한 것에 대하여는, 이하를 참조해 주세요.
<PRE>
     <a href="http://www.syncml.org">http://www.syncml.org</a> 
</PRE>
<P>
1 개(살)상의 레벨에서는, 라이터는 경합이 존재할지 어떨지를 체크해, 존재하는 경우는 데이터 소스에 아무것도 기입하지 않습니다. 이 동기 레벨에는,<code>RowSet</code> 객체가 데이터를 취득한 뒤 다른 사용자가 데이터 소스내의 대응하는 데이터로 변경을 더했을 경우,<code>RowSet</code> 객체의 변경이 없어진다고 하는 문제가 있습니다. RIOptimisticProvider</code> 구현은, 이 동기 레벨을 사용합니다.
<P>
최고 레벨의 동기 (염세적인 병행 모델의 동기)로는, 라이터는, 경합을 피하기 위해서(때문에) 락을 설정합니다. 락의 설정이라고 해도, 단일의 행의 락으로부터, 테이블 또는 데이터 소스 전체의 락까지, 다양한 레벨이 있습니다. 따라서, 동기 레벨은, 복수의 사용자에 의한 데이터 소스에의 동시 액세스에 중점을 둘까하고, 라이터가 <code>RowSet</code> 객체내의 데이터와 데이터 소스를 동기 하게 하는 것에 중점을 둘까하고의 트레이드 오프가 됩니다.
<P>
반대로, 라이터의 기능을 유효하게 하면, 동시 액세스 기능은 무효가 됩니다.  미접속의 모든 <code>RowSet</code> 객체 (<code>CachedRowSet</code>,<code>FilteredRowSet</code>,<code>JoinRowSet</code>, 및 <code>WebRowSet</code> 객체)는,<code>SyncFactory</code> 기구로부터 <code>SyncProvider</code> 객체를 취득할 필요가 있습니다.   
<P>
레퍼런스 구현 (RI)은, 다음의 2 살의 동기 프로바이더를 제공합니다.
        <UL>
<LI><b><tt>RIOptimisticProvider</tt></b> <br> 프로바이더 구현이 지정되어 있지 않을 때,<code>SyncFactory</code> 인스턴스로부터 미접속의 <code>RowSet</code> 객체에 제공되는 디폴트의 프로바이더. <BR>데이타베이스내의 같은 데이터에 액세스 하는 사용자 사이에 경합이 거의 존재하지 않으면 상정한, 오프티미스틱 병행 모델을 사용합니다. 락은 사용합니다만, 그 대신에,<code>RowSet</code> 객체와 데이터 소스의 동기를 잡기 전에, 경합이 존재할지 어떨지의 체크를 실시합니다. 경합이 존재하는 경우는, 아무것도 실시하지 않습니다. 즉,<code>RowSet</code> 객체의 변경은, 데이터 소스에서는 보관 유지되지 않습니다.
<LI><B><tt>RIXMLProvider</tt></B> <BR> <code>WebRowSet</code> 객체, 즉 XML 형식에서 읽어내 또는 기입해 가능한 행 세트로 사용할 수 있는 동기 프로바이더. <code>RIXMLProvider</code> 구현은 경합의 체크를 일절 실시하지 않고,<code>WebRowSet</code> 객체의 갱신 데이터를 부하의 데이터 소스에 단순하게 기입합니다. <code>WebRowSet</code> 객체는, XML 데이터의 처리시에, 이 프로바이더를 사용합니다.
        </UL>

이러한 <code>SyncProvider</code> 구현은, 레퍼런스 구현에 번들 되고 있기 (위해)때문에,<code>RowSet</code> 구현은 이러한 구현을 언제라도 이용할 수 있습니다. <code>SyncProvider</code>구현은,<code>SyncFactory</code> 싱글 톤에 등록되면(자), 이용 가능한 상태가 됩니다. <code>RowSet</code>  객체로부터 프로바이더 (생성자 내로 지정, 또는 <code>CachedRowSet</code> 의 <code>setSyncProvider</code>메소드의 인수로서 지정)의 요구를 받아들이면(자),<code>SyncFactory</code> 싱글 톤은, 요구된 프로바이더가 등록되어 있는지 어떤지를 확인합니다. 등록되어 있는 경우는,<code></code>그 인스턴스를 작성해, 요구원의 <code>RowSet</code> 객체에 건네줍니다. 지정된 <code>SyncProvider</code>구현이 등록되지 않은 경우는,<code>SyncFactory</code> 싱글 톤은 <code>SyncFactoryException</code> 객체를 throw 합니다. 프로바이더가 지정되어 있지 않은 경우는, 디폴트 프로바이더 구현 <code>RIOptimisticProvider</code> 를 작성해, 요구원의 <code>RowSet</code> 객체에 건네줍니다. <code></code>

<P>
<code>WebRowSet</code> 객체의 생성자 내에 프로바이더가 지정되어 있지 않은 경우,<code>SyncFactory</code> 는,<code>RIOptimisticProvider</code> 의 인스턴스를 건네줍니다. 다만, 구현에 의해,<code>WebRowSet</code> 의 생성자 이 프로바이더로서 <code>RIXMLProvider</code> 를 설정하는 경우,<code>RowSet</code> 객체의 읽기 및 기입은 XML 형식에서 행해집니다.
<P>
상세한 것에 대하여는,<a href="SyncProvider.html">SyncProvider</a>  클래스 스펙을 참조해 주세요.  
<p>
벤더는,<tt>SyncProvider</tt> 구현과 임의의 동기 레벨을 개발해,<code>RowSet</code> 객체에  동기기구를 선택시킬 수가 있습니다. 또,<code>jdbc@sun.com</code> 로 Sun Microsystems 에 구현의 완전 수식 클래스명을 등록하는 것으로써, 그 구현을 공개할 수도 있습니다. 이 처리의 상세한 것에 대하여는, 이하로 설명합니다.  
<P>

<a name="arch"><h3>2.0 서비스 프로바이더 인터페이스 아키텍쳐(architecture)</h3>
<ul>
<b>2.1 개요</b> 
<p>
서비스 프로바이더 인터페이스는,<code>SyncProvider</code> 구현을 등록한 뒤, 필요한 때에 생성할 수가 있는, 플러그 인 가능한 기구를 제공합니다. <code>SyncFactory</code> 의 지연 참조 기구는, 미접속의 <code>RowSet</code> 객체로부터 요구가 있을 때까지 인스턴스의 생성을 늦추는 것으로, 자원의 쓸데없는 소비를 제한합니다. <code>SyncFactory</code> 클래스는, 특정의 <code>SyncProvider</code> 구현에 의해 제공되는 로그 옵션과 스트림을 구성하기 위한 표준 API 도 제공합니다. <b></b> 
<p>
<b>2.2 <code>SyncFactory</code> 에의 등록</b> 
<p>
미접속의 <code>RowSet</code> 객체가 서드 파티의 <code>SyncProvider</code> 구현을 취득해, 그 <code>javax.sql.RowSetReader</code> 구현과 <code>javax.sql.RowSetWriter</code> 구현을 사용할 수 있도록(듯이) 하려면 , 이 구현을 <code>SyncFactory</code> 에 등록할 필요가 있습니다. 모든 <code>SyncProvider</code> 구현은, 다음의 등록 기구를 이용할 수 있습니다.
<ul>
<li><b>시스템 프로퍼티</b> - 커멘드행으로 설정하는 프로퍼티. 이러한 프로퍼티은 실행시로 설정되어 Java 어플리케이션의 호출에 의해 시스템 전체에 적용된다. 상세한 것에 대하여는,<a href="#reldocs">「관련 항목」</a>을 참조 
<p>
<li><b>프로퍼티 파일</b> - 표준 프로퍼티 파일로 지정하는 프로퍼티. 시스템 프로퍼티을 이용하는지, 플랫폼의 실행시에 검출된 표준 프로퍼티 파일을 변경하는 것에 의해 지정한다. 이 테크놀러지의 레퍼런스 구현에는 표준 프로퍼티 파일이 1 개 포함된다.  이 표준 프로퍼티 파일을 편집하는 것으로,<code>SyncProvider</code> 객체를 추가할 수 있다 
<p> 
<li><b>JNDI 문맥</b> - 사용 가능한 프로바이더는 JNDI 문맥에 등록할 수 있다. SyncFactory</tt> 은, 문맥에 바인드 된 <tt>SyncProvider</tt> 객체를 로드해, 팩토리에 등록하려고 한다. 이 기구를 정상적으로 기능시키기 위해서(때문에)는, 문맥을 <code>SyncFactory</code> 에 건네줄 필요가 있다
</ul>
<p>
프로퍼티 파일내에 시스템 프로퍼티이나 프로퍼티을 지정하는 방법, JNDI 문맥을 구성하는 방법의 상세한 것에 대하여는,<a href="SyncFactory.html"><code>SyncFactory</code></a>  클래스의 설명을 참조해 주세요.  
<p>
<b>2.3 SyncFactory 프로바이더 인스턴스 생성 정책</b> 
<p>
프로바이더가 정상적으로 등록되어 있으면,<code>SyncFactory</code> 은 요구된 <code>SyncProvider</code> 객체를 생성합니다. 미접속의 <code>RowSet</code> 객체가 특정의 <code>SyncProvider</code> 구현으로 초기화되었을 때, 또는 그 외의 <code>SyncProvider</code> 객체로 실행시에 복구 이루어졌을 때는, 다음의 정책가 시행됩니다.
<ul>
<li> <code>SyncProvider</code> 객체가 지정되어<code>SyncFactory</code> 에 프로바이더의 참조가 포함되지 않는 경우,<code>SyncFactoryException</code> 가 throw 된다 
<p>
<li> <code>SyncProvider</code> 객체가 지정되어<code>SyncFactory</code> 에 프로바이더의 참조가 포함되는 경우, 요구된 프로바이더가 제공된다 
<p>
<li> <code>SyncProvider</code> 객체가 지정되어 있지 않은 경우, 레퍼런스 구현 프로바이더 <code>RIOptimisticProvider</code> 가 제공된다
</ul>
<p>
이러한 정책의 상세한 것에 대하여는,<a href="SyncFactory.html"><code>SyncFactory</code></a>  클래스의 설명을 참조해 주세요.
</ul>

<li><a name="impl"><h3>3.0 SyncProvider 구현 가이드</h3>
<ul>
<b>3.1 요건</b> 
<p>
<code>SyncFactory</code> 에 완전하게 플러그 인 가능한 <code>SyncProvider</code> 준거 구현은, 모든 추상 메소드를 확장해,<a href="SyncProvider.html"><code>SyncProvider</code></a>  클래스에 구현할<b>필요가 있습니다</b>. 개개의 구현은,<code>SyncProvider</code> 클래스 정의내의 그레이드, 락, 갱신 가능 뷰의 기능을 확정할<b>필요가 있습니다</b>. 1 개(살) 이상의 <code>SyncProvider</code> 기술 기준이 지원되고 있을<b>필요가 있습니다</b>. 벤더 구현은, 그레이드, 락, 갱신 가능 뷰의 기능의 범위를 나타내는 것이 요구됩니다.  
<p>
게다가<code>SyncProvider</code> 명명 규칙에 준거할<b>필요가 있습니다</b>.  이 명명 규칙의 상세한 것에 대하여는,<a href="SyncProvider.html"><code>SyncProvider</code></a>  클래스의 설명을 참조해 주세요.  
<p>
<b>3.2 그레이드</b> 
<p>
JSR 114 에는,<code>SyncProvider</code> 객체로부터 미접속의 <code>RowSet</code> 객체에 제공되는 동기의 품질을 나타내는, 일련의 그레이드가 정의되고 있습니다. 이러한 그레이드는, 서비스 품질의 낮은 순서에 일람 됩니다.
<ul>
<li><b>GRADE_NONE</b> - 원래의 데이터 소스와의 동기는 행해지지 않는다. 이 그레이드를 돌려주는 <code>SyncProvider</code> 구현은,<code>RowSet</code> 객체내의 변경이 끝난 데이터를 부하의 데이터 소스에 덧쓰기할 뿐. 원의 값과 현재의 값을 비교해 경합이 있을지 어떨지를 확인하는 처리는 행해지지 않는다. <code>RIXMLProvider</code> 는, 이 그레이드로 구현되고 있다 
<p>
<li><b>GRADE_CHECK_MODIFIED_AT_COMMIT</b> - 저그레이드의 오프티미스틱 병행 동기. 이 그레이드를 돌려주는 <code>SyncProvider</code> 구현은, 전회의 동기부터 이번 동기까지 변경된 은행내에 경합이 없는가 체크를 실시한다. 원래의 데이터 소스로 변경이 더해진 뒤, 그 내용이 미접속의 <code>RowSet</code> 객체에 반영될 것은 없다. 경합이 존재하지 않는 경우,<code>RowSet</code> 객체내의 변경은 데이터 소스에 기입해진다. 경합이 존재하는 경우, 변경 내용은 기입해지지 않다. <code>RIOptimisticProvider</code> 구현은, 이 그레이드를 사용한다 
<p>
<li><b>GRADE_CHECK_ALL_AT_COMMIT</b> - 고그레이드의 오프티미스틱 병행 동기. 이 그레이드를 돌려주는 <code>SyncProvider</code> 구현은, 미접속의 <code>RowSet</code> 객체내의 모든 행을, 미변경의 것도 포함해 체크한다. 이것에 의해, 동기가 정상적으로 완료했을 때, 부하의 데이터 소스내의 모든 행의 변경이 미접속의 <code>RowSet</code> 객체에 반영된다 
<p>
<li><b>GRADE_LOCK_WHEN_MODIFIED</b> - 염세적인 병행 동기. 이 그레이드를 돌려주는 <code>SyncProvider</code> 구현은,<code>RowSet</code> 객체내의 행이 변경되었을 때, 데이터 소스내의 같은 데이터가 다른 프로세스에 의해 변경되는 것이 없게, 원래의 데이터 소스내의 행을 잠근다 
<p>
<li><b>GRADE_LOCK_WHEN_LOADED</b> - 고그레이드의 염세적인 병행 동기. 이 그레이드를 돌려주는 <code>SyncProvider</code> 구현은,<code>RowSet</code> 객체의 이식에 사용된 원의 쿼리의 영향을 받는 뷰와 테이블 전체, 또는 그 어느쪽이든을 잠근다
</ul>
<p>
<b>3.3 락</b> 
<p>
JSR 114 에는,<code>RowSet</code> 객체의 부하의 데이터 소스에 락이 적용되고 있는지 어떤지, 적용되고 있는 경우는 어느 구조체에 적용되고 있는지를 나타내는 정수세트가 정의되고 있습니다. 이러한 락은, 데이터 소스로부터 <code>RowSet</code> 객체가 절단 될 때까지, 데이터 소스상에 보관 유지됩니다.
<P>
이러한 정수는, 그레이드 정수를 보완하는 정수입니다. 대부분의 그레이드의 디폴트 설정은,<code>RowSet</code> 객체를 데이터 소스로부터 절단 할 때 데이터 소스의 락도 파기하는 것을 요구합니다. 그레이드 <code>GRADE_LOCK_WHEN_MODIFIED</code> 및 <code>GRADE_LOCK_WHEN_LOADED</code> 에서는, 미접속의 <code>RowSet</code> 객체로 락의 단계를 세세하게 제어할 수 있습니다.
<ul>
<li><b>DATASOURCE_NO_LOCK</b> - 락은 원래의 데이터 소스상에 보관 유지되지 않는다. <code>RowSet</code> 객체의 관리하에 있는 것을 제외하는 모든 <code>SyncProvider</code> 구현의 디폴트의 락 설정입니다.  
<p>
<li><b>DATASOURCE_ROW_LOCK</b> - 락은,<code>RowSet</code> 객체의 이식에 사용된 원의 SQL 쿼리의 영향을 받는 행에게만 보관 유지된다 
<p> 
<li><b>DATASOURCE_TABLE_LOCK</b> - 락은,<code>RowSet</code> 객체의 이식에 사용된 쿼리의 영향을 받는 모든 테이블상에서 보관 유지된다 
<p>
<li><b>DATASOURCE_DB_LOCK</b> - 락은,<code>RowSet</code> 객체에 의해 사용되는 데이터 소스 전체로 보관 유지된다
</ul>
<p>
<b>3.4 갱신 가능 뷰</b> 
<p>
<code>RowSet</code> 객체에는, SQL <code>VIEW</code> 의 데이터를 이식할 수 있습니다. 이하는,<code>SyncProvider</code> 객체가,<code>VIEW</code> 의 파생원의 테이블 (복수가) 내의 데이터를 갱신할 수 있을지 어떨지를 나타내는 정수입니다.
<ul>
<li><b>UPDATABLE_VIEW_SYNC</b> - <code>SyncProvider</code> 구현이,<code>RowSet</code> 객체를 이식하기 위해서 사용된 SQL <code>VIEW</code> 의 파생원의 테이블 (복수가능)에의 동기를 지원하는 것을 나타낸다 
<p>
<li><b>NONUPDATABLE_VIEW_SYNC</b> - <code>SyncProvider</code> 구현이,<code>RowSet</code> 객체를 이식하기 위해서 사용된 SQL <code>VIEW</code> 의 파생원의 테이블 (복수가능)에의 동기를 지원<b>하지 않는</b>것을 나타낸다
</ul>
<p>
<b>3.5 <code>SyncProvider</code> 의 그레이드 기능과 락 기능의 사용 방법</b> 
<p>
다음에, 레퍼런스 구현 <tt>CachedRowSetImpl</tt> 가 <tt>setSyncProvider</tt> 메소드를 호출하는 것에 의해 현재의 <tt>SyncProvider</tt> 객체를 복구성 하는 예를 나타냅니다. <br>
       
<PRE>
    CachedRowSetImpl crs = new CachedRowSetImpl() ;k
    crs.setSyncProvider("com.foo.bar.HASyncProvider");
</PRE>
어플리케이션은, 미접속의 <code>RowSet</code> 객체에 의해 현재 사용되고 있는 <tt>SyncProvider</tt> 객체를 취득할 수 있습니다. 또, 프로바이더의 구현에 사용된 동기의 그레이드와 현재 사용되고 있는 락의 단계도 취득할 수 있습니다. 어플리케이션의 유연성을 이용해, 사용하는 락의 단계를 설정하는 것으로써, 동기의 성공의 확률을 높일 수가 있습니다. 이러한 오퍼레이션에 대해서는, 이하의 코드의 발췌를 참조해 주세요.
<PRE>
    SyncProvider sync = crs.getSyncProvider();

    switch (sync.getProviderGrade()) {
    case:SyncProvider.GRADE_CHECK_ALL_AT_COMMIT
         //A high grade of optimistic synchronization
    break;
    case: SyncProvider.GRADE_CHECK_MODIFIED_AT_COMMIT 
         //A low grade of optimistic synchronization 
    break;
    case:SyncProvider.GRADE_LOCK_WHEN_LOADED 
         // A pessimistic synchronization grade 
    break;
    case:SyncProvider.GRADE_LOCK_WHEN_MODIFIED 
         // A pessimistic synchronization grade 
    break;
    case:SyncProvider.GRADE_NONE 
      // No synchronization with the originating data source provided
    break;
    }
          
    switch (sync.getDataSourcLock() {
      case:SyncProvider.DATASOURCE_DB_LOCK
       // A lock is placed on the entire datasource that is used by the
       // <code>RowSet</code> object 
       break;

      case:SyncProvider.DATASOURCE_NO_LOCK
       // No locks remain on the  originating data source.
      break;

      case:SyncProvider.DATASOURCE_ROW_LOCK
       // A lock is placed on the rows that are  touched by the original 
       // SQL statement used to populate
       // the RowSet object that is using the SyncProvider
       break;

      case: DATASOURCE_TABLE_LOCK
       // A lock is placed on  all tables that are touched by the original 
       // SQL statement used to populated
       // the RowSet object that is using the SyncProvider
       break;

</PRE>
<code>SyncFactory</code> 클래스의 static 유틸리티 메소드를 사용해, 현재 <code>SyncFactory</code> 에 등록되어 있는 <code>SyncProvider</code> 구현의 일람을 확인할 수도 있습니다.
       
<pre>
        Enumeration e = SyncFactory.getRegisteredProviders();
</pre>    

</ul>

<h3><a name="resolving">4.0 동기 경합의 해결</h3>

어플리케이션은,<code>SyncResolver</code> 인터페이스를 이용해, 경합이 발생했을 때의 수동에서의 대처법을 결정할 수 있습니다. <code>CachedRowSet</code> 의 <code>acceptChanges</code> 메소드가 종료해, 경합의 존재가 확인되었을 경우, 이 메소드는 <code>SyncProviderException</code> 객체를 throw 합니다. 어플리케이션은 예외를 캐치 해,<code>SyncProviderException.getSyncResolver()</code> 메소드 호출에 의해 <code>SyncResolver</code> 객체를 취득시킬 수가 있습니다.  
<P>
<code>SyncResolver</code> 객체는,<code>SyncResolver</code> 인터페이스를 구현하고 있는 특수한 <code>CachedRowSet</code> 또는 <code>JdbcRowSet</code> 객체이며, 1 행씩 경합의 체크를 실시합니다. 동기 되는 <code>RowSet</code> 객체의 복제가 되어 있어, 경합의 원인이 되고 있는 데이터 소스의 데이터만을 포함하고 있습니다. 그 외의 모든 렬치는 <code>null</code> 로 설정됩니다. SyncResolver</code> 객체는, 경합 하고 있는 값으로부터 다른 경합 하고 있는 값에 이동할 수 있는 메소드,<code>nextConflict</code> 및 <code>previousConflict</code> 를 제공하고 있습니다.
<P>
<code>SyncResolver</code> 인터페이스는, 이하의 처리를 실시하는 메소드도 제공합니다.
<UL>
<LI>갱신, 삭제, 또는 삽입을 필요로 하는 경합일지 어떨지를 검출
<LI>경합의 원인이 된 데이터 소스내의 값을 취득
<LI>만약 데이터 소스내의 데이터를 변경할 필요가 있는 경우 그 적절한 값의 설정.  혹은,<code>RowSet</code> 객체의 데이터를 변경할 필요가 있는 경우 그 적절한 값의 설정
</UL>
<P>
<code>CachedRowSet</code> 의 <code>acceptChanges</code> 메소드는, 불려 가면(자),<code>RowSet</code> 객체의 <code>SyncProvider</code> 객체를 위양 합니다. 이 <code>SyncProvider</code> 객체로부터 제공되는 라이터의 구현 방법에 따라, 경합의 체크 레벨 (그레이드)이 결정됩니다. 경합의 체크가 모두 완료해, 실제로 경합이 검출되었을 경우,<code>acceptChanges</code> 메소드는 <code>SyncProviderException</code> 객체를 throw 합니다. 어플리케이션은 예외를 캐치 해, 이 예외를 사용해 <code>SyncResolver</code> 객체를 취득할 수가 있습니다.   
<P>
그 후,<code>SyncResolver</code> 메소드를 사용해, 각 경합의 정보를 취득해, 대처 방법을 결정합니다.  어플리케이션 논리 또는 사용자에 의해,<code>RowSet</code> 객체내의 값을 지속시킬 필요가 있다고 하는 판단이 내려졌을 경우, 어플리케이션 또는 사용자는, 이 값으로 데이터 소스치를 덧쓰기할 수 있습니다.   
<P>
상세한 것에 대하여는,<code>SyncResolver</code> 인터페이스의 코멘트를 참조해 주세요. <a name="relspec">

<a name="relspec"><h3>5.0 관련 스펙</h3>
<ul>
<li><a href="http://java.sun.com/products/jndi">JNDI 1.3</a> 
<li><a href="../../../../../technotes/guides/logging/index.html">Java 로깅 API</a> 
</ul>
<a name="reldocs"><h3>6.0 관련 항목</h3>
<ul>
<li><a href="../../../../../technotes/tools/index.html#basic">시스템 프로퍼티</a> 
<li>resource file
<li><a href="http://java.sun.com/tutorial/jdbc">JDBC 접속의 데이터 소스</a> 
</ul>
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../javax/sql/rowset/serial/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../../javax/swing/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?javax/sql/rowset/spi/package-summary.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
