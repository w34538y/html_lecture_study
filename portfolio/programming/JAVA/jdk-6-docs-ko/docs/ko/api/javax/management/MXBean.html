<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:02:31 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
MXBean (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="MXBean (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/MXBean.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/management/MBeanTrustPermission.html" title="javax.management 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/management/NotCompliantMBeanException.html" title="javax.management 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/management/MXBean.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="MXBean.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;필수 &nbsp;|&nbsp;<A HREF="#annotation_type_optional_element_summary">옵션</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#annotation_type_element_detail">요소</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.management</FONT>
<BR>
주석형 MXBean</H2>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE><FONT SIZE="-1"><A HREF="../../java/lang/annotation/Documented.html" title="java.lang.annotation 안의 주석">@Documented</A> 
<A HREF="../../java/lang/annotation/Retention.html" title="java.lang.annotation 안의 주석">@Retention</A> (<A HREF="../../java/lang/annotation/Retention.html#value()">value</A> =<A HREF="../../java/lang/annotation/RetentionPolicy.html#RUNTIME">RUNTIME</A> )
<A HREF="../../java/lang/annotation/Target.html" title="java.lang.annotation 안의 주석">@Target</A> (<A HREF="../../java/lang/annotation/Target.html#value()">value</A> =<A HREF="../../java/lang/annotation/ElementType.html#TYPE">TYPE</A> )
</FONT>public @interface <B>MXBean</B></DL>
</PRE>

<P>
<p>인터페이스에 대해서, MXBean 인터페이스이다, 또는 MXBean 인터페이스는 아니라고 하는 마크를 명시적으로 붙이기 위한 주석입니다. 디폴트에서는,<code>SomethingMXBean</code> 와 같이, 이름의 말미가 <code>MXBean</code> 의 인터페이스는 MXBean 인터페이스입니다. 다음에 나타내는 인터페이스는, MXBean 인터페이스입니다. </p>

    <pre>
    public interface WhatsitMXBean {}

    &#64;MXBean
    public interface Whatsit1Interface {}

    &#64;MXBean(true)
    public interface Whatsit2Interface {}
    </pre>

 <p>다음에 나타내는 인터페이스는, MXBean 인터페이스가 아닙니다. </p>

    <pre>
    public interface Whatsit3Interface{}

    &#64;MXBean(false)
    public interface MisleadingMXBean {}
    </pre>

<h3><a name="MXBean-spec">MXBean 스펙</a> </h3>

 <p>MXBean 의 개념을 사용하면(자),<A HREF="../../javax/management/openmbean/package-summary.html"><CODE>javax.management.openmbean</CODE></A>  에 의해 정의된, 정의 끝난 형태 세트만을 참조하는 MBean 를 간단하게 코딩 할 수 있습니다. 이것에 의해, 원격 클라이언트를 포함한 임의의 클라이언트가, MBean 의 형태를 나타내는 「모델 고유 클래스」에 액세스 하지 않아도, MBean 를 확실히 사용할 수 있게 됩니다. <em></em></p>

 <p>이 개념은, Standard MBean 의 개념과 비교해, 이해하기 쉬운 것입니다. 여기에서는, 관리 대상 객체를 Standard MBean 및 MXBean 로서 표현하는 방법에 대해 설명합니다. </p>

    <table border="1" cellpadding="5">
      <tr>
<th>Standard MBean</th><th>MXBean</th>
      </tr>
      <tr>
        <td><pre>
public interface MemoryPool<b>MBean</b> {
    String getName();
    MemoryUsage getUsage();
    // ...
}
          </pre></td>
        <td><pre>
public interface MemoryPool<b>MXBean</b> {
    String getName();
    MemoryUsage getUsage();
    // ...
}
          </pre></td>
      </tr>
    </table>

 <p>상기의 기술로부터, 정의는 매우 유사하고 있는 것을 알 수 있습니다. 유일한 차이점은, 인터페이스의 명명 규칙으로서 Standard MBean 에서는 <code><em>Something</em>MBean</code> 를 사용하는데 대해, MXBean 에서는 <code><em>Something</em>MXBean</code> 를 사용한다고 하는 점입니다. </p>

 <p>이 관리 대상 객체에서는,<A HREF="../../java/lang/management/MemoryUsage.html" title="java.lang.management 안의 클래스"><CODE>MemoryUsage</CODE></A>  형의 <code>Usage</code> 라는 이름의 속성이 있습니다. 이런 종류의 속성의 특징은, 데이터 항목 세트의 일관한 snapshot를 제공하는 점입니다. 예를 들어, 메모리 풀내의 현재의 사용이 끝난 메모리 용량이나, 현재의 메모리 풀의 최대치를 포함할 수가 있습니다. 이것들이 다른 항목이 되어 있으면(자),<A HREF="../../javax/management/MBeanServer.html#getAttribute(javax.management.ObjectName, java.lang.String)"><CODE>getAttribute</CODE></A>  를 개별적으로 호출해 항목을 취득하기 위해(때문에), 다양한 시점의 일관성이 없는 값을 취득할 가능성이 있습니다. <code>max</code> 치보다 큰 <code>used</code> 치를 취득할 가능성도 있습니다. </p>

 <p>이 때문에, 다음과 같이 <code>MemoryUsage</code> 를 정의할 수 있습니다. </p>

    <table border="1" cellpadding="5">
      <tr>
<th>Standard MBean</th><th>MXBean</th>
      </tr>
      <tr>
        <td><pre>
public class MemoryUsage <b>implements Serializable</b> {
    // standard JavaBean conventions with getters

    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}
          </pre></td>
        <td><pre>
public class MemoryUsage {
    // standard JavaBean conventions with getters
    <b>&#64;ConstructorProperties({"init", "used", "committed", "max"})</b>
    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}
          </pre></td>
      </tr>
    </table>

 <p>MXBean 에서는 <code>MemoryUsage</code> 에 <code>Serializable</code> 의 마크를 붙일 필요가 없는 것을 제외하면, 어느 쪽의 경우도 정의는 같습니다 (다만,<code>Serializable</code> 의 마크를 붙이는 것은 가능). 한편, MXBean 에는, 생성자  파라미터를 대응하는 취득 메소드에 링크하기 위한 ,<code>@ConstructorProperties</code> 주석이 추가되고 있습니다. 이 점에 대해서는, 나중에 자세하게 설명합니다. </p>

 <p><code>MemoryUsage</code> 는, 「모델 고유 클래스」입니다. <em></em>Standard MBean 에서는,<code>MemoryUsage</code> 클래스가 불명한 경우, MBean Server 의 클라이언트는 <code>Usage</code> 속성에 액세스 할 수 없습니다. 클라이언트가, JMX 기술에 근거하는 총칭 콘솔인 경우를 생각해 봅시다. 이 경우, 콘솔은, 접속처의 각 어플리케이션의 모델 고유 클래스를 사용해 설정할 필요가 있습니다. Java 언어로 기술되어 있지 않은 클라이언트의 경우, 문제는 한층 어려워집니다. 이 경우,<code>MemoryUsage</code> 의 내용에 대해 클라이언트에 알릴 방법이 없을 가능성이 있습니다. </p>

 <p>이러한 경우에, MXBean 는 Standard MBean 와 다릅니다. 관리 인터페이스의 정의 방법은 거의 같습니다만, MXBean 시스템에서는, 모델 고유 클래스가 Java 플랫폼의 표준 클래스에 변환됩니다. <em></em>배열 및 표준 <A HREF="../../javax/management/openmbean/package-summary.html"><CODE>javax.management.openmbean</CODE></A>  패키지 <A HREF="../../javax/management/openmbean/CompositeData.html" title="javax.management.openmbean 중의 인터페이스"><CODE>CompositeData</CODE></A>  클래스와 <A HREF="../../javax/management/openmbean/TabularData.html" title="javax.management.openmbean 안의 인터페이스"><CODE>TabularData</CODE></A>  클래스를 사용하는 것으로, 임의의 복잡함의 데이터 구조를 표준 클래스만을 사용해 구축할 수 있습니다. </p>

 <p>이 점은, 2 개의 모델의 클라이언트를 비교하는 것으로보다 명확하게 됩니다. </p>

    <table border="1" cellpadding="5">
      <tr>
<th>Standard MBean</th><th>MXBean</th>
      </tr>
      <tr>
        <td><pre>
String name = (String)
mbeanServer. <A HREF="../../javax/management/MBeanServer.html#getAttribute(javax.management.ObjectName, java.lang.String)"><CODE>getAttribute</CODE></A> (objectName, "Name");
<b>MemoryUsage</b> usage = (<b>MemoryUsage</b>)
mbeanServer.getAttribute(objectName, "Usage");
<b>long used = usage.getUsed();</b>
          </pre></td>
        <td><pre>
String name = (String)
mbeanServer. <A HREF="../../javax/management/MBeanServer.html#getAttribute(javax.management.ObjectName, java.lang.String)"><CODE>getAttribute</CODE></A> (objectName, "Name");
<b><A HREF="../../javax/management/openmbean/CompositeData.html" title="javax.management.openmbean 안의 인터페이스"><CODE>CompositeData</CODE></A> </b> usage = (<b>CompositeData</b>)
mbeanServer.getAttribute(objectName, "Usage");
<b>long used = (Long) usage. <A HREF="../../javax/management/openmbean/CompositeData.html#get(java.lang.String)"><CODE>get</CODE></A> ("used");</b>
          </pre></td>
    </table>

 <p><code>String</code> 등이 단순한 형태의 속성의 경우, 코드는 같습니다. 다만, 복잡한 형태의 속성의 경우, Standard MBean 의 코드에서는 클라이언트가 모델 고유 클래스 <code>MemoryUsage</code> 를 인식할 필요가 있는데 대해, MXBean 의 코드에서는 비표준 클래스는 필요 없습니다. </p>

 <p>여기에 나타내는 클라이언트 코드에서는, MXBean 클라이언트가 얼마인가 복잡하게 되어 있습니다. 다만, 클라이언트가 모델 (여기에서는,<code>MemoryPoolMXBean</code> 인터페이스와 <code>MemoryUsage</code> 클래스)을 실제로 인식하고 있는 경우는, 「프록시」의 구축이 가능합니다. <em></em>모델이 사전에 아는 경우에는, Standard MBean 를 사용할까 MXBean 를 사용할까에 관계없이, 이 방법으로 관리 대상 객체와의 교환을 실시하는 것을 추천합니다. </p>

    <table border="1" cellpadding="5">
      <tr>
<th>Standard MBean</th><th>MXBean</th>
      </tr>
      <tr>
        <td><pre>
MemoryPool<b>MBean</b> proxy =
JMX. <b><A HREF="../../javax/management/JMX.html#newMBeanProxy(javax.management.MBeanServerConnection, javax.management.ObjectName, java.lang.Class)"><CODE>newMBeanProxy</CODE></A> </b>(
mbeanServer,
objectName,
MemoryPool<b>MBean</b>. class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre></td>
        <td><pre>
MemoryPool<b>MXBean</b> proxy =
JMX. <b><A HREF="../../javax/management/JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection, javax.management.ObjectName, java.lang.Class)"><CODE>newMXBeanProxy</CODE></A> </b>(
mbeanServer,
objectName,
MemoryPool<b>MXBean</b>. class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre></td>
      </tr>
    </table>

 <p>MemoryPool 객체의 구현의 동작은, Standard MBean 에서도 MXBean 에서도 같습니다. </p>

    <table border="1" cellpadding="5">
      <tr>
<th>Standard MBean</th><th>MXBean</th>
      </tr>
      <tr>
        <td><pre>
public class MemoryPool
implements MemoryPool<b>MBean</b> {
public String getName() {...}
public MemoryUsage getUsage() {...}
    // ...
}
          </pre></td>
        <td><pre>
public class MemoryPool
implements MemoryPool<b>MXBean</b> {
public String getName() {...}
public MemoryUsage getUsage() {...}
    // ...
}
          </pre></td>
      </tr>
    </table>

 <p>MBean Server 에의 MBean 의 등록의 동작은, 어느 쪽의 경우도 같습니다. </p>

    <table border="1" cellpadding="5">
      <tr>
<th>Standard MBean</th><th>MXBean</th>
      </tr>
      <tr>
        <td><pre>
{
MemoryPool<b>MBean</b> pool = new MemoryPool();
mbeanServer. <A HREF="../../javax/management/MBeanServer.html#registerMBean(java.lang.Object, javax.management.ObjectName)"><CODE>registerMBean</CODE></A> (pool, objectName);
}
          </pre></td>
        <td><pre>
{
MemoryPool<b>MXBean</b> pool = new MemoryPool();
mbeanServer. <A HREF="../../javax/management/MBeanServer.html#registerMBean(java.lang.Object, javax.management.ObjectName)"><CODE>registerMBean</CODE></A> (pool, objectName);
}
          </pre></td>
      </tr>
    </table>


<h2><a name="mxbean-def">MXBean 의 정의</a> </h2>

 <p>MXBean 는, MBean 의 일종입니다. MXBean 객체는, MBean Server 에 직접 등록하는 일도,<A HREF="../../javax/management/StandardMBean.html" title="javax.management 안의 클래스"><CODE>StandardMBean</CODE></A>  의 인수로서 사용해, 결과의 MBean 를 MBean Server 에 등록할 수도 있습니다. </p>

 <p><A HREF="../../javax/management/MBeanServer.html" title="javax.management 안의 인터페이스"><CODE>MBeanServer</CODE></A>  인터페이스의 <code>registerMBean</code> 나 <code>createMBean</code> 메소드를 사용해 객체를 MBean Server 에 등록하면(자), MBean 의 형태를 판별하기 위해서 객체의 클래스가 검사됩니다. </p>

    <ul>
<li>클래스가 <A HREF="../../javax/management/DynamicMBean.html" title="javax.management 안의 인터페이스"><CODE>DynamicMBean</CODE></A>  인터페이스를 구현하는 경우, MBean 는 Dynamic MBean 입니다. <code>StandardMBean</code> 클래스는 이 인터페이스를 구현합니다. 이 때문에, 이것은 <code>StandardMBean</code> 클래스를 사용해 작성된 Standard MBean 또는 MXBean 에 적용됩니다. </li>

<li>그 이외로, 클래스가 Standard MBean 의 명명 규칙에 일치하는 경우, MBean 는 Standard MBean 입니다. </li>

<li>상기의 어느 것에도 들어맞지 않는 경우는, MXBean 의 가능성이 있습니다. 다음의 인터페이스가 있을지 어떨지, 객체에 의해 구현된 인터페이스세트가 검사됩니다.

        <ul>
<li>클래스명이 <code><em>S</em>MXBean</code> 의 인터페이스. <code><em>S</em></code> 는 빈 상태(empty)이 아닌 캐릭터 라인이며, 주석 <code>@MXBean(false)</code> 를 포함하지 않는다. </li>
<li><code>@MXBean(true)</code> 또는 단지 <code>@MXBean</code> 라고 하는 주석을 포함한 인터페이스. </li>
        </ul>

정확하게 일치하는 인터페이스가 존재하는지, 다른 모든 서브 인터페이스인 인터페이스가 존재하는 경우, 그 객체는 MXBean 입니다. 문제의 인터페이스는 <em>MXBean interface</em> 가 됩니다. 이 예에서는, MXBean 인터페이스는 <code>MemoryPoolMXBean</code> 입니다.

<li>이러한 조건에 들어맞는 것이 없는 경우, MBean 는 무효이며, 등록을 시도하면(자) <A HREF="../../javax/management/NotCompliantMBeanException.html" title="javax.management 동안의 클래스"><CODE>NotCompliantMBeanException</CODE></A>  가 생성됩니다.
    </ul>

 <p>MXBean 인터페이스내에서 메소드의 파라미터 또는 반환값의 형태로서 나타나는 모든 Java 형이, 다음의 룰에 따라 「변환 가능」이 아니면 안됩니다. <em></em>또, 파라미터가 이하의 정의에 따라 재구축 가능하지 않으면 안됩니다. <em></em></p>

 <p>상기의 룰에 준거하지 않는 MXBean 를 구축하려고 하면(자), 예외가 throw 됩니다. </p>


<h2><a name="naming-conv">명명 규칙</a> </h2>

 <p>MXBean 내의 메소드에는, Standard MBean 내의 메소드와 같은 명명 규칙이 적용됩니다. </p>

    <ol>
<li><code><em>T</em> get<em>N</em>()</code> 메소드 (<code><em>T</em></code> 는 <code>void</code> 가 아닌 Java 형,<code><em>N</em></code> 는 빈 상태(empty)이 아닌 캐릭터 라인)는,<code><em>N</em></code> 라는 이름의 읽어내 가능한 속성이 존재하는 것을 나타냅니다. 속성의 Java 형 및 공개형은, 다음의 매핑 룰에 따라 결정됩니다. <code>Object</code> 로부터 상속한 <code>final Class getClass()</code> 메소드는, 취득 메소드의 검색시에는 무시됩니다. </li>

<li><code>boolean is<em>N</em>()</code> 메소드는, Java 형 <code>boolean</code> 및 공개형 <code>SimpleType.Boolean</code> 의 읽기 가능 속성 <code><em>N</em></code> 가 존재하는 것을 나타냅니다. </li>

<li><code>void set<em>N</em>(<em>T</em> x)</code> 메소드는, 기입 가능 속성 <code><em>N</em></code> 가 존재하는 것을 나타냅니다. 속성의 Java 형 및 공개형은, 다음의 매핑 룰에 따라 결정됩니다. 파라미터의 이름 <code>x</code> 는 관계 없습니다. </li>

<li>다른 모든 메소드는, 메소드와 같은 이름의 연산이 존재하는 것을 나타냅니다. 반환값 및 각 파라미터의 Java 형 및 공개형은, 다음의 매핑 룰에 따라 결정됩니다. </li>
    </ol>

 <p><code>get<em>N</em></code> 및 <code>is<em>N</em></code> 의 룰에 의해, 「취득 메소드」의 개념이 정리해 정의됩니다. <em></em><code>set<em>N</em></code> 의 룰에 의해, 「설정 메소드」의 개념이 정의됩니다. <em></em></p>

 <p>동명의 취득 메소드가 2 개 존재하거나 동명의 설정 메소드가 2 개 존재하면(자) 에러가 됩니다. 동명의 취득 메소드와 설정 메소드가 존재하는 경우는, 양쪽 모두의 <code><em>T</em></code> 형을 같게 합니다. 이 경우, 속성은 읽어내/기입 속성이 됩니다. 취득 메소드와 설정 메소드의 어느쪽이든 한편이 1 개만 존재하는 경우, 속성은 각각 읽어내 전용 또는 기입해 전용이 됩니다. </p>


<h2><a name="mapping-rules">형태 매핑 룰</a> </h2>

 <p><A HREF="../../javax/management/openmbean/package-summary.html"><CODE>javax.management.openmbean</CODE></A>  패키지로 정의되고 있도록(듯이), MXBean 는 Open MBean 의 일종입니다. 이것은, 속성, 연산 파라미터, 및 연산의 반환값이 모두, 「공개형」<em></em> (즉 <A HREF="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean 안의 클래스"><CODE>OpenType</CODE></A>  의 4 개의 표준 서브 클래스)을 사용해 기술 가능하지 않으면 안 되는 것을 의미합니다. MXBean 에서는, Java 형을 공개형에 매핑 하는 것으로 이것을 실현합니다. </p>

 <p>모든 Java 형 <em>J</em> 로, MXBean 매핑의 기술에 다음의 정보가 사용됩니다. </p>

    <ul>
<li>대응하는 공개형인 <em>opentype(J)</em>. 이것은,<A HREF="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean 안의 클래스"><CODE>OpenType</CODE></A>  의 서브 클래스의 인스턴스입니다. </li>
<li>「맵 되었다」Java 형 <em>opendata(J)</em>. 이것은 어느 <em>opentype(J)</em> 에 대해서도, 1 개의 <em>opendata(J)</em> 에 대해서는 항상 같습니다. <em></em>이것은 Java 클래스입니다. </li>
<li>값을 <em>J</em> 형으로부터 <em>opendata(J)</em> 형으로 변환하는 방법. </li>
<li>값을 <em>opendata(J)</em> 형으로부터 <em>J</em> 형으로 변환하는 방법 (가능한 경우). </li>
    </ul>

 <p>예를 들어, Java 형 <code>List&lt;String&gt;</code> 에 대해 생각해 봅시다. </p>

    <ul>
<li>공개형,<em>opentype(</em><code>List&lt;String&gt;</code><em>)</em> 는 <A HREF="../../javax/management/openmbean/ArrayType.html" title="javax.management.openmbean 안의 클래스"><CODE>ArrayType</CODE></A> <code>(1, </code><A HREF="../../javax/management/openmbean/SimpleType.html#STRING"><CODE>SimpleType.STRING</CODE></A> <code>)</code> 이며, 1 차원의 <code>String</code> 배열을 나타냅니다. </li>
<li>맵 된 Java 형,<em>opendata(</em><code>List&lt;String&gt;</code><em>)</em> 는 <code>String[]</code> 입니다. </li>
<li><code>List&lt;String&gt;</code> 는,<A HREF="../../java/util/List.html#toArray(T[])"><CODE>List.toArray(new String[0])</CODE></A>  를 사용해 <code>String[]</code> 로 변환할 수 있습니다. </li>
<li><code>String[]</code> 는,<A HREF="../../java/util/Arrays.html#asList(T...)"><CODE>Arrays.asList</CODE></A>  를 사용해 <code>List&lt;String&gt;</code> 로 변환할 수 있습니다. </li>
    </ul>

 <p><em>J</em> 로부터 <em>opentype(J)</em> 를 파생시키는 매핑 룰이 존재하지 않는 경우,<em>J</em> 를 MXBean 인터페이스내의 메소드 파라미터 또는 반환값의 형태로 할 수 없습니다. </p>

 <p><em>opendata(J)</em> 를 <em>J</em> 에 재변환하는 방법이 있는 경우,<em>J</em> 는 「재구축 가능」이다고 합니다. <em></em>MXBean 인터페이스내의 모든 메소드 파라미터는, 재구축 가능하지 않으면 안됩니다. 이것은, MXBean 시스템가 메소드를 호출할 때에, 이러한 파라미터를 <em>opendata(J)</em> 로부터 <em>J</em> 로 변환할 필요가 있기 (위해)때문에입니다. <A HREF="../../javax/management/JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection, javax.management.ObjectName, java.lang.Class)"><CODE>JMX.newMXBeanProxy</CODE></A>  에 의해 생성된 프록시에서는, 이것은, 재구축 가능하지 않으면 안 되는 MXBean 인터페이스내의 메소드의 반환값입니다. </p>

 <p>null 치를 사용할 수 없는 프리미티브(primitive) Java 형을 제외한, 모든 Java 형과 공개형으로, null 치가 허가됩니다. <em>J</em> 형을 <em>opendata(J)</em> 형으로 변환하거나<em>opendata(J)</em> 형을 <em>J</em> 형으로 변환하는 경우는, null 치와 null 치가 매핑 됩니다. </p>

 <p>다음의 겉(표)에, 형태 매핑 룰의 개요를 나타냅니다. </p>

    <table border="1" cellpadding="5">
      <tr>
<th>Java 형 <em>J</em></th>
<th><em>opentype(J)</em></th>
<th><em>opendata(J)</em></th>
      </tr>
      <tbody cellvalign="top">
        <tr>
<td><code>int</code>,<code>boolean</code> 등<br> (8 개의 프리미티브(primitive) Java 형)</td>
<td><code>SimpleType.INTEGER</code>,<br> <code>SimpleType.BOOLEAN</code> 등</td>
<td><code>Integer</code>,<code>Boolean</code> 등<br> (대응하는 boxed 형)</td>
        </tr>
        <tr>
<td><code>Integer</code>,<code>ObjectName</code> 등<br> (<A HREF="../../javax/management/openmbean/SimpleType.html" title="javax.management.openmbean 안의 클래스"><CODE>SimpleType</CODE></A>  의 적용 범위내의 형태)</td>
<td>대응하는 <code>SimpleType</code></td>
<td><em>J</em>, 같은 형태</td>
        </tr>
        <tr>
<td><code>int[]</code> 등<br> (프리미티브(primitive) 요소형의<br> 1 차원 배열)</td>
<td><code>ArrayType.getPrimitiveArrayType(int[]. class)</code> 등</td>
<td><em>J</em>, 같은 형태</td>
        <tr>
<td><em>E</em><code>[]</code><br> (비프리미티브(primitive) 요소형 <em>E</em> 의 배열,<code>int[][]</code> 를 포함한다. <em>E</em> 는 <code>int[]</code>)</td>
<td><code>ArrayType.getArrayType(</code><em>opentype(E)</em><code>)</code></td>
<td><em>opendata(E)</em><code>[]</code></td>
        </tr>
        <tr>
<td><code>List&lt;</code><em>E</em><code>&gt;</code><br> <code>Set&lt;</code><em>E</em><code>&gt;</code><br> <code>SortedSet&lt;</code><em>E</em><code>&gt;</code> (아래와 같이를 참조)</td>
<td><em>E</em><code>[]</code> 에 대하는 것과 같다</td>
<td><em>E</em><code>[]</code> 에 대하는 것과 같다</td>
        </tr>
        <tr>
<td>열거 <em>E</em><br> (Java 내에서 <code>enum </code><em>E</em> <code>{...}</code> (으)로서 선언된다)</td>
<td><code>SimpleType.STRING</code></td>
<td><code>String</code></td>
        </tr>
        <tr>
<td><code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code><br> <code>SortedMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code></td>
<td><A HREF="../../javax/management/openmbean/TabularType.html" title="javax.management.openmbean 안의 클래스"><CODE>TabularType</CODE></A> <br> (아래와 같이를 참조)</td>
<td><A HREF="../../javax/management/openmbean/TabularData.html" title="javax.management.openmbean 안의 인터페이스"><CODE>TabularData</CODE></A> <br> (아래와 같이를 참조)</td>
        </tr>
        <tr>
<td>MXBean 인터페이스</td>
<td><code>SimpleType.OBJECTNAME</code><br> (아래와 같이를 참조)</td>
<td><A HREF="../../javax/management/ObjectName.html" title="javax.management 안의 클래스"><CODE>ObjectName</CODE></A> <br> (아래와 같이를 참조)</td>
        </tr>
        <tr>
<td>그 외의 형태</td>
<td>가능한 경우에는 <A HREF="../../javax/management/openmbean/CompositeType.html" title="javax.management.openmbean 안의 클래스"><CODE>CompositeType</CODE></A> <br> (아래와 같이를 참조)</td>
<td><A HREF="../../javax/management/openmbean/CompositeData.html" title="javax.management.openmbean 안의 인터페이스"><CODE>CompositeData</CODE></A> </td>
      </tbody>
    </table>

 <p>이후시에에서는, 이러한 룰에 대해 자세하게 설명합니다. </p>


<h3>원시형의 매핑</h3>

 <p>8 개의 프리미티브(primitive) Java 형 (<code>boolean</code>,<code>byte</code>,<code>short</code>,<code>int</code>,<code>long</code>,<code>float</code>,<code>double</code>,<code>char</code>)은,<code>java.lang</code> 로부터 <code>Boolean</code>,<code>Byte</code> 등의 대응하는 boxed 형에 매핑 됩니다. 공개형은, 대응하는 <code>SimpleType</code> 입니다. 이 때문에,<em>opentype(</em><code>long</code><em>)</em> 는 <code>SimpleType.LONG</code> 에,<em>opendata(</em><code>long</code><em>)</em> 는 <code>java.lang.Long</code> 가 됩니다. </p>

 <p><code>long[]</code> 등의 원시형의 배열은, 공개형으로서 직접 표현할 수 있습니다. 이 때문에,<em>openType(</em><code>long[]</code><em>)</em> 는 <code>ArrayType.getPrimitiveArrayType(long[]. class)</code> 에,<em>opendata(</em><code>long[]</code><em>)</em> 는 <code>long[]</code> 가 됩니다. </p>

 <p>JMX API 내의 연산은 프리미티브(primitive)이지 않고 항상 Java 객체상에서 실행되기 (위해)때문에, 실제로는, 프레인인 <code>int</code> 와 <code>Integer</code> 의 차이등이 명확하게 될 것은 없습니다. 다만, 배열로 차이가 밝혀집니다. <em></em></p>


<h3>컬렉션의 매핑 (<code>List&lt;</code><em>E</em><code>&gt;</code> 등)</h3>

 <p><code>List&lt;</code><em>E</em><code>&gt;</code> 나 <code>Set&lt;</code><em>E</em><code>&gt;</code> (<code>List&lt;String&gt;</code> 이나 <code>Set&lt;ObjectName&gt;</code> 등)의 매핑 방법은, 같은 요소형의 배열 (<code>String[]</code> 나 <code>ObjectName[]</code> 등)과 같습니다. </p>

 <p><code>SortedSet&lt;</code><em>E</em><code>&gt;</code> 도 <em>E</em><code>[]</code> 와 같은 방법으로 매핑 됩니다. 다만, 이것이 변환 가능한 것은,<em>E</em> 가 <A HREF="../../java/lang/Comparable.html" title="java.lang 안의 인터페이스"><CODE>Comparable</CODE></A>  를 구현하는 클래스 또는 인터페이스인 경우만입니다. 이 때문에,<code>SortedSet&lt;String&gt;</code> 나 <code>SortedSet&lt;Integer&gt;</code> 는 변환 가능합니다만,<code>SortedSet&lt;int[]&gt;</code> 나 <code>SortedSet&lt;List&lt;String&gt;&gt;</code> 는 변환 불가능합니다. <code>SortedSet</code> 인스턴스의 변환은, null 이외의 <A HREF="../../java/util/SortedSet.html#comparator()"><CODE>comparator()</CODE></A>  가 존재하면(자),<code>IllegalArgumentException</code> 를 throw 해 실패합니다. </p>

 <p><code>List&lt;</code><em>E</em><code>&gt;</code> 는 <code>java.util.ArrayList&lt;</code><em>E</em><code>&gt;</code> 로서<code>Set&lt;</code><em>E</em><code>&gt;</code> 는 <code>java.util.HashSet&lt;</code><em>E</em><code>&gt;</code> 로서<code>SortedSet&lt;</code><em>E</em><code>&gt;</code> 는 <code>java.util.TreeSet&lt;</code><em>E</em><code>&gt;</code> 로서 각각 재구축 됩니다. </p>


<h3>맵의 매핑 (<code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> 등)</h3>

 <p><code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> 또는 <code>SortedMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> (<code>Map&lt;String, ObjectName&gt;</code> 등)는, 공개형 <A HREF="../../javax/management/openmbean/TabularType.html" title="javax.management.openmbean 내의 클래스"><CODE>TabularType</CODE></A>  를 가져,<A HREF="../../javax/management/openmbean/TabularData.html" title="javax.management.openmbean 안의 인터페이스"><CODE>TabularData</CODE></A>  에 매핑 됩니다. <code>TabularType</code> 에는,<code>key</code> 및 <code>value</code> 라는 이름의 2 개의 항목이 포함됩니다. <code>key</code> 의 공개형은 <em>opentype(K)</em>,<code>value</code> 의 공개형은 <em>opentype(V)</em> 입니다. <code>TabularType</code> 의 인덱스는, 단일의 항목 <code>key</code> 입니다. </p>

 <p>예를 들어,<code>Map&lt;String, ObjectName&gt;</code> 의 <code>TabularType</code> 는, 다음과 같은 코드를 사용해 구축할 수 있습니다. </p>

    <pre>
String typeName =
"java.util.Map&lt;java.lang.String, javax.management.ObjectName&gt;";
String[] keyValue =
new String[] {"key", "value"};
OpenType[] openTypes =
new OpenType[] {SimpleType.STRING, SimpleType.OBJECTNAME};
CompositeType rowType =
new CompositeType(typeName, typeName, keyValue, keyValue, openTypes);
TabularType tabularType =
new TabularType(typeName, typeName, rowType, new String[] {"key"});
    </pre>

 <p><code>typeName</code> 는, 다음에 상술하는<a href="#type-names">형명 룰</a>에 따라 결정됩니다.

 <p><code>SortedMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> 는 같은 방법으로 매핑 됩니다. 다만, 이것이 변환 가능한 것은,<em>K</em> 가 <A HREF="../../java/lang/Comparable.html" title="java.lang 안의 인터페이스"><CODE>Comparable</CODE></A>  를 구현하는 클래스 또는 인터페이스인 경우만입니다. 이 때문에,<code>SortedMap&lt;String, int[]&gt;</code> 는 변환 가능합니다만,<code>SortedMap&lt;int[], String&gt;</code> 는 변환 불가능합니다. <code>SortedMap</code> 인스턴스의 변환은, null 이외의 <A HREF="../../java/util/SortedMap.html#comparator()"><CODE>comparator()</CODE></A>  가 존재하면(자),<code>IllegalArgumentException</code> 를 throw 해 실패합니다. </p>

 <p><code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> 는 <code>java.util.HashMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> 로서<code>SortedMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> 는 <code>java.util.TreeMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> 로서 각각 재구축 됩니다. </p>

 <p><code>TabularData</code> 는 인터페이스입니다. <code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> 를 공개 데이터로서 표현하는데 사용되는 구상 클래스는 <A HREF="../../javax/management/openmbean/TabularDataSupport.html" title="javax.management.openmbean 안의 클래스"><CODE>TabularDataSupport</CODE></A> , 또는 <code>TabularDataSupport</code> 로서 직렬화하는 <code>TabularData</code> 를 구현하는 다른 클래스입니다. </p>


<h3><a name="mxbean-map">MXBean 인터페이스의 매핑</a> </h3>

 <p>MXBean 인터페이스, 또는 MXBean 인터페이스 내부에서 참조되는 형태는, 다른 MXBean 인터페이스 <em>J</em> 를 참조할 수 있습니다. 이 경우,<em>opentype(J)</em> 는 <code>SimpleType.OBJECTNAME</code>,<em>opendata(J)</em> 는 <code>ObjectName</code> 입니다. </p>

 <p>예를 들어, 다음과 같은 2 개의 MXBean 인터페이스가 존재하는 경우를 생각합시다. </p>

    <pre>
public interface ProductMXBean {
public ModuleMXBean[] getModules();
}

public interface ModuleMXBean {
public ProductMXBean getProduct();
}
    </pre>

 <p><code>ModuleMXBean</code> 인터페이스를 구현하는 객체는, 그 <code>getProduct</code> 메소드로부터,<code>ProductMXBean</code> 인터페이스를 구현하는 객체를 돌려줍니다. <code>ModuleMXBean</code> 객체와 반환되는 <code>ProductMXBean</code> 객체의 양쪽 모두를, 같은 MBean Server 의 MXBean 로서 등록할 필요가 있습니다. </p>

 <p><code>ModuleMXBean.getProduct()</code> 메소드는,<code>Product</code> 라는 이름의 속성을 정의합니다. 이 속성의 공개형은 <code>SimpleType.OBJECTNAME</code> 입니다. 대응하는 <code>ObjectName</code> 치는, 참조되는 <code>ProductMXBean</code> 가 MBean Server 내에서 등록되는 이름이 됩니다. </p>

 <p><code>ModuleMXBean</code> 용의 MXBean 프록시를 작성해, 그 <code>getProduct()</code> 메소드를 호출하는 경우, 다른 MXBean 프록시를 작성하는 것으로써, 프록시가 <code>ObjectName</code> 를 <code>ProductMXBean</code> 에 재차 매핑 합니다. 즉,<A HREF="../../javax/management/JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection, javax.management.ObjectName, java.lang.Class)"><CODE>JMX.newMXBeanProxy(mbeanServerConnection, objectNameX, interfaceX)</CODE></A>  를 사용해 작성된 프록시가 <code>objectNameY</code> 를 다른 MXBean 인터페이스인 <code>interfaceY</code> 에 재차 매핑 할 필요가 있는 경우,<code>JMX.newMXBeanProxy(mbeanServerConnection, objectNameY, interfaceY)</code> 가 사용됩니다. 이 구현에서는, 같은 파라미터를 사용해 <code>JMX.newMXBeanProxy</code> 를 호출하는 것으로, 이전에 작성된 프록시가 반환되는 일이 있습니다. 또, 신규 프록시가 작성되는 일도 있습니다. </p>

 <p><code>ModuleMXBean</code> 인터페이스를 다음과 같이 변경하는 것으로, 역매핑을 실행할 수 있습니다. </p>

    <pre>
public interface ModuleMXBean {
public ProductMXBean getProduct();
public void setProduct(ProductMXBean c);
}
    </pre>

 <p><code>setProduct</code> 메소드의 존재는,<code>Product</code> 속성이 읽어내/기입인 것을 나타냅니다. 이전과 같게, 이 속성의 값은 <code>ObjectName</code> 가 됩니다. 이 속성을 설정하는 경우는,<code>ObjectName</code> 를 <code>setProduct</code> 메소드로 필요한 <code>ProductMXBean</code> 객체로 변환합니다. 이 객체는, 같은 MBean Server 내의 지정된 <code>ObjectName</code> 의 MXBean 프록시가 됩니다. </p>

 <p>{<code>ModuleMXBean</code> 용의 MXBean 프록시를 작성해 그 <code>setProduct</code> 메소드를 호출하는 경우, 프록시는 그 <code>ProductMXBean</code> 인수를 <code>ObjectName</code> 에 재차 매핑 합니다. 이것이 기능하는 것은, 인수가 실제로, 같은 <code>MBeanServerConnection</code> 내의 <code>ProductMXBean</code> 에 대응하는 다른 프록시인 경우만입니다. 프록시는, 다른 프록시로부터 반환되는 일이 있습니다 (예를 들어,<code>ModuleMXBean.getProduct()</code> 는 <code>ProductMXBean</code> 용의 프록시를 돌려준다). 또,<A HREF="../../javax/management/JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection, javax.management.ObjectName, java.lang.Class)"><CODE>JMX.newMXBeanProxy</CODE></A>  에 의해 작성되는 일도,<A HREF="../../javax/management/MBeanServerInvocationHandler.html" title="javax.management 안의 클래스"><CODE>MBeanServerInvocationHandler</CODE></A>  또는 서브 클래스인 호출 핸들러를 가지는 <A HREF="../../java/lang/reflect/Proxy.html" title="java.lang.reflect 동안의 클래스"><CODE>Proxy</CODE></A>  를 사용해 작성되는 일도 있습니다. </p>

 <p>2 개(살)이 다른 <code>ObjectName</code> 에 같은 MXBean 가 등록되어 있으면(자), 다른 MXBean 로부터 그 MXBean 에의 참조가 애매하게 됩니다. 이 때문에, MBean Server 에 등록을 마친 MXBean 객체를, 다른 이름으로 같은 MBean Server 에 등록하려고 하면(자),<A HREF="../../javax/management/InstanceAlreadyExistsException.html" title="javax.management 안의 클래스"><CODE>InstanceAlreadyExistsException</CODE></A>  가 throw 됩니다. 일반적으로, 1 개의 MBean 객체를 복수의 이름으로 등록하는 것은 피해 주세요. 특히,<A HREF="../../javax/management/NotificationBroadcaster.html" title="javax.management 안의 인터페이스"><CODE>NotificationBroadcaster</CODE></A>  인 MBean 에서는, 올바르게 동작하지 않습니다. </p>

<h3><a name="composite-map">그 외의 형태의 매핑</a> </h3>

 <p>Java 클래스나 인터페이스 <em>J</em> 가 상기의 겉(표)에 나타낸 그 다른 룰에 들어맞지 않는 경우, 다음에 나타내도록(듯이), MXBean 시스템에 의해 <A HREF="../../javax/management/openmbean/CompositeType.html" title="javax.management.openmbean 안의 클래스"><CODE>CompositeType</CODE></A>  에의 매핑이 시도됩니다. 이 <code>CompositeType</code> 의 형명은, 다음의<a href="#type-names">형명 룰</a>에 따라 결정됩니다. </p>

 <p>취득 메소드의 클래스는,<a href="#naming-conv">상기의 </a>규칙을 사용해 검사됩니다(취득 메소드는 public 인스턴스 메소드가 아니면 안된다). 취득 메소드가 존재하지 않는지, 취득 메소드의 형태가 변환 불가능한 경우,<em>J</em> 는 변환 불가능합니다. </p>

 <p>1 개(살) 이상의 취득 메소드가 존재해, 어느 취득 메소드에도 변환 가능한 형태가 존재하는 경우,<em>opentype(J)</em> 는 각 취득 메소드용의 항목을 1 개 보관 유지하는 <code>CompositeType</code> 입니다. 다음의 취득 메소드의 경우,

    <blockquote>
      <code><em>T</em> get<em>Name</em>()</code>
    </blockquote>

<code>CompositeType</code> 내의 항목은 <code>name</code> 로 불려<em>opentype(T)</em> 형을 가집니다. 예를 들어, 다음의 항목의 경우,

    <blockquote>
      <code>String getOwner()</code>
    </blockquote>

항목은 <code>owner</code> 로 불려 공개형 <code>SimpleType.STRING</code> 를 가집니다. 다음의 취득 메소드의 경우,

    <blockquote>
      <code>boolean is<em>Name</em>()</code>
    </blockquote>

<code>CompositeType</code> 내의 항목은 <code>name</code> 로 불려<code>SimpleType.BOOLEAN</code> 형을 가집니다. </p>

 <p>최초의 문자 (코드 포인트)가, 소문자에 변환되는 것에 유의해 주세요. 이것은 Java Beans 의 규칙에 따르고 있습니다. 역사적인 이유로부터, 이것은 Standard MBean 의 규칙과는 다릅니다. Standard MBean 또는 MXBean 인터페이스에서는 <code>getOwner</code> 메소드는 <code>Owner</code> 라는 이름의 속성을 정의해, Java Bean 또는 맵 된 <code>CompositeType</code> 에서는 <code>getOwner</code> 메소드는 <code>owner</code> 라는 이름의 프로퍼티 또는 항목을 정의합니다. </p>

 <p>2 개의 메소드가 같은 항목명을 생성하는 경우 (<code>getOwner</code> 와 <code>isOwner</code>,<code>getOwner</code> 와 <code>getowner</code> 등), 형태의 변환은 불가능합니다. </p>

 <p>공개형이 <code>CompositeType</code> 의 경우, 대응하는 맵 된 Java 형 (<em>opendata(J)</em>)는 <A HREF="../../javax/management/openmbean/CompositeData.html" title="javax.management.openmbean 안의 인터페이스"><CODE>CompositeData</CODE></A>  가 됩니다. <em>J</em> 의 인스턴스로부터, 상기의 <code>CompositeType</code> 에 대응하는 <code>CompositeData</code> 에의 매핑은, 다음과 같이 실행됩니다. 최초로,<em>J</em> 가 <A HREF="../../javax/management/openmbean/CompositeDataView.html" title="javax.management.openmbean 안의 인터페이스"><CODE>CompositeDataView</CODE></A>  인터페이스를 구현하는 경우, 그 인터페이스의 <A HREF="../../javax/management/openmbean/CompositeDataView.html#toCompositeData(javax.management.openmbean.CompositeType)"><CODE>toCompositeData</CODE></A>  메소드가 불려 가, 변환이 실행됩니다. 그 이외의 경우는, 항목 마다 취득 메소드를 호출해 대응하는 공개 데이터형으로 변환하는 것으로,<code>CompositeData</code> 가 구축됩니다. 이것에 의해, 다음과 같은 취득 메소드가,</p>

    <blockquote>
<code>List&lt;String&gt; getNames()</code>
    </blockquote>

 <p>이름 「<code>names</code>」 및 공개형 <code>ArrayType(1, SimpleType.STRING)</code> 의 항목에 매핑 됩니다. <code>CompositeData</code> 에의 변환에 의해 <code>getNames()</code> 가 불려 가 생성된 <code>List&lt;String&gt;</code> 가 항목 「<code>names</code>」의 <code>String[]</code> 에 변환됩니다. </p>

 <p><code>CompositeData</code> 는 인터페이스입니다. 형태를 공개 데이터로서 표현하는데 사용되는 구상 클래스는,<A HREF="../../javax/management/openmbean/CompositeDataSupport.html" title="javax.management.openmbean 안의 클래스"><CODE>CompositeDataSupport</CODE></A>  또는 <code>CompositeDataSupport</code> 로서 직렬화하는 <code>CompositeData</code> 를 구현하는 다른 클래스입니다. </p>


<h4><code>CompositeData</code> 로부터 Java 형 <em>J</em> 의 인스턴스를 재구축 한다</h4>

 <p><em>opendata(J)</em> 가 Java 형 <em>J</em> 의 <code>CompositeData</code> 인 경우,<em>J</em> 의 인스턴스를 <code>CompositeData</code> 로부터 재구축 가능한가,<em>J</em> 는 재구축 불가능한가의 어딘가에 됩니다. <code>CompositeData</code> 내의 몇개의 항목이 재구축 불가능한 경우,<em>J</em> 도 재구축 불가능합니다. </p>

 <p>지정한 임의의 <em>J</em> 에 관해서,<code>CompositeData</code> 로부터 <em>J</em> 의 인스턴스를 재구축 할 때, 다음의 룰이 적용됩니다. 리스트내에서 적용 가능한 최초의 룰이 사용됩니다. </p>

    <ol>

<li><p><em>J</em> 가<br> <code>public static </code><em>J </em><code>from(CompositeData cd)</code> 메소드를 가지는 경우,<br>그 메소드를 호출하는 것으로 <em>J</em> 의 인스턴스가 재구축 됩니다. </p></li>

<li><p>그 이외로,<em>J</em> 가 <A HREF="../../java/beans/ConstructorProperties.html" title="java.beans 안의 주석"><CODE>ConstructorProperties</CODE></A>  주석을 포함한 1 개(살) 이상의 public 생성자 을 가지는 경우는, 이러한 생성자 의 1 개 (항상 같은 생성자 일 필요는 없다)를 호출해,<em>J</em> 의 인스턴스가 재구축 됩니다. 이러한 모든 주석은, 생성자 이 가지는 파라미터와 동일한 캐릭터 라인을 리스트에 포함할 필요가 있습니다. 각 캐릭터 라인은 <em>J</em> 의 취득 메소드에 대응하는 프로퍼티의 이름으로 합니다. 이 취득 메소드의 형태는, 대응하는 생성자  파라미터와 같게 할 필요가 있습니다. <code>ConstructorProperties</code> 주석에 기술되어 있지 않은 취득 메소드가 존재한다고 해도, 그것은 에러가 아닙니다. 이것들은, 객체의 재구축에는 불필요한 정보에 관련한 메소드일 가능성이 있습니다. </p>

 <p><em>J</em> 의 인스턴스는,<code>CompositeData</code> 로부터 재구축 된 적절한 항목을 사용해 생성자 을 호출하는 것으로 재구축 됩니다. 이 <code>CompositeData</code> 는, 일부의 항목이 존재하고 있지 않았던 이전의 버젼의 <em>J</em> 에 유래하는 것일 가능성이 있습니다. 이 때문에, 불려 가는 생성자 은,<code>CompositeData</code> 내에 실재하는 항목에 근거해 실행시로 결정됩니다. 생성자 이 「적용 가능」이 되는 것은,<code>ConstructorProperties</code> 주석에 기재된 모든 프로퍼티이 <code>CompositeData</code> 내에 항목으로서 존재하는 경우입니다. <em></em>적용 가능한 생성자 이 존재하지 않는 경우는,<em>J</em> 를 재구축 하는 시도는 실패합니다. </p>

 <p>프로퍼티을 임의에 조합하는 경우는, 다음이 있지 않고 가가 들어맞읍니다. (a) 적용 가능한 생성자 이 존재하지 않는, (b) 적용 가능한 생성자 이 1 개만 존재하는, (c) 적용 가능한 생성자 의 1 개가, 다른 적용 가능한 각 생성자 이 지정한 프로퍼티의 적절한 슈퍼 세트를 지정한다. 즉, 선택하는 생성자 에 관해서 애매함은 존재하지 않게 됩니다. 이 조건이 true 가 아닌 경우,<em>J</em> 는 재구축 가능하지는 않습니다. </p></li>

<li><p>그 이외로,<em>J</em> 가 인수의 없는 public 생성자 을 가져, 형태가 <em>T</em> 로 이름이 <em>N</em> 의 <em>J</em> 내의 각 취득 메소드에 대해서 같은 이름과 형태의 대응하는 설정 메소드가 존재하는 경우는,<em>J</em> 의 인스턴스가 인수의 없는 생성자 을 사용해 구축되어 설정 메소드가 <code>CompositeData</code> 로부터 재구축 된 항목을 사용해 불려 가 값이 복원됩니다. 예를 들어,<br><code>public List&lt;String&gt; getNames()</code> 메소드가 존재하는 경우,<br>이 룰이 적용된다<br> <code>public void setNames(List&lt;String&gt; names)</code> 메소드도<br>존재할 필요가 있습니다. </p>

 <p><code>CompositeData</code> 가 <em>J</em> 의 이전의 버젼에 근거하는 경우, 일부의 항목이 존재하지 않을 가능성이 있습니다. 이 경우, 대응하는 설정 메소드는 불려 가지 않습니다. </p></li>

<li><p>그 이외로,<em>J</em> 가 취득 메소드 이외의 메소드를 가지지 않는 인터페이스인 경우,<em>J</em> 의 인스턴스는,<A HREF="../../java/lang/reflect/Proxy.html" title="java.lang.reflect 안의 클래스"><CODE>Proxy</CODE></A>  를 사용해 구축됩니다. 그 때, 변환 대상의 <code>CompositeData</code> 를 이용하는 <A HREF="../../javax/management/openmbean/CompositeDataInvocationHandler.html" title="javax.management.openmbean 동안의 클래스"><CODE>CompositeDataInvocationHandler</CODE></A>  가 사용됩니다. </p></li>

<li><p>그 이외의 경우,<em>J</em> 는 재구축 불가능합니다. </p></li>
    </ol>

 <p>이하의 예에서는,<code>int</code> 및 <code>String</code> 로 구성되는 <code>NamedNumber</code> 형을 코딩 하는 몇개의 방법을 나타냅니다. 어느 경우에서도,<code>CompositeType</code> 는 다음과 같이 됩니다. </p>

    <blockquote>
      <pre>
<A HREF="../../javax/management/openmbean/CompositeType.html" title="javax.management.openmbean 안의 클래스"><CODE>CompositeType</CODE></A> (
    "NamedNumber",                      // typeName
    "NamedNumber",                      // description
    new String[] {"number", "name"},    // itemNames
    new String[] {"number", "name"},    // itemDescriptions
    new OpenType[] {SimpleType.INTEGER,
                    SimpleType.STRING}  // itemTypes
);
      </pre>
    </blockquote>

    <ol>
<li>static <code>from</code> 메소드:

        <blockquote>
          <pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    private NamedNumber(int number, String name) {
        this.number = number;
        this.name = name;
    }
    <b>public static NamedNumber from(CompositeData cd)</b> {
        return new NamedNumber((Integer) cd.get("number"),
                               (String) cd.get("name"));
    }
    private final int number;
    private final String name;
}
          </pre>
        </blockquote>
      </li>

<li><code>&#64;ConstructorProperties</code> 주석을 포함한 public 생성자:

        <blockquote>
          <pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    <b>&#64;ConstructorProperties({"number", "name"})
    public NamedNumber(int number, String name)</b> {
        this.number = number;
        this.name = name;
    }
    private final int number;
    private final String name;
}
          </pre>
        </blockquote>
      </li>

<li>각 취득 메소드용의 설정 메소드:

        <blockquote>
          <pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public void <b>setNumber</b>(int number) {this.number = number;}
    public String getName() {return name;}
    public void <b>setName</b>(String name) {this.name = name;}
    <b>public NamedNumber()</b> {}
    private int number;
    private String name;
}
          </pre>
        </blockquote>
      </li>

<li>취득 메소드만을 가지는 인터페이스:

        <blockquote>
          <pre>
public interface NamedNumber {
    public int getNumber();
    public String getName();
}
          </pre>
        </blockquote>
      </li>
    </ol>

 <p>데이터의 컬렉션을 표현할 뿐(만큼)의 클래스는, 일반적으로, 「불변」으로 해 두는 것을 추천합니다. <em></em>불변 클래스의 인스턴스는, 구축 후로 변경할 수 없습니다. <code>CompositeData</code> 자체는 불변인 것에 유의해 주세요. 불변인 것에는 다수의 이점이 있습니다. 특히 thread의 안전성이나 시큐리티면에서 큰 메리트가 있습니다. 이 때문에, 설정 메소드의 사용은, 가능한 경우는 피하도록 해 주세요. </p>


<h3>재귀형</h3>

 <p>재귀 (자기 참조) 형을 MXBean 인터페이스내에서 사용할 수 없습니다. 이것은,<A HREF="../../javax/management/openmbean/CompositeType.html" title="javax.management.openmbean 안의 클래스"><CODE>CompositeType</CODE></A>  의 불변성에 의하는 것입니다. 예를 들어, 다음의 형태는 자신을 참조하기 위해(때문에), 속성의 형태가 될 수 없습니다. </p>

    <pre>
public interface <b>Node</b> {
public String getName();
public int getPriority();
public <b>Node</b> getNext();
}
</pre>

 <p>이러한 재귀형을 고쳐 써, 재귀형이 아니고 하는 것은 언제라도 가능합니다. 거기에는, 새로운 형태를 도입하는 것이 필요한 경우가 있습니다. 다음에 예를 나타냅니다. </p>

    <pre>
public interface <b>NodeList</b> {
public List&lt;Node&gt; getNodes();
}

public interface Node {
public String getName();
public int getPriority();
}
</pre>

<h3>MXBean 에 대응한 MBeanInfo 의 내용</h3>

 <p>MXBean 는, Open MBean 의 일종입니다. 다만, 호환성을 유지하기 위해(때문에),<A HREF="../../javax/management/MBeanInfo.html" title="javax.management 안의 클래스"><CODE>MBeanInfo</CODE></A>  는 <A HREF="../../javax/management/openmbean/OpenMBeanInfo.html" title="javax.management.openmbean 안의 인터페이스"><CODE>OpenMBeanInfo</CODE></A>  와 다르고 있습니다. 특히, 속성, 파라미터, 오퍼레이션의 반환값의 형태가 <code>int</code> 등의 원시형 또는 <code>void</code> (반환값의 형태)인 경우, 속성, 파라미터, 오퍼레이션은 각각 <A HREF="../../javax/management/MBeanAttributeInfo.html" title="javax.management 안의 클래스"><CODE>MBeanAttributeInfo</CODE></A> ,<A HREF="../../javax/management/MBeanParameterInfo.html" title="javax.management 안의 클래스"><CODE>MBeanParameterInfo</CODE></A> ,<A HREF="../../javax/management/MBeanOperationInfo.html" title="javax.management 안의 클래스"><CODE>MBeanOperationInfo</CODE></A>  로 나타내집니다. 이러한 <code>getType()</code> 또는 <code>getReturnType()</code> 는 프리미티브(primitive)명 (<code>int</code> 등)을 돌려줍니다. 상기의 매핑 룰로,<em>opendata</em> 매핑이 랩 되는 형태 (<code>Integer</code> 등)와 지정되는 경우에서도, 이것은 들어맞읍니다. </p>

 <p>MXBean 의 <A HREF="../../javax/management/MBeanInfo.html#getConstructors()"><CODE>MBeanInfo.getConstructors()</CODE></A>  가 돌려주는 public 생성자 의 배열 (MBean Server 에 직접 등록되기)에는, 그 MXBean 의 public 생성자 이 모두 포함됩니다. MXBean 의 클래스가 public 가 아닌 경우, 생성자 도 public 가 아니다고 보입니다. <A HREF="../../javax/management/StandardMBean.html" title="javax.management 안의 클래스"><CODE>StandardMBean</CODE></A>  클래스를 사용해 구축되는 MXBean 에 대해서 반환되는 리스트는, Standard MBean 와 같은 방법으로 취득됩니다. MXBean 의 구축 방법으로 관계없이, 생성자  파라미터는 MXBean 매핑 룰의 영향을 받지 않고, 대응하는 <code>OpenType</code> 를 가지지 않습니다. </p>

 <p>MBean Server 내에 직접 등록되는 MXBean 가 <A HREF="../../javax/management/NotificationBroadcaster.html" title="javax.management 안의 인터페이스"><CODE>NotificationBroadcaster</CODE></A>  인터페이스를 구현하지 않는 경우, 그 MXBean 의 <A HREF="../../javax/management/MBeanInfo.html#getNotifications()"><CODE>MBeanInfo.getNotifications()</CODE></A>  가 돌려주는 통지형의 배열은 비웁니다. 그 이외의 경우, 이것은, MXBean 의 등록시에 <A HREF="../../javax/management/NotificationBroadcaster.html#getNotificationInfo()"><CODE>NotificationBroadcaster.getNotificationInfo()</CODE></A>  를 호출한 결과가 됩니다. 그 후, 이 메소드의 결과가 바뀌어도,<code>MBeanInfo.getNotifications()</code> 의 결과는 바뀌지 않습니다. <A HREF="../../javax/management/StandardMBean.html" title="javax.management 안의 클래스"><CODE>StandardMBean</CODE></A>  또는 <A HREF="../../javax/management/StandardEmitterMBean.html" title="javax.management 안의 클래스"><CODE>StandardEmitterMBean</CODE></A>  클래스를 사용해 구축되는 MXBean 에 대해서 반환되는 리스트는, Standard MBean 와 같은 방법으로 취득됩니다. </p>

 <p><code>MBeanInfo</code> 에 포함되는 모든 <code>MBeanAttributeInfo</code>,<code>MBeanParameterInfo</code>, 및 <code>MBeanOperationInfo</code> 객체 <A HREF="../../javax/management/Descriptor.html" title="javax.management 중의 인터페이스"><CODE>Descriptor</CODE></A>  는, 상기의 매핑 룰로 지정된 <A HREF="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean 동안의 클래스"><CODE>OpenType</CODE></A>  를 값으로 하는 필드 <code>openType</code> 를 가집니다. 이 때문에,<code>getType()</code> 가 「<code>int</code>」여도,<code>getDescriptor(). getField("openType")</code> 는 <A HREF="../../javax/management/openmbean/SimpleType.html#INTEGER"><CODE>SimpleType.INTEGER</CODE></A>  가 됩니다. </p>

 <p>이러한 각 객체의 <code>Descriptor</code> 도, MXBean 인터페이스내에 표시되는 Java 형을 나타내는 캐릭터 라인인 <code>originalType</code> 필드를 가집니다. 이 캐릭터 라인의 서식에 대해서는, 다음의<a href="#type-names">「형명」</a>을 참조해 주세요. </p>

 <p><code>MBeanInfo</code> 의 <code>Descriptor</code> 는, 캐릭터 라인 「<code>true</code>」를 값으로 하는 <code>mxbean</code> 필드를 가집니다. </p>


<h3><a name="type-names">형명</a> </h3>

 <p>MXBean 내의 메소드 파라미터나 반환값의 맵되어 있지 않은 형태 <em>T</em> 를 캐릭터 라인으로서 표현하는 것이 필요한 경우가 있습니다. <em>T</em> 가 총칭형이 아닌 경우, 이 캐릭터 라인은 <A HREF="../../java/lang/Class.html#getName()"><CODE>Class.getName()</CODE></A>  에 의해 반환되는 값이 됩니다. 그 이외의 경우, 이것은 <em>genericstring(T)</em> 의 값이 됩니다. 다음에 이 정의를 나타냅니다.

    <ul>

<li><em>T</em> 가 총칭형에서도 배열형도 아닌 경우,<em>genericstring(T)</em> 은 <A HREF="../../java/lang/Class.html#getName()"><CODE>Class.getName()</CODE></A>  에 의해 반환되는 값이 됩니다 (<code>"int"</code>,<code>"java.lang.String"</code> 등).

<li><em>T</em> 가 배열 <em>E[]</em> 인 경우,<em>genericstring(T)</em> 은 <em>genericstring(E)</em> 의 후에 <code>"[]"</code> 를 부가한 것이 됩니다. 예를 들어,<em>genericstring(<code>int[]</code>)</em> 은 <code>"int[]"</code>,<em>genericstring(<code>List&lt;String&gt;[][]</code>)</em> 는 <code>"java.util.List&lt;java.lang.String&gt;[][]"</code> 가 됩니다.

<li>그 이외의 경우,<em>T</em> 는,<code>List&lt;String&gt;</code> 등의 파라미터화 된 형태가 됩니다.  <em>genericstring(T)</em> 은<code>Class.getName()</code> 에 의해 반환되는 파라미터화 된 형태의 완전 지정명, 왼쪽산괄호 (<code>"&lt;"</code>),<em>genericstring(A)</em> (<em>A</em> 는 최초의 형태 파라미터), 2 번째의 형태 파라미터 <em>B</em> 가 존재하는 경우는 <code>", "</code> (콤마와 공백 문자 1 개(살))라고 <em>genericstring(B)</em>, 및 우야마 괄호 (<code>"&gt;"</code>)로 구성됩니다.

    </ul>

 <p>메소드가 <code>int[]</code> 를 돌려주는 경우는, 이것은,<code>Class.getName()</code> 에 의해 반환되는 캐릭터 라인 <code>"[I"</code> 로 나타내집니다. 다만, 메소드가 <code>List&lt;int[]&gt;</code> 를 돌려주는 경우, 이것은 캐릭터 라인 <code>"java.util.List&lt;int[]&gt;"</code> 로 나타내집니다.

<h3>예외</h3>

 <p>Java 형으로부터 공개형에의 매핑으로 문제가 발생하면(자),<A HREF="../../javax/management/openmbean/OpenDataException.html" title="javax.management.openmbean 안의 클래스"><CODE>OpenDataException</CODE></A>  에 의해 통지됩니다. <em></em><em></em>이것은, 취득 메소드를 가지지 않는 <A HREF="../../java/util/Random.html" title="java.util 동안의 클래스"><CODE>java.util.Random</CODE></A>  등의 형태를 참조하는 경우 등, MXBean 인터페이스의 분석중에 발생하는 일이 있습니다. 또, 인스턴스의 변환중 (MXBean 내의 메소드로부터의 반환값 또는 MXBean 프록시내의 메소드에의 파라미터)에 발생하는 일도 있습니다. 예를 들어,<code>SortedSet</code> 가 null 이외의 <code>Comparator</code> 를 가지는 경우에,<code>SortedSet&lt;String&gt;</code> 로부터 <code>String[]</code> 로 변환할 때 발생합니다. </p>

 <p>공개형으로부터 Java 형에의 매핑으로 문제가 발생하면(자),<A HREF="../../java/io/InvalidObjectException.html" title="java.io 안의 클래스"><CODE>InvalidObjectException</CODE></A>  에 의해 통지됩니다. <em></em><em></em>이것은, 재구축 가능한 형태가 필수의 문맥으로, 상기의 룰에 따르면(자) 「재구축 가능」이 아닌 형태를 참조하는 경우 등, MXBean 인터페이스의 분석중에 발생하는 일이 있습니다. <em></em>또, 해당하는 이름의 Enum 정수가 존재하지 않는 상황으로 String 로부터 Enum 에의 변환을 실시하는 경우와 같이, 인스턴스의 변환중 (MXBean 내의 메소드에의 파라미터 또는 MXBean 프록시내의 메소드로부터의 반환값)에 발생하는 일도 있습니다. </p>

 <p>문맥에 응해,<code>OpenDataException</code> 또는 <code>InvalidObjectException</code> 를,<A HREF="../../javax/management/RuntimeMBeanException.html" title="javax.management 안의 클래스"><CODE>RuntimeMBeanException</CODE></A>  나 <A HREF="../../java/lang/reflect/UndeclaredThrowableException.html" title="java.lang.reflect 안의 클래스"><CODE>UndeclaredThrowableException</CODE></A>  등의 다른 예외내에 랩 할 수 있습니다. throw 되는 예외 각각으로, 조건 <em>C</em> 가 true 가 됩니다. "<em>e</em> 는 <code>OpenDataException</code> 와 <code>InvalidObjectException</code> 의 언젠가 적절한 (분)편입니다. 또,<em>C</em> 는 <em>e</em>. <A HREF="../../java/lang/Throwable.html#getCause()"><CODE>getCause()</CODE></A> " 의 true 입니다. </p>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
<HR>

<P>
<!-- =========== ANNOTATION TYPE OPTIONAL MEMBER SUMMARY =========== -->

<A NAME="annotation_type_optional_element_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>임의 요소의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/management/MXBean.html#value()">value</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;주석 첨부 인터페이스가 MXBean 인터페이스인 경우, true 가 됩니다. </TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="value()"><!-- --></A> <H3>
value</H3>
<PRE>
public abstract boolean <B>value</B></PRE>
<DL>
<DD>주석 첨부 인터페이스가 MXBean 인터페이스인 경우, true 가 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>주석 첨부 인터페이스가 MXBean 인터페이스인 경우는 true</DL>
<DL>
<DT><B>디폴트:</B><DD>true</DD>
</DL>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/MXBean.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/management/MBeanTrustPermission.html" title="javax.management 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/management/NotCompliantMBeanException.html" title="javax.management 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/management/MXBean.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="MXBean.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;필수 &nbsp;|&nbsp;<A HREF="#annotation_type_optional_element_summary">옵션</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#annotation_type_element_detail">요소</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
