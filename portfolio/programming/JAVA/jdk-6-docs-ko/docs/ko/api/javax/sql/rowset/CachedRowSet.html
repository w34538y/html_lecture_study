<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:04:53 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
CachedRowSet (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="CachedRowSet (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/CachedRowSet.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/sql/rowset/BaseRowSet.html" title="javax.sql.rowset 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/sql/rowset/FilteredRowSet.html" title="javax.sql.rowset 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/sql/rowset/CachedRowSet.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="CachedRowSet.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.sql.rowset</FONT>
<BR>
인터페이스 CachedRowSet</H2>
<DL>
<DT><B>모든 슈퍼 인터페이스:</B> <DD><A HREF="../../../javax/sql/rowset/Joinable.html" title="javax.sql.rowset 내의 인터페이스">Joinable</A> , <A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A> , <A HREF="../../../javax/sql/RowSet.html" title="javax.sql 안의 인터페이스">RowSet</A> , <A HREF="../../../java/sql/Wrapper.html" title="java.sql 안의 인터페이스">Wrapper</A> </DD>
</DL>
<DL>
<DT><B>기존의 서브 인터페이스의 일람:</B> <DD><A HREF="../../../javax/sql/rowset/FilteredRowSet.html" title="javax.sql.rowset 내의 인터페이스">FilteredRowSet</A> , <A HREF="../../../javax/sql/rowset/JoinRowSet.html" title="javax.sql.rowset 안의 인터페이스">JoinRowSet</A> , <A HREF="../../../javax/sql/rowset/WebRowSet.html" title="javax.sql.rowset 안의 인터페이스">WebRowSet</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public interface <B>CachedRowSet</B><DT>extends <A HREF="../../../javax/sql/RowSet.html" title="javax.sql 내의 인터페이스">RowSet</A> , <A HREF="../../../javax/sql/rowset/Joinable.html" title="javax.sql.rowset 안의 인터페이스">Joinable</A> </DL>
</PRE>

<P>
<code>CachedRowSet</code> 의 모든 표준 구현이 구현해야 하는 인터페이스입니다.  &nbsp;<P>
Sun Microsystems 로부터 제공된 <code>CachedRowSet</code> 인터페이스의 레퍼런스 구현은, 표준 구현입니다. 개발자는 이것을 그대로 사용하는 일도, 확장하는 일도, 또는 이 인터페이스의 구현을 독자적으로 작성할 수도 있습니다.  &nbsp;<P>
<code>CachedRowSet</code> 객체는, 메모리내에 행을 캐쉬하는, 데이터행의 컨테이너이며, 항상 그 데이터 소스에 접속하고 있지 않아도 처리를 실행할 수 있습니다. 또, 스크롤, 갱신, 직렬화가 가능한 JavaBeans<sup><font size="-2">TM</font></sup> 컴퍼넌트입니다. <code>CachedRowSet</code> 객체에는, 일반적으로, 결과 세트의 행이 포함됩니다만, 스프레드쉬트 등, 겉(표) 형식의 모든 파일의 행을 포함할 수도 있습니다. 레퍼런스 구현은,<code>ResultSet</code> 객체로부터의 데이터의 취득 밖에 지원합니다만, 개발자는, 그 외의 겉(표) 형식의 데이터 소스에 액세스 할 수 있도록(듯이),<code>SyncProvider</code> 구현을 확장할 수가 있습니다.  &nbsp;<P>
어플리케이션은,<code>CachedRowSet</code> 객체내의 데이터를 변경할 수 있습니다.  이러한 변경은, 데이터 소스에도 반영됩니다.  &nbsp;<P>
<code>CachedRowSet</code> 객체는 「미접속의」행 세트입니다.  즉, 데이터 소스와의 접속을 조금 밖에 이용하지 않습니다. <code>CachedRowSet</code> 객체가 데이터 소스에 접속하는 것은, 데이터를 읽어내 자신에게 행을 읽어들일 때와 부하의 데이터 소스로 변경 내용을 반영할 때 뿐입니다. 그 이외 때는, 데이터의 변경중도 포함해, 데이터 소스로부터 절단 되고 있습니다. <code>RowSet</code> 객체는, 이와 같이, 데이터 소스로부터 절단 되고 있기 (위해)때문에 헛일이 적고, 그 외의 컴퍼넌트에 건네주기 쉬워지고 있습니다. 예를 들어, 미접속의 <code>RowSet</code> 객체를 직렬화해, 회선 경유로 PDA 등의 thin 클라이언트에 건네줄 수가 있습니다.  &nbsp;<P>

<h3>1.0<code>CachedRowSet</code> 객체의 작성</h3>
다음의 코드는, 레퍼런스 구현 (RI)의 <code>CachedRowSet</code>의 디폴트 생성자 을 사용해, 디폴트의 <code>CachedRowSet</code>객체를 작성합니다.
 <PRE>
     CachedRowSetImpl crs = new CachedRowSetImpl() ;k
 </PRE>
이 새로운 <code>CachedRowSet</code>객체는, 그 프로퍼티을 <code>BaseRowSet</code>객체의 디폴트의 프로퍼티으로 설정합니다.  게다가 동기 프로바이더로서 <code>RIOptimisticProvider</code>객체를 가집니다. RI 에 포함되는 2 개의 <code>SyncProvider</code>구현 가운데 1 개,<code>RIOptimisticProvider</code>는, 동기 프로바이더가 지정되어 있지 않은 경우에 <code>SyncFactory</code>싱글 톤으로부터 제공되는 디폴트의 프로바이더입니다.  &nbsp;<P>
<code>SyncProvider</code> 객체는,<code>CachedRowSet</code> 객체와 데이터 소스로부터 데이터를 읽어내 자신에게 데이터를 읽어들이는 리더 (<code>RowSetReader</code> 객체)를 제공합니다. 리더를 구현하는 것으로써,<code>ResultSet</code> 객체나 겉(표) 형식의 파일로부터 데이터를 읽어낼 수가 있습니다. <code>SyncProvider</code> 객체는, 라이터(<code>RowSetWriter</code> 객체)도 제공합니다.  라이터는, 부하의 데이터 소스내의 데이터로부터 절단 되고 있는 동안에 <code>CachedRowSet</code> 객체에 더해진 변경 내용을 동기 합니다.  &nbsp;<P>
라이터를 구현하는 것으로써, 다양한 레벨로, 행 세트에 값을 읽어들인 후에 데이터 소스내의 값이 변경되었을 경우에 발생하는 경합의 체크나 예방을 실시할 수가 있습니다. RIOptimisticProvider</code> 구현은, 경합이 거의 없는지, 전혀 없는 것으로서 락을 일절 설정하지 않습니다. 이 구현은, 경합이 없는 경우에게만,<code>CachedRowSet</code> 객체의 값으로 데이터 소스를 갱신합니다. 변경된 데이터를 데이터 소스에 기입하는 목적에서만 구현되는 라이터도 있습니다.  이 구현은, 경합의 체크를 실시하지 않는가, 그 완전히 역으로, 데이터 소스내의 데이터의 변경을 충분히 막을 수 있을 뿐(만큼)의 락을 설정하는 것에 의해 행해집니다. 또, 그 거의 중간의 라이터 구현도 있습니다.  &nbsp;<P>
<code>CachedRowSet</code> 객체는,<code>SyncFactory</code> 싱글 톤에 등록된 임의의 <code>SyncProvider</code> 구현을 사용할 수 있습니다. 어플리케이션은, 다음의 코드를 호출하는 것으로, 등록되어 있는 <code>SyncProvider</code> 구현을 검출할 수 있습니다.
 <PRE>
      java.util.Enumeration providers = SyncFactory.getRegisteredProviders();
 </PRE>
 <P>
<code>CachedRowSet</code> 객체로 사용하는 <code>SyncProvider</code>객체를 지정하는 방법은, 다음의 2 대로입니다.
<UL)
     <LI>생성자 에 구현명을 제공한다<br>다음의 코드는, 디폴트 값 (다만 <code>SyncProvider</code> 를 지정)로 초기화되는 <code>CachedRowSet</code> 객체 <i>crs2</i> 를 작성합니다.
     <PRE>
          CachedRowSetImpl crs2 = new CachedRowSetImpl(
                                 "com.fred.providers.HighAvailabilityProvider");
     </PRE>
<LI><code>CachedRowSet</code> 메소드 <code>setSyncProvider</code>를 사용해 <code>SyncProvider</code> 를 설정한다<br>다음의 코드는,<i>crs</i> 의 <code>SyncProvider</code> 객체 (디폴트의 생성자 으로 작성된 <code>CachedRowSet</code> 객체)를 리셋 합니다.  
      <PRE>
           crs.setSyncProvider("com.fred.providers.HighAvailabilityProvider");
      </PRE>
</UL)
 See the comments for 상세한 것에 대하여는 <code>SyncFactory</code>및 <code>SyncProvider</code>를 참조해 주세요.

 <P>
<h3>2.0<code>CachedRowSet</code> 객체로부터의 데이터의 취득</h3>
데이터는,<code>ResultSet</code>인터페이스로부터 상속된 취득 메소드를 사용해,<code>CachedRowSet</code>객체로부터 취득됩니다. 다음의 예는,<code>crs</code>를 <code>CachedRowSet</code>객체로서 행의 반복 처리를 실시해, 각 행으로부터 열의 값을 취득하는 방법을 나타냅니다. 최초의 예에서는, 열번호를 취하는 취득 메소드를 사용합니다.  2 번째의 예에서는, 렬명을 취하는 취득 메소드를 사용합니다. 열번호는, 일반적으로,<code>RowSet</code>객체의 커멘드가 <code>SELECT * FROM TABLENAME</code>의 형식이 되는 경우에 사용됩니다.  렬명은, 렬명을 지정하는 커멘드로 자주(잘) 사용됩니다.
 <PRE>
    while (crs.next()) {
        String name = crs.getString(1);
        int id = crs.getInt(2);
        Clob comment = crs.getClob(3);
        short dept = crs.getShort(4);
        System.out.println(name + "  " + id + "  " + comment + "  " + dept);
    }
 </PRE>

 <PRE>
    while (crs.next()) {
        String name = crs.getString("NAME");
        int id = crs.getInt("ID");
        Clob comment = crs.getClob("COM");
        short dept = crs.getShort("DEPT");
        System.out.println(name + "  " + id + "  " + comment + "  " + dept);
    }
 </PRE>
<h4>3.0<code>RowSetMetaData</code> 의 취득</h4>
어플리케이션은,<code>RowSetMetaData</code>객체상에 <code>ResultSetMetaData</code>메소드와 <code>RowSetMetaData</code>메소드를 호출하는 것으로,<code>CachedRowSet</code>객체내의 열에 관한 정보를 취득할 수 있습니다. 다음의 코드의 발췌에서는,<i>crs</i>를 <code>CachedRowSet</code>객체로서 이 처리에 대해 설명합니다. 1 행 째로는,<i>crs</i>내의 열에 관한 정보를 가지는 <code>RowSetMetaData</code>객체를 작성합니다. <code>ResultSet</code>인터페이스로부터 상속된 <code>getMetaData</code>메소드는,<code>ResultSetMetaData</code>객체를 돌려줍니다.  반환된 객체는, 변수 <i>rsmd</i>에 할당할 수 있기 전에 <code>RowSetMetaData</code>객체에 캐스트 됩니다. 2 행 째로는,<i>jrs</i>의 렬수를 확인합니다.  3 행 째로는,<code>jrs</code>의 2 번째의 열에 포함된 값의 JDBC 형을 가져옵니다.
 <PRE>
     RowSetMetaData rsmd = (RowSetMetaData) crs.getMetaData();
     int count = rsmd.getColumnCount();
     int type = rsmd.getColumnType(2);
 </PRE>
<code>RowSetMetaData</code>인터페이스는, 다음의 2 개의 점으로써,<code>ResultSetMetaData</code>인터페이스와는 다릅니다.
 <UL>
<LI><code>설정</code>메소드를 포함한:<code>RowSet</code> 객체는, 다른 <code>ResultSet</code>객체의 데이터를 읽어들일 때, 이러한 메소드를 내부에서 사용합니다.
   <P>
<LI>포함되는<code>취득</code>메소드의 수가 적은:일부의 <code>ResultSetMetaData</code> 메소드는 <code>RowSet</code> 객체에는 적용되지 않습니다. 예를 들어, 열의 값이 기입해 가능한가 읽기 전용인지를 확인하는 메소드는 적용되지 않습니다.  이것은,<code>RowSet</code> 객체의 모든 열은, 행 세트의 갱신이 가능한 경우는 기입해 가능, 행 세트의 갱신을 할 수 없는 경우는 읽어내 전용이기 때문입니다.          
 </UL>
주:<code>RowSetMetaData</code>객체를 돌려주기 위해서(때문에)는, 구현으로 <code>java.sql.ResultSet</code>에 정의된 <code>getMetaData()</code>메소드를 오버라이드(override) 해,<code>RowSetMetaData</code>객체를 돌려줄 필요가 있습니다.

<h3><code>CachedRowSet</code> 객체의 갱신</h3>
<code>CachedRowSet</code>객체의 갱신 방법은 <code>ResultSet</code>객체의 갱신 방법과 같습니다만, 갱신중, 행 세트는 데이터 소스에 접속하고 있지 않았기 때문에, 부하의 데이터 소스로 변경을 더하는 추가 순서가 필요하게 됩니다. <code>CachedRowSet</code>객체는,<code>updateRow</code>메소드나 <code>insertRow</code>메소드를 호출한 뒤,<code>acceptChanges</code>메소드를 호출해, 갱신 내용을 데이터 소스에 기입할 필요가 있습니다. 다음의 예에서는,<code>CachedRowSet</code>객체 <i>crs</i>내의 행에 커서가 놓여져 있습니다.  이 코드는, 현재의 행의 2 개의 열의 값을 갱신해,<code>RowSet</code>객체의 부하의 데이터 소스를 갱신합니다.
 <PRE>
     crs.updateShort(3, 58);
     crs.updateInt(4, 150000);
     crs.updateRow();
     crs.acceptChanges();
 </PRE>
 <P>
다음의 예에서는, 삽입행으로 이동해, 삽입행 위에 새로운 행을 작성해, 이것을 행 세트에 삽입합니다.  게다가<code>acceptChanges</code> 메소드를 호출해, 부하의 데이터 소스에 새로운 행을 추가합니다. 취득 메소드의 경우와 같게, 갱신 메소드에서도, 열인덱스나 렬명을 사용해 처리 대상의 열을 지정할 수 있습니다.
 <PRE>
     crs.moveToInsertRow();
     crs.updateString("Name", "Shakespeare");
     crs.updateInt("ID", 10098347);
     crs.updateShort("Age", 58);
     crs.updateInt("Sal", 150000);
     crs.insertRow();
     crs.moveToCurrentRow();
     crs.acceptChanges();
 </PRE>
 <P>
주:<code>insertRow()</code> 메소드로,<code>CachedRowSet</code> 객체의 삽입행의 내용을 삽입하는 장소는, 구현으로 정의합니다. <code>CachedRowSet</code> 인터페이스의 레퍼런스 구현은, 현재의 행의 직후에 새로운 행을 삽입합니다만, 다른 임의의 개소에도 삽입하도록(듯이) 구현할 수 있습니다.  &nbsp;<P>
이러한 예에 있어서의 <code>acceptChanges</code> 메소드의 사용 방법에 주목해 주세요. 이 메소드는,<code>RowSet</code> 객체의 라이터를 내부에서 호출해, 데이터 소스로 변경을 기입하는 것으로,<code>CachedRowSet</code> 객체내의 변경 내용을 부하의 데이터 소스에 전달합니다. 이 때문에, 라이터는, 데이터 소스와의 접속을 확립하지 않으면 안됩니다. 최초의 2 개의 코드의 발췌는,<code>updateRow</code> 또는 <code>insertRow</code> 의 호출 후 즉시 <code>acceptChanges</code> 메소드를 호출합니다. 그러나, 복수의 행을 변경하는 경우는, <code>updateRow</code> 와 <code>insertRow</code> 의 호출이 모두 완료하고 나서 <code>acceptChanges</code> 를 호출하는 방법 쪽이 효율이 좋아집니다. <code>acceptChanges</code> 를 1 회 밖에 호출하지 않는 경우는, 접속을 1 개 확립하는 것만으로 끝납니다.  &nbsp;<P>
<h3>4.0 부하의 데이터 소스의 갱신</h3>
<code>acceptChanges</code>메소드의 실행시에는, 행 세트에의 변경점을 부하의 데이터 소스에 기입하기 (위해)때문에, 배후에서 <code>CachedRowSet</code>객체의 라이터,<code>RowSetWriterImpl</code>객체가 불려 갑니다. 이 라이터가 구현되는 것으로, 데이터 소스에의 접속이 확립되어 갱신 정보가 기입해집니다.  &nbsp;<P>
라이터는, 섹션 1 의 「<code>CachedRowSet</code> 객체의 작성」으로 설명했던 대로,<code>SyncProvider</code> 인터페이스의 구현을 개입시켜 이용할 수 있습니다. 디폴트의 레퍼런스 구현 프로바이더 <code>RIOptimisticProvider</code> 는, 오프티미스틱 동시성 처리 제어 기구를 이용하기 위해(때문에), 라이터를 구현하고 있습니다. 즉, 행 세트가 데이타베이스로부터 절단 되고 있는 동안, 부하의 데이타베이스는 락 되지 않고, 데이터 소스에 데이터를 기입하기 전에 경합이 있는지 없는지의 확인을 하게만 됩니다. 경합이 있는 경우, 데이터 소스에는 아무것도 기입해지지 않습니다.  &nbsp;<P>
<code>SyncProvider</code> 클래스에 의해 제공되는 리더/라이터의 기능은, 플러그 인 가능하고, 데이터의 취득과 갱신의 커스터마이즈에 이용할 수 있습니다. 다른 동시성 처리 제어 기구가 필요한 경우는,<code>setSyncProvider</code> 메소드를 사용해, 다른 <code>SyncProvider</code> 구현을 플러그 인 할 수 있습니다.  &nbsp;<P>
오프티미스틱 동시성 처리 제어 루틴을 사용하기 위해(때문에),<code>RIOptismisticProvider</code> 는, 현재의 값과 원의 값 (현재의 값의 직전의 값)의 양쪽 모두를 보관 유지합니다. <code>RowSet</code> 객체내의 데이터가 변경되지 않았던 경우, 현재의 값과 원의 값은 동일 (<code>RowSet</code> 객체가 최초로 생성되었을 때의 값)이 됩니다. 그러나,<code>RowSet</code> 객체내의 값이 변경되었을 경우, 현재의 값과 원의 값은 일치하지 않습니다.  이 단계에서는, 원의 값은 초기치인 채입니다. 그 후의 <code>RowSet</code> 객체내의 데이터의 변경에 의해, 원의 값과 현재의 값은 일치하지 않게 됩니다만, 이전 현재의 값이었던 값이 원의 값이 됩니다.  &nbsp;<P>
원의 값을 추적하는 것으로, 라이터는,<code>RowSet</code> 객체의 원의 값과 데이타베이스내의 값을 비교할 수 있습니다. 데이타베이스내의 값이 <code>RowSet</code> 객체의 원의 값과 일치하지 않는 경우, 데이타베이스내의 값이 변경되고 있어 경합이 발생하고 있는 것을 의미합니다. 라이터를 사용해 경합의 체크를 실시하는지, 어느 정도까지 체크를 실시하는지, 경합을 어떻게 처리할까는, 모두 구현에 따라서 다릅니다.  &nbsp;<P>
<h3>5.0 청취자의 등록과 통지</h3>
JavaBeans 컴퍼넌트이므로, 모든 행 세트는,<code>BaseRowSet</code>클래스로부터 청취자의 등록이라고 변경 내용을 통지하기 위한 메소드를 상속해, JavaBeans 이벤트 모델에 참여 합니다. <code>CachedRowSet</code>객체의 청취자는, 행 세트내로 변경이 있었는지의 여부를 통지되는 컴퍼넌트입니다. 예를 들어,<code>CachedRowSet</code>객체에 쿼리의 결과가 포함되어 이러한 결과가 겉(표)나 막대 그래프로서 표시된다고 합니다.  겉(표)나 막대 그래프는, 행 세트의 청취자로서 등록되는 것으로, 변경 내용을 반영하도록(듯이) 자신의 갱신을 실시할 수가 있습니다. 겉(표)나 막대 그래프의 클래스가 청취자가 되려면 ,<code>RowSetListener</code>인터페이스를 구현할 필요가 있습니다. 그 후, 이것들을 <code>CachedRowSet</code>객체의 청취자의 리스트에 추가합니다.  다음의 코드를 참조해 주세요.
 <PRE>
    crs.addRowSetListener(table);
    crs.addRowSetListener(barGraph);
 </PRE>
커서를 이동하거나 데이터를 변경하거나 하는 <code>CachedRowSet</code>메소드도, 등록을 마친 청취자로 변경을 통지합니다.  따라서,<code>crs</code>내로 변경이 있으면(자),<code>table</code>와 <code>barGraph</code>는 그 통지를 받습니다.  &nbsp;<P>
<h3>6.0 thin 클라이언트에의 데이터의 송신</h3>
<code>CachedRowSet</code>객체는, 주로, 어플리케이션 컴퍼넌트간에서의 데이터의 수수에 이용됩니다. <code>CachedRowSet</code>객체는 직렬화 가능해서, 예를 들어, 서버 환경에서 가동중의 엔터프라이즈 JavaBeans 컴퍼넌트에 의해 실행된 쿼리의 결과를, Web 브라우저로 가동중의 클라이언트에, 네트워크 경유로 송신하기 위해서 이용할 수가 있습니다.  &nbsp;<P>
미접속의 <code>CachedRowSet</code> 객체는, 같은 데이터를 가지는 <code>ResultSet</code> 객체보다 컴팩트해서, 자원의 제한이나 시큐리티상의 이유에 의해 JDBC 드라이버를 사용하는 것이 어려운 PDA 등의 thin 클라이언트에의 데이터 송신에 최적입니다. 이와 같이,<code>CachedRowSet</code> 객체에서는, JDBC API 를 완전하게 구현하지 않아도 행을 취득할 수 있습니다.  &nbsp;<P>
<h3>7.0 스크롤과 갱신</h3>
<code>CachedRowSet</code>객체에는, 스크롤 기능이나 갱신 기능을 가지지 않는 <code>ResultSet</code>객체에 이러한 기능을 제공하는 기능도 있습니다. DBMS 가 스크롤과 갱신의 기능을 완전하게 지원하지 않는 경우는,<code>CachedRowSet</code>객체를 사용해, JDBC 테크놀러지를 사용 가능한 드라이버의 기능을 향상시킬 수가 있습니다. 스크롤 기능을 가지지 않는 읽기 전용의 <code>ResultSet</code>객체에 스크롤 기능과 갱신 기능을 갖게하려면 ,<code>CachedRowSet</code>객체를 작성해, 그 <code>ResultSet</code>객체의 데이터를 읽어들이는 것만으로 끝납니다. 구체적인 예에 대해서는, 다음의 코드의 발췌를 참조해 주세요.  이 예에서는,<code>stmt</code>는 <code>Statement</code>객체를 나타냅니다.
 <PRE>
    ResultSet rs = stmt.executeQuery("SELECT * FROM EMPLOYEES");
    CachedRowSetImpl crs = new CachedRowSetImpl() ;k
    crs.populate(rs);
 </PRE>
 <P>
<code>rs</code> 객체의 경우와 같게,<code>crs</code> 객체에, 겉(표) <code>EMPLOYEES</code> 의 데이터가 추가됩니다. 다만,<code>crs</code> 의 커서는 전방, 후방, 또는 특정의 행으로 이동할 수 있는데 대해,<code>rs</code> 의 커서는 전방 밖에 이동할 수 없습니다. 또,<code>crs</code> 에 갱신 기능이 있는데 대해,<code>rs</code> 에는 갱신 기능은 없습니다.  이것은,<code>CachedRowSet</code> 객체에, 스크롤 기능과 갱신 기능이 디폴트로 준비되어 있기 때문입니다.  &nbsp;<P>
즉,<code>CachedRowSet</code> 객체는, 데이터 소스의 외부에서 캐쉬되는 미접속의 행이 됩니다. 사이즈가 작고, 직렬화 가능해서, 회선 경유로 간단하게 송신 가능할 뿐만 아니라, thin 클라이언트에의 데이터 송신에도 적합합니다. 다만, 메모리내에 동시에 포함할 수 있는 데이터량이 정해져 있기 (위해)때문에,<code>CachedRowSet</code> 객체의 사이즈는 제한되고 있습니다.  &nbsp;<P>
<h3>8.0 범용 데이터 액세스의 취득</h3>
<code>CachedRowSet</code>클래스에는, RDB 이외의 소스로부터 데이터를 취득해, 포함할 수 있다고 하는 이점이 있습니다. 행 세트의 리더를 구현하는 것으로써, 임의의 겉(표) 형식의 데이터 소스 (스프레드쉬트, 플랫 파일을 포함한다) 행 세트의 데이터를 읽어내, read 할 수 있습니다. <code>CachedRowSet</code>객체와 그 메타데이타는, 모두 제로로부터 작성 가능해서, 행 세트의 팩토리로서 기능하는 컴퍼넌트는, 이 기능을 이용해, 비 SQL 데이터 소스로부터 데이터를 포함한 행 세트를 작성할 수 있습니다. 그러나, 대부분의 경우,<code>CachedRowSet</code>객체는, JDBC API 를 사용해 SQL 데이타베이스로부터 취득한 데이터를 포함합니다.  &nbsp;<P>
<h3>9.0 프로퍼티의 설정</h3>
모든 행 세트는, 프로퍼티세트를 가지고 있습니다.  이 세트는 일반적으로, 툴을 사용해 설정합니다. 행 세트의 프로퍼티의 수와 종류는, 행 세트의 기능과 데이터의 취득 방법에 따라서 다릅니다. 예를 들어,<code>ResultSet</code> 객체로부터 데이터를 취득하는 행 세트는, 데이타베이스 접속을 작성하기 위해서 필요한 프로퍼티을 설정할 필요가 있습니다. <code>행 세트가 <code>DriverManager</code>기능을 사용해 접속을 작성하는 경우는, 적절한 드라이버를 식별하는 JDBC URL 의 프로퍼티과 사용자명과 패스워드를 지정하는 프로퍼티을 설정할 필요가 있습니다. 한편, 행 세트가 <code>DataSource</code> 객체를 사용해 접속을 작성하는 경우 (이 방법이 우선된다)는, JDBC URL 의 프로퍼티을 설정할 필요는 없습니다. 대신에, 데이터 소스의 논리명의 프로퍼티과 사용자명 및 패스워드의 프로퍼티을 설정할 필요가 있습니다.  &nbsp;<P>
주:<code>DataSource</code> 객체를 사용해 접속을 작성하는 경우는, Java Naming and Directory Interface<sup><font size=-2>TM</font></sup> (JNDI) API 를 사용하는 네임 서비스에,<code>DataSource</code> 객체를 등록할 필요가 있습니다. 등록은 일반적으로, 시스템 관리 책임자가 실시합니다.  &nbsp;<P>
행 세트에 데이타베이스의 데이터를 읽어들이려면 , 커멘드 프로퍼티을 설정할 필요가 있습니다. 이 프로퍼티은,<code>PreparedStatement</code> 객체를 나타내는 쿼리입니다.  이것에 의해, 쿼리는, 설계시는 아니고 실행시로 설정되는 파라미터 플레이스홀더를 가질 수가 있습니다. 이러한 플레이스홀더 파라미터에 값을 설정하기 위해(때문에), 행 세트는, 각 데이터형의 값을 설정하는 설정 메소드를 제공합니다.  이러한 설정 메소드는,<code>PreparedStatement</code> 인터페이스에 의해 제공되는 설정 메소드와 자주(잘) 닮았습니다.  &nbsp;<P>
다음의 코드의 발췌는,<code>CachedRowSet</code> 객체 <code>crs</code> 에 커멘드 프로퍼티을 설정하는 방법을 나타내고 있습니다. 툴을 사용해 프로퍼티을 설정하는 경우, 이 코드를 사용합니다.
 <PRE>
    crs.setCommand("SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS " +
                   "WHERE CREDIT_LIMIT > ? AND REGION = ? ");
 </PRE>
 <P>
커멘드의 플레이스홀더 파라미터의 설정에 사용되는 값은,<code>RowSet</code> 객체의 <code>params</code> 필드에,<code>Vector</code> 객체로서 포함됩니다. <code>CachedRowSet</code> 클래스는,<code>params</code> 필드내의 요소를 설정하는 설정 메소드세트를 제공합니다. 다음의 코드의 발췌는, 방금전의 예로, 쿼리 안의 2 개의 파라미터를 설정하는 방법을 나타내고 있습니다.
 <PRE>
    crs.setInt(1, 5000);
    crs.setString(2, "West");
 </PRE>
 <P>
<code>params</code> 필드에 2 개의 요소가 추가되었습니다.  이것들은 각각, 요소 2 개(살) 분의 길이의 배열이 됩니다.  최초의 요소는 파라미터 번호, 2 번째의 요소는 설정하는 값을 나타냅니다. 이 경우,<code>params</code> 의 최초의 요소는 <code>1</code>,<code>5000</code>, 2 번째의 요소는 <code>2</code>,<code>"West"</code> 가 됩니다. 어플리케이션은,<code>execute</code> 메소드를 호출하는 것으로, 이 <code>RowSet</code> 객체의 리더를 호출합니다.  이것에 의해, 그 <code>readData</code> 메소드가 불려 갑니다. 이 구현에 포함되는 <code>readData</code> 는,<code>params</code> 내의 값을 취득해, 이것들을 사용해 커멘드의 플레이스홀더 파라미터를 설정합니다. 이하의 코드의 발췌에서는,<code>Connection</code> 객체 <code>con</code> 의 취득 후에, 리더가 플레이스홀더 파라미터를 설정하는 순서를 나타냅니다.
 <PRE>
    PreparedStatement pstmt = con.prepareStatement(crs.getCommand());
    reader.decodeParams();
    // decodeParams figures out which setter methods to use and does something
    // like the following:
    //    for (i = 0; i < params.length; i++) {
    //        pstmt.setObject(i + 1, params[i]);
    //    }
 </PRE>
 <P>
이 시점에서,<code>crs</code> 의 커멘드는, 쿼리 <code>"SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS WHERE CREDIT_LIMIT &gt; 5000 AND REGION = "West"</code> 가 됩니다. <code>readData</code> 메소드는, 다음의 코드로 이 커멘드를 실행하는 것으로써,<code>crs</code> 에 읽히는 <code>rs</code> 의 데이터를 가져옵니다.
 <PRE>
     ResultSet rs = pstmt.executeQuery();
 </PRE>
 <P>
전의 코드의 발췌에서는, 배후에서 행해지는 처리에 대해 설명했습니다.  이러한 코드는, 어플리케이션내에서는 비표시이며,<code>readData</code> 나 <code>decodeParams</code> 등의 메소드를 호출하지 않습니다. 이것에 대해서, 이하의 코드의 발췌는, 어플리케이션의 실행 내용을 나타내고 있습니다.  이 코드에서는, 행 세트의 커멘드를 설정해, 커멘드의 파라미터를 설정해, 커멘드를 실행합니다. <code>execute</code> 메소드를 호출하는 것만으로,<code>crs</code> 에, 요구된 겉(표) <code>CUSTOMERS</code> 의 데이터가 읽힙니다.
 <PRE>
    crs.setCommand("SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS" +
                   "WHERE CREDIT_LIMIT > ? AND REGION = ? ");
    crs.setInt(1, 5000);
    crs.setString(2, "West");
    crs.execute();
 </PRE>

<h3>10.0 페이징 데이터</h3>
<code>CachedRowSet</code>객체는 데이터를 메모리에 포함하기 위해(때문에), 한 번에 포함할 수 있는 데이터의 양은 사용 가능한 메모리의 양에 의해 정해집니다. 이 제한을 회피하기 위해(때문에),<code>CachedRowSet</code>객체에서는,<code>ResultSet</code>객체로부터 「페이지」라고 불리는 체크로, 데이터를 취득할 수 있습니다. 이 기구를 이용하려면 , 어플리케이션으로,<code>setPageSize</code>메소드를 사용해, 페이지에 포함하는 행수를 설정합니다. 즉, 페이지 사이즈를 5 로 설정해 있는 경우, 데이터 소스로부터 한 번에 5 행의 데이터의 체크가 페치 됩니다. 또, 어플리케이션에서는, 옵션으로, 한 번에 페치 할 수 있는 최대행수도 설정할 수 있습니다. 최대행수를 0 으로 설정했을 경우, 또는 최대행수를 설정하지 않는 경우, 한 번에 페치 가능한 행수의 제한은 없습니다.  &nbsp;<P>
프로퍼티의 설정 후,<code>CachedRowSet</code> 객체에,<code>populate</code> 또는 <code>execute</code> 메소드를 사용해, 데이터를 포함할 필요가 있습니다. 이하의 코드행에,<code>populate</code> 메소드를 사용한 예를 나타냅니다. 이 메소드에서는,<code>ResultSet</code> 핸들과 행의 취득을 개시하는 <code>ResultSet</code> 객체내의 행의 2 개의 파라미터를 취합니다.
 <PRE>
     CachedRowSet crs = new CachedRowSetImpl();
     crs.setMaxRows(20);
     crs.setPageSize(4);
     crs.populate(rsHandle, 10);
 </PRE>
이 코드를 실행하면(자),<i>crs</i>에 <i>rsHandle</i>의 10 행 째부터 시작되는 4 행 분이 포함됩니다.  &nbsp;<P>
다음의 코드의 발췌에 <code>execute</code> 메소드를 사용해,<code>CachedRowSet</code> 객체에 포함하는 예를 나타냅니다.  이 메소드는 파라미터로서 <code>Connection</code> 객체를 취하는 경우라고 취하지 않는 경우가 있습니다. 이 코드에서는 <code>execute</code> 에 <code>Connection</code> 객체 <i>conHandle</i> 를 건네주고 있습니다.  &nbsp;<P>
다음의 코드의 발췌와 상기의 코드에는 2 개의 차이가 있습니다. 우선,<code>setMaxRows</code> 메소드를 호출하지 않기 때문에,<i>crs</i> 에 포함할 수 있는 최대행수에 제한이 없습니다 (<i>crs</i> 에는 항상, 메모리내에 포함할 수 있는 데이터량의 제한이 최우선으로 존재하는 것에 주의해 주세요). 2 점목의 차이는 <code>execute</code> 메소드에, 행의 취득을 개시하는 <code>ResultSet</code> 객체내로부터의 행 번호를 건네줄 수 없는 것입니다. 이 메소드는 항상 선두행으로부터 개시합니다.
 <PRE>
     CachedRowSet crs = new CachedRowSetImpl();
     crs.setPageSize(5);
     crs.execute(conHandle);
 </PRE>
이 코드를 실행하면(자),<i>crs</i>에 대한 커멘드에 의해 생성된 <code>ResultSet</code>객체로부터 5 행 분의 데이터가 <i>crs</i>에 포함됩니다. <i>crs</i>의 라이터는 <i>conHandle</i>를 사용해 데이터 소스에 접속해,<i>crs</i>에 대해서 커멘드를 실행합니다. 이것에 의해, 어플리케이션은, 다른 <code>CachedRowSet</code>객체의 데이터의 조작과 같이 <i>crs</i>의 데이터를 조작할 수 있습니다.  &nbsp;<P>
어플리케이션으로 다음의 페이지 (데이터의 체크)에 액세스 하려면 ,<code>nextPage</code> 메소드를 호출합니다. 이 메소드는 새로운 <code>CachedRowSet</code> 객체를 작성해, 거기에 다음의 페이지의 데이터를 포함합니다. 예를 들어,<code>CachedRowSet</code> 객체의 커멘드가 1000 행 분의 데이터를 포함하는 <code>ResultSet</code> 객체 <i>rs</i> 를 돌려주었다고 합니다. 페이지 사이즈가 100 으로 설정되어 있는 경우,<code>nextPage</code> 메소드의 최초의 호출로,<i>rs</i> 의 선두의 100 행을 포함하는 <code>CachedRowSet</code> 객체가 작성됩니다. 이 선두의 100 행의 데이터의 처리가 끝나면(자), 어플리케이션은 다시 <code>nextPage</code> 메소드를 호출해,<i>rs</i> 로부터 다음의 100 행을 포함하는 다른 <code>CachedRowSet</code> 객체를 작성할 수 있습니다. 최초의 <code>CachedRowSet</code> 객체의 데이터는, 2번째의 <code>CachedRowSet</code> 객체의 데이터로 옮겨지고 있기 (위해)때문에, 메모리내에 남아 있지 않습니다. <code>nextPage</code> 메소드의 10 번째의 호출에서는, 10 번째의 <code>CachedRowSet</code> 객체에 <i>rs</i> 로부터의 마지막 100 행의 데이터가 포함되어 이것들이 메모리에 포함됩니다. 항상 메모리에는, 1 개의 <code>CachedRowSet</code> 객체의 데이터만이 포함되게 됩니다.  &nbsp;<P>
<code>nextPage</code> 메소드는, 현재의 페이지가 행의 마지막 페이지가 아닌 동안은 <code>true</code> 를 돌려주어, 그 이후의 페이지가 없어지면(자) <code>false</code> 를 돌려줍니다. 따라서, 다음의 코드행에 나타내도록(듯이),<code>while</code> 루프로 사용하면, 모든 페이지를 취득할 수 있습니다.
 <PRE>
     CachedRowSet crs = CachedRowSetImpl();
     crs.setPageSize(100);
     crs.execute(conHandle);

     while(crs.nextPage()) {
         while(crs.next()) {
             .  .  .  // operate on chunks (of 100 rows each) in crs, 
                   // row by row
         }
     }
 </PRE>
이 코드의 발췌를 실행하면(자), 어플리케이션은 1000 행을 모두 횡단(traverse) 합니다만, 메모리에는 한 번에 100 행까지 밖에 포함되지 않습니다.  &nbsp;<P>
<code>CachedRowSet</code> 인터페이스는 <code>previousPage</code> 메소드도 정의하고 있습니다. <code>nextPage</code> 메소드가 <code>ResultSet</code> 의 <code>next</code> 메소드에 유사하고 있는 것과 같이,<code>previousPage</code> 메소드는 <code>ResultSet</code> 의 <code>previous</code> 메소드를 닮아 있습니다. <code>nextPage</code> 메소드와 같게,<code>previousPage</code> 는 페이지 사이즈로서 설정되었을 뿐의 행수를 포함하는 <code>CachedRowSet</code> 객체를 작성합니다. 그 때문에, 예를 들어, 상기의 코드의 발췌의 마지막 <code>while</code> 루프내에서 <code>previousPage</code> 메소드를 사용해, 마지막 페이지로부터 선두의 페이지까지, 반대로 페이지를 이동할 수가 있습니다. <code>previousPage</code> 메소드는,<code>while</code> 루프로 사용할 수 있는 점으로써 <code>nextPage</code> 와도 닮았습니다.  다만, 전에 다른 페이지가 존재하는 동안 <code>true</code> 를 돌려주어, 그 이전의 페이지가 없어지면(자),<code>false</code> 를 돌려주는 점이 다릅니다.  &nbsp;<P>
다음의 코드의 발췌에 나타내도록(듯이),<code>previous</code> 메소드는 각 페이지의 마지막 행의 말미에 커서를 두는 것으로, 각 페이지의 맨 마지막 줄로부터 선두행까지 이동합니다. 혹은, 각 페이지의 선두행의 전에 커서를 두어,<code>while</code> 루프로 <code>next</code> 메소드를 사용해, 각 페이지의 선두행으로부터 맨 마지막 줄까지 이동할 수도 있습니다.  &nbsp;<P>
다음의 코드의 발췌에서는, 상기의 코드의 발췌의 계속으로, 10 개째의 <code>CachedRowSet</code> 객체의 커서가 마지막 행에 있으면(자) 가정하고 있습니다. 이 코드에서는 커서를 맨 마지막 줄의 후에 이동하고 있기 (위해)때문에,<code>previous</code> 메소드의 최초의 호출로, 커서를 맨 마지막 줄에 되돌립니다. 마지막 페이지 (<code>CachedRowSet</code> 객체 <i>crs</i>)의 모든 행을 이동하면(자), 코드는 <code>while</code> 루프에 들어가, 9 페이지눈으로 이동해, 역방향으로 행을 이동해, 8 페이지눈으로 이동해, 역방향으로 행을 이동해, 똑같이 해 선두 페이지의 선두행까지 나갑니다.
 
 <PRE>
     crs.afterLast();
     while(crs.previous())  {
         .  .  .  // navigate through the rows, last to first
     {
     while(crs.previousPage())  {
         crs.afterLast();
         while(crs.previous())  {
             .  .  .  // go from the last row to the first row of each page
         }
     }
 </PRE>
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#COMMIT_ON_ACCEPT_CHANGES">COMMIT_ON_ACCEPT_CHANGES</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>acceptChanges()</code>의 호출시에,<code>CachedRowSet</code>객체의 <code>SyncProvider</code> 로 변경을 위탁시킵니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.sql.ResultSet"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.sql. <A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/sql/ResultSet.html#CLOSE_CURSORS_AT_COMMIT">CLOSE_CURSORS_AT_COMMIT</A> , <A HREF="../../../java/sql/ResultSet.html#CONCUR_READ_ONLY">CONCUR_READ_ONLY</A> , <A HREF="../../../java/sql/ResultSet.html#CONCUR_UPDATABLE">CONCUR_UPDATABLE</A> , <A HREF="../../../java/sql/ResultSet.html#FETCH_FORWARD">FETCH_FORWARD</A> , <A HREF="../../../java/sql/ResultSet.html#FETCH_REVERSE">FETCH_REVERSE</A> , <A HREF="../../../java/sql/ResultSet.html#FETCH_UNKNOWN">FETCH_UNKNOWN</A> , <A HREF="../../../java/sql/ResultSet.html#HOLD_CURSORS_OVER_COMMIT">HOLD_CURSORS_OVER_COMMIT</A> , <A HREF="../../../java/sql/ResultSet.html#TYPE_FORWARD_ONLY">TYPE_FORWARD_ONLY</A> , <A HREF="../../../java/sql/ResultSet.html#TYPE_SCROLL_INSENSITIVE">TYPE_SCROLL_INSENSITIVE</A> , <A HREF="../../../java/sql/ResultSet.html#TYPE_SCROLL_SENSITIVE">TYPE_SCROLL_SENSITIVE</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#acceptChanges()">acceptChanges</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체에 대한 행의 갱신, 삽입, 삭제등의 변경을 부하의 데이터 소스에 전달합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#acceptChanges(java.sql.Connection)">acceptChanges</A> </B>(<A HREF="../../../java/sql/Connection.html" title="java.sql 안의 인터페이스">Connection</A> &nbsp;con)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>Connection</code>객체를 사용해 데이터 소스에의 접속을 확립해,<code>CachedRowSet</code> 객체의 부하의 데이터 소스에 행의 갱신, 삽입, 삭제등의 변경을 모두 전달합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#columnUpdated(int)">columnUpdated</A> </B>(int&nbsp;idx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 현재의 은행내의 지정된 열이 갱신되었는지의 여부를 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#columnUpdated(java.lang.String)">columnUpdated</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;columnName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 현재의 은행내의 지정된 열이 갱신되었는지의 여부를 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#commit()">commit</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code> 객체의 <code>SyncProvider</code> 에는,<code>ResultSet</code> 의 <code>Connection</code> 객체인가, 생성자 에게 건네지는 JDBC 프로퍼티이 포함됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/sql/rowset/CachedRowSet.html" title="javax.sql.rowset 내의 인터페이스">CachedRowSet</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopy()">createCopy</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 데이터의 딥 카피인 <code>RowSet</code> 객체를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/sql/rowset/CachedRowSet.html" title="javax.sql.rowset 내의 인터페이스">CachedRowSet</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopyNoConstraints()">createCopyNoConstraints</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 딥 카피이지만, 독립하고 있는 <code>CachedRowSet</code> 객체를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/sql/rowset/CachedRowSet.html" title="javax.sql.rowset 내의 인터페이스">CachedRowSet</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopySchema()">createCopySchema</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 빈 상태(empty)의 카피인 <code>CachedRowSet</code> 객체를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/sql/RowSet.html" title="javax.sql 내의 인터페이스">RowSet</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createShared()">createShared</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체와 같은 데이터에 의해, 백업 된 새로운 <code>RowSet</code> 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#execute(java.sql.Connection)">execute</A> </B>(<A HREF="../../../java/sql/Connection.html" title="java.sql 안의 인터페이스">Connection</A> &nbsp;conn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터 소스가 되는 결과 세트를 생성하기 위한 지정의 접속을 사용해, 이 <code>CachedRowSet</code> 객체에 데이터를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getKeyColumns()">getKeyColumns</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 행을 일의에 식별하는 키를 구성하는 열을 나타내는 1개이상의 열번호를 포함하는 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/sql/ResultSet.html" title="java.sql 내의 인터페이스">ResultSet</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getOriginal()">getOriginal</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 원의 값을 포함하는 <code>ResultSet</code> 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/sql/ResultSet.html" title="java.sql 내의 인터페이스">ResultSet</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getOriginalRow()">getOriginalRow</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 현재의 행만의 원의 값을 포함하는 <code>ResultSet</code> 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getPageSize()">getPageSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code> 객체의 페이지 사이즈를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/sql/rowset/RowSetWarning.html" title="javax.sql.rowset 내의 클래스">RowSetWarning</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getRowSetWarnings()">getRowSetWarnings</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>RowSet</code> 객체에 관한 호출에 의해 보고되는 최초의 경고를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getShowDeleted()">getShowDeleted</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;삭제 마크를 붙일 수 있었던 행을 현재의 행 세트내에 표시할지 어떨지를 나타내는 <code>boolean</code> 를 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/sql/rowset/spi/SyncProvider.html" title="javax.sql.rowset.spi 내의 클래스">SyncProvider</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getSyncProvider()">getSyncProvider</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 <code>SyncProvider</code> 구현을 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getTableName()">getTableName</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 작성에 사용된 객체 (테이블)의 식별자를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#nextPage()">nextPage</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code> 의 현재의 페이지를 증분 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#populate(java.sql.ResultSet)">populate</A> </B>(<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A> &nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체로 지정된 <code>ResultSet</code>객체의 데이터를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#populate(java.sql.ResultSet, int)">populate</A> </B>(<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A> &nbsp;rs,
         int&nbsp;startRow)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체로 지정된 <code>ResultSet</code>객체의 데이터를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#previousPage()">previousPage</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code> 의 현재의 페이지를 감 분 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#release()">release</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 현재의 컨텐츠를 해제해, 등록을 마친 모든 청취자에게 <code>rowSetChanged</code> 이벤트를 송신합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#restoreOriginal()">restoreOriginal</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체를 원의 값 (전회의 변경 세트의 전의 값)에 되돌립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#rollback()">rollback</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code> 객체의 <code>SyncProvider</code> 에는, 원의 <code>ResultSet</code> 의 <code>Connection</code> 객체인가, 거기에 건네받는 JDBC 프로퍼티이 포함됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#rollback(java.sql.Savepoint)">rollback</A> </B>(<A HREF="../../../java/sql/Savepoint.html" title="java.sql 안의 인터페이스">Savepoint</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code> 객체의 <code>SyncProvider</code> 에는, 원의 <code>ResultSet</code> 의 <code>Connection</code> 객체인가, 거기에 건네받는 JDBC 프로퍼티이 포함됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#rowSetPopulated(javax.sql.RowSetEvent, int)">rowSetPopulated</A> </B>(<A HREF="../../../javax/sql/RowSetEvent.html" title="javax.sql 안의 클래스">RowSetEvent</A> &nbsp;event,
                int&nbsp;numRows)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;등록이 끝난 청취자에게, 지정된 RowSetEvent 객체내의 RowSet 객체가 다수의 추가행을 읽어들인 것을 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setKeyColumns(int[])">setKeyColumns</A> </B>(int[]&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 <code>keyCols</code> 필드에, 지정된 열번호의 배열 (이 <code>CachedRowSet</code> 객체내의 행을 일의에 식별하는 키를 구성한다)을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setMetaData(javax.sql.RowSetMetaData)">setMetaData</A> </B>(<A HREF="../../../javax/sql/RowSetMetaData.html" title="javax.sql 안의 인터페이스">RowSetMetaData</A> &nbsp;md)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>RowSetMetaData</code>객체를 사용해,<code>CachedRowSet</code> 객체의 메타데이타를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setOriginalRow()">setOriginalRow</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 현재의 행을 원의 행으로서 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setPageSize(int)">setPageSize</A> </B>(int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code> 객체의 페이지 사이즈를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setShowDeleted(boolean)">setShowDeleted</A> </B>(boolean&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>showDeleted</code> 프로퍼티으로서 삭제 마크 첨부의 행을 현재의 행 세트내에 표시할지 어떨지를 지정하는 <code>boolean</code> 를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setSyncProvider(java.lang.String)">setSyncProvider</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;provider)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 <code>SyncProvider</code> 객체로 지정한 객체를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setTableName(java.lang.String)">setTableName</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;tabName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체의 파생원의 테이블의 식별자를, 지정의 테이블명으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#size()">size</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체내의 행수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection()">toCollection</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체를, 이 <code>CachedRowSet</code> 객체의 모든 데이터를 포함하는 <code>Collection</code> 객체로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection(int)">toCollection</A> </B>(int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체내의 지정된 열을 <code>Collection</code> 객체로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection(java.lang.String)">toCollection</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 객체내의 지정된 열을 <code>Collection</code>객체로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoDelete()">undoDelete</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 행의 삭제를 취소해, 청취자로 행이 변경된 것을 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoInsert()">undoInsert</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;만약 행이 삽입된 상태이면,<code>CachedRowSet</code> 객체로부터 현재의 행을 즉시 삭제해, 청취자로 행이 변경된 것을 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoUpdate()">undoUpdate</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;만약 행이 변경되고 있으면, 전회의 갱신 조작을 즉시 바탕으로 되돌립니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.sql.RowSet"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 javax.sql. <A HREF="../../../javax/sql/RowSet.html" title="javax.sql 안의 인터페이스">RowSet</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/sql/RowSet.html#addRowSetListener(javax.sql.RowSetListener)">addRowSetListener</A> , <A HREF="../../../javax/sql/RowSet.html#clearParameters()">clearParameters</A> , <A HREF="../../../javax/sql/RowSet.html#execute()">execute</A> , <A HREF="../../../javax/sql/RowSet.html#getCommand()">getCommand</A> , <A HREF="../../../javax/sql/RowSet.html#getDataSourceName()">getDataSourceName</A> , <A HREF="../../../javax/sql/RowSet.html#getEscapeProcessing()">getEscapeProcessing</A> , <A HREF="../../../javax/sql/RowSet.html#getMaxFieldSize()">getMaxFieldSize</A> , <A HREF="../../../javax/sql/RowSet.html#getMaxRows()">getMaxRows</A> , <A HREF="../../../javax/sql/RowSet.html#getPassword()">getPassword</A> , <A HREF="../../../javax/sql/RowSet.html#getQueryTimeout()">getQueryTimeout</A> , <A HREF="../../../javax/sql/RowSet.html#getTransactionIsolation()">getTransactionIsolation</A> , <A HREF="../../../javax/sql/RowSet.html#getTypeMap()">getTypeMap</A> , <A HREF="../../../javax/sql/RowSet.html#getUrl()">getUrl</A> , <A HREF="../../../javax/sql/RowSet.html#getUsername()">getUsername</A> , <A HREF="../../../javax/sql/RowSet.html#isReadOnly()">isReadOnly</A> , <A HREF="../../../javax/sql/RowSet.html#removeRowSetListener(javax.sql.RowSetListener)">removeRowSetListener</A> , <A HREF="../../../javax/sql/RowSet.html#setArray(int, java.sql.Array)">setArray</A> , <A HREF="../../../javax/sql/RowSet.html#setAsciiStream(int, java.io.InputStream)">setAsciiStream</A> , <A HREF="../../../javax/sql/RowSet.html#setAsciiStream(int, java.io.InputStream, int)">setAsciiStream</A> , <A HREF="../../../javax/sql/RowSet.html#setAsciiStream(java.lang.String, java.io.InputStream)">setAsciiStream</A> , <A HREF="../../../javax/sql/RowSet.html#setAsciiStream(java.lang.String, java.io.InputStream, int)">setAsciiStream</A> , <A HREF="../../../javax/sql/RowSet.html#setBigDecimal(int, java.math.BigDecimal)">setBigDecimal</A> , <A HREF="../../../javax/sql/RowSet.html#setBigDecimal(java.lang.String, java.math.BigDecimal)">setBigDecimal</A> , <A HREF="../../../javax/sql/RowSet.html#setBinaryStream(int, java.io.InputStream)">setBinaryStream</A> , <A HREF="../../../javax/sql/RowSet.html#setBinaryStream(int, java.io.InputStream, int)">setBinaryStream</A> , <A HREF="../../../javax/sql/RowSet.html#setBinaryStream(java.lang.String, java.io.InputStream)">setBinaryStream</A> , <A HREF="../../../javax/sql/RowSet.html#setBinaryStream(java.lang.String, java.io.InputStream, int)">setBinaryStream</A> , <A HREF="../../../javax/sql/RowSet.html#setBlob(int, java.sql.Blob)">setBlob</A> , <A HREF="../../../javax/sql/RowSet.html#setBlob(int, java.io.InputStream)">setBlob</A> , <A HREF="../../../javax/sql/RowSet.html#setBlob(int, java.io.InputStream, long)">setBlob</A> , <A HREF="../../../javax/sql/RowSet.html#setBlob(java.lang.String, java.sql.Blob)">setBlob</A> , <A HREF="../../../javax/sql/RowSet.html#setBlob(java.lang.String, java.io.InputStream)">setBlob</A> , <A HREF="../../../javax/sql/RowSet.html#setBlob(java.lang.String, java.io.InputStream, long)">setBlob</A> , <A HREF="../../../javax/sql/RowSet.html#setBoolean(int, boolean)">setBoolean</A> , <A HREF="../../../javax/sql/RowSet.html#setBoolean(java.lang.String, boolean)">setBoolean</A> , <A HREF="../../../javax/sql/RowSet.html#setByte(int, byte)">setByte</A> , <A HREF="../../../javax/sql/RowSet.html#setByte(java.lang.String, byte)">setByte</A> , <A HREF="../../../javax/sql/RowSet.html#setBytes(int, byte[])">setBytes</A> , <A HREF="../../../javax/sql/RowSet.html#setBytes(java.lang.String, byte[])">setBytes</A> , <A HREF="../../../javax/sql/RowSet.html#setCharacterStream(int, java.io.Reader)">setCharacterStream</A> , <A HREF="../../../javax/sql/RowSet.html#setCharacterStream(int, java.io.Reader, int)">setCharacterStream</A> , <A HREF="../../../javax/sql/RowSet.html#setCharacterStream(java.lang.String, java.io.Reader)">setCharacterStream</A> , <A HREF="../../../javax/sql/RowSet.html#setCharacterStream(java.lang.String, java.io.Reader, int)">setCharacterStream</A> , <A HREF="../../../javax/sql/RowSet.html#setClob(int, java.sql.Clob)">setClob</A> , <A HREF="../../../javax/sql/RowSet.html#setClob(int, java.io.Reader)">setClob</A> , <A HREF="../../../javax/sql/RowSet.html#setClob(int, java.io.Reader, long)">setClob</A> , <A HREF="../../../javax/sql/RowSet.html#setClob(java.lang.String, java.sql.Clob)">setClob</A> , <A HREF="../../../javax/sql/RowSet.html#setClob(java.lang.String, java.io.Reader)">setClob</A> , <A HREF="../../../javax/sql/RowSet.html#setClob(java.lang.String, java.io.Reader, long)">setClob</A> , <A HREF="../../../javax/sql/RowSet.html#setCommand(java.lang.String)">setCommand</A> , <A HREF="../../../javax/sql/RowSet.html#setConcurrency(int)">setConcurrency</A> , <A HREF="../../../javax/sql/RowSet.html#setDataSourceName(java.lang.String)">setDataSourceName</A> , <A HREF="../../../javax/sql/RowSet.html#setDate(int, java.sql.Date)">setDate</A> , <A HREF="../../../javax/sql/RowSet.html#setDate(int, java.sql.Date, java.util.Calendar)">setDate</A> , <A HREF="../../../javax/sql/RowSet.html#setDate(java.lang.String, java.sql.Date)">setDate</A> , <A HREF="../../../javax/sql/RowSet.html#setDate(java.lang.String, java.sql.Date, java.util.Calendar)">setDate</A> , <A HREF="../../../javax/sql/RowSet.html#setDouble(int, double)">setDouble</A> , <A HREF="../../../javax/sql/RowSet.html#setDouble(java.lang.String, double)">setDouble</A> , <A HREF="../../../javax/sql/RowSet.html#setEscapeProcessing(boolean)">setEscapeProcessing</A> , <A HREF="../../../javax/sql/RowSet.html#setFloat(int, float)">setFloat</A> , <A HREF="../../../javax/sql/RowSet.html#setFloat(java.lang.String, float)">setFloat</A> , <A HREF="../../../javax/sql/RowSet.html#setInt(int, int)">setInt</A> , <A HREF="../../../javax/sql/RowSet.html#setInt(java.lang.String, int)">setInt</A> , <A HREF="../../../javax/sql/RowSet.html#setLong(int, long)">setLong</A> , <A HREF="../../../javax/sql/RowSet.html#setLong(java.lang.String, long)">setLong</A> , <A HREF="../../../javax/sql/RowSet.html#setMaxFieldSize(int)">setMaxFieldSize</A> , <A HREF="../../../javax/sql/RowSet.html#setMaxRows(int)">setMaxRows</A> , <A HREF="../../../javax/sql/RowSet.html#setNCharacterStream(int, java.io.Reader)">setNCharacterStream</A> , <A HREF="../../../javax/sql/RowSet.html#setNCharacterStream(int, java.io.Reader, long)">setNCharacterStream</A> , <A HREF="../../../javax/sql/RowSet.html#setNCharacterStream(java.lang.String, java.io.Reader)">setNCharacterStream</A> , <A HREF="../../../javax/sql/RowSet.html#setNCharacterStream(java.lang.String, java.io.Reader, long)">setNCharacterStream</A> , <A HREF="../../../javax/sql/RowSet.html#setNClob(int, java.sql.NClob)">setNClob</A> , <A HREF="../../../javax/sql/RowSet.html#setNClob(int, java.io.Reader)">setNClob</A> , <A HREF="../../../javax/sql/RowSet.html#setNClob(int, java.io.Reader, long)">setNClob</A> , <A HREF="../../../javax/sql/RowSet.html#setNClob(java.lang.String, java.sql.NClob)">setNClob</A> , <A HREF="../../../javax/sql/RowSet.html#setNClob(java.lang.String, java.io.Reader)">setNClob</A> , <A HREF="../../../javax/sql/RowSet.html#setNClob(java.lang.String, java.io.Reader, long)">setNClob</A> , <A HREF="../../../javax/sql/RowSet.html#setNString(int, java.lang.String)">setNString</A> , <A HREF="../../../javax/sql/RowSet.html#setNString(java.lang.String, java.lang.String)">setNString</A> , <A HREF="../../../javax/sql/RowSet.html#setNull(int, int)">setNull</A> , <A HREF="../../../javax/sql/RowSet.html#setNull(int, int, java.lang.String)">setNull</A> , <A HREF="../../../javax/sql/RowSet.html#setNull(java.lang.String, int)">setNull</A> , <A HREF="../../../javax/sql/RowSet.html#setNull(java.lang.String, int, java.lang.String)">setNull</A> , <A HREF="../../../javax/sql/RowSet.html#setObject(int, java.lang.Object)">setObject</A> , <A HREF="../../../javax/sql/RowSet.html#setObject(int, java.lang.Object, int)">setObject</A> , <A HREF="../../../javax/sql/RowSet.html#setObject(int, java.lang.Object, int, int)">setObject</A> , <A HREF="../../../javax/sql/RowSet.html#setObject(java.lang.String, java.lang.Object)">setObject</A> , <A HREF="../../../javax/sql/RowSet.html#setObject(java.lang.String, java.lang.Object, int)">setObject</A> , <A HREF="../../../javax/sql/RowSet.html#setObject(java.lang.String, java.lang.Object, int, int)">setObject</A> , <A HREF="../../../javax/sql/RowSet.html#setPassword(java.lang.String)">setPassword</A> , <A HREF="../../../javax/sql/RowSet.html#setQueryTimeout(int)">setQueryTimeout</A> , <A HREF="../../../javax/sql/RowSet.html#setReadOnly(boolean)">setReadOnly</A> , <A HREF="../../../javax/sql/RowSet.html#setRef(int, java.sql.Ref)">setRef</A> , <A HREF="../../../javax/sql/RowSet.html#setRowId(int, java.sql.RowId)">setRowId</A> , <A HREF="../../../javax/sql/RowSet.html#setRowId(java.lang.String, java.sql.RowId)">setRowId</A> , <A HREF="../../../javax/sql/RowSet.html#setShort(int, short)">setShort</A> , <A HREF="../../../javax/sql/RowSet.html#setShort(java.lang.String, short)">setShort</A> , <A HREF="../../../javax/sql/RowSet.html#setSQLXML(int, java.sql.SQLXML)">setSQLXML</A> , <A HREF="../../../javax/sql/RowSet.html#setSQLXML(java.lang.String, java.sql.SQLXML)">setSQLXML</A> , <A HREF="../../../javax/sql/RowSet.html#setString(int, java.lang.String)">setString</A> , <A HREF="../../../javax/sql/RowSet.html#setString(java.lang.String, java.lang.String)">setString</A> , <A HREF="../../../javax/sql/RowSet.html#setTime(int, java.sql.Time)">setTime</A> , <A HREF="../../../javax/sql/RowSet.html#setTime(int, java.sql.Time, java.util.Calendar)">setTime</A> , <A HREF="../../../javax/sql/RowSet.html#setTime(java.lang.String, java.sql.Time)">setTime</A> , <A HREF="../../../javax/sql/RowSet.html#setTime(java.lang.String, java.sql.Time, java.util.Calendar)">setTime</A> , <A HREF="../../../javax/sql/RowSet.html#setTimestamp(int, java.sql.Timestamp)">setTimestamp</A> , <A HREF="../../../javax/sql/RowSet.html#setTimestamp(int, java.sql.Timestamp, java.util.Calendar)">setTimestamp</A> , <A HREF="../../../javax/sql/RowSet.html#setTimestamp(java.lang.String, java.sql.Timestamp)">setTimestamp</A> , <A HREF="../../../javax/sql/RowSet.html#setTimestamp(java.lang.String, java.sql.Timestamp, java.util.Calendar)">setTimestamp</A> , <A HREF="../../../javax/sql/RowSet.html#setTransactionIsolation(int)">setTransactionIsolation</A> , <A HREF="../../../javax/sql/RowSet.html#setType(int)">setType</A> , <A HREF="../../../javax/sql/RowSet.html#setTypeMap(java.util.Map)">setTypeMap</A> , <A HREF="../../../javax/sql/RowSet.html#setURL(int, java.net.URL)">setURL</A> , <A HREF="../../../javax/sql/RowSet.html#setUrl(java.lang.String)">setUrl</A> , <A HREF="../../../javax/sql/RowSet.html#setUsername(java.lang.String)">setUsername</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.sql.ResultSet"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.sql. <A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/sql/ResultSet.html#absolute(int)">absolute</A> , <A HREF="../../../java/sql/ResultSet.html#afterLast()">afterLast</A> , <A HREF="../../../java/sql/ResultSet.html#beforeFirst()">beforeFirst</A> , <A HREF="../../../java/sql/ResultSet.html#cancelRowUpdates()">cancelRowUpdates</A> , <A HREF="../../../java/sql/ResultSet.html#clearWarnings()">clearWarnings</A> , <A HREF="../../../java/sql/ResultSet.html#close()">close</A> , <A HREF="../../../java/sql/ResultSet.html#deleteRow()">deleteRow</A> , <A HREF="../../../java/sql/ResultSet.html#findColumn(java.lang.String)">findColumn</A> , <A HREF="../../../java/sql/ResultSet.html#first()">first</A> , <A HREF="../../../java/sql/ResultSet.html#getArray(int)">getArray</A> , <A HREF="../../../java/sql/ResultSet.html#getArray(java.lang.String)">getArray</A> , <A HREF="../../../java/sql/ResultSet.html#getAsciiStream(int)">getAsciiStream</A> , <A HREF="../../../java/sql/ResultSet.html#getAsciiStream(java.lang.String)">getAsciiStream</A> , <A HREF="../../../java/sql/ResultSet.html#getBigDecimal(int)">getBigDecimal</A> , <A HREF="../../../java/sql/ResultSet.html#getBigDecimal(int, int)">getBigDecimal</A> , <A HREF="../../../java/sql/ResultSet.html#getBigDecimal(java.lang.String)">getBigDecimal</A> , <A HREF="../../../java/sql/ResultSet.html#getBigDecimal(java.lang.String, int)">getBigDecimal</A> , <A HREF="../../../java/sql/ResultSet.html#getBinaryStream(int)">getBinaryStream</A> , <A HREF="../../../java/sql/ResultSet.html#getBinaryStream(java.lang.String)">getBinaryStream</A> , <A HREF="../../../java/sql/ResultSet.html#getBlob(int)">getBlob</A> , <A HREF="../../../java/sql/ResultSet.html#getBlob(java.lang.String)">getBlob</A> , <A HREF="../../../java/sql/ResultSet.html#getBoolean(int)">getBoolean</A> , <A HREF="../../../java/sql/ResultSet.html#getBoolean(java.lang.String)">getBoolean</A> , <A HREF="../../../java/sql/ResultSet.html#getByte(int)">getByte</A> , <A HREF="../../../java/sql/ResultSet.html#getByte(java.lang.String)">getByte</A> , <A HREF="../../../java/sql/ResultSet.html#getBytes(int)">getBytes</A> , <A HREF="../../../java/sql/ResultSet.html#getBytes(java.lang.String)">getBytes</A> , <A HREF="../../../java/sql/ResultSet.html#getCharacterStream(int)">getCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#getCharacterStream(java.lang.String)">getCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#getClob(int)">getClob</A> , <A HREF="../../../java/sql/ResultSet.html#getClob(java.lang.String)">getClob</A> , <A HREF="../../../java/sql/ResultSet.html#getConcurrency()">getConcurrency</A> , <A HREF="../../../java/sql/ResultSet.html#getCursorName()">getCursorName</A> , <A HREF="../../../java/sql/ResultSet.html#getDate(int)">getDate</A> , <A HREF="../../../java/sql/ResultSet.html#getDate(int, java.util.Calendar)">getDate</A> , <A HREF="../../../java/sql/ResultSet.html#getDate(java.lang.String)">getDate</A> , <A HREF="../../../java/sql/ResultSet.html#getDate(java.lang.String, java.util.Calendar)">getDate</A> , <A HREF="../../../java/sql/ResultSet.html#getDouble(int)">getDouble</A> , <A HREF="../../../java/sql/ResultSet.html#getDouble(java.lang.String)">getDouble</A> , <A HREF="../../../java/sql/ResultSet.html#getFetchDirection()">getFetchDirection</A> , <A HREF="../../../java/sql/ResultSet.html#getFetchSize()">getFetchSize</A> , <A HREF="../../../java/sql/ResultSet.html#getFloat(int)">getFloat</A> , <A HREF="../../../java/sql/ResultSet.html#getFloat(java.lang.String)">getFloat</A> , <A HREF="../../../java/sql/ResultSet.html#getHoldability()">getHoldability</A> , <A HREF="../../../java/sql/ResultSet.html#getInt(int)">getInt</A> , <A HREF="../../../java/sql/ResultSet.html#getInt(java.lang.String)">getInt</A> , <A HREF="../../../java/sql/ResultSet.html#getLong(int)">getLong</A> , <A HREF="../../../java/sql/ResultSet.html#getLong(java.lang.String)">getLong</A> , <A HREF="../../../java/sql/ResultSet.html#getMetaData()">getMetaData</A> , <A HREF="../../../java/sql/ResultSet.html#getNCharacterStream(int)">getNCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#getNCharacterStream(java.lang.String)">getNCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#getNClob(int)">getNClob</A> , <A HREF="../../../java/sql/ResultSet.html#getNClob(java.lang.String)">getNClob</A> , <A HREF="../../../java/sql/ResultSet.html#getNString(int)">getNString</A> , <A HREF="../../../java/sql/ResultSet.html#getNString(java.lang.String)">getNString</A> , <A HREF="../../../java/sql/ResultSet.html#getObject(int)">getObject</A> , <A HREF="../../../java/sql/ResultSet.html#getObject(int, java.util.Map)">getObject</A> , <A HREF="../../../java/sql/ResultSet.html#getObject(java.lang.String)">getObject</A> , <A HREF="../../../java/sql/ResultSet.html#getObject(java.lang.String, java.util.Map)">getObject</A> , <A HREF="../../../java/sql/ResultSet.html#getRef(int)">getRef</A> , <A HREF="../../../java/sql/ResultSet.html#getRef(java.lang.String)">getRef</A> , <A HREF="../../../java/sql/ResultSet.html#getRow()">getRow</A> , <A HREF="../../../java/sql/ResultSet.html#getRowId(int)">getRowId</A> , <A HREF="../../../java/sql/ResultSet.html#getRowId(java.lang.String)">getRowId</A> , <A HREF="../../../java/sql/ResultSet.html#getShort(int)">getShort</A> , <A HREF="../../../java/sql/ResultSet.html#getShort(java.lang.String)">getShort</A> , <A HREF="../../../java/sql/ResultSet.html#getSQLXML(int)">getSQLXML</A> , <A HREF="../../../java/sql/ResultSet.html#getSQLXML(java.lang.String)">getSQLXML</A> , <A HREF="../../../java/sql/ResultSet.html#getStatement()">getStatement</A> , <A HREF="../../../java/sql/ResultSet.html#getString(int)">getString</A> , <A HREF="../../../java/sql/ResultSet.html#getString(java.lang.String)">getString</A> , <A HREF="../../../java/sql/ResultSet.html#getTime(int)">getTime</A> , <A HREF="../../../java/sql/ResultSet.html#getTime(int, java.util.Calendar)">getTime</A> , <A HREF="../../../java/sql/ResultSet.html#getTime(java.lang.String)">getTime</A> , <A HREF="../../../java/sql/ResultSet.html#getTime(java.lang.String, java.util.Calendar)">getTime</A> , <A HREF="../../../java/sql/ResultSet.html#getTimestamp(int)">getTimestamp</A> , <A HREF="../../../java/sql/ResultSet.html#getTimestamp(int, java.util.Calendar)">getTimestamp</A> , <A HREF="../../../java/sql/ResultSet.html#getTimestamp(java.lang.String)">getTimestamp</A> , <A HREF="../../../java/sql/ResultSet.html#getTimestamp(java.lang.String, java.util.Calendar)">getTimestamp</A> , <A HREF="../../../java/sql/ResultSet.html#getType()">getType</A> , <A HREF="../../../java/sql/ResultSet.html#getUnicodeStream(int)">getUnicodeStream</A> , <A HREF="../../../java/sql/ResultSet.html#getUnicodeStream(java.lang.String)">getUnicodeStream</A> , <A HREF="../../../java/sql/ResultSet.html#getURL(int)">getURL</A> , <A HREF="../../../java/sql/ResultSet.html#getURL(java.lang.String)">getURL</A> , <A HREF="../../../java/sql/ResultSet.html#getWarnings()">getWarnings</A> , <A HREF="../../../java/sql/ResultSet.html#insertRow()">insertRow</A> , <A HREF="../../../java/sql/ResultSet.html#isAfterLast()">isAfterLast</A> , <A HREF="../../../java/sql/ResultSet.html#isBeforeFirst()">isBeforeFirst</A> , <A HREF="../../../java/sql/ResultSet.html#isClosed()">isClosed</A> , <A HREF="../../../java/sql/ResultSet.html#isFirst()">isFirst</A> , <A HREF="../../../java/sql/ResultSet.html#isLast()">isLast</A> , <A HREF="../../../java/sql/ResultSet.html#last()">last</A> , <A HREF="../../../java/sql/ResultSet.html#moveToCurrentRow()">moveToCurrentRow</A> , <A HREF="../../../java/sql/ResultSet.html#moveToInsertRow()">moveToInsertRow</A> , <A HREF="../../../java/sql/ResultSet.html#next()">next</A> , <A HREF="../../../java/sql/ResultSet.html#previous()">previous</A> , <A HREF="../../../java/sql/ResultSet.html#refreshRow()">refreshRow</A> , <A HREF="../../../java/sql/ResultSet.html#relative(int)">relative</A> , <A HREF="../../../java/sql/ResultSet.html#rowDeleted()">rowDeleted</A> , <A HREF="../../../java/sql/ResultSet.html#rowInserted()">rowInserted</A> , <A HREF="../../../java/sql/ResultSet.html#rowUpdated()">rowUpdated</A> , <A HREF="../../../java/sql/ResultSet.html#setFetchDirection(int)">setFetchDirection</A> , <A HREF="../../../java/sql/ResultSet.html#setFetchSize(int)">setFetchSize</A> , <A HREF="../../../java/sql/ResultSet.html#updateArray(int, java.sql.Array)">updateArray</A> , <A HREF="../../../java/sql/ResultSet.html#updateArray(java.lang.String, java.sql.Array)">updateArray</A> , <A HREF="../../../java/sql/ResultSet.html#updateAsciiStream(int, java.io.InputStream)">updateAsciiStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateAsciiStream(int, java.io.InputStream, int)">updateAsciiStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateAsciiStream(int, java.io.InputStream, long)">updateAsciiStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateAsciiStream(java.lang.String, java.io.InputStream)">updateAsciiStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateAsciiStream(java.lang.String, java.io.InputStream, int)">updateAsciiStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateAsciiStream(java.lang.String, java.io.InputStream, long)">updateAsciiStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateBigDecimal(int, java.math.BigDecimal)">updateBigDecimal</A> , <A HREF="../../../java/sql/ResultSet.html#updateBigDecimal(java.lang.String, java.math.BigDecimal)">updateBigDecimal</A> , <A HREF="../../../java/sql/ResultSet.html#updateBinaryStream(int, java.io.InputStream)">updateBinaryStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateBinaryStream(int, java.io.InputStream, int)">updateBinaryStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateBinaryStream(int, java.io.InputStream, long)">updateBinaryStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateBinaryStream(java.lang.String, java.io.InputStream)">updateBinaryStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateBinaryStream(java.lang.String, java.io.InputStream, int)">updateBinaryStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateBinaryStream(java.lang.String, java.io.InputStream, long)">updateBinaryStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateBlob(int, java.sql.Blob)">updateBlob</A> , <A HREF="../../../java/sql/ResultSet.html#updateBlob(int, java.io.InputStream)">updateBlob</A> , <A HREF="../../../java/sql/ResultSet.html#updateBlob(int, java.io.InputStream, long)">updateBlob</A> , <A HREF="../../../java/sql/ResultSet.html#updateBlob(java.lang.String, java.sql.Blob)">updateBlob</A> , <A HREF="../../../java/sql/ResultSet.html#updateBlob(java.lang.String, java.io.InputStream)">updateBlob</A> , <A HREF="../../../java/sql/ResultSet.html#updateBlob(java.lang.String, java.io.InputStream, long)">updateBlob</A> , <A HREF="../../../java/sql/ResultSet.html#updateBoolean(int, boolean)">updateBoolean</A> , <A HREF="../../../java/sql/ResultSet.html#updateBoolean(java.lang.String, boolean)">updateBoolean</A> , <A HREF="../../../java/sql/ResultSet.html#updateByte(int, byte)">updateByte</A> , <A HREF="../../../java/sql/ResultSet.html#updateByte(java.lang.String, byte)">updateByte</A> , <A HREF="../../../java/sql/ResultSet.html#updateBytes(int, byte[])">updateBytes</A> , <A HREF="../../../java/sql/ResultSet.html#updateBytes(java.lang.String, byte[])">updateBytes</A> , <A HREF="../../../java/sql/ResultSet.html#updateCharacterStream(int, java.io.Reader)">updateCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateCharacterStream(int, java.io.Reader, int)">updateCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateCharacterStream(int, java.io.Reader, long)">updateCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateCharacterStream(java.lang.String, java.io.Reader)">updateCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateCharacterStream(java.lang.String, java.io.Reader, int)">updateCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateCharacterStream(java.lang.String, java.io.Reader, long)">updateCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateClob(int, java.sql.Clob)">updateClob</A> , <A HREF="../../../java/sql/ResultSet.html#updateClob(int, java.io.Reader)">updateClob</A> , <A HREF="../../../java/sql/ResultSet.html#updateClob(int, java.io.Reader, long)">updateClob</A> , <A HREF="../../../java/sql/ResultSet.html#updateClob(java.lang.String, java.sql.Clob)">updateClob</A> , <A HREF="../../../java/sql/ResultSet.html#updateClob(java.lang.String, java.io.Reader)">updateClob</A> , <A HREF="../../../java/sql/ResultSet.html#updateClob(java.lang.String, java.io.Reader, long)">updateClob</A> , <A HREF="../../../java/sql/ResultSet.html#updateDate(int, java.sql.Date)">updateDate</A> , <A HREF="../../../java/sql/ResultSet.html#updateDate(java.lang.String, java.sql.Date)">updateDate</A> , <A HREF="../../../java/sql/ResultSet.html#updateDouble(int, double)">updateDouble</A> , <A HREF="../../../java/sql/ResultSet.html#updateDouble(java.lang.String, double)">updateDouble</A> , <A HREF="../../../java/sql/ResultSet.html#updateFloat(int, float)">updateFloat</A> , <A HREF="../../../java/sql/ResultSet.html#updateFloat(java.lang.String, float)">updateFloat</A> , <A HREF="../../../java/sql/ResultSet.html#updateInt(int, int)">updateInt</A> , <A HREF="../../../java/sql/ResultSet.html#updateInt(java.lang.String, int)">updateInt</A> , <A HREF="../../../java/sql/ResultSet.html#updateLong(int, long)">updateLong</A> , <A HREF="../../../java/sql/ResultSet.html#updateLong(java.lang.String, long)">updateLong</A> , <A HREF="../../../java/sql/ResultSet.html#updateNCharacterStream(int, java.io.Reader)">updateNCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateNCharacterStream(int, java.io.Reader, long)">updateNCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateNCharacterStream(java.lang.String, java.io.Reader)">updateNCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateNCharacterStream(java.lang.String, java.io.Reader, long)">updateNCharacterStream</A> , <A HREF="../../../java/sql/ResultSet.html#updateNClob(int, java.sql.NClob)">updateNClob</A> , <A HREF="../../../java/sql/ResultSet.html#updateNClob(int, java.io.Reader)">updateNClob</A> , <A HREF="../../../java/sql/ResultSet.html#updateNClob(int, java.io.Reader, long)">updateNClob</A> , <A HREF="../../../java/sql/ResultSet.html#updateNClob(java.lang.String, java.sql.NClob)">updateNClob</A> , <A HREF="../../../java/sql/ResultSet.html#updateNClob(java.lang.String, java.io.Reader)">updateNClob</A> , <A HREF="../../../java/sql/ResultSet.html#updateNClob(java.lang.String, java.io.Reader, long)">updateNClob</A> , <A HREF="../../../java/sql/ResultSet.html#updateNString(int, java.lang.String)">updateNString</A> , <A HREF="../../../java/sql/ResultSet.html#updateNString(java.lang.String, java.lang.String)">updateNString</A> , <A HREF="../../../java/sql/ResultSet.html#updateNull(int)">updateNull</A> , <A HREF="../../../java/sql/ResultSet.html#updateNull(java.lang.String)">updateNull</A> , <A HREF="../../../java/sql/ResultSet.html#updateObject(int, java.lang.Object)">updateObject</A> , <A HREF="../../../java/sql/ResultSet.html#updateObject(int, java.lang.Object, int)">updateObject</A> , <A HREF="../../../java/sql/ResultSet.html#updateObject(java.lang.String, java.lang.Object)">updateObject</A> , <A HREF="../../../java/sql/ResultSet.html#updateObject(java.lang.String, java.lang.Object, int)">updateObject</A> , <A HREF="../../../java/sql/ResultSet.html#updateRef(int, java.sql.Ref)">updateRef</A> , <A HREF="../../../java/sql/ResultSet.html#updateRef(java.lang.String, java.sql.Ref)">updateRef</A> , <A HREF="../../../java/sql/ResultSet.html#updateRow()">updateRow</A> , <A HREF="../../../java/sql/ResultSet.html#updateRowId(int, java.sql.RowId)">updateRowId</A> , <A HREF="../../../java/sql/ResultSet.html#updateRowId(java.lang.String, java.sql.RowId)">updateRowId</A> , <A HREF="../../../java/sql/ResultSet.html#updateShort(int, short)">updateShort</A> , <A HREF="../../../java/sql/ResultSet.html#updateShort(java.lang.String, short)">updateShort</A> , <A HREF="../../../java/sql/ResultSet.html#updateSQLXML(int, java.sql.SQLXML)">updateSQLXML</A> , <A HREF="../../../java/sql/ResultSet.html#updateSQLXML(java.lang.String, java.sql.SQLXML)">updateSQLXML</A> , <A HREF="../../../java/sql/ResultSet.html#updateString(int, java.lang.String)">updateString</A> , <A HREF="../../../java/sql/ResultSet.html#updateString(java.lang.String, java.lang.String)">updateString</A> , <A HREF="../../../java/sql/ResultSet.html#updateTime(int, java.sql.Time)">updateTime</A> , <A HREF="../../../java/sql/ResultSet.html#updateTime(java.lang.String, java.sql.Time)">updateTime</A> , <A HREF="../../../java/sql/ResultSet.html#updateTimestamp(int, java.sql.Timestamp)">updateTimestamp</A> , <A HREF="../../../java/sql/ResultSet.html#updateTimestamp(java.lang.String, java.sql.Timestamp)">updateTimestamp</A> , <A HREF="../../../java/sql/ResultSet.html#wasNull()">wasNull</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.sql.Wrapper"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.sql. <A HREF="../../../java/sql/Wrapper.html" title="java.sql 안의 인터페이스">Wrapper</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/sql/Wrapper.html#isWrapperFor(java.lang.Class)">isWrapperFor</A> , <A HREF="../../../java/sql/Wrapper.html#unwrap(java.lang.Class)">unwrap</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.sql.rowset.Joinable"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 javax.sql.rowset. <A HREF="../../../javax/sql/rowset/Joinable.html" title="javax.sql.rowset 안의 인터페이스">Joinable</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/sql/rowset/Joinable.html#getMatchColumnIndexes()">getMatchColumnIndexes</A> , <A HREF="../../../javax/sql/rowset/Joinable.html#getMatchColumnNames()">getMatchColumnNames</A> , <A HREF="../../../javax/sql/rowset/Joinable.html#setMatchColumn(int)">setMatchColumn</A> , <A HREF="../../../javax/sql/rowset/Joinable.html#setMatchColumn(int[])">setMatchColumn</A> , <A HREF="../../../javax/sql/rowset/Joinable.html#setMatchColumn(java.lang.String)">setMatchColumn</A> , <A HREF="../../../javax/sql/rowset/Joinable.html#setMatchColumn(java.lang.String[])">setMatchColumn</A> , <A HREF="../../../javax/sql/rowset/Joinable.html#unsetMatchColumn(int)">unsetMatchColumn</A> , <A HREF="../../../javax/sql/rowset/Joinable.html#unsetMatchColumn(int[])">unsetMatchColumn</A> , <A HREF="../../../javax/sql/rowset/Joinable.html#unsetMatchColumn(java.lang.String)">unsetMatchColumn</A> , <A HREF="../../../javax/sql/rowset/Joinable.html#unsetMatchColumn(java.lang.String[])">unsetMatchColumn</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="COMMIT_ON_ACCEPT_CHANGES"><!-- --></A> <H3>
COMMIT_ON_ACCEPT_CHANGES</H3>
<PRE>
static final boolean <B>COMMIT_ON_ACCEPT_CHANGES</B></PRE>
<DL>
<DD><code>acceptChanges()</code>의 호출시에,<code>CachedRowSet</code>객체의 <code>SyncProvider</code> 로 변경을 위탁시킵니다. false 로 설정되어 있는 경우, 변경 내용은,<code>CachedRowSet</code>인터페이스 트랜잭션(transaction) 메소드가 불려 갈 때까지<b>위탁되지 않습니다</b>.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#commit()"><CODE>commit()</CODE></A> , 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#rollback()"><CODE>rollback()</CODE></A> , 
<A HREF="../../../constant-values.html#javax.sql.rowset.CachedRowSet.COMMIT_ON_ACCEPT_CHANGES">정수 필드치</A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="populate(java.sql.ResultSet)"><!-- --></A> <H3>
populate</H3>
<PRE>
void <B>populate</B>(<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A> &nbsp;data)
              throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체로 지정된 <code>ResultSet</code>객체의 데이터를 읽어들입니다.  &nbsp;<P>
이 메소드는, 어플리케이션이 오픈하고 있는 <code>ResultSet</code> 객체에 접속하고 있을 때 <code>execute</code> 메소드의 대체로서 사용할 수 있습니다. 새로운 접속을 열어 이 <code>CachedRowSet</code>객체의 커멘드를 재실행할 필요가 없는 점으로써,<code>populate</code> 메소드는, 파라미터를 취하지 않는 <code>execute</code>메소드보다 효율적입니다. 또,<code>populate</code> 메소드를 사용하는 것은,<code>ResultSet</code>객체를 취하는 <code>execute</code> 메소드보다 편리합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>data</CODE> - 이 <code>CachedRowSet</code> 객체에 읽힌다
                데이터를 포함한 <code>ResultSet</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - null 의 <code>ResultSet</code> 객체가 제공되었을 경우, 또는 이 <code>CachedRowSet</code> 객체가

                관련하는 <code>ResultSetMetaData</code> 객체를 취득할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#execute(java.sql.Connection)"><CODE>execute(java.sql.Connection)</CODE></A> , 
<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스"><CODE>ResultSet</CODE></A> , 
<A HREF="../../../java/sql/ResultSetMetaData.html" title="java.sql 안의 인터페이스"><CODE>ResultSetMetaData</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="execute(java.sql.Connection)"><!-- --></A> <H3>
execute</H3>
<PRE>
void <B>execute</B>(<A HREF="../../../java/sql/Connection.html" title="java.sql 안의 인터페이스">Connection</A> &nbsp;conn)
             throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>데이터 소스가 되는 결과 세트를 생성하기 위한 지정의 접속을 사용해, 이 <code>CachedRowSet</code> 객체에 데이터를 읽어들입니다. 이 메소드는, 작성하는 모든 데이타베이스 접속을 클로즈 하는 것으로, 데이터 소스로부터 데이터를 읽어내고 있을 때와 데이터 소스에 데이터를 기입하고 있을 때 이외, 이 <code>CachedRowSet</code>객체가 미접속 상태인 것을 보증합니다.  &nbsp;<P>
이 <code>CachedRowSet</code>객체의 리더는, 행 세트의 커멘드를 실행해, 결과적으로 생성되는 <code>ResultSet</code> 객체로부터 이 <code>CachedRowSet</code> 객체에 데이터를 읽어들이기 위해서(때문에),<i>conn</i>를 사용해 데이터 소스에의 접속을 확립합니다. 또, 이 메소드는, 이 <code>CachedRowSet</code>객체의 생성 후에, <i>conn</i> 를 클로즈 합니다.  &nbsp;<P>
구현의 생성 후에 이 메소드를 호출하면(자), 컨텐츠와 메타데이타가 리셋 됩니다. 또,<code>acceptChanges</code>메소드를 호출해, 아직 적용하고 있지 않는 갱신을 확정한 뒤, 이 메소드를 호출하면(자), 갱신 내용은 없어집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>conn</CODE> - 유효한 프로퍼티을 가지는 표준 JDBC <code>Connection</code> 객체 
                properties
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 무효인 <code>Connection</code> 객체가 제공되었을 경우,
                또는 데이터 소스와의 접속의 확립시에
                에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#populate(java.sql.ResultSet)"><CODE>populate(java.sql.ResultSet)</CODE></A> , 
<A HREF="../../../java/sql/Connection.html" title="java.sql 안의 인터페이스"><CODE>Connection</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="acceptChanges()"><!-- --></A> <H3>
acceptChanges</H3>
<PRE>
void <B>acceptChanges</B>()
                   throws <A HREF="../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 내의 클래스">SyncProviderException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체에 대한 행의 갱신, 삽입, 삭제등의 변경을 부하의 데이터 소스에 전달합니다.  &nbsp;<P>
이 메소드는, 이 <code>CachedRowSet</code>객체의 라이터상에서 불려 가 배후에서 처리를 실시합니다. 표준 <code>CachedRowSet</code> 구현은,<code>SyncFactory</code>싱글 톤을 사용해 <code>SyncProvider</code> 인스턴스를 취득하는 것으로써,<code>RowSetWriter</code>객체 (라이터)를 제공합니다. 라이터는, 이 <code>CachedRowSet</code>객체에의 변경을 데이터 소스에 반송하려고 합니다.  &nbsp;<P>
<code>acceptChanges</code>메소드가 정상적으로 실행되었을 경우, 데이터 소스에 변경이 기입해져 현재의 행의 값이 원의 행의 값으로 변경됩니다.  &nbsp;<P>
사용하는 <code>SyncProvider</code>구현의 동기 레벨에 의해, 라이터는 원의 값과 데이터 소스내의 값을 비교해, 경합의 체크를 실시합니다. 경합이 검출되었을 경우, 예를 들어 <code>RIOptimisticProvider</code>구현은,<code>SyncProviderException</code> 를 throw 해, 데이터 소스에는 아무것도 기입하지 않습니다.  &nbsp;<P>
어플리케이션은,<code>SyncProviderException</code>객체를 캐치 해, 이 객체에 포함되는 <code>SyncResolver</code>객체를 취득할 수가 있습니다. <code>SyncResolver</code>객체는, 행 마다 경합을 일람 해, 현재 존재하는 경합을 해결할 때까지 새로운 경합이 발생하지 않게, 데이터 소스를 잠급니다. 게다가 개개의 경합에 대해서, 경합을 검사해, 데이터 소스에 남기는 값을 설정하는 메소드를 제공합니다. 모든 경합이 해결되면(자), 어플리케이션은 재차 <code>acceptChanges</code>메소드를 호출해, 해결된 값을 데이터 소스에 기입할 필요가 있습니다. 데이터 소스내의 모든 값이 벌써 지속치인 경우,<code>acceptChanges</code>메소드는 아무것도 실시하지 않습니다.  &nbsp;<P>
일부의 프로바이더 구현은, 경합을 막기 위해서(때문에) 락을 사용합니다. 이 경우,<code>acceptChanges</code>메소드를 호출했을 때, 라이터에 의한 데이터 소스에의 변경의 기입은 반드시 성공합니다. 이 메소드는,<code>updateRow</code>메소드,<code>insertRow</code> 메소드, 또는 <code>deleteRow</code>메소드의 호출 후 즉시 호출할 수 있습니다만, 모든 변경이 완료해, 1 개(살)만 접속을 확립하면 좋은 상태로 호출하는 편이 효율적입니다.  &nbsp;<P>
주:<code>acceptChanges()</code> 메소드는,<code>COMMIT_ON_ACCEPT_CHANGES</code>가 true 로 설정되어 있는지 어떤지를 판단합니다. true로 설정되어 있는 경우, 동기내의 모든 갱신이 데이터 소스에 위탁됩니다. 그 이외의 경우, 어플리케이션은,<code>commit()</code>메소드나 <code>rollback()</code> 메소드를 명시적으로 호출할<b>필요가 있습니다</b>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 커서가 삽입행에 있는 경우
<DD><CODE><A HREF="../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 안의 클래스">SyncProviderException</A> </CODE> - 부하의 동기 프로바이더의 라이터가, 데이터 소스에의 갱신의 기입에

                실패했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#acceptChanges(java.sql.Connection)"><CODE>acceptChanges(java.sql.Connection)</CODE></A> , 
<A HREF="../../../javax/sql/RowSetWriter.html" title="javax.sql 안의 인터페이스"><CODE>RowSetWriter</CODE></A> , 
<A HREF="../../../javax/sql/rowset/spi/SyncFactory.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncFactory</CODE></A> , 
<A HREF="../../../javax/sql/rowset/spi/SyncProvider.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncProvider</CODE></A> , 
<A HREF="../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncProviderException</CODE></A> , 
<A HREF="../../../javax/sql/rowset/spi/SyncResolver.html" title="javax.sql.rowset.spi 안의 인터페이스"><CODE>SyncResolver</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="acceptChanges(java.sql.Connection)"><!-- --></A> <H3>
acceptChanges</H3>
<PRE>
void <B>acceptChanges</B>(<A HREF="../../../java/sql/Connection.html" title="java.sql 안의 인터페이스">Connection</A> &nbsp;con)
                   throws <A HREF="../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 내의 클래스">SyncProviderException</A> </PRE>
<DL>
<DD>지정된 <code>Connection</code>객체를 사용해 데이터 소스에의 접속을 확립해,<code>CachedRowSet</code> 객체의 부하의 데이터 소스에 행의 갱신, 삽입, 삭제등의 변경을 모두 전달합니다.  &nbsp;<P>
이제(벌써) 한편의 <code>acceptChanges</code> 메소드는 <code>RowSet</code>객체내에 벌써 정의되고 있는 <code>Connection</code> 객체 (초기 생성시에 사용되는 접속)를 사용하므로, 접속을 건네받지 않습니다.  &nbsp;<P>
이 형식의 <code>acceptChanges</code>메소드는, 인수를 취하지 않는 형식과 자주(잘) 닮습니다만, 부하의 데이터 소스가 JDBC 데이터 소스인 경우 밖에 사용할 수 없는 점으로써, 그 외의 형식과는 다릅니다. <code>SyncProvider</code> 는,<code>CachedRowSet</code>객체가 정상적으로 동기 되도록(듯이), 갱신된 <code>Connection</code> 프로퍼티을 사용해 <code>RowSetWriter</code>구성을 리셋 할 필요가 있습니다.
 <P> 
<code>acceptChanges</code>메소드가 정상적으로 실행되었을 경우, 데이터 소스에 변경이 기입해져 현재의 행의 값이 원의 행의 값으로 변경됩니다.  &nbsp;<P>
사용하는 <code>SyncProvider</code>구현의 동기 레벨에 의해, 라이터는 원의 값과 데이터 소스내의 값을 비교해, 경합의 체크를 실시합니다. 경합이 검출되었을 경우, 예를 들어 <code>RIOptimisticProvider</code>구현은,<code>SyncProviderException</code> 를 throw 해, 데이터 소스에는 아무것도 기입하지 않습니다.  &nbsp;<P>
어플리케이션은,<code>SyncProviderException</code>객체를 캐치 해, 이 객체에 포함되는 <code>SyncResolver</code>객체를 취득할 수가 있습니다. <code>SyncResolver</code>객체는, 행 마다 경합을 일람 해, 현재 존재하는 경합을 해결할 때까지 새로운 경합이 발생하지 않게, 데이터 소스를 잠급니다. 게다가 개개의 경합에 대해서, 경합을 검사해, 데이터 소스에 남기는 값을 설정하는 메소드를 제공합니다. 모든 경합이 해결되면(자), 어플리케이션은 재차 <code>acceptChanges</code>메소드를 호출해, 해결된 값을 데이터 소스에 기입할 필요가 있습니다. 데이터 소스내의 모든 값이 벌써 지속치인 경우,<code>acceptChanges</code>메소드는 아무것도 실시하지 않습니다.  &nbsp;<P>
일부의 프로바이더 구현은, 경합을 막기 위해서(때문에) 락을 사용합니다. 이 경우,<code>acceptChanges</code>메소드를 호출했을 때, 라이터에 의한 데이터 소스에의 변경의 기입은 반드시 성공합니다. 이 메소드는,<code>updateRow</code>메소드,<code>insertRow</code> 메소드, 또는 <code>deleteRow</code>메소드의 호출 후 즉시 호출할 수 있습니다만, 모든 변경이 완료해, 1 개(살)만 접속을 확립하면 좋은 상태로 호출하는 편이 효율적입니다.  &nbsp;<P>
주:<code>acceptChanges()</code> 메소드는,<code>COMMIT_ON_ACCEPT_CHANGES</code>가 true 로 설정되어 있는지 어떤지를 판단합니다. true로 설정되어 있는 경우, 동기내의 모든 갱신이 데이터 소스에 위탁됩니다. false 의 경우, 어플리케이션은,<code>commit</code>메소드나 <code>rollback</code> 메소드를 명시적으로 호출할<b>필요가 있습니다</b>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>con</CODE> - 표준 JDBC <code>Connection</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 커서가 삽입행에 있는 경우
<DD><CODE><A HREF="../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 안의 클래스">SyncProviderException</A> </CODE> - 부하의 동기 프로바이더의 라이터가,
                데이터 소스에의 갱신의 기입에
                실패했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#acceptChanges()"><CODE>acceptChanges()</CODE></A> , 
<A HREF="../../../javax/sql/RowSetWriter.html" title="javax.sql 안의 인터페이스"><CODE>RowSetWriter</CODE></A> , 
<A HREF="../../../javax/sql/rowset/spi/SyncFactory.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncFactory</CODE></A> , 
<A HREF="../../../javax/sql/rowset/spi/SyncProvider.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncProvider</CODE></A> , 
<A HREF="../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncProviderException</CODE></A> , 
<A HREF="../../../javax/sql/rowset/spi/SyncResolver.html" title="javax.sql.rowset.spi 안의 인터페이스"><CODE>SyncResolver</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="restoreOriginal()"><!-- --></A> <H3>
restoreOriginal</H3>
<PRE>
void <B>restoreOriginal</B>()
                     throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체를 원의 값 (전회의 변경 세트의 전의 값)에 되돌립니다. 행 세트가 변경되어 있지 않은 경우나, 변경 세트가 1 개 밖에 없는 경우는, 이 <code>CachedRowSet</code>객체에 읽힌 값이 원의 값이 됩니다.  &nbsp;<P>
이 메소드가 불려 갔을 경우,<code>CachedRowSet</code>구현은, 현재의 행 세트 인스턴스에의 모든 갱신, 삽입, 및 삭제를 이전의 값으로 옮겨놓을 필요가 있습니다. 게다가 커서를 최초의 행에 되돌려,<code>rowSetChanged</code>이벤트를 트리거해, 등록을 마친 모든 청취자에게 통지를 보낼 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 이 <code>CachedRowSet</code> 객체의 현재의 값을
       이전의 값에 되돌리고 있는 동안에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/RowSetListener.html#rowSetChanged(javax.sql.RowSetEvent)"><CODE>RowSetListener.rowSetChanged(javax.sql.RowSetEvent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="release()"><!-- --></A> <H3>
release</H3>
<PRE>
void <B>release</B>()
             throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 현재의 컨텐츠를 해제해, 등록을 마친 모든 청취자에게 <code>rowSetChanged</code> 이벤트를 송신합니다. 이 메소드를 호출하면(자), 아직 적용되지 않은 갱신은 모두 파기되어 행 세트의 행이 모두 삭제됩니다. 부하의 데이터 소스와의 대화는 행해지지 않기 때문에, 행 세트의 컨텐츠, 메타데이타, 컨텐츠의 갱신을 복원할 수 없습니다.  &nbsp;<P>
이 <code>CachedRowSet</code>객체는, 컨텐츠와 그 갱신이 완전하게 소거될 때까지 락 됩니다.  따라서, 이 <code>RowSet</code>객체에의 참조를 포함하는 그 외의 컴퍼넌트에 의한 더티 읽기는 발생하지 않습니다. 또, 이 <code>CachedRowSet</code>객체를 읽어내는 모든 컴퍼넌트가 읽기를 완료할 때까지, 컨텐츠를 해제할 수 없습니다. 이 <code>CachedRowSet</code>객체의 동작은,<code>rowSetChanged</code> 이벤트가 트리거된 뒤, 정상적인 상태에 돌아옵니다.  &nbsp;<P>
JDBC 프로퍼티과 Synchronization SPI 프로퍼티을 포함한 메타데이타는, 장래 사용하기 위해서 보관 유지됩니다. <code>command</code>프로퍼티등의 프로퍼티은, 이 <code>CachedRowSet</code>객체의 생성원의 데이터 소스에 관련지을 필요가 있습니다.  &nbsp;<P>
<code>close</code> 메소드는, 모든 행 세트를 복원 가능으로 해, 가비지 컬렉터에 행 세트의 Java VM자원을 허가합니다만, 이 메소드는, 행 세트를 비웁니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 이 <code>CachedRowSet</code> 객체의 컨텐츠의 플래시시에
                에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/RowSetListener.html#rowSetChanged(javax.sql.RowSetEvent)"><CODE>RowSetListener.rowSetChanged(javax.sql.RowSetEvent)</CODE></A> , 
<A HREF="../../../java/sql/ResultSet.html#close()"><CODE>ResultSet.close()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="undoDelete()"><!-- --></A> <H3>
undoDelete</H3>
<PRE>
void <B>undoDelete</B>()
                throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>현재의 행의 삭제를 취소해, 청취자로 행이 변경된 것을 통지합니다. 이 메소드를 호출한 뒤, 현재의 행은 삭제의 대상으로부터 제외됩니다. 이 메소드는, 행 세트의 수명의 사이 언제라도 호출할 수가 있습니다.  &nbsp;<P>
게다가 복수의 행의 삭제를 취소할 수도 있습니다.  이 경우는, 다음과 같은 커서 위치 제어 메소드를 사용해, 커서의 위치를 조정합니다.
 <ul>
<li><code>CachedRowSet.absolute</code>
<li><code>CachedRowSet.first</code>
<li><code>CachedRowSet.last</code>
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - (1) 현재의 행이 삭제되어 있지 않은 경우,
 (2) 커서가 삽입행, 최초의 행의 전,
 또는 맨 마지막 줄의 뒤에 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoInsert()"><CODE>undoInsert()</CODE></A> , 
<A HREF="../../../java/sql/ResultSet.html#cancelRowUpdates()"><CODE>ResultSet.cancelRowUpdates()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="undoInsert()"><!-- --></A> <H3>
undoInsert</H3>
<PRE>
void <B>undoInsert</B>()
                throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>만약 행이 삽입된 상태이면,<code>CachedRowSet</code> 객체로부터 현재의 행을 즉시 삭제해, 청취자로 행이 변경된 것을 통지합니다. 이 메소드는, 행 세트의 수명의 사이 언제라도 호출할 수 있습니다.  현재의 행이 예외 제한 (아래와 같이 참조) 내에 있는 경우, 현재의 행의 삽입을 취소합니다.  &nbsp;<P>
게다가 복수의 행의 삽입을 취소할 수도 있습니다.  이 경우는, 다음과 같은 커서 위치 제어 메소드를 사용해, 커서의 위치를 조정합니다.
 <ul>
<li><code>CachedRowSet.absolute</code>
<li><code>CachedRowSet.first</code>
<li><code>CachedRowSet.last</code>
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - (1) 현재의 행이 삽입되어 있지 않은 경우,
 (2) 커서가 최초의 행의 전, 맨 마지막 줄의 뒤,
 또는 삽입행에 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoDelete()"><CODE>undoDelete()</CODE></A> , 
<A HREF="../../../java/sql/ResultSet.html#cancelRowUpdates()"><CODE>ResultSet.cancelRowUpdates()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="undoUpdate()"><!-- --></A> <H3>
undoUpdate</H3>
<PRE>
void <B>undoUpdate</B>()
                throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>만약 행이 변경되고 있으면, 전회의 갱신 조작을 즉시 바탕으로 되돌립니다. 이 메소드는, 최종적으로 은행내의 모든 갱신이 전회의 동기화 (<code>acceptChanges</code>) 또는 생성의 직전 상태에 돌아오도록(듯이), 모든 열의 갱신을 바탕으로 되돌립니다. 이 메소드는, 삽입행의 갱신중에도 호출할 수가 있습니다.  &nbsp;<P>
<code>undoUpdate</code> 는, 행 세트의 수명의 사이 언제라도 호출할 수가 있습니다. 다만, 동기화를 한 뒤, 행 세트에 한층 더 변경이 더해질 때까지는, 이 메소드는 아무것도 실시하지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 커서가, 이 <code>CachedRowSet</code> 객체의
     최초의 행의 전 또는 마지막 행의 뒤에 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoDelete()"><CODE>undoDelete()</CODE></A> , 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoInsert()"><CODE>undoInsert()</CODE></A> , 
<A HREF="../../../java/sql/ResultSet.html#cancelRowUpdates()"><CODE>ResultSet.cancelRowUpdates()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="columnUpdated(int)"><!-- --></A> <H3>
columnUpdated</H3>
<PRE>
boolean <B>columnUpdated</B>(int&nbsp;idx)
                      throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 현재의 은행내의 지정된 열이 갱신되었는지의 여부를 나타냅니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>idx</CODE> - 갱신의 체크를 실시하는 열을 나타내는 <code>int</code>
<DT><B>반환값:</B><DD>지정된 열이 분명하게 갱신되고 있는 경우는 <code>true</code>,
                그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 커서가 삽입행, 최초의 행의 전,
       또는 맨 마지막 줄의 뒤에 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/sql/DatabaseMetaData.html#updatesAreDetected(int)"><CODE>DatabaseMetaData.updatesAreDetected(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="columnUpdated(java.lang.String)"><!-- --></A> <H3>
columnUpdated</H3>
<PRE>
boolean <B>columnUpdated</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;columnName)
                      throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 현재의 은행내의 지정된 열이 갱신되었는지의 여부를 나타냅니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnName</CODE> - 갱신의 체크를 실시하는 열의 
        이름을 지정하는 <code>String</code> 객체
<DT><B>반환값:</B><DD>열이 분명하게 갱신되고 있는 경우는 <code>true</code>,
                그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 커서가 삽입행, 최초의 행의 전,
       또는 맨 마지막 줄의 뒤에 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/sql/DatabaseMetaData.html#updatesAreDetected(int)"><CODE>DatabaseMetaData.updatesAreDetected(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toCollection()"><!-- --></A> <H3>
toCollection</H3>
<PRE>
<A HREF="../../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;? &gt; <B>toCollection</B>()
                           throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체를, 이 <code>CachedRowSet</code> 객체의 모든 데이터를 포함하는 <code>Collection</code> 객체로 변환합니다. Collection</code> 시스템의 추상성에 의해, 구현은, 이 <code>Collection</code>객체를 어느 정도 자유롭게 표현할 수가 있습니다. 각 행은 범용적인 <code>Collection</code>구현인가, 또는 <code>TreeMap</code>객체나 <code>Vector</code>객체등이 특수한 <code>Collection</code>구현의 어느 쪽인지로 완전하게 표현할 필요가 있습니다. SQL <code>NULL</code>렬치는 Java 프로그램 언어로 <code>null</code> 로서 표현할 필요가 있습니다.  &nbsp;<P>
<code>CachedRowSet</code> 인터페이스의 표준적인 레퍼런스 구현에서는, 행 세트에 <code>TreeMap</code>객체를 사용해, 각 행의 값을 <code>Vector</code>객체에 포함합니다. 대부분의 구현으로와 같이  처리하는 것이 상정됩니다.  &nbsp;<P>
<code>TreeMap</code>형의 컬렉션에 의해, 키의 클래스의 본래의 순서에 따라, 맵이 승순으로 소트 됩니다. 각 키는,<code>RowSet</code>객체의 1 행에 대응하는 <code>Vector</code> 객체를 참조합니다. 따라서, 각 <code>Vector</code>객체의 사이즈는,<code>RowSet</code> 객체내의 렬수에 정확하게 일치할 필요가 있습니다. <code>TreeMap</code>컬렉션으로 사용하는 키는, 구현 마다 결정합니다.  구현에서는,<code>RowSet</code> 객체 자체, 또는 부하의 SQL 데이터에 벌써 설정되어 있는 키에 의해, 내부의 <code>RowSet</code>표 구조내의 사용 가능한 세트 키를 이용할 수가 있습니다.  &nbsp;<P>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code> 객체의 각 행의 
                값을 포함하는 <code>Collection</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 컬렉션의 생성시에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection(int)"><CODE>toCollection(int)</CODE></A> , 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection(java.lang.String)"><CODE>toCollection(String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toCollection(int)"><!-- --></A> <H3>
toCollection</H3>
<PRE>
<A HREF="../../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;? &gt; <B>toCollection</B>(int&nbsp;column)
                           throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체내의 지정된 열을 <code>Collection</code> 객체로 변환합니다. Collection</code> 시스템의 추상성에 의해, 구현은, 이 <code>Collection</code>객체를 어느 정도 자유롭게 표현할 수가 있습니다. 각 렬치는 범용적인 <code>Collection</code> 구현인가, 또는 <code>Vector</code>객체등이 특수한 <code>Collection</code> 구현의 어느 쪽인지로 완전하게 표현할 필요가 있습니다. SQL <code>NULL</code>렬치는 Java 프로그램 언어로 <code>null</code> 로서 표현할 필요가 있습니다.  &nbsp;<P>
표준적인 레퍼런스 구현에서는,<code>Vector</code>객체를 사용해, 렬치를 포함합니다만, 대부분의 구현으로와 같이  처리하는 것이 상정됩니다. <code>Vector</code>객체를 사용하는 경우는, 사이즈를 이 <code>CachedRowSet</code>객체의 행수와 정확하게 일치시킬 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>column</CODE> - 치를 <code>Collection</code> 객체로 표현한다
        열을 나타내는 <code>int</code>
<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code> 객체의 지정된 열에 포함되었다
                값을 포함한 <code>Collection</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 컬렉션의 생성시에 에러가 발생했을 경우,
                또는 무효인 열 ID 가 제공되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection()"><CODE>toCollection()</CODE></A> , 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection(java.lang.String)"><CODE>toCollection(String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toCollection(java.lang.String)"><!-- --></A> <H3>
toCollection</H3>
<PRE>
<A HREF="../../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;? &gt; <B>toCollection</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;column)
                           throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체내의 지정된 열을 <code>Collection</code>객체로 변환합니다. <code>Collection</code> 시스템의 추상성에 의해, 구현은, 이 <code>Collection</code>객체를 어느 정도 자유롭게 표현할 수가 있습니다. 각 렬치는 범용적인 <code>Collection</code> 구현인가, 또는 <code>Vector</code>객체등이 특수한 <code>Collection</code> 구현의 어느 쪽인지로 완전하게 표현할 필요가 있습니다. SQL <code>NULL</code>렬치는 Java 프로그램 언어로 <code>null</code> 로서 표현할 필요가 있습니다.  &nbsp;<P>
표준적인 레퍼런스 구현에서는,<code>Vector</code>객체를 사용해, 렬치를 포함합니다만, 대부분의 구현으로와 같이  처리하는 것이 상정됩니다. <code>Vector</code>객체를 사용하는 경우는, 사이즈를 이 <code>CachedRowSet</code>객체의 행수와 정확하게 일치시킬 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>column</CODE> - 컬렉션으로 표현되는 값을 가지는 열의 
        이름을 지정하는 <code>String</code> 객체
<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code> 객체의 지정된 열에 포함되었다
                값을 포함한 <code>Collection</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 컬렉션의 생성시에 에러가 발생했을 경우,
                또는 무효인 열 ID 가 제공되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection()"><CODE>toCollection()</CODE></A> , 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection(int)"><CODE>toCollection(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSyncProvider()"><!-- --></A> <H3>
getSyncProvider</H3>
<PRE>
<A HREF="../../../javax/sql/rowset/spi/SyncProvider.html" title="javax.sql.rowset.spi 안의 클래스">SyncProvider</A>  <B>getSyncProvider</B>()
                             throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 <code>SyncProvider</code> 구현을 가져옵니다. 행 세트는, 이 메소드를 내부에서 사용해, 행 세트와 데이터 소스간의 읽어내 또는 기입해 조작을 트리거합니다. 예를 들어, 행 세트는, 데이터를 포함하기 위해(때문에),<code>SyncProvider</code>로부터 행 세트 리더 (<code>RowSetReader</code>객체)의 핸들을 취득해야 하는 경우가 있습니다.
 <pre>
     RowSetReader rowsetReader = null;
     SyncProvider provider = 
         SyncFactory.getInstance("javax.sql.rowset.provider.RIOptimisticProvider");
         if (provider instanceof RIOptimisticProvider) {
             rowsetReader = provider.getRowSetReader();
         }
 </pre>
<i>rowsetReader</i>가 행 세트 구현내의 private 인 액세스 가능 필드이다고 하면(자), 어플리케이션이 <code>execute</code>메소드를 호출하면(자), 이 메소드는 리더의 <code>readData</code>메소드를 호출해,<code>RowSet</code>객체에 데이터를 포함합니다.  <cmnt2trhtml><pre>    
     rowsetReader.readData((RowSetInternal) this);
 </pre>
 <P>
게다가 어플리케이션은 이 메소드로부터 반환되는 <code>SyncProvider</code>객체를 사용해, 벤더, 버젼, 프로바이더 ID, 동기의 그레이드, 현재 설정되어 있는 락등의 <code>SyncProvider</code>객체에 관한 정보를 돌려주는 메소드를 호출할 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행 세트가 인스턴스화 되었을 때에 설정된 <code>SyncProvider</code> 객체.
      또는, 설정되어 있지 않은 경우는 디폴트의 프로바이더
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - <code>SyncProvider</code> 객체를 돌려줄 때
                에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setSyncProvider(java.lang.String)"><CODE>setSyncProvider(java.lang.String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSyncProvider(java.lang.String)"><!-- --></A> <H3>
setSyncProvider</H3>
<PRE>
void <B>setSyncProvider</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;provider)
                     throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 <code>SyncProvider</code> 객체로 지정한 객체를 설정합니다. 이 메소드로,<code>SyncProvider</code>객체를 리셋 할 수 있습니다.  &nbsp;<P>
<code>CachedRowSet</code> 구현은 항상 이용 가능한 <code>SyncProvider</code>기구로 인스턴스화할 필요가 있습니다만,<code>SyncProvider</code>객체의 리셋가 바람직한, 또는 필요하게 되는 경우도 있습니다. 예를 들어, 어플리케이션으로, 당분간은 디폴트의 <code>SyncProvider</code>객체를 사용해 두어, 나중에 최근 이용할 수 있게 된, 보다 필요하게 이루어지는 프로바이더를 선택해 사용할 수가 있습니다.  &nbsp;<P>
<code>SyncProvider</code> 객체를 리셋 하면(자),<code>RowSet</code>객체는 <code>SyncFactory</code> 로부터 새로운 <code>SyncProvider</code>구현을 요구합니다. 이것에 의해, 이전의 모든 접속과 원의 데이터 소스와의 관계를 리셋 해, 미접속의 행 세트의 동기 동작을 큰폭으로 변경할 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>provider</CODE> - <code>SyncProvider</code> 구현의
        완전 수식 클래스명을 지정하는 <code>String</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - <code>SyncProvider</code> 구현의 리셋중에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getSyncProvider()"><CODE>getSyncProvider()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A> <H3>
size</H3>
<PRE>
int <B>size</B>()</PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체내의 행수를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행 세트내의 행수</DL>
</DD>
</DL>
<HR>

<A NAME="setMetaData(javax.sql.RowSetMetaData)"><!-- --></A> <H3>
setMetaData</H3>
<PRE>
void <B>setMetaData</B>(<A HREF="../../../javax/sql/RowSetMetaData.html" title="javax.sql 안의 인터페이스">RowSetMetaData</A> &nbsp;md)
                 throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>지정된 <code>RowSetMetaData</code>객체를 사용해,<code>CachedRowSet</code> 객체의 메타데이타를 설정합니다. RowSetReader</code>객체는, 행 세트의 컨텐츠를 읽어낼 때에,<code>RowSetMetaData</code>객체를 생성해,<code>RowSetMetaData</code>구현내의 메소드를 사용해 이것을 초기화합니다. 레퍼런스 구현에서는 <code>RowSetMetaDataImpl</code>클래스를 사용합니다. 리더가 행 세트의 컨텐츠의 읽기를 완료하면(자), 이 메소드가 내부에서 불려 가<code>RowSetMetaData</code>객체가 행 세트에게 건네집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>md</CODE> - 이 <code>CachedRowSet</code>객체의 열에 관한 메타데이타를 포함하는 <code>RowSetMetaData</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 행 세트에 무효인 메타데이타가
                제공되었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getOriginal()"><!-- --></A> <H3>
getOriginal</H3>
<PRE>
<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A>  <B>getOriginal</B>()
                      throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 원의 값을 포함하는 <code>ResultSet</code> 객체를 돌려줍니다.  &nbsp;<P>
<code>ResultSet</code> 객체의 커서는, 선두행의 전에 둘 필요가 있습니다. 게다가 반환되는 <code>ResultSet</code>객체는 다음의 프로퍼티을 가질 필요가 있습니다.
 <UL>
<LI>ResultSet.TYPE_SCROLL_INSENSITIVE
<LI>ResultSet.CONCUR_UPDATABLE
 </UL>
 <P>
<code>RowSet</code>객체의 원의 값은, 부하의 데이터 소스와 마지막 동기의 앞에 포함되고 있던 값입니다. 동기가 없었던 경우, 원의 값은,<code>RowSet</code>객체에 포함된 값이 됩니다. 이 메소드는, 어플리케이션이 <code>acceptChanges</code>메소드를 호출해,<code>SyncProvider</code>객체가 경합을 확인하도록(듯이) 구현되고 있는 경우에, 내부에서 불려 갑니다. 이 경우, 라이터는 원의 값과 데이터 소스내의 현재의 값을 비교해, 경합을 확인합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code> 객체의 
         원의 값을 포함하는 <code>ResultSet</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - <code>ResultSet</code> 객체의 생성시에 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getOriginalRow()"><!-- --></A> <H3>
getOriginalRow</H3>
<PRE>
<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A>  <B>getOriginalRow</B>()
                         throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 현재의 행만의 원의 값을 포함하는 <code>ResultSet</code> 객체를 돌려줍니다.  &nbsp;<P>
<code>ResultSet</code> 객체의 커서는, 선두행의 전에 둘 필요가 있습니다. 게다가 반환되는 <code>ResultSet</code>객체는 다음의 프로퍼티을 가질 필요가 있습니다.
 <UL>
<LI>ResultSet.TYPE_SCROLL_INSENSITIVE
<LI>ResultSet.CONCUR_UPDATABLE
 </UL>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행의 원의 결과 세트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 현재행이 존재하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setOriginalRow()"><CODE>setOriginalRow()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setOriginalRow()"><!-- --></A> <H3>
setOriginalRow</H3>
<PRE>
void <B>setOriginalRow</B>()
                    throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 현재의 행을 원의 행으로서 설정합니다.  &nbsp;<P>
이 메소드는, 현재의 행의 변경된 값이 데이터 소스와 동기 된 뒤에, 내부에서 불려 갑니다. 현재의 행은, 삽입, 삭제, 또는 갱신으로서 태그 붙이고 되어 있어서는 안됩니다.  &nbsp;<P>
<code>setOriginalRow</code> 의 호출은 취소할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 현재행이 존재하지 않는 경우,
                또는 원의 행의 컨텐츠의 리셋시에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getOriginalRow()"><CODE>getOriginalRow()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTableName()"><!-- --></A> <H3>
getTableName</H3>
<PRE>
<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A>  <B>getTableName</B>()
                    throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 작성에 사용된 객체 (테이블)의 식별자를 돌려줍니다. 이 이름은, 반복 설정할 수 있습니다.  이름의 설정 회수나, 표준 구현이 이전의 테이블명을 추적할 필요가 있을지 어떨지에 대해서는, 스펙에 의한 제한은 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code> 객체의 데이터의 소스이다
         테이블명을 지정하는 <code>String</code> 객체.
         또는, 테이블의 이름을 설정하고 있지 않는 경우는 <code>null</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 테이블명을 돌려줄 때 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/sql/ResultSetMetaData.html#getTableName(int)"><CODE>ResultSetMetaData.getTableName(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setTableName(java.lang.String)"><!-- --></A> <H3>
setTableName</H3>
<PRE>
void <B>setTableName</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;tabName)
                  throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 파생원의 테이블의 식별자를, 지정의 테이블명으로 설정합니다. 라이터는, 동기시에, 이 이름을 사용해, 데이터 소스의 값과 <code>CachedRowSet</code>객체의 값을 비교할 때에 사용하는 테이블을 판단합니다. 테이블의 식별자는, 이 <code>CachedRowSet</code>객체로부터 변경된 값을 기입하는 장소도 가리킵니다.  &nbsp;<P>
이 <code>CachedRowSet</code> 객체의 구현에서는, 내부적으로 <code>RowSetMetaDataImpl</code>객체에 이름을 취득시킬 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tabName</CODE> - 이 <code>CachedRowSet</code>객체가 파생했다
             테이블을 식별하는 <code>String</code> 객체. <code>null</code> 는 불가,
         빈 상태(empty)의 캐릭터 라인은 가능
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 테이블의 이름부로 에러가 발생했을 경우,
     또는 <i>tabName</i> 가 <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/RowSetMetaData.html#setTableName(int, java.lang.String)"><CODE>RowSetMetaData.setTableName(int, java.lang.String)</CODE></A> , 
<A HREF="../../../javax/sql/RowSetWriter.html" title="javax.sql 안의 인터페이스"><CODE>RowSetWriter</CODE></A> , 
<A HREF="../../../javax/sql/rowset/spi/SyncProvider.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncProvider</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getKeyColumns()"><!-- --></A> <H3>
getKeyColumns</H3>
<PRE>
int[] <B>getKeyColumns</B>()
                    throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 행을 일의에 식별하는 키를 구성하는 열을 나타내는 1개이상의 열번호를 포함하는 배열을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code> 객체의 행의
       주키를 구성한다
       열을 나타내는 열번호를 포함하는 배열. 주키를 표현하는 열이 없는 경우,
       이 배열은 비운다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 이 <code>CachedRowSet</code> 객체가 빈 상태(empty)의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setKeyColumns(int[])"><CODE>setKeyColumns(int[])</CODE></A> , 
<A HREF="../../../javax/sql/rowset/Joinable.html#getMatchColumnIndexes()"><CODE>Joinable.getMatchColumnIndexes()</CODE></A> , 
<A HREF="../../../javax/sql/rowset/Joinable.html#getMatchColumnNames()"><CODE>Joinable.getMatchColumnNames()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setKeyColumns(int[])"><!-- --></A> <H3>
setKeyColumns</H3>
<PRE>
void <B>setKeyColumns</B>(int[]&nbsp;keys)
                   throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 <code>keyCols</code> 필드에, 지정된 열번호의 배열 (이 <code>CachedRowSet</code> 객체내의 행을 일의에 식별하는 키를 구성한다)을 설정합니다.  &nbsp;<p>
<code>CachedRowSet</code> 객체가 <code>JoinRowSet</code>객체에 포함되는 경우, 키열로서 지정된 열이 일치열이 되면, 이 메소드로 정의된 키와 생성된 제약은 보관 유지됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>keys</CODE> - 이 <code>CachedRowSet</code> 객체의 주키를 구성한다
        열을 나타내는 <code>int</code> 배열.
        배열내의 각 요소는,<code>0</code> 보다 크고,
        한편 이 행 세트내의 렬수이하일 필요가 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 지정된 배열내의 번호가
            이 행 세트로 유효하지 않은 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getKeyColumns()"><CODE>getKeyColumns()</CODE></A> , 
<A HREF="../../../javax/sql/rowset/Joinable.html#setMatchColumn(java.lang.String)"><CODE>Joinable.setMatchColumn(String)</CODE></A> , 
<A HREF="../../../javax/sql/rowset/Joinable.html#setMatchColumn(int)"><CODE>Joinable.setMatchColumn(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createShared()"><!-- --></A> <H3>
createShared</H3>
<PRE>
<A HREF="../../../javax/sql/RowSet.html" title="javax.sql 안의 인터페이스">RowSet</A>  <B>createShared</B>()
                    throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체와 같은 데이터에 의해, 백업 된 새로운 <code>RowSet</code> 객체를 돌려줍니다. 실제로 양쪽 모두의 <code>CachedRowSet</code>객체는 같은 데이터상에 커서를 가집니다. 그 결과, 원의 객체에 의한 변경이, 그 모든 중복에 가시인 것과 같게, 중복에 의한 모든 변경이, 원의 객체와 그 외의 모든 중복에 가시가 됩니다. 중복으로 부하의 데이터를 변경하는 메소드를 호출하면(자), 그 메소드는, 원의 <code>CachedRowSet</code>객체에 의해 불려 가는 경우와 완전히 똑같이, 등록된 모든 청취자에게 통지합니다.  &nbsp;<P>
게다가 이 메소드에 의해 작성되는 <code>RowSet</code> 객체는 이 <code>CachedRowSet</code>객체와 같은 프로퍼티을 가집니다. 예를 들어, 이 <code>CachedRowSet</code>객체가 읽어내 전용의 경우, 그 모든 중복도 읽어내 전용이 됩니다. 이것을 갱신 가능하게 변경하면(자), 중복도 갱신 가능하게 됩니다.  &nbsp;<P>
주:복수의 thread가 <code>createShared()</code> 메소드에 의해 작성된 <code>RowSet</code>객체에 액세스 하는 경우, 공유 데이터의 무결성을 확보하기 위해(때문에), 다음의 동작이 지정됩니다. 모든 공유된 <code>RowSet</code>객체의 읽기와 기입은, 각 객체와 부하의 단일의 겉(표) 구조간에 순서대로 행해질 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code> 객체와 같은 프로퍼티을 가져,
         같은 데이터상에 커서를 가진다
         새로운 공유 <code>RowSet</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 에러가 발생했을 경우, 또는 부하의 플랫폼에서 복제가 지원되어 있지 않은 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/RowSetEvent.html" title="javax.sql 내의 클래스"><CODE>RowSetEvent</CODE></A> , 
<A HREF="../../../javax/sql/RowSetListener.html" title="javax.sql 안의 인터페이스"><CODE>RowSetListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createCopy()"><!-- --></A> <H3>
createCopy</H3>
<PRE>
<A HREF="../../../javax/sql/rowset/CachedRowSet.html" title="javax.sql.rowset 안의 인터페이스">CachedRowSet</A>  <B>createCopy</B>()
                        throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 데이터의 딥 카피인 <code>RowSet</code> 객체를 작성합니다. createShared</code>호출에 의해 생성된 <code>RowSet</code>객체의 경우와는 달라, 원의 <code>RowSet</code>객체의 카피의 갱신이, 원의 <code>RowSet</code>객체에 가시여 되지 않습니다. 또, 원의 <code>RowSet</code>에 등록된 이벤트 청취자의 스코프에, 새로운 <code>RowSet</code>카피가 포함되어 있어 되지 않습니다. 또, 확립 끝난 제약 제한은 보관 유지되지 않으면 안됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>새로운 <code>RowSet</code>객체. <code>
              <code>CachedRowSet</code> 객체의 딥 카피이며, 이 <code>CachedRowSet</code> 객체로부터는 완전하게 독립하고 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - <code>CachedRowSet</code> 객체의 카피의 생성시에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createShared()"><CODE>createShared()</CODE></A> , 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopySchema()"><CODE>createCopySchema()</CODE></A> , 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopyNoConstraints()"><CODE>createCopyNoConstraints()</CODE></A> , 
<A HREF="../../../javax/sql/RowSetEvent.html" title="javax.sql 안의 클래스"><CODE>RowSetEvent</CODE></A> , 
<A HREF="../../../javax/sql/RowSetListener.html" title="javax.sql 안의 인터페이스"><CODE>RowSetListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createCopySchema()"><!-- --></A> <H3>
createCopySchema</H3>
<PRE>
<A HREF="../../../javax/sql/rowset/CachedRowSet.html" title="javax.sql.rowset 안의 인터페이스">CachedRowSet</A>  <B>createCopySchema</B>()
                              throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 빈 상태(empty)의 카피인 <code>CachedRowSet</code> 객체를 작성합니다. 카피에는, 아무것도 포함하지 않고, 원의 <code>CachedRowSet</code>객체의 겉(표) 구조만을 표현할 필요가 있습니다. 게다가 원의 <code>CachedRowSet</code>객체로 설정된 주키 또는 외부 키의 제약을, 새로운 빈 상태(empty)의 <code>CachedRowSet</code>객체에도 동일하게 적용할 필요가 있습니다. <code>createShared</code>메소드 호출에 의해 생성된 <code>RowSet</code>객체와는 달라,<code>createCopySchema</code>메소드에 의한 이 <code>CachedRowSet</code>객체의 카피에의 갱신은 가시으로서는 안됩니다.  &nbsp;<P>
어플리케이션은, 이 메소드에 의해 반환된 <code>CachedRowSet</code> 객체로부터 <code>WebRowSet</code>객체를 형성해, 나중에 사용하기 위해서,<code>RowSet</code> schema 정의를 XML 에 export 할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 이 <code>CachedRowSet</code> 객체의
         구조의 복제시에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createShared()"><CODE>createShared()</CODE></A> , 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopySchema()"><CODE>createCopySchema()</CODE></A> , 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopyNoConstraints()"><CODE>createCopyNoConstraints()</CODE></A> , 
<A HREF="../../../javax/sql/RowSetEvent.html" title="javax.sql 안의 클래스"><CODE>RowSetEvent</CODE></A> , 
<A HREF="../../../javax/sql/RowSetListener.html" title="javax.sql 안의 인터페이스"><CODE>RowSetListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createCopyNoConstraints()"><!-- --></A> <H3>
createCopyNoConstraints</H3>
<PRE>
<A HREF="../../../javax/sql/rowset/CachedRowSet.html" title="javax.sql.rowset 안의 인터페이스">CachedRowSet</A>  <B>createCopyNoConstraints</B>()
                                     throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체의 딥 카피이지만, 독립하고 있는 <code>CachedRowSet</code> 객체를 작성합니다. createShared</code>메소드 호출에 의해 생성된 <code>RowSet</code>객체의 경우와는 달라, 이 <code>CachedRowSet</code>객체의 카피에 대해서 행해진 변경은 가시여 되지 않습니다. 게다가 이 <code>CachedRowSet</code>객체에 의해 등록된 모든 이벤트 청취자의 스코프에 새로운 <code>RowSet</code>객체가 포함되어 있어 되지 않습니다. 또, 이 <code>CachedRowSet</code>객체에 대해서 확립된 제약 제한은 카피에 유지<b>되고 있어 되지 않습니다</b>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>새로운 <code>CachedRowSet</code>객체. <code>
              <code>CachedRowSet</code> 객체의 딥 카피이며, 이 <code>CachedRowSet</code> 객체로부터는 완전하게 독립하고 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - <code>CachedRowSet</code> 객체의 카피의 생성시에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopy()"><CODE>createCopy()</CODE></A> , 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#createShared()"><CODE>createShared()</CODE></A> , 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopySchema()"><CODE>createCopySchema()</CODE></A> , 
<A HREF="../../../javax/sql/RowSetEvent.html" title="javax.sql 안의 클래스"><CODE>RowSetEvent</CODE></A> , 
<A HREF="../../../javax/sql/RowSetListener.html" title="javax.sql 안의 인터페이스"><CODE>RowSetListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRowSetWarnings()"><!-- --></A> <H3>
getRowSetWarnings</H3>
<PRE>
<A HREF="../../../javax/sql/rowset/RowSetWarning.html" title="javax.sql.rowset 안의 클래스">RowSetWarning</A>  <B>getRowSetWarnings</B>()
                                throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>RowSet</code> 객체에 관한 호출에 의해 보고되는 최초의 경고를 돌려줍니다. 후속의 <code>RowSet</code>객체의 경고는, 이 메소드가 돌려주는 <code>RowSetWarning</code>객체에 체인 됩니다.

경고 체인은, 새로운 행이 읽힐 때마다 자동적으로 클리어 됩니다. 이 메소드는 클로즈 된 RowSet 객체의 호출에는 사용하지 않습니다.  사용하면(자) <code>SQLException</code> 가 throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>RowSetWarning. 보고된 최초의 <code>RowSetWarning</code> 객체.
 없는 경우는 null
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 이 메소드가, 닫혀진 RowSet 상에서 불려 갔을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/RowSetWarning.html" title="javax.sql.rowset 내의 클래스"><CODE>RowSetWarning</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getShowDeleted()"><!-- --></A> <H3>
getShowDeleted</H3>
<PRE>
boolean <B>getShowDeleted</B>()
                       throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>삭제 마크를 붙일 수 있었던 행을 현재의 행 세트내에 표시할지 어떨지를 나타내는 <code>boolean</code> 를 가져옵니다. true</code> 가 돌려주어졌을 경우, 삭제행은 현재의 행과 함께 표시됩니다. <code>false</code> 가 돌려주어졌을 경우, 삭제행은 현재의 행세트내에 표시되지 않습니다. 디폴트 값는 <code>false</code> 입니다.  &nbsp;<P>
표준행 세트 구현은, 시큐리티상의 배려 또는 특정의 배치 시나리오에 적합시키기 (위해)때문에, 이 동작을 제한할 수가 있습니다. 이것은, 정의 끝난 구현으로서 남겨져 표준의 동작을 나타내지 않습니다.  &nbsp;<P>
주:삭제된 행을 표시하면(자), 일부의 표준 JDBC <code>RowSet</code>구현 메소드의 동작이 복잡하게 됩니다. 그러나, 삭제된 행을 표시하는 기능은, 매우 전문적인 어플리케이션으로 밖에 사용되지 않습니다.  따라서, 대부분의 행 세트 사용자는, 이 설정을 무시해 괜찮습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>삭제된 행을 표시하는 경우는 <code>true</code>,
         그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 행 세트 구현이, 삭제행이 표시될지 어떨지를 판단할 수  없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setShowDeleted(boolean)"><CODE>setShowDeleted(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setShowDeleted(boolean)"><!-- --></A> <H3>
setShowDeleted</H3>
<PRE>
void <B>setShowDeleted</B>(boolean&nbsp;b)
                    throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>showDeleted</code> 프로퍼티으로서 삭제 마크 첨부의 행을 현재의 행 세트내에 표시할지 어떨지를 지정하는 <code>boolean</code> 를 설정합니다. 값이 <code>true</code> 의 경우, 삭제된 행이 현재의 행 세트와 함께 표시됩니다. 값이 <code>false</code> 의 경우, 삭제된 행은 현재의 행 세트내에 표시되지 않습니다.  &nbsp;<P>
표준행 세트 구현은, 시큐리티상의 배려 또는 특정의 배치 시나리오에 적합시키기 (위해)때문에, 이 동작을 제한할 수가 있습니다. 이것은, 정의 끝난 구현으로서 남겨져 표준의 동작을 나타내지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>b</CODE> - 삭제된 행을 표시하는 경우는 <code>true</code>,
              그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 행 세트 구현이, 삭제행의 표시 또는 비표시의 설정을 리셋 할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getShowDeleted()"><CODE>getShowDeleted()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="commit()"><!-- --></A> <H3>
commit</H3>
<PRE>
void <B>commit</B>()
            throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>CachedRowSet</code> 객체의 <code>SyncProvider</code> 에는,<code>ResultSet</code> 의 <code>Connection</code> 객체인가, 생성자 에게 건네지는 JDBC 프로퍼티이 포함됩니다. 이 메소드는,<code>Connection</code> 위탁 메소드를 랩 해, 유연한 자동 위탁 또는 비자동 위탁의 트랜잭션(transaction) 제어 지원를 제공합니다.  &nbsp;<p>
전회의 위탁/롤백(rollback)의 뒤,<code>acceptChanges()</code>메소드에 의해 행해진 모든 변경을 영속적인 것으로 합니다. 이 메소드는 자동 위탁 모드가 무효가 되어 있을 때 밖에 사용할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 데이타베이스 액세스 에러가 발생했을 경우,
 또는 이 <code>CachedRowSet</code> 내의 Connection 객체가 자동 위탁 모드인 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/sql/Connection.html#setAutoCommit(boolean)"><CODE>Connection.setAutoCommit(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="rollback()"><!-- --></A> <H3>
rollback</H3>
<PRE>
void <B>rollback</B>()
              throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>CachedRowSet</code> 객체의 <code>SyncProvider</code> 에는, 원의 <code>ResultSet</code> 의 <code>Connection</code> 객체인가, 거기에 건네받는 JDBC 프로퍼티이 포함됩니다.  &nbsp;<p>
현재의 트랜잭션(transaction)에서의 모든 변경을 취소합니다. 이 메소드는 자동 위탁 모드가 무효가 되어 있을 때 밖에 사용할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 데이타베이스 액세스 에러가 발생했을 경우,
 또는 이 <code>CachedRowSet</code> 내의 Connection 객체가 자동 위탁 모드인 경우</DL>
</DD>
</DL>
<HR>

<A NAME="rollback(java.sql.Savepoint)"><!-- --></A> <H3>
rollback</H3>
<PRE>
void <B>rollback</B>(<A HREF="../../../java/sql/Savepoint.html" title="java.sql 안의 인터페이스">Savepoint</A> &nbsp;s)
              throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>CachedRowSet</code> 객체의 <code>SyncProvider</code> 에는, 원의 <code>ResultSet</code> 의 <code>Connection</code> 객체인가, 거기에 건네받는 JDBC 프로퍼티이 포함됩니다.  &nbsp;<p>
현재의 트랜잭션(transaction)에서의 모든 변경을 취소해, 마지막 <code>Savepoint</code>트랜잭션(transaction) 마커에 되돌립니다. 이 메소드는 자동 위탁 모드가 무효가 되어 있을 때 밖에 사용할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - <code>Savepoint</code>트랜잭션(transaction) 마커
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 데이타베이스 액세스 에러가 발생했을 경우,
 또는 이 <code>CachedRowSet</code> 내의 Connection 객체가 자동 위탁 모드인 경우</DL>
</DD>
</DL>
<HR>

<A NAME="rowSetPopulated(javax.sql.RowSetEvent, int)"><!-- --></A> <H3>
rowSetPopulated</H3>
<PRE>
void <B>rowSetPopulated</B>(<A HREF="../../../javax/sql/RowSetEvent.html" title="javax.sql 안의 클래스">RowSetEvent</A> &nbsp;event,
                     int&nbsp;numRows)
                     throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>등록이 끝난 청취자에게, 지정된 RowSetEvent 객체내의 RowSet 객체가 다수의 추가행을 읽어들인 것을 통지합니다. numRows</code>파라미터에 의해, 이 이벤트는,<code>numRow</code>마다 트리거됩니다.  &nbsp;<p>
이벤트의 소스는 event.getSource 메소드로 취득할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>event</CODE> - 이벤트의 소스인 <code>RowSet</code> 객체를 
     포함하는 <code>RowSetEvent</code> 객체<DD><CODE>numRows</CODE> - read시의 행의 간격수.
     여기서, 읽힌 <code>CachedRowSet</code> 가 트리거된다. 디폴트 값는 제로.
     <code>fetchSize</code> 보다 작은 값과 제로보다 작은 값은 지정할 수 없다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE></DL>
</DD>
</DL>
<HR>

<A NAME="populate(java.sql.ResultSet, int)"><!-- --></A> <H3>
populate</H3>
<PRE>
void <B>populate</B>(<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A> &nbsp;rs,
              int&nbsp;startRow)
              throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code> 객체로 지정된 <code>ResultSet</code>객체의 데이터를 읽어들입니다. <code>populate(ResultSet)</code>메소드에 관련지을 수 있고 있는 경우, 추가 파라미터에 의해, CashedRowSet 인스턴스의 read를 개시하는 <code>ResultSet</code>내의 개시 위치를 지정할 수가 있습니다.  &nbsp;<P>
이 메소드는, 어플리케이션이 오픈하고 있는 <code>ResultSet</code> 객체에 접속하고 있을 때 <code>execute</code> 메소드의 대체로서 사용할 수 있습니다. 새로운 접속을 열어 이 <code>CachedRowSet</code>객체의 커멘드를 재실행할 필요가 없는 점으로써,<code>populate</code> 메소드는, 파라미터를 취하지 않는 <code>execute</code>메소드보다 효율적입니다. 또,<code>populate</code> 메소드를 사용하는 것은,<code>ResultSet</code>객체를 취하는 <code>execute</code> 메소드보다 편리합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>startRow</CODE> - 이 <code>CachedRowSet</code> 에의 레코드의 read를 개시하는,
                <code>ResultSet</code> 내의 위치<DD><CODE>rs</CODE> - 이 <code>CachedRowSet</code> 객체에 읽힌다
                데이터를 포함한 <code>ResultSet</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - null 의 <code>ResultSet</code> 객체가 제공되었을 경우,
                또는 이 <code>CachedRowSet</code> 객체가
                관련하는 <code>ResultSetMetaData</code> 객체를 취득할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#execute(java.sql.Connection)"><CODE>execute(java.sql.Connection)</CODE></A> , 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#populate(java.sql.ResultSet)"><CODE>populate(ResultSet)</CODE></A> , 
<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스"><CODE>ResultSet</CODE></A> , 
<A HREF="../../../java/sql/ResultSetMetaData.html" title="java.sql 안의 인터페이스"><CODE>ResultSetMetaData</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPageSize(int)"><!-- --></A> <H3>
setPageSize</H3>
<PRE>
void <B>setPageSize</B>(int&nbsp;size)
                 throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>CachedRowSet</code> 객체의 페이지 사이즈를 설정합니다. CachedRowSet</code>는, 자신을 페이지 사이즈로 설정된 행수의 행에 읽어들이는 설정으로 할 수 있습니다. <code>populate()</code>또는 <code>execute()</code>가 불려 가면(자),<code>CachedRowSet</code>는, RowSet 의 read 사용한 원의 SQL 쿼리에 따라, 추가 페이지를 페치 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>size</CODE> - <code>CachedRowSet</code>의 페이지 사이즈
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - <code>CachedRowSet</code> 페이지 사이즈의 설정시에 에러가 발생했을 경우, 
      또는 페이지 사이즈가 제로보다 작은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getPageSize()"><!-- --></A> <H3>
getPageSize</H3>
<PRE>
int <B>getPageSize</B>()</PRE>
<DL>
<DD><code>CachedRowSet</code> 객체의 페이지 사이즈를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>페이지 사이즈를 나타내는 <code>int</code></DL>
</DD>
</DL>
<HR>

<A NAME="nextPage()"><!-- --></A> <H3>
nextPage</H3>
<PRE>
boolean <B>nextPage</B>()
                 throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>CachedRowSet</code> 의 현재의 페이지를 증분 합니다. 이것에 의해,<code>CachedRowSet</code>구현은, 다음의 페이지 사이즈 분의행을 페치 해, RowSet 에 읽어들입니다.  다만, 이 때문에는, 그 외의 행이 RowSet의 read에 사용된 원의 SQL 쿼리의 스코프내에 남아 있지 않으면 안됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아직 페이지가 있는 경우는 true, 이것이 마지막 페이지인 경우는 false
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 다음의 페이지의 페치시에 에러가 발생했을 경우,
     또는 이 메소드가 populate 나 execute 의 실행전에 너무 빨리 불려 갔을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="previousPage()"><!-- --></A> <H3>
previousPage</H3>
<PRE>
boolean <B>previousPage</B>()
                     throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>CachedRowSet</code> 의 현재의 페이지를 감 분 합니다. 이것에 의해,<code>CachedRowSet</code>구현은, 이전의 페이지 사이즈 분의행을 페치 해, RowSet 에 읽어들입니다. 이전의 페이지내가 반환된 행의 양은, RowSet의 read에 사용된 원의 SQL 쿼리의 스코프내에 남아 있을 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>전의 페이지가 정상적으로 취득되었을 경우는 true,
     이것이 최초의 페이지인 경우는 false
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 이전의 페이지의 페치시에 에러가 발생했을 경우,
     또는 이 메소드가 populate 나 execute 의 실행전에 너무 빨리 불려 갔을 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/CachedRowSet.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/sql/rowset/BaseRowSet.html" title="javax.sql.rowset 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/sql/rowset/FilteredRowSet.html" title="javax.sql.rowset 내의 인터페이스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/sql/rowset/CachedRowSet.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="CachedRowSet.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자 &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
