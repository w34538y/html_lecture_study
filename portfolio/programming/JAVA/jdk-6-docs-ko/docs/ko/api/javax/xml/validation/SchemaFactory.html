<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:44:56 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
SchemaFactory (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="SchemaFactory (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SchemaFactory.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/xml/validation/SchemaFactoryLoader.html" title="javax.xml.validation 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/xml/validation/SchemaFactory.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="SchemaFactory.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.xml.validation</FONT>
<BR>
클래스 SchemaFactory</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.xml.validation.SchemaFactory</B>
</PRE>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public abstract class <B>SchemaFactory</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 안의 클래스"><CODE>Schema</CODE></A>  객체를 작성하기 위한 팩토리입니다. API 검증의 엔트리 포인트입니다.

 <p>
<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  는 schema 컴파일러입니다. schema의 외부 표현을 읽어내, 그것들을 검증을 위해서(때문에) 준비합니다.
 
 <p>
<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  클래스는 thread에 대해서 안전하지는 않습니다. 즉, 어플리케이션측에서, 어떠한 경우도 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  객체를 사용하는 thread가 1 개 뿐이도록(듯이) 할 필요가 있습니다. 구현에서는, 메소드에 <code>synchronized</code> 의 마크를 붙여, 장해가 있는 클라이언트로부터 보호하는 것을 추천합니다.
 
 <p>
<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  는 재입 불가능합니다. <code>newSchema</code> 메소드의 1 개가 불려 가고 있을 때, 어플리케이션은, 같은 thread로부터에서 만나도,<code>newSchema</code> 메소드를 재귀적으로 호출할 수 없습니다.
 
<h2><a name="schemaLanguage"></a> schema 언어</h2>
 <p>
이 스펙은 이름 공간 URI 를 사용해, schema 언어를 지정합니다. 다음의 겉(표)에, 이 스펙에 의해 정의된 값을 나타냅니다.  &nbsp;<p>
스펙에 준거하기 위해서, 구현으로 지원할 필요가 있는 것은 W3C XML Schema 1.0 뿐입니다. 다만, 여기에 나타낸 그 외의 schema 언어를 지원하는 경우는, 이 스펙에 설명하는 관련의 동작에 따를 필요가 있습니다.
 
 <p>
여기에 나타내지 않은 schema 언어에서는, 독자적인 URI 를 도입해, 그것들을 나타내는 것이 기대됩니다. <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  클래스는 실행시에, 다른 schema 언어외의 구현을 찾아낼 수가 있습니다.
 
 <p>
XML DTD 는, 구문 분석 프로세스에 강하게 연결시킬 수 있고 있어 구문 분석 프로세스에 큰 영향을 주기 (위해)때문에, DTD 검증을 구문 분석으로부터 독립한 프로세스로서 정의할 수 없습니다. 이 때문에, 이 스펙에서는, XML DTD 의 시멘틱스를 정의하지 않습니다. 이것은, 적절이라고 생각되는 방법에서의 구현을 금지하는 것이 아닙니다만, 이 인터페이스에 구현된 DTD 검증을, 반드시 XML 1.0 으로 정의되는 XML DTD 시멘틱스로부터 갈라 놓도록 해 주세요.
 
 <table border="1" cellpadding="2">
   <thead>
     <tr>
<th>value</th>
<th>language</th>
     </tr>
   </thead>
   <tbody>
     <tr>
<td><A HREF="../../../javax/xml/XMLConstants.html#W3C_XML_SCHEMA_NS_URI"><CODE>XMLConstants.W3C_XML_SCHEMA_NS_URI</CODE></A>  ("<code>http://www.w3.org/2001/XMLSchema</code>")</td>
<td><a href="http://www.w3.org/TR/xmlschema-1">W3C XML Schema 1.0</a> </td>
     </tr>
     <tr>
<td><A HREF="../../../javax/xml/XMLConstants.html#RELAXNG_NS_URI"><CODE>XMLConstants.RELAXNG_NS_URI</CODE></A>  ("<code>http://relaxng.org/ns/structure/1. 0</code>")</td>
<td><a href="http://www.relaxng.org/">RELAX NG 1.0</a> </td>
     </tr>
   </tbody>
 </table>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#SchemaFactory()">SchemaFactory</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;상속 클래스의 생성자 입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 내의 인터페이스">ErrorHandler</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#getErrorHandler()">getErrorHandler</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  로 설정된 현재 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 중의 인터페이스"><CODE>ErrorHandler</CODE></A>  를 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#getFeature(java.lang.String)">getFeature</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기능 플래그의 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#getProperty(java.lang.String)">getProperty</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;프로퍼티치를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 내의 인터페이스">LSResourceResolver</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#getResourceResolver()">getResourceResolver</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  로 설정된 현재 <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 중의 인터페이스"><CODE>LSResourceResolver</CODE></A>  를 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#isSchemaLanguageSupported(java.lang.String)">isSchemaLanguageSupported</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;schemaLanguage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 schema가 이 <code>SchemaFactory</code> 에 지원되고 있을까를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 내의 클래스">SchemaFactory</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newInstance(java.lang.String)">newInstance</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;schemaLanguage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 schema 언어를 지원하는 <code>SchemaFactory</code> 의 구현을 검색해, 그것을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 내의 클래스">SchemaFactory</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newInstance(java.lang.String, java.lang.String, java.lang.ClassLoader)">newInstance</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;schemaLanguage,
            <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;factoryClassName,
            <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;classLoader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클래스명으로부터 <code>SchemaFactory</code> 의 새로운 인스턴스를 가져옵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 내의 클래스">Schema</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema()">newSchema</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;특수한 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 안의 클래스"><CODE>Schema</CODE></A>  객체를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 내의 클래스">Schema</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(java.io.File)">newSchema</A> </B>(<A HREF="../../../java/io/File.html" title="java.io 안의 클래스">File</A> &nbsp;schema)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>File</code> 를 schema로서 구문 분석 해, 그것을 <code>Schema</code> 로서 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 내의 클래스">Schema</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(javax.xml.transform.Source)">newSchema</A> </B>(<A HREF="../../../javax/xml/transform/Source.html" title="javax.xml.transform 안의 인터페이스">Source</A> &nbsp;schema)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 소스를 schema로서 구문 분석 해, 그것을 schema로서 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 내의 클래스">Schema</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(javax.xml.transform.Source[])">newSchema</A> </B>(<A HREF="../../../javax/xml/transform/Source.html" title="javax.xml.transform 안의 인터페이스">Source</A> []&nbsp;schemas)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 소스를 schema로서 구문 분석 해, 그것을 schema로서 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 내의 클래스">Schema</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(java.net.URL)">newSchema</A> </B>(<A HREF="../../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;schema)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>URL</code> 를 schema로서 구문 분석 해, 그것을 <code>Schema</code> 로서 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#setErrorHandler(org.xml.sax.ErrorHandler)">setErrorHandler</A> </B>(<A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 안의 인터페이스">ErrorHandler</A> &nbsp;errorHandler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>newSchema</code> 메소드의 호출로 발생한 에러를 받도록(듯이) <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 동안의 인터페이스"><CODE>ErrorHandler</CODE></A>  를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#setFeature(java.lang.String, boolean)">setFeature</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
           boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>SchemaFactory</code>, 이 팩토리에 의해 작성된 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 동안의 클래스"><CODE>Schema</CODE></A> , 한층 더 그러한 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 안의 클래스"><CODE>Schema</CODE></A>  에 의해 작성된 <A HREF="../../../javax/xml/validation/Validator.html" title="javax.xml.validation 동안의 클래스"><CODE>Validator</CODE></A>  및 <A HREF="../../../javax/xml/validation/ValidatorHandler.html" title="javax.xml.validation 안의 클래스"><CODE>ValidatorHandler</CODE></A>  의 기능을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#setProperty(java.lang.String, java.lang.Object)">setProperty</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
            <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;프로퍼티치를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/xml/validation/SchemaFactory.html#setResourceResolver(org.w3c.dom.ls.LSResourceResolver)">setResourceResolver</A> </B>(<A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 안의 인터페이스">LSResourceResolver</A> &nbsp;resourceResolver)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;schema의 구문 분석시에 자원 해결을 커스터마이즈 하도록(듯이) <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 동안의 인터페이스"><CODE>LSResourceResolver</CODE></A>  를 설정합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../../java/lang/Object.html#toString()">toString</A> , <A HREF="../../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SchemaFactory()"><!-- --></A> <H3>
SchemaFactory</H3>
<PRE>
protected <B>SchemaFactory</B>()</PRE>
<DL>
<DD><p>상속 클래스의 생성자 입니다. </p>
 
　<p>이 생성자 은 아무것도 실시하지 않습니다. </p>
 
　<p>상속 클래스에서는 <code>null</code> <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 내의 인터페이스"><CODE>ErrorHandler</CODE></A>  및 <code>null</code> <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 내의 인터페이스"><CODE>LSResourceResolver</CODE></A>  <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 중의 클래스"><CODE>SchemaFactory</CODE></A>  객체를 작성할 필요가 있습니다. </p>
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="newInstance(java.lang.String)"><!-- --></A> <H3>
newInstance</H3>
<PRE>
public static final <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 내의 클래스">SchemaFactory</A>  <B>newInstance</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;schemaLanguage)</PRE>
<DL>
<DD><p>지정된 schema 언어를 지원하는 <code>SchemaFactory</code> 의 구현을 검색해, 그것을 돌려줍니다. </p>
 
　<p>지정된 schema 언어의 <code>SchemaFactory</code> 객체를 검색하는 경우, 이 메소드는 「클래스 로더」가 문맥 클래스 로더를 참조하는 이하의 차례로, 다음의 장소를 조사합니다. </p>
 <ol>
  <li>
시스템 프로퍼티<code>「javax.xml.validation.SchemaFactory:<i>schemaLanguage</i>」</code>가 존재하는 (<i>schemaLanguage</i> 는 이 메소드의 파라미터) 경우, 그 값은 클래스명으로서 읽어내집니다. 이 메소드는, 클래스 로더를 사용해 이 클래스의 새로운 인스턴스를 작성을 시도해 성공했을 경우는 그것을 돌려줍니다.
   </li>
   <li>
<code>$java.home/lib/jaxp.properties</code> 가 읽어내져 상기의 시스템 프로퍼티인 키에 관련지을 수 있었던 값이 검색됩니다. 값이 존재하면, 상기와 같이 값이 처리됩니다.
   </li>
   <li>
　<p>클래스 로더는, 자원 디렉토리 META-INF/services 내의 <code>javax.xml.validation.SchemaFactory</code> 에 일치하는 서비스 프로바이더의 프로바이더 구성 파일이 요구됩니다. 파일 형식과 구문 분석 규칙에 대해서는, JAR 파일의 스펙을 참조해 주세요. 각 서비스 프로바이더는, 다음의 메소드를 구현하고 있을 필요가 있습니다. </p>
     <pre>
        <A HREF="../../../javax/xml/validation/SchemaFactory.html#isSchemaLanguageSupported(java.lang.String)"><CODE>isSchemaLanguageSupported(String schemaLanguage)</CODE></A> 
     </pre> 
지정된 schema 언어를 지원하는 클래스 로더내에서 최초로 검출된 서비스 프로바이더가 돌려주어집니다.
   </li>
   <li>
플랫폼의 디폴트 <code>SchemaFactory</code> 는, 구현 고유의 방법으로 배치됩니다. W3C XML Schema 용의 플랫폼의 디폴트 <code>SchemaFactory</code> 가 있을 필요가 있습니다.
   </li>
 </ol>
 
　<p>모든 것이 실패했을 경우,<A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스"><CODE>IllegalArgumentException</CODE></A>  가 throw 됩니다. </p>
 
　<p><strong>트러블 슈팅의 힌트</strong></p>
　<p>프로퍼티 파일이 어떻게 구문 분석 될까에 대해서는,<A HREF="../../../java/util/Properties.html#load(java.io.InputStream)"><CODE>Properties.load(java.io.InputStream)</CODE></A>  를 참조해 주세요. 특히, 구두점 「:」은, 프로퍼티 파일내에서 이스케이프 될 필요가 있기 (위해)때문에, schema 언어 URI 가 적절히 이스케이프 되고 있는 것을 확인해 주세요. 다음에 예를 나타냅니다. </p>
 <pre>
 http\://www.w3.org/2001/XMLSchema=org.acme.foo.XSSchemaFactory
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>schemaLanguage</CODE> - 반환되는 SchemaFactory 가 이해한다
      schema 언어를 지정한다. 지정할 수 있는 값에 대해서는
      <a href="#schemaLanguage">사용 가능한
      schema 언어의 리스트</a>를 참조
<DT><B>반환값:</B><DD><code>SchemaFactory</code> 의 새로운 인스턴스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 사용 가능한 schema 언어의 구현이 없는 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>schemaLanguage</code> 파라미터가 null 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#newInstance(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>newInstance(String schemaLanguage, String factoryClassName, ClassLoader classLoader)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="newInstance(java.lang.String, java.lang.String, java.lang.ClassLoader)"><!-- --></A> <H3>
newInstance</H3>
<PRE>
public static <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 내의 클래스">SchemaFactory</A>  <B>newInstance</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;schemaLanguage,
                                        <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;factoryClassName,
                                        <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;classLoader)</PRE>
<DL>
<DD><p>클래스명으로부터 <code>SchemaFactory</code> 의 새로운 인스턴스를 가져옵니다. 지정된 팩토리 클래스명이 지정된 schema 언어를 지원하는 경우,<code>SchemaFactory</code> 가 돌려주어집니다. 이 기능은, classpath 에 복수의 프로바이더가 존재하는 경우에 편리합니다. 로드하는 프로바이더를 지정할 수 있으므로, 어플리케이션으로 상세하게 제어할 수 있게 됩니다. </p>
     
<h2>트러블 슈팅의 힌트</h2>
　<p><code>jaxp.debug</code> 시스템 프로퍼티을 설정하면(자), 이 메소드는 실행중의 처리나 검색하고 있는 장소에 관한 대량의 디버그 메세지를 <code>System.err</code> 에 출력합니다. </p>
 
　<p> 문제가 있는 경우는 다음의 커멘드를 시험해 주세요. </p>
 <pre>
 java -Djaxp.debug=1 YourProgram ....
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>schemaLanguage</CODE> - 반환되는 <code>SchemaFactory</code> 가 이해한다
                          schema 언어를 지정한다. 지정할 수 있는 값에 대해서는
                          <a href="#schemaLanguage">사용 가능한
                          schema 언어의 리스트</a>를 참조<DD><CODE>factoryClassName</CODE> - <code>javax.xml.validation.SchemaFactory</code> 의 구현을 제공하는 완전 수식의 팩토리 클래스명<DD><CODE>classLoader</CODE> - 팩토리 클래스의 로드에 사용하는 <code>ClassLoader</code>. <code>null</code> 의 경우,  
                     팩토리 클래스의 로드에는 현재의 <code>Thread</code> 의 문맥 classLoader 가 사용된다
<DT><B>반환값:</B><DD><code>SchemaFactory</code> 의 새로운 인스턴스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>factoryClassName</code> 가 <code>null</code> 의 경우. 또는,
                   팩토리 클래스를 로드 및 인스턴스화할 수 없는 경우. 또는,
                   팩토리 클래스가 <code>schemLanguage</code> 파라미터로 지정된 schema 언어를
                   지원하지 않는 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>schemaLanguage</code> 파라미터가 null 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#newInstance(java.lang.String)"><CODE>newInstance(String schemaLanguage)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isSchemaLanguageSupported(java.lang.String)"><!-- --></A> <H3>
isSchemaLanguageSupported</H3>
<PRE>
public abstract boolean <B>isSchemaLanguageSupported</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;schemaLanguage)</PRE>
<DL>
<DD><p>지정된 schema가 이 <code>SchemaFactory</code> 에 지원되고 있을까를 돌려줍니다. </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>schemaLanguage</CODE> - 반환되는 <code>SchemaFactory</code> 가 이해하는 schema 언어를 지정한다.
    <code>schemaLanguage</code> 는 <a href="#schemaLanguage">유효한 </a>schema 언어를 지정할 필요가 있다
<DT><B>반환값:</B><DD><code>SchemaFactory</code> 가 <code>schemaLanguage</code> 를 지원하고 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>schemaLanguage</code> 가 <code>null</code> 의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>schemaLanguage.length() == 0</code> 
   또는 <code>schemaLanguage</code> 가<a href="#schemaLanguage">유효한 </a>schema 언어를 지정하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getFeature(java.lang.String)"><!-- --></A> <H3>
getFeature</H3>
<PRE>
public boolean <B>getFeature</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                   throws <A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 내의 클래스">SAXNotRecognizedException</A> ,
                          <A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 안의 클래스">SAXNotSupportedException</A> </PRE>
<DL>
<DD>기능 플래그의 값을 검색합니다.

　<p>기능명은 완전 수식 URI 입니다. 기능명은 완전 수식 URI 입니다.  <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  는 기능명을 인식할 수 있습니다만, 일시적으로 그 값을 돌려줄 수 없습니다.

　<p>독자적인 URI 에 근거해 작성된 이름을 사용해, 구현자가 독자적인 기능을 작성할 수도 있습니다 (추천). </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 기능명.  null 이외의 완전 수식 URI 로 나타내진다
<DT><B>반환값:</B><DD>기능의 현재의 값 (true 또는 false)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 안의 클래스">SAXNotRecognizedException</A> </CODE> - 기능치를 할당할 수 없는,
   또는 취득할 수 없는 경우
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 안의 클래스">SAXNotSupportedException</A> </CODE> - <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 내의 클래스"><CODE>SchemaFactory</CODE></A>  가
   기능명을 인식하는 것만으로,
   현시점에서는 그 값을 판단할 수  없는 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>name</code> 가 <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#setFeature(java.lang.String, boolean)"><CODE>setFeature(String, boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setFeature(java.lang.String, boolean)"><!-- --></A> <H3>
setFeature</H3>
<PRE>
public void <B>setFeature</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
                       boolean&nbsp;value)
                throws <A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 내의 클래스">SAXNotRecognizedException</A> ,
                       <A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 안의 클래스">SAXNotSupportedException</A> </PRE>
<DL>
<DD><p>이 <code>SchemaFactory</code>, 이 팩토리에 의해 작성된 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 동안의 클래스"><CODE>Schema</CODE></A> , 한층 더 그러한 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 안의 클래스"><CODE>Schema</CODE></A>  에 의해 작성된 <A HREF="../../../javax/xml/validation/Validator.html" title="javax.xml.validation 동안의 클래스"><CODE>Validator</CODE></A>  및 <A HREF="../../../javax/xml/validation/ValidatorHandler.html" title="javax.xml.validation 안의 클래스"><CODE>ValidatorHandler</CODE></A>  의 기능을 설정합니다.
 </p>

　<p>구현시 및 개발시에는,<A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema()"><CODE>newSchema()</CODE></A>  에 의해 반환되는 특별한 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 안의 클래스"><CODE>Schema</CODE></A>  객체의 처리 방법으로 특별히 주의하도록(듯이) 합니다. 예를 들어, 경우에 따라서는,<code>SchemaFactory</code> 와 클래스가, 다른 구현으로부터의 schema를 실제로 로드할 때,<code>SchemaFactory</code> 의 기능을 자동적으로 상속할 수 없는 것이 있습니다. 개발시에는, 시큐리티 처리등의 기능을 양쪽 모두의 장소에서 명시적으로 설정하도록 해 주세요. </p>

　<p>기능명은 완전 수식 URI 입니다. 기능명은 완전 수식 URI 입니다.  <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  는 기능의 값을 표시할 수 있습니다만, 현재의 값을 변경할 수 없습니다. </p>

　<p>구현은 모두,<A HREF="../../../javax/xml/XMLConstants.html#FEATURE_SECURE_PROCESSING"><CODE>XMLConstants.FEATURE_SECURE_PROCESSING</CODE></A>  기능을 지원하고 있을 필요가 있습니다. 이 기능에 대해서는 다음과 같습니다. </p>
 <ul>
   <li>
<code>true</code> 의 경우, 구현은 구현 한계에 준거하는 XML 처리를 제한합니다. 예로서는, 엔티티 확장 제한이나 대용량의 자원을 소비하는 XML schema등이 있습니다. 시큐리티상의 이유로부터 XML 처리가 제한되는 경우는, 등록을 마친 <A HREF="../../../org/xml/sax/ErrorHandler.html#fatalError(org.xml.sax.SAXParseException)"><CODE>ErrorHandler.fatalError(SAXParseException exception)</CODE></A>  에 호출을 개입시켜 보고됩니다. <A HREF="../../../javax/xml/validation/SchemaFactory.html#setErrorHandler(org.xml.sax.ErrorHandler)"><CODE>setErrorHandler(ErrorHandler errorHandler)</CODE></A>  를 참조해 주세요.
   </li>
   <li>
<code>false</code> 의 경우, 구현은, 구현 한계를 고려하지 않고 , XML 스펙에 따라 XML 를 처리합니다.
   </li>
 </ul>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 기능명.  null 이외의 완전 수식 URI 로 나타내지는<DD><CODE>value</CODE> - 기능의 요구된 값 (true 또는 false)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 안의 클래스">SAXNotRecognizedException</A> </CODE> - 기능치를 할당할 수 없는,
   또는 취득할 수 없는 경우
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 안의 클래스">SAXNotSupportedException</A> </CODE> - <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 내의 클래스"><CODE>SchemaFactory</CODE></A>  가
   기능명을 인식하는 것만으로,
   요구된 값을 설정할 수 없는 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>name</code> 가 <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#getFeature(java.lang.String)"><CODE>getFeature(String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setProperty(java.lang.String, java.lang.Object)"><!-- --></A> <H3>
setProperty</H3>
<PRE>
public void <B>setProperty</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
                        <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;object)
                 throws <A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 내의 클래스">SAXNotRecognizedException</A> ,
                        <A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 안의 클래스">SAXNotSupportedException</A> </PRE>
<DL>
<DD>프로퍼티치를 설정합니다.

　<p>프로퍼티명은 완전 수식 URI 입니다. <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  는 프로퍼티명을 인식할 수 있습니다만, 현재의 값을 변경할 수 없습니다. </p>

　<p><A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  는 특정의 프로퍼티명의 설정을 인식할 필요는 없습니다. </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 프로퍼티명.  null 이외의 완전 수식 URI 로 나타내지는<DD><CODE>object</CODE> - 요구된 프로퍼티치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 안의 클래스">SAXNotRecognizedException</A> </CODE> - 프로퍼티의 값을 할당할 수 없는,
   또는 취득할 수 없는 경우
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 안의 클래스">SAXNotSupportedException</A> </CODE> - <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 내의 클래스"><CODE>SchemaFactory</CODE></A>  가
   프로퍼티명을 인식하는 것만으로,
   요구된 값을 설정할 수 없는 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>name</code> 가 <code>null</code> 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getProperty(java.lang.String)"><!-- --></A> <H3>
getProperty</H3>
<PRE>
public <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getProperty</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                   throws <A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 내의 클래스">SAXNotRecognizedException</A> ,
                          <A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 안의 클래스">SAXNotSupportedException</A> </PRE>
<DL>
<DD>프로퍼티치를 검색합니다.

　<p>프로퍼티명은 완전 수식 URI 입니다. <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  는 프로퍼티명을 인식할 수 있습니다만, 일시적으로 그 값을 돌려줄 수 없습니다. </p>

　<p><A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  는 특정의 프로퍼티명을 인식할 필요는 없습니다. </p>

　<p>독자적인 URI 에 근거해 작성된 이름을 사용해, 구현자가 독자적인 프로퍼티을 작성할 수도 있습니다 (추천). </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 프로퍼티명.  null 이외의 완전 수식 URI 로 나타내진다
<DT><B>반환값:</B><DD>현재의 프로퍼티치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotRecognizedException.html" title="org.xml.sax 안의 클래스">SAXNotRecognizedException</A> </CODE> - 프로퍼티의 값을 할당할 수 없는,
   또는 취득할 수 없는 경우
<DD><CODE><A HREF="../../../org/xml/sax/SAXNotSupportedException.html" title="org.xml.sax 안의 클래스">SAXNotSupportedException</A> </CODE> - XMLReader 가
   프로퍼티명을 인식하는 것만으로,
   현시점에서는 그 값을 판단할 수  없는 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>name</code> 가 <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#setProperty(java.lang.String, java.lang.Object)"><CODE>setProperty(String, Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setErrorHandler(org.xml.sax.ErrorHandler)"><!-- --></A> <H3>
setErrorHandler</H3>
<PRE>
public abstract void <B>setErrorHandler</B>(<A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 안의 인터페이스">ErrorHandler</A> &nbsp;errorHandler)</PRE>
<DL>
<DD><code>newSchema</code> 메소드의 호출로 발생한 에러를 받도록(듯이) <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 동안의 인터페이스"><CODE>ErrorHandler</CODE></A>  를 설정합니다.
 
 <p>
에러 핸들러를 사용해, schema 구문 분석시의 에러 처리를 커스터마이즈 할 수 있습니다. <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 안의 인터페이스"><CODE>ErrorHandler</CODE></A>  를 설정하면(자), schema의 구문 분석으로 발견된 에러는 우선 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 안의 인터페이스"><CODE>ErrorHandler</CODE></A>  에 보내집니다.
 
 <p>
에러 핸들러는 핸들러로부터 <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 안의 클래스"><CODE>SAXException</CODE></A>  를 throw 해, schema의 구문 분석을 즉시 중단할 수가 있습니다. 또는, 에러를 화면에 출력하거나<A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 동안의 인터페이스"><CODE>ErrorHandler</CODE></A>  로부터 정상적으로 돌아와 처리를 속행시키거나 할 수도 있습니다.  
 
 <p>
<A HREF="../../../java/lang/Throwable.html" title="java.lang 안의 클래스"><CODE>Throwable</CODE></A>  (또는 그 상속 클래스의 인스턴스)가 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 안의 인터페이스"><CODE>ErrorHandler</CODE></A>  로부터 throw 되면(자),<code>newSchema</code> 메소드의 호출 바탕으로는 같은 <A HREF="../../../java/lang/Throwable.html" title="java.lang 안의 클래스"><CODE>Throwable</CODE></A>  객체가 throw 됩니다.
 
 <p>
<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  는, 최초로 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 안의 인터페이스"><CODE>ErrorHandler</CODE></A>  에 보고하지 않으면,<A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 안의 클래스"><CODE>SAXException</CODE></A>  를 throw 할 수가 없습니다.
 
 <p>
어플리케이션에서는 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 안의 클래스"><CODE>Schema</CODE></A>  의 구문 분석 그 중에서 이 메소드를 호출할 수가 있습니다.  
 
 <p>
<A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 안의 인터페이스"><CODE>ErrorHandler</CODE></A>  가 null 의 경우, 구현은 다음 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 중의 인터페이스"><CODE>ErrorHandler</CODE></A>  가 설정되었는지와 같이 동작합니다.
 <pre>
 class DraconianErrorHandler implements <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 내의 인터페이스"><CODE>ErrorHandler</CODE></A>  {
     public void fatalError( <A HREF="../../../org/xml/sax/SAXParseException.html" title="org.xml.sax 안의 클래스"><CODE>SAXParseException</CODE></A>  e ) throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 내의 클래스"><CODE>SAXException</CODE></A>  {
         throw e;
     }
     public void error( <A HREF="../../../org/xml/sax/SAXParseException.html" title="org.xml.sax 안의 클래스"><CODE>SAXParseException</CODE></A>  e ) throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 내의 클래스"><CODE>SAXException</CODE></A>  {
         throw e;
     }
     public void warning( <A HREF="../../../org/xml/sax/SAXParseException.html" title="org.xml.sax 안의 클래스"><CODE>SAXParseException</CODE></A>  e ) throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 내의 클래스"><CODE>SAXException</CODE></A>  {
         // noop
     }
 }
 </pre>
 
 <p>
새로운 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 동안의 클래스"><CODE>SchemaFactory</CODE></A>  객체가 작성되면(자), 최초로 이 필드는 null 로 설정됩니다. 이 필드는, 이 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  로부터 작성된 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 동안의 클래스"><CODE>Schema</CODE></A> ,<A HREF="../../../javax/xml/validation/Validator.html" title="javax.xml.validation 안의 클래스"><CODE>Validator</CODE></A> , 또는 <A HREF="../../../javax/xml/validation/ValidatorHandler.html" title="javax.xml.validation 안의 클래스"><CODE>ValidatorHandler</CODE></A>  에 상속되지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>errorHandler</CODE> - 설정하는 새로운 에러 핸들러.
   이 파라미터는 <code>null</code> 도 가능</DL>
</DD>
</DL>
<HR>

<A NAME="getErrorHandler()"><!-- --></A> <H3>
getErrorHandler</H3>
<PRE>
public abstract <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 내의 인터페이스">ErrorHandler</A>  <B>getErrorHandler</B>()</PRE>
<DL>
<DD>이 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  로 설정된 현재 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 중의 인터페이스"><CODE>ErrorHandler</CODE></A>  를 가져옵니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 메소드는,<A HREF="../../../javax/xml/validation/SchemaFactory.html#setErrorHandler(org.xml.sax.ErrorHandler)"><CODE>setErrorHandler(ErrorHandler)</CODE></A>  메소드에 의해
      마지막에 설정된 객체를 돌려준다. 또는,
      이 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  가 작성되고 나서,
      그 메소드가 불려 가지 않은 경우는 null 를 돌려주는<DT><B>관련 항목:</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#setErrorHandler(org.xml.sax.ErrorHandler)"><CODE>setErrorHandler(ErrorHandler)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setResourceResolver(org.w3c.dom.ls.LSResourceResolver)"><!-- --></A> <H3>
setResourceResolver</H3>
<PRE>
public abstract void <B>setResourceResolver</B>(<A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 안의 인터페이스">LSResourceResolver</A> &nbsp;resourceResolver)</PRE>
<DL>
<DD>schema의 구문 분석시에 자원 해결을 커스터마이즈 하도록(듯이) <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 동안의 인터페이스"><CODE>LSResourceResolver</CODE></A>  를 설정합니다.
 
 <p>
<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  는, schema의 구문 분석중에 외부 자원의 장소를 확인할 필요가 있을 때 <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 동안의 인터페이스"><CODE>LSResourceResolver</CODE></A>  를 사용합니다만, 「외부 자원의 검색」을 엄밀하게 구성하는 것은 schema 언어에 의해 다릅니다. 예를 들어, W3C XML Schema 에서는,<code>&lt;include></code> 또는 <code>&lt;import></code> 된 파일, 및 schema 파일로부터 참조된 DTD 등이 포함됩니다.
 
 <p>
어플리케이션에서는 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 안의 클래스"><CODE>Schema</CODE></A>  의 구문 분석 그 중에서 이 메소드를 호출할 수가 있습니다.  
 
 <p>
<A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 안의 인터페이스"><CODE>LSResourceResolver</CODE></A>  가 null 의 경우, 구현은 다음 <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 중의 인터페이스"><CODE>LSResourceResolver</CODE></A>  가 설정되었는지와 같이 동작합니다.
 <pre>
 class DumbDOMResourceResolver implements <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 내의 인터페이스"><CODE>LSResourceResolver</CODE></A>  {
     public <A HREF="../../../org/w3c/dom/ls/LSInput.html" title="org.w3c.dom.ls 내의 인터페이스"><CODE>LSInput</CODE></A>  resolveResource(
         String publicId, String systemId, String baseURI) {
         
         return null; // always return null
     }
 }
 </pre>
 
 <p>
<A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 안의 인터페이스"><CODE>LSResourceResolver</CODE></A>  가 <A HREF="../../../java/lang/RuntimeException.html" title="java.lang 안의 클래스"><CODE>RuntimeException</CODE></A>  (또는 그 상속 클래스의 인스턴스)를 throw 하면(자),<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  는 구문 분석을 이상종료(ABEND) 해,<code>newSchema</code> 메소드의 호출원래는 같은 <A HREF="../../../java/lang/RuntimeException.html" title="java.lang 안의 클래스"><CODE>RuntimeException</CODE></A>  를 받습니다.  
 
 <p>
새로운 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 동안의 클래스"><CODE>SchemaFactory</CODE></A>  객체가 작성되면(자), 최초로 이 필드는 null 로 설정됩니다. 이 필드는, 이 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  로부터 작성된 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 동안의 클래스"><CODE>Schema</CODE></A> ,<A HREF="../../../javax/xml/validation/Validator.html" title="javax.xml.validation 안의 클래스"><CODE>Validator</CODE></A> , 또는 <A HREF="../../../javax/xml/validation/ValidatorHandler.html" title="javax.xml.validation 안의 클래스"><CODE>ValidatorHandler</CODE></A>  에 상속되지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>resourceResolver</CODE> - 설정하는 새로운 자원 리절버. 이 파라미터는 null 도 가능</DL>
</DD>
</DL>
<HR>

<A NAME="getResourceResolver()"><!-- --></A> <H3>
getResourceResolver</H3>
<PRE>
public abstract <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 내의 인터페이스">LSResourceResolver</A>  <B>getResourceResolver</B>()</PRE>
<DL>
<DD>이 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  로 설정된 현재 <A HREF="../../../org/w3c/dom/ls/LSResourceResolver.html" title="org.w3c.dom.ls 중의 인터페이스"><CODE>LSResourceResolver</CODE></A>  를 가져옵니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 메소드는,<A HREF="../../../javax/xml/validation/SchemaFactory.html#setResourceResolver(org.w3c.dom.ls.LSResourceResolver)"><CODE>setResourceResolver(LSResourceResolver)</CODE></A>  메소드에 의해
      마지막에 설정된 객체를 돌려준다. 또는,
      이 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  가 작성되고 나서,
      그 메소드가 불려 가지 않은 경우는 null 를 돌려주는<DT><B>관련 항목:</B><DD><A HREF="../../../javax/xml/validation/SchemaFactory.html#setErrorHandler(org.xml.sax.ErrorHandler)"><CODE>setErrorHandler(ErrorHandler)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="newSchema(javax.xml.transform.Source)"><!-- --></A> <H3>
newSchema</H3>
<PRE>
public <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 내의 클래스">Schema</A>  <B>newSchema</B>(<A HREF="../../../javax/xml/transform/Source.html" title="javax.xml.transform 안의 인터페이스">Source</A> &nbsp;schema)
                 throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 내의 클래스">SAXException</A> </PRE>
<DL>
<DD><p>지정된 소스를 schema로서 구문 분석 해, 그것을 schema로서 돌려줍니다. </p>
 
　<p>이것은 <A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(javax.xml.transform.Source[])"><CODE>newSchema(Source[] schemas)</CODE></A>  의 편리한 메소드입니다. </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>schema</CODE> - schema를 나타내는 소스
<DT><B>반환값:</B><DD><code>schema</code> 의 구문 분석으로부터의 새로운 <code>Schema</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 안의 클래스">SAXException</A> </CODE> - 구문 분석시에 SAX 에러가 발생했을 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>schema</code> 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="newSchema(java.io.File)"><!-- --></A> <H3>
newSchema</H3>
<PRE>
public <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 내의 클래스">Schema</A>  <B>newSchema</B>(<A HREF="../../../java/io/File.html" title="java.io 안의 클래스">File</A> &nbsp;schema)
                 throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 내의 클래스">SAXException</A> </PRE>
<DL>
<DD><p>지정된 <code>File</code> 를 schema로서 구문 분석 해, 그것을 <code>Schema</code> 로서 돌려줍니다. </p>
 
　<p>이것은 <A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(javax.xml.transform.Source)"><CODE>newSchema(Source schema)</CODE></A>  의 편리한 메소드입니다. </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>schema</CODE> - schema를 나타내는 파일
<DT><B>반환값:</B><DD><code>schema</code> 의 구문 분석으로부터의 새로운 <code>Schema</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 안의 클래스">SAXException</A> </CODE> - 구문 분석시에 SAX 에러가 발생했을 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>schema</code> 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="newSchema(java.net.URL)"><!-- --></A> <H3>
newSchema</H3>
<PRE>
public <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 내의 클래스">Schema</A>  <B>newSchema</B>(<A HREF="../../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;schema)
                 throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 내의 클래스">SAXException</A> </PRE>
<DL>
<DD><p>지정된 <code>URL</code> 를 schema로서 구문 분석 해, 그것을 <code>Schema</code> 로서 돌려줍니다. </p>
 
　<p>이것은 <A HREF="../../../javax/xml/validation/SchemaFactory.html#newSchema(javax.xml.transform.Source)"><CODE>newSchema(Source schema)</CODE></A>  의 편리한 메소드입니다. </p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>schema</CODE> - schema를 나타내는 <code>URL</code>
<DT><B>반환값:</B><DD><code>schema</code> 의 구문 분석으로부터의 새로운 <code>Schema</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 안의 클래스">SAXException</A> </CODE> - 구문 분석시에 SAX 에러가 발생했을 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>schema</code> 가 null 의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="newSchema(javax.xml.transform.Source[])"><!-- --></A> <H3>
newSchema</H3>
<PRE>
public abstract <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 내의 클래스">Schema</A>  <B>newSchema</B>(<A HREF="../../../javax/xml/transform/Source.html" title="javax.xml.transform 안의 인터페이스">Source</A> []&nbsp;schemas)
                          throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 내의 클래스">SAXException</A> </PRE>
<DL>
<DD>지정된 소스를 schema로서 구문 분석 해, 그것을 schema로서 돌려줍니다.
 
 <p>
불려 가는 측은 모든 <A HREF="../../../javax/xml/transform/Source.html" title="javax.xml.transform 안의 인터페이스"><CODE>Source</CODE></A>  를 읽어내, 그것들을 1 개의 schema에 결합합니다. 이 편성의 정확한 시멘틱스는, 이 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  객체가 작성된 schema 언어에 따라서 다릅니다.
 
 <p>
<A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 안의 인터페이스"><CODE>ErrorHandler</CODE></A>  가 설정되어 있는 경우, 불려 가는 측은 소스에 발견된 모든 에러를 핸들러에 보고합니다. 핸들러는 예외를 throw 하면(자), schema의 컴파일을 중단합니다. 그리고 같은 예외가 이 메소드로부터 throw 됩니다. 또, 에러가 핸들러에 보고된 뒤, 불려 가는 측은 에러를 throw 하는 것에 의한 이후의 처리를 중단할 수가 있습니다. 에러 핸들러가 설정되어 있는 경우는, 불려 가는 측이 소스에 발견된 최초의 에러를 throw 합니다.    
 
<h2>W3C XML Schema 1.0</h2>
 <p>
결과적으로 얻을 수 있는 schema에는, 지정된 소스로부터의 컴퍼넌트가 포함됩니다. 이것들 모든 소스를, schemaLocation 과 이름 공간의 적절한 값을 사용해, 다른 targetNamespace 를 가지는 고유의 컴퍼넌트를 가지지 않는 1 개의 schema 문서에 임포트 했을 경우에서도, 임포트 요소가 소스로서 같은 순서가 되어 있으면 같은 결과를 얻을 수 있습니다. XML Schema 권고의 섹션 4.2. 3 에, 이것에 관한 프로세서의 옵션이 기재되어 있습니다. 프로세서는 JAXP schema 소스와 XML schema의 임포트를 일관해 취급할 필요가 있습니다만, JAXP 준거의 퍼서 사이의 동작은 달라도 괜찮습니다.  특히, schemaLocation 로 제공되는 정보에 관계없이, 퍼서는 지정된 이름 공간의 최초의 &lt;import &gt; 이외를 모두 무시할 수 있습니다.
 
 <p>
해석된 일련의 schema에, XML Schema 스펙의 섹션 5.1 에 나타내는 것 같은 에러가 포함되는 경우, 에러를 <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 안의 인터페이스"><CODE>ErrorHandler</CODE></A>  에 보고할 필요가 있습니다.
 
<h2>RELAX NG</h2>
 
　<p>RELAX NG 의 경우로 <code>schemas.length! =1</code> 때, 이 메소드는 <A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A>  를 throw 할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>schemas</CODE> - 해석되는 입력. <A HREF="../../../javax/xml/transform/sax/SAXSource.html" title="javax.xml.transform.sax 안의 클래스"><CODE>SAXSource</CODE></A> ,
      <A HREF="../../../javax/xml/transform/stream/StreamSource.html" title="javax.xml.transform.stream 안의 클래스"><CODE>StreamSource</CODE></A> ,
      <A HREF="../../../javax/xml/transform/stax/StAXSource.html" title="javax.xml.transform.stax 안의 클래스"><CODE>StAXSource</CODE></A> ,
      및 <A HREF="../../../javax/xml/transform/dom/DOMSource.html" title="javax.xml.transform.dom 안의 클래스"><CODE>DOMSource</CODE></A>  
      (을)를 인식하기 위해서 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  가 필요.
      입력 schema는 XML 문서 또는 
      XML 요소인 것이 필요해 null 는 불가. 하위 호환성을 위해서(때문에),
      문서와 요소 이외의 모든 것을 주고 받은 결과는
      구현에 의존하고 있다.
      구현은, 입력을 인식해 처리하는지,
      IllegalArgumentException 를 throw 할 필요가 있다
<DT><B>반환값:</B><DD>항상 null 이외의 유효한 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 안의 클래스"><CODE>Schema</CODE></A>  객체를 돌려준다.
      에러가 보고되었을 경우,
      반환된 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 동안의 클래스"><CODE>Schema</CODE></A>  객체가 의미를 가지는 것은
      보증되지 않는다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 안의 클래스">SAXException</A> </CODE> - 지정된 입력의 처리시에 에러가 발견되었을 경우.
      <A HREF="../../../org/xml/sax/ErrorHandler.html" title="org.xml.sax 안의 인터페이스"><CODE>ErrorHandler</CODE></A>  가 설정되어 있는 경우, 에러는 최초로 그것들에
      보고된다. <A HREF="../../../javax/xml/validation/SchemaFactory.html#setErrorHandler(org.xml.sax.ErrorHandler)"><CODE>setErrorHandler(ErrorHandler)</CODE></A>  를 참조
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>schemas</code> 파라미터 자체가 null 인가,
      배열내의 항목이 null 인 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 배열내의 항목이 이 메소드에 의해 인식되지 않는 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - schema 언어가 이 처리를 지원하고 있지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="newSchema()"><!-- --></A> <H3>
newSchema</H3>
<PRE>
public abstract <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 내의 클래스">Schema</A>  <B>newSchema</B>()
                          throws <A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 내의 클래스">SAXException</A> </PRE>
<DL>
<DD>특수한 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 안의 클래스"><CODE>Schema</CODE></A>  객체를 작성합니다.
 
　<p>반환되는 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 동안의 클래스"><CODE>Schema</CODE></A>  객체의 정확한 시멘틱스는, 이 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  가 작성된 schema 언어에 따라서 다릅니다.
 
　<p>게다가 구현에서는 구현 고유의 프로퍼티 또는 기능을 사용해, 이 메소드의 시멘틱스를 변경할 수 있습니다. </p>
 
　<p>구현시 및 개발시에는, 이 특수한 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 안의 클래스"><CODE>Schema</CODE></A>  에 의한 <A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 동안의 클래스"><CODE>SchemaFactory</CODE></A>  의 기능 세트의 처리 방법으로 특별히 주의하도록(듯이) 합니다. 예를 들어, 경우에 따라서는,<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  와 클래스가, 다른 구현으로부터의 schema를 실제로 로드할 때,<A HREF="../../../javax/xml/validation/SchemaFactory.html" title="javax.xml.validation 안의 클래스"><CODE>SchemaFactory</CODE></A>  의 기능을 자동적으로 상속할 수 없는 것이 있습니다. 개발시에는, 시큐리티 처리등의 기능을 양쪽 모두의 장소에서 명시적으로 설정하도록 해 주세요. </p>
 
<h2>W3C XML Schema 1.0</h2>
 <p>
XML Schema 의 경우, 이 메소드는 문서로 지정된 장소의 힌트를 사용해, 검증을 실행하는 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 동안의 클래스"><CODE>Schema</CODE></A>  객체를 작성합니다.
 
 <p>
반환되는 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 동안의 클래스"><CODE>Schema</CODE></A>  객체는, 문서로 schema의 장소의 힌트의 같은 URL 를 참조하고 있는 경우, 그것들은 항상 같은 schema 문서에 해결되는 것으로 간주합니다. 이 상정에 의해, 구현에서는 schema 문서의 해석 결과를 재사용할 수 있기 (위해)때문에, 같은 schema에 대한 복수의 검증의 실행이 빨라집니다.
 
 <p>
schema의 장소의 힌트를 사용하는 것으로, 서비스 방해 공격을 받기 쉬워질테니 주의해 주세요.  
  
 
<h2>RELAX NG</h2>
 <p>
RELAX NG 에서는 이 처리를 지원하고 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>항상 null 이외의 유효한 <A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 안의 클래스"><CODE>Schema</CODE></A>  객체를 돌려준다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 처리가 불려 가는 측에야는 지원되어 있지 않은 경우
<DD><CODE><A HREF="../../../org/xml/sax/SAXException.html" title="org.xml.sax 안의 클래스">SAXException</A> </CODE> - 이 처리는 지원되고 있지만, 어떠한 이유에 의해 실패했을 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SchemaFactory.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/xml/validation/Schema.html" title="javax.xml.validation 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/xml/validation/SchemaFactoryLoader.html" title="javax.xml.validation 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/xml/validation/SchemaFactory.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="SchemaFactory.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요:&nbsp;상자&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세:&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
