<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:27:49 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
JTable (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JTable (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JTable.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/swing/JTabbedPane.ModelListener.html" title="javax.swing 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/swing/JTable.AccessibleJTable.html" title="javax.swing 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/swing/JTable.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="JTable.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.swing</FONT>
<BR>
클래스 JTable</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">java.awt.Component</A> 
      <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">java.awt.Container</A> 
          <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">javax.swing.JComponent</A> 
              <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.swing.JTable</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 내의 인터페이스">ImageObserver</A> , <A HREF="../../java/awt/MenuContainer.html" title="java.awt 안의 인터페이스">MenuContainer</A> , <A HREF="../../java/io/Serializable.html" title="java.io 안의 인터페이스">Serializable</A> , <A HREF="../../java/util/EventListener.html" title="java.util 안의 인터페이스">EventListener</A> , <A HREF="../../javax/accessibility/Accessible.html" title="javax.accessibility 안의 인터페이스">Accessible</A> , <A HREF="../../javax/swing/event/CellEditorListener.html" title="javax.swing.event 안의 인터페이스">CellEditorListener</A> , <A HREF="../../javax/swing/event/ListSelectionListener.html" title="javax.swing.event 안의 인터페이스">ListSelectionListener</A> , <A HREF="../../javax/swing/event/RowSorterListener.html" title="javax.swing.event 안의 인터페이스">RowSorterListener</A> , <A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 안의 인터페이스">TableColumnModelListener</A> , <A HREF="../../javax/swing/event/TableModelListener.html" title="javax.swing.event 안의 인터페이스">TableModelListener</A> , <A HREF="../../javax/swing/Scrollable.html" title="javax.swing 안의 인터페이스">Scrollable</A> </DD>
</DL>
<HR><script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><HR>
<DL>
<DT><PRE>public class <B>JTable</B><DT>extends <A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> <DT>implements <A HREF="../../javax/swing/event/TableModelListener.html" title="javax.swing.event 내의 인터페이스">TableModelListener</A> , <A HREF="../../javax/swing/Scrollable.html" title="javax.swing 안의 인터페이스">Scrollable</A> , <A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 안의 인터페이스">TableColumnModelListener</A> , <A HREF="../../javax/swing/event/ListSelectionListener.html" title="javax.swing.event 안의 인터페이스">ListSelectionListener</A> , <A HREF="../../javax/swing/event/CellEditorListener.html" title="javax.swing.event 안의 인터페이스">CellEditorListener</A> , <A HREF="../../javax/accessibility/Accessible.html" title="javax.accessibility 안의 인터페이스">Accessible</A> , <A HREF="../../javax/swing/event/RowSorterListener.html" title="javax.swing.event 안의 인터페이스">RowSorterListener</A> </DL>
</PRE>

<P>
<code>JTable</code> 는, 셀의 일반적으로의 2 차원 테이블 형식을 표시해, 편집하기 위해서 사용합니다. <code>JTable</code> 사용의 태스크 지향의 메뉴얼과 예에 대해서는, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/components/table.html">「How to Use Tables」</a>를 참조해 주세요.

 <p>
<code>JTable</code> 는, 그 draw 및 편집을 커스터마이즈 할 수 있도록(듯이) 하는 다수의 기능을 갖추는 한편으로, 이러한 기능의 디폴트를 제공해 간단한 테이블을 용이하게 설정할 수 있도록(듯이) 하고 있습니다. 예를 들어, 10 행 10 열로부터 구성되는 테이블은 다음과 같이 설정할 수 있습니다.  &nbsp;<p>
 <pre>
      TableModel dataModel = new AbstractTableModel() {
          public int getColumnCount() { return 10; }
          public int getRowCount() { return 10;}
          public Object getValueAt(int row, int col) { return new Integer(row*col); }
      };
      JTable table = new JTable(dataModel);
      JScrollPane scrollpane = new JScrollPane(table);
 </pre>
 <p>
스탠드얼론의 뷰 (<code>JScrollPane</code> 의 외측) 내에서 <code>JTable</code> 를 사용해, 헤더를 표시하는 경우는,<A HREF="../../javax/swing/JTable.html#getTableHeader()"><CODE>getTableHeader()</CODE></A>  를 사용해 헤더를 취득해, 개별적으로 표시할 수 있습니다.  &nbsp;<p>
행의 소트 및 필터링을 가능하게 하려면 ,<code>RowSorter</code> 를 사용합니다. 행 소터는, 다음의 2 종류의 방법으로 설정할 수 있습니다.  
 <ul>
<li><code>RowSorter</code> 를 직접 설정합니다. 다음에 예를 나타냅니다. <code>table.setRowSorter(new TableRowSorter(model))</code>.
<li><code>autoCreateRowSorter</code> 프로퍼티을 <code>true</code> 로 설정해,<code>JTable</code> 가 자동적으로 <code>RowSorter</code> 를 작성하도록(듯이) 합니다. 다음에 예를 나타냅니다. <code>setAutoCreateRowSorter(true)</code>.
 </ul>
 <p>
<code>JTable</code> 를 사용하는 어플리케이션을 설계하는 경우, 테이블의 데이터를 표현하는 데이터 구조에 충분히 주의할 필요가 있습니다. <code>DefaultTableModel</code> 는 <code>Object</code> 의 <code>Vectors</code> 의 <code>Vector</code> 를 사용해 셀의 값을 포함하는 구현의 모델입니다. 어플리케이션으로부터 <code>DefaultTableModel</code> 에 데이터를 카피함과 함께, 상기의 예의 통과해, 데이터가 직접 <code>JTable</code> 에게 건네지도록(듯이),<code>TableModel</code> 인터페이스의 메소드내의 데이터를 랩 할 수도 있습니다. 이것에 의해, 모델이 데이터에 가장 적합한 내부 표현을 자유롭게 선택할 수 있는 것으로부터, 한층 더 효과적인 어플리케이션을 작성할 수 있습니다. <code>AbstractTableModel</code> 또는 <code>DefaultTableModel</code> 의 어느 쪽을 사용할까를 결정하는 대범한 지침에서는, 서브 클래스를 작성하기 위한 base class로서 <code>AbstractTableModel</code> 가 사용되어 서브 클래스화가 불필요한 경우에 <code>DefaultTableModel</code> 가 사용됩니다.  &nbsp;<p>
소스로서 배포되는 demo 영역의 「TableExample」디렉토리는, 다수의 <code>JTable</code> 의 사용 방법에 관한 완전한 예를 제공합니다. 이 예에는, 데이타베이스로부터 취득하는 데이터의 편집 가능한 뷰를 제공하기 위해서 <code>JTable</code> 를 사용하는 방법이나, 특수한 렌더링이나 에디터를 사용하기 위해서 디스플레이내의 열을 변경하는 방법등이 있습니다.  &nbsp;<p>
<code>JTable</code> 는 정수형을 배타적으로 사용해, 그것이 표시하는 모델의 행과 열을 어느쪽이나 참조합니다. <code>JTable</code> 는 단지 탭 형식 범위의 셀을 취득해 <code>getValueAt(int, int)</code> 를 사용해, draw시에 모델로부터 값을 꺼냅니다. 다양한 <code>JTable</code> 메소드로부터 반환되는 열인덱스와 행 인덱스는 <code>JTable</code> (뷰)의 것이며, 모델이 사용하는 인덱스와는 반드시 같지 않은 점에 주의해 주세요.  &nbsp;<p>
디폴트로, 열은 <code>JTable</code> 로 다시 배열해 , 뷰의 열이 모델내의 열과는 다른 차례로 표시되게 됩니다. 이것은, 모델의 구현에 전혀 영향을 주지 않습니다. 열이 늘어놓고 바꾸고를 실시할 때는,<code>JTable</code> 는 열의 새로운 차례를 내부적으로 유지해, 그 열인덱스를 모델의 조회전으로 변환합니다.  &nbsp;<p>
이 때문에,<code>TableModel</code> 를 기술할 때는, 뷰로 무엇이 일어나고 있을까에 관계없이 모델은 그것 자신의 좌표계로 조회되므로, 열 늘어놓고 바꾸고 이벤트에 대기할 필요는 없습니다. examples 부하에게는, 열은 아니고 행의 차례를 변경하는 이제(벌써) 1 개의 좌표계를 삽입하기 위한 , 이 방법을 이용한 늘어놓고 바꾸고 알고리즘의 샘플이 준비되어 있습니다.  &nbsp;<p>
같이<code>RowSorter</code> 로부터 제공되는 소트 기능과 필터링 기능을 사용할 때, 부하의 <code>TableModel</code> 가 소트의 방법을 파악하고 있을 필요는 없습니다. 소트 처리는,<code>RowSorter</code> 에 의해 행해집니다. 행 베이스의 <code>JTable</code> 메소드와 부하의 <code>TableModel</code> 를 사용하는 경우는, 좌표변화가 필요하게 됩니다. 행 베이스의 <code>JTable</code> 메소드는 모두 <code>RowSorter</code> 의 것이며, 부하의 <code>TableModel</code> 의 메소드와 반드시 일치하고 있습니다. 예를 들어, 선택은 항상 <code>JTable</code> 에 관해서 행해지므로,<code>RowSorter</code> 를 사용할 때는,<code>convertRowIndexToView</code> 또는 <code>convertRowIndexToModel</code> 를 사용해 변환할 필요가 있습니다. 다음의 코드는,<code>JTable</code> 로부터 부하의 모델에 좌표변화를 실시하는 방법을 나타냅니다.
 <pre>
   int[] selection = table.getSelectedRows();
   for (int i = 0; i &lt; selection.length; i++) {
     selection[i] = table.convertRowIndexToModel(selection[i]);
   }
   // selection is now in terms of the underlying TableModel
 </pre>
 <p>
디폴트에서는, 소트가 유효하게 되어 있는 경우,<code>JTable</code> 는, 소트시에 모델의 선택 내용과 가변의 행의 높이를 보관 유지합니다. 예를 들어 부하의 모델의 행 0 이 현재 선택되고 있는 경우는, 소트 후도 부하의 모델의 행 0 이 선택됩니다. 시각적으로는 선택 내용이 변경되고 있을 가능성이 있습니다만, 부하의 모델의 선택 내용은 변하지 않습니다. 예외는, 모델 인덱스가 가시가 아니게 되었을 경우나, 삭제되었을 경우입니다. 예를 들어, 모델의 행 0 이 필터 되어 표시되지 않게 되었을 경우, 소트 후에 선택 내용은 비웁니다.  &nbsp;<p>
J2SE 5 에서는,<code>JTable</code> 에, 일반적인 인쇄 요구를 실현할 수 있는 편리한 메소드를 추가하고 있습니다. 새로운 <A HREF="../../javax/swing/JTable.html#print()"><CODE>print()</CODE></A>  메소드를 사용하는 것만으로, 신속하고 용이하게 인쇄 기능을 어플리케이션에 추가할 수 있습니다. 또, 한층 더 고도의 인쇄 요구에는, 새로운 <A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><CODE>getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)</CODE></A>  메소드를 사용할 수 있습니다.  &nbsp;<p>
모든 <code>JComponent</code> 클래스에 관해서는,<A HREF="../../javax/swing/InputMap.html" title="javax.swing 안의 클래스"><CODE>InputMap</CODE></A>  와 <A HREF="../../javax/swing/ActionMap.html" title="javax.swing 안의 클래스"><CODE>ActionMap</CODE></A>  를 사용해 <A HREF="../../javax/swing/Action.html" title="javax.swing 동안의 인터페이스"><CODE>Action</CODE></A>  객체와 <A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스"><CODE>KeyStroke</CODE></A>  를 관련지어 지정한 조건으로 액션을 실행할 수 있습니다.  &nbsp;<p>
<strong>경고:</strong> Swing 는 thread에 대해서 안전하지는 않습니다. 자세한 것은,<a  href="package-summary.html#threading">「Swing's Threading Policy」</a>를 참조해 주세요.  &nbsp;<p>
<strong>경고:</strong> 이 클래스의 직렬화 된 객체는, 향후의 Swing 릴리스와 호환은 아니게 될 예정입니다. 현재의 직렬화의 지원는, 단기간의 운용이나, 같은 버젼의 Swing 를 실행하는 어플리케이션간의 RMI 에 적절하고 있습니다. JDK Version 1.4 이후, 모든 JavaBeans<sup><font size="-2">&trade;</font></sup> 의 장기간의 운용 지원는,<code>java.beans</code> 패키지에 추가되고 있습니다. 자세한 것은,<A HREF="../../java/beans/XMLEncoder.html" title="java.beans 안의 클래스"><CODE>XMLEncoder</CODE></A>  를 참조해 주세요.
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/DefaultTableModel.html" title="javax.swing.table 내의 클래스"><CODE>DefaultTableModel</CODE></A> , 
<A HREF="../../javax/swing/table/TableRowSorter.html" title="javax.swing.table 안의 클래스"><CODE>TableRowSorter</CODE></A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>상자의 클래스의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.AccessibleJTable.html" title="javax.swing 안의 클래스">JTable.AccessibleJTable</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 클래스는 <code>JTable</code> 클래스용의 접근성? 지원를 구현하고 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.DropLocation.html" title="javax.swing 안의 클래스">JTable.DropLocation</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JTable</code> 의 드롭 위치를 나타내는 <code>TransferHandler.DropLocation</code> 의 서브 클래스입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JTable</code> 의 인쇄에 사용하는 인쇄 모드입니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_javax.swing.JComponent"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 javax.swing. <A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A>  로부터 상속된 상자의 클래스/인터페이스</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javax/swing/JComponent.AccessibleJComponent.html" title="javax.swing 안의 클래스">JComponent.AccessibleJComponent</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<A NAME="nested_classes_inherited_from_class_java.awt.Container"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Container.html" title="java.awt 안의 클래스">Container</A>  로부터 상속된 상자의 클래스/인터페이스</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Container.AccessibleAWTContainer.html" title="java.awt 안의 클래스">Container.AccessibleAWTContainer</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<A NAME="nested_classes_inherited_from_class_java.awt.Component"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A>  로부터 상속된 상자의 클래스/인터페이스</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.AccessibleAWTComponent.html" title="java.awt 안의 클래스">Component.AccessibleAWTComponent</A> , <A HREF="../../java/awt/Component.BaselineResizeBehavior.html" title="java.awt 안의 열거형">Component.BaselineResizeBehavior</A> , <A HREF="../../java/awt/Component.BltBufferStrategy.html" title="java.awt 안의 클래스">Component.BltBufferStrategy</A> , <A HREF="../../java/awt/Component.FlipBufferStrategy.html" title="java.awt 안의 클래스">Component.FlipBufferStrategy</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#AUTO_RESIZE_ALL_COLUMNS">AUTO_RESIZE_ALL_COLUMNS</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 사이즈 변경 조작으로, 각 열을 균등하게 사이즈 변경합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#AUTO_RESIZE_LAST_COLUMN">AUTO_RESIZE_LAST_COLUMN</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 사이즈 변경 조작으로, 최종열인 만큼 조정을 적용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#AUTO_RESIZE_NEXT_COLUMN">AUTO_RESIZE_NEXT_COLUMN</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열을 UI 로 조정할 때는, 다음의 열을 역방향으로 조정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#AUTO_RESIZE_OFF">AUTO_RESIZE_OFF</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;렬폭의 조정은 자동적으로 실시하지 않고 , 스크롤 바를 사용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#AUTO_RESIZE_SUBSEQUENT_COLUMNS">AUTO_RESIZE_SUBSEQUENT_COLUMNS</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UI 를 조정할 때는, 그 이후의 열을 변경해 열의 합계폭을 유지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#autoCreateColumnsFromModel">autoCreateColumnsFromModel</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true 의 경우, 열의 디폴트 세트를 구축하도록(듯이) <code>TableModel</code> 에 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#autoResizeMode">autoResizeMode</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 폭의 사이즈를 자동 변경해 각 열로 테이블폭전체를 차지하도록(듯이) 할지 어떨지를 지정해, 그 사이즈 변경의 방법을 지정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#cellEditor">cellEditor</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 셀이 차지하는 화면상의 장소를 덧쓰기해, 사용자가 그 내용을 변경할 수 있도록(듯이) 하는 액티브한 셀 에디터 객체입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#cellSelectionEnabled">cellSelectionEnabled</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 2 플랫폼 v1. 3 에서는 사용하지 않습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 내의 인터페이스">TableColumnModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnModel">columnModel</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 <code>TableColumnModel</code> 입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#dataModel">dataModel</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 <code>TableModel</code> 입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/util/Hashtable.html" title="java.util 내의 클래스">Hashtable</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#defaultEditorsByColumnClass">defaultEditorsByColumnClass</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;셀의 내용을 표시 및 편집하는 객체의 테이블입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/util/Hashtable.html" title="java.util 내의 클래스">Hashtable</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#defaultRenderersByColumnClass">defaultRenderersByColumnClass</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;셀의 내용을 표시하는 객체의 테이블입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editingColumn">editingColumn</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;편집중의 셀의 열을 식별합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editingRow">editingRow</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;편집중의 셀의 행을 식별합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editorComp">editorComp</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;편집시이면, 편집을 처리하고 있는 <code>Component</code> 입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#gridColor">gridColor</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;구라두의 색입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#preferredViewportSize">preferredViewportSize</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Scrollable</code> 인터페이스에 의해 사용되어 가시 영역의 초기설정을 실시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#rowHeight">rowHeight</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 각 행의 높이를 픽셀로 나타낸 것입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#rowMargin">rowMargin</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;각 행의 셀간의 마진의 높이를 픽셀로 나타낸 것입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#rowSelectionAllowed">rowSelectionAllowed</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블로 행 선택이 허가되고 있는 경우, true 입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#selectionBackground">selectionBackground</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 셀의 백그라운드 칼라</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#selectionForeground">selectionForeground</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 셀의 foreground 칼라</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스">ListSelectionModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#selectionModel">selectionModel</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;행 선택을 추적하는데 사용하는, 테이블의 <code>ListSelectionModel</code> 입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#showHorizontalLines">showHorizontalLines</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>showHorizontalLines</code> 가 true 의 경우, 테이블은 셀간에 수평선을 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#showVerticalLines">showVerticalLines</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>showVerticalLines</code> 가 true 의 경우, 테이블은 셀간에 수직선을 draw 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스">JTableHeader</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#tableHeader">tableHeader</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 <code>TableHeader</code> 입니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_javax.swing.JComponent"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 javax.swing. <A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javax/swing/JComponent.html#accessibleContext">accessibleContext</A> , <A HREF="../../javax/swing/JComponent.html#listenerList">listenerList</A> , <A HREF="../../javax/swing/JComponent.html#TOOL_TIP_TEXT_KEY">TOOL_TIP_TEXT_KEY</A> , <A HREF="../../javax/swing/JComponent.html#ui">ui</A> , <A HREF="../../javax/swing/JComponent.html#UNDEFINED_CONDITION">UNDEFINED_CONDITION</A> , <A HREF="../../javax/swing/JComponent.html#WHEN_ANCESTOR_OF_FOCUSED_COMPONENT">WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</A> , <A HREF="../../javax/swing/JComponent.html#WHEN_FOCUSED">WHEN_FOCUSED</A> , <A HREF="../../javax/swing/JComponent.html#WHEN_IN_FOCUSED_WINDOW">WHEN_IN_FOCUSED_WINDOW</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.Component"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.html#BOTTOM_ALIGNMENT">BOTTOM_ALIGNMENT</A> , <A HREF="../../java/awt/Component.html#CENTER_ALIGNMENT">CENTER_ALIGNMENT</A> , <A HREF="../../java/awt/Component.html#LEFT_ALIGNMENT">LEFT_ALIGNMENT</A> , <A HREF="../../java/awt/Component.html#RIGHT_ALIGNMENT">RIGHT_ALIGNMENT</A> , <A HREF="../../java/awt/Component.html#TOP_ALIGNMENT">TOP_ALIGNMENT</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.image.ImageObserver"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.awt.image. <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/image/ImageObserver.html#ABORT">ABORT</A> , <A HREF="../../java/awt/image/ImageObserver.html#ALLBITS">ALLBITS</A> , <A HREF="../../java/awt/image/ImageObserver.html#ERROR">ERROR</A> , <A HREF="../../java/awt/image/ImageObserver.html#FRAMEBITS">FRAMEBITS</A> , <A HREF="../../java/awt/image/ImageObserver.html#HEIGHT">HEIGHT</A> , <A HREF="../../java/awt/image/ImageObserver.html#PROPERTIES">PROPERTIES</A> , <A HREF="../../java/awt/image/ImageObserver.html#SOMEBITS">SOMEBITS</A> , <A HREF="../../java/awt/image/ImageObserver.html#WIDTH">WIDTH</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable()">JTable</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트 데이터 모델, 디폴트열모델, 및 디폴트 선택 모델로 초기화되는, 디폴트의 <code>JTable</code> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable(int, int)">JTable</A> </B>(int&nbsp;numRows,
       int&nbsp;numColumns)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DefaultTableModel</code> 를 사용해, 빈 상태(empty)의 셀 <code>numRows</code> 와 <code>numColumns</code> 를 가지는 <code>JTable</code> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable(java.lang.Object[][], java.lang.Object[])">JTable</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> [][]&nbsp;rowData,
       <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;columnNames)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 차원 배열 <code>rowData</code> 의 값을 표시하는 <code>JTable</code> 를, 렬명 <code>columnNames</code> 로 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable(javax.swing.table.TableModel)">JTable</A> </B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터 모델 <code>dm</code>, 디폴트열모델, 및 디폴트 선택 모델로 초기화되는 <code>JTable</code> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable(javax.swing.table.TableModel, javax.swing.table.TableColumnModel)">JTable</A> </B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dm,
       <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 안의 인터페이스">TableColumnModel</A> &nbsp;cm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터 모델 <code>dm</code>, 열모델 <code>cm</code>, 및 디폴트 선택 모델로 초기화되는 <code>JTable</code> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable(javax.swing.table.TableModel, javax.swing.table.TableColumnModel, javax.swing.ListSelectionModel)">JTable</A> </B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dm,
       <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 안의 인터페이스">TableColumnModel</A> &nbsp;cm,
       <A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 안의 인터페이스">ListSelectionModel</A> &nbsp;sm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터 모델 <code>dm</code>, 열모델 <code>cm</code>, 및 선택 모델 <code>sm</code> 로 초기화되는 <code>JTable</code> 를 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable(java.util.Vector, java.util.Vector)">JTable</A> </B>(<A HREF="../../java/util/Vector.html" title="java.util 안의 클래스">Vector</A> &nbsp;rowData,
       <A HREF="../../java/util/Vector.html" title="java.util 안의 클래스">Vector</A> &nbsp;columnNames)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Vectors</code> 의 <code>Vector</code> 의 값을 표시하는 <code>JTable</code>, 즉 <code>rowData</code> 를, 렬명 <code>columnNames</code> 로 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메소드의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#addColumn(javax.swing.table.TableColumn)">addColumn</A> </B>(<A HREF="../../javax/swing/table/TableColumn.html" title="javax.swing.table 안의 클래스">TableColumn</A> &nbsp;aColumn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JTable</code> 의 열모델이 보관 유지하는 열의 배열의 말미에 <code>aColumn</code> 를 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#addColumnSelectionInterval(int, int)">addColumnSelectionInterval</A> </B>(int&nbsp;index0,
                           int&nbsp;index1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index0</code> 로부터 <code>index1</code> 까지의 열 (상하한치를 포함한다)을 현재의 선택 영역에 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#addNotify()">addNotify</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>configureEnclosingScrollPane</code> 메소드를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#addRowSelectionInterval(int, int)">addRowSelectionInterval</A> </B>(int&nbsp;index0,
                        int&nbsp;index1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index0</code> 로부터 <code>index1</code> 까지의 행 (상하한치를 포함한다)을 현재의 선택 영역에 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#changeSelection(int, int, boolean, boolean)">changeSelection</A> </B>(int&nbsp;rowIndex,
                int&nbsp;columnIndex,
                boolean&nbsp;toggle,
                boolean&nbsp;extend)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>toggle</code> 와 <code>extend</code> 의 2 개의 플래그 상태에 의해, 테이블의 선택 모델을 갱신합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#clearSelection()">clearSelection</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택 떠날 수 있어 모든 열 및 행을 선택 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnAdded(javax.swing.event.TableColumnModelEvent)">columnAdded</A> </B>(<A HREF="../../javax/swing/event/TableColumnModelEvent.html" title="javax.swing.event 안의 클래스">TableColumnModelEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블열모델에 열이 추가될 때 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnAtPoint(java.awt.Point)">columnAtPoint</A> </B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;point)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>point</code> 가 존재하는 경우는 그 열의 인덱스, 결과가 [0, <code>getColumnCount()</code>-1] 의 범위내에 없는 경우는 -1 을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnMarginChanged(javax.swing.event.ChangeEvent)">columnMarginChanged</A> </B>(<A HREF="../../javax/swing/event/ChangeEvent.html" title="javax.swing.event 안의 클래스">ChangeEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;마진의 변경을 위해서(때문에) 열이 이동될 때 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnMoved(javax.swing.event.TableColumnModelEvent)">columnMoved</A> </B>(<A HREF="../../javax/swing/event/TableColumnModelEvent.html" title="javax.swing.event 안의 클래스">TableColumnModelEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열이 재배치되면(자) 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnRemoved(javax.swing.event.TableColumnModelEvent)">columnRemoved</A> </B>(<A HREF="../../javax/swing/event/TableColumnModelEvent.html" title="javax.swing.event 안의 클래스">TableColumnModelEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열이 테이블열모델로부터 삭제될 때 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnSelectionChanged(javax.swing.event.ListSelectionEvent)">columnSelectionChanged</A> </B>(<A HREF="../../javax/swing/event/ListSelectionEvent.html" title="javax.swing.event 안의 클래스">ListSelectionEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TableColumnModel</code> 의 선택 모델이 변경될 때 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#configureEnclosingScrollPane()">configureEnclosingScrollPane</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;일반적으로은 이 <code>JTable</code> 가 둘러싸 옆 <code>JScrollPane</code> 의 <code>viewportView</code> 입니다만, 그 경우, 특히 테이블의 <code>tableHeader</code> 을 스크롤 구획의 <code>columnHeaderView</code> 로서 인스톨 하는 것에 의해, 이 <code>ScrollPane</code> 의 설정을 실시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#convertColumnIndexToModel(int)">convertColumnIndexToModel</A> </B>(int&nbsp;viewColumnIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;식별자 객체 <code>viewColumnIndex</code> 의 뷰내의 열의 인덱스를, 테이블 모델내의 열의 인덱스에 매핑 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#convertColumnIndexToView(int)">convertColumnIndexToView</A> </B>(int&nbsp;modelColumnIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>modelColumnIndex</code> 의 테이블 모델내의 열의 인덱스를, 뷰내의 열의 인덱스에 매핑 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#convertRowIndexToModel(int)">convertRowIndexToModel</A> </B>(int&nbsp;viewRowIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;뷰의 행의 인덱스를 부하의 <code>TableModel</code> 에 매핑 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#convertRowIndexToView(int)">convertRowIndexToView</A> </B>(int&nbsp;modelRowIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TableModel</code> 의 행의 인덱스를 뷰에 매핑 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 내의 인터페이스">TableColumnModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultColumnModel()">createDefaultColumnModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DefaultTableColumnModel</code> 인 디폴트의 열모델 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultColumnsFromModel()">createDefaultColumnsFromModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메소드는 <code>TableModel</code> 인터페이스로 정의된 <code>getColumnCount</code> 메소드를 사용해, 데이터 모델로부터 테이블의 디폴트의 열을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultDataModel()">createDefaultDataModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DefaultTableModel</code> 인 디폴트의 테이블 모델 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultEditors()">createDefaultEditors</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;객체, 수, 및 boolean 치의 디폴트의 셀 에디터를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultRenderers()">createDefaultRenderers</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;객체, 수, double 치, 일자, boolean 치, 및 아이콘의 디폴트의 셀 렌더링을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스">ListSelectionModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultSelectionModel()">createDefaultSelectionModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DefaultListSelectionModel</code> 인 디폴트의 선택 모델 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스">JTableHeader</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultTableHeader()">createDefaultTableHeader</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JTableHeader</code> 인 디폴트의 테이블 헤더 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../javax/swing/JScrollPane.html" title="javax.swing 내의 클래스">JScrollPane</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createScrollPaneForTable(javax.swing.JTable)">createScrollPaneForTable</A> </B>(<A HREF="../../javax/swing/JTable.html" title="javax.swing 안의 클래스">JTable</A> &nbsp;aTable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>Swing 1.0. 2 로 <code>new JScrollPane(aTable)</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#doLayout()">doLayout</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블에 행과 열을 레이아웃 시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editCellAt(int, int)">editCellAt</A> </B>(int&nbsp;row,
           int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code>,<code>column</code> 에 위치하는 셀의 인덱스가 유효한 범위내에 있어, 그 위치에 있는 셀이 편집 가능한 경우는, 셀의 편집을 프로그램에 근거해 개시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editCellAt(int, int, java.util.EventObject)">editCellAt</A> </B>(int&nbsp;row,
           int&nbsp;column,
           <A HREF="../../java/util/EventObject.html" title="java.util 안의 클래스">EventObject</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code>,<code>column</code> 에 위치하는 셀의 인덱스가 유효한 범위내에 있어, 그 위치에 있는 셀이 편집 가능한 경우는, 셀의 편집을 프로그램에 근거해 개시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editingCanceled(javax.swing.event.ChangeEvent)">editingCanceled</A> </B>(<A HREF="../../javax/swing/event/ChangeEvent.html" title="javax.swing.event 안의 클래스">ChangeEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;편집이 삭제되면(자) 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editingStopped(javax.swing.event.ChangeEvent)">editingStopped</A> </B>(<A HREF="../../javax/swing/event/ChangeEvent.html" title="javax.swing.event 안의 클래스">ChangeEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;편집이 완료했을 때에 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/accessibility/AccessibleContext.html" title="javax.accessibility 내의 클래스">AccessibleContext</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getAccessibleContext()">getAccessibleContext</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 JTable 에 관련한 AccessibleContext 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getAutoCreateColumnsFromModel()">getAutoCreateColumnsFromModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 디폴트의 열을 모델로부터 작성할지 어떨지를 지정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getAutoCreateRowSorter()">getAutoCreateRowSorter</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모델이 변경될 때마다 새로운 <code>RowSorter</code> 를 작성해, 테이블의 소터로서 인스톨 하는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getAutoResizeMode()">getAutoResizeMode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 자동 사이즈 변경 모드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getCellEditor()">getCellEditor</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 현재 편집중이 아닌 경우는 액티브한 셀 에디터 (<code>null</code>)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getCellEditor(int, int)">getCellEditor</A> </B>(int&nbsp;row,
              int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code> 와 <code>column</code> 가 지정하는 셀의 적절한 에디터를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getCellRect(int, int, boolean)">getCellRect</A> </B>(int&nbsp;row,
            int&nbsp;column,
            boolean&nbsp;includeSpacing)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code> 와 <code>column</code> 가 교차하는 위치의 셀의 구형을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 내의 인터페이스">TableCellRenderer</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getCellRenderer(int, int)">getCellRenderer</A> </B>(int&nbsp;row,
                int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 행과 열로 지정하는 셀의 적절한 렌더링을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getCellSelectionEnabled()">getCellSelectionEnabled</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;행 선택 모델과 열선택 모델의 양쪽 모두가 가능한 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableColumn.html" title="javax.swing.table 내의 클래스">TableColumn</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getColumn(java.lang.Object)">getColumn</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;identifier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>equals</code> 를 사용해 비교해, 식별자가 <code>identifier</code> 에 동일한 테이블내의 열의 <code>TableColumn</code> 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getColumnClass(int)">getColumnClass</A> </B>(int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열위치 <code>column</code> 의 뷰에 표시되는 열의 형태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getColumnCount()">getColumnCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열모델내의 렬수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 내의 인터페이스">TableColumnModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getColumnModel()">getColumnModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 모든 열정보를 보관 유지하는 <code>TableColumnModel</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getColumnName(int)">getColumnName</A> </B>(int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열위치 <code>column</code> 의 뷰에 표시되는 열의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getColumnSelectionAllowed()">getColumnSelectionAllowed</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열을 선택할 수 있는 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getDefaultEditor(java.lang.Class)">getDefaultEditor</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TableColumn</code> 에 에디터가 설정되어 있지 않은 경우에 사용하는 에디터를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 내의 인터페이스">TableCellRenderer</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getDefaultRenderer(java.lang.Class)">getDefaultRenderer</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TableColumn</code> 에 렌더링이 설정되어 있지 않은 경우에 사용하는, 셀 렌더링을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getDragEnabled()">getDragEnabled</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;자동 드래그 처리가 유효한지 어떤지를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/JTable.DropLocation.html" title="javax.swing 내의 클래스">JTable.DropLocation</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getDropLocation()">getDropLocation</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 컴퍼넌트의 드래그＆드롭시에 드롭 위치로서 시각적으로 가리키는 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/DropMode.html" title="javax.swing 내의 열거형">DropMode</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getDropMode()">getDropMode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 드롭 모드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getEditingColumn()">getEditingColumn</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 편집중의 셀을 포함한 열의 인덱스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getEditingRow()">getEditingRow</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 편집중의 셀을 포함한 행의 인덱스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getEditorComponent()">getEditorComponent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;편집 세션을 처리하고 있는 컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getFillsViewportHeight()">getFillsViewportHeight</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블을 항상 둘러싸 옆의 뷰포트의 높이에 맞추어 크게 할지 어떨지를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getGridColor()">getGridColor</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;구라두선의 draw에 사용하는 색을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getIntercellSpacing()">getIntercellSpacing</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;셀간의 수평 간격과 수직 간격을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getModel()">getModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JTable</code> 가 표시하는 데이터를 제공하는 <code>TableModel</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getPreferredScrollableViewportSize()">getPreferredScrollableViewportSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 뷰포트의 바람직한 사이즈를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/print/Printable.html" title="java.awt.print 내의 인터페이스">Printable</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)">getPrintable</A> </B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
             <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
             <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 JTable 의 인쇄에 사용하는 <code>Printable</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getRowCount()">getRowCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스페이스에 제한이 없는 경우,<code>JTable</code> 에 표시할 수 있는 행수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getRowHeight()">getRowHeight</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블행의 높이를 픽셀로 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getRowHeight(int)">getRowHeight</A> </B>(int&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code> 의 셀의 높이를 픽셀 단위로 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getRowMargin()">getRowMargin</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;셀의 간격을 픽셀 단위로 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getRowSelectionAllowed()">getRowSelectionAllowed</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;행을 선택할 수 있는 경우에 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/RowSorter.html" title="javax.swing 내의 클래스">RowSorter</A> &lt;?  extends <A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getRowSorter()">getRowSorter</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소트 처리를 실시하는 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getScrollableBlockIncrement(java.awt.Rectangle, int, int)">getScrollableBlockIncrement</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;visibleRect,
                            int&nbsp;orientation,
                            int&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 방향에 의해 <code>visibleRect.height</code> 또는 <code>visibleRect.width</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getScrollableTracksViewportHeight()">getScrollableTracksViewportHeight</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>getFillsViewportHeight</code> 가 <code>true</code> 로, 테이블의 적절한 높이가 뷰포트의 높이보다 낮은 경우를 제외해,<code>false</code> 를 돌려주어, 뷰포트의 높이가 테이블의 높이를 결정하지 않는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getScrollableTracksViewportWidth()">getScrollableTracksViewportWidth</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>autoResizeMode</code> 가 <code>AUTO_RESIZE_OFF</code> 로 설정되어 있는 경우는 false 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getScrollableUnitIncrement(java.awt.Rectangle, int, int)">getScrollableUnitIncrement</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;visibleRect,
                           int&nbsp;orientation,
                           int&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 1 행 또는 1 열을 완전하게 표시하는 스크롤 증분치를 (방향에 근거해) 픽셀 단위로 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectedColumn()">getSelectedColumn</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;최초로 선택된 열의 인덱스를 돌려주는지, 열이 선택되어 있지 않은 경우는 -1 을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectedColumnCount()">getSelectedColumnCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택되고 있는 열의 수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectedColumns()">getSelectedColumns</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 모든 열의 인덱스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectedRow()">getSelectedRow</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;최초로 선택된 행의 인덱스를 돌려주는지, 행이 선택되어 있지 않은 경우는 -1 을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectedRowCount()">getSelectedRowCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 행수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectedRows()">getSelectedRows</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 모든 행의 인덱스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectionBackground()">getSelectionBackground</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 셀의 백그라운드 칼라를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectionForeground()">getSelectionForeground</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택되고 있는 셀의 foreground 칼라를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스">ListSelectionModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectionModel()">getSelectionModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;행 선택 상태를 유지하는데 사용하는 <code>ListSelectionModel</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getShowHorizontalLines()">getShowHorizontalLines</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 셀간에 수평선을 draw 하는 경우는 true, draw 하지 않는 경우는 false 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getShowVerticalLines()">getShowVerticalLines</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 셀간에 수직선을 draw 하는 경우는 true, draw 하지 않는 경우는 false 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSurrendersFocusOnKeystroke()">getSurrendersFocusOnKeystroke</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;키보드가 에디터를 액티브화했을 때에 에디터가 포커스를 취득하는 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스">JTableHeader</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getTableHeader()">getTableHeader</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JTable</code> 가 사용하는 <code>tableHeader</code> 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getToolTipText(java.awt.event.MouseEvent)">getToolTipText</A> </B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JComponent</code> 의 <code>getToolTipText</code> 메소드를 오버라이드(override) 해, 텍스트 세트가 있는 경우, 렌더링의 힌트를 사용할 수 있도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/plaf/TableUI.html" title="javax.swing.plaf 내의 클래스">TableUI</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getUI()">getUI</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트를 draw 하는 L&F 객체를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getUIClassID()">getUIClassID</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Look & Feel 클래스의 이름의 구축에 사용된 접미사(suffix)을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getUpdateSelectionOnSort()">getUpdateSelectionOnSort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소트 후, 선택 내용을 갱신하는 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getValueAt(int, int)">getValueAt</A> </B>(int&nbsp;row,
           int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code>,<code>column</code> 에 위치하는 셀치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#initializeLocalVars()">initializeLocalVars</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 각 테이블 프로퍼티을 디폴트 값에 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#isCellEditable(int, int)">isCellEditable</A> </B>(int&nbsp;row,
               int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code>,<code>column</code> 에 위치하는 셀이 편집 가능한 경우에 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#isCellSelected(int, int)">isCellSelected</A> </B>(int&nbsp;row,
               int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 인덱스가 유효한 행 및 열의 범위내에 있어, 지정된 위치에 있는 셀이 선택되고 있는 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#isColumnSelected(int)">isColumnSelected</A> </B>(int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 인덱스가 유효한 열의 범위내에 있어, 그 인덱스로 나타나는 열이 선택되고 있는 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#isEditing()">isEditing</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;셀을 편집중의 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#isRowSelected(int)">isRowSelected</A> </B>(int&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 인덱스가 유효한 행의 범위내에 있어, 그 인덱스로 나타나는 행이 선택되고 있는 경우는 true 를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#moveColumn(int, int)">moveColumn</A> </B>(int&nbsp;column,
           int&nbsp;targetColumn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>column</code> 의 열을, 뷰내의 <code>targetColumn</code> 의 열이 현재 차지하는 위치로 이동합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#paramString()">paramString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#prepareEditor(javax.swing.table.TableCellEditor, int, int)">prepareEditor</A> </B>(<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 안의 인터페이스">TableCellEditor</A> &nbsp;editor,
              int&nbsp;row,
              int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code>,<code>column</code> 의 위치에 있는 셀의 값 및 선택 상태를 데이터 모델에 조회해, 에디터를 준비합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#prepareRenderer(javax.swing.table.TableCellRenderer, int, int)">prepareRenderer</A> </B>(<A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 안의 인터페이스">TableCellRenderer</A> &nbsp;renderer,
                int&nbsp;row,
                int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code>,<code>column</code> 의 위치에 있는 셀의 값 및 선택 상태를 데이터 모델에 조회해, 렌더링을 준비합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#print()">print</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인쇄 다이얼로그를 표시해, 이 <code>JTable</code> 를, 모드 <code>PrintMode.FIT_WIDTH</code> 로, 헤더 텍스트 또는 풋터 텍스트를 지정하지 않고 인쇄하는 편리한 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#print(javax.swing.JTable.PrintMode)">print</A> </B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인쇄 다이얼로그를 표시해, 이 <code>JTable</code> 를, 지정된 인쇄 모드로, 헤더 텍스트 또는 풋터 텍스트를 지정하지 않고 인쇄하는 편리한 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)">print</A> </B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
      <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
      <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인쇄 다이얼로그를 표시해, 이 <code>JTable</code> 를, 지정된 인쇄 모드로, 헤더 텍스트 또는 풋터 텍스트를 지정해 인쇄하는 편리한 메소드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat, boolean, javax.print.attribute.PrintRequestAttributeSet, boolean)">print</A> </B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
      <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
      <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat,
      boolean&nbsp;showPrintDialog,
      <A HREF="../../javax/print/attribute/PrintRequestAttributeSet.html" title="javax.print.attribute 안의 인터페이스">PrintRequestAttributeSet</A> &nbsp;attr,
      boolean&nbsp;interactive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;완전 지정의 <A HREF="../../javax/swing/JTable.html#print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat, boolean, javax.print.attribute.PrintRequestAttributeSet, boolean, javax.print.PrintService)"><CODE>print</CODE></A>  메소드로 지정된 것처럼, 인쇄 서비스로서 지정된 디폴트 프린터를 사용해, 이 테이블을 인쇄합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat, boolean, javax.print.attribute.PrintRequestAttributeSet, boolean, javax.print.PrintService)">print</A> </B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
      <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
      <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat,
      boolean&nbsp;showPrintDialog,
      <A HREF="../../javax/print/attribute/PrintRequestAttributeSet.html" title="javax.print.attribute 안의 인터페이스">PrintRequestAttributeSet</A> &nbsp;attr,
      boolean&nbsp;interactive,
      <A HREF="../../javax/print/PrintService.html" title="javax.print 안의 인터페이스">PrintService</A> &nbsp;service)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JTable</code> 를 인쇄합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#processKeyBinding(javax.swing.KeyStroke, java.awt.event.KeyEvent, int, boolean)">processKeyBinding</A> </B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;ks,
                  <A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e,
                  int&nbsp;condition,
                  boolean&nbsp;pressed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>KeyEvent</code> <code>e</code> 의 결과로서 <code>ks</code> 의 키 바인드를 처리하기 위해서 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#removeColumn(javax.swing.table.TableColumn)">removeColumn</A> </B>(<A HREF="../../javax/swing/table/TableColumn.html" title="javax.swing.table 안의 클래스">TableColumn</A> &nbsp;aColumn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>aColumn</code> 를 이 <code>JTable</code> 의 열배열로부터 삭제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#removeColumnSelectionInterval(int, int)">removeColumnSelectionInterval</A> </B>(int&nbsp;index0,
                              int&nbsp;index1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index0</code> 로부터 <code>index1</code> 까지의 열 (상하한치를 포함한다)을 선택 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#removeEditor()">removeEditor</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;에디터 객체를 파기해, 그 객체가 셀 draw에 사용한 장소를 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#removeNotify()">removeNotify</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>unconfigureEnclosingScrollPane</code> 메소드를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#removeRowSelectionInterval(int, int)">removeRowSelectionInterval</A> </B>(int&nbsp;index0,
                           int&nbsp;index1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index0</code> 로부터 <code>index1</code> 까지의 행 (상하한치를 포함한다)을 선택 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#resizeAndRepaint()">resizeAndRepaint</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>revalidate</code> 의 후에 <code>repaint</code> 를 호출하는 것과 동등합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#rowAtPoint(java.awt.Point)">rowAtPoint</A> </B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;point)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>point</code> 가 존재하는 경우는 그 행의 인덱스, 결과가 [0, <code>getRowCount()</code>-1] 의 범위내에 없는 경우는 -1 을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#selectAll()">selectAll</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 모든 행, 열, 및 셀을 선택합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setAutoCreateColumnsFromModel(boolean)">setAutoCreateColumnsFromModel</A> </B>(boolean&nbsp;autoCreateColumnsFromModel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 <code>autoCreateColumnsFromModel</code> 플래그를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setAutoCreateRowSorter(boolean)">setAutoCreateRowSorter</A> </B>(boolean&nbsp;autoCreateRowSorter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모델이 변경될 때마다 테이블의 <code>RowSorter</code> 를 작성할지 어떨지를 지정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setAutoResizeMode(int)">setAutoResizeMode</A> </B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 사이즈 변경시에 테이블의 자동 사이즈 변경 모드를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setCellEditor(javax.swing.table.TableCellEditor)">setCellEditor</A> </B>(<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 안의 인터페이스">TableCellEditor</A> &nbsp;anEditor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;액티브한 셀 에디터를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setCellSelectionEnabled(boolean)">setCellSelectionEnabled</A> </B>(boolean&nbsp;cellSelectionEnabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열선택과 행 선택의 동시 실행을 이 테이블이 허가할지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setColumnModel(javax.swing.table.TableColumnModel)">setColumnModel</A> </B>(<A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 안의 인터페이스">TableColumnModel</A> &nbsp;columnModel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 열모델을 <code>newModel</code> 로 설정해, 새로운 열모델로부터의 청취자 통지를 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setColumnSelectionAllowed(boolean)">setColumnSelectionAllowed</A> </B>(boolean&nbsp;columnSelectionAllowed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 모델의 열을 선택할 수 있을지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setColumnSelectionInterval(int, int)">setColumnSelectionInterval</A> </B>(int&nbsp;index0,
                           int&nbsp;index1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index0</code> 로부터 <code>index1</code> 까지의 열 (상하한치를 포함한다)을 선택합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setDefaultEditor(java.lang.Class, javax.swing.table.TableCellEditor)">setDefaultEditor</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass,
                 <A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 안의 인터페이스">TableCellEditor</A> &nbsp;editor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TableColumn</code> 에 에디터가 설정되어 있지 않은 경우에 사용하는, 디폴트의 셀 에디터를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setDefaultRenderer(java.lang.Class, javax.swing.table.TableCellRenderer)">setDefaultRenderer</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass,
                   <A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 안의 인터페이스">TableCellRenderer</A> &nbsp;renderer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TableColumn</code> 에 렌더링이 설정되어 있지 않은 경우에 사용하는, 디폴트의 셀 렌더링을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setDragEnabled(boolean)">setDragEnabled</A> </B>(boolean&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;자동 드래그 처리를 온 또는 오프로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setDropMode(javax.swing.DropMode)">setDropMode</A> </B>(<A HREF="../../javax/swing/DropMode.html" title="javax.swing 안의 열거형">DropMode</A> &nbsp;dropMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 드롭 모드를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setEditingColumn(int)">setEditingColumn</A> </B>(int&nbsp;aColumn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>editingColumn</code> 변수를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setEditingRow(int)">setEditingRow</A> </B>(int&nbsp;aRow)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>editingRow</code> 변수를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setFillsViewportHeight(boolean)">setFillsViewportHeight</A> </B>(boolean&nbsp;fillsViewportHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블을 항상 둘러싸 옆의 뷰포트의 높이에 맞추어 크게 할지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setGridColor(java.awt.Color)">setGridColor</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;gridColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;구라두선의 draw에 사용하는 색을 <code>gridColor</code> 로 설정해, 재표시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setIntercellSpacing(java.awt.Dimension)">setIntercellSpacing</A> </B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;intercellSpacing)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>rowMargin</code> 와 <code>columnMargin</code>, 즉 셀간의 스페이스의 높이와 폭을,<code>intercellSpacing</code> 로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setModel(javax.swing.table.TableModel)">setModel</A> </B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dataModel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 데이터 모델을 <code>newModel</code> 로 설정해, 거기에 새로운 데이터 모델로부터의 청취자 통지를 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setPreferredScrollableViewportSize(java.awt.Dimension)">setPreferredScrollableViewportSize</A> </B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 뷰포트의 바람직한 사이즈를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setRowHeight(int)">setRowHeight</A> </B>(int&nbsp;rowHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 행의 높이 <code>rowHeight</code> 가 1 미만의 경우 셀의 높이는, 행의 높이로부터 행 마진을 깎은 값이 됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setRowHeight(int, int)">setRowHeight</A> </B>(int&nbsp;row,
             int&nbsp;rowHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code> 의 높이를 <code>rowHeight</code> 로 설정해, 재확인해, 페인트 다시 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setRowMargin(int)">setRowMargin</A> </B>(int&nbsp;rowMargin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인접하는 행의 셀의 간격을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setRowSelectionAllowed(boolean)">setRowSelectionAllowed</A> </B>(boolean&nbsp;rowSelectionAllowed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 모델의 행을 선택할 수 있을지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setRowSelectionInterval(int, int)">setRowSelectionInterval</A> </B>(int&nbsp;index0,
                        int&nbsp;index1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index0</code> 로부터 <code>index1</code> 까지의 행 (상하한치를 포함한다)을 선택합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setRowSorter(javax.swing.RowSorter)">setRowSorter</A> </B>(<A HREF="../../javax/swing/RowSorter.html" title="javax.swing 안의 클래스">RowSorter</A> &lt;?  extends <A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A> &gt;&nbsp;sorter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RowSorter</code> 를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setSelectionBackground(java.awt.Color)">setSelectionBackground</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;selectionBackground)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 셀의 백그라운드 칼라를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setSelectionForeground(java.awt.Color)">setSelectionForeground</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;selectionForeground)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 셀의 foreground 칼라를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setSelectionMode(int)">setSelectionMode</A> </B>(int&nbsp;selectionMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 선택 모드를 설정하면(자), 단일 항목 선택, 연속 구간의 선택, 또는 연속 구간의 복수 선택을 가능하게 할 수 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setSelectionModel(javax.swing.ListSelectionModel)">setSelectionModel</A> </B>(<A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 안의 인터페이스">ListSelectionModel</A> &nbsp;newModel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 행 선택 모델을 <code>newModel</code> 로 설정해, 새로운 선택 모델로부터의 청취자 통지를 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setShowGrid(boolean)">setShowGrid</A> </B>(boolean&nbsp;showGrid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 셀의 주위에 구라두선을 draw 할지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setShowHorizontalLines(boolean)">setShowHorizontalLines</A> </B>(boolean&nbsp;showHorizontalLines)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 셀간에 수평선을 draw 할지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setShowVerticalLines(boolean)">setShowVerticalLines</A> </B>(boolean&nbsp;showVerticalLines)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 셀간에 수직선을 draw 할지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setSurrendersFocusOnKeystroke(boolean)">setSurrendersFocusOnKeystroke</A> </B>(boolean&nbsp;surrendersFocusOnKeystroke)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JTable 가 셀의 키보드 이벤트를 전송 한 결과적으로, 이 JTable 의 에디터가 키보드 포커스를 취득할지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setTableHeader(javax.swing.table.JTableHeader)">setTableHeader</A> </B>(<A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 안의 클래스">JTableHeader</A> &nbsp;tableHeader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JTable</code> 의 <code>tableHeader</code> 를 <code>newHeader</code> 로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setUI(javax.swing.plaf.TableUI)">setUI</A> </B>(<A HREF="../../javax/swing/plaf/TableUI.html" title="javax.swing.plaf 안의 클래스">TableUI</A> &nbsp;ui)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트를 draw 해 페인트 다시 하는 L&F 객체를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setUpdateSelectionOnSort(boolean)">setUpdateSelectionOnSort</A> </B>(boolean&nbsp;update)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소트 후, 선택 내용을 갱신할지 어떨지를 지정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setValueAt(java.lang.Object, int, int)">setValueAt</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;aValue,
           int&nbsp;row,
           int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블 모델내의 <code>row</code>,<code>column</code> 에 위치하는 셀의 값을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#sizeColumnsToFit(boolean)">sizeColumnsToFit</A> </B>(boolean&nbsp;lastColumnOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천 되고 있지 않습니다. </B>&nbsp;<I>Swing 1.0. 3 이후는,<code>doLayout()</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#sizeColumnsToFit(int)">sizeColumnsToFit</A> </B>(int&nbsp;resizingColumn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 2 플랫폼 v1. 4 에서는 사용하지 않습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#sorterChanged(javax.swing.event.RowSorterEvent)">sorterChanged</A> </B>(<A HREF="../../javax/swing/event/RowSorterEvent.html" title="javax.swing.event 안의 클래스">RowSorterEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RowSorter</code> 가 변경된 것을 알리는 <code>RowSorterListener</code> 통지입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#tableChanged(javax.swing.event.TableModelEvent)">tableChanged</A> </B>(<A HREF="../../javax/swing/event/TableModelEvent.html" title="javax.swing.event 안의 클래스">TableModelEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 <code>TableModel</code> 이 <code>TableModelEvent</code> 를 생성할 경우에 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#unconfigureEnclosingScrollPane()">unconfigureEnclosingScrollPane</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;포위측의 스크롤 구획의 <code>columnHeaderView</code> 를 <code>null</code> 에 옮겨놓는 것에 의해,<code>configureEnclosingScrollPane</code> 의 효과를 취소합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#updateUI()">updateUI</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&F 가 변경되었다고 하는 <code>UIManager</code> 로부터의 통지입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#valueChanged(javax.swing.event.ListSelectionEvent)">valueChanged</A> </B>(<A HREF="../../javax/swing/event/ListSelectionEvent.html" title="javax.swing.event 안의 클래스">ListSelectionEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;행의 선택 영역이 변경되었을 때에 불려 가 페인트 다시 해 새로운 선택 영역을 나타냅니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.swing.JComponent"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 javax.swing. <A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javax/swing/JComponent.html#addAncestorListener(javax.swing.event.AncestorListener)">addAncestorListener</A> , <A HREF="../../javax/swing/JComponent.html#addVetoableChangeListener(java.beans.VetoableChangeListener)">addVetoableChangeListener</A> , <A HREF="../../javax/swing/JComponent.html#computeVisibleRect(java.awt.Rectangle)">computeVisibleRect</A> , <A HREF="../../javax/swing/JComponent.html#contains(int, int)">contains</A> , <A HREF="../../javax/swing/JComponent.html#createToolTip()">createToolTip</A> , <A HREF="../../javax/swing/JComponent.html#disable()">disable</A> , <A HREF="../../javax/swing/JComponent.html#enable()">enable</A> , <A HREF="../../javax/swing/JComponent.html#firePropertyChange(java.lang.String, boolean, boolean)">firePropertyChange</A> , <A HREF="../../javax/swing/JComponent.html#firePropertyChange(java.lang.String, char, char)">firePropertyChange</A> , <A HREF="../../javax/swing/JComponent.html#firePropertyChange(java.lang.String, int, int)">firePropertyChange</A> , <A HREF="../../javax/swing/JComponent.html#fireVetoableChange(java.lang.String, java.lang.Object, java.lang.Object)">fireVetoableChange</A> , <A HREF="../../javax/swing/JComponent.html#getActionForKeyStroke(javax.swing.KeyStroke)">getActionForKeyStroke</A> , <A HREF="../../javax/swing/JComponent.html#getActionMap()">getActionMap</A> , <A HREF="../../javax/swing/JComponent.html#getAlignmentX()">getAlignmentX</A> , <A HREF="../../javax/swing/JComponent.html#getAlignmentY()">getAlignmentY</A> , <A HREF="../../javax/swing/JComponent.html#getAncestorListeners()">getAncestorListeners</A> , <A HREF="../../javax/swing/JComponent.html#getAutoscrolls()">getAutoscrolls</A> , <A HREF="../../javax/swing/JComponent.html#getBaseline(int, int)">getBaseline</A> , <A HREF="../../javax/swing/JComponent.html#getBaselineResizeBehavior()">getBaselineResizeBehavior</A> , <A HREF="../../javax/swing/JComponent.html#getBorder()">getBorder</A> , <A HREF="../../javax/swing/JComponent.html#getBounds(java.awt.Rectangle)">getBounds</A> , <A HREF="../../javax/swing/JComponent.html#getClientProperty(java.lang.Object)">getClientProperty</A> , <A HREF="../../javax/swing/JComponent.html#getComponentGraphics(java.awt.Graphics)">getComponentGraphics</A> , <A HREF="../../javax/swing/JComponent.html#getComponentPopupMenu()">getComponentPopupMenu</A> , <A HREF="../../javax/swing/JComponent.html#getConditionForKeyStroke(javax.swing.KeyStroke)">getConditionForKeyStroke</A> , <A HREF="../../javax/swing/JComponent.html#getDebugGraphicsOptions()">getDebugGraphicsOptions</A> , <A HREF="../../javax/swing/JComponent.html#getDefaultLocale()">getDefaultLocale</A> , <A HREF="../../javax/swing/JComponent.html#getFontMetrics(java.awt.Font)">getFontMetrics</A> , <A HREF="../../javax/swing/JComponent.html#getGraphics()">getGraphics</A> , <A HREF="../../javax/swing/JComponent.html#getHeight()">getHeight</A> , <A HREF="../../javax/swing/JComponent.html#getInheritsPopupMenu()">getInheritsPopupMenu</A> , <A HREF="../../javax/swing/JComponent.html#getInputMap()">getInputMap</A> , <A HREF="../../javax/swing/JComponent.html#getInputMap(int)">getInputMap</A> , <A HREF="../../javax/swing/JComponent.html#getInputVerifier()">getInputVerifier</A> , <A HREF="../../javax/swing/JComponent.html#getInsets()">getInsets</A> , <A HREF="../../javax/swing/JComponent.html#getInsets(java.awt.Insets)">getInsets</A> , <A HREF="../../javax/swing/JComponent.html#getListeners(java.lang.Class)">getListeners</A> , <A HREF="../../javax/swing/JComponent.html#getLocation(java.awt.Point)">getLocation</A> , <A HREF="../../javax/swing/JComponent.html#getMaximumSize()">getMaximumSize</A> , <A HREF="../../javax/swing/JComponent.html#getMinimumSize()">getMinimumSize</A> , <A HREF="../../javax/swing/JComponent.html#getNextFocusableComponent()">getNextFocusableComponent</A> , <A HREF="../../javax/swing/JComponent.html#getPopupLocation(java.awt.event.MouseEvent)">getPopupLocation</A> , <A HREF="../../javax/swing/JComponent.html#getPreferredSize()">getPreferredSize</A> , <A HREF="../../javax/swing/JComponent.html#getRegisteredKeyStrokes()">getRegisteredKeyStrokes</A> , <A HREF="../../javax/swing/JComponent.html#getRootPane()">getRootPane</A> , <A HREF="../../javax/swing/JComponent.html#getSize(java.awt.Dimension)">getSize</A> , <A HREF="../../javax/swing/JComponent.html#getToolTipLocation(java.awt.event.MouseEvent)">getToolTipLocation</A> , <A HREF="../../javax/swing/JComponent.html#getToolTipText()">getToolTipText</A> , <A HREF="../../javax/swing/JComponent.html#getTopLevelAncestor()">getTopLevelAncestor</A> , <A HREF="../../javax/swing/JComponent.html#getTransferHandler()">getTransferHandler</A> , <A HREF="../../javax/swing/JComponent.html#getVerifyInputWhenFocusTarget()">getVerifyInputWhenFocusTarget</A> , <A HREF="../../javax/swing/JComponent.html#getVetoableChangeListeners()">getVetoableChangeListeners</A> , <A HREF="../../javax/swing/JComponent.html#getVisibleRect()">getVisibleRect</A> , <A HREF="../../javax/swing/JComponent.html#getWidth()">getWidth</A> , <A HREF="../../javax/swing/JComponent.html#getX()">getX</A> , <A HREF="../../javax/swing/JComponent.html#getY()">getY</A> , <A HREF="../../javax/swing/JComponent.html#grabFocus()">grabFocus</A> , <A HREF="../../javax/swing/JComponent.html#isDoubleBuffered()">isDoubleBuffered</A> , <A HREF="../../javax/swing/JComponent.html#isLightweightComponent(java.awt.Component)">isLightweightComponent</A> , <A HREF="../../javax/swing/JComponent.html#isManagingFocus()">isManagingFocus</A> , <A HREF="../../javax/swing/JComponent.html#isOpaque()">isOpaque</A> , <A HREF="../../javax/swing/JComponent.html#isOptimizedDrawingEnabled()">isOptimizedDrawingEnabled</A> , <A HREF="../../javax/swing/JComponent.html#isPaintingForPrint()">isPaintingForPrint</A> , <A HREF="../../javax/swing/JComponent.html#isPaintingTile()">isPaintingTile</A> , <A HREF="../../javax/swing/JComponent.html#isRequestFocusEnabled()">isRequestFocusEnabled</A> , <A HREF="../../javax/swing/JComponent.html#isValidateRoot()">isValidateRoot</A> , <A HREF="../../javax/swing/JComponent.html#paint(java.awt.Graphics)">paint</A> , <A HREF="../../javax/swing/JComponent.html#paintBorder(java.awt.Graphics)">paintBorder</A> , <A HREF="../../javax/swing/JComponent.html#paintChildren(java.awt.Graphics)">paintChildren</A> , <A HREF="../../javax/swing/JComponent.html#paintComponent(java.awt.Graphics)">paintComponent</A> , <A HREF="../../javax/swing/JComponent.html#paintImmediately(int, int, int, int)">paintImmediately</A> , <A HREF="../../javax/swing/JComponent.html#paintImmediately(java.awt.Rectangle)">paintImmediately</A> , <A HREF="../../javax/swing/JComponent.html#print(java.awt.Graphics)">print</A> , <A HREF="../../javax/swing/JComponent.html#printAll(java.awt.Graphics)">printAll</A> , <A HREF="../../javax/swing/JComponent.html#printBorder(java.awt.Graphics)">printBorder</A> , <A HREF="../../javax/swing/JComponent.html#printChildren(java.awt.Graphics)">printChildren</A> , <A HREF="../../javax/swing/JComponent.html#printComponent(java.awt.Graphics)">printComponent</A> , <A HREF="../../javax/swing/JComponent.html#processComponentKeyEvent(java.awt.event.KeyEvent)">processComponentKeyEvent</A> , <A HREF="../../javax/swing/JComponent.html#processKeyEvent(java.awt.event.KeyEvent)">processKeyEvent</A> , <A HREF="../../javax/swing/JComponent.html#processMouseEvent(java.awt.event.MouseEvent)">processMouseEvent</A> , <A HREF="../../javax/swing/JComponent.html#processMouseMotionEvent(java.awt.event.MouseEvent)">processMouseMotionEvent</A> , <A HREF="../../javax/swing/JComponent.html#putClientProperty(java.lang.Object, java.lang.Object)">putClientProperty</A> , <A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, javax.swing.KeyStroke, int)">registerKeyboardAction</A> , <A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)">registerKeyboardAction</A> , <A HREF="../../javax/swing/JComponent.html#removeAncestorListener(javax.swing.event.AncestorListener)">removeAncestorListener</A> , <A HREF="../../javax/swing/JComponent.html#removeVetoableChangeListener(java.beans.VetoableChangeListener)">removeVetoableChangeListener</A> , <A HREF="../../javax/swing/JComponent.html#repaint(long, int, int, int, int)">repaint</A> , <A HREF="../../javax/swing/JComponent.html#repaint(java.awt.Rectangle)">repaint</A> , <A HREF="../../javax/swing/JComponent.html#requestDefaultFocus()">requestDefaultFocus</A> , <A HREF="../../javax/swing/JComponent.html#requestFocus()">requestFocus</A> , <A HREF="../../javax/swing/JComponent.html#requestFocus(boolean)">requestFocus</A> , <A HREF="../../javax/swing/JComponent.html#requestFocusInWindow()">requestFocusInWindow</A> , <A HREF="../../javax/swing/JComponent.html#requestFocusInWindow(boolean)">requestFocusInWindow</A> , <A HREF="../../javax/swing/JComponent.html#resetKeyboardActions()">resetKeyboardActions</A> , <A HREF="../../javax/swing/JComponent.html#reshape(int, int, int, int)">reshape</A> , <A HREF="../../javax/swing/JComponent.html#revalidate()">revalidate</A> , <A HREF="../../javax/swing/JComponent.html#scrollRectToVisible(java.awt.Rectangle)">scrollRectToVisible</A> , <A HREF="../../javax/swing/JComponent.html#setActionMap(javax.swing.ActionMap)">setActionMap</A> , <A HREF="../../javax/swing/JComponent.html#setAlignmentX(float)">setAlignmentX</A> , <A HREF="../../javax/swing/JComponent.html#setAlignmentY(float)">setAlignmentY</A> , <A HREF="../../javax/swing/JComponent.html#setAutoscrolls(boolean)">setAutoscrolls</A> , <A HREF="../../javax/swing/JComponent.html#setBackground(java.awt.Color)">setBackground</A> , <A HREF="../../javax/swing/JComponent.html#setBorder(javax.swing.border.Border)">setBorder</A> , <A HREF="../../javax/swing/JComponent.html#setComponentPopupMenu(javax.swing.JPopupMenu)">setComponentPopupMenu</A> , <A HREF="../../javax/swing/JComponent.html#setDebugGraphicsOptions(int)">setDebugGraphicsOptions</A> , <A HREF="../../javax/swing/JComponent.html#setDefaultLocale(java.util.Locale)">setDefaultLocale</A> , <A HREF="../../javax/swing/JComponent.html#setDoubleBuffered(boolean)">setDoubleBuffered</A> , <A HREF="../../javax/swing/JComponent.html#setEnabled(boolean)">setEnabled</A> , <A HREF="../../javax/swing/JComponent.html#setFocusTraversalKeys(int, java.util.Set)">setFocusTraversalKeys</A> , <A HREF="../../javax/swing/JComponent.html#setFont(java.awt.Font)">setFont</A> , <A HREF="../../javax/swing/JComponent.html#setForeground(java.awt.Color)">setForeground</A> , <A HREF="../../javax/swing/JComponent.html#setInheritsPopupMenu(boolean)">setInheritsPopupMenu</A> , <A HREF="../../javax/swing/JComponent.html#setInputMap(int, javax.swing.InputMap)">setInputMap</A> , <A HREF="../../javax/swing/JComponent.html#setInputVerifier(javax.swing.InputVerifier)">setInputVerifier</A> , <A HREF="../../javax/swing/JComponent.html#setMaximumSize(java.awt.Dimension)">setMaximumSize</A> , <A HREF="../../javax/swing/JComponent.html#setMinimumSize(java.awt.Dimension)">setMinimumSize</A> , <A HREF="../../javax/swing/JComponent.html#setNextFocusableComponent(java.awt.Component)">setNextFocusableComponent</A> , <A HREF="../../javax/swing/JComponent.html#setOpaque(boolean)">setOpaque</A> , <A HREF="../../javax/swing/JComponent.html#setPreferredSize(java.awt.Dimension)">setPreferredSize</A> , <A HREF="../../javax/swing/JComponent.html#setRequestFocusEnabled(boolean)">setRequestFocusEnabled</A> , <A HREF="../../javax/swing/JComponent.html#setToolTipText(java.lang.String)">setToolTipText</A> , <A HREF="../../javax/swing/JComponent.html#setTransferHandler(javax.swing.TransferHandler)">setTransferHandler</A> , <A HREF="../../javax/swing/JComponent.html#setUI(javax.swing.plaf.ComponentUI)">setUI</A> , <A HREF="../../javax/swing/JComponent.html#setVerifyInputWhenFocusTarget(boolean)">setVerifyInputWhenFocusTarget</A> , <A HREF="../../javax/swing/JComponent.html#setVisible(boolean)">setVisible</A> , <A HREF="../../javax/swing/JComponent.html#unregisterKeyboardAction(javax.swing.KeyStroke)">unregisterKeyboardAction</A> , <A HREF="../../javax/swing/JComponent.html#update(java.awt.Graphics)">update</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Container"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Container.html" title="java.awt 안의 클래스">Container</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Container.html#add(java.awt.Component)">add</A> , <A HREF="../../java/awt/Container.html#add(java.awt.Component, int)">add</A> , <A HREF="../../java/awt/Container.html#add(java.awt.Component, java.lang.Object)">add</A> , <A HREF="../../java/awt/Container.html#add(java.awt.Component, java.lang.Object, int)">add</A> , <A HREF="../../java/awt/Container.html#add(java.lang.String, java.awt.Component)">add</A> , <A HREF="../../java/awt/Container.html#addContainerListener(java.awt.event.ContainerListener)">addContainerListener</A> , <A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)">addImpl</A> , <A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.beans.PropertyChangeListener)">addPropertyChangeListener</A> , <A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">addPropertyChangeListener</A> , <A HREF="../../java/awt/Container.html#applyComponentOrientation(java.awt.ComponentOrientation)">applyComponentOrientation</A> , <A HREF="../../java/awt/Container.html#areFocusTraversalKeysSet(int)">areFocusTraversalKeysSet</A> , <A HREF="../../java/awt/Container.html#countComponents()">countComponents</A> , <A HREF="../../java/awt/Container.html#deliverEvent(java.awt.Event)">deliverEvent</A> , <A HREF="../../java/awt/Container.html#findComponentAt(int, int)">findComponentAt</A> , <A HREF="../../java/awt/Container.html#findComponentAt(java.awt.Point)">findComponentAt</A> , <A HREF="../../java/awt/Container.html#getComponent(int)">getComponent</A> , <A HREF="../../java/awt/Container.html#getComponentAt(int, int)">getComponentAt</A> , <A HREF="../../java/awt/Container.html#getComponentAt(java.awt.Point)">getComponentAt</A> , <A HREF="../../java/awt/Container.html#getComponentCount()">getComponentCount</A> , <A HREF="../../java/awt/Container.html#getComponents()">getComponents</A> , <A HREF="../../java/awt/Container.html#getComponentZOrder(java.awt.Component)">getComponentZOrder</A> , <A HREF="../../java/awt/Container.html#getContainerListeners()">getContainerListeners</A> , <A HREF="../../java/awt/Container.html#getFocusTraversalKeys(int)">getFocusTraversalKeys</A> , <A HREF="../../java/awt/Container.html#getFocusTraversalPolicy()">getFocusTraversalPolicy</A> , <A HREF="../../java/awt/Container.html#getLayout()">getLayout</A> , <A HREF="../../java/awt/Container.html#getMousePosition(boolean)">getMousePosition</A> , <A HREF="../../java/awt/Container.html#insets()">insets</A> , <A HREF="../../java/awt/Container.html#invalidate()">invalidate</A> , <A HREF="../../java/awt/Container.html#isAncestorOf(java.awt.Component)">isAncestorOf</A> , <A HREF="../../java/awt/Container.html#isFocusCycleRoot()">isFocusCycleRoot</A> , <A HREF="../../java/awt/Container.html#isFocusCycleRoot(java.awt.Container)">isFocusCycleRoot</A> , <A HREF="../../java/awt/Container.html#isFocusTraversalPolicyProvider()">isFocusTraversalPolicyProvider</A> , <A HREF="../../java/awt/Container.html#isFocusTraversalPolicySet()">isFocusTraversalPolicySet</A> , <A HREF="../../java/awt/Container.html#layout()">layout</A> , <A HREF="../../java/awt/Container.html#list(java.io.PrintStream, int)">list</A> , <A HREF="../../java/awt/Container.html#list(java.io.PrintWriter, int)">list</A> , <A HREF="../../java/awt/Container.html#locate(int, int)">locate</A> , <A HREF="../../java/awt/Container.html#minimumSize()">minimumSize</A> , <A HREF="../../java/awt/Container.html#paintComponents(java.awt.Graphics)">paintComponents</A> , <A HREF="../../java/awt/Container.html#preferredSize()">preferredSize</A> , <A HREF="../../java/awt/Container.html#printComponents(java.awt.Graphics)">printComponents</A> , <A HREF="../../java/awt/Container.html#processContainerEvent(java.awt.event.ContainerEvent)">processContainerEvent</A> , <A HREF="../../java/awt/Container.html#processEvent(java.awt.AWTEvent)">processEvent</A> , <A HREF="../../java/awt/Container.html#remove(java.awt.Component)">remove</A> , <A HREF="../../java/awt/Container.html#remove(int)">remove</A> , <A HREF="../../java/awt/Container.html#removeAll()">removeAll</A> , <A HREF="../../java/awt/Container.html#removeContainerListener(java.awt.event.ContainerListener)">removeContainerListener</A> , <A HREF="../../java/awt/Container.html#setComponentZOrder(java.awt.Component, int)">setComponentZOrder</A> , <A HREF="../../java/awt/Container.html#setFocusCycleRoot(boolean)">setFocusCycleRoot</A> , <A HREF="../../java/awt/Container.html#setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)">setFocusTraversalPolicy</A> , <A HREF="../../java/awt/Container.html#setFocusTraversalPolicyProvider(boolean)">setFocusTraversalPolicyProvider</A> , <A HREF="../../java/awt/Container.html#setLayout(java.awt.LayoutManager)">setLayout</A> , <A HREF="../../java/awt/Container.html#transferFocusBackward()">transferFocusBackward</A> , <A HREF="../../java/awt/Container.html#transferFocusDownCycle()">transferFocusDownCycle</A> , <A HREF="../../java/awt/Container.html#validate()">validate</A> , <A HREF="../../java/awt/Container.html#validateTree()">validateTree</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Component"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.html#action(java.awt.Event, java.lang.Object)">action</A> , <A HREF="../../java/awt/Component.html#add(java.awt.PopupMenu)">add</A> , <A HREF="../../java/awt/Component.html#addComponentListener(java.awt.event.ComponentListener)">addComponentListener</A> , <A HREF="../../java/awt/Component.html#addFocusListener(java.awt.event.FocusListener)">addFocusListener</A> , <A HREF="../../java/awt/Component.html#addHierarchyBoundsListener(java.awt.event.HierarchyBoundsListener)">addHierarchyBoundsListener</A> , <A HREF="../../java/awt/Component.html#addHierarchyListener(java.awt.event.HierarchyListener)">addHierarchyListener</A> , <A HREF="../../java/awt/Component.html#addInputMethodListener(java.awt.event.InputMethodListener)">addInputMethodListener</A> , <A HREF="../../java/awt/Component.html#addKeyListener(java.awt.event.KeyListener)">addKeyListener</A> , <A HREF="../../java/awt/Component.html#addMouseListener(java.awt.event.MouseListener)">addMouseListener</A> , <A HREF="../../java/awt/Component.html#addMouseMotionListener(java.awt.event.MouseMotionListener)">addMouseMotionListener</A> , <A HREF="../../java/awt/Component.html#addMouseWheelListener(java.awt.event.MouseWheelListener)">addMouseWheelListener</A> , <A HREF="../../java/awt/Component.html#bounds()">bounds</A> , <A HREF="../../java/awt/Component.html#checkImage(java.awt.Image, java.awt.image.ImageObserver)">checkImage</A> , <A HREF="../../java/awt/Component.html#checkImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">checkImage</A> , <A HREF="../../java/awt/Component.html#coalesceEvents(java.awt.AWTEvent, java.awt.AWTEvent)">coalesceEvents</A> , <A HREF="../../java/awt/Component.html#contains(java.awt.Point)">contains</A> , <A HREF="../../java/awt/Component.html#createImage(java.awt.image.ImageProducer)">createImage</A> , <A HREF="../../java/awt/Component.html#createImage(int, int)">createImage</A> , <A HREF="../../java/awt/Component.html#createVolatileImage(int, int)">createVolatileImage</A> , <A HREF="../../java/awt/Component.html#createVolatileImage(int, int, java.awt.ImageCapabilities)">createVolatileImage</A> , <A HREF="../../java/awt/Component.html#disableEvents(long)">disableEvents</A> , <A HREF="../../java/awt/Component.html#dispatchEvent(java.awt.AWTEvent)">dispatchEvent</A> , <A HREF="../../java/awt/Component.html#enable(boolean)">enable</A> , <A HREF="../../java/awt/Component.html#enableEvents(long)">enableEvents</A> , <A HREF="../../java/awt/Component.html#enableInputMethods(boolean)">enableInputMethods</A> , <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, byte, byte)">firePropertyChange</A> , <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, double, double)">firePropertyChange</A> , <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, float, float)">firePropertyChange</A> , <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, long, long)">firePropertyChange</A> , <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, java.lang.Object, java.lang.Object)">firePropertyChange</A> , <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, short, short)">firePropertyChange</A> , <A HREF="../../java/awt/Component.html#getBackground()">getBackground</A> , <A HREF="../../java/awt/Component.html#getBounds()">getBounds</A> , <A HREF="../../java/awt/Component.html#getColorModel()">getColorModel</A> , <A HREF="../../java/awt/Component.html#getComponentListeners()">getComponentListeners</A> , <A HREF="../../java/awt/Component.html#getComponentOrientation()">getComponentOrientation</A> , <A HREF="../../java/awt/Component.html#getCursor()">getCursor</A> , <A HREF="../../java/awt/Component.html#getDropTarget()">getDropTarget</A> , <A HREF="../../java/awt/Component.html#getFocusCycleRootAncestor()">getFocusCycleRootAncestor</A> , <A HREF="../../java/awt/Component.html#getFocusListeners()">getFocusListeners</A> , <A HREF="../../java/awt/Component.html#getFocusTraversalKeysEnabled()">getFocusTraversalKeysEnabled</A> , <A HREF="../../java/awt/Component.html#getFont()">getFont</A> , <A HREF="../../java/awt/Component.html#getForeground()">getForeground</A> , <A HREF="../../java/awt/Component.html#getGraphicsConfiguration()">getGraphicsConfiguration</A> , <A HREF="../../java/awt/Component.html#getHierarchyBoundsListeners()">getHierarchyBoundsListeners</A> , <A HREF="../../java/awt/Component.html#getHierarchyListeners()">getHierarchyListeners</A> , <A HREF="../../java/awt/Component.html#getIgnoreRepaint()">getIgnoreRepaint</A> , <A HREF="../../java/awt/Component.html#getInputContext()">getInputContext</A> , <A HREF="../../java/awt/Component.html#getInputMethodListeners()">getInputMethodListeners</A> , <A HREF="../../java/awt/Component.html#getInputMethodRequests()">getInputMethodRequests</A> , <A HREF="../../java/awt/Component.html#getKeyListeners()">getKeyListeners</A> , <A HREF="../../java/awt/Component.html#getLocale()">getLocale</A> , <A HREF="../../java/awt/Component.html#getLocation()">getLocation</A> , <A HREF="../../java/awt/Component.html#getLocationOnScreen()">getLocationOnScreen</A> , <A HREF="../../java/awt/Component.html#getMouseListeners()">getMouseListeners</A> , <A HREF="../../java/awt/Component.html#getMouseMotionListeners()">getMouseMotionListeners</A> , <A HREF="../../java/awt/Component.html#getMousePosition()">getMousePosition</A> , <A HREF="../../java/awt/Component.html#getMouseWheelListeners()">getMouseWheelListeners</A> , <A HREF="../../java/awt/Component.html#getName()">getName</A> , <A HREF="../../java/awt/Component.html#getParent()">getParent</A> , <A HREF="../../java/awt/Component.html#getPeer()">getPeer</A> , <A HREF="../../java/awt/Component.html#getPropertyChangeListeners()">getPropertyChangeListeners</A> , <A HREF="../../java/awt/Component.html#getPropertyChangeListeners(java.lang.String)">getPropertyChangeListeners</A> , <A HREF="../../java/awt/Component.html#getSize()">getSize</A> , <A HREF="../../java/awt/Component.html#getToolkit()">getToolkit</A> , <A HREF="../../java/awt/Component.html#getTreeLock()">getTreeLock</A> , <A HREF="../../java/awt/Component.html#gotFocus(java.awt.Event, java.lang.Object)">gotFocus</A> , <A HREF="../../java/awt/Component.html#handleEvent(java.awt.Event)">handleEvent</A> , <A HREF="../../java/awt/Component.html#hasFocus()">hasFocus</A> , <A HREF="../../java/awt/Component.html#hide()">hide</A> , <A HREF="../../java/awt/Component.html#imageUpdate(java.awt.Image, int, int, int, int, int)">imageUpdate</A> , <A HREF="../../java/awt/Component.html#inside(int, int)">inside</A> , <A HREF="../../java/awt/Component.html#isBackgroundSet()">isBackgroundSet</A> , <A HREF="../../java/awt/Component.html#isCursorSet()">isCursorSet</A> , <A HREF="../../java/awt/Component.html#isDisplayable()">isDisplayable</A> , <A HREF="../../java/awt/Component.html#isEnabled()">isEnabled</A> , <A HREF="../../java/awt/Component.html#isFocusable()">isFocusable</A> , <A HREF="../../java/awt/Component.html#isFocusOwner()">isFocusOwner</A> , <A HREF="../../java/awt/Component.html#isFocusTraversable()">isFocusTraversable</A> , <A HREF="../../java/awt/Component.html#isFontSet()">isFontSet</A> , <A HREF="../../java/awt/Component.html#isForegroundSet()">isForegroundSet</A> , <A HREF="../../java/awt/Component.html#isLightweight()">isLightweight</A> , <A HREF="../../java/awt/Component.html#isMaximumSizeSet()">isMaximumSizeSet</A> , <A HREF="../../java/awt/Component.html#isMinimumSizeSet()">isMinimumSizeSet</A> , <A HREF="../../java/awt/Component.html#isPreferredSizeSet()">isPreferredSizeSet</A> , <A HREF="../../java/awt/Component.html#isShowing()">isShowing</A> , <A HREF="../../java/awt/Component.html#isValid()">isValid</A> , <A HREF="../../java/awt/Component.html#isVisible()">isVisible</A> , <A HREF="../../java/awt/Component.html#keyDown(java.awt.Event, int)">keyDown</A> , <A HREF="../../java/awt/Component.html#keyUp(java.awt.Event, int)">keyUp</A> , <A HREF="../../java/awt/Component.html#list()">list</A> , <A HREF="../../java/awt/Component.html#list(java.io.PrintStream)">list</A> , <A HREF="../../java/awt/Component.html#list(java.io.PrintWriter)">list</A> , <A HREF="../../java/awt/Component.html#location()">location</A> , <A HREF="../../java/awt/Component.html#lostFocus(java.awt.Event, java.lang.Object)">lostFocus</A> , <A HREF="../../java/awt/Component.html#mouseDown(java.awt.Event, int, int)">mouseDown</A> , <A HREF="../../java/awt/Component.html#mouseDrag(java.awt.Event, int, int)">mouseDrag</A> , <A HREF="../../java/awt/Component.html#mouseEnter(java.awt.Event, int, int)">mouseEnter</A> , <A HREF="../../java/awt/Component.html#mouseExit(java.awt.Event, int, int)">mouseExit</A> , <A HREF="../../java/awt/Component.html#mouseMove(java.awt.Event, int, int)">mouseMove</A> , <A HREF="../../java/awt/Component.html#mouseUp(java.awt.Event, int, int)">mouseUp</A> , <A HREF="../../java/awt/Component.html#move(int, int)">move</A> , <A HREF="../../java/awt/Component.html#nextFocus()">nextFocus</A> , <A HREF="../../java/awt/Component.html#paintAll(java.awt.Graphics)">paintAll</A> , <A HREF="../../java/awt/Component.html#postEvent(java.awt.Event)">postEvent</A> , <A HREF="../../java/awt/Component.html#prepareImage(java.awt.Image, java.awt.image.ImageObserver)">prepareImage</A> , <A HREF="../../java/awt/Component.html#prepareImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">prepareImage</A> , <A HREF="../../java/awt/Component.html#processComponentEvent(java.awt.event.ComponentEvent)">processComponentEvent</A> , <A HREF="../../java/awt/Component.html#processFocusEvent(java.awt.event.FocusEvent)">processFocusEvent</A> , <A HREF="../../java/awt/Component.html#processHierarchyBoundsEvent(java.awt.event.HierarchyEvent)">processHierarchyBoundsEvent</A> , <A HREF="../../java/awt/Component.html#processHierarchyEvent(java.awt.event.HierarchyEvent)">processHierarchyEvent</A> , <A HREF="../../java/awt/Component.html#processInputMethodEvent(java.awt.event.InputMethodEvent)">processInputMethodEvent</A> , <A HREF="../../java/awt/Component.html#processMouseWheelEvent(java.awt.event.MouseWheelEvent)">processMouseWheelEvent</A> , <A HREF="../../java/awt/Component.html#remove(java.awt.MenuComponent)">remove</A> , <A HREF="../../java/awt/Component.html#removeComponentListener(java.awt.event.ComponentListener)">removeComponentListener</A> , <A HREF="../../java/awt/Component.html#removeFocusListener(java.awt.event.FocusListener)">removeFocusListener</A> , <A HREF="../../java/awt/Component.html#removeHierarchyBoundsListener(java.awt.event.HierarchyBoundsListener)">removeHierarchyBoundsListener</A> , <A HREF="../../java/awt/Component.html#removeHierarchyListener(java.awt.event.HierarchyListener)">removeHierarchyListener</A> , <A HREF="../../java/awt/Component.html#removeInputMethodListener(java.awt.event.InputMethodListener)">removeInputMethodListener</A> , <A HREF="../../java/awt/Component.html#removeKeyListener(java.awt.event.KeyListener)">removeKeyListener</A> , <A HREF="../../java/awt/Component.html#removeMouseListener(java.awt.event.MouseListener)">removeMouseListener</A> , <A HREF="../../java/awt/Component.html#removeMouseMotionListener(java.awt.event.MouseMotionListener)">removeMouseMotionListener</A> , <A HREF="../../java/awt/Component.html#removeMouseWheelListener(java.awt.event.MouseWheelListener)">removeMouseWheelListener</A> , <A HREF="../../java/awt/Component.html#removePropertyChangeListener(java.beans.PropertyChangeListener)">removePropertyChangeListener</A> , <A HREF="../../java/awt/Component.html#removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">removePropertyChangeListener</A> , <A HREF="../../java/awt/Component.html#repaint()">repaint</A> , <A HREF="../../java/awt/Component.html#repaint(int, int, int, int)">repaint</A> , <A HREF="../../java/awt/Component.html#repaint(long)">repaint</A> , <A HREF="../../java/awt/Component.html#resize(java.awt.Dimension)">resize</A> , <A HREF="../../java/awt/Component.html#resize(int, int)">resize</A> , <A HREF="../../java/awt/Component.html#setBounds(int, int, int, int)">setBounds</A> , <A HREF="../../java/awt/Component.html#setBounds(java.awt.Rectangle)">setBounds</A> , <A HREF="../../java/awt/Component.html#setComponentOrientation(java.awt.ComponentOrientation)">setComponentOrientation</A> , <A HREF="../../java/awt/Component.html#setCursor(java.awt.Cursor)">setCursor</A> , <A HREF="../../java/awt/Component.html#setDropTarget(java.awt.dnd.DropTarget)">setDropTarget</A> , <A HREF="../../java/awt/Component.html#setFocusable(boolean)">setFocusable</A> , <A HREF="../../java/awt/Component.html#setFocusTraversalKeysEnabled(boolean)">setFocusTraversalKeysEnabled</A> , <A HREF="../../java/awt/Component.html#setIgnoreRepaint(boolean)">setIgnoreRepaint</A> , <A HREF="../../java/awt/Component.html#setLocale(java.util.Locale)">setLocale</A> , <A HREF="../../java/awt/Component.html#setLocation(int, int)">setLocation</A> , <A HREF="../../java/awt/Component.html#setLocation(java.awt.Point)">setLocation</A> , <A HREF="../../java/awt/Component.html#setName(java.lang.String)">setName</A> , <A HREF="../../java/awt/Component.html#setSize(java.awt.Dimension)">setSize</A> , <A HREF="../../java/awt/Component.html#setSize(int, int)">setSize</A> , <A HREF="../../java/awt/Component.html#show()">show</A> , <A HREF="../../java/awt/Component.html#show(boolean)">show</A> , <A HREF="../../java/awt/Component.html#size()">size</A> , <A HREF="../../java/awt/Component.html#toString()">toString</A> , <A HREF="../../java/awt/Component.html#transferFocus()">transferFocus</A> , <A HREF="../../java/awt/Component.html#transferFocusUpCycle()">transferFocusUpCycle</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메소드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> , <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> , <A HREF="../../java/lang/Object.html#finalize()">finalize</A> , <A HREF="../../java/lang/Object.html#getClass()">getClass</A> , <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> , <A HREF="../../java/lang/Object.html#notify()">notify</A> , <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> , <A HREF="../../java/lang/Object.html#wait()">wait</A> , <A HREF="../../java/lang/Object.html#wait(long)">wait</A> , <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<script type="text/javascript"><!--
google_ad_client = "pub-9323474092375073";
/* 728x90, j2se api document */
google_ad_slot = "6530291297";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script><!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AUTO_RESIZE_OFF"><!-- --></A> <H3>
AUTO_RESIZE_OFF</H3>
<PRE>
public static final int <B>AUTO_RESIZE_OFF</B></PRE>
<DL>
<DD>렬폭의 조정은 자동적으로 실시하지 않고 , 스크롤 바를 사용합니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JTable.AUTO_RESIZE_OFF">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="AUTO_RESIZE_NEXT_COLUMN"><!-- --></A> <H3>
AUTO_RESIZE_NEXT_COLUMN</H3>
<PRE>
public static final int <B>AUTO_RESIZE_NEXT_COLUMN</B></PRE>
<DL>
<DD>열을 UI 로 조정할 때는, 다음의 열을 역방향으로 조정합니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JTable.AUTO_RESIZE_NEXT_COLUMN">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="AUTO_RESIZE_SUBSEQUENT_COLUMNS"><!-- --></A> <H3>
AUTO_RESIZE_SUBSEQUENT_COLUMNS</H3>
<PRE>
public static final int <B>AUTO_RESIZE_SUBSEQUENT_COLUMNS</B></PRE>
<DL>
<DD>UI 를 조정할 때는, 그 이후의 열을 변경해 열의 합계폭을 유지합니다. 이것은 디폴트의 동작입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="AUTO_RESIZE_LAST_COLUMN"><!-- --></A> <H3>
AUTO_RESIZE_LAST_COLUMN</H3>
<PRE>
public static final int <B>AUTO_RESIZE_LAST_COLUMN</B></PRE>
<DL>
<DD>모든 사이즈 변경 조작으로, 최종열인 만큼 조정을 적용합니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JTable.AUTO_RESIZE_LAST_COLUMN">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="AUTO_RESIZE_ALL_COLUMNS"><!-- --></A> <H3>
AUTO_RESIZE_ALL_COLUMNS</H3>
<PRE>
public static final int <B>AUTO_RESIZE_ALL_COLUMNS</B></PRE>
<DL>
<DD>모든 사이즈 변경 조작으로, 각 열을 균등하게 사이즈 변경합니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="dataModel"><!-- --></A> <H3>
dataModel</H3>
<PRE>
protected <A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A>  <B>dataModel</B></PRE>
<DL>
<DD>테이블의 <code>TableModel</code> 입니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="columnModel"><!-- --></A> <H3>
columnModel</H3>
<PRE>
protected <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 내의 인터페이스">TableColumnModel</A>  <B>columnModel</B></PRE>
<DL>
<DD>테이블의 <code>TableColumnModel</code> 입니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="selectionModel"><!-- --></A> <H3>
selectionModel</H3>
<PRE>
protected <A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스">ListSelectionModel</A>  <B>selectionModel</B></PRE>
<DL>
<DD>행 선택을 추적하는데 사용하는, 테이블의 <code>ListSelectionModel</code> 입니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="tableHeader"><!-- --></A> <H3>
tableHeader</H3>
<PRE>
protected <A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스">JTableHeader</A>  <B>tableHeader</B></PRE>
<DL>
<DD>테이블의 <code>TableHeader</code> 입니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="rowHeight"><!-- --></A> <H3>
rowHeight</H3>
<PRE>
protected int <B>rowHeight</B></PRE>
<DL>
<DD>테이블의 각 행의 높이를 픽셀로 나타낸 것입니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="rowMargin"><!-- --></A> <H3>
rowMargin</H3>
<PRE>
protected int <B>rowMargin</B></PRE>
<DL>
<DD>각 행의 셀간의 마진의 높이를 픽셀로 나타낸 것입니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="gridColor"><!-- --></A> <H3>
gridColor</H3>
<PRE>
protected <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>gridColor</B></PRE>
<DL>
<DD>구라두의 색입니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="showHorizontalLines"><!-- --></A> <H3>
showHorizontalLines</H3>
<PRE>
protected boolean <B>showHorizontalLines</B></PRE>
<DL>
<DD><code>showHorizontalLines</code> 가 true 의 경우, 테이블은 셀간에 수평선을 draw 합니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="showVerticalLines"><!-- --></A> <H3>
showVerticalLines</H3>
<PRE>
protected boolean <B>showVerticalLines</B></PRE>
<DL>
<DD><code>showVerticalLines</code> 가 true 의 경우, 테이블은 셀간에 수직선을 draw 합니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="autoResizeMode"><!-- --></A> <H3>
autoResizeMode</H3>
<PRE>
protected int <B>autoResizeMode</B></PRE>
<DL>
<DD>테이블이 폭의 사이즈를 자동 변경해 각 열로 테이블폭전체를 차지하도록(듯이) 할지 어떨지를 지정해, 그 사이즈 변경의 방법을 지정합니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="autoCreateColumnsFromModel"><!-- --></A> <H3>
autoCreateColumnsFromModel</H3>
<PRE>
protected boolean <B>autoCreateColumnsFromModel</B></PRE>
<DL>
<DD>true 의 경우, 열의 디폴트 세트를 구축하도록(듯이) <code>TableModel</code> 에 조회합니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="preferredViewportSize"><!-- --></A> <H3>
preferredViewportSize</H3>
<PRE>
protected <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>preferredViewportSize</B></PRE>
<DL>
<DD><code>Scrollable</code> 인터페이스에 의해 사용되어 가시 영역의 초기설정을 실시합니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="rowSelectionAllowed"><!-- --></A> <H3>
rowSelectionAllowed</H3>
<PRE>
protected boolean <B>rowSelectionAllowed</B></PRE>
<DL>
<DD>이 테이블로 행 선택이 허가되고 있는 경우, true 입니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="cellSelectionEnabled"><!-- --></A> <H3>
cellSelectionEnabled</H3>
<PRE>
protected boolean <B>cellSelectionEnabled</B></PRE>
<DL>
<DD>Java 2 플랫폼 v1. 3 에서는 사용하지 않습니다.  대신에 <code>columnModel</code> 의 <code>rowSelectionAllowed</code> 프로퍼티 및 <code>columnSelectionAllowed</code> 프로퍼티을 사용해 주세요. 혹은 <code>getCellSelectionEnabled</code> 메소드를 사용해 주세요.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="editorComp"><!-- --></A> <H3>
editorComp</H3>
<PRE>
protected transient <A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A>  <B>editorComp</B></PRE>
<DL>
<DD>편집시이면, 편집을 처리하고 있는 <code>Component</code> 입니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="cellEditor"><!-- --></A> <H3>
cellEditor</H3>
<PRE>
protected transient <A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A>  <B>cellEditor</B></PRE>
<DL>
<DD>현재의 셀이 차지하는 화면상의 장소를 덧쓰기해, 사용자가 그 내용을 변경할 수 있도록(듯이) 하는 액티브한 셀 에디터 객체입니다. 테이블이 현재 편집중이 아닌 경우는 <code>null</code> 가 됩니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="editingColumn"><!-- --></A> <H3>
editingColumn</H3>
<PRE>
protected transient int <B>editingColumn</B></PRE>
<DL>
<DD>편집중의 셀의 열을 식별합니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="editingRow"><!-- --></A> <H3>
editingRow</H3>
<PRE>
protected transient int <B>editingRow</B></PRE>
<DL>
<DD>편집중의 셀의 행을 식별합니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="defaultRenderersByColumnClass"><!-- --></A> <H3>
defaultRenderersByColumnClass</H3>
<PRE>
protected transient <A HREF="../../java/util/Hashtable.html" title="java.util 내의 클래스">Hashtable</A>  <B>defaultRenderersByColumnClass</B></PRE>
<DL>
<DD>셀의 내용을 표시하는 객체의 테이블입니다. <code>TableModel</code> 인터페이스의 <code>getColumnClass</code> 로 선언된 클래스에 의한 인덱스가 붙어 있습니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="defaultEditorsByColumnClass"><!-- --></A> <H3>
defaultEditorsByColumnClass</H3>
<PRE>
protected transient <A HREF="../../java/util/Hashtable.html" title="java.util 내의 클래스">Hashtable</A>  <B>defaultEditorsByColumnClass</B></PRE>
<DL>
<DD>셀의 내용을 표시 및 편집하는 객체의 테이블입니다. <code>TableModel</code> 인터페이스의 <code>getColumnClass</code> 로 선언된 클래스에 의한 인덱스가 붙어 있습니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="selectionForeground"><!-- --></A> <H3>
selectionForeground</H3>
<PRE>
protected <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>selectionForeground</B></PRE>
<DL>
<DD>선택된 셀의 foreground 칼라
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="selectionBackground"><!-- --></A> <H3>
selectionBackground</H3>
<PRE>
protected <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>selectionBackground</B></PRE>
<DL>
<DD>선택된 셀의 백그라운드 칼라
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="JTable()"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>()</PRE>
<DL>
<DD>디폴트 데이터 모델, 디폴트열모델, 및 디폴트 선택 모델로 초기화되는, 디폴트의 <code>JTable</code> 를 구축합니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#createDefaultDataModel()"><CODE>createDefaultDataModel()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#createDefaultColumnModel()"><CODE>createDefaultColumnModel()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#createDefaultSelectionModel()"><CODE>createDefaultSelectionModel()</CODE></A> </DL>
</DL>
<HR>

<A NAME="JTable(javax.swing.table.TableModel)"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dm)</PRE>
<DL>
<DD>데이터 모델 <code>dm</code>, 디폴트열모델, 및 디폴트 선택 모델로 초기화되는 <code>JTable</code> 를 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>dm</CODE> - 테이블의 데이터 모델<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#createDefaultColumnModel()"><CODE>createDefaultColumnModel()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#createDefaultSelectionModel()"><CODE>createDefaultSelectionModel()</CODE></A> </DL>
</DL>
<HR>

<A NAME="JTable(javax.swing.table.TableModel, javax.swing.table.TableColumnModel)"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dm,
              <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 안의 인터페이스">TableColumnModel</A> &nbsp;cm)</PRE>
<DL>
<DD>데이터 모델 <code>dm</code>, 열모델 <code>cm</code>, 및 디폴트 선택 모델로 초기화되는 <code>JTable</code> 를 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>dm</CODE> - 테이블의 데이터 모델<DD><CODE>cm</CODE> - 테이블의 열모델<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#createDefaultSelectionModel()"><CODE>createDefaultSelectionModel()</CODE></A> </DL>
</DL>
<HR>

<A NAME="JTable(javax.swing.table.TableModel, javax.swing.table.TableColumnModel, javax.swing.ListSelectionModel)"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dm,
              <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 안의 인터페이스">TableColumnModel</A> &nbsp;cm,
              <A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 안의 인터페이스">ListSelectionModel</A> &nbsp;sm)</PRE>
<DL>
<DD>데이터 모델 <code>dm</code>, 열모델 <code>cm</code>, 및 선택 모델 <code>sm</code> 로 초기화되는 <code>JTable</code> 를 구축합니다. 파라미터중 한쪽이 <code>null</code> 의 경우, 이 메소드는 대응하는 디폴트 모델로 테이블을 초기화합니다. <code>autoCreateColumnsFromModel</code> 플래그는 <code>cm</code> 가 null 이외의 경우는 false 에, 그렇지 않은 경우는 true 로 설정되어 열모델에게는 <code>dm</code> 내의 열에 적절한 <code>TableColumns</code> 가 들어갑니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>dm</CODE> - 테이블의 데이터 모델<DD><CODE>cm</CODE> - 테이블의 열모델<DD><CODE>sm</CODE> - 테이블의 행 선택 모델<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#createDefaultDataModel()"><CODE>createDefaultDataModel()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#createDefaultColumnModel()"><CODE>createDefaultColumnModel()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#createDefaultSelectionModel()"><CODE>createDefaultSelectionModel()</CODE></A> </DL>
</DL>
<HR>

<A NAME="JTable(int, int)"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>(int&nbsp;numRows,
              int&nbsp;numColumns)</PRE>
<DL>
<DD><code>DefaultTableModel</code> 를 사용해, 빈 상태(empty)의 셀 <code>numRows</code> 와 <code>numColumns</code> 를 가지는 <code>JTable</code> 를 구축합니다. 열은, 「A」, 「B」, 「C」라고 한 형식의 이름을 가집니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>numRows</CODE> - 테이블이 보관 유지하는 행수<DD><CODE>numColumns</CODE> - 테이블이 보관 유지하는 렬수<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/DefaultTableModel.html" title="javax.swing.table 내의 클래스"><CODE>DefaultTableModel</CODE></A> </DL>
</DL>
<HR>

<A NAME="JTable(java.util.Vector, java.util.Vector)"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>(<A HREF="../../java/util/Vector.html" title="java.util 안의 클래스">Vector</A> &nbsp;rowData,
              <A HREF="../../java/util/Vector.html" title="java.util 안의 클래스">Vector</A> &nbsp;columnNames)</PRE>
<DL>
<DD><code>Vectors</code> 의 <code>Vector</code> 의 값을 표시하는 <code>JTable</code>, 즉 <code>rowData</code> 를, 렬명 <code>columnNames</code> 로 구축합니다.  <code>rowData</code> 에 포함된 <code>Vectors</code> 는, 그 행의 값을 보관 유지할 필요가 있습니다. 즉, 행 1, 열 5 에 위치하는 셀의 값은 다음의 코드로 취득할 수 있습니다.
 <p>
 <pre>((Vector) rowData.elementAt(1)). elementAt(5);</pre>
 <p>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>rowData</CODE> - 새로운 테이블의 데이터<DD><CODE>columnNames</CODE> - 각 열의 이름</DL>
</DL>
<HR>

<A NAME="JTable(java.lang.Object[][], java.lang.Object[])"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> [][]&nbsp;rowData,
              <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;columnNames)</PRE>
<DL>
<DD>2 차원 배열 <code>rowData</code> 의 값을 표시하는 <code>JTable</code> 를, 렬명 <code>columnNames</code> 로 구축합니다. <code>rowData</code> 하행의 배열이므로, 행 1, 열 5 에 위치하는 셀의 값은 다음의 코드로 취득할 수 있습니다.  
 <p>
 <pre> rowData[1][5]; </pre>
 <p>
모든 행은,<code>columnNames</code> 와 같은 길이가 아니면 안됩니다.  &nbsp;<p>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>rowData</CODE> - 새로운 테이블의 데이터<DD><CODE>columnNames</CODE> - 각 열의 이름</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메소드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="addNotify()"><!-- --></A> <H3>
addNotify</H3>
<PRE>
public void <B>addNotify</B>()</PRE>
<DL>
<DD><code>configureEnclosingScrollPane</code> 메소드를 호출합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#addNotify()">addNotify</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#configureEnclosingScrollPane()"><CODE>configureEnclosingScrollPane()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="configureEnclosingScrollPane()"><!-- --></A> <H3>
configureEnclosingScrollPane</H3>
<PRE>
protected void <B>configureEnclosingScrollPane</B>()</PRE>
<DL>
<DD>일반적으로은 이 <code>JTable</code> 가 둘러싸 옆 <code>JScrollPane</code> 의 <code>viewportView</code> 입니다만, 그 경우, 특히 테이블의 <code>tableHeader</code> 을 스크롤 구획의 <code>columnHeaderView</code> 로서 인스톨 하는 것에 의해, 이 <code>ScrollPane</code> 의 설정을 실시합니다. <code>new JScrollPane(myTable)</code> 을 사용해 일반적으로의 방법으로 <code>JTable</code> 를 <code>JScrollPane</code> 에 추가하면(자), 테이블이 뷰포트에 추가될 때 <code>addNotify</code> 가 <code>JTable</code> 로 불려 갑니다. 다음에 <code>JTable</code> 의 <code>addNotify</code> 메소드가 이 메소드를 호출합니다. 이 메소드는, 디폴트의 인스톨 프로시저를 서브 클래스를 오버라이드(override) 할 수 있도록(듯이) 보호되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#addNotify()"><CODE>addNotify()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="removeNotify()"><!-- --></A> <H3>
removeNotify</H3>
<PRE>
public void <B>removeNotify</B>()</PRE>
<DL>
<DD><code>unconfigureEnclosingScrollPane</code> 메소드를 호출합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#removeNotify()">removeNotify</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#unconfigureEnclosingScrollPane()"><CODE>unconfigureEnclosingScrollPane()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="unconfigureEnclosingScrollPane()"><!-- --></A> <H3>
unconfigureEnclosingScrollPane</H3>
<PRE>
protected void <B>unconfigureEnclosingScrollPane</B>()</PRE>
<DL>
<DD>포위측의 스크롤 구획의 <code>columnHeaderView</code> 를 <code>null</code> 에 옮겨놓는 것에 의해,<code>configureEnclosingScrollPane</code> 의 효과를 취소합니다. <code>JTable</code> 의 <code>removeNotify</code> 메소드가 이 메소드를 호출합니다. 이 메소드는, 이 디폴트의 인스톨 해제 프로시저를 서브 클래스를 오버라이드(override) 할 수 있도록(듯이) 보호되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#removeNotify()"><CODE>removeNotify()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#configureEnclosingScrollPane()"><CODE>configureEnclosingScrollPane()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createScrollPaneForTable(javax.swing.JTable)"><!-- --></A> <H3>
createScrollPaneForTable</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public static <A HREF="../../javax/swing/JScrollPane.html" title="javax.swing 내의 클래스">JScrollPane</A>  <B>createScrollPaneForTable</B>(<A HREF="../../javax/swing/JTable.html" title="javax.swing 안의 클래스">JTable</A> &nbsp;aTable)</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>Swing 1.0. 2 로 <code>new JScrollPane(aTable)</code> 로 옮겨졌습니다. </I>
<P>
<DD><code>new JScrollPane(aTable)</code> 와 동등합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTableHeader(javax.swing.table.JTableHeader)"><!-- --></A> <H3>
setTableHeader</H3>
<PRE>
public void <B>setTableHeader</B>(<A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 안의 클래스">JTableHeader</A> &nbsp;tableHeader)</PRE>
<DL>
<DD>이 <code>JTable</code> 의 <code>tableHeader</code> 를 <code>newHeader</code> 로 설정합니다. <code>null</code> 의 <code>tableHeader</code> 는 유효합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tableHeader</CODE> - 새로운 tableHeader<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getTableHeader()"><CODE>getTableHeader()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTableHeader()"><!-- --></A> <H3>
getTableHeader</H3>
<PRE>
public <A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스">JTableHeader</A>  <B>getTableHeader</B>()</PRE>
<DL>
<DD>이 <code>JTable</code> 가 사용하는 <code>tableHeader</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 테이블이 사용하는 <code>tableHeader</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setTableHeader(javax.swing.table.JTableHeader)"><CODE>setTableHeader(javax.swing.table.JTableHeader)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRowHeight(int)"><!-- --></A> <H3>
setRowHeight</H3>
<PRE>
public void <B>setRowHeight</B>(int&nbsp;rowHeight)</PRE>
<DL>
<DD>새로운 행의 높이 <code>rowHeight</code> 가 1 미만의 경우 셀의 높이는, 행의 높이로부터 행 마진을 깎은 값이 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rowHeight</CODE> - 새로운 행의 높이
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>rowHeight</code> 가 1 미만의 경우<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getRowHeight()"><CODE>getRowHeight()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRowHeight()"><!-- --></A> <H3>
getRowHeight</H3>
<PRE>
public int <B>getRowHeight</B>()</PRE>
<DL>
<DD>테이블행의 높이를 픽셀로 돌려줍니다. 디폴트의 행의 높이는 16.0 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>픽셀 단위의 테이블행의 높이<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setRowHeight(int)"><CODE>setRowHeight(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRowHeight(int, int)"><!-- --></A> <H3>
setRowHeight</H3>
<PRE>
public void <B>setRowHeight</B>(int&nbsp;row,
                         int&nbsp;rowHeight)</PRE>
<DL>
<DD><code>row</code> 의 높이를 <code>rowHeight</code> 로 설정해, 재확인해, 페인트 다시 합니다. 이 행의 셀의 높이는, 행의 높이로부터 행 마진을 깎은 것입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 높이가 변경되는 행<DD><CODE>rowHeight</CODE> - 픽셀 단위에서의 새로운 행의 높이
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>rowHeight</code> 가 1 미만의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRowHeight(int)"><!-- --></A> <H3>
getRowHeight</H3>
<PRE>
public int <B>getRowHeight</B>(int&nbsp;row)</PRE>
<DL>
<DD><code>row</code> 의 셀의 높이를 픽셀 단위로 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 높이가 반환되는 행
<DT><B>반환값:</B><DD>픽셀 단위에서의 행의 셀의 높이<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRowMargin(int)"><!-- --></A> <H3>
setRowMargin</H3>
<PRE>
public void <B>setRowMargin</B>(int&nbsp;rowMargin)</PRE>
<DL>
<DD>인접하는 행의 셀의 간격을 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rowMargin</CODE> - 행의 셀간의 픽셀수<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getRowMargin()"><CODE>getRowMargin()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRowMargin()"><!-- --></A> <H3>
getRowMargin</H3>
<PRE>
public int <B>getRowMargin</B>()</PRE>
<DL>
<DD>셀의 간격을 픽셀 단위로 돌려줍니다. <code>getIntercellSpacing(). height</code> 와 동등합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행의 셀간의 픽셀수<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setRowMargin(int)"><CODE>setRowMargin(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setIntercellSpacing(java.awt.Dimension)"><!-- --></A> <H3>
setIntercellSpacing</H3>
<PRE>
public void <B>setIntercellSpacing</B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;intercellSpacing)</PRE>
<DL>
<DD><code>rowMargin</code> 와 <code>columnMargin</code>, 즉 셀간의 스페이스의 높이와 폭을,<code>intercellSpacing</code> 로 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>intercellSpacing</CODE> - 셀간의 새로운 폭과 높이를 지정하는 <code>Dimension</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getIntercellSpacing()"><CODE>getIntercellSpacing()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getIntercellSpacing()"><!-- --></A> <H3>
getIntercellSpacing</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getIntercellSpacing</B>()</PRE>
<DL>
<DD>셀간의 수평 간격과 수직 간격을 돌려줍니다. 디폴트 간격은, 구라두를 draw 하는 스페이스를 제공하는 (1, 1)입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>셀간의 수평 간격과 수직 간격<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setIntercellSpacing(java.awt.Dimension)"><CODE>setIntercellSpacing(java.awt.Dimension)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setGridColor(java.awt.Color)"><!-- --></A> <H3>
setGridColor</H3>
<PRE>
public void <B>setGridColor</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;gridColor)</PRE>
<DL>
<DD>구라두선의 draw에 사용하는 색을 <code>gridColor</code> 로 설정해, 재표시합니다. 디폴트의 색은 Look & Feel 에 의존합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>gridColor</CODE> - 구라두선의 새로운 색
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>gridColor</code> 가 <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getGridColor()"><CODE>getGridColor()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getGridColor()"><!-- --></A> <H3>
getGridColor</H3>
<PRE>
public <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>getGridColor</B>()</PRE>
<DL>
<DD>구라두선의 draw에 사용하는 색을 돌려줍니다. 디폴트의 색은 Look & Feel 에 의존합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>구라두선을 draw 하는데 사용하는 색<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setGridColor(java.awt.Color)"><CODE>setGridColor(java.awt.Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setShowGrid(boolean)"><!-- --></A> <H3>
setShowGrid</H3>
<PRE>
public void <B>setShowGrid</B>(boolean&nbsp;showGrid)</PRE>
<DL>
<DD>테이블이 셀의 주위에 구라두선을 draw 할지 어떨지를 설정합니다. <code>showGrid</code> 가 true 의 경우는 draw 해, false 의 경우는 draw 하지 않습니다. 이 상태는 각각이 따로 따로 조회되는 <code>showHorizontalLines</code> 와 <code>showVerticalLines</code> 라고 하는 2 개의 변수로 보관 유지되므로,<code>getShowGrid</code> 메소드는 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>showGrid</CODE> - 테이브르뷰가 구라두선을 draw 하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setShowVerticalLines(boolean)"><CODE>setShowVerticalLines(boolean)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#setShowHorizontalLines(boolean)"><CODE>setShowHorizontalLines(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setShowHorizontalLines(boolean)"><!-- --></A> <H3>
setShowHorizontalLines</H3>
<PRE>
public void <B>setShowHorizontalLines</B>(boolean&nbsp;showHorizontalLines)</PRE>
<DL>
<DD>테이블이 셀간에 수평선을 draw 할지 어떨지를 설정합니다. <code>showHorizontalLines</code> 가 true 의 경우는 draw 해, false 의 경우는 draw 하지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>showHorizontalLines</CODE> - 테이브르뷰가 수평선을 draw 하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getShowHorizontalLines()"><CODE>getShowHorizontalLines()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#setShowGrid(boolean)"><CODE>setShowGrid(boolean)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#setShowVerticalLines(boolean)"><CODE>setShowVerticalLines(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setShowVerticalLines(boolean)"><!-- --></A> <H3>
setShowVerticalLines</H3>
<PRE>
public void <B>setShowVerticalLines</B>(boolean&nbsp;showVerticalLines)</PRE>
<DL>
<DD>테이블이 셀간에 수직선을 draw 할지 어떨지를 설정합니다. <code>showVerticalLines</code> 가 true 의 경우는 draw 해, false 의 경우는 draw 하지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>showVerticalLines</CODE> - 테이브르뷰가 수직선을 draw 하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getShowVerticalLines()"><CODE>getShowVerticalLines()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#setShowGrid(boolean)"><CODE>setShowGrid(boolean)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#setShowHorizontalLines(boolean)"><CODE>setShowHorizontalLines(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getShowHorizontalLines()"><!-- --></A> <H3>
getShowHorizontalLines</H3>
<PRE>
public boolean <B>getShowHorizontalLines</B>()</PRE>
<DL>
<DD>테이블이 셀간에 수평선을 draw 하는 경우는 true, draw 하지 않는 경우는 false 를 돌려줍니다. 디폴트는 true 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블이 셀간에 수평선을 draw 하는 경우는 true, draw 하지 않는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setShowHorizontalLines(boolean)"><CODE>setShowHorizontalLines(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getShowVerticalLines()"><!-- --></A> <H3>
getShowVerticalLines</H3>
<PRE>
public boolean <B>getShowVerticalLines</B>()</PRE>
<DL>
<DD>테이블이 셀간에 수직선을 draw 하는 경우는 true, draw 하지 않는 경우는 false 를 돌려줍니다. 디폴트는 true 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블이 셀간에 수직선을 draw 하는 경우는 true, draw 하지 않는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setShowVerticalLines(boolean)"><CODE>setShowVerticalLines(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setAutoResizeMode(int)"><!-- --></A> <H3>
setAutoResizeMode</H3>
<PRE>
public void <B>setAutoResizeMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>테이블의 사이즈 변경시에 테이블의 자동 사이즈 변경 모드를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>mode</CODE> - 다음의 5 개의 유효치의 언젠가.
AUTO_RESIZE_OFF,
AUTO_RESIZE_NEXT_COLUMN,
AUTO_RESIZE_SUBSEQUENT_COLUMNS,
AUTO_RESIZE_LAST_COLUMN,
AUTO_RESIZE_ALL_COLUMNS<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getAutoResizeMode()"><CODE>getAutoResizeMode()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#doLayout()"><CODE>doLayout()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAutoResizeMode()"><!-- --></A> <H3>
getAutoResizeMode</H3>
<PRE>
public int <B>getAutoResizeMode</B>()</PRE>
<DL>
<DD>테이블의 자동 사이즈 변경 모드를 돌려줍니다. 디폴트 모드는 AUTO_RESIZE_SUBSEQUENT_COLUMNS 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블의 autoResizeMode<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setAutoResizeMode(int)"><CODE>setAutoResizeMode(int)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#doLayout()"><CODE>doLayout()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setAutoCreateColumnsFromModel(boolean)"><!-- --></A> <H3>
setAutoCreateColumnsFromModel</H3>
<PRE>
public void <B>setAutoCreateColumnsFromModel</B>(boolean&nbsp;autoCreateColumnsFromModel)</PRE>
<DL>
<DD>이 테이블의 <code>autoCreateColumnsFromModel</code> 플래그를 설정합니다. 이 메소드는,<code>autoCreateColumnsFromModel</code> 가 false 로부터 true 로 변경되었을 경우에 <code>createDefaultColumnsFromModel</code> 를 호출합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>autoCreateColumnsFromModel</CODE> - <code>JTable</code> 가 열을 자동 작성하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getAutoCreateColumnsFromModel()"><CODE>getAutoCreateColumnsFromModel()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#createDefaultColumnsFromModel()"><CODE>createDefaultColumnsFromModel()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAutoCreateColumnsFromModel()"><!-- --></A> <H3>
getAutoCreateColumnsFromModel</H3>
<PRE>
public boolean <B>getAutoCreateColumnsFromModel</B>()</PRE>
<DL>
<DD>테이블이 디폴트의 열을 모델로부터 작성할지 어떨지를 지정합니다. true 의 경우,<code>setModel</code> 는 기존의 열을 클리어 해, 새로운 모델로부터 새로운 열을 작성합니다. 또,<code>tableChanged</code> 통지의 이벤트가, 테이블 전체가 변경된 것을 나타내고 있는 경우는, 열이 재구축 됩니다. 디폴트는 true 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블의 autoCreateColumnsFromModel<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setAutoCreateColumnsFromModel(boolean)"><CODE>setAutoCreateColumnsFromModel(boolean)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#createDefaultColumnsFromModel()"><CODE>createDefaultColumnsFromModel()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultColumnsFromModel()"><!-- --></A> <H3>
createDefaultColumnsFromModel</H3>
<PRE>
public void <B>createDefaultColumnsFromModel</B>()</PRE>
<DL>
<DD>이 메소드는 <code>TableModel</code> 인터페이스로 정의된 <code>getColumnCount</code> 메소드를 사용해, 데이터 모델로부터 테이블의 디폴트의 열을 작성합니다.  &nbsp;<p>
모델로부터의 정보에 근거해 새로운 열을 작성하기 전에, 기존의 열이 있으면 그것을 클리어 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getAutoCreateColumnsFromModel()"><CODE>getAutoCreateColumnsFromModel()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultRenderer(java.lang.Class, javax.swing.table.TableCellRenderer)"><!-- --></A> <H3>
setDefaultRenderer</H3>
<PRE>
public void <B>setDefaultRenderer</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass,
                               <A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 안의 인터페이스">TableCellRenderer</A> &nbsp;renderer)</PRE>
<DL>
<DD><code>TableColumn</code> 에 렌더링이 설정되어 있지 않은 경우에 사용하는, 디폴트의 셀 렌더링을 설정합니다. 렌더링이 <code>null</code> 의 경우는, 이 열클래스의 디폴트의 렌더링을 삭제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnClass</CODE> - 이 columnClass 에 디폴트의 셀 렌더링을 설정<DD><CODE>renderer</CODE> - 이 columnClass 에 사용하는 디폴트의 셀 렌더링<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getDefaultRenderer(java.lang.Class)"><CODE>getDefaultRenderer(java.lang.Class<? >)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#setDefaultEditor(java.lang.Class, javax.swing.table.TableCellEditor)"><CODE>setDefaultEditor(java.lang.Class<? >, javax.swing.table.TableCellEditor)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultRenderer(java.lang.Class)"><!-- --></A> <H3>
getDefaultRenderer</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 내의 인터페이스">TableCellRenderer</A>  <B>getDefaultRenderer</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass)</PRE>
<DL>
<DD><code>TableColumn</code> 에 렌더링이 설정되어 있지 않은 경우에 사용하는, 셀 렌더링을 돌려줍니다. 셀의 draw시에는, 렌더링은 렬내의 셀의 클래스에 근거해 엔트리의 <code>Hashtable</code> 로부터 취득됩니다. 이 <code>columnClass</code> 에 엔트리가 없는 경우, 이 메소드는 가장 명확한 슈퍼 클래스의 엔트리를 돌려줍니다. <code>JTable</code> 는, 그 모든 것을 변경 또는 치환할 수 있는 <code>Object</code>,<code>Number</code>, 및 <code>Boolean</code> 의 엔트리를 인스톨 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnClass</CODE> - 이 columnClass 의 디폴트의 셀 렌더링을 돌려준다
<DT><B>반환값:</B><DD>이 columnClass 의 렌더링<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setDefaultRenderer(java.lang.Class, javax.swing.table.TableCellRenderer)"><CODE>setDefaultRenderer(java.lang.Class<? >, javax.swing.table.TableCellRenderer)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#getColumnClass(int)"><CODE>getColumnClass(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultEditor(java.lang.Class, javax.swing.table.TableCellEditor)"><!-- --></A> <H3>
setDefaultEditor</H3>
<PRE>
public void <B>setDefaultEditor</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass,
                             <A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 안의 인터페이스">TableCellEditor</A> &nbsp;editor)</PRE>
<DL>
<DD><code>TableColumn</code> 에 에디터가 설정되어 있지 않은 경우에 사용하는, 디폴트의 셀 에디터를 설정합니다. 테이블 또는 테이블내의 특정의 열로 편집이 필요없는 경우는,<code>TableModel</code> 인터페이스의 <code>isCellEditable</code> 메소드를 사용해, 이 <code>JTable</code> 가 이러한 열로 에디터를 기동할리가 없게 합니다. 에디터가 <code>null</code> 의 경우는, 이 열클래스로부터 디폴트의 에디터를 삭제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnClass</CODE> - 이 columnClass 에 디폴트의 셀 에디터를 설정하는<DD><CODE>editor</CODE> - 이 columnClass 에 사용하는 디폴트의 셀 에디터<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/TableModel.html#isCellEditable(int, int)"><CODE>TableModel.isCellEditable(int, int)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#getDefaultEditor(java.lang.Class)"><CODE>getDefaultEditor(java.lang.Class<? >)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#setDefaultRenderer(java.lang.Class, javax.swing.table.TableCellRenderer)"><CODE>setDefaultRenderer(java.lang.Class<? >, javax.swing.table.TableCellRenderer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultEditor(java.lang.Class)"><!-- --></A> <H3>
getDefaultEditor</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A>  <B>getDefaultEditor</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass)</PRE>
<DL>
<DD><code>TableColumn</code> 에 에디터가 설정되어 있지 않은 경우에 사용하는 에디터를 돌려줍니다. 셀의 편집시에는, 에디터는 렬내의 셀의 클래스에 근거해 엔트리의 <code>Hashtable</code> 로부터 취득됩니다. 이 <code>columnClass</code> 에 엔트리가 없는 경우, 이 메소드는 가장 명확한 슈퍼 클래스의 엔트리를 돌려줍니다. <code>JTable</code> 는, 그 모든 것을 변경 또는 치환할 수 있는 <code>Object</code>,<code>Number</code>, 및 <code>Boolean</code> 의 엔트리를 인스톨 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnClass</CODE> - 이 columnClass 의 디폴트의 셀 에디터를 돌려준다
<DT><B>반환값:</B><DD>이 columnClass 에 사용하는 디폴트의 셀 에디터<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setDefaultEditor(java.lang.Class, javax.swing.table.TableCellEditor)"><CODE>setDefaultEditor(java.lang.Class<? >, javax.swing.table.TableCellEditor)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#getColumnClass(int)"><CODE>getColumnClass(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDragEnabled(boolean)"><!-- --></A> <H3>
setDragEnabled</H3>
<PRE>
public void <B>setDragEnabled</B>(boolean&nbsp;b)</PRE>
<DL>
<DD>자동 드래그 처리를 온 또는 오프로 합니다. 자동 드래그 처리를 유효하게 하려면 , 이 프로퍼티의 값을 <code>true</code> 로 설정해, 테이블의 <code>TransferHandler</code> 의 값을 <code>null 이외</code> 로 해 주세요. <code>dragEnabled</code> 프로퍼티의 디폴트 값는 <code>false</code> 입니다.  &nbsp;<p>
이 프로퍼티을 받아들여 사용자의 드래그 제스처(gesture)를 인식하는 처리는, Look & Feel 구현 (특히 테이블의 <code>TableUI</code>)에 의해 행해집니다. 자동 드래그 처리가 유효한 경우, 대부분의, Look & Feel (<code>BasicLookAndFeel</code> 의 서브 클래스의 Look & Feel 를 포함한다)는, 사용자가 항목 (단일 선택 모드) 또는 선택 내용 (그 외의 선택 모드) 위에서 mouse button를 눌러 , 마우스를 수픽셀 이동하면(자), 드래그＆드롭 조작을 개시합니다. 따라서, 이 프로퍼티을 <code>true</code> 로 설정하면(자), 선택의 동작에 미묘한 효과가 있습니다.  &nbsp;<p>
이 프로퍼티을 무시하는 것 같은 Look & Feel 를 사용하고 있는 경우도, 테이블의 <code>TransferHandler</code> 상에서 <code>exportAsDrag</code> 를 호출하는 것으로, 드래그＆드롭 조작을 개시할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>b</CODE> - 자동 드래그 처리를 유효하게 할지 어떨지
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/awt/HeadlessException.html" title="java.awt 안의 클래스">HeadlessException</A> </CODE> - <code>b</code> 가 <code>true</code> 의 경우로 <code>GraphicsEnvironment.isHeadless()</code> 가 <code>true</code> 를 돌려주는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/GraphicsEnvironment.html#isHeadless()"><CODE>GraphicsEnvironment.isHeadless()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#getDragEnabled()"><CODE>getDragEnabled()</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setTransferHandler(javax.swing.TransferHandler)"><CODE>JComponent.setTransferHandler(javax.swing.TransferHandler)</CODE></A> , 
<A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 안의 클래스"><CODE>TransferHandler</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDragEnabled()"><!-- --></A> <H3>
getDragEnabled</H3>
<PRE>
public boolean <B>getDragEnabled</B>()</PRE>
<DL>
<DD>자동 드래그 처리가 유효한지 어떤지를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>dragEnabled</code> 프로퍼티의 값<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setDragEnabled(boolean)"><CODE>setDragEnabled(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDropMode(javax.swing.DropMode)"><!-- --></A> <H3>
setDropMode</H3>
<PRE>
public final void <B>setDropMode</B>(<A HREF="../../javax/swing/DropMode.html" title="javax.swing 안의 열거형">DropMode</A> &nbsp;dropMode)</PRE>
<DL>
<DD>이 컴퍼넌트의 드롭 모드를 설정합니다. 후방 호환성을 확보하기 위해(때문에), 이 프로퍼티의 디폴트 값는 <code>DropMode.USE_SELECTION</code> 가 되어 있습니다. 다만, 사용자측의 조작을 개선하는 경우는, 다른 모드를 사용하는 것을 추천합니다. 예를 들어 <code>DropMode.ON</code> 는, 테이블내의 실제의 선택 내용에 영향을 미치는 일 없이, 선택된 것처럼 항목을 표시하는 동작과 닮은 동작을 제공합니다.  &nbsp;<p>
<code>JTable</code> 는 다음의 드롭 모드를 지원하고 있습니다.
 <ul>
<li><code>DropMode.USE_SELECTION</code></li>
<li><code>DropMode.ON</code></li>
<li><code>DropMode.INSERT</code></li>
<li><code>DropMode.INSERT_ROWS</code></li>
<li><code>DropMode.INSERT_COLS</code></li>
<li><code>DropMode.ON_OR_INSERT</code></li>
<li><code>DropMode.ON_OR_INSERT_ROWS</code></li>
<li><code>DropMode.ON_OR_INSERT_COLS</code></li>
 </ul>
 <p>
이 컴퍼넌트가 드롭을 받아들이는 <code>TransferHandler</code> 를 가지고 있지 않으면, 드롭 모드의 효과는 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>dropMode</CODE> - 사용하는 드롭 모드
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 드롭 모드가 지원되어 있지 않은가 <code>null</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getDropMode()"><CODE>getDropMode()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#getDropLocation()"><CODE>getDropLocation()</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setTransferHandler(javax.swing.TransferHandler)"><CODE>JComponent.setTransferHandler(javax.swing.TransferHandler)</CODE></A> , 
<A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 안의 클래스"><CODE>TransferHandler</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDropMode()"><!-- --></A> <H3>
getDropMode</H3>
<PRE>
public final <A HREF="../../javax/swing/DropMode.html" title="javax.swing 내의 열거형">DropMode</A>  <B>getDropMode</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 드롭 모드를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트의 드롭 모드<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setDropMode(javax.swing.DropMode)"><CODE>setDropMode(javax.swing.DropMode)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDropLocation()"><!-- --></A> <H3>
getDropLocation</H3>
<PRE>
public final <A HREF="../../javax/swing/JTable.DropLocation.html" title="javax.swing 내의 클래스">JTable.DropLocation</A>  <B>getDropLocation</B>()</PRE>
<DL>
<DD>이 컴퍼넌트가 컴퍼넌트의 드래그＆드롭시에 드롭 위치로서 시각적으로 가리키는 위치를 돌려줍니다. 현재 위치가 표시되어 있지 않은 경우는 <code>null</code> 를 돌려줍니다.  &nbsp;<p>
이 메소드는,<code>TransferHandler</code> 로부터 드롭 위치를 조회하는 수단으로는 되지 않습니다. 드롭 위치는,<code>TransferHandler</code> 의 <code>canImport</code> 가 돌려주어져 드롭 위치를 표시할 준비를 할 수 있고 나서 설정되기 때문입니다.  &nbsp;<p>
이 프로퍼티이 변경되면(자), 컴퍼넌트에 의해, 프로퍼티 변경 이벤트 dropLocation 가 트리거됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>드롭 위치<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setDropMode(javax.swing.DropMode)"><CODE>setDropMode(javax.swing.DropMode)</CODE></A> , 
<A HREF="../../javax/swing/TransferHandler.html#canImport(javax.swing.TransferHandler.TransferSupport)"><CODE>TransferHandler.canImport(TransferHandler.TransferSupport)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setAutoCreateRowSorter(boolean)"><!-- --></A> <H3>
setAutoCreateRowSorter</H3>
<PRE>
public void <B>setAutoCreateRowSorter</B>(boolean&nbsp;autoCreateRowSorter)</PRE>
<DL>
<DD>모델이 변경될 때마다 테이블의 <code>RowSorter</code> 를 작성할지 어떨지를 지정합니다.  &nbsp;<p>
<code>setAutoCreateRowSorter(true)</code> 가 불려 가면(자), 즉시 <code>TableRowSorter</code> 가 작성되어 테이블에 인스톨 됩니다. <code>autoCreateRowSorter</code> 프로퍼티의 값이 <code>true</code> 의 경우, 모델이 변경될 때마다 새로운 <code>TableRowSorter</code> 가 작성되어 테이블의 행 소터로서 설정됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>autoCreateRowSorter</CODE> - <code>RowSorter</code> 가 자동적으로 작성
될지 어떨지<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/TableRowSorter.html" title="javax.swing.table 내의 클래스"><CODE>TableRowSorter</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAutoCreateRowSorter()"><!-- --></A> <H3>
getAutoCreateRowSorter</H3>
<PRE>
public boolean <B>getAutoCreateRowSorter</B>()</PRE>
<DL>
<DD>모델이 변경될 때마다 새로운 <code>RowSorter</code> 를 작성해, 테이블의 소터로서 인스톨 하는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>모델이 변경될 때마다
<code>RowSorter</code> 가 작성되는 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUpdateSelectionOnSort(boolean)"><!-- --></A> <H3>
setUpdateSelectionOnSort</H3>
<PRE>
public void <B>setUpdateSelectionOnSort</B>(boolean&nbsp;update)</PRE>
<DL>
<DD>소트 후, 선택 내용을 갱신할지 어떨지를 지정합니다. true 의 경우, 소트시에 선택 내용이 리셋 되어 그 모델의 같은 행이 선택된 상태가 됩니다. 디폴트는 true 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>update</CODE> - 소트시에 선택 내용을 갱신할지 어떨지<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUpdateSelectionOnSort()"><!-- --></A> <H3>
getUpdateSelectionOnSort</H3>
<PRE>
public boolean <B>getUpdateSelectionOnSort</B>()</PRE>
<DL>
<DD>소트 후, 선택 내용을 갱신하는 경우는 true 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>소트시에 선택 내용을 갱신할지 어떨지<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRowSorter(javax.swing.RowSorter)"><!-- --></A> <H3>
setRowSorter</H3>
<PRE>
public void <B>setRowSorter</B>(<A HREF="../../javax/swing/RowSorter.html" title="javax.swing 안의 클래스">RowSorter</A> &lt;?  extends <A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A> &gt;&nbsp;sorter)</PRE>
<DL>
<DD><code>RowSorter</code> 를 설정합니다. <code>RowSorter</code> 는,<code>JTable</code> 에 소트 및 필터링 기능을 제공하기 위해서 사용됩니다.  &nbsp;<p>
이 메소드는, 선택을 해제해, 가변의 행의 높이를 모두 리셋 합니다.  &nbsp;<p>
<code>RowSorter</code> 의 부하의 모델이 이 <code>JTable</code> 의 부하의 모델과 일치하지 않는 경우의 동작은 보증되지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>sorter</CODE> - <code>RowSorter</code>. <code>null</code> 의 경우,
소트는 무효<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/TableRowSorter.html" title="javax.swing.table 내의 클래스"><CODE>TableRowSorter</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRowSorter()"><!-- --></A> <H3>
getRowSorter</H3>
<PRE>
public <A HREF="../../javax/swing/RowSorter.html" title="javax.swing 내의 클래스">RowSorter</A> &lt;?  extends <A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A> &gt; <B>getRowSorter</B>()</PRE>
<DL>
<DD>소트 처리를 실시하는 객체를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>소트 처리를 실시하는 객체<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSelectionMode(int)"><!-- --></A> <H3>
setSelectionMode</H3>
<PRE>
public void <B>setSelectionMode</B>(int&nbsp;selectionMode)</PRE>
<DL>
<DD>테이블의 선택 모드를 설정하면(자), 단일 항목 선택, 연속 구간의 선택, 또는 연속 구간의 복수 선택을 가능하게 할 수 있습니다.  &nbsp;<P>
<bold>주:</bold> <code>JTable</code> 는, 열과 행의 선택을 처리하는 모든 메소드를 제공합니다. <code>setSelectionMode</code> 등의 상태를 설정할 때,<code>JTable</code> 하행 선택 모델의 모드를 갱신할 뿐만 아니라,<code>columnModel</code> 의 선택 모델로 같은 값을 설정합니다. 행 및 열의 선택 모델을 다른 모드로 기능시키려면 , 그것들을 양쪽 모두 직접 설정합니다.  &nbsp;<p>
<code>JTable</code> 의 행 선택 모델과 열선택 모델은 어느 쪽과도 디폴트로 <code>DefaultListSelectionModel</code> 를 사용하므로,<code>JTable</code> 는 <code>JList</code> 와 같이 동작합니다. 모드의 자세한 것은,<code>JList</code> 의 <code>setSelectionMode</code> 를 참조해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JList.html#setSelectionMode(int)"><CODE>JList.setSelectionMode(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRowSelectionAllowed(boolean)"><!-- --></A> <H3>
setRowSelectionAllowed</H3>
<PRE>
public void <B>setRowSelectionAllowed</B>(boolean&nbsp;rowSelectionAllowed)</PRE>
<DL>
<DD>이 모델의 행을 선택할 수 있을지 어떨지를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rowSelectionAllowed</CODE> - 이 모델이 행 선택을 허가하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getRowSelectionAllowed()"><CODE>getRowSelectionAllowed()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRowSelectionAllowed()"><!-- --></A> <H3>
getRowSelectionAllowed</H3>
<PRE>
public boolean <B>getRowSelectionAllowed</B>()</PRE>
<DL>
<DD>행을 선택할 수 있는 경우에 true 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행을 선택 가능한 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setRowSelectionAllowed(boolean)"><CODE>setRowSelectionAllowed(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setColumnSelectionAllowed(boolean)"><!-- --></A> <H3>
setColumnSelectionAllowed</H3>
<PRE>
public void <B>setColumnSelectionAllowed</B>(boolean&nbsp;columnSelectionAllowed)</PRE>
<DL>
<DD>이 모델의 열을 선택할 수 있을지 어떨지를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnSelectionAllowed</CODE> - 이 모델이 열선택을 허가하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getColumnSelectionAllowed()"><CODE>getColumnSelectionAllowed()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getColumnSelectionAllowed()"><!-- --></A> <H3>
getColumnSelectionAllowed</H3>
<PRE>
public boolean <B>getColumnSelectionAllowed</B>()</PRE>
<DL>
<DD>열을 선택할 수 있는 경우는 true 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>열을 선택 가능한 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setColumnSelectionAllowed(boolean)"><CODE>setColumnSelectionAllowed(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setCellSelectionEnabled(boolean)"><!-- --></A> <H3>
setCellSelectionEnabled</H3>
<PRE>
public void <B>setCellSelectionEnabled</B>(boolean&nbsp;cellSelectionEnabled)</PRE>
<DL>
<DD>열선택과 행 선택의 동시 실행을 이 테이블이 허가할지 어떨지를 설정합니다. 설정되면(자), 테이블은 행 선택 모델과 열선택 모델의 교차하는 부분을, 선택된 셀로서 처리합니다. 이 디폴트의 동작을 변경하려면 ,<code>isCellSelected</code> 를 오버라이드(override) 합니다. 이 메소드는,<code>columnModel</code> 의 <code>rowSelectionAllowed</code> 프로퍼티 및 <code>columnSelectionAllowed</code> 프로퍼티이 지정된 값으로 설정하는 것과 같은 것입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cellSelectionEnabled</CODE> - 행과 열의 동시 선택을 허가하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getCellSelectionEnabled()"><CODE>getCellSelectionEnabled()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#isCellSelected(int, int)"><CODE>isCellSelected(int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getCellSelectionEnabled()"><!-- --></A> <H3>
getCellSelectionEnabled</H3>
<PRE>
public boolean <B>getCellSelectionEnabled</B>()</PRE>
<DL>
<DD>행 선택 모델과 열선택 모델의 양쪽 모두가 가능한 경우는 true 를 돌려줍니다. <code>getRowSelectionAllowed() && getColumnSelectionAllowed()</code> 와 동등합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행 선택 모델과 열선택 모델의 양쪽 모두가 가능한 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setCellSelectionEnabled(boolean)"><CODE>setCellSelectionEnabled(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="selectAll()"><!-- --></A> <H3>
selectAll</H3>
<PRE>
public void <B>selectAll</B>()</PRE>
<DL>
<DD>테이블의 모든 행, 열, 및 셀을 선택합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearSelection()"><!-- --></A> <H3>
clearSelection</H3>
<PRE>
public void <B>clearSelection</B>()</PRE>
<DL>
<DD>선택 떠날 수 있어 모든 열 및 행을 선택 해제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRowSelectionInterval(int, int)"><!-- --></A> <H3>
setRowSelectionInterval</H3>
<PRE>
public void <B>setRowSelectionInterval</B>(int&nbsp;index0,
                                    int&nbsp;index1)</PRE>
<DL>
<DD><code>index0</code> 로부터 <code>index1</code> 까지의 행 (상하한치를 포함한다)을 선택합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index0</CODE> - 구간의 한편의 구석의 값<DD><CODE>index1</CODE> - 구간의 한편의 구석의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>index0</code> 또는 <code>index1</code> 가 [0, <code>getRowCount()</code>-1] 의 범위외의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="setColumnSelectionInterval(int, int)"><!-- --></A> <H3>
setColumnSelectionInterval</H3>
<PRE>
public void <B>setColumnSelectionInterval</B>(int&nbsp;index0,
                                       int&nbsp;index1)</PRE>
<DL>
<DD><code>index0</code> 로부터 <code>index1</code> 까지의 열 (상하한치를 포함한다)을 선택합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index0</CODE> - 구간의 한편의 구석의 값<DD><CODE>index1</CODE> - 구간의 한편의 구석의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>index0</code> 또는 <code>index1</code> 가 [0, <code>getColumnCount()</code>-1] 의 범위외의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="addRowSelectionInterval(int, int)"><!-- --></A> <H3>
addRowSelectionInterval</H3>
<PRE>
public void <B>addRowSelectionInterval</B>(int&nbsp;index0,
                                    int&nbsp;index1)</PRE>
<DL>
<DD><code>index0</code> 로부터 <code>index1</code> 까지의 행 (상하한치를 포함한다)을 현재의 선택 영역에 추가합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index0</CODE> - 구간의 한편의 구석의 값<DD><CODE>index1</CODE> - 구간의 한편의 구석의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>index0</code> 또는 <code>index1</code> 가 [0, <code>getRowCount()</code>-1] 의 범위외의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="addColumnSelectionInterval(int, int)"><!-- --></A> <H3>
addColumnSelectionInterval</H3>
<PRE>
public void <B>addColumnSelectionInterval</B>(int&nbsp;index0,
                                       int&nbsp;index1)</PRE>
<DL>
<DD><code>index0</code> 로부터 <code>index1</code> 까지의 열 (상하한치를 포함한다)을 현재의 선택 영역에 추가합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index0</CODE> - 구간의 한편의 구석의 값<DD><CODE>index1</CODE> - 구간의 한편의 구석의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>index0</code> 또는 <code>index1</code> 가 [0, <code>getColumnCount()</code>-1] 의 범위외의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="removeRowSelectionInterval(int, int)"><!-- --></A> <H3>
removeRowSelectionInterval</H3>
<PRE>
public void <B>removeRowSelectionInterval</B>(int&nbsp;index0,
                                       int&nbsp;index1)</PRE>
<DL>
<DD><code>index0</code> 로부터 <code>index1</code> 까지의 행 (상하한치를 포함한다)을 선택 해제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index0</CODE> - 구간의 한편의 구석의 값<DD><CODE>index1</CODE> - 구간의 한편의 구석의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>index0</code> 또는 <code>index1</code> 가 [0, <code>getRowCount()</code>-1] 의 범위외의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="removeColumnSelectionInterval(int, int)"><!-- --></A> <H3>
removeColumnSelectionInterval</H3>
<PRE>
public void <B>removeColumnSelectionInterval</B>(int&nbsp;index0,
                                          int&nbsp;index1)</PRE>
<DL>
<DD><code>index0</code> 로부터 <code>index1</code> 까지의 열 (상하한치를 포함한다)을 선택 해제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index0</CODE> - 구간의 한편의 구석의 값<DD><CODE>index1</CODE> - 구간의 한편의 구석의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>index0</code> 또는 <code>index1</code> 가 [0, <code>getColumnCount()</code>-1] 의 범위외의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedRow()"><!-- --></A> <H3>
getSelectedRow</H3>
<PRE>
public int <B>getSelectedRow</B>()</PRE>
<DL>
<DD>최초로 선택된 행의 인덱스를 돌려주는지, 행이 선택되어 있지 않은 경우는 -1 을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>최초로 선택된 행의 인덱스</DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedColumn()"><!-- --></A> <H3>
getSelectedColumn</H3>
<PRE>
public int <B>getSelectedColumn</B>()</PRE>
<DL>
<DD>최초로 선택된 열의 인덱스를 돌려주는지, 열이 선택되어 있지 않은 경우는 -1 을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>최초로 선택된 열의 인덱스</DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedRows()"><!-- --></A> <H3>
getSelectedRows</H3>
<PRE>
public int[] <B>getSelectedRows</B>()</PRE>
<DL>
<DD>선택된 모든 행의 인덱스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>선택된 모든 행의 인덱스를 포함하는 정수의 배열.
행이 선택되어 있지 않은 경우는 빈 상태(empty)의 배열<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getSelectedRow()"><CODE>getSelectedRow()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedColumns()"><!-- --></A> <H3>
getSelectedColumns</H3>
<PRE>
public int[] <B>getSelectedColumns</B>()</PRE>
<DL>
<DD>선택된 모든 열의 인덱스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>선택된 모든 열의 인덱스를 포함하는 정수의 배열.
열이 선택되어 있지 않은 경우는 빈 상태(empty)의 배열<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getSelectedColumn()"><CODE>getSelectedColumn()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedRowCount()"><!-- --></A> <H3>
getSelectedRowCount</H3>
<PRE>
public int <B>getSelectedRowCount</B>()</PRE>
<DL>
<DD>선택된 행수를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>선택된 행의 수. 선택되고 있는 행이 없는 경우는 0</DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedColumnCount()"><!-- --></A> <H3>
getSelectedColumnCount</H3>
<PRE>
public int <B>getSelectedColumnCount</B>()</PRE>
<DL>
<DD>선택되고 있는 열의 수를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>선택된 열의 수. 선택되고 있는 열이 없는 경우는 0</DL>
</DD>
</DL>
<HR>

<A NAME="isRowSelected(int)"><!-- --></A> <H3>
isRowSelected</H3>
<PRE>
public boolean <B>isRowSelected</B>(int&nbsp;row)</PRE>
<DL>
<DD>지정된 인덱스가 유효한 행의 범위내에 있어, 그 인덱스로 나타나는 행이 선택되고 있는 경우는 true 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>row</code> 가 유효한 인덱스이며,
그 인덱스로 나타나는 행이 선택되고 있는 경우는 true (0 은 최초의 행)</DL>
</DD>
</DL>
<HR>

<A NAME="isColumnSelected(int)"><!-- --></A> <H3>
isColumnSelected</H3>
<PRE>
public boolean <B>isColumnSelected</B>(int&nbsp;column)</PRE>
<DL>
<DD>지정된 인덱스가 유효한 열의 범위내에 있어, 그 인덱스로 나타나는 열이 선택되고 있는 경우는 true 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>column</CODE> - 열모델의 열
<DT><B>반환값:</B><DD><code>column</code> 가 유효한 인덱스이며,
그 인덱스로 나타나는 열이 선택되고 있는 경우는 true (0 은 최초의 열)</DL>
</DD>
</DL>
<HR>

<A NAME="isCellSelected(int, int)"><!-- --></A> <H3>
isCellSelected</H3>
<PRE>
public boolean <B>isCellSelected</B>(int&nbsp;row,
                              int&nbsp;column)</PRE>
<DL>
<DD>지정된 인덱스가 유효한 행 및 열의 범위내에 있어, 지정된 위치에 있는 셀이 선택되고 있는 경우는 true 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 조회되는 행<DD><CODE>column</CODE> - 조회되는 열
<DT><B>반환값:</B><DD><code>row</code> 와 <code>column</code> 가 유효한 인덱스이며,
인덱스 <code>(row, column)</code> 위치의 셀이 선택되고 있는 경우는 true.
이 경우, 최초의 행과 최초의 열은 인덱스 0 으로 나타난다</DL>
</DD>
</DL>
<HR>

<A NAME="changeSelection(int, int, boolean, boolean)"><!-- --></A> <H3>
changeSelection</H3>
<PRE>
public void <B>changeSelection</B>(int&nbsp;rowIndex,
                            int&nbsp;columnIndex,
                            boolean&nbsp;toggle,
                            boolean&nbsp;extend)</PRE>
<DL>
<DD><code>toggle</code> 와 <code>extend</code> 의 2 개의 플래그 상태에 의해, 테이블의 선택 모델을 갱신합니다. UI 가 받은 키보드 이벤트 또는 마우스 이벤트에 의해 행해진 선택 범위의 변경은 이 메소드에 의해 처리되어 서브 클래스가 동작을 오버라이드(override) 할 수 있게 됩니다. UI 에는, 불연속인 선택 범위의 선두를 조작하는 경우 등, 이 메소드가 제공하는 것보다도 고도의 기능을 필요로 하는 것도 있어, 일부의 선택 범위의 변경에서는 그러한 UI 가 이 메소드에 불러 들여지지 않은 것이 있습니다.  &nbsp;<p>
구현은 다음의 규칙을 사용합니다.
 <ul>
<li> <code>toggle</code>:<em>false</em>,<code>extend</code>:<em>false</em>기존의 선택을 클리어 해, 새로운 셀이 확실히 선택되도록(듯이) 한다
<li> <code>toggle</code>:<em>false</em>,<code>extend</code>:<em>true</em>기존의 선택을 엥커로부터 지정의 셀까지 확장해, 다른 모든 선택을 클리어 한다
<li> <code>toggle</code>:<em>true</em>,<code>extend</code>:<em>false</em>지정된 셀이 선택되고 있는 경우, 그 셀을 선택 해제한다. 선택되어 있지 않은 경우, 그 셀을 선택한다
<li> <code>toggle</code>:<em>true</em>,<code>extend</code>:<em>true</em>엥커의 선택 상태를, 그 엥커와 지정된 셀간의 모든 셀에 적용한다.
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rowIndex</CODE> - <code>row</code> 의 선택에 영향을 주는<DD><CODE>columnIndex</CODE> - <code>column</code> 의 선택에 영향을 주는<DD><CODE>toggle</CODE> - 상기 참조<DD><CODE>extend</CODE> - true 의 경우, 현재의 선택을 확장하는<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSelectionForeground()"><!-- --></A> <H3>
getSelectionForeground</H3>
<PRE>
public <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>getSelectionForeground</B>()</PRE>
<DL>
<DD>선택되고 있는 셀의 foreground 칼라를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>foreground 프로퍼티의 <code>Color</code> 객체<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setSelectionForeground(java.awt.Color)"><CODE>setSelectionForeground(java.awt.Color)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#setSelectionBackground(java.awt.Color)"><CODE>setSelectionBackground(java.awt.Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSelectionForeground(java.awt.Color)"><!-- --></A> <H3>
setSelectionForeground</H3>
<PRE>
public void <B>setSelectionForeground</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;selectionForeground)</PRE>
<DL>
<DD>선택된 셀의 foreground 칼라를 설정합니다. 셀 렌더링은 이 색을 사용해, 선택된 셀의 텍스트와 그래픽스를 draw 합니다.  &nbsp;<p>
이 프로퍼티의 디폴트 값는, Look & Feel 의 구현에 의해 정의됩니다.  &nbsp;<p>
이것은<a href="http://java.sun.com/docs/books/tutorial/javabeans/whatis/beanDefinition.html">「JavaBeans」</a>바운드 프로퍼티입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>selectionForeground</CODE> - 선택된 리스트 항목의 foreground로
사용하는 <code>Color</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getSelectionForeground()"><CODE>getSelectionForeground()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#setSelectionBackground(java.awt.Color)"><CODE>setSelectionBackground(java.awt.Color)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setForeground(java.awt.Color)"><CODE>JComponent.setForeground(java.awt.Color)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setBackground(java.awt.Color)"><CODE>JComponent.setBackground(java.awt.Color)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setFont(java.awt.Font)"><CODE>JComponent.setFont(java.awt.Font)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSelectionBackground()"><!-- --></A> <H3>
getSelectionBackground</H3>
<PRE>
public <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>getSelectionBackground</B>()</PRE>
<DL>
<DD>선택된 셀의 백그라운드 칼라를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>선택된 리스트 항목의 백그라운드에서 사용하는 <code>Color</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setSelectionBackground(java.awt.Color)"><CODE>setSelectionBackground(java.awt.Color)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#setSelectionForeground(java.awt.Color)"><CODE>setSelectionForeground(java.awt.Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSelectionBackground(java.awt.Color)"><!-- --></A> <H3>
setSelectionBackground</H3>
<PRE>
public void <B>setSelectionBackground</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;selectionBackground)</PRE>
<DL>
<DD>선택된 셀의 백그라운드 칼라를 설정합니다. 셀 렌더링은 이 색을 사용해, 선택된 셀을 전부 칠할 수가 있습니다.  &nbsp;<p>
이 프로퍼티의 디폴트 값는, Look & Feel 의 구현에 의해 정의됩니다.  &nbsp;<p>
이것은<a href="http://java.sun.com/docs/books/tutorial/javabeans/whatis/beanDefinition.html">「JavaBeans」</a>바운드 프로퍼티입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>selectionBackground</CODE> - 선택된 셀의 백그라운드에서 사용하는 <code>Color</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getSelectionBackground()"><CODE>getSelectionBackground()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#setSelectionForeground(java.awt.Color)"><CODE>setSelectionForeground(java.awt.Color)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setForeground(java.awt.Color)"><CODE>JComponent.setForeground(java.awt.Color)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setBackground(java.awt.Color)"><CODE>JComponent.setBackground(java.awt.Color)</CODE></A> , 
<A HREF="../../javax/swing/JComponent.html#setFont(java.awt.Font)"><CODE>JComponent.setFont(java.awt.Font)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getColumn(java.lang.Object)"><!-- --></A> <H3>
getColumn</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableColumn.html" title="javax.swing.table 내의 클래스">TableColumn</A>  <B>getColumn</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;identifier)</PRE>
<DL>
<DD><code>equals</code> 를 사용해 비교해, 식별자가 <code>identifier</code> 에 동일한 테이블내의 열의 <code>TableColumn</code> 객체를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>identifier</CODE> - 식별자 객체
<DT><B>반환값:</B><DD>식별자가 일치하는 <code>TableColumn</code> 객체
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>identifier</code> 이 <code>null</code> 의 경우, 또는 이 식별자를 가지는 <code>TableColumn</code> 가 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="convertColumnIndexToModel(int)"><!-- --></A> <H3>
convertColumnIndexToModel</H3>
<PRE>
public int <B>convertColumnIndexToModel</B>(int&nbsp;viewColumnIndex)</PRE>
<DL>
<DD>식별자 객체 <code>viewColumnIndex</code> 의 뷰내의 열의 인덱스를, 테이블 모델내의 열의 인덱스에 매핑 합니다. 모델내의 대응하는 열의 인덱스를 돌려줍니다. <code>viewColumnIndex</code> 가 제로보다 작은 경우는,<code>viewColumnIndex</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>viewColumnIndex</CODE> - 뷰내의 열의 인덱스
<DT><B>반환값:</B><DD>모델내의 대응하는 열의 인덱스<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#convertColumnIndexToView(int)"><CODE>convertColumnIndexToView(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="convertColumnIndexToView(int)"><!-- --></A> <H3>
convertColumnIndexToView</H3>
<PRE>
public int <B>convertColumnIndexToView</B>(int&nbsp;modelColumnIndex)</PRE>
<DL>
<DD><code>modelColumnIndex</code> 의 테이블 모델내의 열의 인덱스를, 뷰내의 열의 인덱스에 매핑 합니다. 뷰내의 대응하는 열의 인덱스를 돌려줍니다. 이 열이 표시되어 있지 않은 경우는 -1 을 돌려줍니다. <code>modelColumnIndex</code> 가 제로보다 작은 경우는,<code>modelColumnIndex</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>modelColumnIndex</CODE> - 모델내의 열의 인덱스
<DT><B>반환값:</B><DD>뷰내의 대응하는 열의 인덱스<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#convertColumnIndexToModel(int)"><CODE>convertColumnIndexToModel(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="convertRowIndexToView(int)"><!-- --></A> <H3>
convertRowIndexToView</H3>
<PRE>
public int <B>convertRowIndexToView</B>(int&nbsp;modelRowIndex)</PRE>
<DL>
<DD><code>TableModel</code> 의 행의 인덱스를 뷰에 매핑 합니다. 모델의 인덱스와 뷰의 인덱스가 같은 경우, 모델의 내용은 소트 되지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>modelRowIndex</CODE> - 모델의 행의 인덱스
<DT><B>반환값:</B><DD>뷰내의 대응하는 행의 인덱스,
행이 가시가 아닌 경우는 -1
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - 소트 기능이 유효해,
<code>TableModel</code> 의 행수보다 값의 큰 인덱스가 건네받았을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/TableRowSorter.html" title="javax.swing.table 내의 클래스"><CODE>TableRowSorter</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="convertRowIndexToModel(int)"><!-- --></A> <H3>
convertRowIndexToModel</H3>
<PRE>
public int <B>convertRowIndexToModel</B>(int&nbsp;viewRowIndex)</PRE>
<DL>
<DD>뷰의 행의 인덱스를 부하의 <code>TableModel</code> 에 매핑 합니다. 모델의 인덱스와 뷰의 인덱스가 같은 경우, 모델의 내용은 소트 되지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>viewRowIndex</CODE> - 뷰내의 행의 인덱스
<DT><B>반환값:</B><DD>모델내의 대응하는 행의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - 소트 기능이 유효해,
<code>getRowCount</code> 메소드의 결정에 따라
<code>JTable</code> 의 범위보다 값의 큰 인덱스가 건네받았을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/TableRowSorter.html" title="javax.swing.table 내의 클래스"><CODE>TableRowSorter</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#getRowCount()"><CODE>getRowCount()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRowCount()"><!-- --></A> <H3>
getRowCount</H3>
<PRE>
public int <B>getRowCount</B>()</PRE>
<DL>
<DD>스페이스에 제한이 없는 경우,<code>JTable</code> 에 표시할 수 있는 행수를 돌려줍니다. 필터와 함께 <code>RowSorter</code> 가 지정되었을 경우는, 반환되는 행수가 부하의 <code>TableModel</code> 에 의해 반환되는 행수와 다를 가능성이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>JTable</code> 에 표시되는 행수<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getColumnCount()"><CODE>getColumnCount()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getColumnCount()"><!-- --></A> <H3>
getColumnCount</H3>
<PRE>
public int <B>getColumnCount</B>()</PRE>
<DL>
<DD>열모델내의 렬수를 돌려줍니다. 다만, 이것은 테이블 모델내의 렬수와는 다른 경우가 있을테니 주의해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블내의 렬수<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getRowCount()"><CODE>getRowCount()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#removeColumn(javax.swing.table.TableColumn)"><CODE>removeColumn(javax.swing.table.TableColumn)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getColumnName(int)"><!-- --></A> <H3>
getColumnName</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getColumnName</B>(int&nbsp;column)</PRE>
<DL>
<DD>열위치 <code>column</code> 의 뷰에 표시되는 열의 이름을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>column</CODE> - 조회되는 뷰의 열
<DT><B>반환값:</B><DD>뷰내의 <code>column</code> 위치의 렬명. 최초의 열은 column 0</DL>
</DD>
</DL>
<HR>

<A NAME="getColumnClass(int)"><!-- --></A> <H3>
getColumnClass</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>getColumnClass</B>(int&nbsp;column)</PRE>
<DL>
<DD>열위치 <code>column</code> 의 뷰에 표시되는 열의 형태를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>column</CODE> - 조회되는 뷰의 열
<DT><B>반환값:</B><DD>뷰내의 <code>column</code> 에 있는 열의 종류
                (최초의 열은 열 0)</DL>
</DD>
</DL>
<HR>

<A NAME="getValueAt(int, int)"><!-- --></A> <H3>
getValueAt</H3>
<PRE>
public <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getValueAt</B>(int&nbsp;row,
                         int&nbsp;column)</PRE>
<DL>
<DD><code>row</code>,<code>column</code> 에 위치하는 셀치를 돌려줍니다.  &nbsp;<p>
<b>주</b>:렬은 테이브르뷰의 표시순서로 지정되어<code>TableModel</code> 의 렬순에서는 지정되지 않습니다. 사용자가 테이블내의 열을 다시 배열하면(자) 뷰내의 지정된 인덱스의 열이 변경되기 (위해)때문에, 이것은 중요한 상위가 됩니다. 한편, 사용자의 액션은 모델의 열순서부에 영향을 미치지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 치가 조회되는 행<DD><CODE>column</CODE> - 치가 조회되는 열
<DT><B>반환값:</B><DD>지정된 셀의 Object</DL>
</DD>
</DL>
<HR>

<A NAME="setValueAt(java.lang.Object, int, int)"><!-- --></A> <H3>
setValueAt</H3>
<PRE>
public void <B>setValueAt</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;aValue,
                       int&nbsp;row,
                       int&nbsp;column)</PRE>
<DL>
<DD>테이블 모델내의 <code>row</code>,<code>column</code> 에 위치하는 셀의 값을 설정합니다.  &nbsp;<p>
<b>주</b>:렬은 테이브르뷰의 표시순서로 지정되어<code>TableModel</code> 의 렬순에서는 지정되지 않습니다. 사용자가 테이블내의 열을 다시 배열하면(자) 뷰내의 지정된 인덱스의 열이 변경되기 (위해)때문에, 이것은 중요한 상위가 됩니다. 한편, 사용자의 액션은 모델의 열순서부에 영향을 미치지 않습니다.

<code>aValue</code> 는 새로운 값입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aValue</CODE> - 새로운 값<DD><CODE>row</CODE> - 변경되는 셀의 행<DD><CODE>column</CODE> - 변경되는 셀의 열<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getValueAt(int, int)"><CODE>getValueAt(int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isCellEditable(int, int)"><!-- --></A> <H3>
isCellEditable</H3>
<PRE>
public boolean <B>isCellEditable</B>(int&nbsp;row,
                              int&nbsp;column)</PRE>
<DL>
<DD><code>row</code>,<code>column</code> 에 위치하는 셀이 편집 가능한 경우에 true 를 돌려줍니다. 그렇지 않은 경우는, 셀의 <code>setValueAt</code> 를 호출해도 영향을 주지 않습니다.  &nbsp;<p>
<b>주</b>:렬은 테이브르뷰의 표시순서로 지정되어<code>TableModel</code> 의 렬순에서는 지정되지 않습니다. 사용자가 테이블내의 열을 다시 배열하면(자) 뷰내의 지정된 인덱스의 열이 변경되기 (위해)때문에, 이것은 중요한 상위가 됩니다. 한편, 사용자의 액션은 모델의 열순서부에 영향을 미치지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 치가 조회되는 행<DD><CODE>column</CODE> - 치가 조회되는 열
<DT><B>반환값:</B><DD>셀이 편집 가능한 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setValueAt(java.lang.Object, int, int)"><CODE>setValueAt(java.lang.Object, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="addColumn(javax.swing.table.TableColumn)"><!-- --></A> <H3>
addColumn</H3>
<PRE>
public void <B>addColumn</B>(<A HREF="../../javax/swing/table/TableColumn.html" title="javax.swing.table 안의 클래스">TableColumn</A> &nbsp;aColumn)</PRE>
<DL>
<DD>이 <code>JTable</code> 의 열모델이 보관 유지하는 열의 배열의 말미에 <code>aColumn</code> 를 추가합니다. <code>aColumn</code> 의 렬명이 <code>null</code> 의 경우,<code>aColumn</code> 의 렬명을 <code>getModel(). getColumnName()</code> 가 돌려주는 이름으로 설정합니다.
  <p>
이 <code>JTable</code> 에 열을 추가해, 지정된 <code>width</code>,<code>cellRenderer</code>, 및 <code>cellEditor</code> 를 사용해 모델내의 <code>modelColumn</code> 번째의 열의 데이터를 표시하기 위해서, 이하를 사용할 수 있습니다.
  <pre>

      addColumn(new TableColumn(modelColumn, width, cellRenderer, cellEditor));


  </pre>
<code>TableColumn</code> 생성자 을 어떤 것에서도 대신에 사용할 수 있습니다. 모델열번호는 <code>TableColumn</code> 내부에 포함되어 모델내의 적절한 데이터값를 찾아내기 위해서(때문에) draw시와 편집시에 사용됩니다. 모델열번호는, 열을 뷰내로 나란해질 수 있는 바꿀 때도 변경되지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aColumn</CODE> - 추가되는 <code>TableColumn</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#removeColumn(javax.swing.table.TableColumn)"><CODE>removeColumn(javax.swing.table.TableColumn)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="removeColumn(javax.swing.table.TableColumn)"><!-- --></A> <H3>
removeColumn</H3>
<PRE>
public void <B>removeColumn</B>(<A HREF="../../javax/swing/table/TableColumn.html" title="javax.swing.table 안의 클래스">TableColumn</A> &nbsp;aColumn)</PRE>
<DL>
<DD><code>aColumn</code> 를 이 <code>JTable</code> 의 열배열로부터 삭제합니다. 주:이 메소드는, 모델로부터 열의 데이터를 삭제할 것은 없습니다. 열의 데이터의 표시를 행하고 있던 <code>TableColumn</code> 만을 삭제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aColumn</CODE> - 삭제되는 <code>TableColumn</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#addColumn(javax.swing.table.TableColumn)"><CODE>addColumn(javax.swing.table.TableColumn)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="moveColumn(int, int)"><!-- --></A> <H3>
moveColumn</H3>
<PRE>
public void <B>moveColumn</B>(int&nbsp;column,
                       int&nbsp;targetColumn)</PRE>
<DL>
<DD><code>column</code> 의 열을, 뷰내의 <code>targetColumn</code> 의 열이 현재 차지하는 위치로 이동합니다. <code>targetColumn</code> 의 종래의 열은 빈 곳을 만들기 위해서(때문에) 왼쪽 또는 오른쪽으로 쉬프트 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>column</CODE> - 이동하는 열의 인덱스<DD><CODE>targetColumn</CODE> - 열의 새로운 인덱스</DL>
</DD>
</DL>
<HR>

<A NAME="columnAtPoint(java.awt.Point)"><!-- --></A> <H3>
columnAtPoint</H3>
<PRE>
public int <B>columnAtPoint</B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;point)</PRE>
<DL>
<DD><code>point</code> 가 존재하는 경우는 그 열의 인덱스, 결과가 [0, <code>getColumnCount()</code>-1] 의 범위내에 없는 경우는 -1 을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>point</CODE> - 대상의 위치
<DT><B>반환값:</B><DD><code>point</code> 가 존재하는 경우는 그 열의 인덱스, 결과가 [0, <code>getColumnCount()</code>-1] 의 범위내에 없는 경우는 -1<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#rowAtPoint(java.awt.Point)"><CODE>rowAtPoint(java.awt.Point)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="rowAtPoint(java.awt.Point)"><!-- --></A> <H3>
rowAtPoint</H3>
<PRE>
public int <B>rowAtPoint</B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;point)</PRE>
<DL>
<DD><code>point</code> 가 존재하는 경우는 그 행의 인덱스, 결과가 [0, <code>getRowCount()</code>-1] 의 범위내에 없는 경우는 -1 을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>point</CODE> - 대상의 위치
<DT><B>반환값:</B><DD><code>point</code> 가 존재하는 행의 인덱스,
결과가
[0, <code>getRowCount()</code>-1] 의 범위내에 없는 경우는 -1<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#columnAtPoint(java.awt.Point)"><CODE>columnAtPoint(java.awt.Point)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getCellRect(int, int, boolean)"><!-- --></A> <H3>
getCellRect</H3>
<PRE>
public <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getCellRect</B>(int&nbsp;row,
                             int&nbsp;column,
                             boolean&nbsp;includeSpacing)</PRE>
<DL>
<DD><code>row</code> 와 <code>column</code> 가 교차하는 위치의 셀의 구형을 돌려줍니다. <code>includeSpacing</code> 가 true 의 경우, 반환되는 값은 지정된 행과 열의 전높이로 전폭을 포함합니다. false 의 경우, 반환되는 구형은 셀의 간격에 의해 인 세트 되어 draw때 설정되는 draw 컴퍼넌트 또는 편집 컴퍼넌트의 진정한 경계가 돌려주어집니다.  &nbsp;<p>
열인덱스가 유효해 행 인덱스가 제로보다 작은 경우, 메소드는,<code>y</code> 치와 <code>height</code> 치가 적절히 설정되어<code>x</code> 치와 <code>width</code> 치가 함께 제로로 설정된 구형을 돌려줍니다. 일반적으로, 행과 열의 어느 쪽인가의 인덱스가 적절한 범위외의 셀을 나타내는 경우, 메소드는 테이블의 범위내에서 가장 가까운 셀의 가장 가까운 인연을 그리는 구형을 돌려줍니다. 행과 열의 인덱스가 어느쪽이나 범위외의 경우, 반환되는 구형은 가장 가까운 셀의 가장 가까운 점을 나타내고 있습니다.  &nbsp;<p>
어느 케이스에서도, 이 메소드를 사용해 1 개의 축으로 맞추어 결과를 요구하는 계산은, 한편의 축에서는 변칙적인 계산을 실시하므로, 실패할 것은 없습니다. 셀이 유효하지 않은 경우,<code>includeSpacing</code> 파라미터는 무시됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 목적의 셀이 놓여져 있는 행 인덱스<DD><CODE>column</CODE> - 화면내에서 목적의 셀이 놓여져 있는 열인덱스.  이 값은, 테이블의 데이터 모델내의 열인덱스와 같다라고는 한정되지 않는다.  데이터 모델의 열인덱스를 화면의 열인덱스로 변환하는 경우는,<A HREF="../../javax/swing/JTable.html#convertColumnIndexToView(int)"><CODE>convertColumnIndexToView(int)</CODE></A>  메소드를 사용할 수 있는<DD><CODE>includeSpacing</CODE> - false 의 경우, 진정한 셀의 경계를 돌려준다. 이 경계는, 열모델과 행 모델의 높이와 폭으로부터 셀의 간격을 당기는 것에 의해 계산된다
<DT><B>반환값:</B><DD><code>row</code>,<code>column</code> 의 위치의 셀을 보관 유지하는 구형<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getIntercellSpacing()"><CODE>getIntercellSpacing()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="doLayout()"><!-- --></A> <H3>
doLayout</H3>
<PRE>
public void <B>doLayout</B>()</PRE>
<DL>
<DD>이 테이블에 행과 열을 레이아웃 시킵니다. 포함하는 부모의 사이즈의 변경에 맞추어 열을 사이즈 변경할 수 있도록(듯이), 오버라이드(override) 됩니다. 이 <code>JTable</code> 의 열전부의 합계폭이 테이블폭에 동일해지도록(듯이), 테이블내의 1 개 또는 복수의 열의 사이즈 변경을 실시합니다.  &nbsp;<p>
배치가 개시되기 전에, 메소드는 <code>tableHeader</code> 의 <code>resizingColumn</code> 를 가져옵니다. 포위측 윈도우의 사이즈 변경의 결과로서, 메소드가 불려 가는 경우는,<code>resizingColumn</code> 는 <code>null</code> 가 됩니다. 이것은, 사이즈 변경이 <code>JTable</code> 의 「외측」에서 일어난 것, 및 변경 (델타)이 이 <code>JTable</code> 의 자동 사이즈 변경 모드에 관계없이 모든 열에 반영되는 것을 의미합니다.  &nbsp;<p>
<code>resizingColumn</code> 가 <code>null</code> 가 아닌 경우는, 테이블 사이즈의 변경은 아니고, 테이블내가 있는 열의 사이즈가 변경된 것을 나타냅니다. 이 경우, 자동 사이즈 변경 모드에 의해, 여분의, 또는 부족한 스페이스가 이용 가능한 모든 열로 배분될 방법이 결정됩니다.  &nbsp;<p>
다음에, 각 모드를 나타냅니다.
 <ul>
<li>  AUTO_RESIZE_OFF -열의 폭을 자동조정 하지 않는다. 열의 합계가 <code>Viewport</code> 의 폭을 넘는 경우는, 수평 스크롤 바를 사용해 그러한 열에 대응한다. <code>JTable</code> 가 <code>JScrollPane</code> 에 둘러싸이지 않은 경우, 테이블의 일부를 불가시대로 하는 일이 있다.
<li>  AUTO_RESIZE_NEXT_COLUMN -사이즈가 변경된 열의 직후의 열을 사용한다. 이 경우, 인접하는 셀의 사이의 「경계」즉 디바이더를 단독으로 조정할 수 있다.
<li>  AUTO_RESIZE_SUBSEQUENT_COLUMNS -조정중의 열의 뒤의 모든 열을 사용해, 변경을 흡수한다. 이것은 디폴트의 동작.
<li>  AUTO_RESIZE_LAST_COLUMN -마지막 열의 사이즈만을 자동조정 한다. 최종열의 경계를 위해서(때문에) 바람직한 사이즈의 할당을 할 수 없는 경우는, 최종열의 폭을 적절한 한도로 설정해 그 이상의 조정은 실시하지 않는다.
<li>  AUTO_RESIZE_ALL_COLUMNS -조정중의 열을 포함한 <code>JTable</code> 내의 모든 열에 델타를 분산시킨다.
 </ul>
 <p>
<bold>주:<code>JTable</code> 가 렬폭을 조정할 때는, 최소치와 최대치를 무조건 고려에 넣습니다. 이 때문에, 이 메소드를 호출한 후에도, 모든 열의 합계폭이 테이블폭에 동일하지 않은 경우가 있습니다. 이 경우,<code>JTable</code> 는 그것 자신으로 AUTO_RESIZE_OFF 모드에 들어가 스크롤 바를 호출하거나 현재의 자동 사이즈 변경 모드에 의한 그 외의 기능을 중단시키거나 할 것은 없습니다.  그 대신해, 경계를 각 열의 최소 또는 최대의 합계보다 크고, 또는 작게 설정할 수 있도록(듯이) 합니다.  즉, 모든 열을 표시할 여유가 없는지, 열이 <code>JTable</code> 의 경계 기에 부족한가의 어느 쪽인지를 의미합니다. 결국, 전자는 일부의 열의 클리핑을 실행해, 후자는 페인트시에 <code>JTable</code> 의 백그라운드 칼라로 영역을 페인트 하게 됩니다.  &nbsp;<p>
유효한 열의 사이에 델타를 분산시키는 기구는,<code>JTable</code> 클래스의 private 메소드로 제공됩니다.
 <pre>
   adjustSizes(long targetSize, final Resizable3 r, boolean inverse)
 </pre>
이 메소드에 대해서는 다음의 섹션으로 설명합니다. <code>Resizable3</code> 는 private 인터페이스이며, 이 인터페이스에 의해, 사이즈, 적절한 사이즈, 최대 사이즈, 및 최소 사이즈를 가지는 요소의 집합을 포함하는 모든 데이터 구조가 알고리즘에 의해 그 요소를 조작할 수 있게 됩니다.  &nbsp;<p>
<H3> 델타의 분산 </H3>
 <p>
<H4> 개요 </H4>
 <P>
타겟 사이즈와 r 내의 요소의 적절한 사이즈의 합계와의 차이를 「DELTA」라고 합니다. 각 사이즈는, 원의 적절한 사이즈의 각각 DELTA 의 할당분을 더해 산출합니다. 각 할당분은, 적절한 사이즈와 그 최소치 또는 최대치 제한 경계와의 사이의 거리에 근거해 정해집니다.  &nbsp;<p>
<H4>정의</H4>
 <P>
각 정수를 min[i], max[i], 및 pref[i] 로 합니다.  &nbsp;<p>
각각의 합계를 MIN, MAX, 및 PREF 로 합니다.  &nbsp;<p>
새로운 사이즈의 계산방법은 다음과 같습니다.  &nbsp;<p>
 <pre>
          size[i] = pref[i] + delta[i]
 </pre>
delta[i] 의 계산방법은 다음과 같습니다.  &nbsp;<p>
(DELTA < 0)의 경우는, 다음과 같은 축소 모드가 됩니다.  &nbsp;<p>
 <PRE>
                        DELTA
          delta[i] = ------------ * (pref[i] - min[i])
                     (PREF - MIN)
 </PRE>
(DELTA > 0)의 경우는, 다음과 같은 확대 모드가 됩니다.  &nbsp;<p>
 <PRE>
                        DELTA
          delta[i] = ------------ * (max[i] - pref[i])
                      (MAX - PREF)
 </PRE>
 <P>
전체적으로, 합계 사이즈는 같은 비율 k 로 합계 최소치 또는 합계 최대치에 가까워져, 그 비율이 필요한 스페이스 DELTA 에 대응하는 것을 보증합니다.

<H4>상세</H4>
 <P>
여기서 제시한 공식의 단순한 평가는, 유한 정밀도 (int 를 사용)로 이 처리를 하는 것에 의해 생기는 사사오입 오차의 영향을 받습니다. 이것에 대응하기 위해서, 전술의 승률이 반복해 계산되어 그 때에 전회의 사사오입 오차가 고려됩니다. 그 결과, 지정된 모든 요소로 균등하게 사사오입 오차를 분산하는 것에 의해, 값의 합계가 정확하게 <code>targetSize</code> 가 되는 일련의 정수를 생성하는 알고리즘이 됩니다.

<H4>MAX 경계 및 MIN 경계에 이르렀을 경우</H4>
 <P>
<code>targetSize</code> 가 [MIN, MAX] 의 범위외의 경우, 이 알고리즘에 의해 모든 사이즈가 각각의 적절한 최대치 또는 최소치의 제한치로 설정됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#doLayout()">doLayout</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/LayoutManager.html#layoutContainer(java.awt.Container)"><CODE>LayoutManager.layoutContainer(java.awt.Container)</CODE></A> , 
<A HREF="../../java/awt/Container.html#setLayout(java.awt.LayoutManager)"><CODE>Container.setLayout(java.awt.LayoutManager)</CODE></A> , 
<A HREF="../../java/awt/Container.html#validate()"><CODE>Container.validate()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sizeColumnsToFit(boolean)"><!-- --></A> <H3>
sizeColumnsToFit</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public void <B>sizeColumnsToFit</B>(boolean&nbsp;lastColumnOnly)</PRE>
<DL>
<DD><B>추천 되고 있지 않습니다. </B>&nbsp;<I>Swing 1.0. 3 이후는,<code>doLayout()</code> 로 옮겨졌습니다. </I>
<P>
<DD>이용 가능한 스페이스에 맞추어 테이블의 열의 사이즈를 변경합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#doLayout()"><CODE>doLayout()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sizeColumnsToFit(int)"><!-- --></A> <H3>
sizeColumnsToFit</H3>
<PRE>
public void <B>sizeColumnsToFit</B>(int&nbsp;resizingColumn)</PRE>
<DL>
<DD>Java 2 플랫폼 v1. 4 에서는 사용하지 않습니다. 대신에 <code>doLayout()</code> 메소드를 사용해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>resizingColumn</CODE> - 사이즈 변경으로 이 조정을 필요로 하는 열.
들어맞는 열이 없는 경우는 -1<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#doLayout()"><CODE>doLayout()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getToolTipText(java.awt.event.MouseEvent)"><!-- --></A> <H3>
getToolTipText</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getToolTipText</B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</PRE>
<DL>
<DD><code>JComponent</code> 의 <code>getToolTipText</code> 메소드를 오버라이드(override) 해, 텍스트 세트가 있는 경우, 렌더링의 힌트를 사용할 수 있도록(듯이) 합니다.  &nbsp;<p>
<bold>주:<code>JTable</code> 가 렌더링의 툴팁를 적절히 표시할 수 있도록(듯이) 하려면 ,<code>JTable</code> 가 <code>ToolTipManager</code> 에 등록을 마친 컴퍼넌트가 아니면 안됩니다. 이것은 <code>initializeLocalVars</code> 로 자동적으로 행해집니다만, 나중에 <code>JTable</code> 에 <code>setToolTipText(null)</code> 를 통지하면(자), 테이블 컴퍼넌트를 등록 해제하므로, 렌더링으로부터의 힌트는 그 이상 표시되지 않습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#getToolTipText(java.awt.event.MouseEvent)">getToolTipText</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getToolTipText()"><CODE>JComponent.getToolTipText()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSurrendersFocusOnKeystroke(boolean)"><!-- --></A> <H3>
setSurrendersFocusOnKeystroke</H3>
<PRE>
public void <B>setSurrendersFocusOnKeystroke</B>(boolean&nbsp;surrendersFocusOnKeystroke)</PRE>
<DL>
<DD>JTable 가 셀의 키보드 이벤트를 전송 한 결과적으로, 이 JTable 의 에디터가 키보드 포커스를 취득할지 어떨지를 설정합니다. 디폴트에서는, 이 프로퍼티은 false 입니다. JTable 는 셀이 클릭될 때까지 포커스를 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>surrendersFocusOnKeystroke</CODE> - 키스트로크(keystroke)에 의해 에디터가 액티브하게 되었을 때,
에디터가 포커스를 취득한다
경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getSurrendersFocusOnKeystroke()"><CODE>getSurrendersFocusOnKeystroke()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSurrendersFocusOnKeystroke()"><!-- --></A> <H3>
getSurrendersFocusOnKeystroke</H3>
<PRE>
public boolean <B>getSurrendersFocusOnKeystroke</B>()</PRE>
<DL>
<DD>키보드가 에디터를 액티브화했을 때에 에디터가 포커스를 취득하는 경우는 true 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>키스트로크(keystroke)에 의해 에디터가 액티브하게 되었을 때,
에디터가 포커스를 취득한다
경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setSurrendersFocusOnKeystroke(boolean)"><CODE>setSurrendersFocusOnKeystroke(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="editCellAt(int, int)"><!-- --></A> <H3>
editCellAt</H3>
<PRE>
public boolean <B>editCellAt</B>(int&nbsp;row,
                          int&nbsp;column)</PRE>
<DL>
<DD><code>row</code>,<code>column</code> 에 위치하는 셀의 인덱스가 유효한 범위내에 있어, 그 위치에 있는 셀이 편집 가능한 경우는, 셀의 편집을 프로그램에 근거해 개시합니다. 이것은 <code>editCellAt(int, int, null)</code> 의 편리한 메소드입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 편집하는 행<DD><CODE>column</CODE> - 편집하는 열
<DT><B>반환값:</B><DD>하등의 이유로써 셀을 편집할 수 없는 경우, 또는 인덱스가 무효인 경우는 false</DL>
</DD>
</DL>
<HR>

<A NAME="editCellAt(int, int, java.util.EventObject)"><!-- --></A> <H3>
editCellAt</H3>
<PRE>
public boolean <B>editCellAt</B>(int&nbsp;row,
                          int&nbsp;column,
                          <A HREF="../../java/util/EventObject.html" title="java.util 안의 클래스">EventObject</A> &nbsp;e)</PRE>
<DL>
<DD><code>row</code>,<code>column</code> 에 위치하는 셀의 인덱스가 유효한 범위내에 있어, 그 위치에 있는 셀이 편집 가능한 경우는, 셀의 편집을 프로그램에 근거해 개시합니다. <code>JTable</code> 가 특정의 테이블, 열, 또는 셀의 값을 편집할 수 없게 하려면 ,<code>TableModel</code> 인터페이스의 <code>isCellEditable</code> 메소드로부터 false 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 편집하는 행<DD><CODE>column</CODE> - 편집하는 열<DD><CODE>e</CODE> - <code>shouldSelectCell</code> 에게 건네지는 이벤트.
Java 2 플랫폼 v1. 2 이후,
<code>shouldSelectCell</code> 는 불려 가지 않게 되었다
<DT><B>반환값:</B><DD>하등의 이유로써 셀을 편집할 수 없는 경우, 또는 인덱스가 무효인 경우는 false</DL>
</DD>
</DL>
<HR>

<A NAME="isEditing()"><!-- --></A> <H3>
isEditing</H3>
<PRE>
public boolean <B>isEditing</B>()</PRE>
<DL>
<DD>셀을 편집중의 경우는 true 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블이 셀을 편집중의 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#editingColumn"><CODE>editingColumn</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#editingRow"><CODE>editingRow</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getEditorComponent()"><!-- --></A> <H3>
getEditorComponent</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A>  <B>getEditorComponent</B>()</PRE>
<DL>
<DD>편집 세션을 처리하고 있는 컴퍼넌트를 돌려줍니다. 아무것도 편집하고 있지 않는 경우는 null 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>편집 세션을 처리하는 Component</DL>
</DD>
</DL>
<HR>

<A NAME="getEditingColumn()"><!-- --></A> <H3>
getEditingColumn</H3>
<PRE>
public int <B>getEditingColumn</B>()</PRE>
<DL>
<DD>현재 편집중의 셀을 포함한 열의 인덱스를 돌려줍니다. 아무것도 편집하고 있지 않는 경우는 -1 을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재 편집중의 셀을 포함한 열의 인덱스.
                아무것도 편집하고 있지 않는 경우는 -1 을 돌려주는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#editingRow"><CODE>editingRow</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getEditingRow()"><!-- --></A> <H3>
getEditingRow</H3>
<PRE>
public int <B>getEditingRow</B>()</PRE>
<DL>
<DD>현재 편집중의 셀을 포함한 행의 인덱스를 돌려줍니다. 아무것도 편집하고 있지 않는 경우는 -1 을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재 편집중의 셀을 포함한 행의 인덱스.
                아무것도 편집하고 있지 않는 경우는 -1 을 돌려주는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#editingColumn"><CODE>editingColumn</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getUI()"><!-- --></A> <H3>
getUI</H3>
<PRE>
public <A HREF="../../javax/swing/plaf/TableUI.html" title="javax.swing.plaf 내의 클래스">TableUI</A>  <B>getUI</B>()</PRE>
<DL>
<DD>이 컴퍼넌트를 draw 하는 L&F 객체를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트를 draw 하는 <code>TableUI</code> 객체</DL>
</DD>
</DL>
<HR>

<A NAME="setUI(javax.swing.plaf.TableUI)"><!-- --></A> <H3>
setUI</H3>
<PRE>
public void <B>setUI</B>(<A HREF="../../javax/swing/plaf/TableUI.html" title="javax.swing.plaf 안의 클래스">TableUI</A> &nbsp;ui)</PRE>
<DL>
<DD>이 컴퍼넌트를 draw 해 페인트 다시 하는 L&F 객체를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ui</CODE> - TableUI L&F 객체<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/UIDefaults.html#getUI(javax.swing.JComponent)"><CODE>UIDefaults.getUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="updateUI()"><!-- --></A> <H3>
updateUI</H3>
<PRE>
public void <B>updateUI</B>()</PRE>
<DL>
<DD>L&F 가 변경되었다고 하는 <code>UIManager</code> 로부터의 통지입니다. 현재의 UI 객체를 <code>UIManager</code> 의 최신 버젼에 옮겨놓습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#updateUI()">updateUI</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#updateUI()"><CODE>JComponent.updateUI()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getUIClassID()"><!-- --></A> <H3>
getUIClassID</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getUIClassID</B>()</PRE>
<DL>
<DD>Look & Feel 클래스의 이름의 구축에 사용된 접미사(suffix)을 돌려줍니다. 이 클래스는, 이 컴퍼넌트를 draw 하는데 사용됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#getUIClassID()">getUIClassID</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>TableUI 의 캐릭터 라인<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getUIClassID()"><CODE>JComponent.getUIClassID()</CODE></A> , 
<A HREF="../../javax/swing/UIDefaults.html#getUI(javax.swing.JComponent)"><CODE>UIDefaults.getUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setModel(javax.swing.table.TableModel)"><!-- --></A> <H3>
setModel</H3>
<PRE>
public void <B>setModel</B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dataModel)</PRE>
<DL>
<DD>이 테이블의 데이터 모델을 <code>newModel</code> 로 설정해, 거기에 새로운 데이터 모델로부터의 청취자 통지를 등록합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>dataModel</CODE> - 이 테이블의 새로운 데이터 소스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>newModel</code> 가 <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getModel()"><CODE>getModel()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getModel()"><!-- --></A> <H3>
getModel</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A>  <B>getModel</B>()</PRE>
<DL>
<DD>이 <code>JTable</code> 가 표시하는 데이터를 제공하는 <code>TableModel</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>JTable</code> 가 표시하는 데이터를 제공하는 <code>TableModel</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setModel(javax.swing.table.TableModel)"><CODE>setModel(javax.swing.table.TableModel)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setColumnModel(javax.swing.table.TableColumnModel)"><!-- --></A> <H3>
setColumnModel</H3>
<PRE>
public void <B>setColumnModel</B>(<A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 안의 인터페이스">TableColumnModel</A> &nbsp;columnModel)</PRE>
<DL>
<DD>이 테이블의 열모델을 <code>newModel</code> 로 설정해, 새로운 열모델로부터의 청취자 통지를 등록합니다. 또,<code>JTableHeader</code> 의 열모델을 <code>columnModel</code> 로 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnModel</CODE> - 이 테이블의 새로운 데이터 소스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>columnModel</code> 가 <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getColumnModel()"><CODE>getColumnModel()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getColumnModel()"><!-- --></A> <H3>
getColumnModel</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 내의 인터페이스">TableColumnModel</A>  <B>getColumnModel</B>()</PRE>
<DL>
<DD>이 테이블의 모든 열정보를 보관 유지하는 <code>TableColumnModel</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블의 열 상태를 제공하는 객체<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setColumnModel(javax.swing.table.TableColumnModel)"><CODE>setColumnModel(javax.swing.table.TableColumnModel)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSelectionModel(javax.swing.ListSelectionModel)"><!-- --></A> <H3>
setSelectionModel</H3>
<PRE>
public void <B>setSelectionModel</B>(<A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 안의 인터페이스">ListSelectionModel</A> &nbsp;newModel)</PRE>
<DL>
<DD>이 테이블의 행 선택 모델을 <code>newModel</code> 로 설정해, 새로운 선택 모델로부터의 청취자 통지를 등록합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newModel</CODE> - 새로운 선택 모델
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>newModel</code> 가 <code>null</code> 의 경우<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getSelectionModel()"><CODE>getSelectionModel()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSelectionModel()"><!-- --></A> <H3>
getSelectionModel</H3>
<PRE>
public <A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스">ListSelectionModel</A>  <B>getSelectionModel</B>()</PRE>
<DL>
<DD>행 선택 상태를 유지하는데 사용하는 <code>ListSelectionModel</code> 를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행의 선택 상태를 제공하는 객체. 행의 선택이 허가되어 있지 않은 경우는 <code>null</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setSelectionModel(javax.swing.ListSelectionModel)"><CODE>setSelectionModel(javax.swing.ListSelectionModel)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sorterChanged(javax.swing.event.RowSorterEvent)"><!-- --></A> <H3>
sorterChanged</H3>
<PRE>
public void <B>sorterChanged</B>(<A HREF="../../javax/swing/event/RowSorterEvent.html" title="javax.swing.event 안의 클래스">RowSorterEvent</A> &nbsp;e)</PRE>
<DL>
<DD><code>RowSorter</code> 가 변경된 것을 알리는 <code>RowSorterListener</code> 통지입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/RowSorterListener.html" title="javax.swing.event 내의 인터페이스">RowSorterListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/RowSorterListener.html#sorterChanged(javax.swing.event.RowSorterEvent)">sorterChanged</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 변경을 설명하는 <code>RowSorterEvent</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>e</code> 가 <code>null</code> 의 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="tableChanged(javax.swing.event.TableModelEvent)"><!-- --></A> <H3>
tableChanged</H3>
<PRE>
public void <B>tableChanged</B>(<A HREF="../../javax/swing/event/TableModelEvent.html" title="javax.swing.event 안의 클래스">TableModelEvent</A> &nbsp;e)</PRE>
<DL>
<DD>이 테이블의 <code>TableModel</code> 이 <code>TableModelEvent</code> 를 생성할 경우에 불려 갑니다. <code>TableModelEvent</code> 는 모델의 좌표계로 구축되어 이벤트 수신시에 <code>JTable</code> 가 뷰 좌표계에의 적절한 매핑을 실행합니다.  &nbsp;<p>
어플리케이션 코드는 이러한 메소드를 명시적으로는 사용하지 않습니다. 이러한 메소드는 <code>JTable</code> 가 내부적으로 사용합니다.  &nbsp;<p>
JDK Version 1.3 에서는, 이 메소드는, 필요에 따라서 선택 상태가 해제됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/TableModelListener.html" title="javax.swing.event 내의 인터페이스">TableModelListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/TableModelListener.html#tableChanged(javax.swing.event.TableModelEvent)">tableChanged</A> </CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="columnAdded(javax.swing.event.TableColumnModelEvent)"><!-- --></A> <H3>
columnAdded</H3>
<PRE>
public void <B>columnAdded</B>(<A HREF="../../javax/swing/event/TableColumnModelEvent.html" title="javax.swing.event 안의 클래스">TableColumnModelEvent</A> &nbsp;e)</PRE>
<DL>
<DD>테이블열모델에 열이 추가될 때 불려 갑니다.  &nbsp;<p>
어플리케이션 코드는 이러한 메소드를 명시적으로는 사용하지 않습니다. 이러한 메소드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스">TableColumnModelListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html#columnAdded(javax.swing.event.TableColumnModelEvent)">columnAdded</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스"><CODE>TableColumnModelListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="columnRemoved(javax.swing.event.TableColumnModelEvent)"><!-- --></A> <H3>
columnRemoved</H3>
<PRE>
public void <B>columnRemoved</B>(<A HREF="../../javax/swing/event/TableColumnModelEvent.html" title="javax.swing.event 안의 클래스">TableColumnModelEvent</A> &nbsp;e)</PRE>
<DL>
<DD>열이 테이블열모델로부터 삭제될 때 불려 갑니다.  &nbsp;<p>
어플리케이션 코드는 이러한 메소드를 명시적으로는 사용하지 않습니다. 이러한 메소드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스">TableColumnModelListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html#columnRemoved(javax.swing.event.TableColumnModelEvent)">columnRemoved</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스"><CODE>TableColumnModelListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="columnMoved(javax.swing.event.TableColumnModelEvent)"><!-- --></A> <H3>
columnMoved</H3>
<PRE>
public void <B>columnMoved</B>(<A HREF="../../javax/swing/event/TableColumnModelEvent.html" title="javax.swing.event 안의 클래스">TableColumnModelEvent</A> &nbsp;e)</PRE>
<DL>
<DD>열이 재배치되면(자) 불려 갑니다. 셀이 편집중의 경우, 편집은 정지해 셀이 재차 draw 됩니다.  &nbsp;<p>
어플리케이션 코드는 이러한 메소드를 명시적으로는 사용하지 않습니다. 이러한 메소드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스">TableColumnModelListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html#columnMoved(javax.swing.event.TableColumnModelEvent)">columnMoved</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 받은 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스"><CODE>TableColumnModelListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="columnMarginChanged(javax.swing.event.ChangeEvent)"><!-- --></A> <H3>
columnMarginChanged</H3>
<PRE>
public void <B>columnMarginChanged</B>(<A HREF="../../javax/swing/event/ChangeEvent.html" title="javax.swing.event 안의 클래스">ChangeEvent</A> &nbsp;e)</PRE>
<DL>
<DD>마진의 변경을 위해서(때문에) 열이 이동될 때 불려 갑니다. 셀이 편집중의 경우, 편집은 정지해 셀이 재차 draw 됩니다.  &nbsp;<p>
어플리케이션 코드는 이러한 메소드를 명시적으로는 사용하지 않습니다. 이러한 메소드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스">TableColumnModelListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html#columnMarginChanged(javax.swing.event.ChangeEvent)">columnMarginChanged</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 받은 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스"><CODE>TableColumnModelListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="columnSelectionChanged(javax.swing.event.ListSelectionEvent)"><!-- --></A> <H3>
columnSelectionChanged</H3>
<PRE>
public void <B>columnSelectionChanged</B>(<A HREF="../../javax/swing/event/ListSelectionEvent.html" title="javax.swing.event 안의 클래스">ListSelectionEvent</A> &nbsp;e)</PRE>
<DL>
<DD><code>TableColumnModel</code> 의 선택 모델이 변경될 때 불려 갑니다.  &nbsp;<p>
어플리케이션 코드는 이러한 메소드를 명시적으로는 사용하지 않습니다. 이러한 메소드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스">TableColumnModelListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html#columnSelectionChanged(javax.swing.event.ListSelectionEvent)">columnSelectionChanged</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 받은 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스"><CODE>TableColumnModelListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="valueChanged(javax.swing.event.ListSelectionEvent)"><!-- --></A> <H3>
valueChanged</H3>
<PRE>
public void <B>valueChanged</B>(<A HREF="../../javax/swing/event/ListSelectionEvent.html" title="javax.swing.event 안의 클래스">ListSelectionEvent</A> &nbsp;e)</PRE>
<DL>
<DD>행의 선택 영역이 변경되었을 때에 불려 가 페인트 다시 해 새로운 선택 영역을 나타냅니다.  &nbsp;<p>
어플리케이션 코드는 이러한 메소드를 명시적으로는 사용하지 않습니다. 이러한 메소드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/ListSelectionListener.html" title="javax.swing.event 내의 인터페이스">ListSelectionListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/ListSelectionListener.html#valueChanged(javax.swing.event.ListSelectionEvent)">valueChanged</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 받은 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/ListSelectionListener.html" title="javax.swing.event 내의 인터페이스"><CODE>ListSelectionListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="editingStopped(javax.swing.event.ChangeEvent)"><!-- --></A> <H3>
editingStopped</H3>
<PRE>
public void <B>editingStopped</B>(<A HREF="../../javax/swing/event/ChangeEvent.html" title="javax.swing.event 안의 클래스">ChangeEvent</A> &nbsp;e)</PRE>
<DL>
<DD>편집이 완료했을 때에 불려 갑니다. 변경은 보존되어 에디터는 파기됩니다.  &nbsp;<p>
어플리케이션 코드는 이러한 메소드를 명시적으로는 사용하지 않습니다. 이러한 메소드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/CellEditorListener.html" title="javax.swing.event 내의 인터페이스">CellEditorListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/CellEditorListener.html#editingStopped(javax.swing.event.ChangeEvent)">editingStopped</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 받은 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/CellEditorListener.html" title="javax.swing.event 내의 인터페이스"><CODE>CellEditorListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="editingCanceled(javax.swing.event.ChangeEvent)"><!-- --></A> <H3>
editingCanceled</H3>
<PRE>
public void <B>editingCanceled</B>(<A HREF="../../javax/swing/event/ChangeEvent.html" title="javax.swing.event 안의 클래스">ChangeEvent</A> &nbsp;e)</PRE>
<DL>
<DD>편집이 삭제되면(자) 불려 갑니다. 에디터 객체가 파기되어 셀이 한번 더 draw 됩니다.  &nbsp;<p>
어플리케이션 코드는 이러한 메소드를 명시적으로는 사용하지 않습니다. 이러한 메소드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/CellEditorListener.html" title="javax.swing.event 내의 인터페이스">CellEditorListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/CellEditorListener.html#editingCanceled(javax.swing.event.ChangeEvent)">editingCanceled</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 받은 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/CellEditorListener.html" title="javax.swing.event 내의 인터페이스"><CODE>CellEditorListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPreferredScrollableViewportSize(java.awt.Dimension)"><!-- --></A> <H3>
setPreferredScrollableViewportSize</H3>
<PRE>
public void <B>setPreferredScrollableViewportSize</B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;size)</PRE>
<DL>
<DD>이 테이블의 뷰포트의 바람직한 사이즈를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>size</CODE> - 뷰가 이 테이블인 <code>JViewport</code> 의 <code>preferredSize</code> 를 지정하는 <code>Dimension</code> 객체<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/Scrollable.html#getPreferredScrollableViewportSize()"><CODE>Scrollable.getPreferredScrollableViewportSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPreferredScrollableViewportSize()"><!-- --></A> <H3>
getPreferredScrollableViewportSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getPreferredScrollableViewportSize</B>()</PRE>
<DL>
<DD>이 테이블의 뷰포트의 바람직한 사이즈를 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/Scrollable.html" title="javax.swing 내의 인터페이스">Scrollable</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/Scrollable.html#getPreferredScrollableViewportSize()">getPreferredScrollableViewportSize</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 테이블을 표시하는 <code>JViewport</code> 의 <code>preferredSize</code> 를 보관 유지하는 <code>Dimension</code> 객체<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/Scrollable.html#getPreferredScrollableViewportSize()"><CODE>Scrollable.getPreferredScrollableViewportSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getScrollableUnitIncrement(java.awt.Rectangle, int, int)"><!-- --></A> <H3>
getScrollableUnitIncrement</H3>
<PRE>
public int <B>getScrollableUnitIncrement</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;visibleRect,
                                      int&nbsp;orientation,
                                      int&nbsp;direction)</PRE>
<DL>
<DD>새로운 1 행 또는 1 열을 완전하게 표시하는 스크롤 증분치를 (방향에 근거해) 픽셀 단위로 돌려줍니다.  &nbsp;<p>
이 메소드는, 사용자가 단위 스크롤을 요구할 때마다 불려 갑니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/Scrollable.html" title="javax.swing 내의 인터페이스">Scrollable</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/Scrollable.html#getScrollableUnitIncrement(java.awt.Rectangle, int, int)">getScrollableUnitIncrement</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>visibleRect</CODE> - 뷰포트내의 가시의 뷰 영역<DD><CODE>orientation</CODE> - <code>SwingConstants.VERTICAL</code>
        또는 <code>SwingConstants.HORIZONTAL</code><DD><CODE>direction</CODE> - 상또는왼쪽으로 스크롤 하는 경우는 0 보다 작은 값,
아래 또는 오른쪽으로 스크롤 하는 경우는 제로보다 큰 값
<DT><B>반환값:</B><DD>지정된 방향으로 스크롤하기 위한 「유니트」증분치<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/Scrollable.html#getScrollableUnitIncrement(java.awt.Rectangle, int, int)"><CODE>Scrollable.getScrollableUnitIncrement(java.awt.Rectangle, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getScrollableBlockIncrement(java.awt.Rectangle, int, int)"><!-- --></A> <H3>
getScrollableBlockIncrement</H3>
<PRE>
public int <B>getScrollableBlockIncrement</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;visibleRect,
                                       int&nbsp;orientation,
                                       int&nbsp;direction)</PRE>
<DL>
<DD>이 테이블의 방향에 의해 <code>visibleRect.height</code> 또는 <code>visibleRect.width</code> 를 돌려줍니다. Swing 1.1. 1 (Java 2 v 1.2. 2)로부터는, 반환되는 값에 의해 관점(전망)이 행의 경계에 명확하게 배치되게 되었습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/Scrollable.html" title="javax.swing 내의 인터페이스">Scrollable</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/Scrollable.html#getScrollableBlockIncrement(java.awt.Rectangle, int, int)">getScrollableBlockIncrement</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>visibleRect</CODE> - 뷰포트내의 가시의 뷰 영역<DD><CODE>orientation</CODE> - SwingConstants.VERTICAL 또는 SwingConstants.HORIZONTAL<DD><CODE>direction</CODE> - 상또는왼쪽으로 스크롤 하는 경우는 0 보다 작고, 아래 또는 오른쪽으로 스크롤 하는 경우는 0 보다 크다
<DT><B>반환값:</B><DD>방향에 의해,<code>visibleRect.height</code> 또는
                                        <code>visibleRect.width</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/Scrollable.html#getScrollableBlockIncrement(java.awt.Rectangle, int, int)"><CODE>Scrollable.getScrollableBlockIncrement(java.awt.Rectangle, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getScrollableTracksViewportWidth()"><!-- --></A> <H3>
getScrollableTracksViewportWidth</H3>
<PRE>
public boolean <B>getScrollableTracksViewportWidth</B>()</PRE>
<DL>
<DD><code>autoResizeMode</code> 가 <code>AUTO_RESIZE_OFF</code> 로 설정되어 있는 경우는 false 를 돌려줍니다.  이것은 뷰포트의 폭이 테이블의 폭을 결정하지 않는 것을 나타냅니다. 그 이외의 경우는 true 를 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/Scrollable.html" title="javax.swing 내의 인터페이스">Scrollable</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/Scrollable.html#getScrollableTracksViewportWidth()">getScrollableTracksViewportWidth</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>autoResizeMode</code> 이
<code>AUTO_RESIZE_OFF</code> 로 설정되어 있는 경우는 false, 그렇지 않은 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/Scrollable.html#getScrollableTracksViewportWidth()"><CODE>Scrollable.getScrollableTracksViewportWidth()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getScrollableTracksViewportHeight()"><!-- --></A> <H3>
getScrollableTracksViewportHeight</H3>
<PRE>
public boolean <B>getScrollableTracksViewportHeight</B>()</PRE>
<DL>
<DD><code>getFillsViewportHeight</code> 가 <code>true</code> 로, 테이블의 적절한 높이가 뷰포트의 높이보다 낮은 경우를 제외해,<code>false</code> 를 돌려주어, 뷰포트의 높이가 테이블의 높이를 결정하지 않는 것을 나타냅니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/Scrollable.html" title="javax.swing 내의 인터페이스">Scrollable</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/Scrollable.html#getScrollableTracksViewportHeight()">getScrollableTracksViewportHeight</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>getFillsViewportHeight</code> 가 <code>true</code> 로,
테이블을 뷰포트의 사이즈에 잡아늘일 필요가 있는 경우를 제외해
<code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/Scrollable.html#getScrollableTracksViewportHeight()"><CODE>Scrollable.getScrollableTracksViewportHeight()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#setFillsViewportHeight(boolean)"><CODE>setFillsViewportHeight(boolean)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#getFillsViewportHeight()"><CODE>getFillsViewportHeight()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setFillsViewportHeight(boolean)"><!-- --></A> <H3>
setFillsViewportHeight</H3>
<PRE>
public void <B>setFillsViewportHeight</B>(boolean&nbsp;fillsViewportHeight)</PRE>
<DL>
<DD>이 테이블을 항상 둘러싸 옆의 뷰포트의 높이에 맞추어 크게 할지 어떨지를 설정합니다. 테이블의 적절한 높이가 뷰포트의 높이보다 낮은 경우, 테이블은 뷰포트의 사이즈에 길게 늘어집니다. 이와 같이 해, 테이블이 뷰포트보다 작게 안 되게 합니다. 이 프로퍼티의 디폴트는 <code>false</code> 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>fillsViewportHeight</CODE> - 이 테이블을
항상 둘러싸 옆의 뷰포트의 높이에 맞추어
크게 할지 어떨지<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getFillsViewportHeight()"><CODE>getFillsViewportHeight()</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#getScrollableTracksViewportHeight()"><CODE>getScrollableTracksViewportHeight()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getFillsViewportHeight()"><!-- --></A> <H3>
getFillsViewportHeight</H3>
<PRE>
public boolean <B>getFillsViewportHeight</B>()</PRE>
<DL>
<DD>이 테이블을 항상 둘러싸 옆의 뷰포트의 높이에 맞추어 크게 할지 어떨지를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 테이블을 항상 둘러싸 옆의 뷰포트의 높이에 맞추어
크게 할지 어떨지<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setFillsViewportHeight(boolean)"><CODE>setFillsViewportHeight(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="processKeyBinding(javax.swing.KeyStroke, java.awt.event.KeyEvent, int, boolean)"><!-- --></A> <H3>
processKeyBinding</H3>
<PRE>
protected boolean <B>processKeyBinding</B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;ks,
                                    <A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e,
                                    int&nbsp;condition,
                                    boolean&nbsp;pressed)</PRE>
<DL>
<DD><B>클래스 <CODE><A HREF="../../javax/swing/JComponent.html#processKeyBinding(javax.swing.KeyStroke, java.awt.event.KeyEvent, int, boolean)">JComponent</A> </CODE> 의 기술:</B></DD>
<DD><code>KeyEvent</code> <code>e</code> 의 결과로서 <code>ks</code> 의 키 바인드를 처리하기 위해서 불려 갑니다. 이 메소드는 적절한 <code>InputMap</code>, 그 바인딩,<code>ActionMap</code> 의 액션을 취득해, (액션이 발견되어, 컴퍼넌트가 유효한 경우) 액션을 통지하기 위해서 <code>notifyAction</code> 를 호출합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#processKeyBinding(javax.swing.KeyStroke, java.awt.event.KeyEvent, int, boolean)">processKeyBinding</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ks</CODE> - 조회하는 <code>KeyStroke</code><DD><CODE>e</CODE> - <code>KeyEvent</code><DD><CODE>condition</CODE> - 다음의 값의 언젠가.
 <ul>
<li>JComponent.WHEN_FOCUSED
<li>JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT
<li>JComponent.WHEN_IN_FOCUSED_WINDOW
 </ul><DD><CODE>pressed</CODE> - 키가 밀리고 있는 경우는 true
<DT><B>반환값:</B><DD>액션에 바인딩이 있어, 액션이 유효했던 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultRenderers()"><!-- --></A> <H3>
createDefaultRenderers</H3>
<PRE>
protected void <B>createDefaultRenderers</B>()</PRE>
<DL>
<DD>객체, 수, double 치, 일자, boolean 치, 및 아이콘의 디폴트의 셀 렌더링을 작성합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/DefaultTableCellRenderer.html" title="javax.swing.table 내의 클래스"><CODE>DefaultTableCellRenderer</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultEditors()"><!-- --></A> <H3>
createDefaultEditors</H3>
<PRE>
protected void <B>createDefaultEditors</B>()</PRE>
<DL>
<DD>객체, 수, 및 boolean 치의 디폴트의 셀 에디터를 작성합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/DefaultCellEditor.html" title="javax.swing 내의 클래스"><CODE>DefaultCellEditor</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="initializeLocalVars()"><!-- --></A> <H3>
initializeLocalVars</H3>
<PRE>
protected void <B>initializeLocalVars</B>()</PRE>
<DL>
<DD>각 테이블 프로퍼티을 디폴트 값에 초기화합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultDataModel()"><!-- --></A> <H3>
createDefaultDataModel</H3>
<PRE>
protected <A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A>  <B>createDefaultDataModel</B>()</PRE>
<DL>
<DD><code>DefaultTableModel</code> 인 디폴트의 테이블 모델 객체를 돌려줍니다. 서브 클래스는 이 메소드를 오버라이드(override) 해, 다른 테이블 모델 객체를 돌려줄 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>디폴트의 테이블 모델 객체<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/DefaultTableModel.html" title="javax.swing.table 내의 클래스"><CODE>DefaultTableModel</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultColumnModel()"><!-- --></A> <H3>
createDefaultColumnModel</H3>
<PRE>
protected <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 내의 인터페이스">TableColumnModel</A>  <B>createDefaultColumnModel</B>()</PRE>
<DL>
<DD><code>DefaultTableColumnModel</code> 인 디폴트의 열모델 객체를 돌려줍니다. 서브 클래스는 이 메소드를 오버라이드(override) 해, 다른 열모델 객체를 돌려줄 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>디폴트의 열모델 객체<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/DefaultTableColumnModel.html" title="javax.swing.table 내의 클래스"><CODE>DefaultTableColumnModel</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultSelectionModel()"><!-- --></A> <H3>
createDefaultSelectionModel</H3>
<PRE>
protected <A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스">ListSelectionModel</A>  <B>createDefaultSelectionModel</B>()</PRE>
<DL>
<DD><code>DefaultListSelectionModel</code> 인 디폴트의 선택 모델 객체를 돌려줍니다. 서브 클래스는 이 메소드를 오버라이드(override) 해, 다른 선택 모델 객체를 돌려줄 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>디폴트의 선택 모델 객체<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/DefaultListSelectionModel.html" title="javax.swing 내의 클래스"><CODE>DefaultListSelectionModel</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultTableHeader()"><!-- --></A> <H3>
createDefaultTableHeader</H3>
<PRE>
protected <A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스">JTableHeader</A>  <B>createDefaultTableHeader</B>()</PRE>
<DL>
<DD><code>JTableHeader</code> 인 디폴트의 테이블 헤더 객체를 돌려줍니다. 서브 클래스는 이 메소드를 오버라이드(override) 해, 다른 테이블 헤더 객체를 돌려줄 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>디폴트의 테이블 헤더 객체<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스"><CODE>JTableHeader</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="resizeAndRepaint()"><!-- --></A> <H3>
resizeAndRepaint</H3>
<PRE>
protected void <B>resizeAndRepaint</B>()</PRE>
<DL>
<DD><code>revalidate</code> 의 후에 <code>repaint</code> 를 호출하는 것과 동등합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCellEditor()"><!-- --></A> <H3>
getCellEditor</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A>  <B>getCellEditor</B>()</PRE>
<DL>
<DD>테이블이 현재 편집중이 아닌 경우는 액티브한 셀 에디터 (<code>null</code>)를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>편집을 실시하는 <code>TableCellEditor</code>.
테이블이 현재 편집중이 아닌 경우는 <code>null</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#cellEditor"><CODE>cellEditor</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#getCellEditor(int, int)"><CODE>getCellEditor(int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setCellEditor(javax.swing.table.TableCellEditor)"><!-- --></A> <H3>
setCellEditor</H3>
<PRE>
public void <B>setCellEditor</B>(<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 안의 인터페이스">TableCellEditor</A> &nbsp;anEditor)</PRE>
<DL>
<DD>액티브한 셀 에디터를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>anEditor</CODE> - 액티브한 셀 에디터<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#cellEditor"><CODE>cellEditor</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEditingColumn(int)"><!-- --></A> <H3>
setEditingColumn</H3>
<PRE>
public void <B>setEditingColumn</B>(int&nbsp;aColumn)</PRE>
<DL>
<DD><code>editingColumn</code> 변수를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aColumn</CODE> - 편집되는 셀의 열<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#editingColumn"><CODE>editingColumn</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEditingRow(int)"><!-- --></A> <H3>
setEditingRow</H3>
<PRE>
public void <B>setEditingRow</B>(int&nbsp;aRow)</PRE>
<DL>
<DD><code>editingRow</code> 변수를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aRow</CODE> - 편집되는 셀의 행<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#editingRow"><CODE>editingRow</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getCellRenderer(int, int)"><!-- --></A> <H3>
getCellRenderer</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 내의 인터페이스">TableCellRenderer</A>  <B>getCellRenderer</B>(int&nbsp;row,
                                         int&nbsp;column)</PRE>
<DL>
<DD>이 행과 열로 지정하는 셀의 적절한 렌더링을 돌려줍니다. 이 열의 <code>TableColumn</code> 가 null 이외의 렌더링을 가지는 경우는, 그 렌더링을 돌려줍니다. 그렇지 않은 경우는,<code>getColumnClass</code> 를 사용해 이 열의 데이터의 클래스를 찾아내, 이 형태의 데이터의 디폴트 렌더링을 돌려줍니다.  &nbsp;<p>
<b>주:</b> 테이블 패키지 전체를 통해, 내부 구현은 항상 이 메소드를 사용해 렌더링을 제공해, 디폴트의 동작을 서브 클래스가 안전하게 오버라이드(override) 할 수 있도록(듯이) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - draw 하는 셀의 행. 0 은 최초의 행<DD><CODE>column</CODE> - draw 하는 셀의 열.
                        0 은 최초의 열
<DT><B>반환값:</B><DD>할당할 수 있었던 렌더링. <code>null</code> 의 경우, 이 형태의 객체의 디폴트의 렌더링을 돌려주는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/DefaultTableCellRenderer.html" title="javax.swing.table 내의 클래스"><CODE>DefaultTableCellRenderer</CODE></A> , 
<A HREF="../../javax/swing/table/TableColumn.html#setCellRenderer(javax.swing.table.TableCellRenderer)"><CODE>TableColumn.setCellRenderer(javax.swing.table.TableCellRenderer)</CODE></A> , 
<A HREF="../../javax/swing/JTable.html#setDefaultRenderer(java.lang.Class, javax.swing.table.TableCellRenderer)"><CODE>setDefaultRenderer(java.lang.Class<? >, javax.swing.table.TableCellRenderer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="prepareRenderer(javax.swing.table.TableCellRenderer, int, int)"><!-- --></A> <H3>
prepareRenderer</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A>  <B>prepareRenderer</B>(<A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 안의 인터페이스">TableCellRenderer</A> &nbsp;renderer,
                                 int&nbsp;row,
                                 int&nbsp;column)</PRE>
<DL>
<DD><code>row</code>,<code>column</code> 의 위치에 있는 셀의 값 및 선택 상태를 데이터 모델에 조회해, 렌더링을 준비합니다. 이벤트의 위치에 있는 컴퍼넌트 (<code>Component</code> 또는 <code>JComponent</code>)를 돌려줍니다.  &nbsp;<p>
인쇄 조작동안, 이 메소드는, 선택 또는 포커스를 지정하는 일 없이 렌더링을 설정해, 이것들을 인쇄 대상으로부터 제외합니다. 테이블을 인쇄할지 어떨지에 근거해 그 외의 커스터마이즈를 실시하는 경우는, 이 정도치 또는 커스텀 렌더링내의 <A HREF="../../javax/swing/JComponent.html#isPaintingForPrint()"><CODE>JComponent.isPaintingForPrint()</CODE></A>  의 값을 확인할 수 있습니다.  &nbsp;<p>
<b>주:</b> 테이블 패키지 전체를 통해, 내부 구현은 항상 이 메소드를 사용해 렌더링을 준비해, 이 디폴트의 동작을 서브 클래스가 안전하게 오버라이드(override) 할 수 있도록(듯이) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>renderer</CODE> - 준비하는 <code>TableCellRenderer</code><DD><CODE>row</CODE> - draw 하는 셀의 행. 0 은 최초의 행<DD><CODE>column</CODE> - draw 하는 셀의 열.
                        0 은 최초의 열
<DT><B>반환값:</B><DD>이벤트의 위치에 있는 <code>Component</code></DL>
</DD>
</DL>
<HR>

<A NAME="getCellEditor(int, int)"><!-- --></A> <H3>
getCellEditor</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A>  <B>getCellEditor</B>(int&nbsp;row,
                                     int&nbsp;column)</PRE>
<DL>
<DD><code>row</code> 와 <code>column</code> 가 지정하는 셀의 적절한 에디터를 돌려줍니다. 이 열의 <code>TableColumn</code> 가 null 이외의 에디터를 가지는 경우는, 그 에디터를 돌려줍니다. 그렇지 않은 경우는,<code>getColumnClass</code> 를 사용해 이 열의 데이터의 클래스를 찾아내, 이 형태의 데이터의 디폴트 에디터를 돌려줍니다.  &nbsp;<p>
<b>주:</b> 테이블 패키지 전체를 통해, 내부 구현은 항상 이 메소드를 사용해 에디터를 제공해, 이 디폴트의 동작을 서브 클래스가 안전하게 오버라이드(override) 할 수 있도록(듯이) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 편집하는 셀의 행. 0 은 최초의 행<DD><CODE>column</CODE> - 편집하는 셀의 열.
                        0 은 최초의 열
<DT><B>반환값:</B><DD>이 셀의 에디터.
                        <code>null</code> 의 경우,
                이 형태의 셀의 디폴트의 에디터를 돌려주는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/DefaultCellEditor.html" title="javax.swing 내의 클래스"><CODE>DefaultCellEditor</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="prepareEditor(javax.swing.table.TableCellEditor, int, int)"><!-- --></A> <H3>
prepareEditor</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A>  <B>prepareEditor</B>(<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 안의 인터페이스">TableCellEditor</A> &nbsp;editor,
                               int&nbsp;row,
                               int&nbsp;column)</PRE>
<DL>
<DD><code>row</code>,<code>column</code> 의 위치에 있는 셀의 값 및 선택 상태를 데이터 모델에 조회해, 에디터를 준비합니다.  &nbsp;<p>
<b>주:</b> 테이블 패키지 전체를 통해, 내부 구현은 항상 이 메소드를 사용해 에디터를 준비해, 이 디폴트의 동작을 서브 클래스가 안전하게 오버라이드(override) 할 수 있도록(듯이) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>editor</CODE> - 설정하는 <code>TableCellEditor</code><DD><CODE>row</CODE> - 편집하는 셀의 행.
                      0 은 최초의 행<DD><CODE>column</CODE> - 편집하는 셀의 열.
                      0 은 최초의 열
<DT><B>반환값:</B><DD>편집중의 <code>Component</code></DL>
</DD>
</DL>
<HR>

<A NAME="removeEditor()"><!-- --></A> <H3>
removeEditor</H3>
<PRE>
public void <B>removeEditor</B>()</PRE>
<DL>
<DD>에디터 객체를 파기해, 그 객체가 셀 draw에 사용한 장소를 해제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="paramString()"><!-- --></A> <H3>
paramString</H3>
<PRE>
protected <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>paramString</B>()</PRE>
<DL>
<DD>이 테이블의 캐릭터 라인 표현을 돌려줍니다. 이 메소드는 디버그 전용이며, 반환되는 캐릭터 라인의 내용 및 형식은 구현에 따라서 다릅니다. 반환되는 캐릭터 라인은 빈 상태(empty)의 경우가 있습니다만,<code>null</code> 로는 되지 않습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#paramString()">paramString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 테이블의 캐릭터 라인 표현</DL>
</DD>
</DL>
<HR>

<A NAME="print()"><!-- --></A> <H3>
print</H3>
<PRE>
public boolean <B>print</B>()
              throws <A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 내의 클래스">PrinterException</A> </PRE>
<DL>
<DD>인쇄 다이얼로그를 표시해, 이 <code>JTable</code> 를, 모드 <code>PrintMode.FIT_WIDTH</code> 로, 헤더 텍스트 또는 풋터 텍스트를 지정하지 않고 인쇄하는 편리한 메소드입니다. 인쇄중은, 중지 옵션 첨부의 모덜인 진척 다이얼로그가 표시됩니다.  &nbsp;<p>
주:헷드레스모드에서는, 다이얼로그는 표시되지 않고, 디폴트의 프린터를 사용해 인쇄를 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>사용자가 인쇄를 취소하지 않는 한 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 인쇄 작업 요구의 개시가 이 thread에 허가되어 있지 않은 경우
<DD><CODE><A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 안의 클래스">PrinterException</A> </CODE> - 인쇄 시스템의 에러가 원인으로 작업이 정지했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><CODE>#print(JTable.PrintMode, MessageFormat, MessageFormat,</CODE>, 
<A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><CODE>getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="print(javax.swing.JTable.PrintMode)"><!-- --></A> <H3>
print</H3>
<PRE>
public boolean <B>print</B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode)
              throws <A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 내의 클래스">PrinterException</A> </PRE>
<DL>
<DD>인쇄 다이얼로그를 표시해, 이 <code>JTable</code> 를, 지정된 인쇄 모드로, 헤더 텍스트 또는 풋터 텍스트를 지정하지 않고 인쇄하는 편리한 메소드입니다. 인쇄중은, 중지 옵션 첨부의 모덜인 진척 다이얼로그가 표시됩니다.  &nbsp;<p>
주:헷드레스모드에서는, 다이얼로그는 표시되지 않고, 디폴트의 프린터를 사용해 인쇄를 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>printMode</CODE> - Printable 가 사용하는 인쇄 모드
<DT><B>반환값:</B><DD>사용자가 인쇄를 취소하지 않는 한 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 인쇄 작업 요구의 개시가 이 thread에 허가되어 있지 않은 경우
<DD><CODE><A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 안의 클래스">PrinterException</A> </CODE> - 인쇄 시스템의 에러가 원인으로 작업이 정지했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><CODE>#print(JTable.PrintMode, MessageFormat, MessageFormat,</CODE>, 
<A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><CODE>getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><!-- --></A> <H3>
print</H3>
<PRE>
public boolean <B>print</B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
                     <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
                     <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat)
              throws <A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 내의 클래스">PrinterException</A> </PRE>
<DL>
<DD>인쇄 다이얼로그를 표시해, 이 <code>JTable</code> 를, 지정된 인쇄 모드로, 헤더 텍스트 또는 풋터 텍스트를 지정해 인쇄하는 편리한 메소드입니다. 인쇄중은, 중지 옵션 첨부의 모덜인 진척 다이얼로그가 표시됩니다.  &nbsp;<p>
주:헷드레스모드에서는, 다이얼로그는 표시되지 않고, 디폴트의 프린터를 사용해 인쇄를 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>printMode</CODE> - Printable 가 사용하는 인쇄 모드<DD><CODE>headerFormat</CODE> - 헤더의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. 헤더가 없는 경우는 null<DD><CODE>footerFormat</CODE> - 풋터의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. 풋터가 없는 경우는 null
<DT><B>반환값:</B><DD>사용자가 인쇄를 취소하지 않는 한 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 인쇄 작업 요구의 개시가 이 thread에 허가되어 있지 않은 경우
<DD><CODE><A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 안의 클래스">PrinterException</A> </CODE> - 인쇄 시스템의 에러가 원인으로 작업이 정지했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><CODE>#print(JTable.PrintMode, MessageFormat, MessageFormat,</CODE>, 
<A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><CODE>getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat, boolean, javax.print.attribute.PrintRequestAttributeSet, boolean)"><!-- --></A> <H3>
print</H3>
<PRE>
public boolean <B>print</B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
                     <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
                     <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat,
                     boolean&nbsp;showPrintDialog,
                     <A HREF="../../javax/print/attribute/PrintRequestAttributeSet.html" title="javax.print.attribute 안의 인터페이스">PrintRequestAttributeSet</A> &nbsp;attr,
                     boolean&nbsp;interactive)
              throws <A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 내의 클래스">PrinterException</A> ,
                     <A HREF="../../java/awt/HeadlessException.html" title="java.awt 안의 클래스">HeadlessException</A> </PRE>
<DL>
<DD>완전 지정의 <A HREF="../../javax/swing/JTable.html#print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat, boolean, javax.print.attribute.PrintRequestAttributeSet, boolean, javax.print.PrintService)"><CODE>print</CODE></A>  메소드로 지정된 것처럼, 인쇄 서비스로서 지정된 디폴트 프린터를 사용해, 이 테이블을 인쇄합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>printMode</CODE> - Printable 가 사용하는 인쇄 모드<DD><CODE>headerFormat</CODE> - 헤더의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. 헤더가 없는 경우는 <code>null</code><DD><CODE>footerFormat</CODE> - 풋터의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. 풋터가 없는 경우는 <code>null</code><DD><CODE>showPrintDialog</CODE> - 인쇄 다이얼로그를 표시할지 어떨지<DD><CODE>attr</CODE> - 인쇄 속성을 나타내는 <code>PrintRequestAttributeSet</code>. 인쇄 속성이 없는 경우는 <code>null</code><DD><CODE>interactive</CODE> - 대화형 모드로 인쇄할지 어떨지
<DT><B>반환값:</B><DD>사용자가 인쇄를 취소하지 않는 한 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/awt/HeadlessException.html" title="java.awt 안의 클래스">HeadlessException</A> </CODE> - 메소드가 인쇄 다이얼로그를 표시하는지, 대화형으로 실행하도록(듯이) 요구되어<code>GraphicsEnvironment.isHeadless</code> 가 <code>true</code> 를 돌려주었을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 인쇄 작업 요구의 개시가 이 thread에 허가되어 있지 않은 경우
<DD><CODE><A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 안의 클래스">PrinterException</A> </CODE> - 인쇄 시스템의 에러가 원인으로 작업이 정지했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><CODE>#print(JTable.PrintMode, MessageFormat, MessageFormat,</CODE>, 
<A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><CODE>getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat, boolean, javax.print.attribute.PrintRequestAttributeSet, boolean, javax.print.PrintService)"><!-- --></A> <H3>
print</H3>
<PRE>
public boolean <B>print</B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
                     <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
                     <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat,
                     boolean&nbsp;showPrintDialog,
                     <A HREF="../../javax/print/attribute/PrintRequestAttributeSet.html" title="javax.print.attribute 안의 인터페이스">PrintRequestAttributeSet</A> &nbsp;attr,
                     boolean&nbsp;interactive,
                     <A HREF="../../javax/print/PrintService.html" title="javax.print 안의 인터페이스">PrintService</A> &nbsp;service)
              throws <A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 내의 클래스">PrinterException</A> ,
                     <A HREF="../../java/awt/HeadlessException.html" title="java.awt 안의 클래스">HeadlessException</A> </PRE>
<DL>
<DD>이 <code>JTable</code> 를 인쇄합니다. 대부분의 개발자가 <code>JTable</code> 의 인쇄에 사용하는 순서를 실행합니다. 간략하게 말하면, 테이블을 준비해,<code>getPrintable</code> 를 호출해 적절한 <code>Printable</code> 를 꺼내, 그것을 프린터에 보냅니다.  &nbsp;<p>
<code>boolean</code> 파라미터를 사용하면(자), 인쇄 다이얼로그가 사용자에게 표시될지 어떨지를 지정할 수 있습니다. 인쇄 다이얼로그가 표시되는 경우, 사용자는 이 다이얼로그를 사용해 출력처의 프린터나 인쇄 속성을 변경하거나 인쇄를 취소하거나 할 수가 있습니다. 다른 2 개의 파라미터에서는,<code>PrintService</code> 와 인쇄 속성을 지정할 수 있습니다. 이러한 파라미터는, 인쇄 다이얼로그의 초기치를 지정하거나 다이얼로그가 표시되지 않을 때에 값을 지정하기 위해서 사용할 수 있습니다.  &nbsp;<p>
2 번째의 <code>boolean</code> 파라미터를 사용하면(자), 대화형 모드로 인쇄를 실행할지 어떨지를 지정할 수 있습니다. <code>true</code> 의 경우는, 인쇄중에 중지 옵션이 붙은 모덜인 진척 다이얼로그가 표시됩니다. 이 다이얼로그에서는, 테이블에 영향을 미치는 사용자 액션을 방지할 수도 있습니다. 다만, 테이블이 코드 (<code>SwingUtilities.invokeLater</code> 를 사용해 갱신 내용을 보내는 다른 thread등)에 의해 변경되지 않게 할 수 없습니다. 이 때문에, 개발자는 인쇄중에 테이블이 다른 코드에 의해 결코 변경되지 않게 할 필요가 있습니다 (부정한 변경에는, 사이즈, 렌더링, 기본이 되는 데이터의 변경이 있다). 인쇄중으로 테이블이 변경되면(자), 인쇄 동작은 보증되지 않습니다.  &nbsp;<p>
이 파라미터를 <code>false</code> 로 지정하면(자), 다이얼로그는 표시되지 않고, 이벤트발송쓰레드로 즉석에서 인쇄가 개시됩니다. 이것에 의해, 인쇄가 완료할 때까지 다른 모든 이벤트 (재페인트등)의 처리가 중단됩니다. 이것은, 테이블이 변경되지 않게 하려면  효과적입니다만, 사용자측의 순서가 없습니다. 이 이유로부터, 표시할 수 있는 GUI 가 없는 어플리케이션으로부터 인쇄할 경우에 마셔 <code>false</code> 를 지정하는 것을 추천합니다.  &nbsp;<p>
주:헷드레스모드로 인쇄 다이얼로그를 표시하는지, 대화형으로 실행하려고 하면(자),<code>HeadlessException</code> 가 throw 됩니다.  &nbsp;<p>
이 메소드는, Printable 를 취득하기 전에, 필요에 따라서 에디터를 종료해, 인쇄 결과에 에디터를 표시하지 않게 합니다. 또,<code>JTable</code> 는, 인쇄중에 선택과 포커스가 지정되지 않게 렌더링을 준비합니다. 테이블의 인쇄 결과를 한층 더 커스터마이즈 하는 경우, 개발자는,<A HREF="../../javax/swing/JComponent.html#isPaintingForPrint()"><CODE>JComponent.isPaintingForPrint()</CODE></A>  의 값에 조건을 설정하는 커스텀 렌더링 또는 페인트 코드를 제공할 수 있습니다.  &nbsp;<p>
테이블의 인쇄 방법의 자세한 것은,<A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><CODE>getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)</CODE></A>  를 참조해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>printMode</CODE> - Printable 가 사용하는 인쇄 모드<DD><CODE>headerFormat</CODE> - 헤더의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. 헤더가 없는 경우는 <code>null</code><DD><CODE>footerFormat</CODE> - 풋터의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. 풋터가 없는 경우는 <code>null</code><DD><CODE>showPrintDialog</CODE> - 인쇄 다이얼로그를 표시할지 어떨지<DD><CODE>attr</CODE> - 인쇄 속성을 나타내는 <code>PrintRequestAttributeSet</code>. 인쇄 속성이 없는 경우는 <code>null</code><DD><CODE>interactive</CODE> - 대화형 모드로 인쇄할지 어떨지<DD><CODE>service</CODE> - 출력처의 <code>PrintService</code>. 디폴트의 프린터를 사용하는 경우는 <code>null</code>
<DT><B>반환값:</B><DD>사용자가 인쇄를 취소하지 않는 한 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/awt/HeadlessException.html" title="java.awt 안의 클래스">HeadlessException</A> </CODE> - 메소드가 인쇄 다이얼로그를 표시하는지, 대화형으로 실행하도록(듯이) 요구되어<code>GraphicsEnvironment.isHeadless</code> 가 <code>true</code> 를 돌려주었을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐리티 매니저가 존재해,
<A HREF="../../java/lang/SecurityManager.html#checkPrintJobAccess()"><CODE>SecurityManager.checkPrintJobAccess()</CODE></A> 
메소드에 의해, 이 thread에서의 인쇄 작업 요구의 작성이 금지되고 있는 경우
<DD><CODE><A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 안의 클래스">PrinterException</A> </CODE> - 인쇄 시스템의 에러가 원인으로 작업이 정지했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.6</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><CODE>getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)</CODE></A> , 
<A HREF="../../java/awt/GraphicsEnvironment.html#isHeadless()"><CODE>GraphicsEnvironment.isHeadless()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><!-- --></A> <H3>
getPrintable</H3>
<PRE>
public <A HREF="../../java/awt/print/Printable.html" title="java.awt.print 내의 인터페이스">Printable</A>  <B>getPrintable</B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
                              <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
                              <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat)</PRE>
<DL>
<DD>이 JTable 의 인쇄에 사용하는 <code>Printable</code> 를 돌려줍니다.  &nbsp;<p>
이 메소드는,<code>JTable</code> 의 <code>print</code> 메소드에 의해 사용되는 디폴트의 <code>Printable</code> 구현을 커스터마이즈 하는 수단으로서 사용합니다. 테이블을 인쇄할 뿐(만큼)의 경우는, 이러한 메소드의 어느쪽이든을 직접 사용하는 것을 추천합니다.  &nbsp;<p>
<code>Printable</code> 는, 2 개의 인쇄 모드의 어느쪽이든으로 요구할 수 있습니다. 어느 쪽의 모드에서도, 1 페이지 근처의 행수를 가능한 한 많이 해, 테이블의 행을 순서에 복수 페이지에 걸쳐서 자연스럽게 분산시킵니다. <code>PrintMode.NORMAL</code> 는, 테이블이 현재의 사이즈로 인쇄되는 것을 나타냅니다. 이 모드에서는, 행의 경우와 같게 열도 복수 페이지에 걸쳐서 분산시킬 필요가 있습니다. 필요에 따라서, 테이블의 <code>ComponentOrientation</code> 에 알맞은 순서로 열이 분산됩니다. <code>PrintMode.FIT_WIDTH</code> 는, 필요에 따라서, 각 페이지에 테이블의 폭전체 (모든 열)가 들어가도록(듯이) 출력이 축소되는 것을 나타냅니다. 폭과 높이는 균일하게 슬캘링 되어 출력의 종횡비가 유지됩니다.  &nbsp;<p>
<code>Printable</code> 는, 각 페이지의 테이블 부분의 선두에 테이블의 <code>JTableHeader</code> 로부터의 적절한 섹션 (존재하는 경우)을 붙입니다.  &nbsp;<p>
<code>MessageFormat</code> 인수를 지정하면(자), 헤더 텍스트와 풋터 텍스트를 출력에 추가할 수 있습니다. 인쇄 코드는, 그러한 형식으로부터 String 를 요구해, 서식 첨부 캐릭터 라인에 포함되는 단일의 항목 (현재의 페이지 번호를 나타내는 <code>Integer</code>)을 제공합니다.  &nbsp;<p>
홑겹 인용부호등의 일부의 특수 문자에는 이스케이프가 필요하기 (위해)때문에,<code>MessageFormat</code> 의 문서를 자주(잘) 읽어 주세요.  &nbsp;<p>
다음에, 「Duke's Table:Page - 」라고 현재의 페이지 번호의 인쇄에 사용할 수 있는 <code>MessageFormat</code> 의 작성예를 나타냅니다.  &nbsp;<p>
 <pre>
     // notice the escaping of the single quote
     // notice how the page number is included with "{0}"
     MessageFormat format = new MessageFormat("Duke''s Table: Page - {0}");
 </pre>
 <p>
<code>Printable</code> 에서는, draw 하는 내용을, 인쇄하는 각 페이지의 인쇄 가능 영역에 제한합니다. 경우에 따라서는, 페이지의 모든 내용이 그 영역에 들어가지 않는 것이 있습니다. 이 경우는, 출력이 클립 되는 일이 있습니다만, 구현은 하등의 타당한 처리를 하려고 시도합니다. 다음에, 이러한 상황의 몇개의 발생예와 이 구현에 의한 그러한 대처 방법을 나타냅니다.
 <ul>
<li>모든 모드로, 헤더 텍스트 또는 풋터 텍스트가 너무 커 인쇄 가능 영역에 완전하게 들어가지 않는 경우 -- 테이블의 <code>ComponentOrientation</code> 에 의해 결정할 수 있었던 대로 텍스트의 선두로부터 한도 가득까지 인쇄한다
<li>모든 모드로, 행이 너무 길어 인쇄 가능 영역에 들어가지 않는 경우 -- 행의 최상 부분을 인쇄해, 움푹한 곳 경계는 테이블에 페인트 하지 않는다
<li><code>PrintMode.NORMAL</code> 로, 열이 너무 넓어 인쇄 가능 영역에 들어가지 않는 경우 -- 열의 중앙 부분을 인쇄해, 왼쪽 및 오른쪽의 경계를 테이블에서 제외한다
 </ul>
 <p>
복잡한 리포트나 문서를 작성하기 위해서, 이 <code>Printable</code> 를 다른 <code>Printable</code> 내에 랩 하는 것은 전혀 문제 없습니다. 또, 다른 페이지가 사이즈의 다른 인쇄 가능 영역에 draw 되도록(듯이) 요구할 수도 있습니다. 구현은, 이러한 상황에 대처할 수 있는 것 (아마 실행중에 그 레이아웃 계산을 실시하는 것으로) 같게 준비되어 있을 필요가 있습니다. 다만,<code>PrintMode.NORMAL</code> 로 복수 페이지에 열을 분산시킬 필요가 있는 경우는, 각 페이지에 다른 높이를 지정하면(자), 올바르게 동작하지 않을 가능성이 있습니다.  &nbsp;<p>
인쇄 결과의 테이블의 외관을 커스터마이즈 하는 경우, 인쇄중의 선택 및 포커스의 비표시 설정은,<code>JTable</code> 자체에 의해 처리됩니다. 보다 세세하게 커스터마이즈 하는 경우는, 렌더링 또는 페인트 코드를 사용해,<A HREF="../../javax/swing/JComponent.html#isPaintingForPrint()"><CODE>JComponent.isPaintingForPrint()</CODE></A>  의 값에 근거해 외관을 커스터마이즈 할 수 있습니다. <p>
또, 이 메소드를 호출하기 전<i></i>에,<i></i>우선 테이블 상태를 변경하는 (셀 편집의 취소해, 사용자에 의한 테이블의 사이즈의 설정 등) 일이 생깁니다. 다만, 이 <code>Printable</code> 가 취득된 뒤<i></i>는, 테이블 상태를 변경 해서는 안됩니다. 무효인 변경에는, 사이즈의 변경이나, 부하의 데이터의 변경등이 있습니다. 테이블로 변경을 더했을 경우, 반환되는 <code>Printable</code> 의 동작은 보증되지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>printMode</CODE> - Printable 가 사용하는 인쇄 모드<DD><CODE>headerFormat</CODE> - 헤더의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. 헤더가 없는 경우는 null<DD><CODE>footerFormat</CODE> - 풋터의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. 풋터가 없는 경우는 null
<DT><B>반환값:</B><DD>이 JTable 를 인쇄하기 위한 <code>Printable</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><CODE>#print(JTable.PrintMode, MessageFormat, MessageFormat,</CODE>, 
<A HREF="../../java/awt/print/Printable.html" title="java.awt.print 안의 인터페이스"><CODE>Printable</CODE></A> , 
<A HREF="../../java/awt/print/PrinterJob.html" title="java.awt.print 안의 클래스"><CODE>PrinterJob</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAccessibleContext()"><!-- --></A> <H3>
getAccessibleContext</H3>
<PRE>
public <A HREF="../../javax/accessibility/AccessibleContext.html" title="javax.accessibility 내의 클래스">AccessibleContext</A>  <B>getAccessibleContext</B>()</PRE>
<DL>
<DD>이 JTable 에 관련한 AccessibleContext 를 돌려줍니다. 테이블의 경우, AccessibleContext 는 AccessibleJTable  의 형식을 취합니다. 필요에 따라서, 신규의 AccessibleJTable 인스턴스가 작성됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/accessibility/Accessible.html" title="javax.accessibility 내의 인터페이스">Accessible</A> </CODE> 내의 <CODE><A HREF="../../javax/accessibility/Accessible.html#getAccessibleContext()">getAccessibleContext</A> </CODE><DT><B>오버라이드(override):</B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#getAccessibleContext()">getAccessibleContext</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 JTable 의 AccessibleContext 로서
기능하는 AccessibleJTable</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JTable.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/swing/JTabbedPane.ModelListener.html" title="javax.swing 내의 클래스"><B>앞의 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/swing/JTable.AccessibleJTable.html" title="javax.swing 내의 클래스"><B>다음의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javax/swing/JTable.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="JTable.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요 :&nbsp;<A HREF="#nested_class_summary">상자</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">생성자</A> &nbsp;|&nbsp;<A HREF="#method_summary">메소드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세 :&nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메소드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="../../../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
