<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0-rc) on Mon Feb 05 20:54:47 JST 2007 -->
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>
비추천 API 의 리스트 (Java Platform SE 6)
 - xrath.com 에서 번역됨</TITLE>

<META NAME="date" CONTENT="2007-02-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="비추천 API 의 리스트 (Java Platform SE 6) - xrath.com 에서 번역됨";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">패키지</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">사용</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>비추천 API</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp; 전&nbsp;
&nbsp;다음</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?deprecated-list.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="deprecated-list.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<CENTER>
<H2>
<B>추천되어 있지 않은 API</B></H2>
</CENTER>
<HR SIZE="4" NOSHADE>
<B>컨텐츠</B><UL>
<LI><A HREF="#interface">추천되어 있지 않은 인터페이스</A> 
<LI><A HREF="#class">추천되어 있지 않은 클래스</A> 
<LI><A HREF="#exception">추천되어 있지 않은 예외</A> 
<LI><A HREF="#annotation_type">추천되어 있지 않은 주석형</A> 
<LI><A HREF="#field">추천되어 있지 않은 필드</A> 
<LI><A HREF="#method">추천되어 있지 않은 메소드</A> 
<LI><A HREF="#constructor">추천되어 있지 않은 생성자</A> 
<LI><A HREF="#annotation_type_member">추천되어 있지 않은 주석형의 요소</A> 
</UL>

<A NAME="interface"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 인터페이스</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/xml/sax/AttributeList.html" title="org.xml.sax 안의 인터페이스">org.xml.sax.AttributeList</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 인터페이스는, 이름 공간을 지원하는 SAX2 의
             <A HREF="org/xml/sax/Attributes.html" title="org.xml.sax 안의 인터페이스"><CODE>Attributes</CODE></A> 
             인터페이스로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/Certificate.html" title="java.security 안의 인터페이스">java.security.Certificate</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 플랫폼에서는, 증명서를 취급하는 새로운 패키지가 작성되었습니다. 이 Certificate 인터페이스의 사용은 추천 되지 않습니다.  새로운 패키지에의 원활한 이행을 위해서(때문에) 남아 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/xml/sax/DocumentHandler.html" title="org.xml.sax 안의 인터페이스">org.xml.sax.DocumentHandler</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 인터페이스는, 이름 공간을 지원하는 SAX2 의
             <A HREF="org/xml/sax/ContentHandler.html" title="org.xml.sax 안의 인터페이스"><CODE>ContentHandler</CODE></A> 
             인터페이스로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynAny.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynAny</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynAny.html">DynAny</a>  를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynArray.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynArray</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynArray.html">DynArray</a>  를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynEnum.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynEnum</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynEnum.html">DynEnum</a>  를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynFixed.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynFixed</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynFixed.html">DynFixed</a>  를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynSequence.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynSequence</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynSequence.html">DynSequence</a>  를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynStruct.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynStruct</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynStruct.html">DynStruct</a>  를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynUnion.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynUnion</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynUnion.html">DynUnion</a>  를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynValue.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynValue</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynValue.html">DynValue</a>  를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LoaderHandler.html" title="java.rmi.server 안의 인터페이스">java.rmi.server.LoaderHandler</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/xml/sax/Parser.html" title="org.xml.sax 안의 인터페이스">org.xml.sax.Parser</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 인터페이스는, 이름 공간을 지원하는 SAX2 의
             <A HREF="org/xml/sax/XMLReader.html" title="org.xml.sax 안의 인터페이스"><CODE>XMLReader</CODE></A>  
             인터페이스로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/registry/RegistryHandler.html" title="java.rmi.registry 안의 인터페이스">java.rmi.registry.RegistryHandler</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html" title="java.rmi.server 안의 인터페이스">java.rmi.server.RemoteCall</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Skeleton.html" title="java.rmi.server 안의 인터페이스">java.rmi.server.Skeleton</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. 스켈리턴은, Java 2 플랫폼 1.2 이후의 버젼의 원격 메소드 호출에서는 불요</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/bind/Validator.html" title="javax.xml.bind 안의 인터페이스">javax.xml.bind.Validator</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>since JAXB 2.0</I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="class"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 클래스</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/accessibility/AccessibleResourceBundle.html" title="javax.accessibility 안의 클래스">javax.accessibility.AccessibleResourceBundle</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 플랫폼의 버젼 1.3 이후에서는,
             이 클래스는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/xml/sax/helpers/AttributeListImpl.html" title="org.xml.sax.helpers 안의 클래스">org.xml.sax.helpers.AttributeListImpl</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는 비추천의 인터페이스 
             <A HREF="org/xml/sax/AttributeList.html" title="org.xml.sax 안의 인터페이스"><CODE>AttributeList</CODE></A> ; 
             (을)를 구현합니다. 이 인터페이스는 벌써,
             <A HREF="org/xml/sax/Attributes.html" title="org.xml.sax 안의 인터페이스"><CODE>Attributes</CODE></A>  
             (으)로 옮겨지고 있습니다. 이것은,
             <A HREF="org/xml/sax/helpers/AttributesImpl.html" title="org.xml.sax.helpers 안의 클래스"><CODE>AttributesImpl</CODE></A>  헬퍼 클래스에 구현되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/DefaultLoaderRepository.html" title="javax.management 안의 클래스">javax.management.DefaultLoaderRepository</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에, 
 <A HREF="javax/management/MBeanServer.html#getClassLoaderRepository()"><CODE>MBeanServer.getClassLoaderRepository()</CODE></A>  
 (을)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/loading/DefaultLoaderRepository.html" title="javax.management.loading 안의 클래스">javax.management.loading.DefaultLoaderRepository</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에, 
 <A HREF="javax/management/MBeanServer.html#getClassLoaderRepository()"><CODE>MBeanServer.getClassLoaderRepository()</CODE></A> } 
 (을)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/DefaultTextUI.html" title="javax.swing.text 안의 클래스">javax.swing.text.DefaultTextUI</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynamicImplementation.html" title="org.omg.CORBA 안의 클래스">org.omg.CORBA.DynamicImplementation</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>org.omg.CORBA.DynamicImplementation</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/xml/sax/HandlerBase.html" title="org.xml.sax 안의 클래스">org.xml.sax.HandlerBase</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는 비추천의 
             <A HREF="org/xml/sax/DocumentHandler.html" title="org.xml.sax 안의 인터페이스"><CODE>DocumentHandler</CODE></A>  
             인터페이스로 동작합니다. SAX2 에서는, 이 클래스는 
             <A HREF="org/xml/sax/helpers/DefaultHandler.html" title="org.xml.sax.helpers 안의 클래스"><CODE>DefaultHandler</CODE></A>  
             클래스에서 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/Identity.html" title="java.security 안의 클래스">java.security.Identity</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는 현재 사용되고 있지 않습니다. 이 클래스의 기능은,<code>java.security.KeyStore</code> 클래스,<code>java.security.cert</code> 패키지, 및 <code>java.security.Principal</code> 클래스로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/IdentityScope.html" title="java.security 안의 클래스">java.security.IdentityScope</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는 현재 사용되고 있지 않습니다. 이 클래스의 기능은,<code>java.security.KeyStore</code> 클래스,<code>java.security.cert</code> 패키지, 및 <code>java.security.Principal</code> 클래스로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/LineNumberInputStream.html" title="java.io 안의 클래스">java.io.LineNumberInputStream</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는, 문자가 바이트에 의해 적절히 표현된다고 하는 잘못한 인식을 전제로 하고 있습니다. JDK&nbsp;1. 1 이후, 문자 스트림의 처리에는, 행 번호를 카운트하기 위한 클래스가 포함되어 있는 새로운 문자 스트림 클래스를 사용하는 것이 적절합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html" title="java.rmi.server 안의 클래스">java.rmi.server.LogStream</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/metal/MetalComboBoxUI.MetalComboPopup.html" title="javax.swing.plaf.metal 안의 클래스">javax.swing.plaf.metal.MetalComboBoxUI.MetalComboPopup</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 4 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Operation.html" title="java.rmi.server 안의 클래스">java.rmi.server.Operation</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/xml/sax/helpers/ParserFactory.html" title="org.xml.sax.helpers 안의 클래스">org.xml.sax.helpers.ParserFactory</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는 비추천의 
             <A HREF="org/xml/sax/Parser.html" title="org.xml.sax 안의 인터페이스"><CODE>Parser</CODE></A>  
             인터페이스로 동작합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/security/auth/Policy.html" title="javax.security.auth 안의 클래스">javax.security.auth.Policy</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.4 로, java.security.Policy 로 옮겨졌습니다. java.security.Policy 에는 다음의 메소드가 존재합니다.

 <pre>
        public PermissionCollection getPermissions
            (java.security.ProtectionDomain pd)
 
 </pre>
또, ProtectionDomain 에는 다음의 생성자 이 있습니다.
 <pre>
        public ProtectionDomain
            (CodeSource cs,
             PermissionCollection permissions,
             ClassLoader loader,
             Principal[] principals)
 </pre>

이것들 2 개의 API 는, 호출 측에, Principal 베이스의 Permission 엔트리용 Policy 의 문의를 실행하는 수단을 제공합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/Principal.html" title="org.omg.CORBA 안의 클래스">org.omg.CORBA.Principal</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/PrincipalHolder.html" title="org.omg.CORBA 안의 클래스">org.omg.CORBA.PrincipalHolder</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/Signer.html" title="java.security 안의 클래스">java.security.Signer</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는 현재 사용되고 있지 않습니다. 이 클래스의 기능은,<code>java.security.KeyStore</code> 클래스,<code>java.security.cert</code> 패키지, 및 <code>java.security.Principal</code> 클래스로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/soap/SOAPElementFactory.html" title="javax.xml.soap 안의 클래스">javax.xml.soap.SOAPElementFactory</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>- SOAPElement 의 작성에 <code>javax.xml.soap.SOAPFactory</code> 를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/StringBufferInputStream.html" title="java.io 안의 클래스">java.io.StringBufferInputStream</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스에서는, 문자로부터 바이트에의 변환이 올바르게 행해지지 않습니다. JDK&nbsp;1. 1 이후는, 캐릭터 라인으로부터 스트림을 작성하려면 ,<code>StringReader</code> 클래스를 사용하는 것이 적절합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/TableView.TableCell.html" title="javax.swing.text 안의 클래스">javax.swing.text.TableView.TableCell</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>테이블 셀은 임의의 View 구현이 될 수가 있습니다. </I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="exception"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 예외</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/RMISecurityException.html" title="java.rmi 안의 클래스">java.rmi.RMISecurityException</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 <A HREF="java/lang/SecurityException.html" title="java.lang 안의 클래스"><CODE>SecurityException</CODE></A>  를 사용합니다.
 어플리케이션 코드로부터 이 클래스를 직접 참조하지 말아 주세요.
 <code>RMISecurityManager</code> 는,
 현재는 이 <code>java.lang.SecurityException</code> 의 서브 클래스를 throw 하지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/ServerRuntimeException.html" title="java.rmi 안의 클래스">java.rmi.ServerRuntimeException</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/SkeletonMismatchException.html" title="java.rmi.server 안의 클래스">java.rmi.server.SkeletonMismatchException</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. 스켈리턴은, Java 2 플랫폼 1.2 이후의 버젼의 원격 메소드 호출에서는 불요</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/SkeletonNotFoundException.html" title="java.rmi.server 안의 클래스">java.rmi.server.SkeletonNotFoundException</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. 스켈리턴은, Java 2 플랫폼 1.2 이후의 버젼의 원격 메소드 호출에서는 불요</I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="annotation_type"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 주석형</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/jws/soap/InitParam.html" title="javax.jws.soap 안의 주석">javax.jws.soap.InitParam</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JSR-181 2.0 이후는 추천 되지 않게 되어, 대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/jws/soap/SOAPMessageHandler.html" title="javax.jws.soap 안의 주석">javax.jws.soap.SOAPMessageHandler</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JSR-181 2.0 이후는 추천 되지 않게 되어, 대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/jws/soap/SOAPMessageHandlers.html" title="javax.jws.soap 안의 주석">javax.jws.soap.SOAPMessageHandlers</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JSR-181 2.0 이후는 추천 되지 않게 되어, 대체는 없습니다. </I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="field"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 필드</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/openmbean/OpenType.html#ALLOWED_CLASSNAMES">javax.management.openmbean.OpenType.ALLOWED_CLASSNAMES</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에,<A HREF="javax/management/openmbean/OpenType.html#ALLOWED_CLASSNAMES_LIST"><CODE>ALLOWED_CLASSNAMES_LIST</CODE></A>  를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/Monitor.html#alreadyNotified">javax.management.monitor.Monitor.alreadyNotified</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="javax/management/monitor/Monitor.html#alreadyNotifieds"><CODE>Monitor.alreadyNotifieds</CODE></A> [0] 으로 동등합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JViewport.html#backingStore">javax.swing.JViewport.backingStore</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicDesktopPaneUI.html#closeKey">javax.swing.plaf.basic.BasicDesktopPaneUI.closeKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>버젼 1.3 시점</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#CROSSHAIR_CURSOR">java.awt.Frame.CROSSHAIR_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.CROSSHAIR_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/Monitor.html#dbgTag">javax.management.monitor.Monitor.dbgTag</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#DEFAULT_CURSOR">java.awt.Frame.DEFAULT_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.DEFAULT_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JRootPane.html#defaultPressAction">javax.swing.JRootPane.defaultPressAction</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JRootPane.html#defaultReleaseAction">javax.swing.JRootPane.defaultReleaseAction</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#dividerResizeToggleKey">javax.swing.plaf.basic.BasicSplitPaneUI.dividerResizeToggleKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicToolBarUI.html#downKey">javax.swing.plaf.basic.BasicToolBarUI.downKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicTabbedPaneUI.html#downKey">javax.swing.plaf.basic.BasicTabbedPaneUI.downKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#downKey">javax.swing.plaf.basic.BasicSplitPaneUI.downKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#E_RESIZE_CURSOR">java.awt.Frame.E_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.E_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#endKey">javax.swing.plaf.basic.BasicSplitPaneUI.endKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/logging/Logger.html#global">java.util.logging.Logger.global</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 필드의 초기화시에 데드락이 발생할 가능성이 있습니다. 이 필드는 Logger 클래스 초기화에 의해 초기화됩니다만, 그것에 의해, LogManager 클래스 초기화와의 사이에 데드락이 발생할 가능성이 있습니다. 그러한 경우, 2 개의 클래스 초기화는 한편이 완료할 때까지 대기합니다. JDK version 1.6 이후에 글로벌 로거객체를 취득하기 위한 추천의 방법은,<code>Logger.getLogger(Logger.GLOBAL_LOGGER_NAME)</code> 를 호출하는 것입니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#HAND_CURSOR">java.awt.Frame.HAND_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.HAND_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#homeKey">javax.swing.plaf.basic.BasicSplitPaneUI.homeKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/HttpURLConnection.html#HTTP_SERVER_ERROR">java.net.HttpURLConnection.HTTP_SERVER_ERROR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>잘못한 필드이며, 존재해야 하는 것이어 선. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#inCheck">java.lang.SecurityManager.inCheck</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐리티 체크는 추천 되지 않습니다.
대신에 <code>checkPermission</code> 의 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#keyboardDownRightListener">javax.swing.plaf.basic.BasicSplitPaneUI.keyboardDownRightListener</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#keyboardEndListener">javax.swing.plaf.basic.BasicSplitPaneUI.keyboardEndListener</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#keyboardHomeListener">javax.swing.plaf.basic.BasicSplitPaneUI.keyboardHomeListener</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#keyboardResizeToggleListener">javax.swing.plaf.basic.BasicSplitPaneUI.keyboardResizeToggleListener</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#keyboardUpLeftListener">javax.swing.plaf.basic.BasicSplitPaneUI.keyboardUpLeftListener</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicToolBarUI.html#leftKey">javax.swing.plaf.basic.BasicToolBarUI.leftKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicTabbedPaneUI.html#leftKey">javax.swing.plaf.basic.BasicTabbedPaneUI.leftKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#leftKey">javax.swing.plaf.basic.BasicSplitPaneUI.leftKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicDesktopPaneUI.html#maximizeKey">javax.swing.plaf.basic.BasicDesktopPaneUI.maximizeKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>버젼 1.3 시점</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicDesktopPaneUI.html#minimizeKey">javax.swing.plaf.basic.BasicDesktopPaneUI.minimizeKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>버젼 1.3 시점</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#MOVE_CURSOR">java.awt.Frame.MOVE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.MOVE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#N_RESIZE_CURSOR">java.awt.Frame.N_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.N_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicDesktopPaneUI.html#navigateKey">javax.swing.plaf.basic.BasicDesktopPaneUI.navigateKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>버젼 1.3 시점</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicDesktopPaneUI.html#navigateKey2">javax.swing.plaf.basic.BasicDesktopPaneUI.navigateKey2</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>버젼 1.3 시점</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#NE_RESIZE_CURSOR">java.awt.Frame.NE_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.NE_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#NW_RESIZE_CURSOR">java.awt.Frame.NW_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.NW_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicInternalFrameUI.html#openMenuKey">javax.swing.plaf.basic.BasicInternalFrameUI.openMenuKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/datatransfer/DataFlavor.html#plainTextFlavor">java.awt.datatransfer.DataFlavor.plainTextFlavor</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Version 1.3 에서는,<code>Transferable.getTransferData(DataFlavor.plainTextFlavor)</code> 는 아니고, 
<code>DataFlavor.getReaderForText(Transferable)</code> 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/html/FormView.html#RESET">javax.swing.text.html.FormView.RESET</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>1.3 에서는, 값은 FormView.resetButtonText 의
             UIManager 프로퍼티으로부터의 것입니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/table/TableColumn.html#resizedPostingDisableCount">javax.swing.table.TableColumn.resizedPostingDisableCount</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicToolBarUI.html#rightKey">javax.swing.plaf.basic.BasicToolBarUI.rightKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicTabbedPaneUI.html#rightKey">javax.swing.plaf.basic.BasicTabbedPaneUI.rightKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#rightKey">javax.swing.plaf.basic.BasicSplitPaneUI.rightKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#S_RESIZE_CURSOR">java.awt.Frame.S_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.S_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#SE_RESIZE_CURSOR">java.awt.Frame.SE_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.SE_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/html/FormView.html#SUBMIT">javax.swing.text.html.FormView.SUBMIT</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>1.3 에서는, 값은 FormView.submitButtonText 의
             UIManager 프로퍼티으로부터의 것입니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Character.UnicodeBlock.html#SURROGATES_AREA">java.lang.Character.UnicodeBlock.SURROGATES_AREA</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>J2SE 5 에서는,<A HREF="java/lang/Character.UnicodeBlock.html#HIGH_SURROGATES"><CODE>Character.UnicodeBlock.HIGH_SURROGATES</CODE></A> ,<A HREF="java/lang/Character.UnicodeBlock.html#HIGH_PRIVATE_USE_SURROGATES"><CODE>Character.UnicodeBlock.HIGH_PRIVATE_USE_SURROGATES</CODE></A> , 및 <A HREF="java/lang/Character.UnicodeBlock.html#LOW_SURROGATES"><CODE>Character.UnicodeBlock.LOW_SURROGATES</CODE></A>  를 사용합니다. 이러한 새로운 정수는, Unicode 표준의 블록 정의에 일치합니다.
<A HREF="java/lang/Character.UnicodeBlock.html#of(char)"><CODE>Character.UnicodeBlock.of(char)</CODE></A>  메소드와 <A HREF="java/lang/Character.UnicodeBlock.html#of(int)"><CODE>Character.UnicodeBlock.of(int)</CODE></A>  메소드는, SURROGATES_AREA 는 아니고, 새로운 정수를 돌려줍니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#SW_RESIZE_CURSOR">java.awt.Frame.SW_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.SW_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#TEXT_CURSOR">java.awt.Frame.TEXT_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.TEXT_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicToolBarUI.html#upKey">javax.swing.plaf.basic.BasicToolBarUI.upKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicTabbedPaneUI.html#upKey">javax.swing.plaf.basic.BasicTabbedPaneUI.upKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#upKey">javax.swing.plaf.basic.BasicSplitPaneUI.upKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#W_RESIZE_CURSOR">java.awt.Frame.W_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.W_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#WAIT_CURSOR">java.awt.Frame.WAIT_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.WAIT_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="method"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 메소드</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#action(java.awt.Event, java.lang.Object)">java.awt.Component.action(Event, Object)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
액션 이벤트를 개시하는 컴퍼넌트의 ActionListener 로서
이 컴퍼넌트를 등록할 필요가 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#addItem(java.lang.String)">java.awt.List.addItem(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>add(String)</code> 를 사용</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#addItem(java.lang.String, int)">java.awt.List.addItem(String, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>add(String, int)</code> 를 사용</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/BorderLayout.html#addLayoutComponent(java.lang.String, java.awt.Component)">java.awt.BorderLayout.addLayoutComponent(String, Component)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>addLayoutComponent(Component, Object)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/CardLayout.html#addLayoutComponent(java.lang.String, java.awt.Component)">java.awt.CardLayout.addLayoutComponent(String, Component)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>addLayoutComponent(Component, Object)</code> 에
      옮겨놓을 수 있었습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#allowsMultipleSelections()">java.awt.List.allowsMultipleSelections()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>isMultipleMode()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/ThreadGroup.html#allowThreadSuspension(boolean)">java.lang.ThreadGroup.allowThreadSuspension(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 호출의 정의는, 추천되어 있지 않은 <A HREF="java/lang/ThreadGroup.html#suspend()"><CODE>ThreadGroup.suspend()</CODE></A>  에 의존합니다.
또, 이 호출의 동작은 지정되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#appendText(java.lang.String)">java.awt.TextArea.appendText(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>append(String)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Window.html#applyResourceBundle(java.util.ResourceBundle)">java.awt.Window.applyResourceBundle(ResourceBundle)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>J2SE version 1.4 이후는,
<A HREF="java/awt/Component.html#applyComponentOrientation(java.awt.ComponentOrientation)"><CODE>Component.applyComponentOrientation</CODE></A>  로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Window.html#applyResourceBundle(java.lang.String)">java.awt.Window.applyResourceBundle(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>J2SE version 1.4 이후는,
<A HREF="java/awt/Component.html#applyComponentOrientation(java.awt.ComponentOrientation)"><CODE>Component.applyComponentOrientation</CODE></A>  로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#bounds()">java.awt.Component.bounds()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>getBounds()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#checkMulticast(java.net.InetAddress, byte)">java.lang.SecurityManager.checkMulticast(InetAddress, byte)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 #checkPermission(java.security.Permission)를 사용하는</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#classDepth(java.lang.String)">java.lang.SecurityManager.classDepth(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐리티 체크는 추천 되지 않습니다.
대신에 <code>checkPermission</code> 의 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#classLoaderDepth()">java.lang.SecurityManager.classLoaderDepth()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐리티 체크는 추천 되지 않습니다.
대신에 <code>checkPermission</code> 의 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#clear()">java.awt.List.clear()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>removeAll()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/image/renderable/RenderContext.html#concetenateTransform(java.awt.geom.AffineTransform)">java.awt.image.renderable.RenderContext.concetenateTransform(AffineTransform)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>concatenateTransform(AffineTransform)</code> 에
                 옮겨놓을 수 있었습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#countComponents()">java.awt.Container.countComponents()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
getComponentCount()로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Menu.html#countItems()">java.awt.Menu.countItems()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getItemCount()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#countItems()">java.awt.List.countItems()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getItemCount()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Choice.html#countItems()">java.awt.Choice.countItems()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getItemCount()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuBar.html#countMenus()">java.awt.MenuBar.countMenus()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getMenuCount()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Thread.html#countStackFrames()">java.lang.Thread.countStackFrames()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 호출의 정의는, 추천되어 있지 않은 <A HREF="java/lang/Thread.html#suspend()"><CODE>Thread.suspend()</CODE></A>  에 의존합니다.
또, 이 호출의 결과는 보증되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_basic_dyn_any(org.omg.CORBA.TypeCode)">org.omg.CORBA.ORB.create_basic_dyn_any(TypeCode)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_dyn_any(org.omg.CORBA.Any)">org.omg.CORBA.ORB.create_dyn_any(Any)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_dyn_array(org.omg.CORBA.TypeCode)">org.omg.CORBA.ORB.create_dyn_array(TypeCode)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_dyn_enum(org.omg.CORBA.TypeCode)">org.omg.CORBA.ORB.create_dyn_enum(TypeCode)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_dyn_sequence(org.omg.CORBA.TypeCode)">org.omg.CORBA.ORB.create_dyn_sequence(TypeCode)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_dyn_struct(org.omg.CORBA.TypeCode)">org.omg.CORBA.ORB.create_dyn_struct(TypeCode)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_dyn_union(org.omg.CORBA.TypeCode)">org.omg.CORBA.ORB.create_dyn_union(TypeCode)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_recursive_sequence_tc(int, int)">org.omg.CORBA.ORB.create_recursive_sequence_tc(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 create_recursive_tc 와 create_sequence_tc 의 편성을 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/soap/SOAPElementFactory.html#create(javax.xml.soap.Name)">javax.xml.soap.SOAPElementFactory.create(Name)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에
 javax.xml.soap.SOAPFactory.createElement(javax.xml.soap.Name)를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/soap/SOAPElementFactory.html#create(java.lang.String)">javax.xml.soap.SOAPElementFactory.create(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에
 javax.xml.soap.SOAPFactory.createElement(String localName)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/soap/SOAPElementFactory.html#create(java.lang.String, java.lang.String, java.lang.String)">javax.xml.soap.SOAPElementFactory.create(String, String, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에
 javax.xml.soap.SOAPFactory.createElement(String localName,
                      String prefix,
                      String uri)
 (을)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#createKeyboardDownRightListener()">javax.swing.plaf.basic.BasicSplitPaneUI.createKeyboardDownRightListener()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#createKeyboardEndListener()">javax.swing.plaf.basic.BasicSplitPaneUI.createKeyboardEndListener()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#createKeyboardHomeListener()">javax.swing.plaf.basic.BasicSplitPaneUI.createKeyboardHomeListener()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#createKeyboardResizeToggleListener()">javax.swing.plaf.basic.BasicSplitPaneUI.createKeyboardResizeToggleListener()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#createKeyboardUpLeftListener()">javax.swing.plaf.basic.BasicSplitPaneUI.createKeyboardUpLeftListener()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JTable.html#createScrollPaneForTable(javax.swing.JTable)">javax.swing.JTable.createScrollPaneForTable(JTable)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Swing 1.0. 2 로 <code>new JScrollPane(aTable)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/TableView.html#createTableCell(javax.swing.text.Element)">javax.swing.text.TableView.createTableCell(Element)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>테이블 셀은 임의의 View 구현이 될 수가 있습니다만,
 테이블은 아니고,
 ViewFactory 에 의해 작성되도록(듯이) 합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/bind/JAXBContext.html#createValidator()">javax.xml.bind.JAXBContext.createValidator()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>since JAXB2. 0</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#currentClassLoader()">java.lang.SecurityManager.currentClassLoader()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐리티 체크는 추천 되지 않습니다.
대신에 <code>checkPermission</code> 의 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#currentLoadedClass()">java.lang.SecurityManager.currentLoadedClass()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐리티 체크는 추천 되지 않습니다.
대신에 <code>checkPermission</code> 의 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/URLDecoder.html#decode(java.lang.String)">java.net.URLDecoder.decode(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>플랫폼의 디폴트의 인코딩에 응해 결과적으로 얻을 수 있는 캐릭터 라인이 바뀔 가능성이 있습니다. 대신에, decode(String, String) 메소드를 사용해 인코딩을 지정하도록 해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/ClassLoader.html#defineClass(byte[], int, int)">java.lang.ClassLoader.defineClass(byte[], int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE>defineClass(String, byte[], int, int)</CODE></A>  로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#delItem(int)">java.awt.List.delItem(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>remove(String)</code> 와
                         <code>remove(int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#delItems(int, int)">java.awt.List.delItems(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 일반 이용될 예정은 없습니다.
 이 메소드는, 패키지 private 메소드로서 만
 보관 유지될 예정입니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#deliverEvent(java.awt.Event)">java.awt.Container.deliverEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
<code>dispatchEvent(AWTEvent e)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#deliverEvent(java.awt.Event)">java.awt.Component.deliverEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
<code>dispatchEvent(AWTEvent e)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/MBeanServer.html#deserialize(javax.management.ObjectName, byte[])">javax.management.MBeanServer.deserialize(ObjectName, byte[])</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="javax/management/MBeanServer.html#getClassLoaderFor(javax.management.ObjectName)"><CODE>getClassLoaderFor</CODE></A>  를 사용해, 직렬화 복원에 사용하는 적절한 클래스 로더를 가져옵니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/MBeanServer.html#deserialize(java.lang.String, byte[])">javax.management.MBeanServer.deserialize(String, byte[])</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="javax/management/MBeanServer.html#getClassLoaderRepository()"><CODE>MBeanServer.getClassLoaderRepository()</CODE></A>  를 사용해 클래스 로더 리포지터리(repository)를 취득해, 이것을 사용해 직렬화 복원을 실시합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/MBeanServer.html#deserialize(java.lang.String, javax.management.ObjectName, byte[])">javax.management.MBeanServer.deserialize(String, ObjectName, byte[])</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="javax/management/MBeanServer.html#getClassLoader(javax.management.ObjectName)"><CODE>getClassLoader</CODE></A>  를 사용해, 직렬화 복원에 사용하는 클래스 로더를 가져옵니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Thread.html#destroy()">java.lang.Thread.destroy()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는 원래 클린 업없이 파기되도록(듯이) 설계되고 있었습니다.
보관 유지되는 모니터는 락 된 상태를 유지합니다.
다만, 이 메소드는 구현되지 않았습니다.
구현되고 있으면(자),<A HREF="java/lang/Thread.html#suspend()"><CODE>Thread.suspend()</CODE></A>  와 거의 똑같이 데드락이 발생합니다.
타겟 thread가 중요한 system resource를 보호하는 락을 보관 유지한 상태로 파기되었을 경우, 어느 thread도 다시 이 자원에 액세스 할 수 없습니다.
다른 thread가 이 자원을 잠그려고 하면(자), 데드락이 발생합니다. 일반적으로, 이러한 데드락은, 프로세스의 「동결」에 의해 밝혀집니다. 자세한 것은, 이하를 참조해 주세요.
<a href="/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#disable()">java.awt.Component.disable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>setEnabled(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuItem.html#disable()">java.awt.MenuItem.disable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>setEnabled(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#disable()">javax.swing.JComponent.disable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,<code>java.awt.Component.setEnabled(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/table/TableColumn.html#disableResizedPosting()">javax.swing.table.TableColumn.disableResizedPosting()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/FocusManager.html#disableSwingFocusManager()">javax.swing.FocusManager.disableSwingFocusManager()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>1.4 이후는,
 <code>KeyboardFocusManager.setDefaultFocusTraversalPolicy(FocusTraversalPolicy)로 옮겨졌습니다. </code></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Skeleton.html#dispatch(java.rmi.Remote, java.rmi.server.RemoteCall, int, long)">java.rmi.server.Skeleton.dispatch(Remote, RemoteCall, int, long)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#done()">java.rmi.server.RemoteCall.done()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteRef.html#done(java.rmi.server.RemoteCall)">java.rmi.server.RemoteRef.done(RemoteCall)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 1.2 형식의 Stub는, 이 메소드를 사용하지 않습니다. 원격 참조로 일련의 메소드 호출 (<code>newCall</code>,<code>invoke</code>, 및 <code>done</code>)을 사용하는 대신에, Stub는 원격 참조로 <code>invoke(Remote, Method, Object[], int)</code> 메소드만을 사용해 파라미터의 정렬화, 원격 메소드의 실행, 및 반환값의 비정렬화를 실행합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/metal/MetalComboBoxUI.html#editablePropertyChanged(java.beans.PropertyChangeEvent)">javax.swing.plaf.metal.MetalComboBoxUI.editablePropertyChanged(PropertyChangeEvent)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 4 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#enable()">java.awt.Component.enable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>setEnabled(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuItem.html#enable()">java.awt.MenuItem.enable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>setEnabled(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#enable()">javax.swing.JComponent.enable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,<code>java.awt.Component.setEnabled(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#enable(boolean)">java.awt.Component.enable(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>setEnabled(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuItem.html#enable(boolean)">java.awt.MenuItem.enable(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>setEnabled(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/table/TableColumn.html#enableResizedPosting()">javax.swing.table.TableColumn.enableResizedPosting()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/URLEncoder.html#encode(java.lang.String)">java.net.URLEncoder.encode(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>플랫폼의 디폴트의 인코딩에 응해 결과적으로 얻을 수 있는 캐릭터 라인이 바뀔 가능성이 있습니다. 대신에, encode(String, String) 메소드를 사용해 인코딩을 지정하도록 해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/SignatureSpi.html#engineGetParameter(java.lang.String)">java.security.SignatureSpi.engineGetParameter(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/SignatureSpi.html#engineSetParameter(java.lang.String, java.lang.Object)">java.security.SignatureSpi.engineSetParameter(String, Object)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="java/security/SignatureSpi.html#engineSetParameter(java.security.spec.AlgorithmParameterSpec)"><CODE>engineSetParameter</CODE></A>  로 옮겨놓을 수 있었습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/datatransfer/DataFlavor.html#equals(java.lang.String)">java.awt.datatransfer.DataFlavor.equals(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>hashCode()</code> 규약과 일관성이 없기 때문에,
대신에 <code>isMimeTypeEqual(String)</code> 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ServerRequest.html#except(org.omg.CORBA.Any)">org.omg.CORBA.ServerRequest.except(Any)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>set_exception()를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#executeCall()">java.rmi.server.RemoteCall.executeCall()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/Any.html#extract_Principal()">org.omg.CORBA.Any.extract_Principal()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/SwingUtilities.html#findFocusOwner(java.awt.Component)">javax.swing.SwingUtilities.findFocusOwner(Component)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>1.4 이후,<code>KeyboardFocusManager.getFocusOwner()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#get_current()">org.omg.CORBA.ORB.get_current()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>resolve_initial_references</code> 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/Security.html#getAlgorithmProperty(java.lang.String, java.lang.String)">java.security.Security.getAlgorithmProperty(String, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는, SUN 암호화 서비스 프로바이더의 마스터 파일내에 있는 소유 프로퍼티의 값을 돌려주기 위해서(때문에) 사용됩니다.  이것은, 알고리즘 고유의 파라미터의 구문 분석 방법을 결정하기 위한 처리입니다. 이 메소드 대신에, 새로운 프로바이더를 사용하는, 알고리즘에 의존하지 않는 <code>AlgorithmParameters</code> 및 <code>KeyFactory</code> 엔진 클래스 (J2SE 1.2 플랫폼보다 도입)를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/ResultSet.html#getBigDecimal(int, int)">java.sql.ResultSet.getBigDecimal(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/CallableStatement.html#getBigDecimal(int, int)">java.sql.CallableStatement.getBigDecimal(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>getBigDecimal(int parameterIndex)</code> 또는 <code>getBigDecimal(String parameterName)</code> 를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/ResultSet.html#getBigDecimal(java.lang.String, int)">java.sql.ResultSet.getBigDecimal(String, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Polygon.html#getBoundingBox()">java.awt.Polygon.getBoundingBox()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getBounds()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/String.html#getBytes(int, int, byte[], int)">java.lang.String.getBytes(int, int, byte[], int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드에서는, 문자로부터 바이트에의 변환이 올바르게 행해지지 않습니다.
JDK&nbsp;1. 1 에서는, 문자로부터 바이트에의 변환에는, 플랫폼의 디폴트 캐릭터 세트를 사용하는 <A HREF="java/lang/String.html#getBytes()"><CODE>String.getBytes()</CODE></A>  메소드의 사용이 추천 됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Graphics.html#getClipRect()">java.awt.Graphics.getClipRect()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getClipBounds()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JMenuBar.html#getComponentAtIndex(int)">javax.swing.JMenuBar.getComponentAtIndex(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>getComponent(int i)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JPopupMenu.html#getComponentAtIndex(int)">javax.swing.JPopupMenu.getComponentAtIndex(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="java/awt/Container.html#getComponent(int)"><CODE>Container.getComponent(int)</CODE></A>  로 옮겨놓을 수 있었습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/CheckboxGroup.html#getCurrent()">java.awt.CheckboxGroup.getCurrent()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getSelectedCheckbox()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#getCursorType()">java.awt.Frame.getCursorType()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
<code>Component.getCursor()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#getDate()">java.sql.Time.getDate()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getDate()">java.util.Date.getDate()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.get(Calendar.MONTH)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#getDay()">java.sql.Time.getDay()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getDay()">java.util.Date.getDay()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.get(Calendar.DAY_OF_WEEK)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/URLConnection.html#getDefaultRequestProperty(java.lang.String)">java.net.URLConnection.getDefaultRequestProperty(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>URLConnection 의 해당 인스턴스를 취득한 뒤는, 인스턴스 고유의 getRequestProperty 메소드를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#getDefaultStream()">java.rmi.server.LogStream.getDefaultStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/StringMonitorMBean.html#getDerivedGauge()">javax.management.monitor.StringMonitorMBean.getDerivedGauge()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/StringMonitorMBean.html#getDerivedGauge(javax.management.ObjectName)"><CODE>StringMonitorMBean.getDerivedGauge(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/StringMonitor.html#getDerivedGauge()">javax.management.monitor.StringMonitor.getDerivedGauge()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,
 <A HREF="javax/management/monitor/StringMonitor.html#getDerivedGauge(javax.management.ObjectName)"><CODE>StringMonitor.getDerivedGauge(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/GaugeMonitorMBean.html#getDerivedGauge()">javax.management.monitor.GaugeMonitorMBean.getDerivedGauge()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/GaugeMonitorMBean.html#getDerivedGauge(javax.management.ObjectName)"><CODE>GaugeMonitorMBean.getDerivedGauge(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/GaugeMonitor.html#getDerivedGauge()">javax.management.monitor.GaugeMonitor.getDerivedGauge()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,
 <A HREF="javax/management/monitor/GaugeMonitor.html#getDerivedGauge(javax.management.ObjectName)"><CODE>GaugeMonitor.getDerivedGauge(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitorMBean.html#getDerivedGauge()">javax.management.monitor.CounterMonitorMBean.getDerivedGauge()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/CounterMonitorMBean.html#getDerivedGauge(javax.management.ObjectName)"><CODE>CounterMonitorMBean.getDerivedGauge(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitor.html#getDerivedGauge()">javax.management.monitor.CounterMonitor.getDerivedGauge()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,
 <A HREF="javax/management/monitor/CounterMonitor.html#getDerivedGauge(javax.management.ObjectName)"><CODE>CounterMonitor.getDerivedGauge(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/StringMonitorMBean.html#getDerivedGaugeTimeStamp()">javax.management.monitor.StringMonitorMBean.getDerivedGaugeTimeStamp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/StringMonitorMBean.html#getDerivedGaugeTimeStamp(javax.management.ObjectName)"><CODE>StringMonitorMBean.getDerivedGaugeTimeStamp(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/StringMonitor.html#getDerivedGaugeTimeStamp()">javax.management.monitor.StringMonitor.getDerivedGaugeTimeStamp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,
 <A HREF="javax/management/monitor/StringMonitor.html#getDerivedGaugeTimeStamp(javax.management.ObjectName)"><CODE>StringMonitor.getDerivedGaugeTimeStamp(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/GaugeMonitorMBean.html#getDerivedGaugeTimeStamp()">javax.management.monitor.GaugeMonitorMBean.getDerivedGaugeTimeStamp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/GaugeMonitorMBean.html#getDerivedGaugeTimeStamp(javax.management.ObjectName)"><CODE>GaugeMonitorMBean.getDerivedGaugeTimeStamp(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/GaugeMonitor.html#getDerivedGaugeTimeStamp()">javax.management.monitor.GaugeMonitor.getDerivedGaugeTimeStamp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,
 <A HREF="javax/management/monitor/GaugeMonitor.html#getDerivedGaugeTimeStamp(javax.management.ObjectName)"><CODE>GaugeMonitor.getDerivedGaugeTimeStamp(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitorMBean.html#getDerivedGaugeTimeStamp()">javax.management.monitor.CounterMonitorMBean.getDerivedGaugeTimeStamp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/CounterMonitorMBean.html#getDerivedGaugeTimeStamp(javax.management.ObjectName)"><CODE>CounterMonitorMBean.getDerivedGaugeTimeStamp(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitor.html#getDerivedGaugeTimeStamp()">javax.management.monitor.CounterMonitor.getDerivedGaugeTimeStamp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,
 <A HREF="javax/management/monitor/CounterMonitor.html#getDerivedGaugeTimeStamp(javax.management.ObjectName)"><CODE>CounterMonitor.getDerivedGaugeTimeStamp(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#getDividerBorderSize()">javax.swing.plaf.basic.BasicSplitPaneUI.getDividerBorderSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후는,
 디바이더에 경계를 설정합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/bind/Validator.html#getEventHandler()">javax.xml.bind.Validator.getEventHandler()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>since JAXB2. 0</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Toolkit.html#getFontList()">java.awt.Toolkit.getFontList()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="java/awt/GraphicsEnvironment.html#getAvailableFontFamilyNames()"><CODE>GraphicsEnvironment.getAvailableFontFamilyNames()</CODE></A>  를 참조해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/LabelView.html#getFontMetrics()">javax.swing.text.LabelView.getFontMetrics()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>FontMetrics 는, JDK 로 실행하는 경우는 Glyph draw에는
  사용되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Toolkit.html#getFontMetrics(java.awt.Font)">java.awt.Toolkit.getFontMetrics(Font)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.2 이후는,<code>Font</code> 메소드 
                <code>getLineMetrics</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Toolkit.html#getFontPeer(java.lang.String, int)">java.awt.Toolkit.getFontPeer(String, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>java.awt.GraphicsEnvironment#getAllFonts 를 참조해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#getHours()">java.sql.Date.getHours()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getHours()">java.util.Date.getHours()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.get(Calendar.HOUR_OF_DAY)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#getInCheck()">java.lang.SecurityManager.getInCheck()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐리티 체크는 추천 되지 않습니다.
대신에 <code>checkPermission</code> 의 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#getInputStream()">java.rmi.server.RemoteCall.getInputStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/KeyStroke.html#getKeyStroke(char, boolean)">javax.swing.KeyStroke.getKeyStroke(char, boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>getKeyStroke(char)를 사용</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/AbstractButton.html#getLabel()">javax.swing.AbstractButton.getLabel()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>getText</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Scrollbar.html#getLineIncrement()">java.awt.Scrollbar.getLineIncrement()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getUnitIncrement()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Runtime.html#getLocalizedInputStream(java.io.InputStream)">java.lang.Runtime.getLocalizedInputStream(InputStream)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK&nbsp;1. 1 에서는, 로컬인 인코딩의 바이트 스트림을 Unicode 의 문자 스트림로 변환하려면 ,<code>InputStreamReader</code> 클래스와 <code>BufferedReader</code> 클래스를 사용하는 (분)편이 적절합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Runtime.html#getLocalizedOutputStream(java.io.OutputStream)">java.lang.Runtime.getLocalizedOutputStream(OutputStream)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK&nbsp;1. 1 에서는, Unicode 의 문자 스트림을 로컬인 인코딩의 바이트 스트림로 변환하려면 ,<code>OutputStreamWriter</code> 클래스,<code>BufferedWriter</code> 클래스, 및 <code>PrintWriter</code> 클래스를 사용하는 (분)편이 적절합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/DriverManager.html#getLogStream()">java.sql.DriverManager.getLogStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/FontMetrics.html#getMaxDecent()">java.awt.FontMetrics.getMaxDecent()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1. 1 이후는,
 <code>getMaxDescent()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JRootPane.html#getMenuBar()">javax.swing.JRootPane.getMenuBar()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Swing version 1.0. 3 이후는,
<code>getJMenuBar()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JInternalFrame.html#getMenuBar()">javax.swing.JInternalFrame.getMenuBar()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Swing version 1.0. 3 이후는,
<code>getJMenuBar()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#getMinutes()">java.sql.Date.getMinutes()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getMinutes()">java.util.Date.getMinutes()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.get(Calendar.MINUTE)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#getMonth()">java.sql.Time.getMonth()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getMonth()">java.util.Date.getMonth()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.get(Calendar.MONTH)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#getNextFocusableComponent()">javax.swing.JComponent.getNextFocusableComponent()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.4 이후는,<code>FocusTraversalPolicy</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/MonitorMBean.html#getObservedObject()">javax.management.monitor.MonitorMBean.getObservedObject()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/MonitorMBean.html#getObservedObjects()"><CODE>MonitorMBean.getObservedObjects()</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/Monitor.html#getObservedObject()">javax.management.monitor.Monitor.getObservedObject()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/Monitor.html#getObservedObjects()"><CODE>Monitor.getObservedObjects()</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Operation.html#getOperation()">java.rmi.server.Operation.getOperation()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Skeleton.html#getOperations()">java.rmi.server.Skeleton.getOperations()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/ComponentOrientation.html#getOrientation(java.util.ResourceBundle)">java.awt.ComponentOrientation.getOrientation(ResourceBundle)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>J2SE 1.4 로부터는 <A HREF="java/awt/ComponentOrientation.html#getOrientation(java.util.Locale)"><CODE>ComponentOrientation.getOrientation(java.util.Locale)</CODE></A>  를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#getOutputStream()">java.rmi.server.RemoteCall.getOutputStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#getOutputStream()">java.rmi.server.LogStream.getOutputStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Scrollbar.html#getPageIncrement()">java.awt.Scrollbar.getPageIncrement()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getBlockIncrement()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/Signature.html#getParameter(java.lang.String)">java.security.Signature.getParameter(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#getPeer()">java.awt.Component.getPeer()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는, 프로그램은 직접 피어를 조작할 수 없습니다. <code>boolean isDisplayable()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Font.html#getPeer()">java.awt.Font.getPeer()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>폰트의 draw는 현재는 어느 플랫폼으로도 같습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuComponent.html#getPeer()">java.awt.MenuComponent.getPeer()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 프로그램은 직접 피어를 조작할 수 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/bind/Validator.html#getProperty(java.lang.String)">javax.xml.bind.Validator.getProperty(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>since JAXB2. 0</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#getResultStream(boolean)">java.rmi.server.RemoteCall.getResultStream(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#getSeconds()">java.sql.Date.getSeconds()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getSeconds()">java.util.Date.getSeconds()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.get(Calendar.SECOND)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RMIClassLoader.html#getSecurityContext(java.lang.ClassLoader)">java.rmi.server.RMIClassLoader.getSecurityContext(ClassLoader)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. Java 2 플랫폼 1.2 이후의 RMI 에서는, 클래스 로더의 시큐리티 문맥을 취득하기 위해서 이 메소드를 사용하지 않습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LoaderHandler.html#getSecurityContext(java.lang.ClassLoader)">java.rmi.server.LoaderHandler.getSecurityContext(ClassLoader)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JPasswordField.html#getText()">javax.swing.JPasswordField.getText()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.2 이후,<code>getPassword</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JPasswordField.html#getText(int, int)">javax.swing.JPasswordField.getText(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.2 이후,<code>getPassword</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitorMBean.html#getThreshold()">javax.management.monitor.CounterMonitorMBean.getThreshold()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/CounterMonitorMBean.html#getThreshold(javax.management.ObjectName)"><CODE>CounterMonitorMBean.getThreshold(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitor.html#getThreshold()">javax.management.monitor.CounterMonitor.getThreshold()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/CounterMonitor.html#getThreshold(javax.management.ObjectName)"><CODE>CounterMonitor.getThreshold(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getTimezoneOffset()">java.util.Date.getTimezoneOffset()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>-(Calendar.get(Calendar.ZONE_OFFSET) + Calendar.get(Calendar.DST_OFFSET)) / (60 * 1000)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/MulticastSocket.html#getTTL()">java.net.MulticastSocket.getTTL()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 getTimeToLive 메소드를 사용해 주세요. 이 메소드는,<b>byte</b> 는 아니고 <b>int</b> 를 돌려줍니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/DatagramSocketImpl.html#getTTL()">java.net.DatagramSocketImpl.getTTL()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 getTimeToLive 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/ResultSet.html#getUnicodeStream(int)">java.sql.ResultSet.getUnicodeStream(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>getUnicodeStream</code> 대신에 <code>getCharacterStream</code> 를 사용</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/ResultSet.html#getUnicodeStream(java.lang.String)">java.sql.ResultSet.getUnicodeStream(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 <code>getCharacterStream</code> 를 사용</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/ScrollPaneLayout.html#getViewportBorderBounds(javax.swing.JScrollPane)">javax.swing.ScrollPaneLayout.getViewportBorderBounds(JScrollPane)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 의 Swing 1.1 이후는
    <code>JScrollPane.getViewportBorderBounds()</code> 로 옮겨놓을 수 있었습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Scrollbar.html#getVisible()">java.awt.Scrollbar.getVisible()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getVisibleAmount()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#getYear()">java.sql.Time.getYear()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getYear()">java.util.Date.getYear()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.get(Calendar.YEAR) - 1900</code> 으로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#gotFocus(java.awt.Event, java.lang.Object)">java.awt.Component.gotFocus(Event, Object)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
processFocusEvent(FocusEvent)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#handleEvent(java.awt.Event)">java.awt.Component.handleEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
processEvent(AWTEvent)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Window.html#hide()">java.awt.Window.hide()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.5 이후는,
<A HREF="java/awt/Window.html#setVisible(boolean)"><CODE>Window.setVisible(boolean)</CODE></A>  로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#hide()">java.awt.Component.hide()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>setVisible(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Dialog.html#hide()">java.awt.Dialog.hide()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.5 이후는,
 <A HREF="java/awt/Dialog.html#setVisible(boolean)"><CODE>setVisible(boolean)</CODE></A>  로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#inClass(java.lang.String)">java.lang.SecurityManager.inClass(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐리티 체크는 추천 되지 않습니다.
대신에 <code>checkPermission</code> 의 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#inClassLoader()">java.lang.SecurityManager.inClassLoader()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐리티 체크는 추천 되지 않습니다.
대신에 <code>checkPermission</code> 의 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/Any.html#insert_Principal(org.omg.CORBA.Principal)">org.omg.CORBA.Any.insert_Principal(Principal)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/html/HTMLEditorKit.InsertHTMLTextAction.html#insertAtBoundry(javax.swing.JEditorPane, javax.swing.text.html.HTMLDocument, int, javax.swing.text.Element, java.lang.String, javax.swing.text.html.HTML.Tag, javax.swing.text.html.HTML.Tag)">javax.swing.text.html.HTMLEditorKit.InsertHTMLTextAction.insertAtBoundry(JEditorPane, HTMLDocument, int, Element, String, HTML.Tag, HTML.Tag)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 에 대해 insertAtBoundary 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#insertText(java.lang.String, int)">java.awt.TextArea.insertText(String, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>insert(String, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#insets()">java.awt.Container.insets()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
<code>getInsets()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#inside(int, int)">java.awt.Component.inside(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
contains(int, int)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Rectangle.html#inside(int, int)">java.awt.Rectangle.inside(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>contains(int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Polygon.html#inside(int, int)">java.awt.Polygon.inside(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>contains(int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteRef.html#invoke(java.rmi.server.RemoteCall)">java.rmi.server.RemoteRef.invoke(RemoteCall)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 1.2 형식의 Stub는, 이 메소드를 사용하지 않습니다. 원격 참조로 일련의 메소드 호출 (<code>newCall</code>,<code>invoke</code>, 및 <code>done</code>)을 사용하는 대신에, Stub는 원격 참조로 <code>invoke(Remote, Method, Object[], int)</code> 메소드만을 사용해 파라미터의 정렬화, 원격 메소드의 실행, 및 반환값의 비정렬화를 실행합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynamicImplementation.html#invoke(org.omg.CORBA.ServerRequest)">org.omg.CORBA.DynamicImplementation.invoke(ServerRequest)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Portable Object Adapter 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JViewport.html#isBackingStoreEnabled()">javax.swing.JViewport.isBackingStoreEnabled()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후,<code>getScrollMode()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/FocusManager.html#isFocusManagerEnabled()">javax.swing.FocusManager.isFocusManagerEnabled()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>1.4 이후는,
   <code>KeyboardFocusManager.getDefaultFocusTraversalPolicy()로 옮겨졌습니다. </code></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#isFocusTraversable()">java.awt.Component.isFocusTraversable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.4 이후는,<code>isFocusable()</code> 를 사용</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Character.html#isJavaLetter(char)">java.lang.Character.isJavaLetter(char)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>isJavaIdentifierStart(char)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Character.html#isJavaLetterOrDigit(char)">java.lang.Character.isJavaLetterOrDigit(char)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>isJavaIdentifierPart(char)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#isManagingFocus()">javax.swing.JComponent.isManagingFocus()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>1.4 이후는 <code>Component.setFocusTraversalKeys(int, Set)</code> 와 <code>Container.setFocusCycleRoot(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#isSelected(int)">java.awt.List.isSelected(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>isIndexSelected(int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Character.html#isSpace(char)">java.lang.Character.isSpace(char)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>isWhitespace(char)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/dgc/VMID.html#isUnique()">java.rmi.dgc.VMID.isUnique()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/bind/Unmarshaller.html#isValidating()">javax.xml.bind.Unmarshaller.isValidating()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>since JAXB2. 0,<A HREF="javax/xml/bind/Unmarshaller.html#getSchema()"><CODE>Unmarshaller.getSchema()</CODE></A>  를 참조</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#keyDown(java.awt.Event, int)">java.awt.Component.keyDown(Event, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
processKeyEvent(KeyEvent)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#keyUp(java.awt.Event, int)">java.awt.Component.keyUp(Event, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
processKeyEvent(KeyEvent)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#layout()">java.awt.Container.layout()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
<code>doLayout()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#layout()">java.awt.Component.layout()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
<code>doLayout()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/ScrollPane.html#layout()">java.awt.ScrollPane.layout()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>doLayout()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String)">java.rmi.server.RMIClassLoader.loadClass(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>loadClass(String, String)</code> 메소드로 옮겨졌던</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LoaderHandler.html#loadClass(java.lang.String)">java.rmi.server.LoaderHandler.loadClass(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LoaderHandler.html#loadClass(java.net.URL, java.lang.String)">java.rmi.server.LoaderHandler.loadClass(URL, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#locate(int, int)">java.awt.Container.locate(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
<code>getComponentAt(int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#locate(int, int)">java.awt.Component.locate(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
getComponentAt(int, int)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#location()">java.awt.Component.location()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>getLocation()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#log(java.lang.String)">java.rmi.server.LogStream.log(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#lostFocus(java.awt.Event, java.lang.Object)">java.awt.Component.lostFocus(Event, Object)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
processFocusEvent(FocusEvent)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#minimumSize()">java.awt.Container.minimumSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
<code>getMinimumSize()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#minimumSize()">java.awt.Component.minimumSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
<code>getMinimumSize()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextField.html#minimumSize()">java.awt.TextField.minimumSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getMinimumSize()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#minimumSize()">java.awt.TextArea.minimumSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getMinimumSize()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#minimumSize()">java.awt.List.minimumSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getMinimumSize()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextField.html#minimumSize(int)">java.awt.TextField.minimumSize(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getMinimumSize(int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#minimumSize(int)">java.awt.List.minimumSize(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getMinimumSize(int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#minimumSize(int, int)">java.awt.TextArea.minimumSize(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getMinimumSize(int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/View.html#modelToView(int, java.awt.Shape)">javax.swing.text.View.modelToView(int, Shape)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#mouseDown(java.awt.Event, int, int)">java.awt.Component.mouseDown(Event, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
processMouseEvent(MouseEvent)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#mouseDrag(java.awt.Event, int, int)">java.awt.Component.mouseDrag(Event, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
processMouseMotionEvent(MouseEvent)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#mouseEnter(java.awt.Event, int, int)">java.awt.Component.mouseEnter(Event, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
processMouseEvent(MouseEvent)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#mouseExit(java.awt.Event, int, int)">java.awt.Component.mouseExit(Event, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
processMouseEvent(MouseEvent)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#mouseMove(java.awt.Event, int, int)">java.awt.Component.mouseMove(Event, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
processMouseMotionEvent(MouseEvent)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#mouseUp(java.awt.Event, int, int)">java.awt.Component.mouseUp(Event, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
processMouseEvent(MouseEvent)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#move(int, int)">java.awt.Component.move(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>setLocation(int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Rectangle.html#move(int, int)">java.awt.Rectangle.move(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>setLocation(int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/Principal.html#name()">org.omg.CORBA.Principal.name()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/Principal.html#name(byte[])">org.omg.CORBA.Principal.name(byte[])</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteRef.html#newCall(java.rmi.server.RemoteObject, java.rmi.server.Operation[], int, long)">java.rmi.server.RemoteRef.newCall(RemoteObject, Operation[], int, long)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 1.2 형식의 Stub는, 이 메소드를 사용하지 않습니다. Stub의 원격 참조로 일련의 메소드 호출 (<code>newCall</code>,<code>invoke</code>, 및 <code>done</code>)을 사용하는 대신에, Stub는 원격 참조로 <code>invoke(Remote, Method, Object[], int)</code> 메소드만을 사용해, 파라미터의 정렬화, 원격 메소드의 실행, 및 반환값의 비정렬화를 실행합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#nextFocus()">java.awt.Component.nextFocus()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
transferFocus()로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/datatransfer/DataFlavor.html#normalizeMimeType(java.lang.String)">java.awt.datatransfer.DataFlavor.normalizeMimeType(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/activation/ActivationDataFlavor.html#normalizeMimeType(java.lang.String)">javax.activation.ActivationDataFlavor.normalizeMimeType(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/datatransfer/DataFlavor.html#normalizeMimeTypeParameter(java.lang.String, java.lang.String)">java.awt.datatransfer.DataFlavor.normalizeMimeTypeParameter(String, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/activation/ActivationDataFlavor.html#normalizeMimeTypeParameter(java.lang.String, java.lang.String)">javax.activation.ActivationDataFlavor.normalizeMimeTypeParameter(String, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ServerRequest.html#op_name()">org.omg.CORBA.ServerRequest.op_name()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>operation()를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ServerRequest.html#params(org.omg.CORBA.NVList)">org.omg.CORBA.ServerRequest.params(NVList)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>arguments</code> 메소드를 사용하는<!-- ENDMARK --></FONT></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#parse(java.lang.String)">java.util.Date.parse(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>DateFormat.parse(String s)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#parseLevel(java.lang.String)">java.rmi.server.LogStream.parseLevel(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuContainer.html#postEvent(java.awt.Event)">java.awt.MenuContainer.postEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는,
 dispatchEvent(AWTEvent)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Window.html#postEvent(java.awt.Event)">java.awt.Window.postEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
<code>dispatchEvent(AWTEvent)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#postEvent(java.awt.Event)">java.awt.Component.postEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
dispatchEvent(AWTEvent)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuComponent.html#postEvent(java.awt.Event)">java.awt.MenuComponent.postEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <A HREF="java/awt/MenuComponent.html#dispatchEvent(java.awt.AWTEvent)"><CODE>dispatchEvent</CODE></A>  로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/image/renderable/RenderContext.html#preConcetenateTransform(java.awt.geom.AffineTransform)">java.awt.image.renderable.RenderContext.preConcetenateTransform(AffineTransform)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>preConcatenateTransform(AffineTransform)</code> 에
                 (으)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#preferredSize()">java.awt.Container.preferredSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
<code>getPreferredSize()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#preferredSize()">java.awt.Component.preferredSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>getPreferredSize()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextField.html#preferredSize()">java.awt.TextField.preferredSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getPreferredSize()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#preferredSize()">java.awt.TextArea.preferredSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getPreferredSize()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#preferredSize()">java.awt.List.preferredSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getPreferredSize()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextField.html#preferredSize(int)">java.awt.TextField.preferredSize(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getPreferredSize(int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#preferredSize(int)">java.awt.List.preferredSize(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getPreferredSize(int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#preferredSize(int, int)">java.awt.TextArea.preferredSize(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>getPreferredSize(int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/portable/InputStream.html#read_Principal()">org.omg.CORBA.portable.InputStream.read_Principal()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/DataInputStream.html#readLine()">java.io.DataInputStream.readLine()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는, 바이트를 적절히 캐릭터 라인으로 변환하지 않습니다. JDK&nbsp;1. 1 에서는, 텍스트행을 읽어들이는 방법으로서는 <code>BufferedReader.readLine()</code> 메소드를 사용하는 것이 추천 되고 있습니다. 행을 읽어들이는데 <code>DataInputStream</code> 클래스를 사용하는 프로그램을,<code>BufferedReader</code> 클래스를 사용하도록(듯이) 변환하려면 , 다음의 형식의 코드를,
 <blockquote><pre>
     DataInputStream d =&nbsp;new&nbsp;DataInputStream(in);
 </pre></blockquote>
다음의 형식의 코드로 옮겨놓습니다.
 <blockquote><pre>
     BufferedReader d
          =&nbsp;new&nbsp;BufferedReader(new&nbsp;InputStreamReader(in));
 </pre></blockquote></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/ObjectInputStream.html#readLine()">java.io.ObjectInputStream.readLine()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드에서는, 바이트로부터 문자에의 변환이 올바르게 행해지지 않습니다.
                상세 및 대체 메소드에 대해서는 DataInputStream 을 참조해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/registry/RegistryHandler.html#registryImpl(int)">java.rmi.registry.RegistryHandler.registryImpl(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. Java 2 플랫폼 1.2 이후는,
 RMI 는 레지스트리의 구현을 취득하기 위해서 
 <code>RegistryHandler</code> 를 사용하지 않습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/registry/RegistryHandler.html#registryStub(java.lang.String, int)">java.rmi.registry.RegistryHandler.registryStub(String, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. Java 2 플랫폼 1.2 이후는,
 RMI 는 레지스트리의 Stub를 취득하기 위해서 
 <code>RegistryHandler</code> 를 사용하지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#releaseInputStream()">java.rmi.server.RemoteCall.releaseInputStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#releaseOutputStream()">java.rmi.server.RemoteCall.releaseOutputStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/metal/MetalComboBoxUI.html#removeListeners()">javax.swing.plaf.metal.MetalComboBoxUI.removeListeners()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 4 이후 사용되고 있지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#replaceText(java.lang.String, int, int)">java.awt.TextArea.replaceText(String, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>replaceRange(String, int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#requestDefaultFocus()">javax.swing.JComponent.requestDefaultFocus()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>1.4 이후는 <code>FocusTraversalPolicy.getDefaultComponent(Container). requestFocus()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Window.html#reshape(int, int, int, int)">java.awt.Window.reshape(int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
<code>setBounds(int, int, int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#reshape(int, int, int, int)">java.awt.Component.reshape(int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>setBounds(int, int, int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Rectangle.html#reshape(int, int, int, int)">java.awt.Rectangle.reshape(int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>setBounds(int, int, int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#reshape(int, int, int, int)">javax.swing.JComponent.reshape(int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 5 이후는,<code>Component.setBounds(int, int, int, int)</code> 로 옮겨졌습니다.

 <p>
이 컴퍼넌트를 이동해, 사이즈 변경합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#resize(java.awt.Dimension)">java.awt.Component.resize(Dimension)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>setSize(Dimension)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#resize(int, int)">java.awt.Component.resize(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>setSize(int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Rectangle.html#resize(int, int)">java.awt.Rectangle.resize(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>setSize(int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ServerRequest.html#result(org.omg.CORBA.Any)">org.omg.CORBA.ServerRequest.result(Any)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>set_result</code> 메소드를 사용하는<!-- ENDMARK --></FONT></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Thread.html#resume()">java.lang.Thread.resume()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는 데드락을 발생하기 쉽기 때문에 추천 되지 않습니다.  <A HREF="java/lang/Thread.html#suspend()"><CODE>Thread.suspend()</CODE></A>  와 함께 사용하기 위해(때문에)인 만큼 제공되고 있습니다.

자세한 것은, 이하를 참조해 주세요.  
<a href="/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/ThreadGroup.html#resume()">java.lang.ThreadGroup.resume()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는 단지 <tt>Thread.suspend</tt> 및 <tt>ThreadGroup.suspend</tt> 와 조합해 사용됩니다.  모두 데드락을 발생시키기 쉽기 때문에 추천 되지 않습니다. 자세한 것은 <A HREF="java/lang/Thread.html#suspend()"><CODE>Thread.suspend()</CODE></A>  를 참조해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/System.html#runFinalizersOnExit(boolean)">java.lang.System.runFinalizersOnExit(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는 본질적으로 안전하지는 않습니다. 파이나라이자가 라이브 객체에 대해서 불려 가는 결과가 될 가능성이 있어, 그 때 다른 thread가 그러한 객체를 병행해 조작하고 있으면(자), 동작이 이상하게 되는지, 데드락이 발생합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Runtime.html#runFinalizersOnExit(boolean)">java.lang.Runtime.runFinalizersOnExit(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는 본질적으로 안전하지는 않습니다. 파이나라이자가 라이브 객체에 대해서 불려 가는 결과가 될 가능성이 있어, 그 때 다른 thread가 그러한 객체를 병행해 조작하고 있으면(자), 동작이 이상하게 되는지, 데드락이 발생합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Properties.html#save(java.io.OutputStream, java.lang.String)">java.util.Properties.save(OutputStream, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는, 프로퍼티 리스트의 보존중에 입출력 에러가 발생해도, IOException 를 throw 하지 않습니다. 프로퍼티 리스트의 보존 방법으로서는,<code>store(OutputStream out, String comments)</code> 메소드 또는 <code>storeToXML(OutputStream os, String comment)</code> 메소드의 사용이 추천 됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/MulticastSocket.html#send(java.net.DatagramPacket, byte)">java.net.MulticastSocket.send(DatagramPacket, byte)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에, 다음의 코드 또는 그것과 동등의 코드를 사용해 주세요.
        ......
        + context.getLifetime());
+ context.getLifetime());
        + context.getLifetime());
        + context.getLifetime());
        ......</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JViewport.html#setBackingStoreEnabled(boolean)">javax.swing.JViewport.setBackingStoreEnabled(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후,<code>setScrollMode()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/CheckboxGroup.html#setCurrent(java.awt.Checkbox)">java.awt.CheckboxGroup.setCurrent(Checkbox)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>setSelectedCheckbox(Checkbox)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#setCursor(int)">java.awt.Frame.setCursor(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,
<code>Component.setCursor(Cursor)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#setDate(int)">java.sql.Time.setDate(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#setDate(int)">java.util.Date.setDate(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.set(Calendar.DAY_OF_MONTH, int date)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/URLConnection.html#setDefaultRequestProperty(java.lang.String, java.lang.String)">java.net.URLConnection.setDefaultRequestProperty(String, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>URLConnection 의 해당 인스턴스를 취득한 뒤는, 인스턴스 고유의 setRequestProperty 메소드를 사용합니다. 이 메소드를 호출해도, 무슨 효과도 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#setDefaultStream(java.io.PrintStream)">java.rmi.server.LogStream.setDefaultStream(PrintStream)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextField.html#setEchoCharacter(char)">java.awt.TextField.setEchoCharacter(char)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>setEchoChar(char)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/bind/Validator.html#setEventHandler(javax.xml.bind.ValidationEventHandler)">javax.xml.bind.Validator.setEventHandler(ValidationEventHandler)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>since JAXB2. 0</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#setHours(int)">java.sql.Date.setHours(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#setHours(int)">java.util.Date.setHours(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.set(Calendar.HOUR_OF_DAY, int hours)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/AbstractButton.html#setLabel(java.lang.String)">javax.swing.AbstractButton.setLabel(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>setText(text)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Scrollbar.html#setLineIncrement(int)">java.awt.Scrollbar.setLineIncrement(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>setUnitIncrement(int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/DriverManager.html#setLogStream(java.io.PrintStream)">java.sql.DriverManager.setLogStream(PrintStream)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/ValueExp.html#setMBeanServer(javax.management.MBeanServer)">javax.management.ValueExp.setMBeanServer(MBeanServer)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>ValueExp</code> 는 MBean 서버에 액세스 해,
 <A HREF="javax/management/QueryEval.html#getMBeanServer()"><CODE>QueryEval.getMBeanServer()</CODE></A>  를 사용해 평가되기 (위해)때문에,
 이 메소드는 불필요합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JRootPane.html#setMenuBar(javax.swing.JMenuBar)">javax.swing.JRootPane.setMenuBar(JMenuBar)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Swing version 1.0. 3 이후는,
<code>setJMenuBar(JMenuBar menu)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JInternalFrame.html#setMenuBar(javax.swing.JMenuBar)">javax.swing.JInternalFrame.setMenuBar(JMenuBar)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Swing version 1.0. 3 이후는,
<code>setJMenuBar(JMenuBar m)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#setMinutes(int)">java.sql.Date.setMinutes(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#setMinutes(int)">java.util.Date.setMinutes(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.set(Calendar.MINUTE, int minutes)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/event/KeyEvent.html#setModifiers(int)">java.awt.event.KeyEvent.setModifiers(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK1. 1.4 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#setMonth(int)">java.sql.Time.setMonth(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#setMonth(int)">java.util.Date.setMonth(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.set(Calendar.MONTH, int month)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#setMultipleSelections(boolean)">java.awt.List.setMultipleSelections(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>setMultipleMode(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#setNextFocusableComponent(java.awt.Component)">javax.swing.JComponent.setNextFocusableComponent(Component)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.4 이후는,<code>FocusTraversalPolicy</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/MonitorMBean.html#setObservedObject(javax.management.ObjectName)">javax.management.monitor.MonitorMBean.setObservedObject(ObjectName)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/MonitorMBean.html#addObservedObject(javax.management.ObjectName)"><CODE>MonitorMBean.addObservedObject(javax.management.ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/Monitor.html#setObservedObject(javax.management.ObjectName)">javax.management.monitor.Monitor.setObservedObject(ObjectName)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/Monitor.html#addObservedObject(javax.management.ObjectName)"><CODE>Monitor.addObservedObject(javax.management.ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#setOutputStream(java.io.OutputStream)">java.rmi.server.LogStream.setOutputStream(OutputStream)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Scrollbar.html#setPageIncrement(int)">java.awt.Scrollbar.setPageIncrement(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.1 이후는,
 <code>setBlockIncrement()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/Signature.html#setParameter(java.lang.String, java.lang.Object)">java.security.Signature.setParameter(String, Object)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="java/security/Signature.html#setParameter(java.security.spec.AlgorithmParameterSpec)"><CODE>setParameter</CODE></A>  를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/bind/Validator.html#setProperty(java.lang.String, java.lang.Object)">javax.xml.bind.Validator.setProperty(String, Object)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>since JAXB2. 0</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteStub.html#setRef(java.rmi.server.RemoteStub, java.rmi.server.RemoteRef)">java.rmi.server.RemoteStub.setRef(RemoteStub, RemoteRef)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. <code>RemoteStub</code> 은 <code>RemoteStub(RemoteRef)</code> 생성자 을 사용해 작성할 수 있기 (위해)때문에,<code>setRef</code> 메소드는 필요 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#setSeconds(int)">java.sql.Date.setSeconds(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#setSeconds(int)">java.util.Date.setSeconds(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.set(Calendar.SECOND, int seconds)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitorMBean.html#setThreshold(java.lang.Number)">javax.management.monitor.CounterMonitorMBean.setThreshold(Number)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/CounterMonitorMBean.html#setInitThreshold(java.lang.Number)"><CODE>CounterMonitorMBean.setInitThreshold(java.lang.Number)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitor.html#setThreshold(java.lang.Number)">javax.management.monitor.CounterMonitor.setThreshold(Number)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/CounterMonitor.html#setInitThreshold(java.lang.Number)"><CODE>CounterMonitor.setInitThreshold(java.lang.Number)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/MulticastSocket.html#setTTL(byte)">java.net.MulticastSocket.setTTL(byte)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 setTimeToLive 메소드를 사용해 주세요. 이 메소드는 ttl 의 형태로서<b>byte</b> 는 아니고 <b>int</b> 를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/DatagramSocketImpl.html#setTTL(byte)">java.net.DatagramSocketImpl.setTTL(byte)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 setTimeToLive 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/PreparedStatement.html#setUnicodeStream(int, java.io.InputStream, int)">java.sql.PreparedStatement.setUnicodeStream(int, InputStream, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/sql/rowset/BaseRowSet.html#setUnicodeStream(int, java.io.InputStream, int)">javax.sql.rowset.BaseRowSet.setUnicodeStream(int, InputStream, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 getCharacterStream 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/URLStreamHandler.html#setURL(java.net.URL, java.lang.String, java.lang.String, int, java.lang.String, java.lang.String)">java.net.URLStreamHandler.setURL(URL, String, String, int, String, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>setURL(URL, String, int, String, String, String, String)를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/bind/Unmarshaller.html#setValidating(boolean)">javax.xml.bind.Unmarshaller.setValidating(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>since JAXB2. 0,<A HREF="javax/xml/bind/Unmarshaller.html#setSchema(javax.xml.validation.Schema)"><CODE>Unmarshaller.setSchema(javax.xml.validation.Schema)</CODE></A>  를 참조</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#setYear(int)">java.sql.Time.setYear(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#setYear(int)">java.util.Date.setYear(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.set(Calendar.YEAR, year + 1900)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Window.html#show()">java.awt.Window.show()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.5 이후는,
<A HREF="java/awt/Window.html#setVisible(boolean)"><CODE>Window.setVisible(boolean)</CODE></A>  로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#show()">java.awt.Component.show()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>setVisible(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Dialog.html#show()">java.awt.Dialog.show()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.5 이후는,
 <A HREF="java/awt/Dialog.html#setVisible(boolean)"><CODE>setVisible(boolean)</CODE></A>  로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#show(boolean)">java.awt.Component.show(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>setVisible(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#size()">java.awt.Component.size()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>getSize()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JTable.html#sizeColumnsToFit(boolean)">javax.swing.JTable.sizeColumnsToFit(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Swing 1.0. 3 이후는,<code>doLayout()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Thread.html#stop()">java.lang.Thread.stop()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는 본질적으로 안전하지는 않습니다. Thread.stop 를 사용해 thread를 정지하면(자), 체크되어 있지 않은 <code>ThreadDeath</code> 예외가 스택아래에서 위에게 전할 수 있었던 결과, 그 thread에 의해 락 되고 있던 모니터의 락이 모두 해제됩니다. 이러한 모니터에 의해 직전까지 보호되고 있던 객체가 무결성의 없는 상태에 있었을 경우, 망가진 객체는 다른 thread에 대해서 가시가 되어, 동작이 보증되지 않는 것이 있습니다. 많은 경우, 타겟 thread의 실행 정지를 지시하려면 ,<code>stop</code> 는 아니고, 단지 일부의 변수를 변경하는 코드를 사용할 필요가 있습니다. 타겟 thread는, 이 변수를 정기적으로 검사해, 실행을 정지해야 할 일을 변수가 가리키고 있는 경우에는, thread의 run 메소드로부터 일반적으로의 방법으로 복귀할 필요가 있습니다. 조건 변수등으로 타겟 thread가 오랫동안 대기하고 있는 경우, 대기를 중단시키려면 ,<code>interrupt</code> 메소드를 사용합니다.  
자세한 것은, 이하를 참조해 주세요.  
<a href="/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/ThreadGroup.html#stop()">java.lang.ThreadGroup.stop()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는 본질적으로 안전하지는 않습니다. 자세한 것은 <A HREF="java/lang/Thread.html#stop()"><CODE>Thread.stop()</CODE></A>  를 참조해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Thread.html#stop(java.lang.Throwable)">java.lang.Thread.stop(Throwable)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는 본질적으로 안전하지는 않습니다. <A HREF="java/lang/Thread.html#stop()"><CODE>Thread.stop()</CODE></A>  를 참조해 주세요.
게다가 이 메소드는, 타겟 thread로 처리의 준비가 되어 있지 않은 예외의 생성에 사용되는 일이 있는 점에서도 위험합니다 (이 메소드가 없으면 thread에 의해 throw 될리가 없는, 체크된 예외 등).
자세한 것은, 이하를 참조해 주세요.  
<a href="/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Thread.html#suspend()">java.lang.Thread.suspend()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는 데드락을 발생하기 쉽기 때문에 추천 되지 않습니다.
타겟 thread가, 중단되는 시점에서, 중요한 system resource를 보호하는 모니터를 잠그고 있는 경우, 타겟 thread가 재개될 때까지 어느 thread도 그 자원에 액세스 할 수 없습니다. 이 때, 타겟 thread를 재개하는 thread가,<code>resume</code> 를 호출하기 전에 이 모니터를 잠그려고 하면(자), 데드락이 발생합니다. 일반적으로, 이러한 데드락은, 프로세스의 「동결」에 의해 밝혀집니다.
자세한 것은, 이하를 참조해 주세요.  
<a href="/../technotes/guides/concurrency/threadPrimitiveDeprecation.html">Thread.stop, Thread.suspend, Thread.resume, 및 Runtime.runFinalizersOnExit 가 추천 되지 않는 이유</a> </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/ThreadGroup.html#suspend()">java.lang.ThreadGroup.suspend()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는 본질적으로 데드락을 발생시키기 쉬워지고 있습니다. 자세한 것은 <A HREF="java/lang/Thread.html#suspend()"><CODE>Thread.suspend()</CODE></A>  를 참조해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#toGMTString()">java.util.Date.toGMTString()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는, GMT <code>TimeZone</code> 를 사용하는 것으로써,<code>DateFormat.format(Date date)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#toLocaleString()">java.util.Date.toLocaleString()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>DateFormat.format(Date date)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Operation.html#toString()">java.rmi.server.Operation.toString()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#toString()">java.rmi.server.LogStream.toString()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/ByteArrayOutputStream.html#toString(int)">java.io.ByteArrayOutputStream.toString(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는 바이트를 캐릭터 라인에 적절히 변환할 수 없습니다. JDK&nbsp;1. 1 현재, 추천 되는 방법은, 인코딩명을 인수에 취하는 <code>toString(String enc)</code> 메소드인가, 플랫폼의 디폴트의 캐릭터 세트를 사용하는 <code>toString()</code> 메소드를 사용하는 것입니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/File.html#toURL()">java.io.File.toURL()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드에서는, URL 내에서 사용할 수 없는 이스케이프 문자는 자동적으로 변환할 수 없습니다. 새로운 코드의 추상 경로명을 URL 로 변환하려면 , 우선 <A HREF="java/io/File.html#toURI()"><CODE>toURI</CODE></A>  메소드를 사용해 URI 로 변환하고 나서,<A HREF="java/net/URI.html#toURL()"><CODE>URI.toURL</CODE></A>  메소드를 사용해 URL 로 변환하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#UTC(int, int, int, int, int, int)">java.util.Date.UTC(int, int, int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.set(year + 1900, month, date, hrs, min, sec)</code> 또는 <code>GregorianCalendar(year + 1900, month, date, hrs, min, sec)</code> 로 옮겨졌습니다. UTC <code>TimeZone</code> 를 사용해,<code>Calendar.getTime(). getTime()</code> 가 나중에 계속됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/bind/Validator.html#validate(java.lang.Object)">javax.xml.bind.Validator.validate(Object)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>since JAXB2. 0</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/xml/bind/Validator.html#validateRoot(java.lang.Object)">javax.xml.bind.Validator.validateRoot(Object)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>since JAXB2. 0</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/View.html#viewToModel(float, float, java.awt.Shape)">javax.swing.text.View.viewToModel(float, float, Shape)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/portable/OutputStream.html#write_Principal(org.omg.CORBA.Principal)">org.omg.CORBA.portable.OutputStream.write_Principal(Principal)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#write(byte[], int, int)">java.rmi.server.LogStream.write(byte[], int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#write(int)">java.rmi.server.LogStream.write(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/ObjectOutputStream.PutField.html#write(java.io.ObjectOutput)">java.io.ObjectOutputStream.PutField.write(ObjectOutput)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는,<code>PutField</code> 객체에 의해 포함되었을 때의 형식에서 값을 기입하지 않기 때문에, 직렬화 스트림이 파괴되는 일이 있습니다. <code>PutField</code> 데이터를 올바르게 기입하려면 ,<A HREF="java/io/ObjectOutputStream.html#writeFields()"><CODE>ObjectOutputStream.writeFields()</CODE></A>  메소드를 호출합니다. </I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="constructor"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 생성자</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/AttributeValueExp.html#AttributeValueExp()">javax.management.AttributeValueExp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 생성자 으로 작성된 인스턴스는,
 쿼리 안에서는 사용할 수 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#Date(int, int, int)">java.sql.Date(int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 생성자 <code>Date(long date)</code> 를 사용</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#Date(int, int, int)">java.util.Date(int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.set(year + 1900, month, date)</code> 또는 <code>GregorianCalendar(year + 1900, month, date)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#Date(int, int, int, int, int)">java.util.Date(int, int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.set(year + 1900, month, date,  hrs, min)</code> 또는 <code>GregorianCalendar(year + 1900, month, date, hrs, min)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#Date(int, int, int, int, int, int)">java.util.Date(int, int, int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>Calendar.set(year + 1900, month, date, hrs, min, sec)</code> 또는 <code>GregorianCalendar(year + 1900, month, date, hrs, min, sec)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#Date(java.lang.String)">java.util.Date(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK Version 1.1 이후는,<code>DateFormat.parse(String s)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/event/KeyEvent.html#KeyEvent(java.awt.Component, int, long, int, int)">java.awt.event.KeyEvent(Component, int, long, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK1. 1 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Operation.html#Operation(java.lang.String)">java.rmi.server.Operation(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/RMISecurityException.html#RMISecurityException(java.lang.String)">java.rmi.RMISecurityException(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/RMISecurityException.html#RMISecurityException(java.lang.String, java.lang.String)">java.rmi.RMISecurityException(String, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/ServerRuntimeException.html#ServerRuntimeException(java.lang.String, java.lang.Exception)">java.rmi.ServerRuntimeException(String, Exception)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/SkeletonMismatchException.html#SkeletonMismatchException(java.lang.String)">java.rmi.server.SkeletonMismatchException(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/Socket.html#Socket(java.net.InetAddress, int, boolean)">java.net.Socket(InetAddress, int, boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>UDP 전송은 아니고 DatagramSocket 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/Socket.html#Socket(java.lang.String, int, boolean)">java.net.Socket(String, int, boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>UDP 전송은 아니고 DatagramSocket 를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/StreamTokenizer.html#StreamTokenizer(java.io.InputStream)">java.io.StreamTokenizer(InputStream)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 1.1 현재, 입력 스트림을 토큰화하려면 , 다음과 같이 해 입력 스트림을 문자 스트림로 변환할 방법이 적절합니다.
 <blockquote><pre>
   Reader r = new BufferedReader(new InputStreamReader(is));
   StreamTokenizer st = new StreamTokenizer(r);
 </pre></blockquote></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/String.html#String(byte[], int)">java.lang.String(byte[], int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드에서는, 바이트로부터 문자에의 변환이 올바르게 행해지지 않습니다.
JDK&nbsp;1. 1 이후에서는, 바이트로부터 문자에의 변환에는, 인수로서 <A HREF="java/nio/charset/Charset.html" title="java.nio.charset 안의 클래스"><CODE>Charset</CODE></A> , 캐릭터 세트의 이름을 취하는 <code>String</code> 생성자 , 또는 플랫폼의 디폴트 캐릭터 세트를 사용하는 <code>String</code> 생성자 의 사용이 추천 됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/String.html#String(byte[], int, int, int)">java.lang.String(byte[], int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드에서는, 바이트로부터 문자에의 변환이 올바르게 행해지지 않습니다.
JDK&nbsp;1. 1 이후에서는, 바이트로부터 문자에의 변환에는, 인수로서 <A HREF="java/nio/charset/Charset.html" title="java.nio.charset 안의 클래스"><CODE>Charset</CODE></A> , 캐릭터 세트의 이름을 취하는 <code>String</code> 생성자 , 또는 플랫폼의 디폴트 캐릭터 세트를 사용하는 <code>String</code> 생성자 의 사용이 추천 됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/TCKind.html#TCKind(int)">org.omg.CORBA.TCKind(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메소드는 OMG 스펙에 의하면 private 이기 (위해)때문에,
 이 생성자 은 사용하지 말아 주세요. 대신에 <A HREF="org/omg/CORBA/TCKind.html#from_int(int)"><CODE>TCKind.from_int(int)</CODE></A>  를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#Time(int, int, int)">java.sql.Time(int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 생성자  대신에 밀리 세컨드의 값을 받는 생성자 을 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Timestamp.html#Timestamp(int, int, int, int, int, int, int)">java.sql.Timestamp(int, int, int, int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Timestamp(long millis)</code> 생성자 을 대신에 사용해 주세요. </I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="annotation_type_member"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 주석형의 요소</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/jws/HandlerChain.html#name()">javax.jws.HandlerChain.name</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JSR-181 2.0 이후는 추천 되지 않게 되어, 대체는 없습니다. </I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">패키지</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">사용</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>비추천 API</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;Platform<br>Standard&nbsp;Ed.  6</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp; 전&nbsp;
&nbsp;다음</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?deprecated-list.html" target="_top"><B>프레임 있어</B></A>   &nbsp;
&nbsp;<A HREF="deprecated-list.html" target="_top"><B>프레임 없음</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1"><a href="http://bugs.sun.com/services/bugreport/index.jsp">버그의 보고와 기능의 요청</a> <br>한층 더 자세한 API 레퍼런스 및 개발자 문서에 대해서는,<a href="/../../webnotes/devdocs-vs-specs.html">Java SE 개발자용 문서</a>를 참조해 주세요. 개발자전용의 상세한 해설, 개념의 개요, 용어의 정의, 버그의 회피책, 및 코드 실례가 포함되어 있습니다. <p>Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="/../legal/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조해 주세요. </font>
</BODY>
</HTML>
