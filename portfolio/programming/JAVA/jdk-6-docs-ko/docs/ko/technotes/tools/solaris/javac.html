<? xml version="1.0" encoding="utf-8"? >
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">

    <link rel="stylesheet" href="../../css/tools.css"  type="text/css" />
<title>javac - Java 프로그램 언어 컴파일러 - xrath.com 에서 번역됨</title>
  </head>

  <body>
<h1>javac - Java 프로그램 언어 컴파일러</h1>

    <ul>
<li><a href="#synopsis">형식</a> </li>

<li><a href="#description">설명</a> </li>

<li><a href="#options">옵션</a> </li>

<li><a href="#commandlineargfile">커멘드행 인수 파일</a> </li>

<li><a href="#processing">주석 처리</a> </li>

<li><a href="#searching">형태의 검색</a> </li>

<li><a href="#proginterface">프로그라마틱인타페스</a> </li>

<li><a href="#examples">례</a> </li>

<li><a href="#seealso">관련 항목</a> </li>
    </ul>

<h2><a name="synopsis">형식</a> </h2>

    <blockquote>
      <pre>
	<b>javac</b> [ options ] [ sourcefiles ] [ classes ] [ @argfiles ]
      </pre>
<p>인수는 무순서입니다. </p>

      <blockquote>
	<dl>
	  <dt><a href="#options"><code>options</code></a> </dt>

	  <dd>커멘드행 옵션</dd>

	  <dt><code>sourcefiles</code></dt>

	  <dd>컴파일 되는 1 개(살) 이상의 원시 파일 (MyClass.java 등)</dd>

	  <dt><code>classes</code></dt>

	  <dd>주석의 처리 대상이 되는 1 개 이상의 클래스 (MyPackage.MyClass 등)</dd>

	  <dt><code><a href= 		"#commandlineargfile">@argfiles</a> </code></dt>

	  <dd>옵션과 원시 파일을 열거한 1 개(살) 이상의 파일. 이 파일 중(안)에서는,<code>-J</code> 옵션은 지정할 수 없습니다. </dd>
	</dl>
      </blockquote>
    </blockquote>

<h2><a name="description">설명</a> </h2>

    <blockquote>
<p><b>javac</b> 툴은, Java 프로그램 언어로 기술된 클래스와 인터페이스의 정의를 읽어내, 바이트 코드의 클래스 파일에 컴파일 합니다. 또, Java 원시 파일 및 클래스내의 주석의 처리도 실시합니다. </p>

<p>원시 코드의 파일명을 <b>javac</b> 에 건네주려면 , 다음의 2 개의 방법이 있습니다. </p>

      <ul>
	<li>원시 파일의 수가 적은 경우는, 파일명을 커멘드행으로 직접 지정합니다. </li>

	<li>원시 파일의 수가 많은 경우는, 파일명을 공백 또는 개행으로 단락지어, 1 개의 파일에 열거합니다. 다음에, 이 리스트 파일명의 선두에 <b>@</b> 를 붙여,<b>javac</b> 의 커멘드행으로 지정합니다. </li>
      </ul>

<p>원시 코드의 파일명은 <code>. java</code> 확장자(extension)를, 클래스의 파일명은 <code>. class</code> 확장자(extension)를 가지고 있지 않으면 안됩니다. 또, 원시 파일과 클래스 파일의 어느쪽이나, 해당하는 클래스에 대응하는 루트명을 가지고 있지 않으면 안됩니다. 예를 들어,<code>MyClass</code> 라는 이름의 클래스는,<code>MyClass.java</code> 라는 이름의 원시 파일에 기술합니다. 이 원시 파일은,<code>MyClass.class</code> 라는 이름의 바이트 코드 클래스 파일에 컴파일 됩니다. </p>

<p>내부 클래스가 정의되고 있으면(자), 추가의 클래스 파일이 생성됩니다. 이러한 클래스 파일의 이름은,<code>MyClass$MyInnerClass.class</code> 와 같이, 외부 클래스명과 내부 클래스명을 조합한 것이 됩니다. </p>

<p>원시 파일은, 패키지 트리를 반영한 디렉토리 트리에 배치할 필요가 있습니다. 예를 들어, 모든 원시 파일을 <b>/workspace</b> 에 두고 있는 경우,<code>com.mysoft.mypack.MyClass</code> 의 원시 코드는 <b>/workspace/com/mysoft/mypack/MyClass.java</b> 에 있을 필요가 있습니다. </p>

<p>디폴트에서는, 컴파일러는, 각 클래스 파일을 대응하는 원시 파일과 같은 디렉토리에 둡니다. 다른 출력처 디렉토리를 지정하려면 ,<b>-d</b> 를 사용합니다 (이후에의<a href= 	  "#options">옵션</a>을 참조). </p>
    </blockquote>

<h2><a name="options">옵션</a> </h2>

    <blockquote>
<p>컴파일러에는, 현재의 개발 환경에서 지원되고 있어 장래의 릴리스에서도 지원되는 표준 옵션세트가 있습니다. 이외의 비표준 옵션은, 현재의 가상 머신 및 컴파일러의 구현에 고유의 옵션으로, 장래로 변경될 가능성이 있습니다. 비표준 옵션은,<b>-X</b> 로 시작됩니다. </p>
    </blockquote>

<h3><a name="standard">표준 옵션</a> </h3>

    <blockquote>
      <dl>
	<dt><b>-A</b><i>key[=value]</i></dt>
	<dd>
	  주석 프로세서에게 건네지는 옵션. 이것들은, javac 에 의해 직접 해석되지 않고, 개개의 프로세서에 의해 사용됩니다.
<i>key</i> 에는, 1 개(살) 또는 복수의 식별자를 「.」(으)로 단락지은 것을 지정해 주세요. 	</dd>

	<dt><b>-cp</b> <i>path</i> 또는 <b>-classpath</b> <i>path</i></dt>

	<dd>
	  사용자의 클래스 파일 및 (경우에 따라서는) 주석 프로세서나 원시 파일의 검색 장소를 지정합니다. 이 클래스 패스는 <b>CLASSPATH</b> 환경 변수의 사용자 클래스 패스를 오버라이드(override) 합니다. <b>CLASSPATH</b>,<b>-cp</b>,<b>-classpath</b> 의 모두 지정되어 있지 않은 경우, 사용자 클래스 패스는, 현재의 디렉토리가 됩니다. 자세한 것은,<a href="../index.html#classpath">「클래스 패스의 설정」</a>을 참조해 주세요.

	  <p><b>-sourcepath</b> 옵션이 지정되어 있지 않은 경우는, 원시 파일도 사용자 클래스 패스로부터 검색됩니다. </p>
	  
	  <p><b>-processorpath</b> 옵션이 지정되어 있지 않은 경우는, 주석 프로세서도 사용자 클래스 패스로부터 검색됩니다. </p>

	  <!-- ********** 11.15 classpath addition  -->
	  
	  <p>편의상,<code>*</code> 의 베이스명을 포함한 클래스 패스 요소는, 디렉토리내의 확장자(extension) <code>. jar</code> 또는 <code>. JAR</code> 를 가지는 모든 파일의 리스트를 지정하는 것과 같은 것으로 간주해집니다. <br /><br />예를 들어, 디렉토리 <code>foo</code> 에 <code>a.jar</code> 와 <code>b.JAR</code> 가 포함되어 있는 경우, 클래스 패스 요소 <code>foo/*</code> 는 <code>A.jar:b.JAR</code> 에 전개됩니다. 다만, JAR 파일의 차례는 지정되지 않습니다. 이 리스트에는, 은폐 파일도 포함해 지정된 디렉토리내의 모든 JAR 파일이 포함됩니다. <code>*</code> 만일 수 있는으로부터 완성되는 클래스 패스 엔트리는, 커런트 디렉토리내의 모든 JAR 파일의 리스트에 전개됩니다. <code>CLASSPATH</code> 환경 변수도, 정의시에는과 같이  전개됩니다. <b>주:</b> 커멘드행 환경의 구성에 따라서는,<code>javac -cp "*. jar" MyClass.java</code> 등과 같이, 와일드 카드 문자를 인용부호로 둘러싸지 않으면 안 되는 경우가 있습니다. </p>
	  
	  <!-- ************ end classpath ************* -->

	</dd>

	<dt><b>-Djava.ext.dirs=</b><i>directories</i></dt>

	<dd>인스톨형 확장 기능의 위치를 오버라이드(override) 합니다. </dd>

	<dt><b>-Djava.endorsed.dirs=</b><i>directories</i></dt>

	<dd>승인된 표준 패스의 위치를 오버라이드(override) 합니다. </dd>

	<dt><b>-d</b> <i>directory</i></dt>

	<dd>
	  클래스 파일의 출력처 디렉토리를 설정합니다.  출력처 디렉토리는 벌써 존재하고 있습니다. <b>javac</b> 는 디렉토리를 작성하지 않습니다. 클래스가 패키지의 일부인 경우,<b>javac</b> 는, 필요에 따라서 디렉토리를 작성해, 패키지명을 반영한 서브 디렉토리에 클래스 파일을 둡니다. 예를 들어,<b>-d /home/myclasses</b> 와 지정해, 클래스의 이름이 <code>com.mypackage.MyClass</code> 인 경우, 클래스 파일은 <code>/home/myclasses/com/mypackage/MyClass.class</code> 가 됩니다.

	  <p><b>-d</b> 가 지정되지 않았던 경우,<b>javac</b> 는 각 클래스 파일을, 그 생성원이 되는 원시 파일과 같은 디렉토리내에 포함합니다. </p>

	  <p><b>주:</b> <b>-d</b> 로 지정한 디렉토리는 사용자 클래스 패스에 자동적으로는 추가되지 않습니다. </p>
	</dd>

	<dt><b>-deprecation</b></dt>

	<dd>
	  추천 되지 않는 멤버나 클래스가, 사용 또는 오버라이드(override) 될 때마다 설명을 표시합니다. <b>-deprecation</b> 가 지정되어 있지 않은 경우,<b>javac</b> 는, 추천 되지 않는 멤버나 클래스를 사용 또는 오버라이드(override) 하고 있는 원시 파일의 요약을 표시합니다. <b>-deprecation</b> 는 <b>-Xlint:deprecation</b> 의 생략 표기입니다.
	</dd>

	<dt><b>-encoding</b> <i>encoding</i></dt>

	<dd>
	  원시 파일의 인코딩명 (<code>EUC-JP</code> 나 <code>UTF-8</code> 등)을 지정합니다. <b>-encoding</b> 가 지정되어 있지 않은 경우는, 플랫폼의 디폴트 컨버터가 사용됩니다.
	</dd>

	<dt><b>-g</b></dt>

	<dd>국소 변수를 포함한 모든 디버그 정보를 생성합니다. 디폴트에서는, 행 번호 및 원시 파일 정보만이 생성됩니다.
	</dd>

	<dt><b>-g:none</b></dt>

	<dd>디버그 정보를 생성하지 않습니다. </dd>

	<dt><b>-g:</b><i>{keyword list}</i></dt>

	<dd>
	  콤마로 단락지어진 키워드 리스트에 의해 지정된, 특정의 종류의 디버그 정보만을 생성합니다. 다음의 키워드가 유효합니다.

	  <dl>
	    <dt><b>source</b></dt>

	    <dd>원시 파일의 디버그 정보</dd>

	    <dt><b>lines</b></dt>

	    <dd>행 번호의 디버그 정보</dd>

	    <dt><b>vars</b></dt>

	    <dd>국소 변수의 디버그 정보</dd>
	  </dl>
	</dd>

	<dt><b>-help</b></dt>

	<dd>표준 옵션의 형식을 표시합니다. </dd>

	<dt><a name="implicit"><b>-implicit:</b></a> <i>{class, none}</i></dt>
	<dd>
	  암묵적으로 로드 된 원시 파일에 대한 클래스 파일의 생성을 제어합니다. 클래스 파일을 자동 생성하려면 ,<b>-implicit:class</b> 를 사용합니다. 클래스 파일의 생성을 억제하려면 ,<b>-implicit:none</b> 를 사용합니다.

	  이 옵션이 지정되지 않았던 경우의 디폴트 동작은, 클래스 파일의 자동 생성이 됩니다. 그 경우, 그러한 클래스 파일이 생성되었을 때에 주석 처리도 실행되면(자), 컴파일러로부터 경고가 발행됩니다.

	  이 옵션이 명시적으로 설정되었을 경우에는, 경고는 발행되지 않습니다.

	  <a href="#searching">「형태의 검색」</a>을 참조해 주세요.
	</dd>

	<dt><b>-nowarn</b></dt>

	<dd>
	  경고 메세지를 무효로 합니다. 이것은 <b>-Xlint:none</b> 와 같은 의미입니다.
	</dd>

	<dt><b>-proc:</b> <i>{none, only}</i></dt>
	<dd>
	  주석 처리, 컴파일, 그 양쪽 모두, 의 머지않아를 실행하는지를 제어합니다. <b>-proc:none</b> 는, 주석 처리없이 컴파일이 실행되는 것을 의미합니다. <b>-proc:only</b> 는, 주석 처리만이 실행되어 후속의 컴파일은 전혀 실행되지 않는 것을 의미합니다.
	</dd>
	
	<dt><b>-processor</b> <i>class1[, class2, class3...]</i></dt>
	<dd>
	  실행하는 주석 프로세서의 이름. 이것을 지정했을 경우, 디폴트의 검색 처리는 생략 됩니다.
	</dd>

	<dt><b>-processorpath</b> <i>path</i></dt>
	<dd>
	  주석 프로세서의 검색 장소를 지정합니다. 이 옵션을 사용하지 않았던 경우, 클래스 패스내에서 프로세서의 검색을 합니다.
	</dd>

	<dt><b>-s</b> <i>dir</i></dt>
	<dd>
	  생성된 원시 파일의 포함처가 되는 디렉토리를 지정합니다. 그 디렉토리는 벌써 존재하고 있을 필요가 있습니다. <b>javac</b> 는 작성하지 않습니다. 클래스가 패키지의 일부가 되어 있었을 경우, 컴파일러는 그 원시 파일을, 패키지명을 반영한 서브 디렉토리내에 포함합니다. 그 때, 필요에 따라서 디렉토리를 작성합니다. 예를 들어, 사용자가 <b>-s /home/mysrc</b> 와 지정해, 클래스의 이름이 <code>com.mypackage.MyClass</code> 이었을 경우, 그 원시 파일은 <code>/home/mysrc/com/mypackage/MyClass.java</code> 내에 포함됩니다.
	</dd>

	<dt><b>-source</b> <i>release</i></dt>

	<dd>
	  받아들이는 원시 코드의 버젼을 지정합니다. <i>release</i> 에는 다음의 값을 지정할 수 있습니다.
	  <dl>
	    <dt> <b>1.3</b> </dt>
	    <dd>
	      이 컴파일러에서는, JDK 1.3 이후에 도입된 assertion, 총칭, 또는 다른 언어 기능을 지원하지 않습니다.
	    </dd>
	    <dt><b>1.4</b> </dt>
	    <dd>
	      JDK 1.4 로 도입된, assertion를 포함한 코드를 받아들입니다.
	    </dd>
	    <dt> <b>1.5</b> </dt>
	    <dd>
	      JDK 5 로 도입된 총칭 및 다른 언어 기능을 포함한 코드를 받아들입니다.
	    </dd>
	    <dt><b>5</b></dt>
	    <dd>
	      1.5 로 동의입니다.
	    </dd>
	    <dt><b>1.6</b></dt>
	    <dd>
	      이것이 디폴트 값입니다. Java SE 6 에서는 언어에 대한 변경은 도입되지 않았습니다만, 원시 파일내의 인코딩 에러가, 이전과 같은 「경고」는 아니고, 「에러」로서 보고되게 되었습니다.
	    </dd>
	    <dt><b>6</b></dt>
	    <dd>
	      1.6 으로 동의입니다.
	    </dd>
	  </dl>
	  <p>
	  </p>
	</dd>

	<dt><a name="sourcepath"><b>-sourcepath</b></a>  <i>sourcepath</i></dt>

	<dd>
	  클래스 또는 인터페이스의 정의를 검색하는 원시 코드 패스를 지정합니다. 사용자 클래스 패스와 같게, 소스 패스의 복수의 엔트리는 구두점 (<b>:</b>)으로 단락짓습니다.  소스 패스의 엔트리에는, 디렉토리, JAR 어카이브(archive), 또는 ZIP 어카이브(archive)를 지정할 수 있습니다. 패키지를 사용하고 있는 경우는, 디렉토리 또는 어카이브(archive)내의 로컬 경로명이 패키지명을 반영하고 있지 않으면 안됩니다.

	  <p><b>주:</b> &nbsp;클래스 패스로부터 클래스 뿐만이 아니라 그 소스도 발견되었을 경우, 그 클래스는 자동재컴파일의 대상이 되는 일이 있습니다. <a href="#searching">「형태의 검색」</a>을 참조해 주세요. </p>
	</dd>

	<dt><b>-verbose</b></dt>

	<dd>상세한 출력을 표시합니다. 로드 되는 클래스 및 컴파일 되는 원시 파일마다의 정보가 출력됩니다. </dd>

	<dt><a name="X"><b>-X</b></a> </dt>

	<dd>비표준 옵션에 관한 정보를 표시해 종료합니다. </dd>
      </dl>
    </blockquote>

<h3><a name="crosscomp-options">크로스 컴파일 옵션</a> </h3>

    <blockquote>
<p>디폴트에서는, 클래스의 컴파일은,<b>javac</b> 가 첨부되고 있는 플랫폼의 bootstrap 클래스 및 확장 기능 클래스에 대해서 행해집니다. 다만,<b>javac</b> 는, 다른 Java 플랫폼에 구현된 bootstrap 클래스 및 확장 기능 클래스에 대해서 컴파일을 실시하는 「크로스 컴파일」도 지원하고 있습니다. 크로스 컴파일을 실시하는 경우는,<b>-bootclasspath</b> 및 <b>-extdirs</b> 를 사용하는 것이 중요합니다. 이후에의<a href= 	  "#crosscomp-example">「크로스 컴파일의 예」</a>를 참조해 주세요. </p>

      <dl>
	<dt><b>-target</b> <i>version</i></dt>

	<dd>지정된 버젼의 VM 를 타겟으로 한 클래스 파일을 생성합니다. 이 클래스 파일은, 지정된 타겟 이후의 버젼에서는 동작합니다만, 그것보다 전의 버젼의 VM 에서는 동작하지 않습니다. 유효한 타겟은,<b>1.1</b>,<b>1.2</b>,<b>1.3</b>,<b>1.4</b>,<b>1.5</b> (<b>5</b> 도 가능), 및 <b>1.6</b> (<b>6</b> 도 가능)입니다.  
	  <p>
	    <b>-target</b> 의 디폴트는, 다음과 같이 <b>-source</b> 의 값에 의해 정해집니다.  
	  </p>
	  <ul>
	    <li>
	      -source 가<b>지정되지 않았던</b>경우, -target 의 값은 <b>1.6</b> 이 됩니다.
	    </li>
	    <li>
	      -source 가<b>1.2</b> 의 경우, -target 의 값은 <b>1.4</b> 가 됩니다.
	    </li>
	    <li>
	      -source 가<b>1.3</b> 의 경우, -target 의 값은 <b>1.4</b> 가 됩니다.
	    </li>
	    <li>
	      -source 가<b>그 이외의 값의 경우는 모두</b>, \-target 의 값은 <b>-source</b> 의 값이 됩니다.
	    </li>
	  </ul>
	  <p>
	  </p>
	</dd>

	<dt><b>-bootclasspath</b> <i>bootclasspath</i></dt>

	<dd>지정된 일련의 부트 클래스에 대해서 크로스 컴파일을 실시합니다. 사용자 클래스 패스와 같게, 부트 클래스 패스의 복수의 엔트리는 구두점 (<b>:</b>)으로 단락짓습니다. 부트 클래스 패스의 엔트리에는, 디렉토리, JAR 어카이브(archive), 또는 ZIP 어카이브(archive)를 지정할 수 있습니다. </dd>

	<dt><b>-extdirs</b> <i>directories</i></dt>

	<dd>지정된 확장 기능 디렉토리에 대해서 크로스 컴파일을 실시합니다. <i>directories</i> 에는, 구두점으로 단락지은 디렉토리의 리스트를 지정합니다. 지정한 디렉토리내의 각 JAR 어카이브(archive)로부터, 클래스 파일이 검색됩니다. </dd>
      </dl>
    </blockquote>

<h3><a name="nonstandard">비표준 옵션</a> </h3>

    <blockquote>
      <dl>
	<dt><b>-Xbootclasspath/p:</b><i>path</i></dt>

	<dd>bootstrap 클래스 패스전에 추가합니다. </dd>

	<dt><b>-Xbootclasspath/a:</b><i>path</i></dt>

	<dd>bootstrap 클래스 패스의 뒤로 추가합니다. </dd>

	<dt><b>-Xbootclasspath/:</b><i>path</i></dt>

	<dd>bootstrap 클래스 파일의 위치를 오버라이드(override) 합니다. </dd>

	<dt><b>-Xlint</b></dt>

	<dd>추천 되는 모든 경고를 유효하게 합니다. 이 릴리스에서는, 이용 가능한 모든 경고가 추천 되고 있습니다. </dd>

	<dt><b>-Xlint:none</b></dt>

	<dd>Java 언어 스펙에서는 지정되어 있지 않은 모든 경고를 무효로 합니다. </dd>

	<dt><b>-Xlint:-</b><i>name</i></dt>

	<dd>경고 <i>name</i> 를 무효로 합니다. 다만,<i>name</i> 는,<b>-Xlint:</b><i>name</i> 에 사용할 수 있는 경고명의 어느 쪽인가에 됩니다.  이 경고명은 다음과 같습니다. </dd>

	<dt><b>-Xlint:unchecked</b></dt>

	<dd>Java 언어 스펙으로 지정되고 있는 미검사 변환 경고의 상세를 나타냅니다. </dd>

	<dt><b>-Xlint:path</b></dt>

	<dd>존재하지 않는 패스 (classpath, sourcepath 등) 디렉토리에 도착해 경고합니다. </dd>

	<dt><b>-Xlint:serial</b></dt>

	<dd><code>serialVersionUID</code> 정의가 직렬화 가능 클래스에 없는 것을 경고합니다. </dd>

	<dt><b>-Xlint:finally</b></dt>

	<dd>정상적으로 완료할 수 없는 <code>finally</code> 절에 대해 경고합니다. </dd>

	<dt><b>-Xlint:fallthrough</b></dt>

	<dd>
	  fall-through 케이스의 <tt>switch</tt> 블록을 체크해, 검출된 것에 대해서 경고 메세지를 표시합니다. Fall-through 케이스는,<tt>switch</tt> 블록내의 마지막 케이스를 제외한 케이스입니다. 이 코드에는 <tt>break</tt> 문은 포함되지 않습니다. 코드의 실행을 그 케이스로부터 다음의 케이스에 이동합니다. 예를 들어, 이 <tt>switch</tt> 블록내의 <tt>case 1</tt> 라벨에 계속되는 코드는,<tt>break</tt> 문으로 끝나 있지 않습니다.

	  <blockquote>
	    <pre>
switch (x) {
case 1:
       System.out.println("1");
       //  No  break;  statement here.
case 2:
       System.out.println("2");
}
	    </pre>
	  </blockquote>이 코드의 컴파일시에 <tt>-Xlint:fallthrough</tt> 플래그가 사용되고 있었을 경우, 컴파일러는 해당 케이스의 행 번호와 함께, fall-through 케이스의 가능성이 있는 것을 나타내는 경고를 발행합니다.
	</dd>

	<dt><b>-Xmaxerrors</b> <i>number</i></dt>

	<dd>인쇄하는 에러의 최대수를 설정합니다. </dd>

	<dt><b>-Xmaxwarns</b> <i>number</i></dt>

	<dd>인쇄하는 경고의 최대수를 설정합니다. </dd>

	<dt><b>-Xstdout</b> <i>filename</i></dt>

	<dd>컴파일러의 메세지를, 지정된 파일에 보냅니다. 디폴트에서는, 컴파일러의 메세지는 <code>System.err</code> 에 보내집니다.
	</dd>

	<dt><a name="Xprefer"><b>-Xprefer:</b></a> <i>{newer, source}</i> </dt>
	<dd>
	  어느 형태에 대해서 원시 파일과 클래스 파일의 양쪽 모두가 발견되었을 경우, 그 어느 쪽의 파일을 읽어내야할 것인가를 지정합니다 (<a href="#searching">「형태의 검색」</a>을 참조). <i>-Xprefer:newer</i> 를 사용했을 경우, 어느 형태에 대한 원시 파일과 클래스 파일의 새로운 것이 읽어내집니다 (디폴트). <i>-Xprefer:source</i>옵션을 사용했을 경우, 원시 파일이 읽어내집니다. <code>SOURCE</code> 의 보존 정책를 사용해 선언된 주석에 임의의 주석 프로세서를 액세스 할 수 있도록(듯이) 하고 싶은 경우는,<i>-Xprefer:source</i>를 사용해 주세요.
	</dd>

	<dt><b>-Xprint</b> </dt>
	<dd>
	  지정된 형태의 텍스트 표현을 디버그 목적으로 출력합니다. 주석 처리, 컴파일의 어느쪽이나 실행하지 않습니다. 출력 형식은 변경될 가능성이 있습니다.
	</dd>

	<dt><b>-XprintProcessorInfo</b> </dt>
	<dd>
	  어느 특정의 프로세서가 처리를 의뢰받고 있는 주석에 관한 정보를 출력합니다.
	</dd>

	<dt><b>-XprintRounds</b> </dt>
	<dd>
	  첫회 및 후속의 주석 처리 라운드에 관한 정보를 출력합니다.
	</dd>

      </dl>
    </blockquote>

<h3><a name="J">-J 옵션</a> </h3>

    <blockquote>
      <dl>
	<dt><b>-J</b><i>option</i></dt>

	<dd>
	  <b>javac</b> 가 호출하는 <b>java</b> 기동 툴에,<i>option</i> 를 건네줍니다. 예를 들어,<b>-J-Xms48m</b> 와 지정하면(자), 스타트 업 메모리는 48M 바이트로 설정됩니다. 이 옵션은 <b>-X</b> 로 시작되어 있지 않습니다만,<b>javac</b> 의 「표준 옵션」이 아닙니다. <b>-J</b> 를 사용해, Java 로 기술된 어플리케이션을 실행하는 배후의 VM 에 옵션 건네주는 것은, 잘 행해지고 있습니다.

	  <p><b>주:</b> &nbsp; <b>CLASSPATH</b>,<b>-classpath</b>,<b>-bootclasspath</b>, 및 <b>-extdirs</b> 는,<b>javac</b> 를 실행하기 위해서 사용하는 클래스를 지정하는 것이 아닙니다. 이러한 방법으로 컴파일러의 구현을 조작하는 것은, 일반적으로은 무의미하고, 항상 위험을 수반합니다. 이러한 방법을 사용할 필요가 있는 경우는,<b>-J</b> 옵션을 사용해, 필요한 옵션을 배후의 <b>java</b> 기동 툴에 건네주세요.
	  </p></dd>
      </dl>
    </blockquote>

<h2><a name="commandlineargfile">커멘드행 인수 파일</a> </h2>

    <blockquote>
<p><code>javac</code> 의 커멘드행을 짧게 하거나 간결하게 하거나 하기 위해서,<code>javac</code> 커멘드에 대한 인수 (<code>-J</code> 옵션을 제외하다)를 포함한 1 개(살) 이상의 파일을 지정할 수가 있습니다. 이 방법을 사용하면(자), 어느  operating system상에서도, 임의의 길이의 javac 커멘드를 작성할 수 있습니다. </p>

<p>인수 파일에는, javac 의 옵션과 원시 파일명을 자유롭게 조합해 기술할 수 있습니다. 파일내의 각 인수는, 스페이스 또는 개행으로 단락짓습니다. 파일명에 공백이 포함되어 있는 경우는, 그 파일명 전체를 이중 인용부호로 둘러쌉니다. </p>

<p>인수 파일내의 파일명은, 현재의 디렉토리로부터 본 상대 패스가 됩니다. 인수 파일의 위치로부터 본 상대 패스가 아닙니다. 인수 파일내의 파일명 리스트에서는, 와일드 카드 (*)는 사용할 수 없습니다. 예를 들어,<code>*. java</code> 와는 지정할 수 없습니다. 인수 파일내의 인수로 <tt>@</tt> 문자를 사용해, 복수의 파일을 재귀적으로 해석하는 것은 지원되고 있지 않습니다. 또,<code>-J</code> 옵션도 지원되고 있지 않습니다. 이 옵션은 기동 툴에게 건네집니다만, 기동 툴에서는 인수 파일을 지원하고 있지 않기 때문입니다. </p>

<p>javac 를 실행할 경우에, 각 인수 파일의 패스와 파일명의 선두에 <tt>@</tt> 문자를 붙여 건네줍니다. javac 는,<tt>@</tt> 문자로 시작되는 인수를 찾아내면(자), 그 파일의 내용을 전개해 인수 리스트에 삽입합니다. </p>

<h3>인수 파일을 1 개 지정하는 예</h3>
<p><code>argfile</code> 라는 이름의 인수 파일에 모든 javac 인수를 포함하는 경우는, 다음과 같이 지정합니다. </p>
      <pre>
  % <b>javac @argfile</b>
      </pre>
<p>이 인수 파일에는, 다음의 예로 나타나고 있는 2 개의 파일의 내용을 양쪽 모두 들어갈 수 있을 수가 있습니다. </p>

<h3>인수 파일을 2 개 지정하는 예</h3>
<p>예를 들어, javac 옵션용으로 1 파일, 원시 파일명용으로 1 파일과 같이, 2 개의 인수 파일을 작성할 수도 있습니다. 덧붙여 이후에의 리스트에서는, 행의 계속 문자를 사용하고 있습니다. </p>

<p>이하의 내용을 포함한 <code>options</code> 라는 이름의 파일을 작성합니다. </p>
      <pre>
     -d classes
     -g
     -sourcepath /java/pubs/ws/1. 3/src/share/classes
      </pre>

<p>이하의 내용을 포함한 <code>classes</code> 라는 이름의 파일을 작성합니다. </p>
      <pre>
     MyClass1.java
     MyClass2.java
     MyClass3.java
      </pre>
<p>다음의 커멘드를 사용해 <b>javac</b> 를 실행합니다. </p>
      <pre>
  % <b>javac @options @classes</b>
      </pre>

<h3>패스 첨부의 인수 파일의 예</h3>
<p>인수 파일에는, 패스를 지정할 수 있습니다. 다만, 그 파일내로 지정된 파일명은, 현재의 작업 디렉토리로부터 본 상대 패스가 됩니다. 즉, 아래의 예의 경우는,<code>path1</code> 나 <code>path2</code> 로부터 본 상대 패스가 아닙니다. </p>
      <pre>
  % <b>javac @path1/options @path2/classes</b>
      </pre>
    </blockquote>


<h2><a name="processing">주석 처리</a> </h2>

    <blockquote>

<p><b>javac</b> 가 주석 처리를 직접 지원하고 있기 (위해)때문에, 독립한 주석 처리 툴인 <b>apt</b> 를 사용할 필요가 없어졌습니다. </p>

<p>주석 처리의 API 는,<code>javax.annotation.processing</code> 및 <code>javax.lang.model</code> 패키지와 그 서브 패키지내에 정의되고 있습니다. </p>

<h3>주석 처리의 개요</h3>

<p><b>-proc:none</b> 옵션에 의해 주석 처리가 무효화되지 않는 한, 컴파일러는 사용 가능한 모든 주석 프로세서를 검색합니다. 검색 패스는 <b>-processorpath</b> 옵션을 사용해 지정할 수 있습니다. 검색 패스를 지정하지 않았던 경우는, 사용자 클래스 패스가 사용됩니다. 프로세서의 검색은, 검색 패스상의 <code>META_INF/services/javax.annotation.processing.Processor</code> 라는 이름의 서비스 프로바이더 구성 파일에 근거해 행해집니다. 이러한 파일에는, 사용하는 모든 주석 프로세서의 이름을, 1 행에 1 개씩 포함해 주세요. 또, 다른 방법으로서<b>-processor</b> 옵션을 사용해 프로세서를 명시적으로 지정할 수도 있습니다. </p>
      
<p>컴파일러는, 커멘드행의 원시 파일이나 클래스를 주사 하는 것으로, 어떠한 주석이 존재하고 있는지를 다 확인하면(자) , 프로세서에 대해서 문의를 실시해, 그러한 프로세서가 어느 주석을 처리할 수 있는지를 확인합니다. 일치하는 것이 발견되었을 경우, 그 프로세서가 불려 갑니다. 각 프로세서는, 자신이 처리하는 주석을 「요구」할 수 있습니다.  그 경우, 그러한 주석에 대한 다른 프로세서를 찾아내는 시도 하행 깨지지 않습니다. 모든 주석이 요구되어 버리면(자), 컴파일러는 그 이상 프로세서의 검색을 실시하지 않습니다. </p>
      
<p>몇개의 프로세서에 의해 새로운 원시 파일이 생성되면(자), 주석 처리의 2 번째의 라운드가 개시됩니다. 새롭게 생성된 모든 원시 파일이 주사 되어 전회와 같게 주석이 처리됩니다. 이전의 라운드로 불려 간 프로세서는 모두, 후속의 어느 라운드에서도 불려 갑니다. 이것이, 새로운 원시 파일이 생성되지 않게 될 때까지 계속됩니다. </p>
      
<p>어느 라운드로 새로운 원시 파일이 생성되지 않았던 경우, 주석 프로세서가 앞으로 1 회만 불려 가 필요한 처리를 실행할 기회가 주어집니다. 마지막으로,<b>-proc:only</b> 옵션이 사용되지 않는 한, 컴파일러는, 원의 원시 파일과 생성된 모든 원시 파일을 컴파일 합니다. </p>
      
<h3>암묵적으로 로드 된 원시 파일</h3>
      
<p>컴파일러는, 일련의 원시 파일을 컴파일 할 때에, 다른 원시 파일을 암묵적으로 로드하지 않으면 안 되는 경우가 있습니다 (<a href="#searching">「형태의 검색」</a>을 참조). 그러한 파일은, 현시점에서는 주석 처리의 대상이 되지 않습니다. 디폴트에서는, 주석 처리가 실행되어 한편 암묵적으로 로드 된 원시 파일이 1 개에서도 컴파일 되었을 경우에 컴파일러는 경고를 발행합니다. 이 경고를 억제하는 방법에 대해서는,<a href="#implicit">-implicit</a>  옵션을 참조해 주세요.
    </p></blockquote>

<h2><a name="searching">형태의 검색</a> </h2>

    <blockquote>
<p>원시 파일을 컴파일 하는 경우, 커멘드행으로 지정한 원시 파일에 형태의 정의가 발견되지 않을 때, 컴파일러는 일반적으로, 그 형태에 관한 정보를 필요로 합니다. 컴파일러는, 원시 파일로 사용되고 있는 클래스 또는 인터페이스, 확장되고 있는 클래스 또는 인터페이스, 혹은 구현되고 있는 클래스 또는 인터페이스 모두에 임해서, 형태의 정보를 필요로 합니다. 이것에는, 원시 파일로 명시적으로는 언급되어 있지 않아도, 상속을 통해서 정보를 제공하는 클래스와 인터페이스도 포함됩니다.
      </p>

<p>예를 들어,<b>java.applet.Applet</b>를 서브 클래스로 했을 경우,<b>애플릿의</b>조상의 클래스(<b>java.awt.Panel</b>,<b>java.awt.Container</b>,<b>java.awt.Component</b>,<b>java.lang.Object</b>)를 사용하고 있게 됩니다. </p>

<p>컴파일러는, 형태의 정보가 필요하게 되면(자), 그 형태를 정의하고 있는 원시 파일 또는 클래스 파일을 찾습니다. 우선, bootstrap 클래스와 확장 기능 클래스를 검색해, 계속되어 사용자 클래스 패스 (디폴트에서는 커런트 디렉토리)를 검색합니다. 사용자 클래스 패스는,<b>CLASSPATH</b> 환경 변수를 설정해 정의하는지, 또는 <b>-classpath</b> 커멘드행 옵션을 사용해 설정합니다. 자세한 것은,<a href="../index.html#classpath">「클래스 패스의 설정」</a>을 참조해 주세요. </p>

<p><a href="#sourcepath">-sourcepath</a>  옵션이 지정되고 있는 경우, 컴파일러는, 지정된 패스로부터 원시 파일을 검색합니다.  그 이외의 경우는, 사용자 클래스 패스로부터 클래스 파일과 원시 파일의 양쪽 모두를 검색합니다. </p>

<p><b> -bootclasspath</b> 옵션과 <b>-extdirs</b> 옵션을 사용하면(자), 다른 bootstrap 클래스나 확장 기능 클래스를 지정할 수 있습니다. 이후에의<a href="#crosscomp-options">「크로스 컴파일 옵션」</a>을 참조해 주세요. </p>

<p>형태의 검색에 성공했을 때에 얻을 수 있는 결과는, 클래스 파일, 원시 파일, 또는 그 양쪽 모두인 경우가 있습니다. 양쪽 모두가 발견되었을 경우, 그 어느 쪽을 사용해야할 것인가를 <a href="#Xprefer">-Xprefer</a>  옵션으로 컴파일러에 지시할 수 있습니다. <b>newer</b> 가 지정되었을 경우, 컴파일러는 2 개의 파일의 새로운 (분)편을 사용합니다. <b>source</b> 가 지정되었을 경우, 컴파일러는 원시 파일을 사용합니다. 디폴트는 <b>newer</b> 입니다. </p>

<p>형태의 검색 자체에 의해, 또는 <b>-Xprefer</b> 가 설정된 결과적으로 필요한 형태의 원시 파일이 발견되었을 경우, 컴파일러는 그 원시 파일을 읽어내, 필요한 정보를 가져옵니다. 게다가 컴파일러는 디폴트로, 그 원시 파일의 컴파일도 실시합니다. <a href="#implicit">-implicit</a>  옵션을 사용하면 그 동작을 지정할 수 있습니다. <b>none</b> 를 지정했을 경우, 그 원시 파일의 클래스 파일은 생성되지 않습니다. <b>class</b> 를 지정했을 경우, 그 원시 파일의 클래스 파일이 생성됩니다. </p>

<p>컴파일러는, 주석 처리의 완료 후에, 어느 형태 정보의 필요성을 인식하지 않는 경우가 있습니다. 그 형태 정보가 있는 원시 파일내에 발견되어, 한편 <b>-implicit</b> 옵션이 지정되어 있지 않은 경우는, 그 파일이 주석 처리의 대상이 되지 않고 컴파일 되는 것을, 컴파일러가 사용자에게 경고합니다. 이 경고를 무효로 하려면 , (그 파일이 주석 처리의 대상이 되도록(듯이)) 그 파일을 커멘드행으로 지정하든가, 혹은 그러한 원시 파일에 대해서 클래스 파일을 생성해야할 것인가 제발을 <b>-implicit</b> 옵션을 사용해 지정합니다. </p>

    </blockquote>


<h2><a name="proginterface">프로그라마틱인타페스</a> </h2>

    <blockquote>
<p><b>javac</b> 는,<code>javax.tools</code> 패키지내의 클래스와 인터페이스에 의해 정의되는 새로운 Java Compiler API 를 지원합니다. </p>

<h3>례</h3>
<p>커멘드행으로부터 지정된 인수를 사용해 컴파일을 실행하려면 , 다음과 같은 코드를 사용합니다. </p>
      <pre>
JavaCompiler javac = ToolProvider.getSystemJavaCompiler();
int rc = javac.run(null, null, null, args);
      </pre>
<p>이 경우, 표준 출력 스트림에 모든 진단 메세지가 써내져 커멘드행으로부터 불려 간 <b>javac</b> 가 돌려주는 것과 같은 종료 코드가 돌려주어집니다. </p>

<p><code>javax.tools.JavaCompiler</code> 인터페이스상외의 메소드를 사용하면, 진단 메세지의 처리나 파일의 읽기원/기입처의 제어등을 실시할 수 있습니다.
      </p>
    </blockquote>

<h3>구식의 인터페이스</h3>

    <blockquote>
<p><b>주:</b> &nbsp;이 API 는, 하위 호환성을 확보하기 위해(때문에)인 만큼 남아 있습니다. 새로운 코드에서는, 반드시 전술의 Java Compiler API 를 사용해 주세요. </p>

<p><code>com.sun.tools.javac.Main</code> 클래스에는, 프로그램내로부터 컴파일러를 호출하기 위한 static 메소드가 2 개 준비되어 있습니다. 그것들을 다음에 나타냅니다. </p>
      <pre>
public static int compile(String[] args);
public static int compile(String[] args, PrintWriter out);
      </pre>

<p><code>args</code> 파라미터는, javac 프로그램에 일반적으로 건네받는 임의의 커멘드행 인수를 나타내고 있습니다. 그 개요에 대해서는, 전출의<a href="#synopsis">「형식」</a>절을 참조해 주세요. </p>

<p><code>out</code> 파라미터는, 컴파일러의 진단 메세지의 출력처를 나타냅니다. </p>

<p>반환값은,<b>javac</b> 의 종료치와 같습니다. </p>

<p>이름이 <code>com.sun.tools.javac</code> 으로 시작되는 패키지 (비공식에는 <code>com.sun.tools.javac</code> 의 서브 패키지로서 알려진다)에 포함되는<b>그 외의</b>클래스나 메소드는, 모두 완전하게 내부용이며, 언제라도 변경될 가능성이 있습니다. </p>
    </blockquote>

<h2><a name="examples">례</a> </h2>

<h3><a name="simpleexamples">간단한 프로그램의 컴파일</a> </h3>

    <blockquote>
<p><code>Hello.java</code> 라고 하는 원시 파일로,<b>greetings.Hello</b> 라는 이름의 클래스를 정의하고 있다고 합니다. <code>greetings</code> 디렉토리는, 원시 파일과 클래스 파일의 양쪽 모두가 있는 패키지 디렉토리에서, 현재의 디렉토리의 바로 아래에 있습니다. 이 때문에, 이 예에서는, 디폴트의 사용자 클래스 패스를 사용할 수 있습니다. 또,<b>-d</b> 를 사용해 다른 출력처 디렉토리를 지정할 필요도 없습니다. </p>

      <blockquote>
	<pre>
% <b>ls</b>
greetings/
% <b>ls greetings</b>
Hello.java
% <b>cat greetings/Hello.java</b>
package greetings;

public class Hello {
    public static void main(String[] args) {
        for (int i=0; i &lt; args.length; i++) {
            System.out.println("Hello " + args[i]);
        }
    }
}
% <b>javac greetings/Hello.java</b>
% <b>ls greetings</b>
Hello.class   Hello.java
% <b>java greetings.Hello World Universe Everyone</b>
Hello World
Hello Universe
Hello Everyone
	</pre>
      </blockquote>
    </blockquote>

<h3><a name="multiple-example">복수의 원시 파일의 컴파일</a> </h3>

    <blockquote>
<p>다음의 예에서는, 패키지 <code>greetings</code> 내의 모든 원시 파일을 컴파일 합니다. </p>

      <blockquote>
	<pre>
% <b>ls</b>
greetings/
% <b>ls greetings</b>
Aloha.java         GutenTag.java      Hello.java         Hi.java
% <b>javac greetings/*.java</b>
% <b>ls greetings</b>
Aloha.class         GutenTag.class      Hello.class         Hi.class
Aloha.java          GutenTag.java       Hello.java          Hi.java

	</pre>
      </blockquote>
    </blockquote>

<h3><a name="userclasspath">사용자 클래스 패스의 지정</a> </h3>

    <blockquote>
<p>위의 예의 원시 파일중 1 개(살)을 변경해, 변경 후의 파일을 재컴파일 한다고 합니다. </p>

      <blockquote>
	<pre>
% <b>pwd</b>
/examples
% <b>javac greetings/Hi.java</b>
	</pre>
      </blockquote>
<p><code>greetings.Hi</code> 는,<code>greetings</code> 패키지내외의 클래스를 참조하고 있기 (위해)때문에, 컴파일러는 이러한 클래스를 찾을 필요가 있습니다. 위의 예에서는, 디폴트의 사용자 클래스 패스가, 패키지 디렉토리를 포함한 디렉토리와 같기 때문에, 컴파일은 정상적으로 실행됩니다. 다만, 현재 어느 디렉토리에 있을까에 관계없이, 이 파일을 재컴파일 하는 경우는, 사용자 클래스 패스에 <code>/examples</code> 를 추가할 필요가 있습니다. 사용자 클래스 패스에 엔트리를 추가하려면 ,<b>CLASSPATH</b> 를 설정하는 방법도 있습니다만, 여기에서는 <b>-classpath</b> 옵션을 사용하기로 하겠습니다. </p>

      <blockquote>
	<pre>
% <b>javac -classpath /examples /examples/greetings/Hi.java</b>
	</pre>
      </blockquote>
<p>재차 <code>greetings.Hi</code> 를 변경해 배너 유틸리티를 사용하도록(듯이) 했을 경우는, 이 배너 유틸리티도 사용자 클래스 패스를 통해서 액세스 할 수 있게 되어 있을 필요가 있습니다. </p>

      <blockquote>
	<pre>
% <b>javac -classpath /examples:/lib/Banners.jar \
	    /examples/greetings/Hi.java</b>
	</pre>
      </blockquote>

<p><code>greetings</code> 내의 클래스를 실행하려면 ,<code>greetings</code> 와<code>greetings</code> 가 사용하는 클래스의 양쪽 모두에 액세스 할 수 있을 필요가 있습니다. </p>

      <blockquote>
	<pre>
% <b>java -classpath /examples:/lib/Banners.jar greetings.Hi</b>
	</pre>
      </blockquote>
    </blockquote>

<h3><a name="separating">원시 파일과 클래스 파일의 분리</a> </h3>

    <blockquote>
<p>특히 대규모 프로젝트의 경우는, 원시 파일과 클래스 파일을 다른 디렉토리에 두면(자) 편리한 일이 있습니다. 클래스 파일의 출력처를 따로 지정하려면 ,<b>-d</b> 를 사용합니다. 원시 파일은 사용자 클래스 패스에는 없기 때문에,<b>-sourcepath</b> 를 사용해, 컴파일러가 원시 파일을 찾아낼 수가 있도록(듯이) 합니다. </p>

      <blockquote>
	<pre>
% <b>ls</b>
classes/  lib/      src/
% <b>ls src</b>
farewells/
% <b>ls src/farewells</b>
Base.java      GoodBye.java
% <b>ls lib</b>
Banners.jar
% <b>ls classes</b>
% <b>javac -sourcepath src -classpath classes:lib/Banners.jar \
	    src/farewells/GoodBye.java -d classes</b>
% <b>ls classes</b>
farewells/
% <b>ls classes/farewells</b>
Base.class      GoodBye.class

	</pre>
      </blockquote>
<p><b>주:</b> &nbsp;커멘드행에서는 <code>src/farewells/Base.java</code> 를 지정하고 있었습니다만, 이 파일도 컴파일러에 의해 컴파일 되고 있습니다. 자동 컴파일을 감시하려면 ,<b>-verbose</b> 옵션을 사용합니다. </p>
    </blockquote>

<h3><a name="crosscomp-example">크로스 컴파일의 예</a> </h3>

    <blockquote>
<p>여기에서는,<b>javac</b> 를 사용해, 1.5 VM 상에서 실행하는 코드를 컴파일 합니다. </p>

      <blockquote>
	<pre>
% <b>javac -target 1.5 -bootclasspath jdk1. 5.0/lib/rt.jar \
	    -extdirs "" OldCode.java</b>
	</pre>
      </blockquote>

<p><b>-target 1.5</b> 옵션에 의해, 1.5 VM 와 호환성이 있는 클래스 파일이 생성됩니다. 디폴트에서는,<b>javac</b> 는 JDK 6 용으로 컴파일 합니다. </p>

<p>Java 플랫폼 JDK 의 <b>javac</b> 는, 디폴트에서는, Java 2 SDK 의 bootstrap 클래스에 대해서 컴파일을 실시하므로, Java 2 SDK 는 아니고 JDK 1.5 의 bootstrap 클래스에 대해서 컴파일을 실시하도록(듯이) 지정할 필요가 있습니다. 이것은,<b>-bootclasspath</b> 및 <b>-extdirs</b> 를 사용해 지정합니다. 이 지정을 실시하지 않으면 1.5 VM 에는 존재하지 않는 Java 2 플랫폼 API 에 대응한 컴파일을 하기 (위해)때문에, 프로그램의 실행시에 장해가 발생하는 일이 있습니다. </p>
    </blockquote>

<h2><a name="seealso">관련 항목</a> </h2>

    <blockquote>
      <ul>
	<li><a href="../../guides/javac/index.html">「The javac Guide」</a> </li>

	<li>「<a href="java.html">java</a>  - Java 어플리케이션 기동 툴」</li>

	<li>「<a href="jdb.html">jdb</a>  - Java 디버거」</li>

	<li>「<a href="javah.html">javah</a>  - C 헤더와 Stub 파일 제네레이터」</li>

	<li>「<a href="javap.html">javap</a>  - 클래스 파일 disassembler」</li>

	<li>「<a href="javadoc.html">javadoc</a>  - Java API 문서 제네레이터」</li>

	<li>「<a href="jar.html">jar</a>  - JAR 어카이브(archive) 툴」</li>

	<li><a href="../../guides/extensions/index.html">「Java 확장 기능 시스템」</a> </li>
      </ul>
    </blockquote>
    <hr/>

      <table border="0" width="100%" summary="layout">
	<tr valign="top">
	  <td>
	    <p><a href= 		"../../../legal/SMICopyright.html">Copyright</a>  &copy; 2006 <a href="http://www.sun.com">Sun Microsystems, Inc. </a> All Rights Reserved. </p>
	  </td>

	  <td align="right"><img src="../../../images/sunlogo64x30.gif" 	      alt="Sun" width="64" height="30" /><br /> <i> Java Software </i></td>
	</tr>
      </table>
  </body>
</html>
