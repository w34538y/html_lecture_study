<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">

<title>keytool - 열쇠와 증명서의 관리툴 - xrath.com 에서 번역됨</title>
<!-- base href="http://java.sun.com/j2se/1.6.0/docs/tooldocs/solaris/keytool.html" -->

<!-- **************** sandbox for notes *********************  From SEAN's email 7/26/06 paste this into the tiger doc:  Only keytool.html#cacerts (both Windows and Solaris) needs to be updated.  The following certificates should be added to that list (you can also cut-and-paste this out of the Mustang keytool.html#cacert section if it is easier):                <li><b>Alias</b>: verisignclass1g2ca<br />               <b>Owner DN</b>: OU=VeriSign Trust Network,<br />               OU="(c) 1998 VeriSign, Inc.  - For authorized use only",<br />               OU=Class 1 Public Primary Certification Authority - G2,<br />               O="VeriSign, Inc. ", C=US</li>                <li><b>Alias</b>: verisignclass1g3ca<br />               <b>Owner DN</b>: CN=VeriSign Class 1 Public Primary Certification Authority - G3,               OU="(c) 1999 VeriSign, Inc.  - For authorized use only",<br />               OU=VeriSign Trust Network,<br />               O="VeriSign, Inc. ", C=US</li>                <li><b>Alias</b>: verisignclass2g2ca<br />               <b>Owner DN</b>: OU=VeriSign Trust Network,<br />               OU="(c) 1998 VeriSign, Inc.  - For authorized use only",<br />               OU=Class 2 Public Primary Certification Authority - G2,<br />               O="VeriSign, Inc. ", C=US</li>                <li><b>Alias</b>: verisignclass2g3ca<br />               <b>Owner DN</b>: CN=VeriSign Class 2 Public Primary Certification Authority - G3,<br />               OU="(c) 1999 VeriSign, Inc.  - For authorized use only",<br />               OU=VeriSign Trust Network,<br />               O="VeriSign, Inc. ", C=US</li>                <li><b>Alias</b>: verisignclass3g2ca<br />               <b>Owner DN</b>: OU=VeriSign Trust Network,<br />               OU="(c) 1998 VeriSign, Inc.  - For authorized use only",<br />               OU=Class 3 Public Primary Certification Authority - G2,<br />               O="VeriSign, Inc. ", C=US</li>                <li><b>Alias</b>: verisignclass3g3ca<br />               <b>Owner DN</b>: CN=VeriSign Class 3 Public Primary Certification Authority - G3,<br />               OU="(c) 1999 VeriSign, Inc.  - For authorized use only",<br />               OU=VeriSign Trust Network,<br />               O="VeriSign, Inc. ", C=US</li>                <li><b>Alias</b>: entrustclientca<br />               <b>Owner DN</b>: CN=Entrust.net Client Certification Authority,<br  />               OU=(c) 1999 Entrust.net Limited,<br />               OU=www.entrust.net/Client_CA_Info/CPS incorp.  by ref.  limits liab.  ,<br />               O=Entrust.net, C=US</li>                <li><b>Alias</b>: entrustglobalclientca<br />               <b>Owner DN</b>: CN=Entrust.net Client Certification Authority,<br  />               OU=(c) 2000 Entrust.net Limited,<br />               OU=www.entrust.net/GCCA_CPS incorp.  by ref.  (limits liab. ),<br />               O=Entrust.net</li>                <li><b>Alias</b>: entrust2048ca<br />               <b>Owner DN</b>: CN=Entrust.net Certification Authority (2048),<br  />               OU=(c) 1999 Entrust.net Limited,<br />               OU=www.entrust.net/CPS_2048 incorp.  by ref.  (limits liab. ),<br />               O=Entrust.net</li>                <li><b>Alias</b>: entrustsslca<br />               <b>Owner DN</b>: CN=Entrust.net Secure Server Certification Author ity,<br />               OU=(c) 1999 Entrust.net Limited,<br />               OU=www.entrust.net/CPS incorp.  by ref.  (limits liab. ),<br />               O=Entrust.net, C=US</li>                <li><b>Alias</b>: entrustgsslca<br />               <b>Owner DN</b>: CN=Entrust.net Secure Server Certification Author ity,<br />               OU=(c) 2000 Entrust.net Limited,<br />               OU=www.entrust.net/SSL_CPS incorp.  by ref.  (limits liab. ),<br />               O=Entrust.net</li>                <li><b>Alias</b>: godaddyclass2ca<br />               <b>Owner DN</b>: OU=Go Daddy Class 2 Certification Authority,<br / >               O="The Go Daddy Group, Inc. ", C=US</li>                <li><b>Alias</b>: starfieldclass2ca<br />               <b>Owner DN</b>: OU=Starfield Class 2 Certification Authority,<br />               O="Starfield Technologies, Inc. ", C=US</li>                <li><b>Alias</b>: valicertclass2ca<br />               <b>Owner DN</b>: EMAILADDRESS=info@valicert.com,<br />               CN=http://www.valicert.com/,<br />               OU=ValiCert Class 2 Policy Validation Authority,<br />               O="ValiCert, Inc. ", L=ValiCert Validation Network</li>                <li><b>Alias</b>: geotrustglobalca<br />               <b>Owner DN</b>: CN=GeoTrust Global CA,<br />               O=GeoTrust Inc., C=US</li>                <li><b>Alias</b>: equifaxsecureca<br />               <b>Owner DN</b>: OU=Equifax Secure Certificate Authority,<br />               O=Equifax, C=US</li>                <li><b>Alias</b>: equifaxsecureebusinessca1<br />               <b>Owner DN</b>: CN=Equifax Secure eBusiness CA-1,<br />               O=Equifax Secure Inc., C=US</li>                <li><b>Alias</b>: equifaxsecureebusinessca2<br />               <b>Owner DN</b>: OU=Equifax Secure eBusiness CA-2,<br />               O=Equifax Secure, C=US</li>                <li><b>Alias</b>: equifaxsecureglobalebusinessca1<br />               <b>Owner DN</b>: CN=Equifax Secure Global eBusiness CA-1,<br />               O=Equifax Secure Inc., C=US</li>                <li><b>Alias</b>: soneraclass1ca<br />               <b>Owner DN</b>: CN=Sonera Class1 CA, O=Sonera, C=FI</li>                <li><b>Alias</b>: soneraclass2ca<br />               <b>Owner DN</b>: CN=Sonera Class2 CA, O=Sonera, C=FI</li>                <li><b>Alias</b>: comodoaaaca<br />               <b>Owner DN</b>: CN=AAA Certificate Services,<br/>               O=Comodo CA Limited, L=Salford, ST=Greater Manchester, C=GB</li>                <li><b>Alias</b>: addtrustclass1ca<br />               <b>Owner DN</b>: CN=AddTrust Class 1 CA Root,<br/>               OU=AddTrust TTP Network, O=AddTrust AB, C=SE</li>                <li><b>Alias</b>: addtrustexternalca<br />               <b>Owner DN</b>: CN=AddTrust External CA Root,<br/>               OU=AddTrust External TTP Network, O=AddTrust AB, C=SE</li>                <li><b>Alias</b>: addtrustqualifiedca<br />               <b>Owner DN</b>: CN=AddTrust Qualified CA Root,<br/>               OU=AddTrust TTP Network, O=AddTrust AB, C=SE</li>                <li><b>Alias</b>: utnuserfirsthardwareca<br />               <b>Owner DN</b>: CN=UTN-USERFirst-Hardware,<br/>               OU=http://www.usertrust.com, O=The USERTRUST Network,<br/>               L=Salt Lake City, ST=UT, C=US</li>                <li><b>Alias</b>: utnuserfirstclientauthemailca<br />               <b>Owner DN</b>: CN=UTN-USERFirst-Client Authentication and Email, <br/>               OU=http://www.usertrust.com, O=The USERTRUST Network,<br/>               L=Salt Lake City, ST=UT, C=US</li>                <li><b>Alias</b>: utndatacorpsgcca<br />               <b>Owner DN</b>: CN=UTN - DATACorp SGC,<br/>               OU=http://www.usertrust.com, O=The USERTRUST Network,<br/>               L=Salt Lake City, ST=UT, C=US</li>                <li><b>Alias</b>: utnuserfirstobjectca<br />               <b>Owner DN</b>: CN=UTN-USERFirst-Object,<br/>               OU=http://www.usertrust.com, O=The USERTRUST Network,<br/>               L=Salt Lake City, ST=UT, C=US</li>        ********************************************************** -->

</head>

<body bgcolor="#ffffff">

<h1>keytool - 열쇠와 증명서의 관리툴</h1>
<blockquote>
암호화열쇠, X. 509 증명서 체인, 및 신뢰할 수 있는 증명서를 포함한 키스토어 (데이타베이스)를 관리합니다.
</blockquote>

<h2>형식</h2>
<blockquote>
<pre><strong>keytool</strong> [ <a href="#Commands">commands</a>  ]
</pre>
<p>
Java SE 6 으로 keytool 의 커멘드 인터페이스가 변경되었습니다. 상세한 것에 대하여는<a href="#Changes">「변경점」</a>시에를 참조해 주세요. 이전에 정의된 커멘드도 계속해 지원되고 있습니다.
</p>
</blockquote>

<h2>설명</h2>

<blockquote>

<b>keytool</b> 는, 열쇠와 증명서를 관리하기 위한 유틸리티입니다. keytool 를 사용하면(자), 자신의 공개키와 비공개키의 페어, 및 관련하는 증명서를 관리해, 디지털 서명을 사용한 자기 인증 (다른 사용자 또는 서비스에 대해서 자기 자신을 인증하는 것)이나, 데이터의 무결성과 증명서에 관한 서비스를 이용할 수가 있습니다. <b>keytool</b> 에서는, 통신 상대의 공개키를 (증명서의 형태로) 캐쉬할 수도 있습니다.

<p>「증명서」란, 어느 엔티티 (인물, 회사등)로부터의 디지털 서명 첨부의 문서입니다. 증명서에는, 다른 있는 엔티티의 공개키 ( 및 그 외의 정보)가 특별한 값을 가지고 있는 것이 쓰여져 있습니다(<a href="#Certificates">「증명서」</a>를 참조). 데이터에 디지털 서명이 붙어 있는 경우는, 디지털 서명을 검증하는 것으로, 데이터의 무결성 및 데이터가 진짜인 것을 체크할 수 있습니다. 데이터의 「무결성」이란, 데이터가 변경되거나 개편되거나 하고 있지 않는 것을 의미합니다.  또, 데이터가 「진짜이다」란, 그 데이터가, 데이터를 작성해 서명했다고 칭하는 인물로부터 실제로 건네받은 데이터인 것을 의미합니다.

</p><p>또,<b>keytool</b> 를 사용하면, DES 등의 대칭 암호화/복호화로 사용되는 비밀열쇠를 관리할 수도 있습니다.

</p><p><b>keytool</b> 는, 열쇠와 증명서를<a href="#KeyStore"><i>「키스토어」</i></a> 에 포함합니다.

<!-- </p><p>The <a href="http://java.sun.com/j2se/1.6.0/docs/tooldocs/solaris/jarsigner.html"><b>jarsigner</b></a>  tool uses information from a keystore to generate or verify digital signatures for Java ARchive (JAR) files.  (A JAR file packages class files, images, sounds, and/or other digital data in a single file).  <b>jarsigner</b> verifies the digital signature of a JAR file, using the certificate that comes with it (it is included in the signature block file of the JAR file), and then checks whether or not the public key of that certificate is "trusted", i.e., is contained in the specified keystore.   </p><p>The Java Runtime consults keystores to verify signatures on a signed JAR file when the JAR is first loaded.   Administrators can <a href="../../guides/security/PolicyFiles.html"> grant permissions</a>  to different JAR files based on their respective signers.  These permissions are then checked by the access control framework when code from the JAR file executes.  -->

</p></blockquote>


<h2><a name="CommandNotes">커멘드와 옵션에 관한 주</a> </h2>

<blockquote>

<p><a href="#Commands">이하</a>에서는, 커멘드와 그 옵션에 대해 설명합니다. 주:

</p><ul>

<li>어느 커멘드명 및 옵션명에도 선두에 마이너스 기호 (-)가 붙는다<p>

</p></li><li>각 커멘드의 옵션은 임의의 순서로 지정할 수 있다<p>

</p></li><li>이탤릭체로 되어 있지 않은 모든 항목, 또는 안괄호나 꺽쇄묶음으로 둘러싸져 모든 항목은, 그대로로 지정할 필요가 있다<p>

</p></li><li>옵션을 둘러싸는 중 괄호는, 일반적으로, 그 옵션을 커멘드행으로 지정하지 않았던 경우에,<a href="#OptionDefaults">디폴트 값</a>가 사용되는 것을 의미한다. 안괄호는,<code>-v</code>,<code>-rfc</code>, 및 <code>-J</code> 옵션을 둘러싸는데도 사용되지만, 이러한 옵션은 커멘드행으로 지정되었을 경우에게만 의미를 가진다 (즉, 이러한 옵션에는, 옵션 자체를 지정하지 않는 것 이외에 「디폴트 값」는 존재하지 않는다)<p>

</p></li><li>옵션을 둘러싸는 꺽쇄묶음은, 그 옵션을 커멘드행으로 지정하지 않았던 경우에, 값의 입력이 요구되는 것을 의미한다. 다만,<code>-keypass</code> 옵션을 커멘드행으로 지정하지 않았던 경우는,<b>keytool</b> 가 키스토어의 패스워드로부터 비공개/비밀열쇠의 복원을 시도한다. 사용자는, 이 시도가 실패했을 경우에 비공개/비밀열쇠의 입력이 요구된다<p>

</p></li><li>이탤릭체의 항목의 실제의 값 (옵션의 값)은, 사용자가 지정할 필요가 있는 예를 들어,<code>-printcert</code> 커멘드의 형식은 다음과 같다

<pre>  keytool -printcert {-file <i>cert_file</i>} {-v}
</pre>

<p><code>-printcert</code> 커멘드를 지정할 때는,<i>cert_file</i> 대신에 실제의 파일명을 지정한다.  다음에 예를 나타낸다

</p><pre>  keytool -printcert -file VScert.cer
</pre><p>

</p></li><li>옵션의 값에 공백 (스페이스)이 포함되어 있는 경우는, 값을 인용부호로 둘러쌀 필요가 있다<p>

</p></li><li><code>-help</code> 커멘드는 디폴트의 커멘드이다. 예를 들어, 다음과 같이 커멘드행을 지정했다고 한다

<pre>  keytool
</pre>

이것은, 다음과 같이 지정하는 것과 같다

<pre>  keytool -help
</pre>

</li></ul>


<h3><a name="OptionDefaults">옵션의 디폴트 값</a> </h3>

<blockquote>

옵션의 디폴트 값는, 다음과 같습니다.

<pre>-alias "mykey"

-keyalg
    "DSA" (<a href="#genkeypairCmd">-genkeypair</a>  를 사용하고 있는 경우)
    "DES" (<a href="#genseckeyCmd">-genseckey</a>  를 사용하고 있는 경우)

-keysize
    1024 (<a href="#genkeypairCmd">-genkeypair</a>  를 사용하고 있는 경우)
    56 (<a href="#genseckeyCmd">-genseckey</a>  를 사용하고 있어 -keyalg 가 "DES" 의 경우)
    168 (<a href="#genseckeyCmd">-genseckey</a>  를 사용하고 있어 -keyalg 가 "DESede" 의 경우)

-validity 90

-keystore <i>사용자의 홈 디렉토리의 <code>. keystore</code> 라고 하는 파일</i>

-storetype <i>시큐리티 프로퍼티 파일의 「keystore.type」프로퍼티의 값으로,
           <code>java.security.KeyStore</code> 의 정적인 <code>getDefaultType</code> 메소드로부터 반환된다</i>

-file <i>읽을 경우는 표준 입력, 기입의 경우는 표준 출력</i>

-protected false

</pre>

공개/비공개키 페어의 생성에 대해, 서명 알고리즘 (<i>-sigalg</i> 옵션)은, 기본으로 되는 비공개키의 알고리즘으로부터 파생합니다. 기본으로 되는 비공개키가 DSA 타입인 경우,<i>-sigalg</i> 옵션의 디폴트 값는 SHA1withDSA 가 되어, 기본으로 되는 비공개키가 RSA 타입인 경우는,<i>-sigalg</i> 옵션의 디폴트 값는 MD5withRSA 가 됩니다. 선택 가능한 <i>-keyalg</i> 및 <i>-sigalg</i> 의 완전한 일람에 대해서는,<a href="../../guides/security/crypto/CryptoSpec.html#AppA">「Java Cryptography Architecture API Specification & Reference」</a>를 참조해 주세요.

</blockquote>




<h3><a name="OptionsInAll">일반 옵션</a> </h3>

<blockquote>

<code>-v</code> 옵션은,<code>-help</code> 커멘드를 제외한 모든 커멘드로 사용할 수 있습니다. 이 옵션을 지정했을 경우, 커멘드는 「장황」모드로 실행되어 상세한 증명서 정보가 출력됩니다.

<p>또,<code>-J<i>javaoption</i></code> 옵션도, 임의의 커멘드로 사용할 수 있습니다. 이 옵션을 지정했을 경우, 지정된 <i>javaoption</i> 캐릭터 라인이 Java interpreter에 직접 건네받습니다. 이 옵션에는, 공백을 포함할 수 없습니다. 이 옵션은, 실행 환경 또는 메모리 사용을 조정하는 경우에 편리합니다. 지정할 수 있는 interpreter 옵션을 일람표시 하려면 , 커멘드행으로 <code>java -h</code> 또는 <code>java -X</code> 라고 입력해 주세요.

</p><p>다음의 옵션은, 키스토어에 대한 조작을 실시하는 모든 커멘드로 지정할 수 있습니다.

</p><dl><dt><code>-storetype <i>storetype</i></code>
</dt><dd>
이 수식자는, 인스턴스를 생성하는 키스토어의 타입을 지정합니다.

<p></p></dd><dt><code>-keystore <i>keystore</i></code>
</dt><dd>
키스토어의 장소를 지정합니다.

<p> 특정의 <b>keytool</b> 커멘드를 실행할 때에, JKS <a href="#KeyStoreImplementation">스토어 타입</a>이 사용되어 한편 키스토어파일이 아직 존재하고 있지 않았던 경우, 새로운 키스토어파일이 작성됩니다. 예를 들어,<code>keytool -genkeypair</code> 의 실행시에 <code>-keystore</code> 옵션이 지정되지 않았던 경우,<code>. keystore</code> 라는 이름의 데포르트키스토어파일이 사용자의 홈 디렉토리내에 아직 존재하고 있지 않으면, 거기에 작성됩니다. 같이<code>-keystore <i>ks_file</i></code> 라고 하는 옵션이 지정되어도 그 <i>ks_file</i> 가 존재하지 않았던 경우, 그 파일이 작성됩니다.

</p><p><code>-keystore</code> 옵션으로부터의 입력 스트림은,<code>KeyStore.load</code> 메소드에게 건네집니다. URL 로서 <code>NONE</code> 가 지정되고 있는 경우는, null 의 스트림이 <code>KeyStore.load</code> 메소드에게 건네집니다. <code>NONE</code> 는,<code>KeyStore</code> 가 파일 베이스는 아니고, 예를 들어, 하드웨어 토큰 디바이스에 놓여져 있는 경우로 지정합니다.

</p></dd><dt><code>-storepass <i>storepass</i></code>
</dt><dd>
키스토어의 무결성을 보호하기 위해서 사용하는 패스워드를 지정합니다.

<p><em>storepass</em> 는, 6 문자 이상이 아니면 안됩니다. 지정한 패스워드는, 키스토어의 내용에 액세스 하는 모든 커멘드로 사용됩니다. 이런 종류의 커멘드를 실행할 경우에, 커멘드행으로 <code>-storepass</code> 옵션을 지정하지 않았던 경우는, 패스워드의 입력이 요구됩니다.
</p><p>키스토어로부터 정보를 꺼내는 경우는, 패스워드를 생략 할 수 있습니다.  패스워드를 생략 하면(자), 꺼내는 정보의 무결성을 체크할 수 없기 때문에, 경고가 표시됩니다.
</p></dd><dt><code>-providerName <i>provider_name</i></code>
</dt><dd>
시큐리티 프로퍼티 파일내에 포함되는 암호화 서비스 프로바이더명을 특정하기 위해서 사용됩니다. <p></p>

<p></p></dd><dt><code>-providerClass <i>provider_class_name</i></code>
</dt><dd>암호화 서비스 프로바이더가 시큐리티 프로퍼티 파일로 지정되어 있지 않을 때는, 그 마스터 클래스 파일의 이름을 지정할 경우에 사용됩니다. <p>

</p></dd><dt><code>-providerArg <i>provider_arg</i></code>
</dt><dd>
<code>-providerClass</code> 와 조합해 사용합니다. <i>provider_class_name</i> 의 생성자 에 대한 생략 가능한 캐릭터 라인 입력 인수를 나타냅니다. <p></p>

<p></p></dd><dt><code>-protected</code>
</dt><dd>
<code>true</code> 또는 <code>false</code> 의 언젠가. 전용 PIN 리더등의 보호된 인증 패스를 개입시켜 패스워드를 지정할 필요가 있는 경우에는, 이 값에 <code>true</code> 를 지정해 주세요.
<p></p></dd></dl>

</blockquote>



</blockquote>

<h2><a name="Commands">커멘드</a> </h2>

<blockquote>

<h3>키스토어에의 데이터의 추가</h3>

<blockquote>

<dl>

<dt><code><b><font size="+1"><a name="genkeypairCmd">-genkeypair </a> </font></b> {-alias <i>alias</i>} {-keyalg <i>keyalg</i>} {-keysize <i>keysize</i>} {-sigalg <i>sigalg</i>} [-dname <i>dname</i>] [-keypass <i>keypass</i>] {-validity <i>valDays</i>} {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>열쇠의 페어 (공개키 및 관련하는 비공개키)를 생성합니다. 공개키는 X. 509 v3 자기 서명 증명서로 랩 됩니다. 증명서는, 단일의 요소를 가지는 증명서 체인으로서 포함됩니다. 이 증명서 체인과 비공개키는,<em>alias</em> 로 특정되는 새로운 키스토어엔트리에 포함됩니다.

</p><p><em>keyalg</em> 에는, 열쇠의 페어를 생성하는데 사용하는 알고리즘을 지정해,<em>keysize</em> 에는, 생성하는 각 열쇠의 사이즈를 지정합니다. <em> sigalg</em> 에는, 자기 서명 증명서에 서명을 붙일 때 사용하는 알고리즘을 지정합니다.  이 알고리즘은,<em>keyalg</em> 와 호환성이 있는 것 나오지 않으면 안됩니다.

</p><p><em>dname</em> 에는,<em>alias</em> 에 관련지어 자기 서명 증명서의 <code>issuer</code> 필드와 <code>subject</code> 필드로서 사용하는 <a href="#DName">X. 500 식별명</a>을 지정합니다. 커멘드행으로 식별명을 지정하지 않았던 경우는, 식별명의 입력이 요구됩니다.

</p><p><em>keypass</em> 에는, 생성되는 열쇠의 페어 가운데, 비공개키를 보호하는데 사용하는 패스워드를 지정합니다. 패스워드를 지정하지 않았던 경우는, 패스워드의 입력이 요구됩니다. 이 때, Return 키를 누르면(자), 키스토어의 패스워드와 같은 패스워드가 열쇠의 패스워드로 설정됩니다. <em> keypass</em> 는, 6 문자 이상이 아니면 안됩니다.

</p><p><em>valDays</em> 에는, 증명서의 유효 날짜를 지정합니다. </p>
<p>이 커멘드는, 이전의 릴리스에서는 <tt>-genkey</tt> 라는 이름이었습니다. 이 낡은 이름은, 이 릴리스에서도 계속해 지원되고 있어 향후의 릴리스에서도 지원될 예정입니다. 다만, 향후는 알기 쉽게, 새로운 이름 <tt>-genkeypair</tt> 를 사용하는 것을 추천합니다.  </p>
</dd>

<dt><code><b><font size="+1"><a name="genseckeyCmd">-genseckey </a> </font></b> {-alias <i>alias</i>} {-keyalg <i>keyalg</i>} {-keysize <i>keysize</i>} [-keypass <i>keypass</i>] {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt>
<dd>
<p>비밀열쇠를 생성해, 그것을 <em>alias</em> 로 특정되는 새로운 <code>KeyStore.SecretKeyEntry</code> 내에 포함합니다.
</p><p>
<em>keyalg</em> 는 비밀열쇠의 생성에 사용하는 알고리즘을,<em>keysize</em> 는 생성하는 열쇠의 사이즈를, 각각 지정합니다. <em>keypass</em> 는 비밀열쇠의 보호에 사용하는 패스워드입니다. 패스워드를 지정하지 않았던 경우는, 패스워드의 입력이 요구됩니다. 이 때, Return 키를 누르면(자), 키스토어의 패스워드와 같은 패스워드가 열쇠의 패스워드로 설정됩니다. <em> keypass</em> 는, 6 문자 이상이 아니면 안됩니다.
</p></dd>

<dt><code><b><font size="+1"><a name="importCertCmd">-importcert</a> </font></b> {-alias <i>alias</i>} {-file <i>cert_file</i>} [-keypass <i>keypass</i>] {-noprompt} {-trustcacerts} {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>파일 <i>cert_file</i> 로부터 증명서 또는 증명서 체인 (증명서 체인의 경우는, PKCS#7 형식의 응답으로 제공되는 것)을 읽어들여,<i>alias</i> 에 의해 특정되는 키스토어엔트리에 포함합니다. 파일이 지정되어 있지 않은 경우는, 표준 입력으로부터 증명서 또는 PKCS#7 응답을 읽어들입니다.

</p><p><b>keytool</b> 에서는, X. 509 v1, v2, v3 의 증명서, 및, PKCS#7 형식의 증명서로부터 구성되어 있는 PKCS#7 형식의 증명서 체인을 임포트 할 수 있습니다. 임포트 하는 데이터는, 바이너리 encode 방식, 또는 출력 가능 encode 방식 (Base64 encode라고도 불린다)의 어느 쪽인지로 제공할 필요가 있습니다.  출력 가능 encode 방식은,<a href="#EncodeCertificate">인터넷 RFC 1421 증명서 encode 규격</a>으로 정의되고 있습니다. 이 encode 방식의 경우, 증명서는 「-----BEGIN」로 시작되는 캐릭터 라인으로 개시되어 「-----END」로 시작되는 캐릭터 라인으로 종료하지 않으면 안됩니다.

</p><p>증명서의 임포트에는, 다음의 2 개의 목적이 있습니다.  </p><p>

</p><ol>

<li>신뢰할 수 있는 증명서의 리스트에 증명서를 추가한다<p>
</p></li><li>CA 에 증명서 서명 요구 (<a href="#certreqCmd">-certreq</a>  커멘드를 참조)를 송신한 결과적으로, CA 로부터 받은 증명 응답을 임포트 한다

</li></ol>

<p> 어느 쪽의 종류의 임포트를 실시할까는,<code>-alias</code> 옵션의 값에 의해 지정합니다.

</p><ol>

<p></p><li><b>별명이 키 엔트리를 포인트 하지 않는 경우</b>,<b>keytool</b> 는 사용자가 신뢰할 수 있는 증명서 엔트리를 추가하려고 하고 있는 것이라고 봅니다. 이 경우, 별명이 키스토어내에 벌써 존재하고 있어서는 안됩니다. 별명이 벌써 존재하고 있는 경우, 그 별명의 신뢰할 수 있는 증명서가 벌써 존재하게 되므로,<b>keytool</b> 는 에러를 출력해, 증명서의 임포트를 실시하지 않습니다.
<p>

</p></li><li><b>별명이 키 엔트리를 포인트 하지 않는 경우</b>,<b>keytool</b> 는 사용자가 신뢰할 수 있는 증명서 엔트리를 추가하려고 하고 있는 것이라고 봅니다.

</li></ol>

<h4>새로운 신뢰할 수 있는 증명서의 임포트</h4>

<blockquote>

<p><b>keytool</b> 는, 키스토어에 증명서를 추가하기 전에, 키스토어내에 벌써 존재하는 신뢰할 수 있는 증명서를 사용해, 임포트 하는 증명서로부터 (루트 CA 의) 자기 서명 증명서에 이를 때까지의 신뢰의 체인의 구축을 시도합니다.

</p><p><code>-trustcacerts</code> 옵션을 지정했을 경우, 추가의 증명서는 신뢰할 수 있는 즉 <a href="#cacerts">cacerts 라는 이름의 파일</a>에 포함되는 증명서의 체인이라고 보여집니다.

</p><p><b>keytool</b> 가, 임포트 하는 증명서로부터 자기 서명 증명서 (키스토어 또는 cacerts 파일에 포함되어 있는 자기 서명 증명서)에 이를 때까지의 신뢰의 패스의 구축에 실패했을 경우는, 임포트 하는 증명서의 정보를 표시해, 사용자에게 확인을 요구합니다.  이 경우는, 표시된 증명서의 지문과 다른 하등의 (신뢰할 수 있다) 정보원 (증명서의 소유자 본인등)으로부터 입수한 지문을 비교합니다. 「신뢰할 수 있는 증명서」로서 증명서를 임포트 할 때는, 증명서가 유효한 것을 신중하게 확인할 필요가 있습니다. 자세한 것은,<a href="#TrustedCertWarning">「신뢰할 수 있는 증명서의 임포트에 관한 주의 사항」</a>을 참조해 주세요. 임포트 조작은, 증명서를 확인하는 시점에서 중지할 수 있습니다. 다만,<code>-noprompt</code> 옵션이 지정되고 있는 경우, 사용자와의 대화는 행해지지 않습니다.

</p></blockquote>


<h4>증명 응답의 임포트</h4>

<blockquote>

<p>「증명 응답」을 임포트 할 때는, 키스토어내의 신뢰할 수 있는 증명서, 및 (<code>-trustcacerts</code> 옵션이 지정되고 있는 경우는) <a href="#cacerts">cacerts 키스토어파일</a>로 구성된 증명서를 사용해 증명 응답이 검사됩니다.

</p><p>증명 응답을 신뢰할 수 있을지 어떨지를 결정하는 방법은 다음과 같습니다.  </p><p>

</p><ul>

<li><b>증명 응답이 단일의 X. 509 증명서인 경우</b>,<b>keytool</b> 는, 증명 응답으로부터 (루트 CA 의) 자기 서명 증명서에 이를 때까지의 신뢰 체인의 확립을 시도합니다. 증명 응답과 증명 응답의 인증에 사용되는 증명서의 계층 구조는,<i>alias</i> 의 새로운 증명서 체인을 형성합니다. 신뢰 체인이 확립되지 않는 경우, 증명 응답은 임포트 되지 않습니다. 이 경우,<b>keytool</b> 는 증명서를 출력하지 않고, 사용자에게 검증을 요구하는 prompt를 표시합니다. 사용자가 증명 응답의 신뢰성을 판단하는 것은, 불가능하지 않아도 매우 곤란하기 때문에입니다.  <p>

</p></li><li><b>증명 응답이 PKCS#7 형식의 증명서 체인인 경우</b>,<b>keytool</b> 는, 우선 체인을 늘어놓고 바꾸어, 사용자의 증명서가 최초로, 루트 CA 의 자기 서명 증명서가 마지막에 오도록(듯이) 한 뒤, 증명 응답에 포함되는 루트 CA 의 증명서와 키스토어내 또는 (<code>-trustcacerts</code> 옵션이 지정되고 있는 경우는) cacerts 키스토어파일내의 신뢰할 수 있는 증명서를 모두 비교해, 일치하는 것이 있을지 어떨지를 조사합니다. 일치하는 것이 발견되지 않았던 경우는, 루트 CA 의 증명서의 정보를 표시해, 사용자에게 확인을 요구합니다.  이 경우는, 표시된 증명서의 지문과 다른 하등의 (신뢰할 수 있다) 정보원 (루트 CA 자신등)으로부터 입수한 지문을 비교합니다. 임포트 조작은, 증명서를 확인하는 시점에서 중지할 수 있습니다. 다만,<code>-noprompt</code> 옵션이 지정되고 있는 경우, 사용자와의 대화는 행해지지 않습니다.

</li></ul>

<p> 증명서 응답내의 공개키가 <i>alias</i> 아래에 벌써 포함되고 있는 사용자의 공개키에 일치했을 경우, 낡은 증명서 체인이 응답내의 새로운 증명서 체인으로 옮겨놓을 수 있습니다. 이전의 증명서 체인을 새로운 증명서 체인으로 옮겨놓을 수가 있는 것은, 유효한 <i>keypass</i>, 즉 해당하는 엔트리의 비공개키를 보호하기 위한 패스워드를 지정했을 경우만입니다. 패스워드를 지정하고 있지 않고, 비공개키의 패스워드가 키스토어의 패스워드와 다른 경우는, 비공개키의 패스워드의 입력이 요구됩니다.

</p></blockquote>
<p></p>
<p>이 커멘드는, 이전의 릴리스에서는 <tt>-import</tt> 라는 이름이었습니다. 이 낡은 이름은, 이 릴리스에서도 계속해 지원되고 있어 향후의 릴리스에서도 지원될 예정입니다. 다만, 향후는 알기 쉽게, 새로운 이름 <tt>-importcert</tt> 를 사용하는 것을 추천합니다.  </p>
</dd>

<!--dt><code><b><font size="+1"><a name="selfcertCmd">-selfcert </a> </font></b>   {-alias <i>alias</i>}   {-sigalg <i>sigalg</i>} {-dname <i>dname</i>}   {-validity <i>valDays</i>} [-keypass <i>keypass</i>]   {-storetype <i>storetype</i>}   {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]   {-providerName <i>provider_name</i>}   {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}   {-v} {-protected} {-J<i>javaoption</i>}</code> </dt><dd> <p>Generates an X. 509 v3 self-signed certificate, using keystore information including the private key and public key associated with <em>alias</em>.  If <i>dname</i> is supplied at the command line, it is used as the <a href="#DName">X. 500 Distinguished Name</a>  for both the <code>issuer</code> and <code>subject</code> of the certificate.  Otherwise, the X. 500 Distinguished Name associated with <em>alias</em> (at the bottom of its existing certificate chain) is used.   </p><p>The generated certificate is stored as a single-element certificate chain in the keystore entry identified by <em>alias</em>, where it replaces the existing certificate chain.   </p><p><em>sigalg</em> specifies the algorithm that should be used to sign the certificate.   </p><p>In order to access the private key, the appropriate password must be provided, since private keys are protected in the keystore with a password.  If <em>keypass</em> is not provided at the command line, and is different from the password used to protect the integrity of the keystore, the user is prompted for it.   </p><p><em>valDays</em> tells the number of days for which the certificate should be considered valid. </p><p>   </p></dd--> <!--dt><code><b><font size="+1"><a name="identitydbCmd">-identitydb </a> </font></b>   {-file <i>idb_file</i>}   {-storetype <i>storetype</i>}   {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]   {-providerName <i>provider_name</i>}   {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}   {-v} {-protected} {-J<i>javaoption</i>}</code> </dt><dd> <p>Reads the JDK 1.1.x-style identity database from the file <em>idb_file</em>, and adds its entries to the keystore.  If no file is given, the identity database is read from stdin.  If a keystore does not exist, it is created.   </p><p>Only identity database entries ("identities") that were marked as trusted will be imported in the keystore.  All other identities will be ignored.  For each trusted identity, a keystore entry will be created.  The identity's name is used as the "alias" for the keystore entry.   </p><p>The private keys from trusted identities will all be encrypted under the same password, <i>storepass</i>.  This is the same password that is used to protect the keystore's integrity.  Users can later assign individual passwords to those private keys by using the "-keypasswd" <b>keytool</b> command option.   </p><p>An identity in an identity database may hold more than one certificate, each certifying the same public key.  But a keystore key entry for a private key has that private key and a single "certificate chain" (initially just a single certificate), where the first certificate in the chain contains the public key corresponding to the private key.  When importing the information from an identity, only the first certificate of the identity is stored in the keystore.  This is because an identity's name in an identity database is used as the alias for its corresponding keystore entry, and alias names are unique within a keystore,   </p></dd-->
<dt><code><b><font size="+1"><a name="importKeyStoreCmd">-importkeystore </a> </font></b> -srckeystore <i>srckeystore</i> -destkeystore <i>destkeystore</i> {-srcstoretype <i>srcstoretype</i>} {-deststoretype <i>deststoretype</i>} [-srcstorepass <i>srcstorepass</i>] [-deststorepass <i>deststorepass</i>] {-srcprotected} {-destprotected} {-srcalias <i>srcalias</i> {-destalias <i>destalias</i>} [-srckeypass <i>srckeypass</i>] [-destkeypass <i>destkeypass</i>] } {-noprompt} {-srcProviderName <i>src_provider_name</i>} {-destProviderName <i>dest_provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt>
<dd>
<p>
소스키스토어로부터 타겟트키스토어에, 단일의 엔트리 또는 모든 엔트리를 임포트 합니다.
</p><p>
<em>srcalias</em> 옵션이 지정되었을 경우, 이 커멘드는, 그 별명으로 특정되는 단일의 엔트리를 타겟트키스토어에 임포트 합니다. <em>destalias</em> 경유로 타겟 별명이 지정되지 않았던 경우,<em>srcalias</em> 가 타겟 별명으로서 사용됩니다. 소스의 엔트리가 패스워드로 보호되고 있었을 경우,<em>srckeypass</em> 를 사용해 그 엔트리가 회복됩니다. <em>srckeypass</em> 가 지정되지 않았던 경우,<b>keytool</b> 는 <em>srcstorepass</em> 를 사용해 그 엔트리를 회복하려고 합니다. <em>srcstorepass</em> 가 지정되지 않았는지 올바르지 않았던 경우, 사용자는 패스워드의 입력이 요구됩니다. 타겟 엔트리는 <em>destkeypass</em> 에 의해 보호됩니다. <em>destkeypass</em> 가 지정되지 않았던 경우, 타겟 엔트리는 소스 엔트리의 패스워드에 의해 보호됩니다.
</p><p>
<em>srcalias</em> 옵션이 지정되지 않았던 경우, 소스키스토어내의 모든 엔트리가 타겟트키스토어내에 임포트 됩니다. 각 타겟 엔트리는 대응하는 소스 엔트리의 별명아래에 포함됩니다. 소스의 엔트리가 패스워드로 보호되고 있었을 경우,<em>srcstorepass</em> 를 사용해 그 엔트리가 회복됩니다. <em>srcstorepass</em> 가 지정되지 않았는지 올바르지 않았던 경우, 사용자는 패스워드의 입력이 요구됩니다. 소스키스토어내가 있는 엔트리 타입이 타겟트키스토어로 지원되어 있지 않은 경우나, 어느 엔트리를 타겟트키스토어에 포함할 때에 에러가 발생했을 경우, 사용자는 그 엔트리를 스킵 해 처리를 속행하든가, 혹은 처리를 중단할까의 선택이 요구됩니다. 타겟 엔트리는 소스 엔트리의 패스워드에 의해 보호됩니다.
</p><p>
타겟 별명이 타겟트키스토어내에 벌써 존재하고 있었을 경우, 사용자는, 그 엔트리를 덧쓰기하든가, 혹은 다른 별명아래에서 새로운 엔트리를 작성할까의 선택이 요구됩니다.
</p><p>
<code>-noprompt</code> 를 지정했을 경우, 사용자는 새로운 타겟 별명의 입력이 요구되지 않습니다. 기존의 엔트리는 그 타겟 별명으로 자동적으로 덧쓰기됩니다. 마지막으로, 임포트 할 수 없는 엔트리는 자동적으로 스킵 되어 경고가 출력됩니다.
</p>

<p></p>

      </dd>
    </dl>


</blockquote>



<h3>데이터의 export</h3>

<blockquote>

<dl><dt><code><b><font size="+1"><a name="certreqCmd">-certreq </a> </font></b>{-alias <i>alias</i>} {-sigalg <i>sigalg</i>} {-file <i>certreq_file</i>} [-keypass <i>keypass</i>] {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>PKCS#10 형식을 사용해 증명서 서명 요구 (CSR)를 생성합니다.

</p><p>CSR 는, 증명서 발행국 (CA)에 송신하는 것을 목적으로 한 것입니다. CA 는, 증명서 요구자를 (일반적으로은 오프 라인으로) 인증해, 증명서 또는 증명서 체인을 돌려 보냅니다.  이 증명서 또는 증명서 체인은, 키스토어내의 기존의 증명서 체인 (처음은 1 살의 자기 서명 증명서로부터 구성된다)에 옮겨놓아 사용합니다.

</p><p><em>alias</em> 에 관련지을 수 있었던 비공개키와 X. 500 식별명은, PKCS#10 증명서 요구를 작성하는데 사용됩니다. 비공개키는 키스토어내에서는 패스워드에 의해 보호되고 있으므로, 비공개키에 액세스 하려면 , 적절한 패스워드를 제공할 필요가 있습니다. 커멘드행으로 <em>keypass</em> 를 지정하고 있지 않고, 비공개키의 패스워드가 키스토어의 패스워드와 다른 경우는, 비공개키의 패스워드의 입력이 요구됩니다. </p>

<p><em>sigalg</em> 에는, CSR 에 서명을 붙일 때 사용하는 알고리즘을 지정합니다.

</p><p>CSR 는, 파일 <em>certreq_file</em> 에 포함됩니다. 파일이 지정되어 있지 않은 경우는, 표준 출력에 CSR 가 출력됩니다.

</p><p>CA 로부터의 응답을 임포트 하려면 ,<em>importcert</em> 커멘드를 사용합니다. </p><p>


</p></dd><dt><code><b><font size="+1"><a name="exportCertCmd">-exportcert</a> </font></b> {-alias <i>alias</i>} {-file <i>cert_file</i>} {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-rfc} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p><em>alias</em> 에 관련지을 수 있었던 증명서를 (키스토어로부터) 읽어들여, 파일 <em>cert_file</em> 에 포함합니다.

</p><p>파일이 지정되어 있지 않은 경우는, 표준 출력에 증명서가 출력됩니다.

</p><p>디폴트에서는, 바이너리 encode 방식의 증명서가 출력됩니다.  다만,<code>-rfc</code> 옵션을 지정했을 경우는, 출력 가능 encode 방식의 증명서가 출력됩니다.  출력 가능 encode 방식은,<a href="#EncodeCertificate">인터넷 RFC 1421 증명서 encode 규격</a>으로 정의되고 있습니다.

</p><p><i>alias</i> 가, 신뢰할 수 있는 증명서를 참조하고 있는 경우는, 해당하는 증명서가 출력됩니다. 그 이외의 경우,<i>alias</i> 는, 관련지을 수 있었던 증명서 체인을 가지는 열쇠 엔트리를 참조합니다. 이 경우는, 체인내의 최초의 증명서가 돌려주어집니다. 이 증명서는,<i>alias</i> 에 의해 나타내지는 엔티티의 공개키를 인증하는 증명서입니다. </p><p>

</p>
<p>이 커멘드는, 이전의 릴리스에서는 <tt>-export</tt> 라는 이름이었습니다. 이 낡은 이름은, 이 릴리스에서도 계속해 지원되고 있어 향후의 릴리스에서도 지원될 예정입니다. 다만, 향후는 알기 쉽게, 새로운 이름 <tt>-exportcert</tt> 를 사용하는 것을 추천합니다.  </p>
</dd></dl>

</blockquote>


<h3>데이터의 표시</h3>

<blockquote>

<dl><dt><code><b><font size="+1"><a name="listCmd">-list </a> </font></b> {-alias <i>alias</i>} {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v | -rfc} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p><i>alias</i> 로 특정되는 키스토어엔트리의 내용을 (표준 출력에) 출력합니다. 별명이 지정되어 있지 않은 경우는, 키스토어 전체의 내용이 표시됩니다.

</p><p>이 커멘드는, 디폴트에서는 증명서의 MD5 지문을 표시합니다. <code>-v</code> 옵션이 지정되고 있는 경우는, 소유자, 발행자, 시리얼 번호, 확장 기능등의 부가적인 정보와 함께, 인간이 읽을 수 있는 형식에서 증명서가 표시됩니다. <code>-rfc</code> 옵션이 지정되고 있는 경우는, 출력 가능 encode 방식에서 증명서의 내용이 표시됩니다. 출력 가능 encode 방식은,<a href="#EncodeCertificate">인터넷 RFC 1421 증명서 encode 규격</a>으로 정의되고 있습니다.

</p><p><code>-v</code> 옵션과 <code>-rfc</code> 옵션을 동시에 지정할 수 없습니다.
</p><p></p></dd>

<dt><code><b><font size="+1"><a name="printcertCmd">-printcert </a> </font><a name="printcertCmd"></a> </b> <a name="printcertCmd">  {-file <i>cert_file</i>} {-v} {-J<i>javaoption</i>}</a> </code>
</dt><dd>
<p>파일 <a name="printcertCmd"><em>cert_file</em> 로부터 증명서를 읽어들여, 인간이 읽을 수 있는 형식에서 증명서의 내용을 표시합니다. 파일이 지정되어 있지 않은 경우는, 표준 입력으로부터 증명서를 읽어들입니다.

</a> </p><p><a name="printcertCmd">증명서는, 바이너리 encode 방식 또는 출력 가능 encode 방식에서 표시할 수 있습니다. </a> 출력 가능 encode 방식은,<a href="#EncodeCertificate">인터넷 RFC 1421 증명서 encode 규격</a>으로 정의되고 있습니다.

</p><p>주:이 커멘드는 키스토어와는 관계없이 동작합니다. </p><p>


</p></dd>

</dl>

</blockquote>


<h3>키스토어의 관리</h3>

<blockquote>

<dl>
<!--dt><code><b><font size="+1"><a name="keycloneCmd">-keyclone </a> </font></b>   {-alias <i>alias</i>}   [-dest <i>dest_alias</i>]   [-keypass <i>keypass</i>] [-new <i>new_keypass</i>]   {-storetype <i>storetype</i>}   {-keystore <i>keystore</i>} [-storepass <i>storepass</i>]   {-providerName <i>provider_name</i>}   {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}}   {-v} {-protected} {-J<i>javaoption</i>}</code> </dt><dd> <p>Creates a new keystore entry, which has the same private key and certificate chain as the original entry if it's a private key entry, or has the same secret key if it's a secret key entry.   </p><p>The original entry is identified by <em>alias</em> (which defaults to "mykey" if not provided).  The new (destination) entry is identified by <em>dest_alias</em>.  If no destination alias is supplied at the command line, the user is prompted for it.   </p><p>If the private/secret key password is different from the keystore password, then the entry will only be cloned if a valid <i>keypass</i> is supplied.   This is the password used to protect the key associated with <i>alias</i>.  If no key password is supplied at the command line, and the key password is different from the keystore password, the user is prompted for it.   The key in the cloned entry may be protected with a different password, if desired.  If no <code>-new</code> option is supplied at the command line, the user is prompted for the new entry's password (and may choose to let it be the same as for the cloned entry's private/secret key).   </p></dd-->
<dt><code><b><font size="+1"><a name="storePasswdCmd">-storepasswd</a>  </font></b>[-new <i>new_storepass</i>] {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-J<i>javaoption</i>}</code>
</dt><dd>
<p>키스토어의 내용의 무결성을 보호하기 위해서 사용하는 패스워드를 변경합니다. <em>new_storepass</em> 에는, 새로운 패스워드를 지정합니다. <em> new_storepass</em> 는, 6 문자 이상이 아니면 안됩니다. </p>

<p>


</p></dd><dt><code><b><font size="+1"><a name="keyPasswdCmd">-keypasswd</a>  </font></b>{-alias <i>alias</i>} [-keypass <i>old_keypass</i>] [-new <i>new_keypass</i>] {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-J<i>javaoption</i>}</code>
</dt><dd>
<p><em>alias</em> 에 의해 특정되는 비공개/비밀열쇠를 보호하기 위한 패스워드를,<em>old_keypass</em> 로부터 <em>new_keypass</em> 로 변경합니다. <em>new_keypass</em> 는, 6 문자 이상이 아니면 안됩니다.

</p><p>커멘드행으로 <code>-keypass</code> 옵션을 지정하고 있지 않고, 열쇠의 패스워드가 키스토어의 패스워드와 다른 경우는, 열쇠의 패스워드의 입력이 요구됩니다.

</p><p>커멘드행으로 <code>-new</code> 옵션을 지정하지 않았던 경우는, 새로운 패스워드의 입력이 요구됩니다. </p><p>

</p><p>


</p></dd><dt><code><b><font size="+1"><a name="deleteCmd">-delete </a> </font></b> [-alias <i>alias</i>] {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt><dd>
<p><em>alias</em> 에 의해 특정되는 엔트리를 키스토어로부터 삭제합니다. 커멘드행으로 별명을 지정하지 않았던 경우는, 별명의 입력이 요구됩니다. </p><p>

</p></dd>
<dt><code><b><font size="+1"><a name="changeAliasCmd">-changealias</a>  </font></b> {-alias <i>alias</i>} [-destalias <i>destalias</i>] [-keypass <i>keypass</i>] {-storetype <i>storetype</i>} {-keystore <i>keystore</i>} [-storepass <i>storepass</i>] {-providerName <i>provider_name</i>} {-providerClass <i>provider_class_name</i> {-providerArg <i>provider_arg</i>}} {-v} {-protected} {-J<i>javaoption</i>}</code>
</dt>
<dd>
<p>
지정된 <em>alias</em> 로부터 새로운 별명 <em>destalias</em> 에, 기존의 키스토어엔트리를 이동합니다. 타겟 별명이 지정되지 않았던 경우, 이 커멘드는 그 입력을 요구합니다. 원의 엔트리가 엔트리 패스워드로 보호되고 있었을 경우, 「-keypass」옵션 경유로 그 패스워드를 지정할 수 있습니다. 열쇠 패스워드가 지정되지 않았던 경우,<i>storepass</i> (지정되었을 경우)가 우선 시도됩니다. 그 시도가 실패하면(자), 사용자는 패스워드의 입력이 요구됩니다.
</p></dd>
</dl>
</blockquote>


<h3>헬프의 표시</h3>

<blockquote>

<dl><dt><code><b><font size="+1"><a name="helpCmd">-help</a>  </font></b></code>
</dt><dd>
<p>기본적인 커멘드와 그 옵션의 일람을 표시합니다. </p><p>


</p></dd>

</dl>

</blockquote>


</blockquote>





<h2><a name="EXAMPLES">례</a> </h2>

<blockquote>

<p>여기에서는, 자신의 열쇠의 페어 및 신뢰할 수 있는 엔티티로부터의 증명서를 관리하기 위한 키스토어를 작성하는 경우를 예로서 가리킵니다.

</p>
<!--h3>Generating a Secret Key</h3>  <blockquote> <p>You can always generate a secret key in a keystore so that it can be used by a Java program later.  The command is very simple:  </p><pre>    keytool -genseckey -alias mysecret -keyalg DESede -keysize 112
      -keypass 426593 -keystore /working/mykeystore -storepass ab987c
</pre>  <p>This command create a DESede type secret key (with key size 112) in a keystore based on the file /working/mykeystore.  The storepass ab987c is needed to update the keystore.  The keypass 426593 is the protect password for the secret entry itself.  When the secret key is generated, it is stored as a KeyStore.SecretKeyEntry in the key store which you can always use KeyStore.getKey() to retrieve.   </p><p>in order to see what kind of secret key you can create, you can refer to <a href="../../guides/security/crypto/CryptoSpec.html#AppA"> http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA</a>  to see what keyalg you can provide.  Please take attention that although the above link is titled SunJCE Default keysizes, that does not garantee keytool will recognize it, you are still required to provide the keysize option yourself.  </p></blockquote>  </p-->

<h3>열쇠의 페어의 생성</h3>

<blockquote>

<p>우선, 키스토어를 작성해 열쇠의 페어를 생성할 필요가 있습니다. 다음에 나타내는 것은, 실행하는 커멘드의 예입니다.

</p><pre>    keytool -genkeypair -dname "cn=Mark Jones, ou=JavaSoft, o=Sun, c=US"
      -alias business -keypass kpi135 -keystore /working/mykeystore
      -storepass ab987c -validity 180
</pre>

<p>주:이 커멘드는 1 행에 입력하지 않으면 안됩니다. 예로 복수행에 입력하고 있는 것은 읽기 쉽게 하기 (위해)때문에입니다.

</p><p>이 예에서는, working 디렉토리에 mykeystore 라는 이름의 키스토어를 작성해 (키스토어는 아직 존재하고 있지 않으면 가정한다), 작성한 키스토어에 패스워드 ab987c 를 할당합니다. 생성하는 공개키와 비공개키의 페어에 대응하는 엔티티의 「식별명」은, 통칭이 「Mark Jones」, 조직 단위가 「JavaSoft」, 조직이 「Sun」, 2 문자의 나라 번호가 「US」입니다. 공개키와 비공개키의 사이즈는 어느쪽이나 1024 비트로, 열쇠의 작성에는 디폴트의 DSA 열쇠 생성 알고리즘을 사용합니다.

</p><p>이 커멘드는, 공개키와 식별명 정보를 포함한 자기 서명 증명서 (디폴트의 SHA1withDSA 서명 알고리즘을 사용)를 작성합니다. 증명서의 유효기간은 180 일입니다.  증명서는, 별명 「business」로 특정되는 키스토어엔트리내의 비공개키에 관련지을 수 있습니다. 비공개키에는 패스워드 「kpi135」를 할당할 수 있습니다.

</p><p>옵션의 디폴트 값를 사용하는 경우는, 위에 나타낸 커멘드를 큰폭으로 짧게 할 수가 있습니다. 실제로는, 옵션을 1 개나 지정하지 않고 커멘드를 실행하는 일도 가능합니다.  디폴트 값를 가지는 옵션에서는, 옵션을 지정하지 않으면 디폴트 값가 사용되어 필요한 값에 대해서는 입력이 요구됩니다. 예를 들어, 단지 다음과 같이 입력할 수도 있습니다.

</p><pre>    keytool -genkeypair
</pre>

이 경우는, mykey 라고 하는 별명으로 키스토어엔트리가 작성되어 새롭게 생성된 열쇠의 페어, 및 90 일간 유효한 증명서가 이 엔트리에 포함됩니다. 이 엔트리는, 홈 디렉토리내의 . keystore 라는 이름의 키스토어에 놓여집니다. 이 키스토어가 아직 존재하고 있지 않는 경우는, 작성됩니다. 식별명 정보, 키스토어의 패스워드, 및 비공개키의 패스워드에 대해서는, 입력이 요구됩니다.

<p>이하에서는, 옵션을 지정하지 말아줘 <code>-genkeypair</code> 커멘드를 실행한 것으로서 예를 나타냅니다. 정보의 입력이 요구되었을 경우는, 최초로 가리킨 <code>-genkeypair</code> 커멘드의 값을 입력한 것으로 합니다 (예를 들어, 비공개키의 패스워드에는 kpi135 와 지정).

</p></blockquote>


<h3>증명서 발행국에 대한 서명 첨부 증명서의 요구</h3>

<blockquote>

<p>현시점에서 수중에 있는 것은, 1 통의 자기 서명 증명서 뿐입니다. 증명서에 증명서 발행국 (CA)의 서명이 붙어 있으면, 다른 사용자로부터 증명서를 신뢰할 수 있을 가능성도 높아집니다. CA 의 서명을 가져오려면 , 우선, 증명서 서명 요구 (CSR)를 생성합니다.  예를 들어, 다음과 같이 합니다.

</p><pre>    keytool -certreq -file MarkJ.csr
</pre>

CSR (디폴트 별명 「mykey」에 의해 특정되는 엔티티의 CSR)가 작성되어 MarkJ.csr 라는 이름의 파일에 놓여집니다. 이 파일은, VeriSign 등의 CA 에 제출합니다.  CA 는 요구자를 (일반적으로은 오프 라인으로) 인증해, 요구자의 공개키를 인증한 서명 첨부의 증명서를 돌려 보냅니다. 경우에 따라서는, CA 가 증명서의 체인을 돌려주는 일도 있습니다.  증명서의 체인에서는, 각 증명서가 체인내의 그 전의 서명자의 공개키를 인증합니다.

</blockquote>


<h3>CA 로부터의 증명서의 임포트</h3>

<blockquote>

<p>작성한 자기 서명 증명서는, 증명서 체인으로 옮겨놓을 필요가 있습니다.  증명서 체인에서는, 각 증명서가, 「루트」CA 를 기점으로 하는 체인내의 다음의 증명서의 서명자의 공개키를 인증합니다.

</p><p>CA 로부터의 증명 응답을 임포트 하려면 , 키스토어인가, (<a href="#importCertCmd">importcert 커멘드</a>  로 설명하고 있도록(듯이)) <code>cacerts</code> 키스토어파일내에 1 개 이상의 「신뢰할 수 있는 증명서」가 있을 필요가 있습니다.

</p><ul>

<li>증명 응답이 증명서 체인의 경우는, 체인의 탑의 증명서 (그 CA 의 공개키를 인증하는 「루트」CA 의 증명서)만을 필요로 한다<p>

</p></li><li>증명 응답이 단일의 증명서의 경우는, 증명서에 서명한 CA 의 발행용의 증명서가 필요해, 그 증명서가 자기 서명되지 않는 경우는, 한층 더 그 증명서의 서명자용의 증명서를 필요로 한다.  이와 같이 해 자기 서명되는 「루트」CA 의 증명서까지 각각 증명서를 필요로 한다

</li></ul>

<p>cacerts 키스토어파일은, 5 개의 VeriSign 루트 CA 증명서를 포함한 상태로 출시되고 있으므로, VeriSign 의 증명서를, 신뢰할 수 있는 증명서로서 키스토어내에 임포트 할 필요는 없을지도 모릅니다. 다만, 다른 CA 에 대해서 서명 첨부 증명서를 요구하고 있어, 이 CA 의 공개키를 인증하는 증명서가, cacerts 에 아직 추가되어 있지 않은 경우는, 해당하는 CA 로부터의 증명서를, 「신뢰할 수 있는 증명서」로서 임포트 할 필요가 있습니다.

</p><p>일반적으로, CA 로부터의 증명서는, 자기 서명 증명서, 또는 다른 CA 에 의해 서명된 증명서입니다 (후자의 경우는, 해당하는 것 외의 CA 의 공개키를 인증하는 증명서도 필요). 예를 들어, ABC 라고 하는 기업이 CA 라고 합니다.  이 때, 이 CA 의 공개키를 인증하는 자기 서명 증명서라고 생각되는 ABCCA.cer 라는 이름의 파일을, ABC 로부터 입수했다고 합니다.

</p><p>「신뢰할 수 있는 증명서」로서 증명서를 임포트 할 때는, 증명서가 유효한 것을 신중하게 확인할 필요가 있습니다. 우선, 증명서의 내용을 표시해 (<b>keytool</b> <code>-printcert</code> 커멘드를 사용하는지, 또는 <code>-noprompt</code> 옵션을 지정하지 않고 <b>keytool</b> <code>-importcert</code> 커멘드를 사용), 표시된 증명서의 지문이, 기대되는 지문과 일치할지 어떨지를 확인합니다. 증명서를 송신한 인물에게 연락해, 이 인물이 제시한 (또는 안전한 공개키의 리포지터리(repository)에 의해 제시된다) 지문과 위의 커멘드로 표시된 지문을 비교합니다. 지문이 일치하면, 송신 도중에 다른 누군가 (공격자등)에 의한 증명서의 바꿔치기를 하지 않은 것을 확인할 수 있습니다. 송신 도중에 이런 종류의 공격을 하고 있었을 경우, 체크를 실시하지 않고 증명서를 임포트 하면(자), 공격자에 의해 서명된 모든 것을 신뢰하게 됩니다.

</p><p>ABCCA.cer 를 유효한 증명서로서 신뢰하는 경우는, 증명서를 키스토어에 추가할 수 있습니다.  예를 들어, 다음과 같이 합니다.

</p><pre>    keytool -importcert -alias abc -file ABCCA.cer
</pre>

ABCCA.cer 파일의 데이터를 포함한 「신뢰할 수 있는 증명서」의 엔트리가 키스토어내에 작성되어 해당하는 엔트리에 abc 라고 하는 별명을 할당할 수 있습니다.

</blockquote>


<h3>CA 로부터의 증명 응답의 임포트</h3>

<blockquote>

<p>증명서 서명 요구의 제출처의 CA 의 공개키를 인증하는 증명서를 임포트 한 뒤는 (또는 동종의 증명서가 벌써 cacerts 파일내에 존재하고 있는 경우는), 증명 응답을 임포트 해, 자기 서명 증명서를 증명서 체인으로 옮겨놓을 수가 있습니다. 이 증명서 체인은, CA 의 응답이 체인의 경우, 증명서 서명 요구에 대한 응답으로서 CA 로부터 돌려 보내진 증명서 체인입니다.  또, CA 의 응답이 단일의 증명서의 경우는, 이 증명 응답과 임포트처의 키스토어내 또는 cacerts 키스토어파일내에 벌써 존재하는 신뢰할 수 있는 증명서를 사용해 구축한 증명서 체인입니다.

</p><p>예를 들어, 증명서 서명 요구를 VeriSign 에 송신했다고 합니다. 돌려 보내진 증명서의 이름이 VSMarkJ.cer 라고 하면(자), 다음과 같이 해 응답을 임포트 할 수 있습니다.

</p><pre>    keytool -importcert -trustcacerts -file VSMarkJ.cer
</pre>

</blockquote>


<h3>공개키를 인증하는 증명서의 export</h3>

<blockquote>

예를 들어,<a href="http://java.sun.com/javase/6/docs/tooldocs/solaris/jarsigner.html">jarsigner</a>  툴을 사용해 Java ARchive (JAR) 파일에 서명을 붙였다고 합니다. 이 JAR 파일은 클라이언트에 의해 사용됩니다만, 클라이언트측에서는 서명을 인증하고 싶다고 생각하고 있습니다.

<p>클라이언트가 서명을 인증하는 방법의 1 개에, 우선 자신의 공개키의 증명서를 「신뢰할 수 있다」엔트리로서 클라이언트의 키스토어에 임포트 하는 방법이 있습니다. 그 때문에(위해)는, 증명서를 export 해, 클라이언트에 제공합니다. 예를 들어, 다음과 같이 해, 증명서를 <code>MJ.cer</code> 라는 이름의 파일에 카피합니다.  이 엔트리에는 「mykey」라고 하는 별명이 사용되고 있다고 합니다.

</p><pre>    keytool -exportcert -alias mykey -file MJ.cer
</pre>

증명서와 서명 첨부 JAR 파일을 입수한 클라이언트는,<b>jarsigner</b> 툴을 사용해 서명을 인증할 수 있습니다.

</blockquote>




<!--h3>Changing Your Distinguished Name but Keeping your Key Pair</h3>  <blockquote>  Suppose your distinguished name changes, for example because you have changed departments or moved to a different city.  If desired, you may still use the public/private key pair you've previously used, and yet update your distinguished name.  For example, suppose your name is Susan Miller, and you created your initial key entry with the alias <code>sMiller</code> and the distinguished name  <pre>  "cn=Susan Miller, ou=Finance Department, o=BlueSoft, c=us"
</pre>  Suppose you change from the Finance Department to the Accounting Department.  You can still use the previously-generated public/private key pair and yet update your distinguished name by doing the following.   First, copy (clone) your key entry:  <pre>    keytool -keyclone -alias sMiller -dest sMillerNew
</pre>  (This prompts for the store password and for the initial and destination private key passwords, since they aren't provided at the command line. ) Now you need to change the certificate chain associated with the copy, so that the first certificate in the chain uses your different distinguished name.  Start by generating a self-signed certificate with the appropriate name:  <pre>    keytool -selfcert -alias sMillerNew
      -dname "cn=Susan Miller, ou=Accounting Department, o=BlueSoft, c=us"
</pre>  <p>Then generate a Certificate Signing Request based on the information in this new certificate:  </p><pre>    keytool -certreq -alias sMillerNew
</pre>  When you get the CA certificate reply, import it:  <pre>    keytool -import -alias sMillerNew -file VSSMillerNew.cer
</pre>  After importing the certificate reply, you may want to remove the initial key entry that used your old distinguished name:  <pre>    keytool -delete -alias sMiller
</pre>  </blockquote> -->

<h3>키스토어의 임포트</h3>
<blockquote>
<p>커멘드 「importkeystore」를 사용하면, 어느 키스토어의 전체를 다른 키스토어내에 임포트 할 수 있습니다. 이것은, 열쇠나 증명서라고 하는 소스키스토어내의 모든 엔트리가, 단일의 커멘드를 사용해 타겟트키스토어내에 임포트 되는 것을 의미합니다. 이 커멘드를 사용하면, 다른 타입의 키스토어내에 포함되는 엔트리를 임포트 할 수가 있습니다. 임포트시에는, 타겟트키스토어내의 새로운 엔트리는 모두, 원과 같은 별명 및 (비밀열쇠나 비공개키의 경우는) 보호용 패스워드를 가집니다. 소스키스토어내의 비공개키나 비밀키 리커버리시에 문제가 발생했을 경우,<b>keytool</b> 는 사용자에게 패스워드의 입력을 요구합니다. 이 커멘드는, 별명의 중복을 검출하면(자), 사용자에게 새로운 별명의 입력을 요구합니다. 사용자는, 새로운 별명을 지정하는 일도, 단순하게 기존의 별명의 덧쓰기를 <b>keytool</b> 에 허가할 수도 있습니다. </p>

<p>예를 들어, 일반적으로의 JKS 타입의 키스토어 key.jks 내의 엔트리를 PKCS #11 타입의 하드웨어 베이스의 키스토어내에 임포트 하려면 , 다음의 커멘드를 사용할 수 있습니다. </p>

<pre>keytool -importkeystore
    -srckeystore key.jks -destkeystore NONE
    -srcstoretype JKS -deststoretype PKCS11
    -srcstorepass changeit -deststorepass topsecret
</pre>
<p>또, importkeystore 커멘드를 사용하면, 어느 소스키스토어내의 단일의 엔트리를 타겟트키스토어에 임포트 할 수도 있습니다. 이 경우, 상기의 예로 가리킨 옵션에 가세해 임포트 대상이 되는 별명을 지정할 필요가 있습니다. srcalias 옵션을 지정하는 경우에는, 타겟 별명도 커멘드행으로부터 지정할 수 있는 것 외에 비밀/비공개키의 보호용 패스워드나 타겟 보호용 패스워드도 지정할 수 있습니다. 그러면, prompt의 전혀 표시되지 않는 <b>keytool</b> 커멘드를 발행할 수 있습니다. 이것은,<b>keytool</b> 커멘드를 스크립트 파일에 포함할 때에 매우 편리합니다. 다음에 예를 나타냅니다. </p>

<pre>keytool -importkeystore
    -srckeystore key.jks -destkeystore NONE
    -srcstoretype JKS -deststoretype PKCS11
    -srcstorepass changeit -deststorepass topsecret
    -srcalias myprivatekey -destalias myoldprivatekey
    -srckeypass oldkeypass -destkeypass mynewkeypass
    -noprompt
</pre>

</blockquote>
</blockquote>


<h2>용어와 경고</h2>

<blockquote>

<a name="KeyStore"></a> 
<h3>키스토어</h3>

<blockquote>
키스토어는, 암호화의 열쇠와 증명서를 포함하기 위한 기능입니다.
</blockquote>

<ul>
<a name="KeyStoreEntries"></a> 
<li><h4>키스토어의 엔트리</h4>

<blockquote>

키스토어에는 다른 타입의 엔트리를 포함할 수가 있습니다. <b>keytool</b> 에서 가장 적용 범위의 넓은 엔트리 타입은, 다음의 2 개입니다.

<ol>

<li><b>열쇠의 엔트리</b> - 각 엔트리는, 매우 중요한 암호화의 열쇠의 정보를 보관 유지합니다. 이 정보는, 허가하고 있지 않는 액세스를 막기 위해서(때문에), 보호된 형태로 포함됩니다.  일반적으로, 이런 종류의 엔트리로서 포함되는 열쇠는, 비밀열쇠인가, 대응하는 공개키의<a href="#CertChains">증명서 체인</a>을 수반하는 비공개키입니다. <b>keytool</b> 가 이 양쪽 모두의 타입의 엔트리를 처리할 수 있는데 대해,<b>jarsigner</b> 툴은 후자의 타입의 엔트리, 즉 비공개키와 거기에 관련지을 수 있었던 증명서 체인만을 처리합니다. <p>

</p></li><li><b>신뢰할 수 있는 증명서의 엔트리</b> - 각 엔트리는, 제삼자로부터의 공개키 증명서를 1 개 포함하고 있습니다. 이 증명서는, 「신뢰할 수 있는 증명서」라고 불립니다.  그것은, 증명서내의 공개키가, 증명서의 「Subject」(소유자)에 의해 특정되는 아이덴티티에 유래하는 것인 것을, 키스토어의 소유자가 신뢰하기 때문입니다. 증명서의 발행자는, 증명서에 서명을 붙이는 것에 의해, 그 내용을 보증합니다.

</li></ol>

</blockquote>



<a name="KeyStoreAliases"></a> 
</li><li><h4>키스토어의 별명</h4>

<blockquote>

<p>키스토어의 모든 엔트리 (열쇠 및 신뢰할 수 있는 증명서)는, 일의의 「별명」을 개입시켜 액세스 됩니다.

</p><p>별명을 지정하는 것은,<a href="#genseckeyCmd">-genseckey</a>  커멘드를 사용해 비밀열쇠를 생성하거나<a href="#genkeypairCmd">-genkeypair</a>  커멘드를 사용해 열쇠 페어 (공개키와 비공개키)를 생성하거나<a href="#importCertCmd">-importcert</a>  커멘드를 사용해 증명서 또는 증명서 체인을 신뢰할 수 있는 증명서의 리스트에 추가하거나 하는 등, 특정의 엔티티를 키스토어에 추가하는 경우입니다. 이것 이후,<b>keytool</b> 커멘드로 엔티티를 참조하는 경우는, 이 때로 지정한 별명을 사용할 필요가 있습니다.

</p><p>예를 들어,<tt>duke</tt> 라고 하는 별명을 사용해 새로운 공개키와 비공개키의 페어를 생성해, 공개키를 자기 서명 증명서 (<a href="#CertChains">「증명서 체인」</a>을 참조)로 랩 한다고 합니다.  이 경우는, 다음의 커멘드를 실행합니다.

</p><pre>    keytool -genkeypair -alias duke -keypass dukekeypasswd
</pre>

여기에서는, 초기 패스워드로서 dukekeypasswd 를 지정하고 있습니다.  이후, 별명 <code>duke</code> 에 관련지을 수 있었던 비공개키에 액세스 하는 커멘드를 실행할 때는, 이 패스워드가 필요하게 됩니다. duke 의 비공개키의 패스워드를 나중에 변경하려면 , 다음의 커멘드를 실행합니다.

<pre>    keytool -keypasswd -alias duke -keypass dukekeypasswd -new newpass
</pre>

패스워드가, dukekeypasswd 로부터 newpass 로 변경됩니다.

<p>주 -테스트를 목적으로 하는 경우, 또는 안전하다라고 하는 것이 알고 있는 시스템으로 실행하는 경우 이외는, 커멘드행이나 스크립트로 패스워드를 지정하지 말아 주세요. 필요한 패스워드의 옵션을 커멘드행으로 지정하지 않았던 경우는, 패스워드의 입력이 요구됩니다.

</p></blockquote>


<a name="KeyStoreImplementation"></a> 
</li><li><h4>키스토어의 구현</h4>

<blockquote>

<code>java.security</code> 패키지로 제공되는 <code>KeyStore</code> 클래스에는, 키스토어내의 정보에 대한 액세스라고 변경을 행하기 위한 명확하게 정의된 인터페이스가 준비되어 있습니다. 키스토어의 고정 구현으로서는, 각각이 특정의 「타입」의 키스토어를 대상으로 하는 복수가 다른 구현이 존재 가능합니다.

<p>현재,<b>keytool</b> 와 <b>jarsigner</b> 의 2 개의 커멘드행 툴과<b>Policy Tool</b> 라는 이름의 1 개의 GUI 베이스의 툴이, 키스토어의 구현을 사용하고 있습니다. <code>KeyStore</code> 는 public 로서 사용 가능해서, JDK 사용자는 <code>KeyStore</code> 를 사용한 것 외의 시큐리티 어플리케이션도 작성할 수 있습니다.

</p><p>키스토어에는, Sun 가 제공하는 편입의 디폴트의 구현이 있습니다. 이것은, JKS 라는 이름의 독자적인 키스토어타이프 (형식)를 이용해서 , 키스토어를 파일로서 구현하고 있습니다. 이 구현에서는, 개개의 비공개키는 개별의 패스워드에 의해 보호되어 키스토어 전체의 무결성도 (비공개키와는 다른) 패스워드에 의해 보호됩니다.

</p><p>키스토어의 구현은, 프로바이더 베이스입니다. 구체적으로는,<code>KeyStore</code> 가 제공하는 어플리케이션 인터페이스는, Service Provider Interface (SPI)라고 하는 형태로 구현되고 있습니다. 즉, 대응하는 <code>KeystoreSpi</code> 추상 클래스 (이것도 <code>java.security</code> 패키지에 포함되어 있다)가 있어, 이 클래스가 Service Provider Interface 의 메소드를 정의하고 있습니다. 이러한 메소드는, 「프로바이더」가 구현하지 않으면 안됩니다. 여기서, 「프로바이더」란, Java Security API 에 의해 액세스 가능한 서비스의 부분집합에 대해, 그 고정 구현을 제공하는 패키지 또는 패키지의 집합입니다. 따라서, 키스토어의 구현을 제공하려면 ,<a href="../../guides/security/HowToImplAProvider.html">「Java(TM) 암호화 아키텍쳐(architecture)용 프로바이더의 구현 방법」</a>으로 설명하고 있도록(듯이), 클라이언트가 「프로바이더」를 구현해,KeystoreSpi 서브 클래스의 구현을 제공할 필요가 있습니다.

</p><p>어플리케이션에서는,<code>KeyStore</code> 클래스가 제공하는 getInstance 팩토리 메소드를 사용하는 것으로, 다양한 프로바이더로부터 다른 「타입」의 키스토어의 구현을 선택할 수 있습니다. 키스토어의 타입은, 키스토어 정보의 포함 형식과 데이터 형식을 정의함과 함께, 키스토어내의 비공개/비밀열쇠와 키스토어 자체의 무결성을 보호하기 위해서 사용되는 알고리즘을 정의합니다. 다른 타입의 키스토어의 구현에는, 호환성은 없습니다.

</p><p><b>keytool</b> 는, 임의의 파일 베이스의 키스토어 구현으로 동작합니다. <b>keytool</b> 는, 커멘드행으로부터 건네받은 키스토어의 장소를 파일명으로서 취급해, 이것을 FileInputStream 로 변환해, FileInputStream 로부터 키스토어의 정보를 로드합니다. 한편,<b>jarsigner</b> 툴과 <b>policytool</b> 툴은, URL 로 지정 가능한 임의의 장소로부터 키스토어를 읽어들일 수가 있습니다.

</p><p><b>keytool</b> 와 <b>jarsigner</b> 의 경우,<i>-storetype</i> 옵션을 사용해 커멘드행으로 키스토어의 타입을 지정할 수 있습니다. <b>Policy Tool</b>의 경우는, 「키스토어」메뉴에 의해 키스토어의 타입을 지정할 수 있습니다.

</p><p>키스토어의 타입을 명시적으로 지정하지 않는 경우,<b>keytool</b>,<b>jarsigner</b>, 및 <b>policytool</b> 의 각 툴은, 시큐리티 프로퍼티 파일내에서 지정된 <code>keystore.type</code> 프로퍼티의 값에 근거해 키스토어의 구현을 선택합니다. 시큐리티 프로퍼티 파일은,<tt>java.security</tt> 라는 이름으로 시큐리티 프로퍼티 디렉토리 <code><i>java.home</i>/lib/security</code> 에 놓여져 있습니다. <i> java.home</i> 는, 실행 환경의 디렉토리 (SDK 의 <tt>jre</tt> 디렉토리 또는 Java 2 Runtime Environment 의 최상정도 디렉토리)입니다.

</p><p>각 툴은,<code>keystore.type</code> 의 값을 취득해, 이 값으로 지정된 타입의 키스토어를 구현하고 있는 프로바이더가 발견될 때까지, 현재 인스톨 떠날 수 있어 모든 프로바이더를 조사합니다. 목적의 프로바이더가 발견되면(자), 그 프로바이더로부터의 키스토어의 구현을 사용합니다.

</p><p><code>KeyStore</code> 클래스에서는 <code>getDefaultType</code> 라는 이름의 static 메소드가 정의되고 있어 어플리케이션과 애플릿은 이 메소드를 사용하는 것으로 <code>keystore.type</code> 프로퍼티의 값을 취득할 수 있습니다. 다음의 코드는, 디폴트의 키스토어타이프 (<code>keystore.type</code> 프로퍼티으로 지정된 타입)의 인스턴스를 생성합니다.

</p><pre>    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
</pre>

<p>디폴트의 키스토어타이프는 JKS (Sun 가 제공하는 독자적인 타입의 키스토어의 구현)입니다. 이것은, 시큐리티 프로퍼티 파일내의 다음의 행에 의해 지정되고 있습니다.

</p><pre>    keystore.type=jks
</pre>

<p>각 툴로 디폴트 이외의 키스토어의 구현을 사용하려면 , 위의 행을 변경해 다른 키스토어의 타입을 지정합니다.

</p><p>예를 들어, pkcs12 로 불리는 타입의 키스토어의 구현을 제공하고 있는 프로바이더 패키지를 사용하려면 , 위의 행을 다음과 같이 변경합니다.

</p><pre>    keystore.type=pkcs12
</pre>

주:키스토어의 타입의 지정에서는, 대문자와 소문자는 구별되지 않습니다. 예를 들어, JKS 와 jks 는 같은 것으로서 다루어집니다.

</blockquote>

</li></ul>

<h3><a name="Certificates">증명서</a> </h3>

<blockquote>
<b>증명서</b> (<b>공개키 증명서</b>라고도 부른다)란, 어느 엔티티 ( 「발행자」)로부터의 디지털 서명 첨부의 문서입니다.  증명서에는, 다른 있는 엔티티 ( 「서명자」)의 공개키 ( 및 그 외의 정보)가 특별한 값을 가지고 있는 것이 쓰여져 있습니다.
</blockquote>

<ul>
<a name="CertificateTerms"></a> 
<li><h4>증명서의 용어</h4>
<blockquote>

<p></p><dl><dt><i>공개키</i>
</dt><dd>
공개키는, 특정의 엔티티에 관련지을 수 있었던 수입니다. 공개키는, 해당하는 엔티티와의 사이에 신뢰할 수 있는 관계를 가질 필요가 있는 모든 사람에 대해서 공개하는 것을 의도한 것입니다. 공개키는, 서명을 검증하는데 사용됩니다.
</dd><dt><i>디지털 서명</i>
</dt><dd>
데이터가 「디지털 서명」되면(자), 그 데이터는, 엔티티의 「아이덴티티」라고, 그 엔티티가 데이터의 내용에 대해 알고 있는 것을 증명하는 서명과 함께 포함됩니다. 엔티티의 비공개키를 사용해 데이터에 서명을 붙이면(자), 데이터의 위조는 불가능하게 됩니다.
</dd><dt><i>아이덴티티</i>
</dt><dd>
엔티티를 특정하기 위한 기존의 방법입니다. 시스템에 따라서는, 공개키를 아이덴티티로 하는 것이 있습니다. 공개키 외에도, Unix UID 나 전자메일 주소, X. 509 식별명 등, 다양한 것을 아이덴티티로 할 수가 있습니다.
</dd><dt><i>서명</i>
</dt><dd>
서명은, 하등의 데이터를 기본으로 엔티티 (서명자.  증명서에 관해서는 발행자라고도 불린다)의 비공개키를 사용해 계산됩니다.
</dd><dt><i>비공개키</i>
</dt><dd>
비공개키는 특정의 엔티티만이 알고 있는 수로, 이 수를, 그 엔티티의 비공개키라고 합니다. 비공개키는, 그 밖에 알려지지 않게 비밀로 해 두는 것이 전제가 되어 있습니다. 비공개키와 공개키는, 모든 공개키암호화 시스템으로 대가 되어 존재하고 있습니다. DSA 등이 전형적인 공개키암호화 시스템의 경우, 1 개의 비공개키는 정확하게 1 개의 공개키에 대응합니다. 비공개키는, 서명을 계산하는데 사용됩니다.
</dd><dt><i>엔티티</i>
</dt><dd>
엔텐티는, 사람, 조직, 프로그램, 컴퓨터, 기업, 은행 등, 일정한 정도로 신뢰의 대상이 되는 다양한 것을 가리킵니다.
</dd></dl>

<p>
공개키암호화에서는, 그 성질상, 사용자의 공개키에 액세스 할 필요가 있습니다. 대규모 네트워크 환경에서는, 서로 통신하고 있는 엔티티간에 이전의 관계가 계속해 확립되어 있으면(자) 가정하거나 사용해져 모든 공개키를 거둔 신뢰할 수 있는 리포지터리(repository)가 존재하면(자) 가정하거나 하는 것은 불가능합니다. 이러한 공개키의 배포에 관한 문제를 해결하기 위해서 증명서가 고안 되었습니다. 현재는, 「증명서 발행국 (CA)」를 신뢰할 수 있는 제삼자로서 기능합니다. CA 는, 다른 엔티티의 증명서에 서명하는 (발행한다) 행위를, 신뢰해 맡고 있는 엔티티 (기업 등)입니다. CA 는 법률상의 계약에 구속되므로, 유효하고 신뢰할 수 있는 증명서만을 작성하는 것으로서 다루어집니다. <a href="http://www.verisign.com/"> VeriSign</a> ,<a href="http://www.thawte.com/">Thawte</a> ,<a href="http://www.entrust.com/">Entrust</a>  를 시작해 많은 CA 가 존재합니다. Netscape 나 Microsoft 의 인증 서버-, Entrust 의 CA 제품등을 소속 조직내에서 이용하면, 독자적인 증명서 발행국을 운영하는 일도 가능합니다.

</p><p><b>keytool</b> 를 사용하면(자), 증명서의 표시, 임포트, 및 export를 실시할 수가 있습니다. 또, 자기 서명 증명서를 생성할 수도 있습니다.

</p><p>현재,<b>keytool</b> 는 X. 509 증명서를 대상으로 하고 있습니다.
</p></blockquote>

<a name="X509Cert"></a> 
</li><li><h4>X. 509 증명서</h4>

<blockquote>

X. 509 규격에서는, 증명서에 포함하는 정보가 정의되고 있어 이 정보를 증명서에 기입하는 방법 (데이터 형식)에 대해서도 기술되고 있습니다. 증명서의 모든 데이터는, ASN. 1/DER 로 불리는 2 개의 관련 규격을 사용해 encode 됩니다. <i>Abstract Syntax Notation 1</i> 은 데이터에 대해 기술하고 있습니다. <i>Definite Encoding Rules</i> 는, 데이터의 보존 및 전송의 방법에 대해 기술하고 있습니다.

<p>모든 X. 509 증명서는, 서명 외에 다음의 데이터를 포함하고 있습니다.

</p><dl><dt><i>버젼</i>
</dt><dd>증명서에 적용되는 X. 509 규격의 버젼을 특정합니다. 증명서로 지정할 수 있는 정보는, 버젼에 따라서 다릅니다. 지금까지, 3 개의 버젼이 정의되고 있습니다. <b> keytool</b> 에서는, v1, v2, 및 v3 의 증명서의 임포트와 export가 가능합니다. keytool 가 생성하는 것은, v3 의 증명서입니다.

<p>
「X. 509 Version 1」은, 1988 년부터 이용되어 넓게 보급하고 있어, 가장 일반적입니다.

</p><p>「X. 509 Version 2」에서는, Subject 나 발행자의 이름을 나중에 재사용할 수 있도록(듯이) 하기 위해서, Subject 와 발행자의 일의 식별자의 개념이 도입되었습니다. 대부분의 증명서 프로파일 문서에서는, 이름을 재사용하지 않는 것과 증명서로 일의인 식별자를 사용하지 않는 것이, 강하고 추천 되고 있습니다. Version 2 의 증명서는, 넓지는 사용되고 있지 않습니다.

</p><p>「X. 509 Version 3」은 가장 새로운 (1996 년) 규격으로, extension의 개념을 지원하고 있습니다. extension는 누구라도 정의할 수가 있어 증명서에 포함할 수가 있습니다. 현재 사용되고 있는 일반적인 extension로서는, KeyUsage ( 「서명 전용」 등, 열쇠의 사용을 특정의 목적으로 제한한다), AlternativeNames (DNS 명, 전자메일 주소, IP 주소 등, 다른 아이덴티티를 공개키에 관련지을 수가 있다)등이 있습니다. extension에는, critical 라고 하는 마크를 붙여, 그 extension의 체크와 사용을 의무 부여할 수가 있습니다. 예를 들어, critical 와 마크 되어 KeyCertSign 가 설정된 KeyUsage extension가 증명서에 포함되어 있는 경우, 이 증명서를 SSL 통신중에 제시하면(자), 증명서가 거부됩니다. 이것은, 증명서의 extension에 의해, 관련하는 비공개키가 증명서의 서명 전용으로서 지정되고 있어 SSL 에서는 사용할 수 없기 때문입니다.
</p>

</dd><dt><i>시리얼 번호</i>
</dt><dd>증명서를 작성한 엔티티는, 그 엔티티가 발행하는 것 외의 증명서와 구별하기 위해서, 증명서에 시리얼 번호를 할당합니다. 이 정보는, 다양한 방법으로 사용됩니다. 예를 들어, 증명서가 삭제되면(자), 시리얼 번호가 증명서의 취소 리스트 (CRL)에 포함됩니다.

<p></p></dd><dt><i>서명 알고리즘 식별자</i>
</dt><dd>증명서에 서명을 붙일 때 CA 가 사용한 알고리즘을 특정합니다.

<p></p></dd><dt><i>발행자명</i>
</dt><dd>증명서에 서명을 붙인 엔티티의 <a href="#DName">X. 500 식별명</a>입니다. 엔티티는, 일반적으로은 CA 입니다. 이 증명서를 사용하는 것은, 증명서에 서명을 붙인 엔티티를 신뢰하는 것을 의미합니다. 「루트」즉 「톱 레벨」의 CA 의 증명서 등, 경우에 따라서는 발행자가 자신의 증명서에 서명을 붙이는 일이 있는 점에 주의해 주세요.

<p></p></dd><dt><i>유효기간</i>
</dt><dd>각 증명서는, 한정된 기간만 유효하게 됩니다. 이 기간은 개시의 일시와 종료의 일시에 의해 지정되어 몇 초의 짧은 기간부터 100 년이라고 하는 장기에 걸치는 일도 있습니다. 선택되는 유효기간은, 증명서에의 서명에 사용되는 비공개키의 강도나 증명서에 지불하는 금액 등, 다양한 요인으로 다릅니다. 유효기간은, 사용하는 비공개키가 손상되지 않는 경우에, 엔티티가 공개키를 신뢰할 수 있다고 기대되는 기간입니다.

<p></p></dd><dt><i>Subject 명</i>
</dt><dd>증명서로 공개키가 식별되고 있는 엔티티의 이름입니다. 이 이름은 X. 500 표준을 사용하므로, 인터넷 전체로 일의인 것과 상정됩니다. 이것은, 엔티티의 <a href="#DName">X. 500 식별명</a>  (DN)입니다.  다음에 예를 나타냅니다.
<pre>    CN=Java Duke, OU=Java Software Division, O=Sun Microsystems Inc, C=US
</pre>
이것들은 각각 주체의 통칭, 조직 단위, 조직, 나라를 나타냅니다.

<p></p></dd><dt><i>Subject 의 공개키 정보</i>
</dt><dd>이름을 붙일 수 있었던 엔티티의 공개키와 알고리즘 식별자입니다. 알고리즘 식별자에서는, 공개키에 대해서 사용되고 있는 공개키암호화 시스템 및 관련하는 열쇠 파라미터가 지정되고 있습니다.
</dd></dl>

</blockquote>


<a name="CertChains"></a> 
</li><li><h4>증명서 체인</h4>

<blockquote>

<p><b>keytool</b> 에서는, 비공개키 및 관련하는 증명서 「체인」을 포함한 키스토어의 「열쇠」엔트리를 작성해, 관리할 수가 있습니다. 이러한 엔트리에서는, 비공개키에 대응하는 공개키는, 체인의 최초의 증명서에 포함되어 있습니다.

</p><p>열쇠를 처음으로 작성하면(자) (<a href="#genkeypairCmd">-genkeypair</a>  커멘드를 참조), 「자기 서명 증명서」라고 하는 1 개의 요소만을 포함한 체인이 개시됩니다. 자기 서명 증명서는, 발행자 (서명자)가 주체 (증명서로 인증되고 있는 공개키의 소유자)와 같은 증명서입니다. <code> -genkeypair</code> 커멘드를 호출해 새로운 공개키와 비공개키의 페어를 작성하면(자), 공개키는 항상 자기 서명 증명서로 랩 됩니다.

</p><p>이후에, 증명서 서명 요구 (CSR)가 생성되어 (<a href="#certreqCmd">-certreq</a>  커멘드를 참조), CSR 가 증명서 발행국 (CA)에 송신되면(자), CA 로부터의 응답이 임포트 되고 (<a href="#importCertCmd">-importcert</a>  커멘드를 참조), 원의 자기 서명 증명서는 증명서 체인에 의해 옮겨놓을 수 있습니다. 체인의 마지막에 있는 것은, Subject 의 공개키를 인증한 CA 가 발행한 증명서 (응답)입니다. 체인내의 그 전의 증명서는, 「CA」의 공개키를 인증하는 증명서입니다.

</p><p>CA 의 공개키를 인증하는 증명서는, 많은 경우, 자기 서명 증명서 (즉 CA 가 자신의 공개키를 인증한 증명서)이며, 이것은 체인의 최초의 증명서가 됩니다. 경우에 따라서는, CA 가 증명서의 체인을 돌려주는 일도 있습니다. 이 경우, 체인내의 마지막 증명서 (CA 에 의해 서명되어 열쇠 엔트리의 공개키를 인증하는 증명서)에 변화는 없습니다만, 체인내의 그 전의 증명서는, CSR 의 송신지의 CA 와는 「다른」CA 에 의해 서명되어 CSR 의 송신지의 CA 의 공개키를 인증하는 증명서가 됩니다. 게다가 체인내의 그 전의 증명서는, 다음의 CA 의 열쇠를 인증하는 증명서가 됩니다.  이하 같이 자기 서명된 「루트」증명서에 이를 때까지 체인이 계속됩니다. 따라서, 체인내의 (최초의 증명서 이후의) 각 증명서에서는, 체인내의 다음의 증명서의 서명자의 공개키가 인증되고 있게 됩니다.

</p><p>많은 CA 는, 체인을 지원하지 않고 발행필의 증명서만을 돌려줍니다.  특히, 중간의 CA 가 존재하지 않는 플랫인 계층 구조의 경우는, 그 경향이 현저합니다. 이러한 경우는, 키스토어에 벌써 포함되고 있는 신뢰할 수 있는 증명서 정보로부터, 증명서 체인을 확립할 필요가 있습니다.

</p><p>다른 응답 형식 (PKCS#7 로 정의되고 있는 형식)에서도, 발행필 증명서에 가세해 증명서 체인의 지원가 포함되어 있습니다. <b>keytool</b> 에서는, 어느 쪽의 응답 형식도 취급할 수가 있습니다.

</p><p>톱 레벨 (루트) CA 의 증명서는, 자기 서명 증명서입니다. 다만, 루트의 공개키에 대한 신뢰는, 루트의 증명서 자체로부터 도출되는 것은 아니고 (예를 들어, VeriSign 루트 CA 와 같이 유명한 식별명을 사용한 자기 서명 증명서를 작성하는 것 자체는 누구라도 가능), 신문등의 다른 정보원에 유래하는 것입니다. 루트 CA 의 공개키는 널리 알려지고 있습니다. 루트 CA 의 공개키를 증명서에 포함하는 이유는, 증명서라고 하는 형식으로 하는 것으로 많은 툴로부터 이용할 수 있게 되기 때문에 지나지 않습니다.  즉, 증명서는, 루트 CA 의 공개키를 옮기는 「매체」로서 이용될 뿐입니다. 루트 CA 의 증명서를 키스토어에 추가할 때는, 그 전에 증명서의 내용을 표시해 (<code>-printcert</code> 옵션을 사용), 표시된 지문과 신문이나 루트 CA 의 Web 페이지등에서 입수한 기존의 지문을 비교할 필요가 있습니다.

</p></blockquote>

<a name="cacerts"></a> 
</li><li><h4>cacerts 증명서 파일</h4>

<blockquote>

<p><b>cacerts </b>증명서 파일은, 시큐리티 프로퍼티 디렉토리 <code><i>java.home</i>/lib/security</code> 에 놓여져 있습니다. <i> java.home</i> 는, 실행 환경의 디렉토리 (SDK 의 <tt>jre</tt> 디렉토리 또는 Java 2 Runtime Environment 의 최상정도 디렉토리)입니다.

</p><p>cacerts 파일은, CA 의 증명서를 포함한, 시스템 전체의 키스토어입니다. 시스템 관리 책임자는, 키스토어타이프에 jks 를 지정하는 것으로,<b>keytool</b> 를 사용해 이 파일의 구성과 관리를 실시할 수가 있습니다. cacerts 키스토어파일은, 다음의 별명 및 X. 500 소유자 식별명을 가지는 몇개의 루트 CA 증명서를 포함한 상태로 출시되고 있습니다.  </p><p>

</p>            <ul>
<li><b>Alias</b>:thawtepersonalfreemailca <br /> <b>Owner DN</b>:EmailAddress=personal-freemail@thawte.com, <br /> CN=Thawte Personal Freemail CA, <br /> OU=Certification Services Division, <br /> O=Thawte Consulting, L=Cape Town, ST=Western Cape, C=ZA</li>

<li><b>Alias</b>:thawtepersonalbasicca <br /> <b>Owner DN</b>:EmailAddress=personal-basic@thawte.com, <br /> CN=Thawte Personal Basic CA, <br /> OU=Certification Services Division, <br /> O=Thawte Consulting, L=Cape Town, ST=Western Cape, C=ZA</li>

<li><b>Alias</b>:thawtepersonalpremiumca <br /> <b>Owner DN</b>:EmailAddress=personal-premium@thawte.com, <br /> CN=Thawte Personal Premium CA, <br /> OU=Certification Services Division, <br /> O=Thawte Consulting, L=Cape Town, ST=Western Cape, C=ZA</li>

<li><b>Alias</b>:thawteserverca <br /> <b>Owner DN</b>:EmailAddress=server-certs@thawte.com, <br /> CN=Thawte Server CA, OU=Certification Services Division, <br /> O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA</li>

<li><b>Alias</b>:thawtepremiumserverca <br /> <b>Owner DN</b>:EmailAddress=premium-server@thawte.com, <br /> CN=Thawte Premium Server CA, <br /> OU=Certification Services Division, <br /> O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA</li>

<li><b>Alias</b>:verisignclass1ca <br /> <b>Owner DN</b>:OU=Class 1 Public Primary Certification Authority, <br /> O="VeriSign, Inc. ", C=US</li>

<li><b>Alias</b>:verisignclass2ca<br /> <b>Owner DN</b>:OU=Class 2 Public Primary Certification Authority, <br /> O="VeriSign, Inc. ", C=US</li>

<li><b>Alias</b>:verisignclass3ca <br /> <b>Owner DN</b>:OU=Class 3 Public Primary Certification Authority, <br /> O="VeriSign, Inc. ", C=US</li>

<li><b>Alias</b>:verisignserverca <br /> <b>Owner DN</b>:OU=Secure Server Certification Authority, <br /> O="RSA Data Security, Inc. ", C=US</li>

<li><b>Alias</b>:verisignclass1g2ca<br /> <b>Owner DN</b>:OU=VeriSign Trust Network,<br /> OU="(c) 1998 VeriSign, Inc.  - For authorized use only",<br /> OU=Class 1 Public Primary Certification Authority - G2,<br /> O="VeriSign, Inc. ", C=US</li>

<li><b>Alias</b>:verisignclass1g3ca<br /> <b>Owner DN</b>:CN=VeriSign Class 1 Public Primary Certification Authority - G3, OU="(c) 1999 VeriSign, Inc.  - For authorized use only",<br /> OU=VeriSign Trust Network,<br /> O="VeriSign, Inc. ", C=US</li>

<li><b>Alias</b>:verisignclass2g2ca<br /> <b>Owner DN</b>:OU=VeriSign Trust Network,<br /> OU="(c) 1998 VeriSign, Inc.  - For authorized use only",<br /> OU=Class 2 Public Primary Certification Authority - G2,<br /> O="VeriSign, Inc. ", C=US</li>

<li><b>Alias</b>:verisignclass2g3ca<br /> <b>Owner DN</b>:CN=VeriSign Class 2 Public Primary Certification Authority - G3,<br /> OU="(c) 1999 VeriSign, Inc.  - For authorized use only",<br /> OU=VeriSign Trust Network,<br /> O="VeriSign, Inc. ", C=US</li>

<li><b>Alias</b>:verisignclass3g2ca<br /> <b>Owner DN</b>:OU=VeriSign Trust Network,<br /> OU="(c) 1998 VeriSign, Inc.  - For authorized use only",<br /> OU=Class 3 Public Primary Certification Authority - G2,<br /> O="VeriSign, Inc. ", C=US</li>

<li><b>Alias</b>:verisignclass3g3ca<br /> <b>Owner DN</b>:CN=VeriSign Class 3 Public Primary Certification Authority - G3,<br /> OU="(c) 1999 VeriSign, Inc.  - For authorized use only",<br /> OU=VeriSign Trust Network,<br /> O="VeriSign, Inc. ", C=US</li>

<li><b>Alias</b>:baltimorecodesigningca<br /> <b>Owner DN</b>:CN=Baltimore CyberTrust Code Signing Root,<br /> OU=CyberTrust, O=Baltimore, C=IE</li>

<li><b>Alias</b>:gtecybertrustglobalca<br /> <b>Owner DN</b>:CN=GTE CyberTrust Global Root,<br /> OU="GTE CyberTrust Solutions, Inc. ", O=GTE Corporation, C=US</li>

<li><b>Alias</b>:baltimorecybertrustca<br /> <b>Owner DN</b>:CN=Baltimore CyberTrust Root,<br /> OU=CyberTrust, O=Baltimore, C=IE</li>

<li><b>Alias</b>:gtecybertrustca<br /> <b>Owner DN</b>:CN=GTE CyberTrust Root,<br /> O=GTE Corporation, C=US</li>

<li><b>Alias</b>:gtecybertrust5ca<br /> <b>Owner DN</b>:CN=GTE CyberTrust Root 5,<br /> OU="GTE CyberTrust Solutions, Inc. ", O=GTE Corporation, C=US</li>

<li><b>Alias</b>:entrustclientca<br /> <b>Owner DN</b>:CN=Entrust.net Client Certification Authority,<br /> OU=(c) 1999 Entrust.net Limited,<br /> OU=www.entrust.net/Client_CA_Info/CPS incorp.  by ref.  limits liab.,<br /> O=Entrust.net, C=US</li>

<li><b>Alias</b>:entrustglobalclientca<br /> <b>Owner DN</b>:CN=Entrust.net Client Certification Authority,<br /> OU=(c) 2000 Entrust.net Limited,<br /> OU=www.entrust.net/GCCA_CPS incorp.  by ref.  (limits liab. ),<br /> O=Entrust.net</li>

<li><b>Alias</b>:entrust2048ca<br /> <b>Owner DN</b>:CN=Entrust.net Certification Authority (2048),<br /> OU=(c) 1999 Entrust.net Limited,<br /> OU=www.entrust.net/CPS_2048 incorp.  by ref.  (limits liab. ),<br /> O=Entrust.net</li>

<li><b>Alias</b>:entrustsslca<br /> <b>Owner DN</b>:CN=Entrust.net Secure Server Certification Authority,<br /> OU=(c) 1999 Entrust.net Limited,<br /> OU=www.entrust.net/CPS incorp.  by ref.  (limits liab. ),<br /> O=Entrust.net, C=US</li>

<li><b>Alias</b>:entrustgsslca<br /> <b>Owner DN</b>:CN=Entrust.net Secure Server Certification Authority,<br /> OU=(c) 2000 Entrust.net Limited,<br /> OU=www.entrust.net/SSL_CPS incorp.  by ref.  (limits liab. ),<br /> O=Entrust.net</li>

<li><b>Alias</b>:godaddyclass2ca<br /> <b>Owner DN</b>:OU=Go Daddy Class 2 Certification Authority,<br /> O="The Go Daddy Group, Inc. ", C=US</li>

<li><b>Alias</b>:starfieldclass2ca<br /> <b>Owner DN</b>:OU=Starfield Class 2 Certification Authority,<br /> O="Starfield Technologies, Inc. ", C=US</li>

<li><b>Alias</b>:valicertclass2ca<br /> <b>Owner DN</b>:EMAILADDRESS=info@valicert.com,<br /> CN=http://www.valicert.com/,<br /> OU=ValiCert Class 2 Policy Validation Authority,<br /> O="ValiCert, Inc. ", L=ValiCert Validation Network</li>

<li><b>Alias</b>:geotrustglobalca<br /> <b>Owner DN</b>:CN=GeoTrust Global CA,<br /> O=GeoTrust Inc., C=US</li>

<li><b>Alias</b>:equifaxsecureca<br /> <b>Owner DN</b>:OU=Equifax Secure Certificate Authority,<br /> O=Equifax, C=US</li>

<li><b>Alias</b>:equifaxsecureebusinessca1<br /> <b>Owner DN</b>:CN=Equifax Secure eBusiness CA-1,<br /> O=Equifax Secure Inc., C=US</li>

<li><b>Alias</b>:equifaxsecureebusinessca2<br /> <b>Owner DN</b>:OU=Equifax Secure eBusiness CA-2,<br /> O=Equifax Secure, C=US</li>

<li><b>Alias</b>:equifaxsecureglobalebusinessca1<br /> <b>Owner DN</b>:CN=Equifax Secure Global eBusiness CA-1,<br /> O=Equifax Secure Inc., C=US</li>

<li><b>Alias</b>:soneraclass1ca<br /> <b>Owner DN</b>:CN=Sonera Class1 CA, O=Sonera, C=FI</li>

<li><b>Alias</b>:soneraclass2ca<br /> <b>Owner DN</b>:CN=Sonera Class2 CA, O=Sonera, C=FI</li>

<li><b>Alias</b>:comodoaaaca<br /> <b>Owner DN</b>:CN=AAA Certificate Services,<br/> O=Comodo CA Limited, L=Salford, ST=Greater Manchester, C=GB</li>

<li><b>Alias</b>:addtrustclass1ca<br /> <b>Owner DN</b>:CN=AddTrust Class 1 CA Root,<br/> OU=AddTrust TTP Network, O=AddTrust AB, C=SE</li>

<li><b>Alias</b>:addtrustexternalca<br /> <b>Owner DN</b>:CN=AddTrust External CA Root,<br/> OU=AddTrust External TTP Network, O=AddTrust AB, C=SE</li>

<li><b>Alias</b>:addtrustqualifiedca<br /> <b>Owner DN</b>:CN=AddTrust Qualified CA Root,<br/> OU=AddTrust TTP Network, O=AddTrust AB, C=SE</li>

<li><b>Alias</b>:utnuserfirsthardwareca<br /> <b>Owner DN</b>:CN=UTN-USERFirst-Hardware,<br/> OU=http://www.usertrust.com, O=The USERTRUST Network,<br/> L=Salt Lake City, ST=UT, C=US</li>

<li><b>Alias</b>:utnuserfirstclientauthemailca<br /> <b>Owner DN</b>:CN=UTN-USERFirst-Client Authentication and Email,<br/> OU=http://www.usertrust.com, O=The USERTRUST Network,<br/> L=Salt Lake City, ST=UT, C=US</li>

<li><b>Alias</b>:utndatacorpsgcca<br /> <b>Owner DN</b>:CN=UTN - DATACorp SGC,<br/> OU=http://www.usertrust.com, O=The USERTRUST Network,<br/> L=Salt Lake City, ST=UT, C=US</li>

<li><b>Alias</b>:utnuserfirstobjectca<br /> <b>Owner DN</b>:CN=UTN-USERFirst-Object,<br/> OU=http://www.usertrust.com, O=The USERTRUST Network,<br/> L=Salt Lake City, ST=UT, C=US</li>
            </ul>


<p>cacerts 키스토어파일의 초기 패스워드는, changeit 입니다. 시스템 관리 책임자는, SDK 의 인스톨 후, 이 파일의 패스워드와 디폴트 액세스권을 변경할 필요가 있습니다.


</p><blockquote>
<hr />
<b>중요:<code>cacerts</code> 파일을 확인해 주세요. </b> <br /><code>cacerts</code> 파일내의 CA 는, 서명 및 다른 엔티티에의 증명서 발행을 위한 엔티티로서 신뢰되기 (위해)때문에,<code>cacerts</code> 파일의 관리는 신중하게 실시할 필요가 있습니다. <code>cacerts</code> 파일에는, 신뢰하는 CA 의 증명서만이 포함되지 않으면 안됩니다. 사용자는, 자신의 책임에 대해,<code>cacerts</code> 파일에 번들 되고 있는 신뢰할 수 있는 루트 CA 증명서를 검증해, 신뢰성에 관한 독자적인 결정을 실시합니다. 신뢰할 수 없는 CA 증명서를 <code>cacerts</code> 파일로부터 삭제하려면 ,<code>keytool</code> 커멘드의 삭제 옵션을 사용합니다. <code>cacerts</code> 파일은 JRE 의 인스톨 디렉토리에 있습니다. 이 파일을 편집하는 액세스권이 없는 경우는, 시스템 관리 책임자에 연락해 주세요.  <br />
<hr />
</blockquote>
</blockquote>


<a name="EncodeCertificate"></a> 
</li><li><h4>인터넷 RFC 1421 증명서 encode 규격</h4>

<blockquote>

<p>많은 경우, 증명서는, 바이너리 encode는 아니고, 인터넷 RFC 1421 규격으로 정의되고 있는 출력 가능 encode 방식을 사용해 포함됩니다. 「Base 64 encode」라고도 불리는 이 증명서 형식에서는, 전자 메일이나 그 외의 기구를 통해서, 다른 어플리케이션에 증명서를 용이하게 export 할 수 있습니다.

</p><p><code>-importcert</code> 커멘드와 <code>-printcert</code> 커멘드에서는, 이 형식의 증명서와 바이너리 encode의 증명서를 읽어들일 수가 있습니다.

</p><p><code>-exportcert</code> 커멘드에서는, 디폴트로 바이너리 encode의 증명서가 출력됩니다. 다만,<code>-rfc</code> 옵션을 지정했을 경우는, 출력 가능 encode 방식의 증명서가 출력됩니다.

</p><p><code>-list</code> 커멘드에서는, 디폴트로 증명서의 MD5 지문이 출력됩니다. <code>-v</code> 옵션을 지정하면(자), 인간이 읽을 수 있는 형식에서 증명서가 출력됩니다.  한편,<code>-rfc</code> 옵션을 지정하면(자), 출력 가능 encode 방식에서 증명서가 출력됩니다.

</p><p>출력 가능 encode 방식에서 encode 된 증명서는, 다음의 행으로 시작됩니다.

</p><pre>-----BEGIN CERTIFICATE-----
</pre>

<p>최후는, 다음의 행으로 끝납니다.

</p><pre>-----END CERTIFICATE-----
</pre>

</blockquote>

</li></ul>

<a name="DName"></a> 
<h3>X. 500 식별명</h3>

<blockquote>

X. 500 식별명은, 엔티티를 특정하기 위해서 사용됩니다.  예를 들어, X. 509 증명서의 <code>subject</code> 필드와 <code>issuer</code> (서명자) 필드에서 지정되는 이름은, X. 500 식별명입니다. <b> keytool</b> 는, 다음의 서브파트를 지원하고 있습니다.

<ul>

<li><i>commonName</i> - 인의 통칭.  「Susan Jones」 등<p>

</p></li><li><i>organizationUnit</i> - 작은 조직 (부, 과등)의 명칭.  「구입부」 등<p>

</p></li><li><i>organizationName</i> - 큰 조직의 명칭.  「ABCSystems, Inc.」 등<p>

</p></li><li><i>localityName</i> - 지역 (도시) 명.  「Palo Alto」 등<p>

</p></li><li><i>stateName</i> - 주명 또는 지방명.  「California」 등<p>

</p></li><li><i>country</i> - 2 문자의 나라 번호.  「CH」 등<p>

</p></li></ul>

<p><code>-genkeypair</code> <!--or <code>-selfcert</code--> 커멘드<!--s-->의 <code>-dname</code> 옵션의 값으로 해서 식별 명문자열을 지정하는 경우는, 다음의 형식에서 지정할 필요가 있습니다.

</p><pre>CN=<i>cName</i>, OU=<i>orgUnit</i>, O=<i>org</i>, L=<i>city</i>, S=<i>state</i>, C=<i>countryCode</i>
</pre>

<p>이탤릭체의 항목은, 실제로 지정하는 값을 나타냅니다.  단축형의 키워드의 의미는, 다음과 같습니다.

</p><pre>	CN=commonName
	OU=organizationUnit
	O=organizationName
	L=localityName
	S=stateName
	C=country
</pre>

<p>다음에 나타내는 것은, 식별 명문자열의 예입니다.

</p><pre>CN=Mark Smith, OU=JavaSoft, O=Sun, L=Cupertino, S=California, C=US
</pre>

다음은, 이 캐릭터 라인을 사용한 커멘드의 예입니다.

<pre>keytool -genkeypair -dname "CN=Mark Smith, OU=JavaSoft, O=Sun, L=Cupertino,
S=California, C=US" -alias mark
</pre>

<p>키워드의 단축형에서는, 대문자와 소문자는 구별되지 않습니다. 예를 들어, CN, cn, 및 Cn 는, 모두 같은 것으로서 다루어집니다.

</p><p>한편, 키워드의 지정 순서에는 의미가 있어, 각 서브 컴퍼넌트는 위에 나타낸 순서로 지정할 필요가 있습니다. 다만, 서브 컴퍼넌트를 모두 지정할 필요는 없습니다. 예를 들어, 다음과 같이 일부의 서브 컴퍼넌트만을 지정할 수 있습니다.

</p><pre>CN=Steve Meier, OU=SunSoft, O=Sun, C=US
</pre>

<p>식별 명문자열의 값에 콤마가 포함되는 경우에, 커멘드행으로 캐릭터 라인을 지정할 경우에는, 다음과 같이 콤마를 문자 \ 로 이스케이프 할 필요가 있습니다.

</p><pre>   cn=peter schuster, o=Sun Microsystems\, Inc., o=sun, c=us
</pre>

<p>식별 명문자열을 커멘드행으로 지정할 필요는 없습니다. 식별명을 필요로 하는 커멘드를 실행할 경우에, 커멘드행으로 식별명을 지정하지 않았던 경우는, 각 서브 컴퍼넌트의 입력이 요구됩니다. 이 경우는, 콤마를 문자 \ 로 이스케이프 할 필요는 없습니다.
</p></blockquote>


<a name="TrustedCertWarning"></a> 
<h3>신뢰할 수 있는 증명서의 임포트에 관한 주의 사항</h3>

<blockquote>

중요:신뢰할 수 있는 증명서로서 증명서를 임포트 하기 전에, 증명서의 내용을 신중하게 조사해 주세요.

<p>우선, 증명서의 내용을 표시해 (<code>-printcert</code> 커멘드를 사용하는지, 또는 <code>-noprompt</code> 옵션을 지정하지 말아줘 <code>-import</code> 커멘드를 사용), 표시된 증명서의 지문이, 기대되는 지문과 일치할지 어떨지를 확인합니다. 예를 들어, 어느 사용자로부터 증명서가 보내져 와, 이 증명서를 <code>/tmp/cert</code> 라는 이름으로 파일에 포함하고 있다고 합니다. 이 경우는, 신뢰할 수 있는 증명서의 리스트에 이 증명서를 추가하기 전에,<code>-printcert</code> 커멘드를 실행해 지문을 표시할 수 있습니다.  예를 들어, 다음과 같이 합니다.

</p><pre>  keytool -printcert -file /tmp/cert
    Owner: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
    Issuer: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
    Serial Number: 59092b34
    Valid from: Thu Sep 25 18:01:13 PDT 1997 until: Wed Dec 24 17:01:13 PST 1997
    Certificate Fingerprints:
         MD5:  11:81:AD:92:C8:E5:0E:A2:01:2E:D4:7A:D7:5F:07:6F
         SHA1: 20:B6:17:FA:EF:E5:55:8A:D0:71:1F:E8:D6:9D:C0:37:13:0E:5E:FE
</pre>

다음에, 증명서를 송신한 인물에게 연락해, 이 인물이 제시한 지문과 위의 커멘드로 표시된 지문을 비교합니다. 지문이 일치하면, 송신 도중에 다른 누군가 (공격자등)에 의한 증명서의 바꿔치기를 하지 않은 것을 확인할 수 있습니다. 송신 도중에 이런 종류의 공격을 하고 있었을 경우, 체크를 실시하지 않고 증명서를 임포트 하면(자), 공격자에 의해 서명된 모든 것 (공격적 의도를 가지는 클래스 파일을 포함한 JAR 파일등)을 신뢰하게 됩니다.

<p>주:증명서를 임포트 하기 전에 반드시 <code>-printcert</code> 커멘드를 실행해야 하는 것은 아닙니다. 키스토어내의 신뢰할 수 있는 증명서의 리스트에 증명서를 추가하기 전에 <code>-importcert</code> 커멘드를 실행하면(자), 증명서의 정보가 표시되어 확인을 요구하는 메세지가 표시됩니다. 임포트 조작은, 이 시점에서 중지할 수 있습니다. 다만, 확인 메세지가 표시되는 것은,<code>-importcert</code> 커멘드를 <code>-noprompt</code> 옵션을 지정하지 않고 실행했을 경우만입니다. <code>-noprompt</code> 옵션이 지정되고 있는 경우, 사용자와의 대화는 행해지지 않습니다.

</p></blockquote>


<a name="PasswordWarning"></a> 
<h3>패스워드에 관한 주의 사항</h3>

<blockquote>

<p>키스토어에 대한 조작을 실시하는 대부분의 커멘드에서는, 스토어의 패스워드가 필요합니다. 또, 일부의 커멘드에서는, 비공개/비밀열쇠의 패스워드가 필요하게 되는 일이 있습니다.

</p><p>패스워드는 커멘드행으로 지정할 수 있습니다 (스토어의 패스워드에는 <code>-storepass</code> 옵션, 비공개키의 패스워드에는 <code>-keypass</code> 옵션을 사용). 다만, 테스트를 목적으로 하는 경우, 또는 안전하다라고 하는 것이 알고 있는 시스템으로 실행하는 경우 이외는, 커멘드행이나 스크립트로 패스워드를 지정하지 말아 주세요.

</p><p>필요한 패스워드의 옵션을 커멘드행으로 지정하지 않았던 경우는, 패스워드의 입력이 요구됩니다.
</p></blockquote>


</blockquote>

<h2><a name="SeeAlso">관련 항목</a> </h2>

<blockquote>

<ul>

<li><a href="http://java.sun.com/javase/6/docs/tooldocs/solaris/jar.html">jar</a>  툴의 문서<p>

</p></li><li><a href="http://java.sun.com/javase/6/docs/tooldocs/solaris/jarsigner.html">jarsigner</a>  툴의 문서<p>

</p></li><li><b>keytool</b> 의 사용예는,<a href="http://java.sun.com/docs/books/tutorial/"><b>「Java 튜토리얼」</b></a> 의<a href="http://java.sun.com/docs/books/tutorial/security/index.html"><b>「Security」</b></a> 를 참조

</li></ul>

</blockquote>


<h2><a name="Changes">변경점</a> </h2>
<blockquote>
<p>Java SE 6 으로 keytool 의 커멘드 인터페이스가 변경되었습니다. </p>
<p><b>keytool</b> 는, 사용자가 패스워드를 입력할 때에 그 입력 내용을 표시하지 않게 되었습니다. 사용자는 패스워드 입력시에 그 입력 내용을 확인할 수 없게 되었기 때문에, 초기 키스토어파스워드를 설정하거나 열쇠 패스워드를 변경하거나 하는 등, 패스워드의 설정이나 변경을 실시할 때마다 패스워드의 재입력이 요구됩니다. </p>
<p>변경된 커멘드안에는, 이름이 변경되었을 뿐의 것도 있으면, 폐지되어 이 문서에 기재되지 않게 된 것도 있습니다. 이전의 모든 커멘드 (이름이 변경된 것과 폐지된 것의 양쪽 모두)는, 이 릴리스에서도 계속해 지원되고 있어 향후의 릴리스에서도 지원될 예정입니다. keytool 의 커멘드 인터페이스에 더해진 모든 변경점의 개요를, 다음에 나타냅니다.
</p>
<p>이름이 변경된 커멘드:
</p><ul>
<li><code>-export</code> 의 이름이 <a href="#exportCertCmd"><code>-exportcert</code></a>  로 변경</li>
<li><code>-genkey</code> 의 이름이 <a href="#genkeypairCmd"><code>-genkeypair</code></a>  로 변경</li>
<li><code>-import</code> 의 이름이 <a href="#importCertCmd"><code>-importcert</code></a>  로 변경</li>
</ul>
<p>폐지되어 문서에 기재되지 않게 된 커멘드:
</p><ul>
<li><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/keytool.html#keycloneCmd"><code>-keyclone</code></a> </li>
<li><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/keytool.html#identitydbCmd"><code>-identitydb</code></a> </li>
<li><a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/keytool.html#selfcertCmd"><code>-selfcert</code></a> </li>
</ul>
</blockquote>




<hr size="3" noshade="noshade" />

<table border="0" width="100%" summary="layout">
<tbody><tr valign="top">
<td>
<p><font size="-2"><a href="../../../legal/SMICopyright.html">Copyright</a>  &copy; 2002-2006 <a href="http://www.sun.com/">Sun Microsystems, Inc. </a> All Rights Reserved. </font></p>
</td>
<td align="right">
<img src="../../../tooldocs/windows/keytool_files/sunlogo64x30.gif" alt="Sun" border="0" width="64" height="30" /> <br /> <font size="+1"><i>Java Software </i></font>
</td>
</tr>
</tbody></table>


</body></html>
