<html>
<head>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">

<title>  - xrath.com 에서 번역됨</title>
<!-- ===== ==== -->

<!-- ==== sandbox for notes  ==== --> <!--  <!--PPP *************************  -->


<!-- ==== css stylesheet below ==== -->

<style type="text/css">

    p {
    font-family: serif;
    font-size: medium;

    margin-top: 18pt;
    margin-bottom: 18pt;
    margin-left: 24pt;
    margin-right: 0pt;
    padding-left: 0pt;
    padding-right: 0pt;
    }


    li {
    font-family: serif;
    font-size: medium;

    margin-top: 3pt;
    margin-bottom: 9pt;
    margin-left: 24pt;
    margin-right: 0pt;
    padding-left: 0pt;
    padding-right: 0pt;
    }

    li li {margin-left: 42pt}

    table {margin-left: 24pt}

    code, tt {
	  font-family: monospace;
		font-size: 115%;
		font-weight: bold;
	  color: black;
    }
    pre {
	  font-family: monospace;
		font-size: 115%;
		font-weight: bold;
	  color: black;
		margin-left: 30pt;
    }

    . changebar {border-right: 5px solid red}

    h1 {
	font-size: 150%;
	font-weight: bold ;
	   font-family: serif;

	   margin-top: 36pt;
	margin-bottom: 16pt;
	margin-left: 0pt;
	margin-right: 0pt;
    }

    h2 {font-size: 120%;
	font-weight: 400;
	   font-family: serif;

	   margin-top: 30pt;
	margin-bottom: 12pt;
	margin-left: 24pt;
	margin-right: 0pt;}

    h3 {font-size: medium ;
       font-weight: bold;
	  font-family: sans-serif;
	  margin-top: 18pt;
       margin-bottom: 9pt;
       margin-left: 24pt;
       margin-right: 0pt;}

    h4 {font-size: medium ;
       font-weight: bold;
	  font-style: italic;
	  font-family: sans-serif;
	  margin-top: 9pt;
       margin-bottom: 6pt;
       margin-left: 30pt;
       margin-right: 0pt;}


    . green  {color: #006600;
	     font-weight: bold}

    . red    {color: red}
    . blue   {color: blue }
    . brown  {color: brown}

    . ind1 {margin-left: 16pt }
    . ind2 {margin-left: 32pt }
    . ind3 {margin-left: 44pt }

     . tocx {
       margin-top: 12pt;
       margin-bottom: 6pt;
       margin-left:  0pt;
       margin-right: 0pt;
	  }
    . toc {
       margin-top: 4pt;
       margin-bottom: 4pt;
       margin-left: 24pt;
       margin-right: 0pt;
	  font-size: 100%;
	  font-family: helvetica;
	  font-weight: bold;
	  }

    . toc2 {
       margin-top: 3pt;
       margin-bottom: 3pt;
       margin-left: 36pt;
       margin-right: 0pt;
	  }

    . large {font-size: 18pt}

</style>

<!-- ==== javascript below ==== -->
<script type="text/javascript">

</script>


</head>


<!-- ==================================================== -->
<body>

<hr>

<center>
<H1>
Java<!--<font size=-1><sup>TM</sup></font> --> &trade; 암호화 아키텍쳐(architecture) 표준 알고리즘명의 문서<br>
</H1>
<h2>Java<sup><font size="-2">TM</font></sup> Platform Standard Edition 6</h2>

</center>

<hr>

<center><h1>목차</h1></center>

<h1><a href="#provider">표준명</a> </h1>

<h2 class="toc"><a href="#AlgorithmParameterGenerator"><code>AlgorithmParameterGenerator</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#AlgorithmParameters"><code>AlgorithmParameters</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#CertificateFactory"><code>CertificateFactory</code> 타입</a> </h2>

<h2 class="toc"><a href="#CertPathBuilder"><code>CertPathBuilder</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#CertPathEncodings">CertPath encode</a> </h2>

<h2 class="toc"><a href="#CertPathValidator"><code>CertPathValidator</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#CertStore"><code>CertStore</code> 타입</a> </h2>

<h2 class="toc"><a href="#Cipher"><code>Cipher</code> (암호화) 알고리즘</a> </h2>

<h2 class="toc"><a href="#Configuration"><code>Configuration</code> 타입</a> </h2>

<h2 class="toc"><a href="#Exemption">면책 기구</a> </h2>

<h2 class="toc"><a href="#GSSAPI">GSSAPI 기구</a> </h2>

<h2 class="toc"><a href="#KeyAgreement"><code>KeyAgreement</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#KeyFactory"><code>KeyFactory</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#KeyGenerator"><code>KeyGenerator</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#KeyPairGenerator"><code>KeyPairGenerator</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#KeyStore"><code>KeyStore</code> 타입</a> </h2>

<h2 class="toc"><a href="#Mac"><code>Mac</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#MessageDigest"><code>MessageDigest</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#Policy"><code>Policy</code> 타입</a> </h2>

<h2 class="toc"><a href="#SaslClient"><code>SaslClient</code> 기구</a> </h2>

<h2 class="toc"><a href="#SaslServer"><code>SaslServer</code> 기구</a> </h2>

<h2 class="toc"><a href="#SecretKeyFactory"><code>SecretKeyFactory</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#SecureRandom"><code>SecureRandom</code> 난수 생성 (RNG) 알고리즘</a> </h2>

<h2 class="toc"><a href="#Service">서비스 속성</a> </h2>

<h2 class="toc"><a href="#Signature"><code>Signature</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#SSLContext"><code>SSLContext</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#TrustManagerFactory"><code>TrustManagerFactory</code> 알고리즘</a> </h2>

<h2 class="toc"><a href="#XMLSignature">XML 서명 (<code>XMLSignatureFactory</code>/<code>KeyInfoFactory</code>/<code>TransformService)</code> 기구</a> </h2>

<h2 class="toc"><a href="#TransformService">XML 서명 변환 (<code>TransformService</code>) 알고리즘</a> </h2>

<h2 class="toc"><a href="#jssenames">추가의 JSSE 표준명</a> </h2>


<h1><a href="#alg">알고리즘</a> </h1>

<h2 class="toc"><a href="#spectemp">스펙 템플릿</a> </h2>

<h2 class="toc"><a href="#algspec">알고리즘의 스펙</a> </h2>


<h1><a href="#impl">구현 요건</a> </h1>

<br>

<hr>
<p>
<b>주:</b> 특정의 프로바이더 및 알고리즘의 정보는,<a href="SunProviders.html">「Sun Provider Documentation」</a>에 있습니다.
</p>
<hr>

<bblockquote>

<a name="provider">
<h1>표준명</h1></a> 

<p>JDK Security API 는, 다양한 알고리즘, 증명서, 및 키스토어의 타입의 표준명을 필요로 해, 이것들을 사용합니다. 여기에 기재의 스펙은, 표준명으로서 이하의 이름을 확립하는 것입니다. </p>

<p>경우에 따라서는, 복수의 프로바이더의 구현에 걸쳐서 이름의 일관성을 유지할 수 있도록(듯이), 명시적으로 기재되지 않은 이름의 명명 규약이 제안되는 일이 있습니다. 산괄호로 둘러싸인 항목 (<code>&lt;digest&gt;</code>,<code>&lt;encryption&gt;</code> 등)은, 특정의 메세지 다이제스트, 암호화 알고리즘, 또는 그 외의 이름으로 옮겨놓기 위한 플레이스홀더입니다.

</p><bblockquote>
<hr style="margin-left: 24pt; margin-top: 12pt;margin-bottom: 3pt;">
<p style="margin-bottom: 9pt; margin-top: 9pt;"><b>주:</b> 표준명의 대문자와 소문자는 구별되지 않습니다. </p>
<hr style="margin-left: 24pt; margin-top: 3pt;margin-bottom: 12pt;">
</bblockquote>

<p>이 문서에는, 다음의 시큐리티의 서브 영역에 관련하는 표준명의 대응 일람이 기재되어 있습니다.

<ul>
<li><a href="certpath/CertPathProgGuide.html"><b>Java PKI 개발자 안내</b></a> 

</li>

<li><a href="jsse/JSSERefGuide.html"><b>JSSE 레퍼런스 가이드</b></a> 
</li>

<li>표준명의 스펙에 대해서는,<a href="#alg">「알고리즘」</a>을 참조해 주세요. </li>

<LI><a href="crypto/CryptoSpec.html"><b>Java 암호화 아키텍쳐(architecture) API 의 스펙 및 레퍼런스</b></a> 


<LI><a href="jgss/tutorials/index.html"><b>Kerberos 를 사용한 Java 의 싱글 싸인온</b></a> 

<LI><a href="sasl/sasl-refguide.html"><B>Java SASL API 프로그래밍 및 배치 가이드</B></A> 

<LI><a href="xmldsig/overview.html"><B>XML 디지털 서명 API 스펙</B></A> 

</ul>

<!-- ==================================================== -->
</p>
<a name="AlgorithmParameterGenerator">
<h2><code>AlgorithmParameterGenerator</code> 알고리즘 </h2></a> 

<bblockquote>

<p>
이 항의 알고리즘명은,<code>AlgorithmParameterGenerator</code> 의 인스턴스의 생성시로 지정할 수 있습니다.

</p></bblockquote>

<table align="center" border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	DiffieHellman
    </td>
    <td>
	Diffie-Hellman 알고리즘과 함께 사용하는 파라미터.
    </td>
</tr>
<tr>
    <td>
	DSA
    </td>
    <td>
	디지털 서명 알고리즘과 함께 사용하는 파라미터.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="AlgorithmParameters">
<h2><code>AlgorithmParameters</code> 알고리즘</h2></a> 

<bblockquote>

<p>
이 항의 알고리즘명은,<code>AlgorithmParameters</code> 의 인스턴스의 생성시로 지정할 수 있습니다.

</p></bblockquote>

<table align="center" border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	AES
    </td>
    <td>
	AES 알고리즘과 함께 사용하는 파라미터.
    </td>
</tr>
<tr>
    <td>
	Blowfish
    </td>
    <td>
	Blowfish 알고리즘과 함께 사용하는 파라미터.
    </td>
</tr>
<tr>
    <td>
	DES
    </td>
    <td>
	DES 알고리즘과 함께 사용하는 파라미터.
    </td>
</tr>
<tr>
    <td>
	DESede
    </td>
    <td>
	DESede 알고리즘과 함께 사용하는 파라미터.
    </td>
</tr>
<tr>
    <td>
	DiffieHellman
    </td>
    <td>
	DiffieHellman 알고리즘과 함께 사용하는 파라미터.
    </td>
</tr>
<tr>
    <td>
	DSA
    </td>
    <td>
	디지털 서명 알고리즘과 함께 사용하는 파라미터.
    </td>
</tr>
<tr>
    <td>
	OAEP
    </td>
    <td>
	OAEP 알고리즘과 함께 사용하는 파라미터.
    </td>
</tr>
<tr>
    <td>
	PBEWith&lt;digest&gt;And&lt;encryption&gt;
    </td>
    <td>
	PBEWith&lt;digest&gt;And&lt;encryption&gt; 알고리즘과 함께 사용하는 파라미터. 예:<b>PBEWithMD5AndDES</b>,<b>PBEWithHmacSHA1AndDESede</b>.
    </td>
</tr>
<tr>
    <td>
	PBE
    </td>
    <td>
	PBE 알고리즘과 함께 사용하는 파라미터. <i>상기의 것보다 구체적인 PBE 알고리즘명에 우선해 이 이름을 사용하지 말아 주세요. </i>
    </td>
</tr>
<tr>
    <td>
	RC2
    </td>
    <td>
	RC2 알고리즘과 함께 사용하는 파라미터.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="CertificateFactory">
<h2><code>CertificateFactory</code> 타입</h2></a> 

<bblockquote> 

<p>
이 항의 알고리즘명은,<code>CertificateFactory</code> 의 인스턴스의 생성시로 지정할 수 있습니다.
</p><p>

</p></bblockquote>
<table align="center" border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 형 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	X. 509
    </td>
    <td>
	X. 509 에 정의되고 있는 증명서의 타입. <a href="http://www.ietf.org/rfc/rfc3280.txt">RFC 3280</a>  으로부터도 입수 가능
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="CertPathBuilder">
<h2><code>CertPathBuilder</code> 알고리즘</h2></a> 

<bblockquote>

<p>
이 항의 알고리즘명은,<code>CertPathBuilder</code> 의 인스턴스의 생성시로 지정할 수 있습니다.
</p><p>

</p></bblockquote>
<table align="center" border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tr>
    <td>
	PKIX
    </td>
    <td>
	<a href="#Service">ValidationAlgorithm 서비스 속성</a>으로 정의되고 있는 PKIX 증명서 패스의 검증 알고리즘. 이 알고리즘을 구현하고 있는 <code>CertPathBuilder</code> 인스턴스의 출력은, PKIX 검증 알고리즘에 따라 검증된 증명서 패스입니다.
    </td>
<tbody>
</table>

<!-- ==================================================== -->

<a name="CertPathEncodings">
<h2>CertPath encode</h2></a> 

<bblockquote>

<p>
다음의 encode는,<code>CertPath</code> 의 <code>getEncoded</code> 메소드 또는 <code>CertificateFactory</code> 의 <code>generateCertPath(InputStream inStream, String encoding)</code> 메소드에 건네줄 수가 있습니다.
</p><p>

</p></bblockquote>
<table align="center" border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> encode</th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tr>
    <td>
	PKCS7
    </td>
    <td>
	증명서의 중요한 필드만을 가지는 PKCS#7 SignedData 객체. 특히, 서명 및 내용은 무시됩니다. 증명서가 존재하지 않는 경우, 길이가 0 의 <code>CertPath</code> 이다고 보입니다. 경고 :PKCS#7 에서는, 증명서 패스내의 증명서의 순서는 유지되지 않습니다. 따라서,<code>CertPath</code> 가 PKCS#7 로 encode 된 바이트에 변환되고 나서, 바탕으로 되돌려졌을 경우, 증명서의 순서가 변경되거나<code>CertPath</code> 가 무효가 되는 경우가 있습니다. 사용자는, 이 동작을 알아 둘 필요가 있습니다. PKCS7 의 자세한 것은,<a 	href="http://www.rsasecurity.com/rsalabs/pkcs">「RSA Security」</a>를 참조해 주세요.
    </td>

</tr>
<tr>
    <td>
	PkiPath
    </td>
    <td>
	ASN 1 DER 로 encode 된 증명서의 순서. 다음과 같이 정의됩니다.

	<pre>    PkiPath ::= SEQUENCE OF Certificate</pre>

	순서내에서, 증명서는, 최초의 증명서의 주체가 2 번째의 증명서의 발행원이라고 하는 것 같은 순서가 됩니다. <code>PkiPath</code> 내의 각 증명서는 일의입니다. 어느 증명서도,<code>PkiPath</code> 내의 <code>Certificate</code> 의 값에 1 회씩 나타납니다. <code>PkiPath</code> 형식은, X. 509 (2000)에 대한 결함 리포트 279 내에서 정의되고 있어 ITU-T Recommendation X. 509 (2000)의 Technical Corrigendum 1 (DTC 2)에 짜넣어지고 있습니다. 자세한 것은,<a href="http://www.itu.int/rec/T-REC-X.509/en">ITU 의 Web 사이트</a>를 참조해 주세요.
    </td>
</tr>
<tbody>
</table>

<!-- ==================================================== --> <a name="CertPathValidator">
<h2><code>CertPathValidator</code> 알고리즘</h2></a> 

<bblockquote>

<p>
이 항의 알고리즘명은,<code>CertPathValidator</code> 의 인스턴스의 생성시로 지정할 수 있습니다.

</p><p>

</p></bblockquote>
<table align="center" border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tr>
    <td>
	PKIX
    </td>
    <td>
	<a href="#Service">ValidationAlgorithm 서비스 속성</a>으로 정의되고 있는 PKIX 증명서 패스의 검증 알고리즘.
    </td>
<tbody>
</table>

<!-- ==================================================== -->

<a name="CertStore">
<h2><code>CertStore</code> 타입</h2></a> 

<bblockquote>

<p>
이 항의 타입은,<code>CertStore</code> 의 인스턴스의 생성시로 지정할 수 있습니다.
</p><p>

</p></bblockquote>
<table align="center" border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 형 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tr>
    <td>
	Collection
    </td>
    <td>
	증명서 및 CRL 를 <code>Collection</code> 로부터 취득하는 <code>CertStore</code> 구현입니다. 이 타입의 <code>CertStore</code> 는, 서명 첨부 메일 메세지나 SSL 협상 등, 가방 또는 어떤 종류의 첨부 파일로 증명서 또는 CRL 를 수신하는 어플리케이션으로 특히 유용합니다.
    </td>
</tr>
<tr>
    <td>
	LDAP
    </td>
    <td>
	<a href="#Service">LDAPSchema 서비스 속성</a>에 정의되고 있는 방식을 사용해, 증명서 및 CRL 를 LDAP 디렉토리로부터 페치 하는 <code>CertStore</code> 구현입니다.
    </td>
<tbody>
</table>

<!-- ==================================================== -->

<a name="Cipher">
<h2><code>Cipher</code> (암호화) 알고리즘</h2></a>  <bblockquote>

<!-- ==================================================== -->

<h3>Cipher 알고리즘명</h3>
    <bblockquote>
<p><code>Cipher</code> 의 인스턴스를 요구하는 경우, 다음의 이름을<a href="crypto/CryptoSpec.html#trans">변환</a>내의 <i>algorithm</i> 컴퍼넌트로서 지정할 수 있습니다.  </p>

    </bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	AES
    </td>
    <td>
	NIST 에 의해 <a href="http://csrc.nist.gov/publications/fips/index.html">FIPS 197</a>  으로 지정되고 있는 Advanced Encryption Standard. Joan Daemen, Vincent Rijmen 두사람에 의한 Rijndael 알고리즘이라고도 불리고 있습니다. AES 는 128 비트의 블록 암호이며, 128 비트, 192 비트, 256 비트의 열쇠를 지원합니다.
    </td>
</tr>
<tr>
    <td>
	AESWrap
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc3394.txt">RFC 3394</a>  에 설명되고 있는 AES 열쇠 랩핑 알고리즘.
    </td>
</tr>
<tr>
    <td>
	ARCFOUR
    </td>
    <td>
	Ron Rivest 가 개발한 RC4 암호와 완전하게 상호 운용 가능한 스트림 암호. 상세한 것에 대하여는, K.  Kaukonen, R.  Thayer 저 「A Stream Cipher Encryption Algorithm 'Arcfour'」, Internet Draft (expired),<a href= 	"http://www.mozilla.org/projects/security/pki/nss/draft-kaukonen-cipher-arcfour-03.txt">draft-kaukonen-cipher-arcfour-03.txt</a>  를 참조
    </td>
</tr>
<tr>
    <td>
	Blowfish
    </td>
    <td>
	Bruce Schneier 씨의 설계에 의한 <a href="http://www.schneier.com/blowfish.html">Blowfish 블록 암호</a> .
    </td>
</tr>
<tr>
    <td>
	DES
    </td>
    <td>
	<a href="http://csrc.nist.gov/publications/fips/index.html">FIPS PUB 46-3</a>  로 정의되고 있는 데이터 암호화 규격.
    </td>
</tr>
<tr>
    <td>
	DESede
    </td>
    <td>
	트리플 DES 암호화 (DES-EDE, 3 DES, 또는 트리플 DES 라고도 불립니다). 데이터는, DES 알고리즘을 개별적으로 3 회 사용해 암호화됩니다. 데이터는, 최초의 서브열쇠를 사용해 암호화되어 다음에 2 번째의 서브열쇠를 사용해 복호화 된 뒤, 3 번째의 서브열쇠를 사용해 암호화됩니다.
    </td>
</tr>
<tr>
    <td>
	DESedeWrap
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc3217.txt">RFC 3217</a>  에 설명되고 있는 DESede 열쇠 랩핑 알고리즘.
    </td>
</tr>
<tr>
    <td>
	ECIES
    </td>
    <td>
	Elliptic Curve Integrated Encryption Scheme
    </td>
</tr>
<tr>
    <td>
	PBEWith&lt;digest&gt;And&lt;encryption&gt; PBEWith&lt;prf&gt;And&lt;encryption&gt;
    </td>
    <td>
	PKCS 5 에 있는 패스워드 베이스의 암호 알고리즘. 지정된 메세지 다이제스트 (&lt;digest&gt;) 또는 의사 암호 함수 (&lt;prf&gt;), 암호화 알고리즘 (&lt;encryption&gt;)을 사용합니다. 례:
	<ul>
	    <li><b>PBEWithMD5AndDES</b> -<a 		href="http://www.rsasecurity.com/rsalabs/pkcs">1993 년 11 월, RSA Laboratories 의 「PKCS5: Password-Based Encryption Standard」버젼 1.5</a>  에 정의된 패스워드 베이스의 암호화 알고리즘. 이 알고리즘에서는,<a href="#cbcMode">CBC</a>  는 암호 모드,<a href="#pkcs5Pad">PKCS5Padding</a>  는 패딩 방식으로 되어 있습니다. 다른 암호 모드나 패딩 방식에서 사용할 수 없습니다.
	    </li>
	    <li><b>PBEWithHmacSHA1AndDESede</b> -<a 		href="http://www.rsasecurity.com/rsalabs/pkcs">1999 년 3 월, RSA Laboratories 의 「PKCS5: Password-Based Encryption Standard」버젼 2.0</a>  에 정의된 패스워드 베이스의 암호화 알고리즘.
	    </li>
	</ul>
    </td>
</tr>
<tr>
    <td>
	RC2
    </td>
    <td>
	RSA Data Security, Inc 의 Ron Rivest 에 의해 개발된 가변 키 사이즈 암호화 알고리즘입니다.
    </td>
</tr>
<tr>
    <td>
	RC4
    </td>
    <td>
	RSA Data Security, Inc 의 Ron Rivest 에 의해 개발된 가변 키 사이즈 암호화 알고리즘. 상기의 ARCFOUR 에 관한 주를 참조해 주세요.
    </td>
</tr>
<tr>
    <td>
	RC5
    </td>
    <td>
	RSA Data Security, Inc 의 Ron Rivest 에 의해 개발된 가변 키 사이즈 암호화 알고리즘입니다.
    </td>
</tr>
<tr>
     <td>
	RSA
    </td>

    <td>
	<a href="http://www.rsasecurity.com/rsalabs/pkcs">PKCS1</a>  로 정의되고 있는 RSA 암호화 알고리즘
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<h3>Cipher 알고리즘 모드</h3></a>  <bblockquote>
<p><code>Cipher</code> 의 인스턴스를 요구하는 경우, 다음의 이름을<a href="crypto/CryptoSpec.html#trans">변환</a>내의 모드 컴퍼넌트로서 지정할 수 있습니다.  </p>
    </bblockquote>


<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="90%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	NONE
    </td>
    <td>
	모드 없음
    </td>
</tr>
<tr>
    <td>
	<a name="cbcMode">CBC</a> 
    </td>
    <td>
	<a 	href="http://csrc.nist.gov/publications/fips/index.html">FIPS PUB 81</a>  으로 정의된 Cipher Block Chaining Mode.
    </td>
</tr>
<tr>
    <td>
	CFB, CFBx
    </td>
    <td>
	<a 	href="http://csrc.nist.gov/publications/fips/index.html">FIPS PUB 81</a>  으로 정의된 Cipher Feedback Mode. <br><br>CFB 나 OFB 등의 모드를 사용하면(자), 블록 암호는 암호의 실제의 블록 사이즈보다 작은 단위로 데이터를 암호화할 수 있습니다. 이러한 모드를 요구하는 경우, 「DES/CFB8/NoPadding」 및 「DES/OFB32/PKCS5Padding」변환에 나타나도록(듯이), 이 수치를 모드명에 추가하는 것으로써, 한 번에 처리하는 비트수를 옵션으로 지정할 수 있습니다. 수치를 지정하지 않는 경우, 프로바이더 고유의 디폴트가 사용됩니다 예를 들어, SunJCE 프로바이더에서는 디폴트의 DES 의 64 비트가 사용됩니다. 따라서, 블록 암호는, CFB8 나 OFB8 등의 8 비트 모드를 사용해, 바이트 지향의 스트림 암호로 변환할 수 있습니다.
    </td>
</tr>
<tr>
    <td>
	CTR
    </td>
    <td>
	OFB 를 단순화 한 것. Counter 모드는, 카운터로서 입력 블록을 갱신합니다.
    </td>
</tr>
<tr>
    <td>
	CTS
    </td>
    <td>
	「Applied Cryptography-Second Edition」(Bruce Scheneier 저, John Wiley and Sons 발행, 1996)에 설명되고 있는, Cipher Text Stealing.
    </td>
</tr>
<tr>
    <td>
	ECB
    </td>
    <td>
	<a 	href="http://csrc.nist.gov/publications/fips/index.html">FIPS PUB 81</a>  으로 정의된 Electronic Codebook 모드.
    </td>
</tr>
<tr>
    <td>
	OFB, OFBx
    </td>
    <td>
	<a 	href="http://csrc.nist.gov/publications/fips/index.html">FIPS PUB 81</a>  으로 정의된 Output Feedback Mode. <br><br>CFB 나 OFB 등의 모드를 사용하면(자), 블록 암호는 암호의 실제의 블록 사이즈보다 작은 단위로 데이터를 암호화할 수 있습니다. 이러한 모드를 요구하는 경우, 「DES/CFB8/NoPadding」 및 「DES/OFB32/PKCS5Padding」변환에 나타나도록(듯이), 이 수치를 모드명에 추가하는 것으로써, 한 번에 처리하는 비트수를 옵션으로 지정할 수 있습니다. 수치를 지정하지 않는 경우, 프로바이더 고유의 디폴트가 사용됩니다 예를 들어, SunJCE 프로바이더에서는 디폴트의 DES 의 64 비트가 사용됩니다. 따라서, 블록 암호는, CFB8 나 OFB8 등의 8 비트 모드를 사용해, 바이트 지향의 스트림 암호로 변환할 수 있습니다.
    </td>
</tr>
<tr>
    <td>
	PCBC
    </td>
    <td>
	<a href="http://web.mit.edu/kerberos/">Kerberos V4</a>  로 정의된 Propagating Cipher Block Chaining.
    </td>
</tr>
</tbody>
</table>


<!-- ==================================================== -->
<h3>Cipher 알고리즘 패딩</h3>
    <bblockquote>

<p><code>Cipher</code> 의 인스턴스를 요구하는 경우, 다음의 이름을<a href="crypto/CryptoSpec.html#trans">변환</a>내의 padding 컴퍼넌트로서 지정할 수 있습니다.  </p>

    </bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="90%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	NoPadding
    </td>
    <td>
	패딩 없음
    </td>
</tr>
<tr>
    <td>
	ISO10126Padding
    </td>
    <td>
	이 블록 암호용 패딩은, W3C 의 「XML Encryption Syntax and Processing」문서의 <a 	href="http://www.w3.org/TR/xmlenc-core/#sec-Alg-Block">5.2 Block Encryption Algorithms</a>  에 기재되어 있다
    </td>
</tr>
<tr>
    <td>
	OAEPPadding, OAEPWith&lt;digest&gt;And&lt;mgf&gt;Padding
    </td>
    <td>
	PKCS1 에 정의되고 있는 Optimal Asymmetric Encryption Padding 방식. &lt;digest&gt; 는 메세지 다이제스트, &lt;mgf&gt; 는 마스크 생성 함수로 옮겨놓을 필요가 있습니다. 예:<b>OAEPWithMD5AndMGF1Padding</b> 및 <b>OAEPWithSHA-512AndMGF1Padding</b>. <br><br><code>OAEPPadding</code> 이 사용되는 경우, OAEPPadding 에 필요한 값을 제공하기 위해서,<code>Cipher</code> 객체가 <code>javax.crypto.spec.OAEPParameterSpec</code> 객체에 의해 초기화됩니다.
    </td>
</tr>
<tr>
    <td>
	PKCS1Padding
    </td>
    <td>
	<a href="http://www.rsasecurity.com/rsalabs/pkcs">PKCS1</a>  로 설명되고 있는 패딩 방식. RSA 알고리즘과 함께 사용됩니다.
    </td>
</tr>
<tr>
    <td>
	<a name="pkcs5Pad">PKCS5Padding</a> 
    </td>
    <td>
	<a href="http://www.rsasecurity.com/rsalabs/pkcs">「PKCS5: Password-Based Encryption Standard」버젼 1.5 (RSA Laboratories, 1993 년 11 월)</a>  로 규정된 패딩 방식.
    </td>
</tr>
<tr>
    <td>
	SSL3Padding
    </td>
    <td>
	SSL Protocol 버젼 3.0 의 섹션 5.2. 3.2 (CBC 블록 암호)로 규정된 패딩 방식
<pre>    block-ciphered struct {
	opaque content[SSLCompressed.length];
	opaque MAC[CipherSpec.hash_size];
	uint8 padding[
	    GenericBlockCipher.padding_length];
	uint8 padding_length;
    } GenericBlockCipher;</pre>

	GenericBlockCipher 의 인스턴스의 사이즈는, 블록 암호의 블록장의 배수가 아니면 안됩니다. <br><br>패딩은, 패딩장 (항상 존재)에 영향을 받습니다. 다음의 식이 들어맞는 경우를 생각합시다.

<pre>    sizeof(content) + sizeof(MAC) % block_length = 0, </pre>

	이 경우,<code>padding_length</code> 가 존재하기 위해(때문에), 패딩장을 (block_length - 1) 바이트로 할 필요가 있습니다. <br><br>이 때문에, 패딩 방식은 PKCS5Padding 에 유사한 (완전히 동일하지 않다) 것이 됩니다. 패딩장은, 패딩내에서 encode 되어 1 ?  block_length 의 범위의 값이 됩니다. SSL 방식으로는, 패딩의 사이즈는, 항상 존재하는 <code>padding_length</code> 내에서 encode 되기 (위해)때문에, 0 ?  block_length-1 의 범위의 값이 됩니다.
    </td>
</tr>
</tbody>
</table>

</bblockquote>

<!-- ==================================================== -->

<a name="Configuration">
<h2><code>Configuration</code> 타입</h2></a> 

<bblockquote>
<p>
이 항의 타입은,<code>javax.security.auth.login.Configuration</code> 의 인스턴스의 생성시로 지정할 수 있습니다.
</p><p>
</p></bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 형 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	JavaLoginConfig
    </td>
    <td>
	<a href=	"jaas/tutorials/LoginConfigFile.html">ConfigFile class specification</a>  에 설명되고 있는, SUN 프로바이더의 디폴트의 Configuration 구현. 이 타입은, 유효한 <code>Configuration.Parameter</code> 타입으로서 <code>java.security.URIParameter</code> 를 받아들입니다. 이 파라미터가 지정되어 있지 않은 경우는, ConfigFile 클래스 스펙에 기술되고 있는 소스로부터 구성 정보가 로드 됩니다. 이 파라미터가 지정되고 있는 경우는, 지정되고 있는 URI 로부터 마셔 구성 정보가 로드 됩니다.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="Exemption">
<h2>면책 기구</h2></a>  <bblockquote>
<p>암호화 제한을 「면책되었다」라고 보여지는 어플리케이션에 부속되는 액세스권 정책 파일내에서, 다음의 면책 기구명을 지정할 수 있습니다.  </p>
  </bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="90%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	KeyEscrow
    </td>
    <td>
	백업 암호 해독 기능부 암호화 시스템. 이 시스템을 이용하면(자), 특정 조건하에서, 승인된 인물 (사용자, 조직 임원, 정부 직원)이, 특별한 데이터 복원열쇠를 보관 유지하는 신뢰할 수 있는 1 개(살) 이상의 파티의 제공하는 정보를 이용해, 암호 해독을 실행할 수 있습니다.
    </td>
</tr>
<tr>
    <td>
	KeyRecovery
    </td>
    <td>
	암호화 데이터의 락에 사용하는 비밀열쇠를 취득하는 메소드. 이것은, 재해 발생시에, 기업 독자적인 암호화 정보에의 복구 액세스를 실행하는 수단으로서 사용할 수 있습니다.
    </td>
</tr>
<tr>
    <td>
	KeyWeakening
    </td>
    <td>
	열쇠의 일부를 에스크로-또는 복원 가능한 메소드
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="GSSAPI">
<h2>GSSAPI 기구</h2></a>  <bblockquote>
<p>GSSAPI 를 사용하는 경우는, 다음의 기구를 지정할 수 있습니다. GSSAPI 표준과의 일관성을 유지하기 위해서, 이름 대신에 객체 식별자 (OID)가 지정됩니다. </p>
  </bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 기구 OID</th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	1.2. 840.113554. 1.2. 2
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc4121.txt">RFC 4121</a>  에 정의되고 있는 Kerberos v5 GSS-API 기구.
    </td>
</tr>
<tr>
    <td>
	1.3. 6.1. 5.5. 2
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc4178.txt">RFC 4178</a>  으로 정의되고 있는 Simple and Protected GSS-API Negotiation (SPNEGO) 기구입니다.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="KeyAgreement">
<h2><code>KeyAgreement</code> 알고리즘 </h2></a> 

  <bblockquote>
<p><code>KeyAgreement</code> 의 인스턴스를 요구할 때, 다음의 알고리즘명을 지정할 수 있습니다.  </p>
  </bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	DiffieHellman
    </td>
    <td>
	<a href="http://www.rsasecurity.com/rsalabs/pkcs">「PKCS3: Diffie-Hellman Key-Agreement Standard」버젼 1.4 (RSA Laboratories, 1993 년 11 월)</a>  로 정의된 Diffie-Hellman 열쇠 협정.
    </td>
</tr>
<tr>
    <td>
	ECDH
    </td>
    <td>
	Elliptic Curve Diffie-Hellman. ANSI X9. 63 에 정의되고 있어<a 	href="http://www.ietf.org/rfc/rfc3278.txt">RFC 3278</a> :「Use of Elliptic Curve Cryptography (ECC) Algorithms in Cryptographic Message Syntax (CMS)」에 기재되어 있습니다.
    </td>
</tr>
<tr>
    <td>
	ECMQV
    </td>
    <td>
	www.secg.org 의 <a 	href="http://www.secg.org/collateral/sec1.pdf">「Elliptic Curve Cryptography」</a>  에 정의되고 있는 Elliptic Curve Menezes-Qu-Vanstone.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="KeyFactory">
<h2><code>KeyFactory</code> 알고리즘</h2></a> 

<bblockquote>

<p>

특히 지정되고 있는 경우를 제외해, 이러한 클래스는,<a href="../../../api/java/security/Key.html#getAlgorithm()"><code>Key.getAlgorithm()</code></a>  가 표준 알고리즘명을 돌려주는 키를 작성합니다.

<p>

이 항의 타입은,<code>KeyFactory</code> 의 인스턴스의 생성시로 지정할 수 있습니다.

</p></bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	DiffieHellman
    </td>
    <td>
	Diffie-Hellman KeyAgreement 알고리즘의 열쇠.
	<p>
	주:<code>key.getAlgorithm()</code> 는, 「DiffieHellman」는 아니고 「DH」를 돌려줍니다.
    </td>
</tr>
<tr>
    <td>
	DSA
    </td>
    <td>
	디지털 서명 알고리즘의 열쇠.
    </td>
</tr>
<tr>
    <td>
	RSA
    </td>
    <td>
	RSA 알고리즘 (Signature/Cipher)의 열쇠.
    </td>
</tr>


<tr>
    <td>
	EC
    </td>
    <td>
	Elliptic Curve 알고리즘의 열쇠.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="KeyGenerator">
<h2><code>KeyGenerator</code> 알고리즘</h2>
  </a> 

  <bblockquote>
<p><code>KeyGenerator</code> 의 인스턴스를 요구할 때, 다음의 알고리즘명을 지정할 수 있습니다.  </code></code></p>
  </bblockquote><code><code>

</code></code><table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	AES
    </td>
    <td>
	AES 알고리즘과 함께 사용하는 열쇠 제네레이터.
    </td>
</tr>
<tr>
    <td>
	ARCFOUR
    </td>
    <td>
	ARCFOUR (RC4) 알고리즘과 함께 사용하는 열쇠 제네레이터.
    </td>
</tr>
<tr>
    <td>
	Blowfish
    </td>
    <td>
	Blowfish 알고리즘과 함께 사용하는 열쇠 제네레이터.
    </td>
</tr>
<tr>
    <td>
	DES
    </td>
    <td>
	DES 알고리즘과 함께 사용하는 열쇠 제네레이터.
    </td>
</tr>
<tr>
    <td>
	DESede
    </td>
    <td>
	DESede (트리플 DES) 알고리즘과 함께 사용하는 열쇠 제네레이터.
    </td>
</tr>
<tr>
    <td>
	HmacMD5
    </td>
    <td>
	HmacMD5 알고리즘과 함께 사용하는 열쇠 제네레이터.
    </td>
</tr>
<tr>
    <td>
	HmacSHA1 HmacSHA256 HmacSHA384 HmacSHA512
    </td>
    <td>
	HmacSHA 알고리즘의 다양한 후레이바와 함께 사용하는 열쇠 제네레이터.
    </td>
</tr>
<tr>
    <td>
	RC2
    </td>
    <td>
	RC2 알고리즘과 함께 사용하는 열쇠 제네레이터.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== --> <a name="KeyPairGenerator">
<h2><code>KeyPairGenerator</code> 알고리즘</h2>
</a> 

<bblockquote>

<p>

특히 지정되고 있는 경우를 제외해, 이러한 클래스는,<a href="../../../api/java/security/Key.html#getAlgorithm()"><code>Key.getAlgorithm()</code></a>  가 표준 알고리즘명을 돌려주는 키를 작성합니다.

<p>
이 항의 알고리즘명은,<code>KeyPairGenerator</code> 의 인스턴스의 생성시로 지정할 수 있습니다.

</p></bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	DiffieHellman
    </td>
    <td>
	Diffie-Hellman KeyAgreement 알고리즘의 열쇠 페어를 생성합니다.
	<p>
	주:<code>key.getAlgorithm()</code> 는, 「DiffieHellman」는 아니고 「DH」를 돌려줍니다.

    </td>
</tr>
<tr>
    <td>
	DSA
    </td>
    <td>
	디지털 서명 알고리즘의 열쇠 페어를 생성합니다.
    </td>
</tr>
<tr>
    <td>
	RSA
    </td>
    <td>
	RSA 알고리즘 (Signature/Cipher)의 열쇠 페어를 생성합니다.
    </td>
</tr>

<tr>
    <td>
	EC
    </td>
    <td>
	Elliptic Curve 알고리즘의 열쇠 페어를 생성합니다.
    </td>

</tr>

</tbody>
</table>

<!-- ==================================================== --> <a name="KeyStore">
<h2><code>KeyStore</code> 타입</h2>

<bblockquote>
<p>
이 항의 알고리즘명은,<code>KeyStore</code> 의 인스턴스의 생성시로 지정할 수 있습니다.
</p><p>
</p></bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 형 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	jceks
    </td>
    <td>
	「SunJCE」프로바이더에 의해 제공되고 있는<a href="crypto/CryptoSpec.html#KeystoreImplementation">독자적인 키스토어 </a>구현.
    </td>
</tr>
<tr>
    <td>
	jks
    </td>
    <td>
	「SUN」프로바이더에 의해 제공되고 있는<a 	href="crypto/CryptoSpec.html#KeystoreImplementation">독자적인 키스토어 </a>구현.
    </td>
</tr>
<tr>
    <td>
	pkcs12
    </td>
    <td>
	<a href="http://www.rsasecurity.com/rsalabs/pkcs">PKCS12</a>  에 정의되고 있는, 개인의 아이덴티티 정보를 위한 전송 구문.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="Mac">
<h2><code>Mac</code> 알고리즘</h2>
  <a/>

  <bblockquote>
<p><code>Mac</code> 의 인스턴스를 요구할 때, 다음의 알고리즘명을 지정할 수 있습니다.  </p>
  </bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	HmacMD5
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc2104.txt">RFC 2104</a> 「HMAC: Keyed-Hashing for Message Authentication」 (1997 년 2 월)로 정의된 HMAC-MD5 키 해시 알고리즘.
    </td>
</tr>
<tr>
    <td>
	HmacSHA1<br> HmacSHA256<br> HmacSHA384<br> HmacSHA512<br>
    </td>
    <td>
	<a 	href="http://www.ietf.org/rfc/rfc2104.txt">RFC 2104</a> 「HMAC: Keyed-Hashing for Message Authentication」 (1997 년 2 월)로 정의된,<code>SHA-*</code> 를 메세지 다이제스트 알고리즘으로 하는 HmacSHA* 알고리즘.
    </td>
</tr>
<tr>
    <td>
	PBEWith&lt;mac&gt;
    </td>
    <td>
	패스워드 베이스의 메세지 인증 규격,<a 	href="http://www.rsasecurity.com/rsalabs/pkcs">PKCS5 v 2.0</a>  으로 사용되는 Mac. &lt;mac&gt; 는 메세지 인증 코드의 알고리즘명. 예:<b>PBEWithHmacSHA1</b>.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="MessageDigest">
<h2><code>MessageDigest</code> 알고리즘</h2>
</a> 

<bblockquote>

<p>
이 항의 알고리즘명은,<code>MessageDigest</code> 의 인스턴스의 생성시로 지정할 수 있습니다.
</p></bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	MD2
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc1319.txt">RFC 1319</a>  로 정의되고 있는 MD2 메세지 다이제스트 알고리즘.
    </td>
</tr>
<tr>
    <td>
	MD5
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc1321.txt">RFC 1321</a>  으로 정의되고 있는 MD5 메세지 다이제스트 알고리즘.
    </td>
</tr>
<tr>
    <td>
	SHA-1 <br> SHA-256 <br> SHA-384 <br> SHA-512 <br>
    </td>
    <td>
	<a href="http://csrc.nist.gov/publications/fips/index.html">FIPS PUB 180-2</a>  로 정의되고 있는 Hash 알고리즘. <br><br>SHA-256 는, 충돌 공격에 대비해 128 비트의 시큐리티를 제공하기 위한 256 비트 해시 기능이며, SHA-512 는, 256 비트의 시큐리티를 제공하기 위한 512 비트 해시 기능입니다. SHA-512 의 출력을 절약하는 것에 의해, 384 비트의 해시를 얻을 수 있습니다.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="Policy">
<h2><code>Policy</code> 타입</h2>
</a> 

<bblockquote>
<p>
이 항의 타입은,<code>Policy</code> 의 인스턴스의 생성시로 지정할 수 있습니다.
</p><p>
</p></bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 형 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	JavaPolicy
    </td>
    <td>
	<a href="PolicyFiles.html">PolicyFile</a>  가이드에 설명되고 있는, SUN 프로바이더의 디폴트의 Policy 구현. 이 타입은, 유효한 <code>Policy.Parameter</code> 타입으로서 <code>java.security.URIParameter</code> 를 받아들입니다. 이 파라미터가 지정되어 있지 않은 경우는, PolicyFile 가이드의 <a 	href="PolicyFiles.html#DefaultLocs">정책 파일의 디폴트의 장소</a>  섹션에 기술되고 있는 소스로부터 정책 정보가 로드 됩니다. 이 파라미터가 지정되고 있는 경우는, 지정되고 있는 URI 로부터 마셔 정책 정보가 로드 됩니다.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="SaslClient">
<h2><code>SaslClient</code> 기구</h2>
</a>  <bblockquote>
<p>
이 항의 기구는,<code>SaslClient</code> 의 인스턴스의 생성시로 지정할 수 있습니다.
</p><p>
</p></bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 기구 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	CRAM-MD5
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc2195.txt">RFC 2195</a>  를 참조해 주세요. 이 기구는, 해시 된 사용자명/패스워드 인증 방식을 지원하고 있습니다.
    </td>
</tr>
<tr>
    <td>
	DIGEST-MD5
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc2831.txt">RFC 2831</a>  을 참조해 주세요. 이 기구는, SASL 기구로서 HTTP 다이제스트 인증을 사용하는 방법을 정의합니다.
    </td>
</tr>
<tr>
    <td>
	EXTERNAL
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc2222.txt">RFC 2222</a>  를 참조해 주세요. 이 기구는, TLS 나 IPsec 등의 외부 채널로부터 인증 정보를 가져옵니다.
    </td>
</tr>
<tr>
    <td>
	GSSAPI
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc2222.txt">RFC 2222</a>  를 참조해 주세요. 이 기구는, 인증 정보를 취득할 경우에 GSSAPI 를 사용합니다. Kerberos v5 인증을 지원하고 있습니다.
    </td>
</tr>
<tr>
    <td>
	PLAIN
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc2595.txt">RFC 2595</a>  를 참조해 주세요. 이 기구는, clear text 사용자명/패스워드 인증을 지원하고 있습니다.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="SaslServer">
<h2><code>SaslServer</code> 기구</h2>
</a> 

<bblockquote>
<p>
이 항의 기구는,<code>SaslServer</code> 의 인스턴스의 생성시로 지정할 수 있습니다.
</p><p>
</p></bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 기구 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	CRAM-MD5
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc2195.txt">RFC 2195</a>  를 참조해 주세요. 이 기구는, 해시 된 사용자명/패스워드 인증 방식을 지원하고 있습니다.
    </td>
</tr>
<tr>
    <td>
	DIGEST-MD5
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc2831.txt">RFC 2831</a>  을 참조해 주세요. 이 기구는, SASL 기구로서 HTTP 다이제스트 인증을 사용하는 방법을 정의합니다.
    </td>
</tr>
<tr>
    <td>
	GSSAPI
    </td>
    <td>
	<a href="http://www.ietf.org/rfc/rfc2222.txt">RFC 2222</a>  를 참조해 주세요. 이 기구는, 인증 정보를 취득할 경우에 GSSAPI 를 사용합니다. Kerberos v5 인증을 지원하고 있습니다.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== -->

<a name="SecretKeyFactory">
<h2><code>SecretKeyFactory</code> 알고리즘</h2>
  </a> 

  <bblockquote>
<p><code>SecretKeyFactory</code> 의 인스턴스를 요구할 때, 다음의 알고리즘명을 지정할 수 있습니다.  </p>
  </bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>

<tr>
   <td>
AES
    </td>
   <td>
AES 알고리즘과 함께 사용하는 비밀열쇠를 구축합니다.
    </td>
</tr>
<tr>
   <td>
ARCFOUR
    </td>
   <td>
ARCFOUR 알고리즘과 함께 사용하는 비밀열쇠를 구축합니다.
    </td>
</tr>
<tr>
    <td>
	DES
    </td>
    <td>
	DES 알고리즘과 함께 사용하는 비밀열쇠를 구축합니다.
    </td>
</tr>
<tr>
    <td>
	DESede
    </td>
    <td>
	DESede (트리플 DES) 알고리즘과 함께 사용하는 비밀열쇠를 구축합니다.
    </td>
</tr>
<tr>
    <td>
	PBEWith&lt;digest&gt;And&lt;encryption&gt;<br> PBEWith&lt;prf&gt;And&lt;encryption&gt;
    </td>
    <td>

	패스워드 베이스의 암호화 PKCS5 로 사용되는 비밀열쇠 팩토리. &lt;digest&gt; 는 메세지 다이제스트, &lt;prf&gt; 은 의사 랜덤 함수, &lt;encryption&gt; 는 암호화 알고리즘.
	<p>
	례:
	</p><ul>
	<li><b>PBEWithMD5AndDES</b> (PKCS5, v 1.5),</li>
	<li><b>PBEWithHmacSHA1AndDESede</b> (PKCS5, v 2.0)</li>
	</li></ul>
	주:이것들은 각 패스워드 문자의 하위 8 비트만을 사용합니다.
    </td>
</tr>
<tr>
    <td>
	PBKDF2WithHmacSHA1
    </td>
    <td>
	<a href="http://www.rsasecurity.com/rsalabs/pkcs">PKCS5 v2. 0</a>  에 있는 패스워드 베이스 키 파생 기능을 사용해 비밀열쇠를 구축합니다.
    </td>
</tr>

</tbody>
</table>

<!-- ==================================================== -->

<a name="SecureRandom">
<h2><code>SecureRandom</code> 난수 생성 (RNG) 알고리즘</h2></a> 

<bblockquote>

<p>
이 항의 알고리즘명은,<code>SecureRandom</code> 의 인스턴스의 생성시로 지정할 수 있습니다.
</p><p>
</p></bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	SHA1PRNG
    </td>
    <td>
	Sun 프로바이더가 제공하는 의사 난수 생성 (PRNG) 알고리즘. 이 알고리즘은, PRNG 의 기반으로서 SHA-1 를 사용합니다. 각 조작에 대해 값이 1 증가하는 64 비트 카운터를 사용해 쇄장으로 연결된 실로 랜덤인 배정치로부터, SHA-1 해시를 계산합니다. 160 비트의 SHA­1 출력 가운데, 64 비트만이 사용됩니다.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== --> <a name="Service">
<h2>서비스 속성</h2></a>  <bblockquote>

<P>암호화 서비스는, 항상 특정의 알고리즘 또는 타입에 관련지을 수 있고 있습니다. 예를 들어, 디지털 서명 서비스는 항상 특정의 알고리즘 (DSA 등)에,<code>CertificateFactory</code> 서비스는 항상 특정의 증명서 타입 (X. 509 등)에 각각 관련지을 수 있고 있습니다. </p>
<p>
여기서 나타나고 있는 속성은, 암호화 서비스용의 것입니다. 서비스 속성은, 프로바이더를 선택하기 위한 필터로서 사용할 수 있습니다.
</p><p>
속성명 및 속성치는 양쪽 모두 대문자와 소문자를 구별하지 않습니다.
</p></bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 속성 </th>
<th bgcolor="#dedeef" width="90%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	KeySize
    </td>
    <td>
	프로바이더가 암호화 서비스를 위해서(때문에) 지원하고 있는 최대의 키 사이즈
    </td>
</tr>
<tr>
    <td>
	ImplementedIn
    </td>
    <td>
	암호화 서비스의 구현이 소프트웨어와 하드웨어의 어디에서 행해지고 있을까. 이 속성의 값은, 「software」와「hardware」의 어딘가에 됩니다.
    </td>
</tr>
<tr>
    <td>
	ValidationAlgorithm
    </td>
    <td>
	<code>CertPathBuilder</code> 또는 <code>CertPathValidator</code> 가 지원하는 증명서 패스 검증 알고리즘의 구현을 정의하는 스펙의 이름. RFC 는, 「RFC#」 (예:「RFC3280」)과 같이 지정합니다.  Internet Draft 는, 드래프트명으로 지정합니다 (예:「draft-ietf-pkix-rfc2560bis-01. txt」). 이 속성의 값을 <code>Security.getProviders</code> 메소드의 선택 기준으로서 지정했을 경우,<code>String.equalsIgnoreCase</code> 메소드에 의해 값의 비교를 합니다. <code>CertPathBuilder</code> 및 <code>CertPathValidator</code> 의 모든 PKIX 구현은, 이 속성의 값을 제공할 필요가 있습니다.
    </td>
</tr>
<tr>
    <td>
	LDAPSchema
    </td>
    <td>
	LDAP <code>CertStore</code> 의 구현이 증명서와 CRL 의 취득에 사용하는 LDAP 방식을 정의하는 스펙의 이름입니다. 이 속성의 형식 및 시멘틱스는, ValidationAlgorithm 속성의 경우와 같습니다. <code>CertStore</code> 의 모든 LDAP 구현은, 이 속성의 값을 제공할 필요가 있습니다.
    </td>
</tr>
</tbody>
</table>

<bblockquote>
<p>예를 나타냅니다. </p>
<pre>	map.put("KeyPairGenerator.DSA",
	    "sun.security.provider.DSAKeyPairGenerator");
	map.put("KeyPairGenerator.DSA KeySize", "1024");
	map.put("KeyPairGenerator.DSA ImplementedIn", "Software");
</pre>
</bblockquote>

<!-- ==================================================== -->

<a name="Signature">
<h2><code>Signature</code> 알고리즘 </h2></a> 

<bblockquote>

<p>
이 항의 알고리즘명은,<code>Signature</code> 의 인스턴스의 생성시로 지정할 수 있습니다.
</p></bblockquote>


<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	NONEwithRSA
    </td>
    <td>
	RSA 조작을 실시하기 전에 다이제스트 알고리즘 (MD5/SHA1 등)을 사용하지 않는 RSA 서명 알고리즘. RSA 서명 알고리즘에 대해서는,<a href="http://www.rsasecurity.com/rsalabs/pkcs">PKCS1</a>  를 참조해 주세요.
    </td>
</tr>
<tr>
    <td>
	MD2withRSA <br> MD5withRSA <br>
    </td>
    <td>
	<a 	href="http://www.rsasecurity.com/rsalabs/pkcs">PKCS1</a>  에 정의되고 있는 RSA 암호를 사용한 MD2/MD5 서명 알고리즘. MD2/MD5 다이제스트 알고리즘 및 RSA 를 사용해 RSA 디지털 서명을 작성 및 검증합니다.
    </td>
</tr>
<tr>
    <td>
	SHA1withRSA SHA256withRSA<br> SHA384withRSA<br> SHA512withRSA<br>
    </td>
    <td>
	OSI Interoperability Workshop 에 정의되고 있는 SHA-* 및 RSA 암호화 알고리즘을 사용한 서명 알고리즘. <a 	href="http://www.rsasecurity.com/rsalabs/pkcs">PKCS1</a>  로 설명되고 있는 패딩 규칙을 사용합니다.
    </td>
</tr>
<tr>
    <td>
	NONEwithDSA
    </td>
    <td>
	<a 	href="http://csrc.nist.gov/publications/fips/index.html">FIPS PUB 186-2</a>  로 정의되고 있는 디지털 서명 알고리즘. 이 데이터의 길이는 정확하게 20 바이트일 필요가 있습니다. 이 알고리즘은, rawDSA 라고도 불리고 있습니다.
    </td>
</tr>
<tr>
    <td>
	SHA1withDSA
    </td>
    <td>
	<a 	href="http://csrc.nist.gov/publications/fips/index.html">FIPS PUB 186</a>  에 정의되고 있는 SHA-1 를 사용한 DSA 서명 알고리즘. SHA-1 다이제스트 알고리즘 및 DSA 를 사용해 DSA 디지털 서명을 작성 및 검증합니다.
    </td>
</tr>

<td>
	NONEwithECDSA <br> SHA1withECDSA <br> SHA256withECDSA <br> SHA384withECDSA <br> SHA512withECDSA <br> <i>(ECDSA)</i> <br>
</td>
    <td valign="top">
	ANSI X9. 62 로 정의되고 있는 ECDSA 서명 알고리즘.

	<!-- as defined in <a 	href="http://csrc.nist.gov/publications/fips/index.html"> FIPS 	PUB 186</a> .  -->

	<p>
	<b>주:</b> 「ECDSA」는 「SHA1withECDSA」알고리즘의 애매한 이름이기 (위해)때문에, 사용하지 말아 주세요. 대신에, 정식적 이름 「SHA1withECDSA」를 사용합니다.
	</p>
    </td>
</tr>
<tr>
    <td>
	&lt;digest&gt;with&lt;encryption&gt;
    </td>
    <td>
	이 형식을 사용해, 특정의 메세지 다이제스트 (MD2, MD5 등)와 알고리즘 (RSA, DSA 등)을 사용하는 서명 알고리즘의 이름을 지정합니다. 이 마디로 소개한 명시적으로 정의되고 있는 표준명 (MD2withRSA 등)도 같은 형식에서 지정되고 있습니다.
	<p>
	<a href="http://www.rsasecurity.com/rsalabs/pkcs">PKCS1 v 2.0</a>  에 정의된 새로운 서명 방식의 경우는, &lt;digest&gt;with&lt;encryption&gt; 의 형식으로는 불충분하기 때문에,<b>&lt;digest&gt;with&lt;encryption&gt;and&lt;mgf&gt;</b> 의 형식을 사용해, 이름을 지정할 수 있습니다. &lt;mgf&gt; 는, MGF1 등의 마스크 생성 기능에 옮겨놓을 필요가 있습니다. 예:<b>MD5withRSAandMGF1</b>.
    </td>
</tr>
</tbody>
</table>
</bblockquote>

<!-- ==================================================== -->

<a name="SSLContext">
<h2><code>SSLContext</code> 알고리즘</h2></a> 

<bblockquote>

<p>

이 항의 알고리즘명은,<code>SSLContext</code> 의 인스턴스의 생성시로 지정할 수 있습니다.
</p></bblockquote>

<!-- <p>The <code>protocol</code> name parameter passed to the <code>getInstance</code> method of <code>SSLContext</code> supports a named secure socket protocol and optionally a named purpose separated from the protocol name by a '/' character.   -->

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
	<tr>
	  <td>SSL</td>
	  <td>SSL 의 일부의 버젼을 지원한다. 다른 버젼을 지원하는 경우도 있다</td>
	</tr>
	<tr>
	  <td>SSLv2</td>
	  <td>SSL 버젼 2 이후를 지원합니다. 다른 버젼을 지원하는 경우도 있습니다. </td>
	</tr>
	<tr>
	  <td>SSLv3</td>
	  <td>SSL 버젼 3 을 지원한다. 다른 버젼을 지원하는 경우도 있다</td>
	</tr>
	<tr>
	  <td>TLS</td>
	  <td>TLS 의 일부의 버젼을 지원한다. 다른 버젼을 지원하는 경우도 있다</td>
	</tr>
	<tr>
	  <td>TLSv1</td>
	  <td><a href="http://www.ietf.org/rfc/rfc2246.txt">RFC 2246: TLS version 1.0</a>  을 지원합니다. 다른 버젼을 지원하는 경우도 있습니다. </td>
	</tr>
	<tr>
	  <td>TLSv1. 1</td>
	  <td><a href="http://www.ietf.org/rfc/rfc4346.txt">RFC 4346: TLS version 1.1</a>  을 지원합니다. 다른 버젼을 지원하는 경우도 있습니다. </td>
	</tr>
</tbody>
</table>
</bblockquote>

<!-- ==================================================== -->

<a name="TrustManagerFactory">
<h2><code>TrustManagerFactory</code> 알고리즘 </h2></a> 

<bblockquote>

<p>

이 항의 알고리즘명은,<code>TrustManagerFactory</code> 의 인스턴스의 생성시로 지정할 수 있습니다.
</p></bblockquote>

<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 이름 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
	<tr>
	  <td>PKIX</td>
	  <td>
<a href="http://www.ietf.org/rfc/rfc3280.txt">RFC 3280</a>  의 IETF PKIX 워킹 그룹 또는 그 후 상속자에 의해 정의되고 있는 규칙에 따라 증명서 체인을 검증하는 X509TrustManagers 의 팩토리. TrustManagerFactory 는, 클래스 <code>javax.net.ssl.CertPathTrustManagerParameters</code> 를 사용한 초기화를 지원할 필요가 있습니다.
	  </td>
	</tr>
      </tbody>
</table>

<!-- ==================================================== --> <a name="XMLSignature">

<h2>XML 서명 (<code>XMLSignatureFactory</code>/<code>KeyInfoFactory</code>/<code>TransformService)</code> 기구</h2>

<bblockquote>

<p>

이 항의 기구는,<code>XMLSignatureFactory</code>,<code>KeyInfoFactory</code>, 또는 <code>TransformService</code> 의 인스턴스의 생성시로 지정할 수 있습니다. 이 기구는, XML 서명이나 KeyInfo 구조를 해석 및 생성할 경우에 구현에 의해 내부에서 사용되는 XML 처리 기구를 식별합니다. 또, 각 <code>TransformService</code> 인스턴스는, 기구 뿐만이 아니라 특정의 변환 알고리즘도 지원합니다. 변환 알고리즘의 표준명은 다음의 항으로 정의되고 있습니다.

</p><p>

</p></bblockquote>
<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 기구 </th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	DOM
    </td>
    <td>
	문서 객체 모델. DOM 구현의 추가 요건에 대해서는,<a 	href="xmldsig/overview.html#DOM%20Mechanism%20Requirements">DOM 기구의 요건</a>을 참조해 주세요.
    </td>
</tr>
</tbody>
</table>

<!-- ==================================================== --> <a name="TransformService">
<h2>XML 서명 변환 (<code>TransformService</code>) 알고리즘</h2>

<bblockquote>

<p>
이 항의 알고리즘명은,<code>TransformService</code> 의 인스턴스의 생성시로 지정할 수 있습니다. XML 서명 표준과의 일관성을 유지하기 위해서, 이름 대신에 URI 가 지정됩니다. 이러한 URI 마다 API 정수가 정의되고 있어 다음의 표내에서 각 URI 의 뒤의 괄호내에 나타나고 있습니다.
</p><p>

</p></bblockquote>
<table  border="5" cellpadding="5" frame="border" width="90%">
<thead>
<tr>
<th bgcolor="#dedeef" width="20%"> 알고리즘의 URI</th>
<th bgcolor="#dedeef" width="80%"> 설명 </th>
</tr>
</thead>
<tbody>
<tr>
    <td>
	http://www.w3.org/TR/2001/REC-xml-c14n-20010315 (<code>CanonicalizationMethod.INCLUSIVE</code>)
    </td>
    <td>
	<a 	href="http://www.w3.org/TR/2001/REC-xml-c14n-20010315">Canonical XML (without comments)</a>  에 정의되고 있는 정규화 알고리즘.
    </td>
</tr>
<tr>
    <td>
	http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments (<code>CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS</code>)
    </td>
    <td>
	<a 	href="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">Canonical XML with comments</a>  에 정의되고 있는 정규화 알고리즘.
    </td>
</tr>
<tr>
    <td>
	http://www.w3.org/2001/10/xml-exc-c14n# (<code>CanonicalizationMethod.EXCLUSIVE</code>)
    </td>
    <td>
	<a href="http://www.w3.org/2001/10/xml-exc-c14n#">Exclusive Canonical XML (without comments)</a>  에 정의되고 있는 정규화 알고리즘.
    </td>
</tr>
<tr>
    <td>
	http://www.w3.org/2001/10/xml-exc-c14n#WithComments (<code>CanonicalizationMethod.EXCLUSIVE_WITH_COMMENTS</code>)
    </td>
    <td>
	<a href="http://www.w3.org/2001/10/xml-exc-c14n#WithComments">Exclusive Canonical XML with comments</a>  에 정의되고 있는 정규화 알고리즘.
    </td>
</tr>
<tr>
    <td>
	http://www.w3.org/2000/09/xmldsig#base64 (<code>Transform.BASE64</code>)
    </td>
    <td>
	<a href="http://www.w3.org/TR/xmldsig-core/#sec-Base-64">Base64</a>  에 정의되고 있는 변환 알고리즘.
    </td>
    </td>
</tr>
<tr>
    <td>
	http://www.w3.org/2000/09/xmldsig#enveloped-signature (<code>Transform.ENVELOPED</code>)
    </td>
    <td>
	<a 	href="http://www.w3.org/TR/xmldsig-core/#sec-EnvelopedSignature">Enveloped Signature</a>  에 정의되고 있는 변환 알고리즘.
    </td>
    </td>
</tr>
<tr>
    <td>
	http://www.w3.org/TR/1999/REC-xpath-19991116 (<code>Transform.XPATH</code>)
    </td>
    <td>
	<a href="http://www.w3.org/TR/xmldsig-core/#sec-XPath">XPath</a>  에 정의되고 있는 변환 알고리즘.
    </td>
    </td>
</tr>
<tr>
    <td>
	http://www.w3.org/2002/06/xmldsig-filter2 (<code>Transform.XPATH2</code>)
    </td>
    <td>
	<a href="http://www.w3.org/2002/06/xmldsig-filter2">XPath Filter 2</a>  에 정의되고 있는 변환 알고리즘.
    </td>
    </td>
</tr>
<tr>
    <td>
	http://www.w3.org/TR/1999/REC-xslt-19991116 (<code>Transform.XSLT</code>)
    </td>
    <td>
	<a href="http://www.w3.org/TR/xmldsig-core/#sec-XSLT">XSLT</a>  에 정의되고 있는 변환 알고리즘.
    </td>
    </td>
</tr>
</tbody>
</table>

</tbody>
</table>

</bblockquote><code><code>

<!-- ==================================================== -->

<h2><a name="jssenames">추가의 JSSE 표준명</a> </h1>

<p><code>X509KeyManager</code> 의 <code>chooseClientAlias</code> 메소드,<code>chooseServerAlias</code> 메소드,<code>getClientAliases</code> 메소드,<code>getServerAliases</code> 메소드에게 건네지는 <code>keyType</code> 파라미터는, 공개키의 형태를 지정합니다. 이하의 겉(표)에는, 지정된 증명서의 타이프별로,<code>keyType</code> 로 사용되는 표준명을 일람표 가리킵니다.  </p>

  <blockquote>
    <table summary="standard names and types" border="1" cellspacing="1"
 cellpadding="4" width="80%">
      <tbody>
	<tr>
	  <th bgcolor="#dedeef">이름</th>
	  <th bgcolor="#dedeef">증명서의 타입</th>
	</tr>
	<tr>
	  <td>RSA</td>
	  <td>RSA</td>
	</tr>
	<tr>
	  <td>DSA</td>
	  <td>DSA</td>
	</tr>
	<tr>
	  <td>DH_RSA</td>
	  <td>Diffie-Hellman (RSA 서명을 사용)</td>
	</tr>
	<tr>
	  <td>DH_DSA</td>
	  <td>Diffie-Hellman (DSA 서명을 사용)</td>
	</tr>
	<tr>
	  <td>EC</td>
	  <td>Elliptic Curve</td>
	</tr>
	<tr>
	  <td>EC_EC</td>
	  <td>Elliptic Curve (ECDSA 서명을 사용)</td>
	</tr>
	<tr>
	  <td>EC_RSA</td>
	  <td>Elliptic Curve (RSA 서명을 사용)</td>
	</tr>
      </tbody>
    </table>
  </blockquote>
<p><code>SSLSocket</code> 의 <code>setEnabledProtocols</code> 메소드에게 건네지는 <code>protocols</code> 파라미터는, 접속으로 사용할 수 있는 프로토콜의 버젼을 지정합니다. 이하의 겉(표)에는,<code>setEnabledProtocols</code> 에게 건네지는 표준명, 또는 <code>SSLSocket getSupportedProtocols</code> 메소드와 <code>getEnabledProtocols</code> 메소드로부터 반환되는 표준명을 일람표 가리킵니다.  </p>
  <blockquote>
    <table summary="standard names" border="1" cellspacing="1"
 cellpadding="4" width="80%">
      <tbody>
	<tr>
	  <th bgcolor="#dedeef">이름</th>
	  <th bgcolor="#dedeef">프로토콜</th>
	</tr>
	<tr>
	  <td>SSLv2</td>
	  <td>SSL 버젼 2 프로토콜</td>
	</tr>
	<tr>
	  <td>SSLv3</td>
	  <td>SSL 버젼 3 프로토콜</td>
	</tr>
	<tr>
	  <td>TLSv1</td>
	  <td>TLS 버젼 1.0 프로토콜 (<a href="http://www.ietf.org/rfc/rfc2246.txt">RFC 2246 에 정의)</td>
	</tr>
	<tr>
	  <td>TLSv1. 1</td>
	  <td>TLS 버젼 1.1 프로토콜 (<a href="http://www.ietf.org/rfc/rfc4346.txt">RFC 4346 에 정의)</td>
	</tr>
	<tr>
	  <td>SSLv2Hello</td>

	  <td>현재, SSLv3, TLSv1, 및 TLSv1. 1 프로토콜을 사용하면(자), SSLv3, TLSv1, 및 TLSv1. 1 의 hello 를 SSLv2 형식의 hello 에 캡슐화해 송신할 수 있습니다. 이러한 프로토콜로 이러한 호환성을 허가하는 이유에 대해서는, 해당하는 RFC (상기)의 부록 E 를 참조해 주세요. <br><br>일부의 SSL/TLS 서버에서는 v2 hello 형식이 지원되고 있지 않습니다. 이 때문에, 클라이언트 hello 는 SSLv3 또는 TLSv1 의 클라이언트 hello 형식에 준거하고 있을 필요가 있습니다. <br><br>SSLv2Hello 옵션은, SSLv2 캡슐화를 제어합니다. 클라이언트로 SSLv2Hello 가 무효가 되어 있는 경우, 모든 발신 메세지는 SSLv3/TLSv1 의 클라이언트 hello 형식에 준거합니다. 서버로 SSLv2Hello 가 무효가 되어 있는 경우, 모든 착신 메세지는 SSLv3/TLSv1 의 클라이언트 hello 형식에 준거할 필요가 있습니다.
	  </td>
	</tr>
      </tbody>
    </table>
  </blockquote>
<p><code>X509TrustManager</code> 의 <code>checkClientTrusted</code> 메소드와 <code>checkServerTrusted</code> 메소드에게 건네지는 <code>authType</code> 파라미터는, 인증의 타입을 나타냅니다. 이하의 겉(표)에는, 클라이언트 또는 서버의 증명서 체인으로 사용되는 표준명을 나타냅니다.  </p>
  <blockquote>
    <table summary="standard names for certificate chains" border="1"
 cellspacing="1" cellpadding="4" width="80%">
      <tbody>
	<tr>
	  <th bgcolor="#dedeef">클라이언트 또는 서버의 증명서 체인</th>
	  <th bgcolor="#dedeef">인증의 표준명</th>
	</tr>
	<tr>
	  <td>클라이언트</td>
	  <td>실제로 사용하는 증명서에 따라서 다르다. 예를 들어, RSAPublicKey 를 사용하는 경우,<code>authType</code> 는 "RSA" 가 된다</td>
	</tr>
	<tr>
	  <td>서버</td>
	  <td>암호군의 열쇠 교환 알고리즘 부분이,"RSA","DHE_DSS" 와 같은 캐릭터 라인으로 나타내진다. 주:export 가능한 암호군에서는, 실행시, 핸드 쉐이크중에 열쇠 교환 알고리즘이 결정되는 경우가 있다. 예를 들어, TLS_RSA_EXPORT_WITH_RC4_40_MD5 의 <code>authType</code> 는, 일시적인 RSA 열쇠를 사용해 열쇠 교환을 실시하는 경우는 "RSA_EXPORT", 서버 증명서의 열쇠를 사용하는 경우는 "RSA" 가 된다. 그 이외의 경우는 "UNKNOWN"</td>
	</tr>
      </tbody>
    </table>
</blockquote>

<a name="SupportedCipherSuites"></a> 
<p>

다양한 그룹에 의해, SSL/TLS 이름 공간에 새로운 암호군정의가 단계적으로 추가되었습니다. 일부의 암호군의 이름은, TLSv1. 0 이 finalize 되기 전에 정의되었습니다. 이 때문에,<code>SSL_*</code> 접두사가 부여되고 있습니다. 접두사 <code>TLS_*</code> 가 부여되어 TLS RFC 내에서 설명되고 있는 이름은, 접두사 <code>SSL_*</code> 가 부여되고 있는 JSSE 암호군과 기능적으로 동등합니다.

<p>

다음의 겉(표)는, 표준의 암호군의 이름을 나타내고 있습니다.

<blockquote>

<!-- PLEASE MAKE SURE TO EDIT THE TABLE BY HAND SO THAT ITS STRUCTURE AND EDITIBILITY IS PRESERVED. DO not USE AN HTML EDITOR -->

<table border="5" frame="border" align="center" width="90%"
cellpadding="5">
<thead>
<tr>
<th BGCOLOR="#dedeef"> 암호군</th>
</tr>
</thead>
<tbody>

<tr><td><code>SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DH_DSS_WITH_DES_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DH_RSA_WITH_DES_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA</code></td></tr>

<tr><td><code>TLS_DHE_DSS_WITH_AES_128_CBC_SHA</code></td></tr>
<tr><td><code>TLS_DHE_DSS_WITH_AES_256_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA</code></tr>
<tr><td><code>SSL_DHE_DSS_WITH_DES_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DHE_DSS_WITH_RC4_128_SHA</code></td></tr>
<tr><td><code>SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA</code></td></tr>

<tr><td><code>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</code></td></tr>
<tr><td><code>TLS_DHE_RSA_WITH_AES_256_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DHE_RSA_WITH_DES_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA</code></td></tr>

<tr><td><code>SSL_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA</code></td></tr>

<tr><td><code>TLS_DH_anon_WITH_AES_128_CBC_SHA</code></td></tr>
<tr><td><code>TLS_DH_anon_WITH_AES_256_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DH_anon_WITH_3DES_EDE_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DH_anon_WITH_DES_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DH_anon_WITH_RC4_128_MD5</code></td></tr>

<tr><td><code>SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA</code></td></tr>
<tr><td><code>SSL_DH_anon_EXPORT_WITH_RC4_40_MD5</code></td></tr>

<tr><td><code>SSL_FORTEZZA_DMS_WITH_NULL_SHA</code></td></tr>
<tr><td><code>SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA</code></td></tr>

<tr><td><code>TLS_RSA_WITH_AES_128_CBC_SHA</code></td></tr>
<tr><td><code>TLS_RSA_WITH_AES_256_CBC_SHA</code></td></tr>
<tr><td><code>SSL_RSA_WITH_3DES_EDE_CBC_SHA</code></td></tr>
<tr><td><code>SSL_RSA_WITH_DES_CBC_SHA</code></td></tr>
<tr><td><code>SSL_RSA_WITH_IDEA_CBC_SHA</code></td></tr>
<tr><td><code>SSL_RSA_WITH_RC4_128_MD5</code></td></tr>
<tr><td><code>SSL_RSA_WITH_RC4_128_SHA</code></td></tr>
<tr><td><code>SSL_RSA_WITH_NULL_MD5</code></td></tr>
<tr><td><code>SSL_RSA_WITH_NULL_SHA</code></td></tr>
<tr><td><code>SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5</code></td></tr>
<tr><td><code>SSL_RSA_EXPORT_WITH_RC4_40_MD5</code></td></tr>
<tr><td><code>SSL_RSA_EXPORT_WITH_DES40_CBC_SHA</code></td></tr>

<tr><td><code>SSL_RSA_EXPORT1024_WITH_RC4_56_SHA</code></td></tr>
<tr><td><code>SSL_RSA_EXPORT1024_WITH_DES_CBC_SHA</code></td></tr>

<tr><td><code>SSL_RSA_FIPS_WITH_DES_CBC_SHA</code></td></tr>
<tr><td><code>SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA</code></td></tr>

<tr><td><code>TLS_KRB5_WITH_3DES_EDE_CBC_MD5</code></td></tr>
<tr><td><code>TLS_KRB5_WITH_3DES_EDE_CBC_SHA</code></td></tr>
<tr><td><code>TLS_KRB5_WITH_DES_CBC_MD5</code></td></tr>
<tr><td><code>TLS_KRB5_WITH_DES_CBC_SHA</code></td></tr>
<tr><td><code>TLS_KRB5_WITH_IDEA_CBC_SHA</code></td></tr>
<tr><td><code>TLS_KRB5_WITH_IDEA_CBC_MD5</code></td></tr>
<tr><td><code>TLS_KRB5_WITH_RC4_128_MD5</code></td></tr>
<tr><td><code>TLS_KRB5_WITH_RC4_128_SHA</code></td></tr>
<tr><td><code>TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5</code></td></tr>
<tr><td><code>TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA</code></td></tr>
<tr><td><code>TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA</code></td></tr>
<tr><td><code>TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5</code></td></tr>
<tr><td><code>TLS_KRB5_EXPORT_WITH_RC4_40_MD5</code></td></tr>
<tr><td><code>TLS_KRB5_EXPORT_WITH_RC4_40_SHA</code></td></tr>

<tr><td><code>TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDH_ECDSA_WITH_RC4_128_SHA</code></td></tr>
<tr><td><code>TLS_ECDH_ECDSA_WITH_NULL_SHA</code></td></tr>

<tr><td><code>TLS_ECDH_RSA_WITH_AES_128_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDH_RSA_WITH_AES_256_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDH_RSA_WITH_RC4_128_SHA</code></td></tr>
<tr><td><code>TLS_ECDH_RSA_WITH_NULL_SHA</code></td></tr>

<tr><td><code>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDHE_ECDSA_WITH_RC4_128_SHA</code></td></tr>
<tr><td><code>TLS_ECDHE_ECDSA_WITH_NULL_SHA</code></td></tr>

<tr><td><code>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDHE_RSA_WITH_RC4_128_SHA</code></td></tr>
<tr><td><code>TLS_ECDHE_RSA_WITH_NULL_SHA</code></td></tr>

<tr><td><code>TLS_ECDH_anon_WITH_AES_128_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDH_anon_WITH_AES_256_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA</code></td></tr>
<tr><td><code>TLS_ECDH_anon_WITH_RC4_128_SHA</code></td></tr>
<tr><td><code>TLS_ECDH_anon_WITH_NULL_SHA</code></td></tr>

</TABLE>
</blockquote>

      </p>

<!-- ==================================================== -->

<hr>

<h1><a name="alg">알고리즘</a> </h1>

<bblockquote>

<p>이 항에서는, 이 문서로 정의하고 싶은 구두인가의 알고리즘에 관한 상세를 나타냅니다. 일람 되고 있는 알고리즘의 구현을 제공하는 프로바이더는, 이 부록의 스펙에 따르는 것이 필요합니다.

</p>

<p>여기에 기재가 없는 새로운 알고리즘을 추가하려면 , 우선 최초로 프로바이더 패키지의 공급 먼저 문의해, 해당 알고리즘이 추가가 끝난 상태가 아닌지 어떤지를 확인합니다. 벌써 추가되고 있는 경우는, 가능하면 개시되고 있는 정의를 사용합니다. 아직 추가되어 있지 않은 경우는, 알고리즘의 스펙을 더해, 이 항에 기재의 템플릿에 유사한 사용 가능한 템플릿을 작성합니다. </p>



<a name="spectemp">
<h2>스펙 템플릿</h2></a> 

<bblockquote>

<p> 다음의 겉(표)에, 알고리즘의 스펙의 필드를 나타냅니다.. </p>

<bblockquote>

<table border="1" cellpadding="2" cellspacing="2" >
  <thead>
  <tr>
    <th bgcolor="#dedeef" width="23%">
<b>필드</b> </th>
    <th bgcolor="#dedeef" width="77%">
<b>설명</b></th>
  </tr>
  </thead>
  <tbody><tr>
    <td width="23%">
이름</td>
    <td width="77%">
알고리즘의 인식명. 이것은, 기존의 알고리즘 객체명을 판별하기 위해서, (알고리즘의 요구시에) <code>getInstance</code> 메소드에게 건네지는 이름으로,<code>getAlgorithm</code> 메소드에 의해 돌려주어집니다. 이러한 메소드는, 관련 엔진 클래스,<code><a     href="#Signature">Signature</a> </code>,<code><a     href="#MessageDigest">MessageDigest</a> </code>,<code><a     href="#KeyPairGenerator">KeyPairGenerator</a> </code>, 및 <code><a     href="#AlgorithmParameterGenerator">AlgorithmParameterGenerator</a> </code> 내에 있습니다. </td>

  </tr>
  <tr>
    <td width="23%">
형</td>
    <td width="77%">
알고리즘의 형태. <code>Signature</code>,<code>MessageDigest</code>,<code>KeyPairGenerator</code>, 및 <code>ParameterGenerator</code> 내에 있습니다. </td>
  </tr>
  <tr>
    <td width="23%">
설명</td>
    <td width="77%">
알고리즘에 관한 일반 주의. 알고리즘에 의해 구현되는 표준, 실용 방향 특허등을 포함합니다. </td>
  </tr>
  <tr>
    <td width="23%">
<code>KeyPair</code> 알고리즘 (옵션지정)</td>
    <td width="77%">
이 알고리즘의 KeyPair 알고리즘을 나타냅니다. </td>
  </tr>
  <tr>
    <td width="23%">
키 사이즈 (옵션지정)</td>
    <td width="77%">
열쇠 알고리즘 또는 열쇠 생성 알고리즘의 경우는, 올바른 키 사이즈를 나타냅니다. </td>
  </tr>
  <tr>
    <td width="23%">
<p>사이즈 (옵션지정)</p></td>
    <td width="77%">
알고리즘 파라미터 생성 알고리즘의 경우는, 알고리즘 파라미터 생성의 올바른 「사이즈」를 나타냅니다. </td>
  </tr>
  <tr>
    <td width="23%">
<p>파라미터의 디폴트 값 (옵션지정)</p></td>
    <td width="77%">
열쇠 생성 알고리즘의 경우는, 디폴트의 파라미터치를 나타냅니다. </td>
  </tr>
  <tr>
    <td width="23%">
<p><code>서명</code> 포맷 (옵션지정)</p></td>
    <td width="77%">
<code>Signature</code> 알고리즘의 경우는, 서명의 포맷을 나타냅니다. 즉, 검증 메소드의 입력과 서명 메소드의 출력입니다. </td>
  </tr>
</tbody></table>
</bblockquote></bblockquote>


<a name="algspec">
<h2>알고리즘의 스펙</h2></a> 

<bblockquote>


<h3>SHA-1 메세지 다이제스트 알고리즘</h3>

<bblockquote>
  <table  border="1" cellpadding="0" cellspacing="2" width="95%">
    <tbody><tr>
      <td width="28%">
<b>이름</b></td>
      <td width="72%">
SHA-1</td>
    </tr>
    <tr>
      <td width="28%">
<b>형</b></td>
      <td width="72%">
<code>MessageDigest</code></td>
    </tr>
    <tr>
      <td valign="top" width="28%">
<b>설명</b></td>
      <td width="72%">
<a href="http://csrc.nist.gov/CryptoToolkit/tkhash.html">NIST 의 FIPS 180-2</a>  로 정의한 메세지 다이제스트 알고리즘. 이 알고리즘의 출력은 160 비트의 다이제스트입니다. </td>
    </tr>
  </tbody></table>
</bblockquote>

<h3>MD2 메세지 다이제스트 알고리즘</h3>

<bblockquote>
  <table  border="1" cellpadding="0" cellspacing="2" width="95%">
    <tbody><tr>
      <td width="28%">
<b>이름</b></td>
      <td width="72%">
MD2</td>
    </tr>
    <tr>
      <td width="28%">
&nbsp;<b>형</b></td>
      <td width="72%">
<code>MessageDigest</code></td>
    </tr>
    <tr>
      <td valign="top" width="28%">
<b>설명</b></td>
      <td width="72%">
RFC 1319 로 정의되고 있는 메세지 다이제스트 알고리즘. 이 알고리즘의 출력은 128 비트 (16 바이트)의 다이제스트입니다. </td>
    </tr>
  </tbody></table>
</bblockquote>

<h3>MD5 메세지 다이제스트 알고리즘</h3>


  <table border="1" cellpadding="0" cellspacing="2" width="95%">
    <tbody><tr>
      <td width="28%">
<b>이름</b></td>
      <td width="72%">
MD5</td>
    </tr>
    <tr>
      <td width="28%">
<b>형</b></td>
      <td width="72%">
<code>MessageDigest</code></td>
    </tr>
    <tr>
      <td valign="top" width="28%">
<b>설명</b></td>
      <td width="72%">
RFC 1321 으로 정의되고 있는 메세지 다이제스트 알고리즘. 이 알고리즘의 출력은 128 비트 (16 바이트)의 다이제스트입니다. </td>
    </tr>
  </tbody></table>
</p></bblockquote>

<h3>디지털 서명 알고리즘</h3>

<bblockquote>
<table  border="1" cellpadding="0" cellspacing="2" width="95%">
    <tbody><tr>
      <td width="28%">
<b>이름</b></td>
      <td width="72%">
SHA1withDSA</td>
    </tr>
    <tr>
      <td width="28%">
<b>형</b></td>
      <td width="72%">
<code>서명</code></td>
    </tr>
    <tr>
      <td valign="top" width="28%">
<b>설명</b></td>
      <td width="72%">
이 알고리즘은, NIST FIPS 186 에 기술의 서명 알고리즘입니다. DSA 는 SHA-1 메세지 다이제스트 알고리즘을 사용합니다. </td>
    </tr>
    <tr>
      <td width="28%">
<b><code>KeyPair</code> 알고리즘</b></td>
      <td width="72%">
DSA</td>
    </tr>
    <tr>
      <td valign="top" width="28%">
<b>서명 포맷</b></td>
      <td width="72%">
ASN. 1 의 2 개의 INTEGER 치의 순서. <code>r</code> 및 <code>s</code> (이 순서):<br><code>SEQUENCE ::= { r INTEGER, s INTEGER }</code></td>
    </tr>
  </tbody></table><p></p>
</bblockquote>

<h3>RSA 베이스의 서명 알고리즘, MD2, MD5 또는 SHA-1 를 사용합니다. </h3>

<bblockquote>
  <table border="1" cellpadding="0" cellspacing="2" width="95%">
    <tbody><tr>
      <td width="28%">
<b>이름</b></td>
      <td width="72%">
MD2withRSA, MD5withRSA, 및 SHA1withRSA</td>
    </tr>
    <tr>
      <td width="28%">
<b>형</b></td>
      <td width="72%">
<code>서명</code></td>
    </tr>
    <tr>
      <td valign="top" width="28%">
<b>설명</b></td>
      <td width="72%">
각각 MD2, MD5, 및 SHA­1 메세지 알고리즘을 RSA 암호화와 함께 사용하는 서명 알고리즘입니다. </td>
    </tr>
    <tr>
      <td width="28%">
<b><code>KeyPair</code> 알고리즘</b></td>
      <td width="72%">
<bblockquote>RSA</bblockquote>
</td>
    </tr>
    <tr>
      <td valign="top" width="28%">
<b>서명 포맷</b></td>
      <td width="72%">
RSA Laboratory 의 「공개키암호화 표준 노트 #1」로 정의의 DER encode PKCS1 블록. 암호화 데이터는 서명 첨부 데이터의 다이제스트입니다. </td>
    </tr>
  </tbody></table>
  </p></bblockquote>

<h3>DSA KeyPair 생성 알고리즘</h3>

<bblockquote>
<table border="1" cellpadding="0" cellspacing="2" width="95%">
    <tbody><tr>
      <td height="23" width="28%">
<b>이름</b></td>
      <td height="23" width="72%">
DSA</td>
    </tr>
    <tr>
      <td height="23" width="28%">
<b>형</b></td>
      <td height="23" width="72%">
<code>KeyPairGenerator</code></td>
    </tr>
    <tr>
      <td height="42" valign="top" width="28%">
<b>설명</b></td>
      <td height="42" width="72%">
이 알고리즘은, DSA 대응 NIST FIPS 186 에 기재의 열쇠의 페어 생성 알고리즘입니다. </td>
    </tr>
    <tr>
      <td height="41" width="28%">
<b>키 사이즈</b></td>
      <td height="41" width="72%">
계수 <code>p</code> 의 길이 (비트 단위). 512 에서 1024 의 범위에서, 64 의 배수일 필요가 있습니다. 디폴트의 키 사이즈는 1024 입니다. </td>
    </tr>
    <tr>
      <td height="23" valign="top" width="28%">
<b>파라미터의 디폴트 값:</b></td>
      <td height="23" width="72%">
<p>이하의 디폴트의 파라미터치는, 512, 768, 및 1024 비트의 키 사이즈용으로 사용합니다. </p>

<h5>512 비트의 열쇠 파라미터</h5>

<pre>SEED = b869c82b 35d70e1b 1ff91b28 e37a62ec dc34409b
counter = 123
p = fca682ce 8e12caba 26efccf7 110e526d b078b05e decbcd1e b4a208f3
    ae1617ae 01f35b91 a47e6df6 3413c5e1 2ed0899b cd132acd 50d99151
    bdc43ee7 37592e17
q = 962eddcc 369cba8e bb260ee6 b6a126d9 346e38c5

g = 678471b2 7a9cf44e e91a49c5 147db1a9 aaf244f0 5a434d64 86931d2d
    14271b9e 35030b71 fd73da17 9069b32e 2935630e 1c206235 4d0da20a
    6c416e50 be794ca4</pre>

<h5>768 비트의 열쇠 파라미터</h5>

<pre>SEED = 77d0f8c4 dad15eb8 c4f2f8d6 726cefd9 6d5bb399
counter = 263
p = e9e64259 9d355f37 c97ffd35 67120b8e 25c9cd43 e927b3a9 670fbec5
    d8901419 22d2c3b3 ad248009 3799869d 1e846aab 49fab0ad 26d2ce6a
    22219d47 0bce7d77 7d4a21fb e9c270b5 7f607002 f3cef839 3694cf45
    ee3688c1 1a8c56ab 127a3daf
q = 9cdbd84c 9f1ac2f3 8d0f80f4 2ab952e7 338bf511
g = 30470ad5 a005fb14 ce2d9dcd 87e38bc7 d1b1c5fa cbaecbe9 5f190aa7
    a31d23c4 dbbcbe06 17454440 1a5b2c02 0965d8c2 bd2171d3 66844577
    1f74ba08 4d2029d8 3c1c1585 47f3a9f1 a2715be2 3d51ae4d 3e5a1f6a
    7064f316 933a346d 3f529252</pre>

<h5>1024 비트의 열쇠 파라미터</h5>

<pre>SEED = 8d515589 4229d5e6 89ee01e6 018a237e 2cae64cd
counter = 92
p = fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80
    b6512669 455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b
    801d346f f26660b7 6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6
    1bf83b57 e7c6a8a6 150f04fb 83f6d3c5 1ec30235 54135a16 9132f675
    f3ae2b61 d72aeff2 2203199d d14801c7
q = 9760508f 15230bcc b292b982 a2eb840b f0581cf5

g = f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b
    3d078267 5159578e bad4594f e6710710 8180b449 167123e8 4c281613
    b7cf0932 8cc8a6e1 3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f
    0bfa2135 62f1fb62 7a01243b cca4f1be a8519089 a883dfe1 5ae59f06
    928b665e 807b5525 64014c3b fecf492a</pre>
</td>
    </tr>
  </tbody></table><p></p>
</bblockquote>

<h3>RSA KeyPair 생성 알고리즘</h3>

<bblockquote>
  <table border="1" cellpadding="0" cellspacing="2" width="95%">
    <tbody><tr>
      <td width="28%">
<b>이름</b></td>
      <td width="72%">
RSA</td>
    </tr>
    <tr>
      <td width="28%">
<b>형</b></td>
      <td width="72%">
<code>KeyPairGenerator</code></td>
    </tr>
    <tr>
      <td valign="top" width="28%">
<b>설명</b></td>
      <td width="72%">
이 알고리즘은, PKCS1 에 기재의 열쇠의 페어 생성 알고리즘입니다. </td>
    </tr>
    <tr>
      <td valign="top" width="28%">
<b>강도</b></td>
      <td width="72%">
	512 이상으로 8 의 배수의 임의의 정수
</td>
    </tr>
  </tbody></table>
</p></bblockquote>

<h3>DSA 파라미터 생성 알고리즘</h3>

<bblockquote>
  <table border="1" cellpadding="0" cellspacing="2" width="95%">
    <tbody><tr>
      <td width="28%">
<b>이름</b></td>
      <td width="72%">
DSA</td>
    </tr>
    <tr>
      <td width="28%">
<b>형</b></td>
      <td width="72%">
<code>ParameterGenerator</code></td>
    </tr>
    <tr>
      <td valign="top" width="28%">
<b>설명</b></td>
      <td width="72%">
이 알고리즘은, NIST FIPS 186 for DSA 에 기재의 파라미터 생성 알고리즘입니다. </td>
    </tr>
    <tr>
      <td valign="top" width="28%">
<b>강도</b></td>
      <td width="72%">

	계수 <code>p</code> 의 길이 (비트 단위). 512 에서 1024 의 범위에서, 64 의 배수일 필요가 있습니다. 디폴트의 키 사이즈는 1024 입니다.
</td>
    </tr>
  </tbody></table>
</bblockquote></bblockquote></bblockquote> <br>
<hr>

<!-- ==================================================== -->

<h1><a name="impl">구현 요건</a> </h1>

<bblockquote>
<p>이 항에서는, Java SE 6 구현의 시큐리티 알고리즘 요건을 정의합니다. 이 요건은, Java SE 6 구현과 이 알고리즘을 사용하는 어플리케이션의 상호 운용성을 향상하는 것을 의도하고 있습니다.

<p>구현 요건에는, 다음의 2 개가 있습니다.
<ul>
<li> 추천: Java SE 6 의 각 구현은, 지정된 알고리즘을 디폴트로 (인스톨시에) 지원하고 있어야 합니다.
<li> 필수: Java SE 6 의 각 구현은, 지정된 알고리즘을 디폴트로 (인스톨시에) 지원하고 있을 필요가 있습니다.  
</ul>

<p>이 항에서의 요건은, 알고리즘의 강도 또는 시큐리티의 지표와는<b>되지 않습니다</b>. 예를 들어, 근년 발달한 암호 해석에 의해, MD5 MessageDigest 알고리즘의 강도에 약점이 발견되었습니다. 알고리즘이 어플리케이션의 시큐리티 요건을 채우고 있는지 어떤지를 판단할 필요가 있습니다.
<p>알고리즘 또는 엔진이 리스트에 나타나지 않은 경우, 그 알고리즘 또는 엔진은 지정된 요건에 따르고 있지 않습니다.

<p>

<h3>Java 암호화 및 PKI 알고리즘</h3>

<bblockquote>

<p>Java SE 6 의 각 구현은, 다음의 겉(표)의 지정된 알고리즘 (모두 추천)을 디폴트로 (인스톨시에) 지원하고 있어야 합니다. Java SE (7)의 다음의 릴리스에서는, 다음의 표내의 각 알고리즘은 필수로 변경될 예정입니다. 이러한 요건은, 서드 파티 프로바이더에는 들어맞지 않습니다.

</p></bblockquote>

<table border="5" frame="border" align="center" width="90%"
cellpadding="5">

<thead>
<tr>
<th width="30%" BGCOLOR="#dedeef"> 엔진 </th>
<th width="50%" BGCOLOR="#dedeef"> 알고리즘명 </th>
<th width="20%" BGCOLOR="#dedeef"> 요건 </th>
</tr>
</thead>

<tbody>

<!-- ==================================================== -->
<tr>
<td>
<code>AlgorithmParameters</code>
</td>
<td>
DSA <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>CertificateFactory</code>
</td>
<td>
X. 509 <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>CertPathBuilder</code>
</td>
<td>
PKIX <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>CertPathValidator</code>
</td>
<td>
PKIX <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>CertStore</code>
</td>
<td>
Collection <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>Cipher</code> (알고리즘은<a href="crypto/CryptoSpec.html#trans">변환</a>으로서 지정). 구현은, 괄호내의 열쇠 사이즈까지 지원할 필요가 있습니다.
</td>
<td>
AES/CBC/NoPadding (128) <br> AES/CBC/PKCS5Padding (128) <br> AES/ECB/NoPadding (128) <br> AES/ECB/PKCS5Padding (128) <br> DES/CBC/NoPadding (56) <br> DES/CBC/PKCS5Padding (56) <br> DES/ECB/NoPadding (56) <br> DES/ECB/PKCS5Padding (56) <br> DESede/CBC/NoPadding (168) <br> DESede/CBC/PKCS5Padding (168) <br> DESede/ECB/NoPadding (168) <br> DESede/ECB/PKCS5Padding (168) <br> RSA/ECB/PKCS1Padding (2048) <br> RSA/ECB/OAEPPadding (2048) <br>
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>KeyFactory</code> (구현은, 괄호내의 열쇠 사이즈까지 지원할 필요가 있습니다)
</td>
<td>
DSA (1024) <br> RSA (2048) <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>KeyGenerator</code> (구현은, 괄호내의 열쇠 사이즈까지 지원할 필요가 있습니다)
</td>
<td>
AES (128) <br> DES (56) <br> DESede (168) <br> HmacMD5 (128) <br> HmacSHA1 (160) <br> HmacSHA256 (160) <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>KeyPairGenerator</code> (구현은, 괄호내의 열쇠 사이즈까지 지원할 필요가 있습니다)
</td>
<td>
DSA (1024) <br> RSA (2048) <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>KeyStore</code>
</td>
<td>
jks <br> pkcs12 <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>Mac</code> (구현은, 괄호내의 열쇠 사이즈까지 지원할 필요가 있습니다)
</td>
<td>
HmacMD5 (128) <br> HmacSHA1 (160) <br> HmacSHA256 (160) <br>
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>MessageDigest</code>
</td>
<td>
MD5 <br> SHA-1 <br> SHA-256 <br>
</td
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>SecretKeyFactory</code> (구현은, 괄호내의 열쇠 사이즈까지 지원할 필요가 있습니다)
</td>
<td>
AES (128) <br> DES (56) <br> DESede (168) <br>
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>서명</code>
</td>
<td>
MD5withRSA <br> SHA1withDSA <br> SHA1withRSA <br> SHA256withRSA <br>
</td>
<td>
추천<br>
</td>
</tr>
</tbody>
</table>

<h3>XML 서명 알고리즘</h3>

<bblockquote><p>
다음의 겉(표)는, XML 서명 (JSR 105) 구현의 알고리즘 요건을 나타내고 있습니다.
</p></bblockquote>

<table border="5" frame="border" align="center" width="90%"
cellpadding="5">

<thead>
<tr>
<th width="30%" BGCOLOR="#dedeef"> 엔진 </th>
<th width="50%" BGCOLOR="#dedeef"> 알고리즘명 </th>
<th width="20%" BGCOLOR="#dedeef"> 요건 </th>
</tr>
</thead>

<tbody>
<!-- ==================================================== -->
<tr>
<td>
<code>TransformService</code>
</td>
<td>
http://www.w3.org/2001/10/xml-exc-c14n# (<code>CanonicalizationMethod.EXCLUSIVE</code>) <br> 
</td>
<td>
필수<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>TransformService</code>
</td>
<td>
http://www.w3.org/2001/10/xml-exc-c14n#WithComments (<code>CanonicalizationMethod.EXCLUSIVE_WITH_COMMENTS</code>) <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>TransformService</code>
</td>
<td>
http://www.w3.org/TR/2001/REC-xml-c14n-20010315 (<code>CanonicalizationMethod.INCLUSIVE</code>) <br> 
</td>
<td>
필수<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>TransformService</code>
</td>
<td>
http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments (<code>CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS</code>) <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>TransformService</code>
</td>
<td>
http://www.w3.org/2000/09/xmldsig#base64 (<code>Transform.BASE64</code>) <br> 
</td>
<td>
필수<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>TransformService</code>
</td>
<td>
http://www.w3.org/2000/09/xmldsig#enveloped-signature (<code>Transform.ENVELOPED</code>) <br> 
</td>
<td>
필수<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>TransformService</code>
</td>
<td>
http://www.w3.org/TR/1999/REC-xpath-19991116 (<code>Transform.XPATH</code>) <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>TransformService</code>
</td>
<td>
http://www.w3.org/2002/06/xmldsig-filter2 (<code>Transform.XPATH2</code>) <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>XMLSignatureFactory</code>
</td>
<td>
http://www.w3.org/2000/09/xmldsig#sha1 (<code>DigestMethod.SHA1</code>) <br> 
</td>
<td>
필수<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>XMLSignatureFactory</code>
</td>
<td>
http://www.w3.org/2000/09/xmldsig#hmac-sha1 (<code>SignatureMethod.HMAC_SHA1</code>) <br> 
</td>
<td>
필수<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>XMLSignatureFactory</code>
</td>
<td>
http://www.w3.org/2000/09/xmldsig#dsa-sha1 (<code>SignatureMethod.DSA_SHA1</code>) <br> 
</td>
<td>
필수<br>
</td>
</tr>
<!-- ==================================================== -->
<tr>
<td>
<code>XMLSignatureFactory</code>
</td>
<td>
http://www.w3.org/2000/09/xmldsig#rsa-sha1 (<code>SignatureMethod.RSA_SHA1</code>) <br> 
</td>
<td>
추천<br>
</td>
</tr>
<!-- ==================================================== -->
</tbody>
</table>



<!-- ==================================================== -->
</body>
</html>
