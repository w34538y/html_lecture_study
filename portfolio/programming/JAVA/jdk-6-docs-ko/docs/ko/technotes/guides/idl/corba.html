<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML> <HEAD>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">


	<TITLE>CORBA 와 Java 기술 - xrath.com 에서 번역됨</TITLE> </HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<TABLE summary="layout" BORDER="0" WIDTH="50%">
<TR>
<TD WIDTH=50 ALIGN=LEFT>
<IMG SRC="../../../images/javalogo52x88.gif" ALT="Java" BORDER=0 WIDTH=52  HEIGHT=88>
</TD>




<TD ALIGN=CENTER VALIGN=TOP WIDTH=50>
<IMG SRC="images/omg_memb.gif" ALT="OMG" BORDER=0 >
</TD>
<TD ALIGN=RIGHT VALIGN=TOP WIDTH=50>
<IMG SRC="../../../images/sunlogo64x30.gif" ALT="Sun" BORDER=0 >
</TD>
</TR>

</TABLE>

<H1>CORBA 기술과 Java<SUP><FONT SIZE="-2">TM</FONT></SUP> 2 Platform Standard Edition</H1> <p></P>


<P>Java 2 Platform Standard Edition, v1. 4 는, Java CORBA ORB 및 Internet InterORB Protocol (IIOP)를 이용하는 Object Request Broker (ORB) 및 2 개의 CORBA 프로그래밍 모델을 제공하고 있습니다. 이 토픽에서는, CORBA 기술을 작성 및 배포하는 이러한 옵션에 대해 설명합니다.

<P>CORBA 기술은 Java 2 플랫폼에 불가결합니다. <A HREF="#orb">Object Request Broker (ORB)</a>,<A HREF="#rmi">RMI 프로그래밍 모델</a>용 API, 및 <A HREF="#idl">IDL 프로그래밍 모델</a>용 API 로 구성되어 있습니다.  
 </P> 

<P>Java 플랫폼의 이 릴리스로 구현되고 있는 스펙에 대한 자세한 것은,<a href="../../../api/org/omg/CORBA/doc-files/compliance.html">준거에 관한 문서</a>를 참조해 주세요.


<H2>Java SE 에서의 CORBA 의 이점의 활용</H2>

<P><a href="http://www.omg.org/corba/">Common Object Request Broker Architecture (CORBA)</a>  기술은 이기종간 컴퓨팅의 오픈 표준입니다. CORBA 는 분산 객체 시스템, 그 시스템를 지원하는 서비스, 및 발설어와의 상호 운용성을 제공해 Java<SUP><FONT SIZE="-2">TM</FONT></SUP> 플랫폼을 보완합니다. Java 플랫폼은 「Write Once, Run Anywhere<SUP><FONT  SIZE="-2">TM</FONT></SUP>」이식성 기능, 생산성의 높은 런타임, 및 매우 견뢰한 플랫폼을 제공해 CORBA 를 보완합니다. CORBA 를 이용하는 Java 플랫폼과 다른 주요한 엔타프라이즈 기술을 결합하면, Java 2 플랫폼은 분산 기술 솔루션의 최고 레벨의 플랫폼이 됩니다.   </P> 

<P> CORBA 표준은, 실적과 상호 운용성이 있는 인프라스트럭쳐(infrastructure)를 Java 플랫폼에 제공합니다. IIOP (Internet Inter-ORB Protocol)는, 시스템을 구동하는 객체 컴퍼넌트간의 통신을 관리합니다. Java 플랫폼은 주요한 모든  operating system로 동작하는, 이식성이 있는 객체 인프라스트럭쳐(infrastructure)를 제공합니다. CORBA 는 네트워크의 투과성을 제공해, Java 는 구현의 투과성을 제공합니다.



<A NAME="orb"></A> 
<H3>Object Request Broker</H3>

<P>Object Request Broker (ORB)는, Java 2 Platform Standard Edition 의 버젼 1.3 이후에 탑재되고 있습니다. ORB 는, IIOP 통신을 사용한 만큼 산컴퓨팅에 사용할 수 있는 런타임 컴퍼넌트입니다.  

<P><STRONG>주: 다른 언어로 쓰여진 ORB 간에서의 통신이 가능할 것입니다가, Java ORB 와 다른 벤더의 ORB 와의 상호 운용성은 아직 테스트되고 있지 않습니다. </STRONG>

<P> Object Management Group (OMG)는, CORBA 의 스펙을 책정해 발행하고 있는 업계 단체입니다. 벤더가 스펙을 구현해, Object Request Brokers (ORB)로서 알려진 제품을 작성합니다. 버젼 1.2 이후의 Java<sup><font size="-2">TM</font></sup> Platform Standard Edition 에 ORB 가 탑재되어 Java 2 Platform Standard Edition 를 배치하는 경우에 이용할 수 있게 된 것은, 개발자에게 있어 밝은 뉴스입니다. <A HREF="../../api/org/omg/CORBA/ORB.html"><TT><A HREF="../../../api/org/omg/CORBA/ORB.html"><TT>ORB</TT></A>  클래스의 자세한 것은, 링크를 참조해 주세요.


<P>Java CORBA ORB 는 RMI 프로그래밍 모델과 IDL 프로그래밍 모델의 양쪽 모두를 지원하고 있습니다. 어느쪽이나, 와이어 레벨의 통신 프로토콜로서 IIOP 를 사용할 수 있습니다.

<H2>CORBA 프로그래밍 모델의 도입</H2>



<H3>CORBA 프로그래밍 모델의 역사</H3>

    

<P>1997 년에 원격 메소드 호출 (RMI)이 JDK 1.1 에 도입되었습니다. 당초, RMI 는 원격 수속 호출 (RPC)로부터 자연스럽게 파생한 것이라고 하는 위치설정으로, 다른 가상 머신의 Java 객체간, 또 물리적으로 다른 머신의 Java 객체간의 호출을 올바르게 실행하기 위한의 것이었습니다.  



<P>1998 년에 JDK 1.2 가 등장해, CORBA 와의 상호 운용성과 통합성을 가지는 Java API 인 Java IDL 가 도입되었습니다. Java IDL 에는 IIOP 를 지원하는 Java 베이스의 ORB 와 IDL 와 Java 간의 컴파일러인 <TT>idltojava</TT> 가 탑재되어 클라이언트 사이드의 Stub와 서버 사이드의 스켈리턴을 생성할 수 있게 되었습니다. ORB 는, RMI over IIOP 프로그래밍 모델과 Java IDL 프로그래밍 모델을 양쪽 모두 지원하고 있습니다.

<P>1999 년에, Java 플랫폼의 표준 확장 기능으로서 RMI over IIOP 가 JDK 1.1. 6 및 1.2 에 도입되었습니다. 현재는, RMI over IIOP 는 J2SE 버젼 1.3 이후에 짜넣어지고 있습니다. 그 때문에, 옵션으로서의 다운로드는 종료하고 있습니다만, 어카이브(archive)로부터 입수할 수도 있습니다.

<P>OMG 는 IIOP 스펙을 최종적으로 변경해, RMI 의 JDK 1.1 기능의 대부분이 지원되게 되었습니다. RMI over IIOP 는, 표준 확장 기능으로서 JDK 1.2 에 도입되었습니다. 이것에 의해, Java 프로그램 언어로 기술된 원격 객체에 대해, IIOP 를 사용해 임의의 언어로부터 액세스 할 수 있게 되었습니다.  
  
<P>J2SE v1. 3 에서는,100% Pure Java<sup><font  size="-2">TM</font></sup> 의 IDL 와 Java 간의 컴파일러인 <TT>idlj</TT> 가 새롭게 도입되어 IDL 의 abstract 인터페이스와 값의 형태도 지원되었습니다. v1. 3 에서는, RMI over IIOP 도 JDK 에 짜넣어졌습니다.

<P>2001 년에 도입된 현재의 버젼 J2SE v1. 4 에는, Portable Object Adapter, Portable Interceptors, Interoperable Naming Service, GIOP 1.2, 및 동적 Any 의 지원가 짜넣어지고 있습니다. J2SE v1. 4 에는, Object Request Broker Daemon (ORBD)도 짜넣어지고 있습니다. ORBD 는, 클라이언트로부터 CORBA 환경의 서버에 있는 지속 객체를 투과적으로 검색해 호출하기 위해서(때문에) 사용합니다. 또,<tt>servertool</tt> 도 짜넣어지고 있습니다. 이 툴로 제공되는 커멘드행 인터페이스를 사용해, 어플리케이션 프로그래머는 지속 서버의 등록, 등록 해제, 기동, 종료을 실시할 수가 있습니다. J2SE v1. 4 의 신기능의 상세한 것에 대하여는,<a href="jidlChanges.html"><em>「J2SE 1.3 으로 1.4 간에서의 CORBA 기능의 변경점」</em></a> 을 참조해 주세요.

<H3>CORBA 프로그래밍 모델의 비교</H3>

<P>다른 언어간, 다른 벤더간의 상호 운용성은 Internet InterORB Protocol (IIOP)에 의해 실현됩니다. IIOP 는, IDL 나 Java RMI 의 어느쪽이든으로 쓰여진 만큼 산어플리케이션용의 전송 프로토콜입니다.   

<P>IDL 프로그래밍을 사용하는 경우는, 인터페이스가 방법이라고입니다. IDL 에서는, 원격 접근으로부터 불러 출일이 생기는 엔트리 포인트 (불려 간 수속이 받아들이는 인수의 형태등)나, 반환된 정보의 값이나 출력 파라미터등을 정의합니다. 프로그래머는 IDL 를 사용해, 통신 프로세스간을 이동하는 엔트리 포인트나 데이터형을 표준 언어인것 같이 취급할 수가 있습니다.

<P>CORBA 는 언어로부터 중립의 시스템으로, 인수의 값이나 반환값은 사용하는 구현 언어로 나타낼 수가 있는 것에 제한됩니다. CORBA 에서는, 객체의 방향은 참조용으로 건네줄 수가 있는 객체에 제한되는지, 또는 전체의 시스템로 미리 정의되고 있습니다. 객체 코드 자체를 머신간에 건네줄 수가 없습니다. 건네주는 형태도 되돌리는 형태도 인터페이스로 선언되고 있을 필요가 있습니다.

<P>RMI 에서는, 인터페이스와 구현은 같은 언어로 기술되기 (위해)때문에, 양자를 매핑 할 필요는 없습니다. 언어 레벨의 객체 (코드)를 있는 프로세스로부터 다음의 프로세스에 건네줄 수가 있습니다. 값은, 선언된 형태는 아니고 실제의 형태로 돌려주어집니다. 또는, 인터페이스를 컴파일 해 IIOP Stub와 스켈리턴을 생성하면(자), 다른 CORBA 준거의 언어로부터 객체에 액세스 할 수 있게 됩니다.

<A NAME="rmi"></A> 
<H3>RMI 프로그래밍 모델</H3> 

<P><B>RMI 프로그래밍 모델이란</B></P>


<P>RMI 프로그래밍 모델은,<TT>rmi</TT> API 를 사용하는 분산 컴퓨팅을 위한 일반적인 객체 모델입니다. Java Remote Method Protocol (JRMP)를 사용해 Java 프로그램 언어만으로 작업하는 일도, Internet InterORB Protocol (IIOP)를 사용해 다른 CORBA 대응 프로그램 언어로 작업할 수도 있습니다.  

 
<P>RMI 프로그래밍 모델은, Java<SUP><FONT  SIZE="-2">TM</FONT></SUP> 2 Platform Standard Edition 에 짜넣어지고 있어 Object Request Broker (ORB)와 <tt>rmic</tt> 컴파일러로 구성됩니다. <TT><TT>rmic</TT> 컴파일러는, JRMP 프로토콜 또는 IIOP 프로토콜을 사용하는 원격 객체의 Stub, 스켈리턴, 및 Tie 를 생성하기 위해서 사용됩니다. <TT>rmic</TT> 컴파일러로 OMG IDL 를 생성할 수도 있습니다. <TT>rmic</TT> 의 사용법에 대해서는, 「<A  HREF="../../tools/solaris/rmic.html">rmic - Java RMI Stub 컴파일러</a>」를 참조해 주세요.

<P><a href="../rmi-iiop/rmi_iiop_pg.html">「RMI over IIOP 개발자 안내」</a>에서는,RMI 를 JRMP 로 사용하는 경우와 IIOP 로 사용하는 경우의 차이에 대해 해설하고 있습니다.

<P><B>어떠한 경우에 IDL 프로그래밍 모델은 아니고 RMI 프로그래밍 모델을 사용할까</B></P>

<P>RMI 프로그래밍 모델에서는, 개발자는 Java 프로그램 언어만을 사용할 수 있으므로 분산형 어플리케이션의 개발 속도가 향상합니다. RMI 프로그래밍 모델을 사용해 Java 테크놀러지 베이스의 분산형 어플리케이션을 작성하는 경우, 배워야 할 분리된 인터페이스 정의 언어 (IDL)나 매핑이라는 것은 없습니다. RMI 프로그래밍 모델에게는 유연성이 있어, 개발자는 어플리케이션 컴퍼넌트간에 직렬화 가능 Java 객체 (Objects By Value)를 건네줄 수가 있습니다. IDL 프로그래밍 모델과 같게, RMI 프로그래밍 모델은, 다수의 벤더나 사용자의 참가하는 Java Community Process (JCP)로 정의된 오픈 표준에 근거하고 있습니다. IDL 프로그래밍 모델과 같게, RMI 프로그래밍 모델에서도, 통신 프로토콜로서 Internet Inter-ORB Protocol (IIOP)를 사용할 수 있습니다. IIOP 에 의해, C++, Smalltalk, 그 외의 CORBA 대응 언어로 기술된 어플리케이션 컴퍼넌트가 Java 플랫폼에서 실행하는 컴퍼넌트와 통신할 수 있기 (위해)때문에, 종래의 어플리케이션과 Java 플랫폼의 통합이 용이하게 됩니다.

<P>RMI 프로그래밍 모델을 사용하면(자), 개발자는 원격 인터페이스를 Java 프로그램 언어로 기술해, Java 테크놀러지와 Java RMI API 를 사용하는 것만으로 인터페이스를 구현할 수 있습니다. 이러한 인터페이스는 OMG 매핑이 지원하는 다른 언어나, 벤더가 제공하는 그 언어의 ORB 로 구현할 수가 있습니다. 또 클라이언트는, 원격의 Java 기술 베이스의 인터페이스로부터 파생한 IDL 를 사용해 다른 언어로 쓸 수도 있습니다.   

<P><B>RMI 프로그래밍 모델의 상세한 것에 대하여</B></P>
<P><UL>
<P><LI>RMI over IIOP 의 자세한 것은,<A  HREF="../rmi-iiop/index.html">「RMI over IIOP 문서」</a>를 참조해 주세요.

<P><LI>RMI over JRMP 의 자세한 것은,<A  HREF="../rmi/index.html">「RMI 문서」</a>를 참조해 주세요.

<P><LI>RMI over IIOP 를 사용한 입문 튜토리얼은,<A  HREF="../rmi-iiop/tutorial.html">「튜토리얼: RMI over IIOP 입문」</a>을 참조해 주세요. </A> .

<P><LI>Java 인터페이스로부터 OMG IDL 에의 매핑의 자세한 것은,<a href="http://cgi.omg.org/cgi-bin/doc?ptc/00-01-06">「Java Language to OMG IDL Mapping Specification」</a>를 참조해 주세요.
</UL>
<P>
<A NAME="idl"></A> 
<H3>IDL 프로그래밍 모델</H3> 

<P><B>IDL 프로그래밍 모델이란</B></P>

<P>Java<SUP><FONT  SIZE="-2">TM</FONT></SUP> IDL 로서 알려진 IDL 프로그래밍 모델은, Java CORBA ORB 와 <TT>idlj</TT> 컴파일러의 양쪽 모두로 구성되어 있어 Java CORBA ORB 를 사용하고 있는 Java 바인딩에 OMG IDL 를 매핑 합니다.  또, 일련의 API 도 포함되어 있어 이것들은 API 색인의 패키지 섹션으로부터 <a href="../../../api"><tt>org.omg</tt></a>  라고 하는 접두사를 선택해 검색할 수 있습니다.

<P>Java IDL 는, Java 플랫폼에 CORBA (Common Object Request Broker Architecture) 기능을 추가하는 것으로써, 표준 규격에 준거한 상호 운용성 및 접속 기능을 제공합니다. Java IDL 를 사용하면(자), Web 대응의 분산형 Java 어플리케이션으로부터, Object Management Group 에 의한 업계표준의 IDL (Object Management Group Interface Definition Language)나 IIOP (Internet Inter-ORB Protocol) 경유로, 원격 네트워크 서비스상의 오퍼레이션을 투과적으로 호출할 수가 있습니다. 런타임 컴퍼넌트에는, IIOP 통신을 사용한 만큼 산컴퓨팅용의 Java ORB 가 포함되어 있습니다.  
    
<P>IDL 프로그래밍 모델을 사용하려면 , Object Management Group (OMG)의 Interface Definition Language (IDL)를 사용해 원격 인터페이스를 정의한 후,<TT>idlj</TT> 컴파일러를 사용해 이러한 인터페이스를 컴파일 합니다. 인터페이스 정의 파일로 <TT>idlj</TT> 컴파일러를 실행하면(자), Java 버젼의 인터페이스가 작성되어 동시에 Stub와 스켈리턴의 클래스 코드 파일도 생성되어 어플리케이션을 ORB 에 접속할 수 있게 됩니다.   
    
    
<P> Java<SUP><FONT SIZE="-2">TM</FONT></SUP> IDL 는 Java 2 Platform Standard Edition, v1. 2 이후의 릴리스의 일부입니다. Java IDL 를 사용해 어플리케이션을 개발하려면 ,<A HREF="../../tools/share/idlj.html">Java<SUP><FONT SIZE="-2">TM</FONT></SUP> IDL 컴파일러</A>  <TT>idlj</TT> 를 사용합니다.  이것은 버젼 1.3 이후의 J2SE 인스톨시에 매회 구현됩니다.   </P>





<P><B>어떠한 경우에 RMI 프로그래밍 모델은 아니고 IDL 프로그래밍 모델을 사용할까</B></P>

<P>OMG IDL (Interface Definition Language)는, 분산형 어플리케이션으로 프로그램 언어에 의존하지 않는 오퍼레이션 인터페이스를 기술하기 위해서 설계된, 순수하게 정의용의 언어입니다. OMG 에서는 IDL 로부터 다른 언어에의 매핑을 지정하고 있습니다. 이러한 언어에는 Java, C, C++, Lisp, Python, Smalltalk, COBOL, 및 Ada 가 있습니다. OMG IDL 의 구문을 매핑 하면(자), 선택한 프로그램 언어의 대응하는 구문으로 번역됩니다. Java IDL 는 CORBA 스펙의 구현입니다. 예를 들어, Java IDL Compiler,<TT>idlj</TT> 를 사용하면(자), IDL 인터페이스를 Java 에 매핑 해 Java 에 의한 클라이언트 클래스를 구현할 수 있습니다. 다음에 IDL-to-C++ 컴파일러와 C++ ORB 를 사용해 같은 IDL 를 C++ 에 매핑 해, 그 언어로 서버를 구현하면(자), Java 클라이언트와 C++ 서버는, ORB 를 개입시켜 서로 교환할 수 있습니다.   </P>

<P><STRONG>주: 다른 언어로 쓰여진 ORB 간에서의 통신이 가능할 것입니다가, Java ORB 와 다른 벤더의 ORB 와의 상호 운용성은 아직 테스트되고 있지 않습니다. </STRONG>

<P><B>IDL 프로그래밍 모델의 상세한 것에 대하여</b></P>
<P>
<UL>
<P><LI>IDL 프로그래밍 모델의 자세한 것은,<A  HREF="index.html">Java IDL 메뉴얼</a>을 참조해 주세요.

<P><LI>IDL 프로그래밍 모델의 입문 튜토리얼은,<A  HREF="GShome.html">튜토리얼 :Java IDL 입문</a>을 참조해 주세요.
<P><LI>IDL 로부터 Java 언어에의 매핑의 자세한 것은,<a href="http://cgi.omg.org/cgi-bin/doc?ptc/00-01-08">「OMG IDL to Java Language Mapping Specification」</a>를 참조해 주세요.   
</UL>
 <P> 
 
<H3>IDL 프로그래밍 모델과 RMI 프로그래밍 모델의 비교</H3>
 
 
<P>분산형 CORBA 어플리케이션의 작성에는 몇개의 정의 방법이 있습니다. 다음에 일반적인 방법을 나타냅니다.
 
 <P>
 <UL>
<LI>지금까지,<A  HREF="index.html">IDL</A>  를 사용해 CORBA 어플리케이션을 개발하고 있는 경우는, 환경을 그대로 사용할 수가 있습니다. IDL 를 사용해 인터페이스를 작성해, Java 프로그램 언어를 사용해 클라이언트와 서버 어플리케이션을 정의합니다. 이것에 의해, Java 의 「Write Once, Run Anywhere<SUP><FONT SIZE="-2">TM</FONT></SUP>」이식성 기능, 생산성의 높은 실행 환경, 및 매우 견뢰한 플랫폼등의 이점을 활용할 수가 있습니다.   
 <P>
<LI>어플리케이션이 모두 Java 프로그램 언어로 쓰여져 있는 경우,<A HREF="../rmi/index.html">Java RMI</A>  를 사용하는 것으로, 다른 가상 머신의 Java 객체간 및 다른 물리 머신의 Java 객체간에 통신을 실시할 수가 있습니다. IIOP 옵션을 가지지 않는 Java RMI 를 사용하면(자), 코드 이식성의 강함이나, 시큐리티, garbage collection를 활용할 수가 있습니다.
 <P>
<LI>현재, 대부분의 신규 어플리케이션을 Java 프로그램 언어로 쓰고 있지만, 다른 언어로 쓰여져 있는 종래의 어플리케이션도 유지할 필요가 있는 경우는,<A HREF="../rmi-iiop/index.html">IIOP</A>  컴파일러 옵션이 있는 Java RMI 를 사용합니다.   
 </UL>


<H2>CORBA 및 J2EE 에 대해</H2>

<P>Java IDL 및 RMI over IIOP 외에, J2EE 에는 Enterprise JavaBeans<SUP><FONT SIZE="-2">TM</FONT></SUP> 기술 (EJB<SUP><FONT SIZE="-2">TM</FONT></SUP>)도 짜넣어지고 있습니다.

<P><a href="http://java.sun.com/products/ejb/index.jsp">Enterprise JavaBeans</a>  는, Java 2 Platform, Enterprise Edition 에 포함되어 있는 기능입니다. EJB 의 서버측 컴퍼넌트 모델을 사용하면(자), 트랜잭션(transaction)에 적절한, 확장성과 이식성의 높은 미들웨어 컴퍼넌트를 간단하게 개발할 수 있습니다. EJB 서버를 사용하는 것으로, 트랜잭션(transaction), 시큐리티, 데이타베이스 접속이라고 하는 미들웨어 서비스가 자동적으로 지원되기 (위해)때문에, 미들웨어 개발의 복잡함이 경감됩니다.  

<P>EJB 에서는, 분산 객체 모델로서 RMI over IIOP 를 사용해, 분산 트랜잭션(transaction) 모델로서 Java Transaction Service (JTS)를 사용합니다. 이기종 서버 환경에서의 EJB 상호 운용성을 위해서(때문에) RMI over IIOP 프로토콜을 사용해 Enterprise JavaBeans 를 구현했을 경우는, EJB 아키텍쳐(architecture)로부터 CORBA 에의 표준 매핑에 의해, 다음과 같은 상호 운용이 가능하게 됩니다.  
 <P><UL>
<LI>어느 벤더의 ORB 를 사용하고 있는 Java 클라이언트가, 다른 벤더의 제공하는 EJB 서버에 있는 엔터프라이즈 Bean 에 액세스 할 수 있도록(듯이) 한다 

<LI>어느 EJB 서버의 엔터프라이즈 Bean 가, 다른 EJB 서버의 엔터프라이즈 Bean 에 액세스 할 수 있도록(듯이) 한다
<LI> Java 플랫폼 이외의 CORBA 클라이언트가, 임의의 엔터프라이즈 Bean 객체에 액세스 할 수 있도록(듯이) 한다 
</UL>

 <P> 
 <HR> 
<TABLE summary="layout" BORDER="0" WIDTH="100%">
<TR VALIGN=TOP>

<TD>
<P><FONT SIZE="-2"><A HREF="../../../legal/SMICopyright.html">Copyright &#169;</A>  2002 <A HREF="http://www.sun.com/">Sun Microsystems, Inc. </A> All Rights Reserved. </FONT></P>
</TD>

<TD ALIGN=RIGHT>
<IMG SRC="../../../images/sunlogo64x30.gif" ALT="Sun" BORDER=0 WIDTH=64 HEIGHT=30> <BR> <FONT SIZE="+1"><i>Java Software</i></FONT>
</TD>

</TR>
</TABLE>

 </BODY> 
 </HTML>
