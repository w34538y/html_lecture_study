<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><title>HotSpot VM 내의 DTrace 프로브 - xrath.com 에서 번역됨</title>



<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></head><body><h1>HotSpot VM 내의 DTrace 프로브</h1>
<ul>
<li> <a href="#Dtrace_Probes_in_HotSpot">개요</a> 
</li><li> <a href="#The_HotSpot_i_Provider">「hotspot」프로바이더</a> 

<ul>
<li> <a href="#VM_Lifecycle_Probes">VM 라이프 사이클 프로브</a> 
</li>
<li> <a href="#Thread_Lifecycle_Probes">thread 라이프 사이클 프로브</a> 
</li>
<li> <a href="#Classloading_Probes">클래스 로드 프로브</a> 
</li>
<li> <a href="#Garbage_Collection_Probes">가베지 컬렉션 프로브</a> 
</li>

<li> <a href="#Method_Compilation_Probes">메소드 컴파일 프로브</a> 
</li>
<li> <a href="#Monitor_Probes">모니터 프로브</a> 
</li>
<li> <a href="#Application_Tracking_Probes">어플리케이션 추적 프로브</a> 
</li>
</ul>
</li>
<li> <a href="#The_HotSpot_jni_i_Provider">「hotspot_jni」<i></i> 프로바이더</a> 

</li>
<li> <a href="#Reference">참조</a> 
</li>
</ul>


<p>
</p><h1><a name="Dtrace_Probes_in_HotSpot"> </a> 개요 </h1>
<p>
Solaris 10 에서의 DTrace 의 도입에 의해, DTrace 지원가 Java SE 6 HotSpot VM 에 추가되었습니다. 「hotspot」 및 「hotspot_jni」프로바이더는 JVM 의 내부 상태, 액티버티, 및 실행중의 Java 어플리케이션을 감시하기 위해서 사용할 수 있는 프로브를 작성합니다. 프로브는 모두 USDT 프로브이며, JVM 프로세스의 프로세스 ID 를 사용해 액세스 됩니다. 프로브의 상세한 것에 대하여는 다음의 항으로, API 에 대해서는 참조의 항으로 설명합니다.
</p><p>
</p><h2><a name="The_HotSpot_i_Provider"> </a> 「hotspot」프로바이더</h2>
<p>
「hotspot」프로바이더는 VM 의 존속 기간, thread의 개시 및 종료 이벤트, 가베지 컬렉션 및 메모리 풀 통계, 메소드 컴파일, 및 감시 활동의 추적에 사용할 수 있는 프로브를 작성합니다. 기동 플래그에 의해, 메소드에 들어가는 프로브나 메소드로부터 돌아오는 프로브등의 실행중의 Java 프로그램, 및 객체 할당의 감시에 사용할 수 있는 추가 프로브가 유효하게 됩니다. 모든 「hotspot」프로브는 VM 라이브러리 (<b>libjvm.so</b>)를 기준으로 하고 있기 (위해)때문에, VM 가 파묻힌 프로그램으로부터도 제공됩니다.

</p><p>
프로바이더내의 프로브가 많게는, VM 상태에 관한 상세를 제공하기 위해서 검사할 수 있는 인수가 있습니다. 이러한 프로브의 인수의 상당수는, 프로브 기동을 서로 링크하기 위해서 사용할 수 있는 불투명한 ID 입니다. 다만, 캐릭터 라인등의 데이터도 제공됩니다. 캐릭터 라인치가 제공되는 경우, 그것들은 항상, 종료되어 있지 않은 변경된 UTF-8 데이터 (<a href="http://java.sun.com/docs/books/vmspec/">JVM spec</a>  :4. 4.7 을 참조)에의 포인터와 그 데이터의 범위를 나타내는 길이의 값의 페어입니다. 캐릭터 라인 데이터는 (ASCII 의 범위외의 문자가 없는 경우에서도) NUL 문자로 종료되고 있는 보증은 없기 때문에, 길이로 종료되는 <tt>copyinstr()</tt> 편입을 사용해, 프로세스로부터 캐릭터 라인 데이터를 읽어낼 필요가 있습니다.
</p><p>
</p><h3><a name="VM_Lifecycle_Probes"> </a>  VM 라이프 사이클 프로브</h3>
<p>
다음에, VM 라이프 사이클에 관계하는 프로브를 나타냅니다. 여기에서는 인수를 가지는 것은 없습니다.
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>vm-init-begin</tt> </td><td bgcolor="#ffffcc"> VM 초기화가 개시할 경우에 기동하는 프로브</td></tr>

<tr><td align="center" bgcolor="#ffffff"> <tt>vm-init-end</tt> </td><td bgcolor="#ffffff"> VM 초기화가 종료할 경우에 기동하는 프로브로, VM 는 어플리케이션 코드의 실행을 개시할 준비가 되어 있습니다</td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>vm-shutdown</tt> </td><td bgcolor="#ffffcc"> 프로그램 종료 또는 에러에 의해 VM 가 종료 할 경우에 기동하는 프로브</td></tr>
</tbody></table>
<p>
</p><h3><a name="Thread_Lifecycle_Probes"> </a>  thread 라이프 사이클 프로브</h3>

<p>
thread의 개시 및 종료 이벤트의 추적에, 다음의 2 개의 프로브를 사용할 수 있습니다.  
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>thread-start</tt> </td><td bgcolor="#ffffcc"> thread가 개시될 때 기동하는 프로브. 다음의 인수를 지정합니다</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>thread-stop</tt> </td><td bgcolor="#ffffff"> thread가 완료했을 때에 기동하는 프로브. 다음의 인수를 지정합니다</td></tr>
</tbody></table>

<p>
이러한 프로브는, 다음의 인수를 가지고 있습니다.
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>args[0]</tt> </td><td bgcolor="#ffffcc"> thread명을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[1]</tt> </td><td bgcolor="#ffffff"> thread명 데이터의 길이 (바이트 단위)</td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>args[2]</tt> </td><td bgcolor="#ffffcc"> Java thread ID. 이것은 thread 인수를 포함하는 것 외의 HotSpot VM 프로브에 대응하는 값입니다</td></tr>

<tr><td align="center" bgcolor="#ffffff"> <tt>args[3]</tt> </td><td bgcolor="#ffffff"> 네이티브 /OS thread ID. 이것은 호스트  operating system에 의해 할당할 수 있는 ID 입니다</td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>args[4]</tt> </td><td bgcolor="#ffffcc"> 이 thread가 demon인가 어떤가를 나타내는 불리언 값. 값 0 은, demon 이외의 thread를 나타냅니다</td></tr>
</tbody></table>
<p>
</p><h3><a name="Classloading_Probes"> </a>  클래스 로드 프로브</h3>

<p>
클래스의 로드 및 언로드 액티버티의 추적에, 2 개의 프로브를 사용할 수 있습니다.   
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>class-loaded</tt> </td><td bgcolor="#ffffcc"> 클래스가 로드 되었을 때에 기동하는 프로브</td></tr>
<tr><td align="right" bgcolor="#ffffff"> <tt>class-unloaded</tt> </td><td align="center" bgcolor="#ffffff"> 클래스가 시스템으로부터 언로드되었을 때에 기동하는 프로브</td></tr>
</tbody></table>

<p>
이러한 프로브는, 다음의 인수를 가지고 있습니다.
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>args[0]</tt> </td><td bgcolor="#ffffcc"> 로드 된 클래스의 이름을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[1]</tt> </td><td bgcolor="#ffffff"> 클래스명 데이터의 길이 (바이트 단위) </td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>args[2]</tt> </td><td bgcolor="#ffffcc">
클래스 로더 ID. VM 내의 클래스 로더의 일의의 식별자입니다. 이것은, 클래스를 로드한 클래스 로더입니다</td></tr>

<tr><td align="center" bgcolor="#ffffff"> <tt>args[3]</tt> </td><td bgcolor="#ffffff"> 클래스가 공유 클래스인가 어떤가 (클래스가 공유 어카이브(archive)로부터 로드 되었는지 어떠했는지)를 나타내는 불리언 값</td></tr>
</tbody></table>
<p>
</p><h3><a name="Garbage_Collection_Probes"> </a>  가베지 컬렉션 프로브</h3>
<p>
시스템 전체의 가베지 컬렉션 사이클의 기간을 측정하기 위해서 사용할 수 있는 프로브가 있습니다 (개시 및 종료가 정의되고 있는 가비지 컬렉터에 대해). 각 메모리 풀을 개별적으로 추적할 수 있습니다. 풀 컬렉션의 개시와 종료의 양쪽 모두로, 개개의 풀의 프로브는 메모리 매니저의 이름, 풀명, 및 풀 사용 상황의 정보를 건네줍니다.  </p><p>
제공되는 가베지 컬렉션 관련의 프로브는, 다음과 같습니다.
</p><p>

</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>gc-begin</tt> </td><td bgcolor="#ffffcc">
시스템 전체의 컬렉션이 개시 되려고 하고 있을 때 기동하는 프로브. 인수가 1 개 있어 (arg[0]), 이 인수는, 이것이 풀 가베지 컬렉션인가 어떤가를 나타내는 불리언 값입니다.  </td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>gc-end</tt> </td><td bgcolor="#ffffff"> 시스템 전체의 컬렉션이 완료했을 때에 기동하는 프로브. 인수는 없습니다.  </td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>mem-pool-gc-begin</tt> </td><td bgcolor="#ffffcc"> 개개의 메모리 풀이 수집 되려고 하고 있을 때 기동하는 프로브. 다음의 인수를 지정합니다 </td></tr>

<tr><td align="center" bgcolor="#ffffff"> <tt>mem-pool-gc-end</tt> </td><td bgcolor="#ffffff"> 개개의 메모리 풀이 수집된 후에 기동하는 프로브. 다음의 인수를 지정합니다 </td></tr>
</tbody></table>
<p>
메모리 풀 프로브의 인수는, 다음과 같습니다.
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>args[0]</tt> </td><td bgcolor="#ffffcc"> 이 메모리 풀을 관리하는 매니저의 이름을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>

<tr><td align="center" bgcolor="#ffffff"> <tt>args[1]</tt> </td><td bgcolor="#ffffff"> 매니저명 데이터의 길이 (바이트 단위)</td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>args[2]</tt> </td><td bgcolor="#ffffcc"> 메모리 풀의 이름을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[3]</tt> </td><td bgcolor="#ffffff"> 메모리 풀명 데이터의 길이 (바이트 단위)</td></tr>

<tr><td align="center" bgcolor="#ffffcc"> <tt>args[4]</tt> </td><td bgcolor="#ffffcc"> 메모리 풀의 초기 사이즈 (바이트 단위)</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[5]</tt> </td><td bgcolor="#ffffff"> 메모리 풀내의 사용중의 메모리량 (바이트 단위)</td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>args[6]</tt> </td><td bgcolor="#ffffcc"> 메모리 풀내의 위탁이 끝난 페이지수</td></tr>

<tr><td align="center" bgcolor="#ffffff"> <tt>args[7]</tt> </td><td bgcolor="#ffffff"> 메모리 풀의 최대 사이즈</td></tr>
</tbody></table>
<p>
</p><p>
</p><h3><a name="Method_Compilation_Probes"> </a>  메소드 컴파일 프로브</h3>
<p>
어느 메소드가 어느 컴파일러에 의해 컴파일 되고 있는지를 나타내기 위해서(때문에), 프로브를 사용할 수 있습니다. 프로브는, 컴파일 된 메소드의 인스톨 및 언인스톨을 추적하기 위해서 사용할 수도 있습니다.
</p><p>
메소드 컴파일의 개시 및 종료를 나타내는 프로브는, 다음과 같습니다.

</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>method-compile-begin</tt> </td><td bgcolor="#ffffcc"> 메소드 컴파일이 개시되었을 때에 기동하는 프로브. 다음의 인수를 지정합니다 </td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>method-compile-end</tt> </td><td bgcolor="#ffffff"> 메소드 컴파일이 완료했을 때에 기동하는 프로브. 다음에 일람 하는 인수 이외에,<tt>argv[8]</tt> 은 컴파일이 성공했는지의 여부를 나타내는 불리언 값입니다 </td></tr>

</tbody></table>
<p>
메소드 컴파일 프로브의 인수는, 다음과 같습니다.
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>args[0]</tt> </td><td bgcolor="#ffffcc"> 이 메소드를 컴파일 하고 있는 컴파일러의 이름을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[1]</tt> </td><td bgcolor="#ffffff"> 컴파일러명 데이터의 길이 (바이트 단위)</td></tr>

<tr><td align="center" bgcolor="#ffffcc"> <tt>args[2]</tt> </td><td bgcolor="#ffffcc"> 컴파일 되고 있는 메소드의 클래스의 이름을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[3]</tt> </td><td bgcolor="#ffffff"> 클래스명 데이터의 길이 (바이트 단위) </td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>args[4]</tt> </td><td bgcolor="#ffffcc"> 컴파일 되고 있는 메소드의 이름을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>

<tr><td align="center" bgcolor="#ffffff"> <tt>args[5]</tt> </td><td bgcolor="#ffffff"> 메소드명 데이터의 길이 (바이트 단위) </td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>args[6]</tt> </td><td bgcolor="#ffffcc"> 컴파일 되고 있는 메소드의 서명을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[7]</tt> </td><td bgcolor="#ffffff"> 서명 데이터의 길이 (바이트 단위) </td></tr>

</tbody></table>
<p>
</p><p>
컴파일 된 메소드가 실행용으로 인스톨 또는 언인스톨될 때, 다음의 프로브가 기동됩니다.
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>compiled-method-load</tt> </td><td bgcolor="#ffffcc"> 컴파일 된 메소드가 인스톨 될 때 기동하는 프로브. 다음에 일람 하는 인수 이외에,<tt>argv[6]</tt> 에는 컴파일 된 코드에의 포인터가 포함되어<tt>argv[7]</tt> 은 컴파일 된 코드의 사이즈입니다</td></tr>

<tr><td align="center" bgcolor="#ffffff"> <tt>compiled-method-unload</tt> </td><td bgcolor="#ffffff"> 컴파일 된 메소드가 언인스톨될 때 기동하는 프로브. 다음의 인수를 지정합니다 </td></tr>
</tbody></table>
<p>
컴파일 된 메소드의 로드 프로브의 인수는, 다음과 같습니다.
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>args[0]</tt> </td><td bgcolor="#ffffcc"> 인스톨 되고 있는 메소드의 클래스의 이름을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>

<tr><td align="center" bgcolor="#ffffff"> <tt>args[1]</tt> </td><td bgcolor="#ffffff"> 클래스명 데이터의 길이 (바이트 단위) </td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>args[2]</tt> </td><td bgcolor="#ffffcc"> 인스톨 되고 있는 메소드의 이름을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[3]</tt> </td><td bgcolor="#ffffff"> 메소드명 데이터의 길이 (바이트 단위) </td></tr>

<tr><td align="center" bgcolor="#ffffcc"> <tt>args[4]</tt> </td><td bgcolor="#ffffcc"> 인스톨 되고 있는 메소드의 서명을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[5]</tt> </td><td bgcolor="#ffffff"> 서명 데이터의 길이 (바이트 단위) </td></tr>
</tbody></table>
<p>
</p><p>
</p><h3><a name="Monitor_Probes"> </a>  모니터 프로브</h3>

<p>Java 어플리케이션이 실행될 때, thread는 모니터에 들어가는 것으로 모니터로부터 나오는 것, 모니터에서의 대기, 및 통지를 실행합니다. 프로브는, 모든 대기 이벤트 및 통지 이벤트에 사용할 수 있습니다. 또, 경합 하는 모니터에 들어가는 이벤트 및 모니터로부터 나오는 이벤트에도 사용할 수 있습니다. 경합 하는 모니터에 들어간다는 것은, 다른 thread가 벌써 모니터내에 있을 때, thread가 모니터에 들어가려고 하는 상황입니다. 경합 하는 모니터로부터 나오는 이벤트는, thread가 모니터로부터 나올 때, 다른 thread가 모니터에 들어가는 것을 대기하고 있는 경우에 발생합니다. 따라서, 경합 하는 들어가는 이벤트와 경합 하는 나오는 이벤트는, 이러한 이벤트에 조우하는 1 개의 thread에 대해서는 일치합니다만, 1 개의 thread에서의 경합 하는 나오는 이벤트는, 다른 thread (모니터에 들어가는 것을 대기하고 있는 thread)에서의 경합 하는 들어가는 이벤트와 일치한다고 생각됩니다.
</p><p>모든 모니터 이벤트는 thread ID, 모니터 ID, 및 객체의 클래스의 타입을 인수로서 제공합니다. thread 및 클래스는, Java 프로그램에 매핑으로 돌아오는 경우에 도움이 된다고 생각됩니다. 한편, 모니터 ID 는 프로브 기동간의 일치 정보를 제공할 수 있습니다.
</p><p>
VM 내에 이러한 프로브가 존재하는 것에 의해 퍼포먼스가 저하하므로, 이것들은 java 커멘드행으로 VM 플래그 <tt>-XX:+ExtendedDTraceProbes</tt> 가 설정되었을 경우에게만 기동합니다. 이 플래그는,<tt>jinfo</tt> 유틸리티를 사용하는 것에 의해, 실행시에 동적으로 온 및 오프로 할 수 있습니다.
</p><p>전술의 플래그가 오프의 경우, 모니터 프로브는 여전히 dtrace 로부터 취득 가능한 프로브 리스트에 존재합니다만, 휴지 상태이며 기동하지 않습니다. 이 제한은, VM 의 향후의 릴리스에서는 삭제될 예정입니다. 향후의 릴리스에서는, 이러한 프로브는, 퍼포먼스에 영향을 주는 일 없이 상시 유효하게 될 예정입니다.  </p><p>
</p><p>
사용 가능한 프로브는, 다음과 같습니다.
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>monitor-contended-enter</tt> </td><td bgcolor="#ffffcc"> 경합 하는 모니터에 thread가 들어가려고 했을 때에 기동하는 프로브</td></tr>

<tr><td align="right" bgcolor="#ffffff"> <tt>monitor-contended-entered</tt> </td><td bgcolor="#ffffff"> 경합 하는 모니터에 thread가 정상적으로 들어갈 때 기동하는 프로브</td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>monitor-contended-exit</tt> </td><td bgcolor="#ffffcc"> 있는 thread가 모니터를 나올 때, 다른 thread가 들어가는 것을 대기하고 있는 경우에 기동하는 프로브</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>monitor-wait</tt> </td><td bgcolor="#ffffff">
thread가 Object.wait()에 의해 모니터로 대기를 개시할 경우에 기동하는 프로브. 프로브에는 추가의 인수 args[4] 가 있습니다. 이것은, 사용되는 타임 아웃을 나타내는 롱치입니다.  </td></tr>

<tr><td align="center" bgcolor="#ffffcc"> <tt>monitor-waited</tt> </td><td bgcolor="#ffffcc"> thread가 Object.wait()를 완료할 경우에 기동하는 프로브. </td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>monitor-notify<tt> </tt></tt></td><td bgcolor="#ffffff"> thread가 Object.notify()를 호출해 모니터에서의 대기자에게 통지할 경우에 기동하는 프로브</td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>monitor-notifyAll<tt> </tt></tt></td><td bgcolor="#ffffcc"> thread가 Object.notifyAll()를 호출해 모니터에서의 대기자에게 통지할 경우에 기동하는 프로브</td></tr>

</tbody></table>
<p>
모니터 프로브의 인수는, 다음과 같습니다.
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>args[0]</tt> </td><td bgcolor="#ffffcc"> 모니터 오퍼레이션을 실행하는 thread의 Java thread 식별자</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[1]</tt> </td><td bgcolor="#ffffff"> 액션이 실행되는 특정의 모니터의 일의이지만 불투명한 식별자</td></tr>

<tr><td align="center" bgcolor="#ffffcc"> <tt>args[2]</tt> </td><td bgcolor="#ffffcc"> 액션이 실행되고 있는 객체의 클래스명을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[3]</tt> </td><td bgcolor="#ffffff"> 클래스명 데이터의 길이 (바이트 단위) </td></tr>
</tbody></table>
<p>
</p><p>
</p><h3><a name="Application_Tracking_Probes"> </a>  어플리케이션 추적 프로브</h3>

<p>
Java thread 실행을 정밀히 조사하기 위한 프로브가 제공되고 있습니다. 이것들은, 메소드에 들어갈 때나 메소드로부터 돌아올 때 항상 기동하는 프로브, 및 Java 객체를 할당할 수 있었을 때 항상 기동하는 프로브입니다.
</p><p>VM 내에 이러한 프로브가 존재하는 것에 의해 퍼포먼스가 저하하므로, 이것들은 VM 로 <tt>ExtendedDTraceProbes</tt> 플래그가 유효한 경우에게만 기동합니다. 디폴트에서는, 프로브는 모두 VM 내의 프로브의 리스트에 존재합니다만, 적절한 플래그가 서 있지 않은 경우는 휴지 상태입니다. 이 제한은, VM 의 향후의 릴리스에서는 삭제될 예정입니다. 향후의 릴리스에서는, 이러한 프로브는, 퍼포먼스에 영향을 주는 일 없이 상시 유효하게 될 예정입니다.  </p><p>
메소드에 들어가는, 및 메소드로부터 돌아오는 프로브는, 다음과 같습니다.
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>method-entry</tt> </td><td bgcolor="#ffffcc"> 메소드에 들어가 있을 때 기동하는 프로브. </td></tr>

<tr><td align="center" bgcolor="#ffffff"> <tt>method-return</tt> </td><td bgcolor="#ffffff"> 정상적으로, 또는 예외에 의해, 메소드로부터 돌아올 때 기동하는 프로브.  </td></tr>
</tbody></table>
<p>
메소드 프로브의 인수는, 다음과 같습니다.
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>args[0]</tt> </td><td bgcolor="#ffffcc"> 메소드에 들어간다, 또는 메소드를 나오는 thread의 Java thread ID</td></tr>

<tr><td align="center" bgcolor="#ffffff"> <tt>args[1]</tt> </td><td bgcolor="#ffffff"> 메소드의 클래스의 이름을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>args[2]</tt> </td><td bgcolor="#ffffcc"> 클래스명 데이터의 길이 (바이트 단위) </td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[3]</tt> </td><td bgcolor="#ffffff"> 메소드의 이름을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>

<tr><td align="center" bgcolor="#ffffcc"> <tt>args[4]</tt> </td><td bgcolor="#ffffcc"> 메소드명 데이터의 길이 (바이트 단위) </td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[5]</tt> </td><td bgcolor="#ffffff"> 메소드의 서명을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>args[6]</tt> </td><td bgcolor="#ffffcc"> 서명 데이터의 길이 (바이트 단위) </td></tr>

</tbody></table>
<p>
사용 가능한 할당 프로브는, 다음과 같습니다.
</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>object-alloc</tt> </td><td bgcolor="#ffffcc"> <tt>ExtendedDTraceProbes</tt> 플래그가 유효한 경우, 객체를 할당할 수 있었을 때에 기동하는 프로브. </td></tr>
</tbody></table>
<p>
객체 할당 프로브는, 다음의 인수를 가지고 있습니다.

</p><p>
</p><table border="1" cellpadding="0" cellspacing="1">
<tbody><tr><td align="center" bgcolor="#ffffcc"> <tt>args[0]</tt> </td><td bgcolor="#ffffcc"> 객체를 할당하고 있는 thread의 Java thread ID</td></tr>
<tr><td align="center" bgcolor="#ffffff"> <tt>args[1]</tt> </td><td bgcolor="#ffffff"> 할당할 수 있고 있는 객체의 클래스명을 포함한 UTF-8 캐릭터 라인 데이터에의 포인터</td></tr>
<tr><td align="center" bgcolor="#ffffcc"> <tt>args[2]</tt> </td><td bgcolor="#ffffcc"> 클래스명 데이터의 길이 (바이트 단위) </td></tr>

<tr><td align="center" bgcolor="#ffffff"> <tt>args[3]</tt> </td><td bgcolor="#ffffff"> 할당할 수 있고 있는 객체의 사이즈</td></tr>
</tbody></table>
<p>
</p><p>
</p><h2><a name="The_HotSpot_jni_i_Provider"> </a> 「hotspot_jni」<i></i>프로바이더</h2>
<p>
native code로부터 Java 코드를 호출하는 경우, 어플리케이션에의 VM 의 매입이나 Java 어플리케이션내에서의 native code의 실행을 위해, native code는 JNI 인터페이스에 의해 호출을 실시합니다. JNI 인터페이스는, Java 코드의 호출과 VM 상태의 검사에 대해, 다수의 메소드를 제공합니다. DTrace 프로브는, 각각의 메소드의 엔트리 포인트와 리턴 포인트로 제공됩니다. 프로브는, 「hotspot_jni」<i></i>프로바이더에 의해 제공됩니다. 프로브의 이름은, JNI 메소드의 이름에, 들어가는 프로브의 경우는 「-entry」, 돌아오는 프로브의 경우는 「-return」를 붙인 것이 됩니다. 각각의 들어가는 프로브로 사용 가능한 인수는, 그 기능에 제공된 인수입니다. 이 경우, Invoke* 메소드는 예외로, Java 메소드에게 건네지는 인수를 생략 합니다. 돌아오는 프로브에는, 인수로서 메소드의 반환값이 있습니다 (이용 가능한 경우).
</p><p>
</p><h2><a name="Reference"> </a>  참조</h2>
<p>
</p><pre>provider hotspot {
  probe vm-init-begin();
  probe vm-init-end();
  probe vm-shutdown();
  probe class-loaded(
      char* class_name, uintptr_t class_name_len, uintptr_t class_loader_id, bool is_shared);
  probe class-unloaded(
      char* class_name, uintptr_t class_name_len, uintptr_t class_loader_id, bool is_shared);
  probe gc-begin(bool is_full);
  probe gc-end();
  probe mem-pool-gc-begin(
      char* mgr_name, uintptr_t mgr_name_len, char* pool_name, uintptr_t pool_name_len, 
      uintptr_t initial_size, uintptr_t used, uintptr_t committed, uintptr_t max_size);
  probe mem-pool-gc-end(
      char* mgr_name, uintptr_t mgr_name_len, char* pool_name, uintptr_t pool_name_len, 
      uintptr_t initial_size, uintptr_t used, uintptr_t committed, uintptr_t max_size);
  probe thread-start(
      char* thread_name, uintptr_t thread_name_length, 
      uintptr_t java_thread_id, uintptr_t native_thread_id, bool is_daemon);
  probe thread-stop(
      char* thread_name, uintptr_t thread_name_length, 
      uintptr_t java_thread_id, uintptr_t native_thread_id, bool is_daemon);
  probe method-compile-begin(
      char* class_name, uintptr_t class_name_len, 
      char* method_name, uintptr_t method_name_len,
      char* signature, uintptr_t signature_len);
  probe method-compile-end(
      char* class_name, uintptr_t class_name_len, 
      char* method_name, uintptr_t method_name_len,
      char* signature, uintptr_t signature_len,
      bool is_success);
  probe compiled-method-load(
      char* class_name, uintptr_t class_name_len, 
      char* method_name, uintptr_t method_name_len,
      char* signature, uintptr_t signature_len,
      void* code, uintptr_t code_size);
  probe compiled-method-unload(
      char* class_name, uintptr_t class_name_len, 
      char* method_name, uintptr_t method_name_len,
      char* signature, uintptr_t signature_len);
  probe monitor-contended-enter(
      uintptr_t java_thread_id, uintptr_t monitor_id, 
      char* class_name, uintptr_t class_name_len);
  probe monitor-contended-entered(
      uintptr_t java_thread_id, uintptr_t monitor_id, 
      char* class_name, uintptr_t class_name_len);
  probe monitor-contended-exit(
      uintptr_t java_thread_id, uintptr_t monitor_id, 
      char* class_name, uintptr_t class_name_len);
  probe monitor-wait(
      uintptr_t java_thread_id, uintptr_t monitor_id, 
      char* class_name, uintptr_t class_name_len,
      uintptr_t timeout);
  probe monitor-waited(
      uintptr_t java_thread_id, uintptr_t monitor_id, 
      char* class_name, uintptr_t class_name_len);
  probe monitor-notify(
      uintptr_t java_thread_id, uintptr_t monitor_id, 
      char* class_name, uintptr_t class_name_len);
  probe monitor-notifyAll(
      uintptr_t java_thread_id, uintptr_t monitor_id, 
      char* class_name, uintptr_t class_name_len);
  probe method-entry(
      uintptr_t java_thread_id, char* class_name, uintptr_t class_name_len,
      char* method_name, uintptr_t method_name_len,
      char* signature, uintptr_t signature_len);
  probe method-return(
      uintptr_t java_thread_id, char* class_name, uintptr_t class_name_len,
      char* method_name, uintptr_t method_name_len,
      char* signature, uintptr_t signature_len);
  probe object-alloc(
      uintptr_t java_thread_id, char* class_name, uintptr_t class_name_len,
      uintptr_t size);
};

provider hotspot_jni {
  probe AllocObject-entry(void*, void*);
  probe AllocObject-return(void*);
  probe AttachCurrentThreadAsDaemon-entry(void*, void**, void*);
  probe AttachCurrentThreadAsDaemon-return(uint32_t);
  probe AttachCurrentThread-entry(void*, void**, void*);
  probe AttachCurrentThread-return(uint32_t);
  probe CallBooleanMethodA-entry(void*, void*, uintptr_t);
  probe CallBooleanMethodA-return(uintptr_t);
  probe CallBooleanMethod-entry(void*, void*, uintptr_t);
  probe CallBooleanMethod-return(uintptr_t);
  probe CallBooleanMethodV-entry(void*, void*, uintptr_t);
  probe CallBooleanMethodV-return(uintptr_t);
  probe CallByteMethodA-entry(void*, void*, uintptr_t);
  probe CallByteMethodA-return(char);
  probe CallByteMethod-entry(void*, void*, uintptr_t);
  probe CallByteMethod-return(char);
  probe CallByteMethodV-entry(void*, void*, uintptr_t);

  probe CallByteMethodV-return(char);
  probe CallCharMethodA-entry(void*, void*, uintptr_t);
  probe CallCharMethodA-return(uint16_t);
  probe CallCharMethod-entry(void*, void*, uintptr_t);
  probe CallCharMethod-return(uint16_t);
  probe CallCharMethodV-entry(void*, void*, uintptr_t);
  probe CallCharMethodV-return(uint16_t);
  probe CallDoubleMethodA-entry(void*, void*, uintptr_t);
  probe CallDoubleMethodA-return(double);
  probe CallDoubleMethod-entry(void*, void*, uintptr_t);
  probe CallDoubleMethod-return(double);
  probe CallDoubleMethodV-entry(void*, void*, uintptr_t);
  probe CallDoubleMethodV-return(double);
  probe CallFloatMethodA-entry(void*, void*, uintptr_t);
  probe CallFloatMethodA-return(float);
  probe CallFloatMethod-entry(void*, void*, uintptr_t);
  probe CallFloatMethod-return(float);
  probe CallFloatMethodV-entry(void*, void*, uintptr_t);
  probe CallFloatMethodV-return(float);
  probe CallIntMethodA-entry(void*, void*, uintptr_t);
  probe CallIntMethodA-return(uint32_t);
  probe CallIntMethod-entry(void*, void*, uintptr_t);
  probe CallIntMethod-return(uint32_t);
  probe CallIntMethodV-entry(void*, void*, uintptr_t);
  probe CallIntMethodV-return(uint32_t);
  probe CallLongMethodA-entry(void*, void*, uintptr_t);
  probe CallLongMethodA-return(uintptr_t);
  probe CallLongMethod-entry(void*, void*, uintptr_t);
  probe CallLongMethod-return(uintptr_t);
  probe CallLongMethodV-entry(void*, void*, uintptr_t);
  probe CallLongMethodV-return(uintptr_t);
  probe CallNonvirtualBooleanMethodA-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualBooleanMethodA-return(uintptr_t);
  probe CallNonvirtualBooleanMethod-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualBooleanMethod-return(uintptr_t);
  probe CallNonvirtualBooleanMethodV-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualBooleanMethodV-return(uintptr_t);
  probe CallNonvirtualByteMethodA-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualByteMethodA-return(char);
  probe CallNonvirtualByteMethod-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualByteMethod-return(char);
  probe CallNonvirtualByteMethodV-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualByteMethodV-return(char);
  probe CallNonvirtualCharMethodA-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualCharMethodA-return(uint16_t);
  probe CallNonvirtualCharMethod-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualCharMethod-return(uint16_t);
  probe CallNonvirtualCharMethodV-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualCharMethodV-return(uint16_t);
  probe CallNonvirtualDoubleMethodA-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualDoubleMethodA-return(double);
  probe CallNonvirtualDoubleMethod-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualDoubleMethod-return(double);
  probe CallNonvirtualDoubleMethodV-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualDoubleMethodV-return(double);
  probe CallNonvirtualFloatMethodA-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualFloatMethodA-return(float);
  probe CallNonvirtualFloatMethod-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualFloatMethod-return(float);
  probe CallNonvirtualFloatMethodV-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualFloatMethodV-return(float);
  probe CallNonvirtualIntMethodA-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualIntMethodA-return(uint32_t);
  probe CallNonvirtualIntMethod-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualIntMethod-return(uint3t);
  probe CallNonvirtualIntMethodV-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualIntMethodV-return(uint32_t);
  probe CallNonvirtualLongMethodA-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualLongMethodA-return(uintptr_t);
  probe CallNonvirtualLongMethod-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualLongMethod-return(uintptr_t);
  probe CallNonvirtualLongMethodV-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualLongMethodV-return(uintptr_t);
  probe CallNonvirtualObjectMethodA-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualObjectMethodA-return(void*);
  probe CallNonvirtualObjectMethod-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualObjectMethod-return(void*);
  probe CallNonvirtualObjectMethodV-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualObjectMethodV-return(void*);
  probe CallNonvirtualShortMethodA-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualShortMethodA-return(uint16_t);
  probe CallNonvirtualShortMethod-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualShortMethod-return(uint16_t);
  probe CallNonvirtualShortMethodV-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualShortMethodV-return(uint16_t);
  probe CallNonvirtualVoidMethodA-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualVoidMethodA-return();
  probe CallNonvirtualVoidMethod-entry(void*, void*, void*, uintptr_t);
  probe CallNonvirtualVoidMethod-return();
  probe CallNonvirtualVoidMethodV-entry(void*, void*, void*, uintptr_t);  
  probe CallNonvirtualVoidMethodV-return();
  probe CallObjectMethodA-entry(void*, void*, uintptr_t);
  probe CallObjectMethodA-return(void*);
  probe CallObjectMethod-entry(void*, void*, uintptr_t);
  probe CallObjectMethod-return(void*);
  probe CallObjectMethodV-entry(void*, void*, uintptr_t);
  probe CallObjectMethodV-return(void*);
  probe CallShortMethodA-entry(void*, void*, uintptr_t);
  probe CallShortMethodA-return(uint16_t);
  probe CallShortMethod-entry(void*, void*, uintptr_t);
  probe CallShortMethod-return(uint16_t);
  probe CallShortMethodV-entry(void*, void*, uintptr_t);
  probe CallShortMethodV-return(uint16_t);
  probe CallStaticBooleanMethodA-entry(void*, void*, uintptr_t);
  probe CallStaticBooleanMethodA-return(uintptr_t);
  probe CallStaticBooleanMethod-entry(void*, void*, uintptr_t);
  probe CallStaticBooleanMethod-return(uintptr_t);
  probe CallStaticBooleanMethodV-entry(void*, void*, uintptr_t);
  probe CallStaticBooleanMethodV-return(uintptr_t);
  probe CallStaticByteMethodA-entry(void*, void*, uintptr_t);
  probe CallStaticByteMethodA-return(char);
  probe CallStaticByteMethod-entry(void*, void*, uintptr_t);
  probe CallStaticByteMethod-return(char);
  probe CallStaticByteMethodV-entry(void*, void*, uintptr_t);
  probe CallStaticByteMethodV-return(char);
  probe CallStaticCharMethodA-entry(void*, void*, uintptr_t);
  probe CallStaticCharMethodA-return(uint16_t);
  probe CallStaticCharMethod-entry(void*, void*, uintptr_t);
  probe CallStaticCharMethod-return(uint16_t);
  probe CallStaticCharMethodV-entry(void*, void*, uintptr_t);
  probe CallStaticCharMethodV-return(uint16_t);
  probe CallStaticDoubleMethodA-entry(void*, void*, uintptr_t);
  probe CallStaticDoubleMethodA-return(double);
  probe CallStaticDoubleMethod-entry(void*, void*, uintptr_t);
  probe CallStaticDoubleMethod-return(double);
  probe CallStaticDoubleMethodV-entry(void*, void*, uintptr_t);
  probe CallStaticDoubleMethodV-return(double);
  probe CallStaticFloatMethodA-entry(void*, void*, uintptr_t);
  probe CallStaticFloatMethodA-return(float);
  probe CallStaticFloatMethod-entry(void*, void*, uintptr_t);
  probe CallStaticFloatMethod-return(float);
  probe CallStaticFloatMethodV-entry(void*, void*, uintptr_t);
  probe CallStaticFloatMethodV-return(float);
  probe CallStaticIntMethodA-entry(void*, void*, uintptr_t);
  probe CallStaticIntMethodA-return(uint32_t);
  probe CallStaticIntMethod-entry(void*, void*, uintptr_t);
  probe CallStaticIntMethod-return(uint32_t);
  probe CallStaticIntMethodentry(void*, void*, uintptr_t);
  probe CallStaticIntMethodV-return(uint32_t);
  probe CallStaticLongMethodA-entry(void*, void*, uintptr_t);
  probe CallStaticLongMethodA-return(uintptr_t);
  probe CallStaticLongMethod-entry(void*, void*, uintptr_t);
  probe CallStaticLongMethod-return(uintptr_t);
  probe CallStaticLongMethodV-entry(void*, void*, uintptr_t);
  probe CallStaticLongMethodV-return(uintptr_t);
  probe CallStaticObjectMethodA-entry(void*, void*, uintptr_t);
  probe CallStaticObjectMethodA-return(void*);
  probe CallStaticObjectMethod-entry(void*, void*, uintptr_t);
  probe CallStaticObjectMethod-return(void*);
  probe CallStaticObjectMethodV-entry(void*, void*, uintptr_t);
  probe CallStaticObjectMethodV-return(void*);
  probe CallStaticShortMethodA-entry(void*, void*, uintptr_t);
  probe CallStaticShortMethodA-return(uint16_t);
  probe CallStaticShortMethod-entry(void*, void*, uintptr_t);
  probe CallStaticShortMethod-return(uint16_t);
  probe CallStaticShortMethodV-entry(void*, void*, uintptr_t);
  probe CallStaticShortMethodV-return(uint16_t);
  probe CallStaticVoidMethodA-entry(void*, void*, uintptr_t);
  probe CallStaticVoidMethodA-return();
  probe CallStaticVoidMethod-entry(void*, void*, uintptr_t);
  probe CallStaticVoidMethod-return(); 
  probe CallStaticVoidMethodV-entry(void*, void*, uintptr_t);  
  probe CallStaticVoidMethodV-return();
  probe CallVoidMethodA-entry(void*, void*, uintptr_t);  
  probe CallVoidMethodA-return();
  probe CallVoidMethod-entry(void*, void*, uintptr_t);  
  probe CallVoidMethod-return(); 
  probe CallVoidMethodV-entry(void*, void*, uintptr_t);  
  probe CallVoidMethodV-return();
  probe CreateJavaVM-entry(void**, void**, void*);
  probe CreateJavaVM-return(uint32_t);
  probe DefineClass-entry(void*, const char*, void*, char, uintptr_t);
  probe DefineClass-return(void*);
  probe DeleteGlobalRef-entry(void*, void*);
  probe DeleteGlobalRef-return();
  probe DeleteLocalRef-entry(void*, void*);
  probe DeleteLocalRef-return();
  probe DeleteWeakGlobalRef-entry(void*, void*);
  probe DeleteWeakGlobalRef-return();
  probe DestroyJavaVM-entry(void*);
  probe DestroyJavaVM-return(uint32_t);
  probe DetachCurrentThread-entry(void*);
  probe DetachCurrentThread-return(uint32_t);
  probe EnsureLocalCapacity-entry(void*, uint32_t);
  probe EnsureLocalCapacity-return(uint32_t);
  probe ExceptionCheck-entry(void*);
  probe ExceptionCheck-return(uintptr_t);
  probe ExceptionClear-entry(void*);
  probe ExceptionClear-return();
  probe ExceptionDescribe-entry(void*);  
  probe ExceptionDescribe-return();
  probe ExceptionOccurred-entry(void*);
  probe ExceptionOccurred-return(void*);
  probe FatalError-entry(void* env, const char*);
  probe FatalError-return();
  probe FindClass-entry(void*, const char*);
  probe FindClass-return(void*);
  probe FromReflectedField-entry(void*, void*);
  probe FromReflectedField-return(uintptr_t);
  probe FromReflectedMethod-entry(void*, void*);
  probe FromReflectedMethod-return(uintptr_t);
  probe GetArrayLength-entry(void*, void*);
  probe GetArrayLength-return(uintptr_t);
  probe GetBooleanArrayElements-entry(void*, void*, uintptr_t*);
  probe GetBooleanArrayElements-return(uintptr_t*);
  probe GetBooleanArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, uintptr_t*);
  probe GetBooleanArrayRegion-return();
  probe GetBooleanField-entry(void*, void*, uintptr_t);
  probe GetBooleanField-return(uintptr_t);
  probe GetByteArrayElements-entry(void*, void*, uintptr_t*);
  probe GetByteArrayElements-return(char*);
  probe GetByteArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, char*);
  probe GetByteArrayRegion-return();
  probe GetByteField-entry(void*, void*, uintptr_t);
  probe GetByteField-return(char);
  probe GetCharArrayElements-entry(void*, void*, uintptr_t*);
  probe GetCharArrayElements-return(uint16_t*);
  probe GetCharArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, uint16_t*);
  probe GetCharArrayRegion-return();
  probe GetCharField-entry(void*, void*, uintptr_t);
  probe GetCharField-return(uint16_t);
  probe GetCreatedJavaVMs-eintptr_t*);
  probe GetCreatedJavaVMs-return(uintptr_t);
  probe GetCreateJavaVMs-entry(void*, uintptr_t, uintptr_t*);
  probe GetCreateJavaVMs-return(uint32_t);
  probe GetDefaultJavaVMInitArgs-entry(void*);
  probe GetDefaultJavaVMInitArgs-return(uint32_t);
  probe GetDirectBufferAddress-entry(void*, void*);
  probe GetDirectBufferAddress-return(void*);
  probe GetDirectBufferCapacity-entry(void*, void*);
  probe GetDirectBufferCapacity-return(uintptr_t);
  probe GetDoubleArrayElements-entry(void*, void*, uintptr_t*);
  probe GetDoubleArrayElements-return(double*);
  probe GetDoubleArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, double*);
  probe GetDoubleArrayRegion-return();
  probe GetDoubleField-entry(void*, void*, uintptr_t);
  probe GetDoubleField-return(double);
  probe GetEnv-entry(void*, void*, void*);
  probe GetEnv-return(uint32_t);
  probe GetFieldID-entry(void*, void*, const char*, const char*);
  probe GetFieldID-return(uintptr_t);
  probe GetFloatArrayElements-entry(void*, void*, uintptr_t*);
  probe GetFloatArrayElements-return(float*);
  probe GetFloatArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, float*);
  probe GetFloatArrayRegion-return();
  probe GetFloatField-entry(void*, void*, uintptr_t);
  probe GetFloatField-return(float);
  probe GetIntArrayElements-entry(void*, void*, uintptr_t*);
  probe GetIntArrayElements-return(uint32_t*);
  probe GetIntArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, uint32_t*);
  probe GetIntArrayRegion-return();
  probe GetIntField-entry(void*, void*, uintptr_t);
  probe GetIntField-return(uint32_t);
  probe GetJavaVM-entry(void*, void**);
  probe GetJavaVM-return(uint32_t);
  probe GetLongArrayElements-entry(void*, void*, uintptr_t*);
  probe GetLongArrayElements-return(uintptr_t*);
  probe GetLongArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, uintptr_t*);
  probe GetLongArrayRegion-return();
  probe GetLongField-entry(void*, void*, uintptr_t);
  probe GetLongField-return(uintptr_t);
  probe GetMethodID-entry(void*, void*, const char*, const char*);
  probe GetMethodID-return(uintptr_t);
  probe GetObjectArrayElement-entry(void*, void*, uintptr_t);
  probe GetObjectArrayElement-return(void*);
  probe GetObjectClass-entry(void*, void*);
  probe GetObjectClass-return(void*);
  probe GetObjectField-entry(void*, void*, uintptr_t);
  probe GetObjectField-return(void*);
  probe GetObjectRefType-entry(void*, void*);
  probe GetObjectRefType-return(void*);
  probe GetPrimitiveArrayCritical-entry(void*, void*, uintptr_t*);
  probe GetPrimitiveArrayCritical-return(void*);
  probe GetShortArrayElements-entry(void*, void*, uintptr_t*);
  probe GetShortArrayElements-return(uint16_t*);
  probe GetShortArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, uint16_t*);
  probe GetShortArrayRegion-return();
  probe GetShortField-entry(void*, void*, uintptr_t);
  probe GetShortField-return(uint16_t);
  probe GetStaticBooleanField-entry(void*, void*, uintptr_t);
  probe GetStaticBooleanField-return(uintptr_t);
  probe GetStaticByteField-entry(void*, void*, uintptr_t);
  probe GetStaticByteField-return(char);
  probe GetStaticCharField-entry(void*, void*, uintptr_t);
  probe GetStaticCharField-return(uint16_t);
  probe GetStaticDoubleField-entry(void*, void*, uintptr_t);
  probe GetStaticDoubleField-return(double);
  probe GetStaticFieldID-entry(void*, void*, const char*, const char*);
  probe GetStaticFieldID-return(uintptr_t);
  probe GetStaticFloatField-entry(void*, void*, uintptr_t);
  probe GetStaticFloatField-return(float);
  probe GetStaticIntField-entry(void*, void*, uintptr_t);
  probe GetStaticIntField-return(uint32_t);
  probe GetStaticLongField-entry(void*, void*, uintptr_t);
  probe GetStaticLongField-return(uintptr_t);
  probe GetStaticMethodID-entry(void*, void*, const char*, const char*);
  probe GetStaticMethodID-return(uintptr_t);
  probe GetStaticObjectField-entry(void*, void*, uintptr_t);
  probe GetStaticObjectField-return(void*);
  probe GetStaticShortField-entry(void*, void*, uintptr_t);
  probe GetStaticShortField-return(uint16_t);
  pro GetStringChars-entry(void*, void*, uintptr_t*);
  probe GetStringChars-return(const uint16_t*);
  probe GetStringCritical-entry(void*, void*, uintptr_t*);
  probe GetStringCritical-return(const uint16_t*);
  probe GetStringLength-entry(void*, void*);
  probe GetStringLength-return(uintptr_t);
  probe GetStringRegion-entry(void*, void*, uintptr_t, uintptr_t, uint16_t*);
  probe GetStringRegion-return();
  probe GetStringUTFChars-entry(void*, void*, uintptr_t*);
  probe GetStringUTFChars-return(const char*);
  probe GetStringUTFLength-entry(void*, void*);
  probe GetStringUTFLength-return(uintptr_t);
  probe GetStringUTFRegion-entry(void*, void*, uintptr_t, uintptr_t, char*);
  probe GetStringUTFRegion-return();
  probe GetSuperclass-entry(void*, void*);
  probe GetSuperclass-return(void*);
  probe GetVersion-entry(void*);
  probe GetVersion-return(uint32_t);
  probe IsAssignableFrom-entry(void*, void*, void*);
  probe IsAssignableFrom-return(uintptr_t);
  probe IsInstanceOf-entry(void*, void*, void*);
  probe IsInstanceOf-return(uintptr_t);
  probe IsSameObject-entry(void*, void*, void*);
  probe IsSameObject-return(uintptr_t);
  probe MonitorEnter-entry(void*, void*);
  probe MonitorEnter-return(uint32_t);
  probe MonitorExit-entry(void*, void*);
  probe MonitorExit-return(uint32_t);
  probe NewBooleanArray-entry(void*, uintptr_t);
  probe NewBooleanArray-return(void*);
  probe NewByteArray-entry(void*, uintptr_t);
  probe NewByteArray-return(void*);
  probe NewCharArray-entry(void*, uintptr_t);
  probe NewCharArray-return(void*);
  probe NewDirectByteBuffer-entry(void*, void*, uintptr_t);
  probe NewDirectByteBuffer-return(void*);
  probe NewDoubleArray-entry(void*, uintptr_t);
  probe NewDoubleArray-return(void*);
  probe NewFloatArray-entry(void*, uintptr_t);
  probe NewFloatArray-return(void*);
  probe NewGlobalRef-entry(void*, void*);
  probe NewGlobalRef-return(void*);
  probe NewIntArray-entry(void*, uintptr_t);
  probe NewIntArray-return(void*);
  probe NewLocalRef-entry(void*, void*);
  probe NewLocalRef-return(void*);
  probe NewLongArray-entry(void*, uintptr_t);
  probe NewLongArray-return(void*);
  probe NewObjectA-entry(void*, void*, uintptr_t);  
  probe NewObjectA-return(void*);
  probe NewObjectArray-entry(void*, uintptr_t, void*, void*);
  probe NewObjectArray-return(void*);
  probe NewObject-entry(void*, void*, uintptr_t); 
  probe NewObject-return(void*);
  probe NewObjectV-entry(void*, void*, uintptr_t);  
  probe NewObjectV-return(void*);
  probe NewShortArray-entry(void*, uintptr_t);
  probe NewShortArray-return(void*);
  probe NewString-entry(void*, const uint16_t*, uintptr_t);
  probe NewString-return(void*);
  probe NewStringUTF-entry(void*, const char*);
  probe NewStringUTF-return(void*);
  probe NewWeakGlobalRef-entry(void*, void*);
  probe NewWeakGlobalRef-return(void*);
  probe PopLocalFrame-entry(void*, void*);
  probe PopLocalFrame-return(void*);
  probe PushLocalFrame-entry(void*, uint32_t);
  probe PushLocalFrame-return(uint32_t);
  probe RegisterNatives-entry(void*, void*, const void*, uint32_t);  
  probe RegisterNatives-return(uint32_t);
  probe ReleaseBooleanArrayElements-entry(void*, void*, uintptr_t*, uint32_t);
  probe ReleaseBooleanArrayElements-return();
  probe ReleaseByteArrayElements-entry(void*, void*, char*, uint32_t);
  probe ReleaseByteArrayElements-return();
  probe ReleaseCharArrayElements-entry(void*, void*, uint16_t*, uint32_t);
  probe ReleaseCharArrayElements-return();
  probe ReleaseDoubleArrayElements-entry(void*, void*, double*, uint32_t);
  probe ReleaseDoubleArrayElements-return();
  probe ReleaseFloatArrayElements-entry(void*, void*, float*, uint32_t);
  probe ReleaseFloatArrayElements-return();
  probe ReleaseIntArrayElements-entry(void*, void*, uint32_t*, uint32_t);
  probe ReleaseIntArrayElements-return();
  probe ReleaseLongArrayElements-entry(void*, void*, uintptr_t*, uint32_t);
  probe ReleaseLongArrayElements-return();
  probe ReleaseObjectArrayElements-entry(void*, void*, void**, uint32_t);
  probe ReleaseObjectArrayElements-return();
  probe Releasey(void*, void*, void*, uint32_t);
  probe ReleasePrimitiveArrayCritical-return();
  probe ReleaseShortArrayElements-entry(void*, void*, uint16_t*, uint32_t);
  probe ReleaseShortArrayElements-return();
  probe ReleaseStringChars-entry(void*, void*, const uint16_t*);
  probe ReleaseStringChars-return();
  probe ReleaseStringCritical-entry(void*, void*, const uint16_t*);
  probe ReleaseStringCritical-return();
  probe ReleaseStringUTFChars-entry(void*, void*, const char*);
  probe ReleaseStringUTFChars-return();
  probe SetBooleanArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, const uintptr_t*);
  probe SetBooleanArrayRegion-return();
  probe SetBooleanField-entry(void*, void*, uintptr_t, uintptr_t);
  probe SetBooleanField-return();
  probe SetByteArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, const char*);
  probe SetByteArrayRegion-return();
  probe SetByteField-entry(void*, void*, uintptr_t, char);
  probe SetByteField-return();
  probe SetCharArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, const uint16_t*);
  probe SetCharArrayRegion-return();
  probe SetCharField-entry(void*, void*, uintptr_t, uint16_t);
  probe SetCharField-return();
  probe SetDoubleArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, const double*);
  probe SetDoubleArrayRegion-return();
  probe SetDoubleField-entry(void*, void*, uintptr_t, double);
  probe SetDoubleField-return();
  probe SetFloatArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, const float*);
  probe SetFloatArrayRegion-return();
  probe SetFloatField-entry(void*, void*, uintptr_t, float);
  probe SetFloatField-return();
  probe SetIntArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, const uint32_t*);
  probe SetIntArrayRegion-return();
  probe SetIntField-entry(void*, void*, uintptr_t, uint32_t);
  probe SetIntField-return();
  probe SetLongArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, const uintptr_t*);
  probe SetLongArrayRegion-return();
  probe SetLongField-entry(void*, void*, uintptr_t, uintptr_t);
  probe SetLongField-return();
  probe SetObjectArrayElement-entry(void*, void*, uintptr_t, void*);
  probe SetObjectArrayElement-return();
  probe SetObjectField-entry(void*, void*, uintptr_t, void*);
  probe SetObjectField-return();
  probe SetShortArrayRegion-entry(void*, void*, uintptr_t, uintptr_t, const uint16_t*);
  probe SetShortArrayRegion-return();
  probe SetShortField-entry(void*, void*, uintptr_t, uint16_t);
  probe SetShortField-return();
  probe SetStaticBooleanField-entry(void*, void*, uintptr_t, uintptr_t);
  probe SetStaticBooleanField-return();
  probe SetStaticByteField-entry(void*, void*, uintptr_t, char);
  probe SetStaticByteField-return();
  probe SetStaticCharField-entry(void*, void*, uintptr_t, uint16_t);
  probe SetStaticCharField-return();
  probe SetStaticDoubleField-entry(void*, void*, uintptr_t, double);
  probe SetStaticDoubleField-return();
  probe SetStaticFloatField-entry(void*, void*, uintptr_t, float);
  probe SetStaticFloatField-return();
  probe SetStaticIntField-entry(void*, void*, uintptr_t, uint32_t);
  probe SetStaticIntField-return();
  probe SetStaticLongField-entry(void*, void*, uintptr_t, uintptr_t);
  probe SetStaticLongField-return();
  probe SetStaticObjectField-entry(void*, void*, uintptr_t, void*);
  probe SetStaticObjectField-return();
  probe SetStaticShortField-entry(void*, void*, uintptr_t, uint16_t);
  probe SetStaticShortField-return();
  probe Throw-entry(void*, void*);
  probe ThrowNew-entry(void*, void*, const char*);  
  probe ThrowNew-return(uint32_t);
  probe Throw-return(uint32_t);
  probe ToReflectedField-entry(void*, void*, uintptr_t, uintptr_t);
  probe ToReflectedField-return(void*);
  probe ToReflectedMethod-entry(void*, void*, uintptr_t, uintptr_t);
  probe ToReflectedMethod-return(void*);
  probe UnregisterNatives-entry(void*, void*);  
  probe UnregisterNatives-return(uint32_t);
};
</pre>

</body></html>
