<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">

<HTML>
  
  <HEAD>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">

<TITLE>직렬화, 전개, 및 새로운 슈퍼 클래스의 추가 - xrath.com 에서 번역됨</TITLE>
  </HEAD>
  
<BODY BGCOLOR="ffffff"><IMG SRC="../images/bg2.gif" alt="청색의 바" WIDTH="610" HEIGHT="4">
    
<H2>직렬화, 전개, 및 새로운 슈퍼 클래스의 추가</H2>
    
<IMG SRC="../images/bg2.gif" alt="청색의 바" WIDTH="610" HEIGHT="4">
    
<H3>개설</H3>
    
    <BLOCKQUOTE>
      
<P>직렬화 시에 버젼 관리를 사용해, 새로운 슈퍼 클래스를 가지는 클래스를 전개하는 방법을 나타냅니다. 예를 들어, 최초의 클래스가 다음의 구조를 가진다고 합니다.  </P>

<pre>
  class A {...};
  class C extends A {...};
</pre>
      
<P> 전개한 클래스가 다음의 구조를 가진다고 합니다.  </P>

<pre>
  class A {...};
  class B extends A {...};
  class C extends B {...};
</pre>
      
<P>이 경우, 새로운 버젼의 서브 클래스 C 는 낡은 버젼의 서브 클래스 C 를 읽을 수 없으면 안됩니다.  반대로, 낡은 버젼의 서브 클래스 C 도 새로운 버젼의 서브 클래스 C 를 읽을 수 없으면 안됩니다. 이 예제에서는, 이 원리를 설명합니다.  </P>
      
<P>전개된 클래스 (<TT>ASuperClass</TT> 와 <TT>ASubClass</TT>)는,<TT>serialVersionUID</TT> 필드를 정의할 필요가 있습니다.  이 필드는, 오리지날 클래스 (<TT>ASuperClass</TT> 와 <TT>ASubClass</TT>)에서 <TT>serialver</TT> 커멘드를 사용해 취득할 수가 있습니다.  </P>
      
<P>이 예제에서는, 슈퍼 클래스 (A 와 B)는 <TT>Serializable</TT> 인터페이스를 구현합니다. 구현하지 않으면, 서브 클래스 C 가 A 와 B 의 필드의 보존과 복원의 책임을 지게 되어 버립니다.  이 문제의 자세한 것은,<A HREF="../nonserialsuper/index3.html">「슈퍼 클래스가 직렬화 가능하지 않은 경우의 직렬화」</a>를 참조해 주세요. </P> </BLOCKQUOTE><IMG SRC="../images/bg2.gif" alt="청색의 바" WIDTH="190"      HEIGHT="2">
    
<H3>관련 정보 </H3>
    
    <DL>
<DD><A HREF="sources.html">원시 파일</A>  </DD>
<DD><A HREF="torun.html">예제의 실행</A>  </DD>
<DD><A HREF="../index.html">예제 리스트</A>  </DD>
</DL><IMG SRC="../images/bg2.gif" alt="청색의 바" WIDTH="610" HEIGHT="4">
  </BODY>
</HTML>
