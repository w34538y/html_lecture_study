<html><head>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">
<title> - xrath.com 에서 번역됨</title></head>
<body bgcolor=#ffffff>
 
<a href="GettingStartedTOC.fm.html">[선두의 항목]</a>  <a href="rowsetImpl.html">[전의 항목]</a>  [다음의 항목] [마지막 항목]
<hr><br>
 
<a name="1006294"> </a> 
<h2> 부록 A - 새로운 특징의 요약</h2>
<p><a name="1006353"> </a> 주: 이 장의 내용의 일부는, Addison Wesley 사부터 Java 시리즈의 1 권으로서 출판된 「<em>JDBC</em><sup><font size=-2>TM</font></sup><em> API Tutorial and Reference, Second Edition:Universal Data Access for the Java</em><sup><font size=-2>TM</font></sup><em> 2 Platform</em>」(ISBN 0-201-43328-1)에 근거해 작성한 것입니다.
</p><p><a name="1006356"> </a> 

</p><p><a name="999758"> </a> 이 부록에서는, JDBC API 에 지금까지 추가되어 온 신기능을 요약하고 있습니다. 다만, 특정의 기능을 사용하려면 , 그 기능을 지원하고 있는 드라이버를 사용할 필요가 있습니다.
</p><a name="1006300"> </a> 
<h3>A. 1	 JDBC 3.0 API 의 변경점의 개요</h3>
<p><a name="1006541"> </a> JDBC 3.0 API 의 주된 변경점의 1 개는, 패키지 <code>java.sql</code> 뿐만이 아니라 패키지 <code>javax.sql</code> (JDBC 옵션 패키지)도, API 에 포함되게 된 것입니다.  이 개요 설명은 전반과 후반으로 나누어져 있습니다. 전반의 섹션에서는, JDBC 3.0 API 로 양쪽 모두의 패키지에 추가된 기능에 대해 설명합니다.  후반의 섹션에서는, JDBC 2.0 옵션 패키지에 추가된 기능에 대해 설명합니다. 상세한 것에 대하여는, JDBC 3.0 API 스펙을 참조해 주세요.
</p><a name="1006535"> </a> 
<h4>A. 1.1	 JDBC 3.0 API 에 추가된 기능</h4>
<p><a name="1006372"> </a> JDBC 3.0 API 에 추가된 새로운 자료나 변경점은, 다음과 같습니다.
</p><ul><a name="1006373"> </a> 
<li>세이브 포인트의 지원<a name="1006374"> </a> 
<blockquote><code>Savepoint</code> 인터페이스가 추가되었습니다.  이 인터페이스에 포함되는 새로운 메소드를 사용하면, 세이브 포인트의 설정, 세이브 포인트를 해제, 및 지정된 세이브 포인트에의 트랜잭션(transaction)의 롤백(rollback)를 실시할 수 있습니다. </blockquote>
<a name="1006375"> </a> 
<li>접속 풀에서의 준비된 문장의 재사용<a name="1006376"> </a> 
<blockquote>준비된 문장이 접속에 의해 어떻게 풀 및 재사용될까를, 개발자가 제어할 수 있도록(듯이)하기 위한 기능이 추가되었습니다. </blockquote>
<a name="1006377"> </a> 
<li>접속 풀의 설정<a name="1006378"> </a> 
<blockquote><code>ConnectionPoolDataSource</code> 인터페이스용의 프로퍼티이, 많이 정의되었습니다. 이러한 프로퍼티을 사용하면,<code>DataSource</code> 객체에 의해 작성되는 <code>PooledConnection</code> 객체가, 어떻게 풀 되는지를 기술할 수 있습니다. </blockquote>
<a name="1006379"> </a> 
<li>파라미터의 메타데이타의 취득<a name="1006380"> </a> 
<blockquote>새로운 인터페이스 <code>ParameterMetaData</code> 가 추가되었습니다.  이 인터페이스는, 준비된 문장에 대한 파라미터의, 개수, 형태, 및 프로퍼티을 기술합니다. </blockquote>
<a name="1006381"> </a> 
<li>자동 생성 키의 취득<a name="1006382"> </a> 
<blockquote>자동 생성치가 포함되고 있는 열로부터 값을 취득하기 위한 방법이 추가되었습니다. </blockquote>
<a name="1006383"> </a> 
<li>연 <code>ResultSet</code> 객체를 복수 작성하는 기능<a name="1006384"> </a> 
<blockquote>새로운 메소드 <code>getMoreResults(int)</code> 가 추가되었습니다.  이 메소드에는,<code>Statement</code> 로부터 반환된 <code>ResultSet</code> 객체를 닫은 후에 후속의 <code>ResultSet</code> 객체를 돌려줄지 어떨지를 나타내는 인수를 지정합니다. </blockquote>
<a name="1006385"> </a> 
<li><code>CallableStatement</code> 객체에의 이름에 의한 파라미터의 수수<a name="1006386"> </a> 
<blockquote><code>CallableStatement</code> 객체의 파라미터를 식별하는 캐릭터 라인을 설정하는 메소드가 추가되었습니다. </blockquote>
<a name="1006387"> </a> 
<li>보관 유지 가능한 커서의 지원<a name="1006388"> </a> 
<blockquote>트랜잭션(transaction)의 위탁 후에 <code>ResultSet</code> 객체를 연 채로 할지 어떨지를 지정하는 기능이 추가되었습니다. </blockquote>
<a name="1006389"> </a> 
<li><code>BOOLEAN</code> 데이터형<a name="1006390"> </a> 
<blockquote>데이터형 <code>java.sql.Types.BOOLEAN</code> 가 추가되었습니다. <code>BOOLEAN</code> 는, 논리적이게는 <code>BIT</code> 와 동등합니다. </blockquote>
<a name="1006391"> </a> 
<li><code>Blob</code> 객체 및 <code>Clob</code> 객체내의 데이터에 대한 내부적인 갱신<a name="1006392"> </a> 
<blockquote><code>Blob</code> 객체 및 <code>Clob</code> 객체에 포함된 데이터를 변경하기 위한 메소드가 추가되었습니다. </blockquote>
<a name="1006393"> </a> 
<li><code>Ref</code> 객체에 의해 참조되고 있는 객체의 취득 및 갱신<a name="1006394"> </a> 
<blockquote><code>Ref</code> 객체에 의해 참조되고 있는 객체를 취득하기 위한 메소드가 추가되었습니다. 또,<code>Ref</code> 객체에 의해 참조되고 있는 객체를 갱신하기 위한 기능도 추가되었습니다. </blockquote>
<a name="1006395"> </a> 
<li><code>BLOB</code>,<code>CLOB</code>,<code>ARRAY</code>,<code>REF</code> 의 형태를 포함한 열의 갱신<a name="1006396"> </a> 
<blockquote><code>updateBlob</code>,<code>updateClob</code>,<code>updateArray</code>,<code>updateRef</code> 의 각 메소드가 <code>ResultSet</code> 인터페이스에 추가되었습니다. </blockquote>
<a name="1006397"> </a> 
<li><code>DATALINK/URL</code> 데이터형<a name="1006398"> </a> 
<blockquote>데이터형 <code>java.sql.Types.DATALINK</code> 가 추가되었습니다.  JDBC 드라이버는 이 데이터형을 사용하는 것으로, 외부 데이터에의 참조를 포함 및 취득할 수 있게 됩니다. </blockquote>
<a name="1006399"> </a> 
<li>변환 그룹과 형태 매핑<a name="1006400"> </a> 
<blockquote>변환 그룹의 효과와 그것이 어떻게 메타데이타에 반영될까에 임해서, 기술했습니다. </blockquote>
<a name="1006401"> </a> 
<li>JDBC SPI (Service Provider Interface)와 연결기 아키텍쳐(architecture)의 관계<code></code><a name="1006402"> </a> 
<blockquote>JDBC SPI 와 연결기 아키텍쳐(architecture)의 관계에 대해, 기술했습니다. </blockquote>
<a name="1006406"> </a> 
<li><code>DatabaseMetadata</code> API <a name="1006407"> </a> 
<blockquote>SQL 형의 계층 구조나 그 외의 신기능에 관한 각종 정보를 취득하기 위한 메타데이타가 추가되었습니다.  </blockquote>
<a name="1006451"> </a> 
<blockquote></blockquote>
</ul><a name="1006536"> </a> 
<h4>A. 1.2	 JDBC 2.0 옵션 패키지에 추가된 기능</h4>
<p><a name="1006537"> </a> 다음의 기능은,<code>javax.sql</code> 패키지에 추가되었습니다만, 이번, JDBC 3.0 API 의 일부가 되어, 또, J2SE 버젼 1.4 에도 추가되었습니다.
</p><ul><a name="1006551"> </a> 
<li><code>DataSource</code> 객체에 의한 접속의 취득
<p><a name="1006552"> </a> JNDI API 와 새로운 <code>DataSource</code> 인터페이스를 사용하면, 어플리케이션으로부터 데이터 소스에 접속할 때에, 드라이버명을 코드내에서 지정할 필요가 없어집니다. JNDI 네이밍 서비스에 등록된 논리명을 지정하면,<code>DataSource</code> 객체를 취득할 수 있습니다.  이 객체를 사용하면, 목적의 데이터 소스에의 접속을 취득할 수 있습니다. 이 기능에 의해, 코드의 이식성이 높아져, 코드의 보수도 매우 편해집니다.
</p><a name="1006554"> </a> 
<li>접속 풀
<p><a name="1006555"> </a> 접속 풀을 사용하면, 어플리케이션은, 벌써 확립된 데이타베이스 접속을 재사용할 수 있게 되기 (위해)때문에, 항상 새로운 접속을 작성할 필요가 없어집니다. 데이타베이스 접속의 작성과 폐기는 매우 부담이 걸리는 처리이기 (위해)때문에, 양호한 퍼포먼스를 달성하는데 접속 풀은 중요합니다.
</p><p><a name="1006556"> 서버 어플리케이션의 경우는 특히 그렇습니다.  </a> JDBC 2.0 옵션 패키지 API 에는, JDBC 드라이버층의 상부에 접속 풀을 구현하는 것을 가능하게 하는 훅이 포함되어 있습니다. 이것에 의해, 사용중의 모든 JDBC 드라이버에 대한 단일의 접속 캐쉬를 제공하는 것이 가능하게 됩니다.  
</p><a name="1006557"> </a> 
<li>분산 트랜잭션(transaction)의 지원
<p><a name="1006558"> </a> JDBC 2.0 옵션 패키지 API 를 사용하면, JDBC 드라이버는, Java Transaction API (JTA)에 정의되고 있는 표준 2 단계 위탁 프로토콜을 지원할 수 있습니다.  이것은, 1 개의 트랜잭션(transaction)를 복수의 서버에 분산할 수 있는 것을 의미합니다. 따라서, 개발자는, Enterprise JavaBeans<sup><font size=-2>TM</font></sup> 컴퍼넌트를 사용해, 복수의 DBMS 서버에 걸쳐 트랜잭션(transaction) 처리를 실시하는 것 같은 엔터프라이즈 어플리케이션을 기술할 수가 있습니다.
</p><a name="1006576"> </a> 
<li>행 세트
<p><a name="1006577"> </a>  <code>RowSet</code> 객체는, 겉(표) 형식 데이터를 포함하기 위한 컨테이너에 외 되지 않습니다.  이 객체는, JDBC API 의 상층부에 구현됩니다. 행 세트를 사용하면, 네트워크 경유로 행 데이터를 교환할 수 있습니다.  이 때문에, 행 세트는 분산 어플리케이션으로 빈번하게 사용되게 됩니다. 행 세트는, 데이터 소스에의 접속을 절단 하는 것으로 큰폭으로 경량화할 수 있습니다.  따라서, 행 세트를 사용하면, thin 클라이언트상에 데이터를 표시하는 것이 가능하게 됩니다. 또, 행 세트를 사용하면, 기가 되는 DBMS 가 스크롤 가능한 결과 세트를 지원하고 있지 않는 경우에서도, 스크롤을 사용할 수 있습니다. 행 세트는, JavaBeans<sup><font size=-2>TM</font></sup> 컴퍼넌트이기 (위해)때문에, 어플리케이션 구축시의 취급도 간단합니다.
</p><p><a name="1006578"> 개발툴을 사용하는 경우는 특히 그렇습니다.  </a> 일반적으로의 경우,<code>RowSet</code> 의 구현은 서드 파티가 제공해 주기 (위해)때문에, 어플리케이션 프로그래머는, 제공된 구현을 다만 사용할 뿐입니다. <code>RowSet</code> 구현의 API 는 일반적으로, 사용법이 매우 간단합니다.  그렇다고 하는 것도, 행 세트의 기능의 대부분은,<code>ResultSet</code> 인터페이스로부터 상속된 것이기 때문입니다. 행 세트의 복잡한 측면은 모두 내부적으로 처리되기 (위해)때문에, 그러한 부분이 어플리케이션 프로그래머의 눈에 닿을 것은 없습니다. 현시점에서,<code>RowSet</code> 인터페이스의 Early Access 판 구현이 3 개 존재하고 있습니다.  이러한 구현은, Java Developer Connection (<code>http://developer.java.sun.com/developer</code>)로부터 입수할 수 있습니다.
</p></ul><a name="1006363"> </a> 
<h3>A. 2	 JDBC 2.0 코어 API 의 변경점의 개요</h3>
<p><a name="1005997"> </a>  JDBC 2.0 코어 API 는, JDBC 1.0 API 를 포함해, 한층 더 확장 기능 및 새로운 기능을 추가하고 있습니다. 이러한 추가된 기능에 의해, 범용적인 데이터 액세스와 향상한 퍼포먼스의 제공에 의해, 데이타베이스 컴퓨팅의 최전선에 Java 프로그램 언어를 자리 매김을 합니다.
</p><p><a name="1001420"> </a>  「하위 호환성의 목표」에 따르고 있으므로, 구버젼의 JDBC API 를 사용하는 어플리케이션은, Java 2 플랫폼을 사용해 문제 없게 실행할 수 있습니다. 그러나, 2.0 의 새로운 특징을 이용하는 어플리케이션은, 그러한 특징을 구현하고 있는 드라이버와 함께 실행하지 않으면 안됩니다. </a> </p><a backward compatibility of Java 2 platform><p><a name="1002119"> </a> 

</p></a> <p><a backward compatibility of Java 2 platform><a name="1001421"> </a> </a> JDBC 2.0 코어 API 의 새로운 특징은, 새로운 기능의 지원와 SQL99 데이터형의 지원의 2 개에 크게 분류됩니다.
</p><ol>
<a name="1001850"> </a> 
<li>새로운 기능의 지원
<ul>
<a name="1001851"> </a> 
<li>스크롤 가능한 결과 세트 <a name="1001853"> </a> 
<li>배치 갱신 <a name="1001854"> </a> 
<li>프로그램 가능한 삽입, 삭제, 갱신 <a name="1002080"> </a> 
<li>그 외
<ul>
<a name="1002668"> </a> 
<li>퍼포먼스 힌트 <a name="1005156"> </a> 
<li>국제화 된 Unicode 문자의 스트림을 위한 문자 스트림 <a name="1002670"> </a> 
<li><code>java.math.BigDecimal</code> 치의 완전한 정밀도 <a name="1002671"> </a> 
<li><code>Date</code>,<code>Time</code>,<code>Timestamp</code> 치에서의 타임 존의 지원
<p><a name="1002682"> </a> 

</p></ul>
</ul>
<a name="1001422"> </a> 
<li>진보한 데이터형의 지원
<ul>
<a name="1001423"> </a> 
<li>새로운 SQL 데이터형 (SQL99 형) <a name="1001424"> </a> 
<li>Java 프로그램 언어에서의 영속 객체 보존의 강화한 지원
<p><a name="1002687"> </a> 

</p><p><a name="1002688"> </a>  데이터의 검색, 보존, 조작이 편리하게 되어, 게다가 새로운 특징에 의해 JDBC 어플리케이션의 효율이 보다 좋아집니다. 예를 들어, 배치 갱신에 의해 성능이 큰폭으로 향상합니다. 새로운 <code>Blob</code>,<code>Clob</code>,<code>Array</code> 인터페이스에 의해, 어플리케이션은 클라이언트상에 데이터를 실체화할 필요없고, 대량의 데이터를 조작할 수가 있으므로, 전송 시간으로 필요한 메모리 용량의 큰 절약으로 연결됩니다. 또, 페치 사이즈와 페치 방향의 설정을 위한 새로운 메소드에 의해, 프로그래머는 어플리케이션을 미조정해, 보다 효율적인 데이터 검색과 처리를 달성할 수 있습니다.
</p></ul>
</ol>
<a name="1002684"> </a> 
<h3>A. 3	 새로운 기능의 개요</h3>
<p><a name="1001834"> </a>  JDBC 2.0 코어 API 는, 중요한 신기능을 추가하고 있습니다. 여기에서는, 각각의 새로운 기능 범위에 대해 간단하게 설명해, 지원하고 있는 API 를 정리합니다.
</p><a name="1001835"> </a> 
<h4>A. 3.1	 스크롤 가능한 결과 세트</h4>
<p><a name="1004166"> </a>  스크롤 가능한 결과 세트는, 현재의 커서 위치로부터의 상대 위치 또는 지정의 위치에, 커서를 진행시키거나 되돌리거나 할 수 있습니다. 다음의 인터페이스에는, 스크롤 가능한 결과 세트를 지원하는 새로운 메소드가 있습니다.
</p><ul><a name="1001879"> </a> 
<li>ResultSet 
<ul><a name="1001889"> </a> 
<li>커서를 특정의 행 또는 상대 위치로 이동하는 메소드 (전방 또는 후방 이동) <a name="1002298"> </a> 
<li>커서의 현재 위치를 확인하는 메소드 <a name="1001890"> </a> 
<li>결과 세트가 스크롤 가능한가 어떤가를 나타내는 정수
</ul><a name="1001893"> </a> 
<li>Connection
<ul><a name="1001901"> </a> 
<li><code>Statement</code>,<code>PreparedStatement</code>,<code>CallableStatement</code> 객체를 생성하는 메소드의, 스크롤 가능한 결과 세트를 작성하는 새로운 버젼
</ul><a name="1001994"> </a> 
<li>DatabaseMetaData
<ul><a name="1001995"> </a> 
<li>DBMS 와 드라이버가 스크롤 가능한 결과 세트를 지원할지 어떨지를 나타내는 메소드
</ul></ul><a name="1004175"> </a> 
<h4>A. 3.2	 배치 갱신</h4>
<p><a name="1004181"> </a>  새로운 배치 갱신 기능에 의해, 갱신을 개별적으로 송신하지 않고 , 데이타베이스에 복수의 갱신을 한 번에 송신해 배치 실행할 수가 있습니다. 다음의 인터페이스에는, 배치 갱신을 지원하는 메소드가 추가되고 있습니다. <code> BatchUpdateException</code> 예외는 신규입니다.
</p><ul><a name="1002113"> </a> 
<li>Statement, PreparedStatement, 및 CallableStatement
<ul><a name="1002114"> </a> 
<li>배치에 갱신의 문장을 추가하는 메소드, 모든 갱신의 문장을 클리어 하는 메소드, 배치를 실행하는 메소드
</ul><a name="1004185"> </a> 
<li>DatabaseMetaData
<ul><a name="1004186"> </a> 
<li>DBMS 와 드라이버가 배치 갱신을 지원할지 어떨지를 나타내는 메소드
</ul><a name="1002262"> </a> 
<li>BatchUpdateException
<ul><a name="1002263"> </a> 
<li>배치 갱신으로 에러가 발생했을 때에 발행되는 예외
</ul></ul><a name="1001839"> </a> 
<h4>A. 3.3	 프로그램적인 갱신</h4>
<p><a name="1004194"> </a>  프로그램적인 갱신에 의해, SQL 문은 아니고 JDBC API 를 사용해 갱신을 실시할 수가 있습니다. 다음의 인터페이스에는, 프로그램적인 갱신을 지원하는 새로운 메소드와 정수가 있습니다.
</p><ul><a name="1001919"> </a> 
<li>ResultSet
<ul><a name="1001934"> </a> 
<li>각 데이터형을 갱신하기 위한 <code>updater</code> 메소드 <a name="1001939"> </a> 
<li>행의 삽입, 삭제, 갱신을 위한 메소드 <a name="1002047"> </a> 
<li>어느 행이 삽입, 삭제, 갱신되었는지의 여부를 나타내는 메소드 <a name="1002051"> </a> 
<li>행의 갱신을 캔슬하기 위한 메소드 <a name="1001941"> </a> 
<li>결과 세트가 갱신 가능한가 어떤가를 나타내는 정수
</ul><a name="1001927"> </a> 
<li>DatabaseMetaData
<ul><a name="1001965"> </a> 
<li>결과 세트에의 변경이 가시인가 어떤가를 나타내는 정수 <a name="1001968"> </a> 
<li>결과 세트가 삽입, 삭제, 갱신을 검출할지 어떨지를 나타내는 메소드 <a name="1002002"> </a> 
<li>DBMS 와 드라이버가 갱신 가능한 결과 세트를 지원할지 어떨지를 나타내는 메소드
</ul></ul><a name="1005056"> </a> 
<h4>A. 3.4	 그 외의 새로운 특징</h4>
<p><a name="1004199"> </a>  JDBC 2.0 코어 API 에는, 상기 외에, 다양한 새로운 특징이 있습니다.  이 특징을 다음에 정리합니다.
</p><ul><a name="1005117"> </a> 
<li>성능의 향상 - 새로운 메소드에 의해, 데이타베이스로부터의 행의 검색을 프로그래머가 미조정할 수가 있습니다. 이러한 메소드에는, (1) 한층 더 많은 행이 필요한 때에 데이타베이스로부터 페치 하는 결과 세트행의 수를 지정해, (2) 데이타베이스로부터 행을 페치 할 방향을 지정하는 기능이 있습니다.
<ul><a name="1005121"> </a> 
<li>현재의 페치 사이즈와 페치 방향의 취득과 설정에 사용하는 <code>ResultSet</code> 메소드 <a name="1005123"> </a> 
<li>결과 세트의 디폴트의 페치 사이즈와 페치 방향을 취득해 설정하는 <code>Statement</code>,<code>PreparedStatement</code>, 및 <code>CallableStatement</code> 메소드.  이 디폴트의 설정은, 쿼리의 실행에 의해 결과 세트가 최초로 작성될 때 그 결과 세트로 설정됩니다.
</ul><a name="1002712"> </a> 
<li>문자 스트림 - 문자 데이터를, 국제화 된 Unicode 문자의 스트림로서 데이타베이스로부터 검색하거나 데이타베이스에 보내거나 할 수가 있는 메소드. 새로운 메소드는, 추천되어 있지 않은 <code>getUnicodeStream</code> 와 <code>setUnicodeStream</code> 의 2 개의 메소드를 옮겨놓고 있습니다.
<ul><a name="1002722"> </a> 
<li><code>ResultSet.getCharacterStream</code> <a name="1002732"> </a> 
<li><code>CallableStatement.getCharacterStream</code> <a name="1002739"> </a> 
<li><code>PreparedStatement.setCharacterStream</code>
</ul><a name="1002713"> </a> 
<li><code>java.math.BigDecimal</code> 치의 완전한 정밀도 - <code> java.math.BigDecimal</code> 치를 완전한 정밀도로 취급하는, 새로운 버젼의 메소드. 추천되어 있지 않은 버젼과는 달라, 새로운 버젼에서는 정밀도의 지정을 받지 않습니다.
<ul><a name="1002782"> </a> 
<li><code>ResultSet.getBigDecimal</code> <a name="1002740"> </a> 
<li><code>CallableStatement.getBigDecimal</code>
</ul><a name="1002748"> </a> 
<li>타임 존의 지원 - 파라미터로서 <code>Calendar</code> 객체를 받는 새로운 버젼의 메소드. 드라이버에 대해, 일자, 시간, 타임 스탬프의 값을 계산할 때, 디폴트는 아니고 지정된 타임 존을 사용할 수 있습니다.
<ul><a name="1002747"> </a> 
<li><code>ResultSet.getDate</code> <a name="1002749"> </a> 
<li><code>ResultSet.getTime</code> <a name="1002750"> </a> 
<li><code>ResultSet.getTimestamp</code> <a name="1002768"> </a> 
<li><code>CallableStatement.getDate</code> <a name="1002769"> </a> 
<li><code>CallableStatement.getTime</code> <a name="1002770"> </a> 
<li><code>CallableStatement.getTimestamp</code> <a name="1002751"> </a> 
<li><code>PreparedStatement.setDate</code> <a name="1002754"> </a> 
<li><code>PreparedStatement.setTime</code> <a name="1002755"> </a> 
<li><code>PreparedStatement.setTimestamp</code>
</ul></ul><a name="1001702"> </a> 
<h3>A. 4	 진화한 데이터형의 지원</h3>
<p><a name="1002459"> </a>  JDBC 2.0 코어 API 에는 진화한 데이터형의 지원가 추가되어 단순한 데이터형과 같게 간단하게 진화한 데이터형을 사용할 수 있습니다. 이 지원에는, 본질적으로는 객체인 새로운 SQL 데이터형의 보존, 검색, 갱신의 기능도 포함되므로, 객체 데이타베이스와 RDB의 명확한 구별을 없앨 수가 있습니다. 다음의 4 개의 마디 (<a href="appendixB.html#1002458">「A. 4.1 SQL99 데이터형이란 무엇인가」</a>,<a href="appendixB.html#1001430">「A. 4.2 SQL99 데이터형의 지원의 개요」</a>,<a href="appendixB.html#1001475">「A. 4.3 SQL99 형의 매핑」</a>,<a href="appendixB.html#1001484">「A. 4.4 SQL locator」</a>)로,JDBC 2.0 코어 API 의 고도의 데이터형의 지원에 대해 설명합니다.
</p><p><a name="1002464"> </a>  SQL 로 정의되고 있는 객체를 데이타베이스 테이블내의 값으로 해서 보존 가능한 한은 아니고, Java 어플리케이션을 작성하는 프로그래머는, Java 프로그램 언어로 정의되고 있는 객체를 데이타베이스 테이블내의 값으로 해서 보존할 수가 있습니다. <a href="appendixB.html#1002502">「A. 3.5 Java 객체 보존의 지원」</a>  로, 이 기능에 대해 설명합니다.
</p><p><a name="1002550"> </a>  드라이버는, 그 드라이버의 DBMS 가 지원하고 있지 않는 기능을 구현하도록(듯이)는, 요구되고 있지 않습니다.  그 때문에, 모든 드라이버가, 여기서 설명하고 있는 기능을 구현할 필요는 없습니다. <code>getTypeInfo</code>,<code>getColumns</code>,<code>getUDTs</code> 등의 <code>DatabaseMetaData</code> 메소드를 호출해, 드라이버가 지원하고 있는 데이터형의 정보를 취득할 수가 있습니다.
</p><a name="1002458"> </a> 
<h4>A. 4.1	 SQL99 데이터형이란 무엇인가</h4>
<p><a name="1001703"> </a> 여기에서는 새로운 SQL99 데이터형에 대해 설명합니다. Java 프로그램 언어의 데이터형에의 이러한 데이터형의 매핑에 대해서는,<a href="appendixB.html#1001475">「A. 4.3 SQL99 형의 매핑」</a>으로 설명합니다.
</p><p><a name="1001769"> </a> 

</p><p><a name="1002534"> </a>  SQL99 데이터형은, 다음과 같이 분류됩니다.
</p><a name="1006131"> </a> 
<blockquote></blockquote>
<ul><a name="1001704"> </a> 
<li>새로운 편입형 - 큰 객체를 보존하기 위한 데이터형. <code>CHAR</code>,<code>FLOAT</code>,<code>DATE</code> 등의 표준의 편입 데이터형에 추가됩니다.
<ul><a name="1001705"> </a> 
<li><code>BLOB</code> (바이너리 라지 객체) <a name="1001706"> </a> 
<li><code>CLOB</code> (캐릭터 라지 객체)
</ul><a name="1001707"> </a> 
<li>구축형 - 주어진 기본형을 기본으로 한 데이터형
<ul><a name="1001708"> </a> 
<li><code>REF(</code>구조화형<code>)</code> - 지정된 SQL 구조화형에의 참조 <a name="1001709"> </a> 
<li><code>ARRAY[n]</code>: 모두 같은 데이터형의 <code>n</code> 개의 요소의 배열
</ul><a name="1001710"> </a> 
<li>사용자 정의형 (UDT) - SQL 커멘드 &thorn;<code>CREATE TYPE</code> 에 의해 작성되는 새로운 데이터형
<ul><a name="1001711"> </a> 
<li>개별형 - 단일의 편입형의 표현에 근거하는 새로운 데이터형 <a name="1001712"> </a> 
<li>구조화형 - 편입형이나 사용자 정의형등의 복수의 속성을 가지는, 새로운 데이터형
</ul><a name="1001713"> </a> 
<li>locator형 - 데이터 베이스 서버-에 속하는 데이터에의 논리 포인터인 데이터형
<ul><a name="1001714"> </a> 
<li><code>LOCATOR(구조화형)</code> <a name="1001715"> </a> 
<li><code>LOCATOR(배열)</code> <a name="1001716"> </a> 
<li><code>LOCATOR(바이너리 라지 객체)</code> <a name="1001717"> </a> 
<li><code>LOCATOR(캐릭터 라지 객체)</code>
</ul></ul><a name="1001430"> </a> 
<h4>A. 4.2	 SQL99 데이터형의 지원의 개요</h4>
<p><a name="1001431"> </a> JDBC 2.0 코어 API 는, 다음의 새로운 인터페이스, 메소드, 필드에 의해, 새로운 SQL99 데이터형을 지원합니다.
</p><ul><a name="1001432"> </a> 
<li>새로운 데이터형을 위한 새로운 인터페이스. SQL99 데이터형은, 다음의 JDBC 2.0 코어 API 인터페이스에 의해 매핑 된다
<ul><a name="1001433"> </a> 
<li><code>java.sql.Array</code> <a name="1001434"> </a> 
<li><code>java.sql.Blob</code> <a name="1001435"> </a> 
<li><code>java.sql.Clob</code> <a name="1001436"> </a> 
<li><code>java.sql.Ref</code> <a name="1001437"> </a> 
<li><code>java.sql.Struct</code>
</ul><a name="1001438"> </a> 
<li>Java 프로그램 언어의 클래스에의 UDT (SQL 구조화형과 개별형)의 매핑의 커스터마이즈를 지원하는 인터페이스
<ul><a name="1001439"> </a> 
<li><code>SQLData</code> <a name="1001440"> </a> 
<li><code>SQLInput</code> <a name="1001441"> </a> 
<li><code>SQLOutput</code>
</ul><a name="1001442"> </a> 
<li>새로운 SQL99 데이터형을 취득, 보존, 갱신하기 위해서 기존의 인터페이스에 추가된 메소드
<ul><a name="1001443"> </a> 
<li><code>ResultSet</code> 인터페이스의 새로운 <code>getter</code> 메소드.  결과 세트로부터 SQL99 형의 렬치를 취득한다 <a name="1001444"> </a> <code></code>
<li><code>CallableStatement</code> 인터페이스의 새로운 <code>getter</code> 메소드.  출력 파라미터내의 SQL99 형의 값을 취득한다 <a name="1001445"> </a> <code></code>
<li><code>PreparedStatement</code> 인터페이스의 새로운 <code>setter</code> 메소드.  SQL99 형의 렬치를 설정한다 <a name="1006026"> </a> 
<li><code>ResultSet</code> 인터페이스의 새로운 <code>updater</code> 메소드.  프로그램에 의해 값을 갱신한다<code></code>
</ul><a name="1006027"> </a> 
<li><code>DatabaseMetaData</code> 와 <code>ResultSetMetaData</code> 인터페이스의 메소드.  SQL99 데이터형에 관한 메타데이타를 취득한다 <a name="1001448"> </a> 
<li><code>java.sql.Types</code> 클래스에 추가된 필드 (정수).  새로운 데이터형과 영속적인 보존을 지원한다
<ul><a name="1001449"> </a> 
<li><code>DISTINCT</code> <a name="1001450"> </a> 
<li><code>STRUCT</code> <a name="1001451"> </a> 
<li><code>ARRAY</code> <a name="1001452"> </a> 
<li><code>BLOB</code> <a name="1001453"> </a> 
<li><code>CLOB</code> <a name="1001454"> </a> 
<li><code>REF</code> <a name="1001455"> </a> 
<li><code>JAVA_OBJECT</code>
</ul></ul><a name="1001475"> </a> 
<h4>A. 4.3	 SQL99 형의 매핑</h4>
<p><a name="1001660"> </a> JDBC API 에서는, SQL99 데이터형의 정확한 복제를 시도하는 것이 아니라, 그러한 데이터형을 Java 프로그램 언어의 형태에 매핑 하는 것으로써, 그러한 데이터형의 기능성을 유지해, 사용의 편의를 도모하는 것을 목표로 합니다. 예를 들어, SQL99 에는 「locator형」이라고 불리는 데이터형이 있어, 데이터 베이스 서버-에 보존되고 있는 데이터를 가리키기 위해서(때문에) 클라이언트상에서 사용됩니다. locator에서는 클라이언트 머신상에 데이터를 실체화하지 않아도 데이터를 조작할 수 있으므로, 큰 데이터를 취급하는 경우에 도움이 됩니다. SQL99 에는,<code>ARRAY</code>,<code>BLOB</code>,<code>CLOB</code> 형과 구조화형을 위한 locator가 포함되어 있습니다. JDBC API 에는, 직접적으로는 이러한 데이터형을 위한 locator는 포함되어 있지 않습니다 (구조화형을 위한 locator는 전혀 없습니다)가, 드라이버와 DBMS 가 상황에 맞추어 적절한 locator를 사용하도록(듯이) 구현된 인터페이스가 있습니다. 그 결과, JDBC API 를 사용해 SQL 의 <code>ARRAY</code>,<code>BLOB</code>,<code>CLOB</code> 형의 값에 액세스 하는 경우, 개발자는 locator에 대해 생각할 필요는 없습니다.
</p><p><a name="1001664"> </a> SQL99 형으로부터 Java 프로그램 언어의 인터페이스에의 매핑은, 다음과 같습니다.
</p><ul><a name="1001478"> </a> 
<li><code>ARRAY</code> - <code>java.sql.Array</code> 에 매핑 된다 <a name="1001479"> </a> 
<li><code>BLOB</code> - <code>java.sql.Blob</code> 에 매핑 된다 <a name="1001480"> </a> 
<li><code>CLOB</code> - <code>java.sql.Clob</code> 에 매핑 된다 <a name="1001481"> </a> 
<li><code>REF</code> - <code>java.sql.Ref</code> 에 매핑 된다
</ul><ul><a name="1001482"> </a> 
<li>SQL 구조화형 - <code>java.sql.Struct</code> 에 매핑 된다
</ul><p><a name="1001483"> </a>  개별형은 단일의 편입형을 기본으로 하고 있기 (위해)때문에, 단순하게 그 편입형에의 표준적인 매핑에 매핑 되어 인터페이스에는 매핑 되지 않습니다. 예를 들어, 다음의 SQL 문은 새로운 데이터형 <code>MONEY</code> 를 작성합니다.
</p><blockquote><pre>
CREATE TYPE MONEY AS NUMERIC(10, 2)
</pre></blockquote><p><a name="1002576"> </a> 이 새로운 UDT 는 <code>java.math.BigDecimal</code> 에 매핑 되는 데이터형 <code>NUMERIC</code> 를 기본으로 하고 있습니다. 그 때문에, 데이터형 <code>MONEY</code> 는 <code>java.math.BigDecimal</code> 에 매핑 됩니다. 따라서,<code>MONEY</code> 형의 값은 <code>getBigDecimal</code> 메소드로 취득되어<code>setBigDecimal</code> 메소드로 보존되어<code>updateBigDecimal</code> 메소드로 갱신됩니다.  
</p><a name="1001484"> </a> 
<h4>A. 4.4	 SQL locator</h4>
<p><a name="1001485"> </a>  SQL <code>LOCATOR</code> 는, 데이터 베이스 서버-위의 데이터에의 논리 포인터입니다. 일반적으로, 화상이나 오디오 등, 클라이언트상에 생성하기에는  너무 큰 데이터를 참조합니다. locator는 클라이언트 환경에게만 존재해, 일시적인 존재입니다. 표준 구현에서는, 인터페이스 <code>Blob</code>,<code>Clob</code>,<code>Array</code> 의 인스턴스에 대해서, locator를 내부적으로 사용합니다. 즉,<code>Blob</code>,<code>Clob</code>,<code>Array</code> 객체에는 데이터 그 자체가 포함되어 있는 것이 아니라, 서버상의 데이터를 가리키는 locator가 포함되어 있습니다. <code>Blob</code>,<code>Clob</code>,<code>Array</code> 인스턴스를 조작한다고 하는 것은, 실제로는, 그것들이 나타내는 데이타베이스 객체를 조작하고 있게 됩니다. 클라이언트에 데이터를 반입하지 않고 큰 데이타베이스 객체를 조작하는 이 기능은, 성능에 크게 공헌합니다.
</p><p><a name="1001747"> </a> 다만, SQL <code>LOCATOR(</code>구조화형<code>)</code> 의 사용을, JDBC API 가 필요로 하고 있는 것은 아닙니다. 표준적인 구현에서는,<code>Struct</code> 객체에는, 그것이 매핑 되는 구조화형의 데이터가 포함되어 있어,<code>Blob</code>,<code>Clob</code>,<code>Array</code> 객체와 같은 내부적인 locator로서는 구현되고 있지 않습니다.
</p><a name="1002502"> </a> 
<h4>A. 4.5	 Java 객체 보존의 지원</h4>
<p><a name="1002503"> </a>  JDBC API 에서는, Java 프로그램 언어 정의되고 있는 영속적인 보존을, <code>getObject</code>,<code>setObject</code> 메소드를 통해서, 항상 지원 사계라고 있습니다. 물론, Java 객체의 영속적인 보존은, DBMS 가 그것을 지원하고 있지 않는 한 실제로는 일어날 수 없습니다. 이 때문에 지원에는 제한이 있습니다만, Java 객체를 데이터형으로서 인식하는 신세대의 DBMS 가 출현하고 있습니다. Java 릴레이셔널 DBMS 로 불리는 이러한 DBMS 에서는, Java 클래스의 인스턴스를 데이타베이스 테이블내의 열의 값으로 해서 보존할 수 있습니다.
</p>
<hr><br>
 
<a href="GettingStartedTOC.fm.html">[선두의 항목]</a>  <a href="rowsetImpl.html">[전의 항목]</a>  [다음의 항목] [마지막 항목]
<hr><br>



<i><a href="copyright.html">Copyright</a>  &#169; 2001, Sun Microsystems, Inc.    All rights reserved. </i>

</body>
</html>
