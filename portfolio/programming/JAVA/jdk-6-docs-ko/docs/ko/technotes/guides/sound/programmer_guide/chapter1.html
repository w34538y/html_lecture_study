<html><head>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">
<title> - xrath.com 에서 번역됨</title>

</head>
<body bgcolor=#ffffff>
<hr>
<h1>제 1 장 :Java Sound API 의 소개 </h1>
<hr>
<form name="form1">
  <select name="menu1" onChange="Eminem_jumpMenu('parent',this,1)">
    <SCRIPT SRC="menu_script.js" language="JavaScript"></SCRIPT>
  </select>
</form>
<p>&nbsp;</p>
<h3> <a name="design"></a> 설계 목표</h3>
<p><a name="111812"> </a> Java<font size="-1"><sup>TM</sup></font> Sound API 는, 오디오 데이터와 Musical Instrument Digital Interface (MIDI) 데이터의 양쪽 모두를 포함한 음성 미디어의 입출력에의 효과와 제어를 위한 저레벨 API 입니다. Java Sound API 는, 확장성과 유연성을 향상시키는 시스템에 의해, 사운드 입출력에 일반적으로 필요한 기능에 대한 명시적인 제어를 제공합니다.
</p><a name="111814"> </a> 
<h4> Java Sound API 의 대상자 </h4>
<p><a name="111816"> </a> 사운드는 가장 기본적인 요소이기 (위해)때문에, Java Sound API 는 광범위한 어플리케이션 개발자의 요구에 대응하고 있습니다. Java Sound API 는, 예를 들어 다음과 같은 영역의 어플리케이션에 적용됩니다.
</p><ul><a name="111817"> </a> 
<li>통신 시스템 (회의, 전화 등) <a name="111818"> </a> 
<li>최종 사용자 컨텐츠의 배포 시스템 (미디어 플레이어나 음악을 스트리밍 한 컨텐츠를 사용해 배포)<a name="111819"> </a> 
<li>대화형 응용 프로그램 (동적인 컨텐츠를 사용한 게임이나 Web 사이트 등)<a name="111820"> </a> 
<li>컨텐츠의 작성 및 편집 <a name="111821"> </a> 
<li>툴, 툴 킷, 및 유틸리티프로그램 
</ul><a name="111823"> </a> 
<h4> Java Sound API 와 다른 인터페이스의 관계 </h4>
<p><a name="111825"> </a> Java Sound API 는, Java 플랫폼에서 가장 저레벨의 사운드 기능을 제공합니다. 그리고, 응용 프로그램에 사운드 조작을 위한 매우 많은 제어를 제공함과 함께, 확장성도 갖추고 있습니다. Java Sound API 는, system resource (오디오 믹서, MIDI 신디사이저, 다른 오디오 디바이스 또는 MIDI 디바이스, 파일 리더 및 라이터, 사운드 형식 컨버터등)에 대한 인스톨, 액세스, 조작의 각 기능을 갖추고 있습니다. Java Sound API 에는, 고도의 사운드 에디터나 그래픽 툴은 없습니다만, 그러한 프로그램을 작성하기 위해서 사용할 수 있는 기능을 제공합니다. 또, 이 API 가 갖추는 저레벨 제어 기능은, 일반적으로 최종 사용자가 기대하는 이상의 것입니다.
</p><p><a name="111827"> </a> 사운드 관련의 요소를 가지는 Java 플랫폼 API 는 그 밖에도 있습니다. Java Media Framework (JMF)는 한층 더 고레벨의 API 로, 현재는 Java 플랫폼의 표준 확장으로서 입수 가능합니다. JMF 는, 시간 베이스 미디어의 혼잡과 재생을 위한 통합 아키텍쳐(architecture), 메시지 교환 프로토콜, 프로그래밍 인터페이스를 정하고 있습니다. 기본적인 미디어 재생 응용 프로그램에, 보다 간단한 솔루션을 제공합니다. 또, JMF 를 사용하면(자), 오디오와 비디오간 등 이종의 미디어간의 동기화가 가능하게 됩니다. 한편, 사운드를 중시하는 프로그램, 특히 버퍼링 된 오디오의 재생을 세세하게 제어하는 능력이나 MIDI 신디사이저를 직접 조작하는 능력 등, 고도의 기능을 필요로 하는 프로그램에서는, Java Sound API 가 도움이 됩니다. 사운드 기능에 관련하는 Java API 로서는, 이 밖에, Java 3D 및, 전화와 발화를 위한 API 가 있습니다. 이러한 API 는, Java Sound API 의 구현을 내부적으로 사용해 구현할 수 있습니다만, 사용하지 않아도 상관하지 않습니다.
</p><a name="111831"> </a> 
<h3> 패키지</h3>
<p><a name="111832"> </a> Java Sound API 에는, 디지털 오디오 데이터와 MIDI 데이터의 양쪽 모두를 지원하는 기능이 있습니다. 이러한 주된 2 개의 기능의 모듈은, 다른 패키지로 제공됩니다.  
</p><ul><a name="111834"> </a> 
<li><code>javax.sound.sampled </code> <a name="111835"> </a> 
<blockquote>이 패키지에서는, 디지털 (샘플링) 오디오의 수중에 넣어, 믹싱, 및 재생을 위한 인터페이스를 지정하고 있습니다.  </blockquote>
<a name="111837"> </a> 
<li><code>javax.sound.midi</code> <a name="111838"> </a> 
<blockquote>이 패키지에서는, MIDI 합성, 시켄싱, 및 이벤트 전송을 위한 인터페이스를 제공하고 있습니다. </blockquote>
<p><a name="111840"> </a> 
</ul>
이 밖에, 다음의 2 개의 패키지에 의해, 서비스 프로바이더 (어플리케이션 개발자와 대립하는 입장)가, Java Sound API 의 구현의 기능을 확장하는 커스텀 소프트웨어를 작성할 수 있게 됩니다.
<p></p><a name="111842"> </a> 
<ul>
<li><code>javax.sound.sampled.spi </code> <a name="111843"> </a> 
<li><code>javax.sound.midi.spi </code>
<p><a name="111845"> </a> 
</ul>
이 장의 후반으로는, 샘플링 오디오 시스템, MIDI 시스템, SPI 패키지에 대해 간단하게 설명합니다. 각각의 상세한 것에 대하여는, 그 후 설명합니다.  
<p></p><a name="111847"> </a> 
<h3> 샘플링 오디오</h3>
<a name="111849"> </a> 
<h4> 샘플링 오디오란</h4>
<p><a name="112308"> </a>  <code> javax.sound.sampled</code> 패키지가 처리하는 디지털 오디오 데이터를, Java Sound API 에서는 「샘플링 오디오」라고 부릅니다. 「샘플」이란, 신호가 연속하는 snapshot입니다. <em></em>오디오의 경우, 그 신호는 음파입니다. 마이크로폰이 어쿼스틱 신호를 아날로그의 전기신호로 변환해, 그 아날로그 신호를 AD 컨버터가 샘플링 디지털 형식으로 변환합니다. 다음의 그림에, 녹음의 일부를 나타냅니다.
</p>
<blockquote><i><img src="images/chapter1.anc.gif" alt="음파의 샘플링" width="268" height="239"></i></blockquote>

<blockquote><i>음파의 샘플링</i></blockquote>

<blockquote><i></i></blockquote>
<p><a name="111861"> </a> 그래프의 세로축은 음압 (진폭)을 나타내, 횡축은 시간을 나타냅니다. 아날로그 음파의 진폭은 일정한 간격으로 주기적으로 측정하면(자), 디지털 오디오 신호를 구성하는 이산적인 샘플 (그림의 붉은 데이터 포인트)이 됩니다. 중앙의 수평선은 진폭 0 을 나타내, 이것보다 위의 점은 정의 값의 샘플, 이것보다 아래의 점은 0 보다 작은 값입니다. 아날로그 신호의 디지털 근사의 정밀도는, 시간의 분해가능 (샘플링 레이트)과 양자화 즉 진폭의 분해가능 ( 각 샘플을 표현하기 위해서 사용하는 비트의 수)에 의존합니다. <em></em><em></em>참고 기준으로서 콤팩트 디스크용으로 녹음되는 오디오의 샘플링 레이트는 44,100 회/초로, 각 샘플의 비트수는 16 입니다.  
</p><p><a name="115938"> </a> 여기에서는, 「산프링오디오」라고 하는 용어는 너무 엄밀하게 정의하고 있습니다. 음파는, 아날로그 형식인 채 이산 간격으로 샘플링 할 수도 있습니다. 다만, Java Sound API 에서는, 「샘플링 오디오」는 「디지털 오디오」라고 동의입니다.
</p><p><a name="115936"> </a> 일반적으로, 컴퓨터상의 샘플링 오디오는 녹음에 의해 작성됩니다만, 합성해 생성하는 경우도 있습니다 (푸쉬 버튼식 전화의 음성을 작성하는 경우 등). 「샘플링 오디오」라고 하는 용어는, 데이터의 종류를 나타내, 데이터의 출처(소)를 나타내는 것이 아닙니다.  
</p>
<p><a name="112752"> </a>  디지털 오디오 데이터의 구조의 자세한 것은, 제 2 장<a href="chapter2.html">「Sampled 패키지의 개요」</a>의<a href="chapter2.html#112348">「서식 첨부 오디오 데이터란」</a>을 참조해 주세요.  
</p>
<a name="112759"> </a> 
<h4> 오디오 구성 </h4>
<p><a name="111869"> </a> Java Sound API 는, 특정의 오디오 하드웨어 구성을 상정하고 있습니다. 시스템상에 다양한 종류의 오디오 컴퍼넌트를 인스톨 할 수 있도록(듯이) 설계되고 있어 그것들에는 API 를 사용해 액세스 할 수 있습니다. Java Sound API 는, 사운드 카드에 대한 입출력 (사운드 파일의 녹음이나 재생 등), 오디오의 복수의 스트림의 믹싱 등, 일반적인 기능을 지원하고 있습니다. 다음에, 일반적인 오디오 아키텍쳐(architecture)의 예를 나타냅니다.
</p>
<p><a name="112280"> </a>  <img src="images/chapter1.anc1.gif" alt="이후의 문장으로, 이 그림에 대해 설명하고 있습니다. " width="413" height="251"> 
</p>
<blockquote><i>일반적인 오디오 아키텍쳐(architecture)</i></blockquote>
<p><a name="111874"> </a> 이 예에서는, 사운드 카드등의 디바이스에 다양한 입출력 포트가 있어, 믹싱은 소프트웨어내에서 행해집니다. 믹서가 받는 데이터는, 파일로부터 읽어들인 것, 네트워크로부터의 스트림, 응용 프로그램이 진행중에 생성한 것, MIDI 신디사이저가 생성한 것 등 다양합니다. 다음에 설명하는 <code>javax.sound.midi</code> 패키지는, 신디사이저를 위한 Java 언어 인터페이스입니다. 믹서는 모든 오디오 입력을 1 개의 스트림에 정리하므로, 그것을 출력 디바이스에 보내 렌더링 할 수가 있습니다.
</p><a name="111877"> </a> 
<h3> MIDI</h3>
<p><a name="111878"> </a>  <code>javax.sound.midi</code> 패키지에는, MIDI 이벤트의 전송과 시켄싱을 위한 API, 및 그러한 이벤트로부터의 사운드를 합성하기 위한 API 가 있습니다.
</p><a name="111880"> </a> 
<h4> MIDI 란</h4>
<p><a name="112123"> </a> 샘플링 오디오가 사운드 그 자체의 직접 표현인데 대해, MIDI 데이터는 소리, 특히 음악을 작성하기 위한 레시피라고 생각할 수가 있습니다. MIDI 데이터는, 오디오 데이터와 같이 사운드를 직접 기술할 것은 없습니다. 대신에, 신디사이저에 의해 작성되는 사운드에 영향을 주는 이벤트를 기술합니다. MIDI 데이터는, GUI (그래피컬 사용자 인터페이스)의 키보드 이벤트와 마우스 이벤트에 유사하고 있습니다. MIDI 의 경우는, 이벤트는 건반에 대한 액션, 또는 악기의 페달, 슬라이더, 스윗치, 안주 등에 대하는 액션이다고 생각할 수가 있습니다. 이러한 이벤트는, 실제로 하드웨어로서의 악기로 만들어진 것일 필요는 없습니다. 소프트웨어로 시뮬레이션 한 것을 MIDI 파일에 보존할 수가 있습니다. 이러한 파일을 작성, 편집, 실행하는 프로그램을 시퀀서라고 부릅니다. 컴퓨터용 사운드 카드에는 MIDI 제어 가능한 음악 신디사이저 팁이 탑재되고 있는 것이 많아, 시퀀서로부터 MIDI 이벤트를 보낼 수가 있습니다. 시퀀서는, 완전하게 소프트웨어내에 구현할 수도 있습니다. 신디사이저는, 받은 MIDI 이벤트를 해석해 오디오 출력을 생성합니다. 일반적으로, MIDI 데이터로부터 합성되는 소리는, 발화등으로는 없고, 음악입니다. MIDI 신디사이저에 의해, 각종의 사운드 효과를 생성할 수도 있습니다.  
</p><p><a name="111884"> </a> 일부의 사운드 카드에는 MIDI 입출력 포트가 있어, 외부 하드웨어 디바이스 (키보드 신디사이저등의 기기)를 접속할 수 있습니다. 응용 프로그램은, 외부의 MIDI 탑재 악기가 생성한 이벤트를 MIDI 입력 포트로부터 수신할 수 있습니다. 프로그램은, 컴퓨터의 내부 신디사이저를 사용해 음악의 연주를 하거나 MIDI 파일로서 디스크에 보존하거나 음표로 변환하거나 할 수가 있습니다. 또, 프로그램은 MIDI 출력 포트를 사용해 외부의 악기를 연주하거나 녹음 기기등의 외부 디바이스를 제어할 수가 있습니다.
</p>
<p><a name="112482"> </a>  MIDI 데이터에 대해서는, 제 8 장<a href="chapter8.html">「MIDI 패키지의 개요」</a>에 설명이 있습니다만, 특히 「MIDI 에 대해:와이어와 파일」시에에 상세한 설명이 있기 때문에 참조해 주세요.  </p>
<a name="112483"> </a> 
<h4> MIDI 의 구성</h4>
<p><a name="112765"> </a> 아래의 그림에, Java Sound API 를 기본으로 한, MIDI 구성 예의 안의 주된 컴퍼넌트간의 기능의 관계를 나타냅니다. 오디오의 경우와 같게, Java Sound API 에서는 다양한 MIDI 소프트웨어 디바이스를 인스톨 해 상호 접속할 수가 있습니다. 여기서 가리키는 시스템은, 일례에 지나지 않습니다. 컴퍼넌트간의 데이터의 흐름은, 화살표로 가리켜 있습니다. 데이터는, 표준 파일 형식의 데이터의 경우도 있어, 오디오, raw MIDI 바이트, 시각의 태그가 붙은 MIDI 메세지등의 경우도 있습니다 (그림의 우하구석의 key 를 참조).  
</p>
<p><a name="112766"> </a>  <img src="images/chapter1.anc2.gif" alt="이후의 문장으로, 이 그림에 대해 설명하고 있습니다. " width="520" height="360"> 
</p>
<blockquote><i>MIDI 구성의 예</i></blockquote>
<p><a name="111896"> </a> 이 예에서는, 응용 프로그램은, 디스크상에 표준 MIDI 파일로서 보존되고 있는 악보를 로드해 음악의 연주의 준비를 합니다 (그림의 좌측). 표준 MIDI 파일에는, 트럭이 포함되어 있습니다. 각각의 트럭은, 시각의 태그가 붙은 MIDI 이벤트의 리스트입니다. 이벤트의 대부분은 음표 (피치와 리듬)를 나타냅니다. 이 MIDI 파일을 소프트웨어 시퀀서가 읽어들여, 다음에 「연주」합니다. 시퀀서는, 내부 또는 외부의 신디사이저등의 디바이스에 MIDI 이벤트를 송신하는 것에 의해 음악의 연주를 실시합니다. 신디사이저 자체가, 특정의 악기의 사운드를 에뮤레이트하기 위한 지시가 포함되어 있는 사운드 뱅크 파일을 읽어들이는 일도 있습니다. 그 이외의 경우는, 신디사이저는 벌써 신디사이저에 로드 되고 있는 악기의 사운드를 모두 사용해, MIDI 파일안의 소리를 재생합니다.
</p><p><a name="111898"> </a> 그림에 나타내는 대로, MIDI 이벤트는 MIDI 출력 포트를 사용해 외부의 신디사이저에 송신하기 전에, 시각의 태그가 붙지 않은 raw MIDI 에 변환될 필요가 있습니다. 같이 외부 MIDI 소스 (그림의 건반악기)로부터 컴퓨터에 입력되는 raw MIDI 데이터는 시각의 태그가 붙은 MIDI 메세지에 변환됩니다. 이 메세지에 의해 신디사이저를 제어할 수 있습니다. 또, 나중에 사용하기 위해서 시퀀서가 이 메세지를 보존해 둘 수가 있습니다. MIDI 데이터의 흐름에 관해서는, MIDI 에 대해 설명하고 있는 장에 상세가 있습니다 ( 제? 부를 참조).
</p><a name="111901"> </a> 
<h3> 서비스 프로바이더 인터페이스</h3>
<p><a name="111902"> </a> <code>javax.sound.sampled.spi</code> 패키지와 <code>javax.sound.midi.spi</code> 패키지에는, 소프트웨어 개발자가 오디오 또는 MIDI 자원을 신규에 작성하기 위해서 사용할 수 있는 API 가 포함되어 있습니다. 이러한 자원은, 사용자에게 개별적으로 배포하거나 기존의 Java Sound API 구현에 「플러그 인」시킬 수가 있습니다. 이 방법으로 추가할 수 있는 서비스 (자원)로서 다음과 같은 것이 있습니다.
</p><ul><a name="111903"> </a> 
<li>오디오 믹서 <a name="112110"> </a> 
<li>MIDI 신디사이저<a name="111906"> </a> 
<li>신형의 오디오 또는 MIDI 파일의 읽기와 기입이 가능한 파일 퍼서<a name="111907"> </a> 
<li>다른 사운드 데이터 형식간의 변환을 실시하는 컨버터
<p><a name="111910"> </a> 
</ul>
경우에 따라서는, 서비스가, 사운드 카드등의 하드웨어 디바이스 기능에의 소프트웨어 인터페이스가 됩니다. 그 경우, 서비스 프로바이더는, 하드웨어의 벤더와 같은 의미가 됩니다. 또, 순수하게 소프트웨어내에 있는 서비스도 있습니다. 예를 들어, 신디사이저나 믹서가 사운드 카드상의 팁에의 인터페이스가 되는 경우나, 하드웨어를 전혀 지원하지 않고 구현되고 있는 경우 등입니다.  
<p></p><p><a name="111912"> </a> Java Sound API 의 구현에는 서비스의 기본 세트가 포함되어 있습니다만, 서비스 프로바이더 인터페이스 (SPI) 패키지를 사용해 서드 파티에 의한 새로운 서비스의 작성도 가능합니다. 이러한 서드 파티 서비스는, 편입 서비스와 같은 방법으로 시스템에 통합됩니다. <code>sampled</code> 패키지내의 <code>AudioSystem</code> 클래스와 <code>midi</code> 패키지내의 <code>MidiSystem</code> 클래스는, 응용 프로그램이 서비스에 명시적 또는 암묵적으로 액세스하기 위한 조정역으로서 일합니다. 어느 서비스의 존재가, 그 서비스를 사용하는 응용 프로그램에는 안보이는 것도 자주 있습니다. 서비스 프로바이더 기구에 의해, Java Sound API 를 베이스로 하는 응용 프로그램의 사용자는, 편리함을 향수할 수가 있습니다. 그것은, Java SDK 또는 실행 환경의 새로운 릴리스, 또 많은 경우, 응용 프로그램 그 자체의 새로운 릴리스마저도 필요로 하지 않고 , 프로그램에 새로운 사운드 기능을 추가할 수가 있기 때문입니다.
</p>
<p>&nbsp;</p></body>
</html>
