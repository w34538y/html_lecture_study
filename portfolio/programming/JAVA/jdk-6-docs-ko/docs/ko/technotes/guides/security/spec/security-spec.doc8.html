<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<html>
<head>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">

<title>Java 시큐리티 아키텍쳐(architecture):  - 
 - xrath.com 에서 번역됨</title>
</head>
<body bgcolor="#ffffff">
 
<table summary="layout" width="100%"><tr>
<td><!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. --> <!-- font size="-1" --> <a href=security-specTOC.fm.html>목차</a>  | <a href="security-spec.doc7.html">전의 항목</a>  | <a href="security-spec.doc9.html">다음의 항목</a>  <!-- | <a href="security-spec.doc.html">INDEX</a>   --> <!-- /font --></td><td align=right><i>Java 시큐리티 아키텍쳐(architecture)</i></td>
</tr></table>
<br>
 

<p>
<hr size="8" width="35%" align="left" noshade>

<h2><a name="21605"><i> 8 </i>검토 사항 및 장래의 방침</a> </h2>


<br>
<h3>
<a name="20670"><!-- --></a>  <i>	8.1	 </i>자원 소비 관리
</h3>

<blockquote>
<a name="28214"><!-- --></a> 자원 소비 관리에서는, 어플리케이션이 동시에 pop-up 시키는 윈도우의 수를 제한하는 경우 등은, 비교적 간단하게 구현할 수 있습니다. 그러나, 메모리나 파일 시스템의 사용을 제한하는 경우 등, 구현이 매우 곤란한 경우도 있습니다. 장래, 이 문제를 일관성이 있는 방법으로 해결할 예정입니다. <p>
</blockquote>
<br>
<h3>
<a name="28250"><!-- --></a>  <i>	8.2	 </i>액세스권을 임의에 그룹화 한다
</h3>

<blockquote>
<a name="28251"><!-- --></a> 수많은 액세스권을 그룹화 해, 각각 약칭을 붙이면(자) 편리한 경우가 있습니다. 예를 들어, 「SuperPermission」라고 하는 이름의 액세스권에 FilePermission("-", "read, write")와 SocketPermission("*", "connect, accept")의 양쪽 모두를 포함하고 싶은 경우, 기술적으로는 Permissions 클래스 또는 같은 클래스의 <code>add</code> 메소드를 사용해, 목적의 액세스권을 추가하는 것으로써, 이 SuperPermission 를 구현할 수 있습니다. 다만, 이러한 그룹화는, 복잡하게 될 가능성이 있습니다. <p>
<a name="28252"><!-- --></a> 다음과 같은 한층 더 어려운 문제도 있습니다. 우선, 상기의 SuperPermission 를 주었을 경우, 실제로 준 액세스권이 무엇인가를 이해할 필요가 있습니다. 그 때문에(위해) 고정 클래스 또는 이름 첨부 클래스의 어느 쪽인지를 작성해, 정적으로 지정된 액세스권의 그룹을 나타내는지, 멤버의 액세스권을 정책 파일에 정식적 이름으로 기재할 필요가 있습니다. 다음에, 그룹화 된 액세스권을 확장할 필요가 있기 (위해)때문에, 정책 파일의 처리는 한층 더 복잡하게 됩니다. 그룹화 된 액세스권의 네스트화는, 처리를 한층 더 복잡하게 합니다. <p>
</blockquote>
<br>
<h3>
<a name="28253"><!-- --></a>  <i>	8.3	 </i>객체 레벨에서의 보호
</h3>

<blockquote>
<a name="28254"><!-- --></a> Java 프로그램 언어는 객체 지향 언어이기 (위해)때문에, 적절한 객체 레벨의 보호 기구는, 개발자에게 있어 유익하다라고 생각됩니다. 객체 레벨의 보호 기구는, (1) Java 언어가 제공하는 보호 기능을 넘어(2) thread 베이스의 액세스 제어 기구를 추가합니다. <p>
<a name="28255"><!-- --></a> SignedObject 는, 그러한 기구의 1 개입니다. 이 프리미티브(primitive)에 대응해, 객체의 내용을 숨기기 위해서(때문에) 암호를 사용하는 SealedObject 를 제공합니다. 현재의 미국의 암호에 관한 수출규제 조례에 의해, SealedObject 클래스는 SDK 와는 별도로 제공됩니다. <p>
<a name="28256"><!-- --></a> GuardedObject 는, 클래스 및 객체 마다, 또 메소드 마다 액세스 제어를 실시하는 일반적인 방법입니다. 다만, 이런 종류의 제어는 상위 레벨에서의 관리가 곤란하기 때문에, 이 방법은 선택적으로, 또 부분적으로 사용할 필요가 있습니다. <p>
</blockquote>
<br>
<h3>
<a name="28269"><!-- --></a>  <i>	8.4	 </i>보호 도메인의 분할
</h3>

<blockquote>
<a name="28270"><!-- --></a> 현시점에서는 구현되고 있지 않습니다만, 유용이라고 생각되는 개념에 「서브 도메인」이 있습니다. 서브 도메인이란, 다른 도메인에 포함되어 있는 도메인입니다. 서브 도메인은, 그것을 포함한 도메인정도의 액세스권이나 특권은 가지고 있지 않습니다. 예를 들어, 도메인을 작성해, 프로그램의 실행 기능을 선택적으로 제한할 수가 있습니다.  <p>
<a name="28271"><!-- --></a> 도메인은, 상속 기능을 지원하고 있다고 보이는 일이 있습니다. 서브 도메인은, 친도메인의 시큐리티 속성을 자동적으로 상속합니다. 다만, 친도메인이 서브 도메인에 대해 명시적으로 제한했을 경우는 제외합니다. 정당한 상속에 의해 서브 도메인이 제한을 완화하는 것은, 신뢰성의 높은 코드의 경우에 유용한 방법입니다.  <p>
<a name="28272"><!-- --></a> 편의적으로, 시스템 도메인을, 모든 시스템 코드의 단일의 큰 집합체라고 생각할 수가 있습니다. 다만, 보호 기능을 높이기 위해서(때문에)는, 시스템 코드를 복수의 시스템 도메인으로 실행할 필요가 있습니다. 그 경우, 각 도메인은 특정의 종류의 자원을 보호해, 또 각 도메인에는 일식의 특별한 액세스권이 주어집니다. 예를 들어, 파일 시스템 코드 및 네트워크 시스템 코드가 다른 도메인으로 실행되고 있는 경우, 전자는 네트워크 자원에 대한 액세스권이 없고, 후자는 파일 시스템 자원에 대한 액세스권을 가지지 않습니다. 이 경우 1 개의 시스템 도메인의 리스크 및 에러의 결과, 또는 시큐리티 플로우는, 그 시스템 도메인의 범위내로 한정됩니다. <p>
</blockquote>
<br>
<h3>
<a name="28211"><!-- --></a>  <i>	8.5	 </i>서명 첨부의 컨텐츠로 애플릿을 실행한다
</h3>

<blockquote>
<a name="20671"><!-- --></a> JAR 및 Manifest 스펙의 코드 서명에서는, 매우 유연한 서명의 형식이 가능합니다. 같은 어카이브(archive)내의 복수의 클래스를 다른 열쇠로 서명하는 일도, 1 개의 클래스에 대해서, 미서명으로 하거나 1 개의 열쇠로 서명하거나 복수의 열쇠로 서명하거나 하는 일도 가능합니다. 오디오 클립 및 그래픽 이미지 등 어카이브(archive)내의 다른 자원도, 클래스와 같게 서명하거나 미서명으로 할 수 있습니다. <p>
<a name="20672"><!-- --></a> 이 유연성을 위해서(때문에), 해석이 문제가 됩니다. 특히 복수의 열쇠가 따로 따로 처리되는 경우에, 다음일항을 명확하게 하지 않으면 안됩니다. <p>
</blockquote><blockquote><pre>1.  어카이브(archive)내의 몇개의 클래스가 서명되고 있는 경우,
   이미지 및 오디오는 같은 열쇠로 서명하는 것이 필요한가.
2.  이미지 및 오디오가 다른 열쇠로 서명되고 있는 경우,
   그것들을 같은 애플릿 viewer (또는 브라우저의 페이지)에 배치하는 것은 가능한가.
   혹은, 다른 viewer에 보내 처리하는 것이 필요한가.
</pre></blockquote><blockquote>
<a name="20679"><!-- --></a> 이러한 사항을 명확하게 하는 것은, 용이한 일이 아닙니다. 또, 효율을 높이기 위해서(때문에) 플랫폼간 및 프로덕트간에 일관성을 갖게할 필요도 있습니다. 일시적인 해결책은, 서명 첨부인가 어떤가에 관계없이 모든 이미지 및 오디오 클립을 전송 해, 같은 애플릿 클래스 로더로 처리한다고 하는 간단한 것입니다. 이 일시적인 해결책은, 한번 의견 일치를 얻을 수 있으면 개선되어 간다고 생각됩니다. <p>
<a name="22305"><!-- --></a> 게다가 클래스 파일의 바이트 코드의 내용이 JAR 의 서명 첨부 해시치에 일치하지 않기 위해(때문에), 디지털 서명을 검증할 수 없는 경우, JAR 작성자의 본래의 의도에 반해, 시큐리티 예외가 throw 됩니다. 이전에는, 그러한 코드가 신뢰되지 않는 코드로서 실행한다고 하는 제안이 이루어지고 있었습니다. 그러나, 애플릿의 클래스 로더는, 복수의 조직에 의해 서명을 붙일 수 있었던 코드의 로드를 허가하기 위해(때문에), 이 제안은 바람직한 것으로는 없습니다. 즉, 부분적으로 수정된 JAR 파일을 받아들이면(자), 신뢰되지 않는 코드의 일부의 실행, 및 같은 클래스 로더에 의하는 것 외의 코드에의 액세스를 허가해 버립니다. <p>
</blockquote>

<br>
<hr>
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. --> <!-- font size="-1" --> <a href=security-specTOC.fm.html>목차</a>  | <a href="security-spec.doc7.html">전의 항목</a>  | <a href="security-spec.doc9.html">다음의 항목</a>  <!-- | <a href="security-spec.doc.html">INDEX</a>   --> <!-- /font -->

<hr>
<font size="-1"><i><A HREF="../../../../legal/SMICopyright.html">Copyright</a>  &#169 1997-1999 Sun Microsystems, Inc.  All Rights Reserved. </i></font>





</body>
</html>
