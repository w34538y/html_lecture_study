<html><head>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">
<title> - xrath.com 에서 번역됨</title>
</head>
<body bgcolor=#ffffff>
<hr>
<h1>제 8 장 :MIDI 패키지의 개요</h1>
<hr>
<form name="form1">
  <select name="menu1" onChange="Eminem_jumpMenu('parent',this,1)">
    <SCRIPT SRC="menu_script.js" language="JavaScript"></SCRIPT>
  </select>
</form>
<p>&nbsp;</p>
<p><a name="118771"> </a> 제 1 장<a href="chapter1.html">「Java Sound API 의 소개」</a>에서는,Java<font size="-1"><sup>TM</sup></font> Sound API 의 MIDI 기능의 개요를 설명했습니다. </a> 이 장은, 독자가 제 1 장을 다 읽고 있는 것을 전제로 하고 있습니다. 여기에서는,<code>javax.sound.sampled</code> 패키지를 개입시켜 액세스 하는 Java Sound API 의 MIDI 아키텍쳐(architecture)에 대해보다 자세하게 설명합니다. 복습 또는 도입으로서 MIDI 자체의 기본 기능에 대해 설명하고 나서, 주제의 Java Sound API 의 MIDI 기능에 대해 설명합니다. 그 후, Java Sound API 가 MIDI 를 처리하는 방법에 대해 설명해, 계속되는 장으로 취급하는 프로그래밍 작업에 대비합니다. 이 장에서는, MIDI API 에 대해, 주로 데이터와 디바이스의 2 개의 면으로부터 고찰합니다.  </p>
<a name="118774"> </a> 
<h3> MIDI 에 대해:와이어와 파일</h3>
<p><a name="118776"> </a> MIDI (Musical Instrument Digital Interface)는, 전자 키보드등의 전자 악기와 퍼스널 컴퓨터와의 통신 프로토콜을 정의하는 표준 규격입니다. MIDI 데이터는, 실연중은, 특수 케이블을 개입시켜 송신됩니다. 또, 표준 형식의 파일에 포함해, 나중에 재생이나 편집을 실시할 수도 있습니다.
</p><p><a name="118778"> </a> 여기에서는, Java Sound API 로부터 멀어져, MIDI 의 기본 사항에 대해 복습합니다. MIDI 에 대한 지식이 있는 독자는 복습으로서 MIDI 의 지식이 없는 독자는 도입으로서 활용해, 후술 하는 Java Sound API 의 MIDI 패키지의 설명에 대비해 주세요. MIDI 를 충분히 이해하고 있는 독자는, 이 마디를 읽지 않고 다음의 마디에 진행되어도 상관하지 않습니다. 본격적인 MIDI 어플리케이션을 작성하는 경우, MIDI 에 정통하고 있지 않는 프로그래머는, 이 문서에 기재되어 있는 설명보다 한층 더 상세한 MIDI 에 관한 설명이 필요하게 됩니다. 그 경우는, http://www.midi.org 로부터 하드 카피에서만 입수 가능한 「Complete MIDI 1.0 Detailed Specification」를 참조해 주세요 (Web 로부터 입수할 수 있는 것은 간략판만).
</p><p><a name="118780"> </a> MIDI 는, 하드웨어 스펙이며, 한편 소프트웨어 스펙이기도 합니다. MIDI 의 설계를 이해하려면 , 그 역사를 이해하는 것이 지름길입니다. MIDI 는, 본래, 신디사이저등의 전자 키보드 악기간에서의 음악적 이벤트 (키의 압하등)의 인도를 목적으로 해 설계되었습니다. 제 1 장으로 설명했던 대로, MIDI 데이터는, 주로 뮤지션의 제스처(gesture)를 전달하는 제어 이벤트로 구성되어 있습니다. MIDI 데이터에는, 이벤트로부터 생기는 오디오는 포함되지 않습니다. 시퀀서로 불리는 하드웨어 기기에는 신디사이저를 제어하는 악보의 순서가 기억되고 있어 악기 연주의 기록 및 재생을 가능하게 합니다. 그 후, 하드웨어인터페이스의 발전에 의해, MIDI 기기를 컴퓨터의 시리얼 포트에 접속해, 시퀀서를 소프트웨어상에 구현하는 것이 가능하게 되었습니다. 한층 더 최근에는, 컴퓨터의 사운드 카드가 MIDI I/O 와 악기음의 합성을 위한 하드웨어를 짜넣고 있습니다. 현재는, 많은 MIDI 사용자는, 외부의 MIDI 기기에 접속하지 않고 사운드 카드만으로, MIDI 를 즐기고 있습니다. CPU 의 속도도 향상했기 때문에, 신디사이저를 소프트웨어로서 구현하는 일도 가능하게 되었습니다. 사운드 카드는, 일반적으로 오디오 I/O 용으로만 필요합니다만, 어플리케이션에 따라서는, 외부 MIDI 디바이스와의 통신에 필요한 경우도 있습니다.
</p><p><a name="119058"> </a> MIDI 스펙 중(안)에서 하드웨어에 관한 부분은 적고, 여기에는 MIDI 케이블의 핀수 및 케이블을 찔러넣는 잭에 대해 규정되고 있습니다. 하드웨어에 관한 부분은, 프로그래밍 시에 고려에 넣을 필요는 없습니다. 시퀀서나 신디사이저등의 본래 필수 하드웨어였던 기기류가, 현재는 소프트웨어로 구현되고 있기 (위해)때문에, MIDI 하드웨어 디바이스에 관해서 대부분의 프로그래머가 이해할 필요가 있다고 하면, MIDI 에 있어서의 metaphor를 이해하기 위해(때문에) 뿐입니다. 다만, 몇개의 중요한 음악용 어플리케이션에서는, 외부 MIDI 하드웨어 디바이스가 여전히 중요한 역할을 이루어 있기 (위해)때문에, Java Sound API 는 MIDI 데이터의 입력 및 출력을 지원하고 있습니다.
</p><p><a name="118784"> </a> MIDI 스펙의 소프트웨어에 관한 부분에는, 폭넓은 내용이 포함되어 있습니다. 소프트웨어에 관한 부분에서는, MIDI 데이터의 구조, 및 신디사이저등의 디바이스가 MIDI 데이터에 응답할 방법이 기술되고 있습니다. MIDI 데이터에서는, 「스트리밍」또는 「시켄싱」이 가능한 것을 이해하는 것이 중요합니다. <em></em><em></em>이 쌍 대  관계는, 「Complete MIDI 1.0 Detailed Specification」의 다음의 2 개의 부분을 반영하고 있습니다.
</p><ul><a name="118786"> </a> 
<li>MIDI 1.0 <a name="118787"> </a> 
<li>표준 MIDI 파일
<p><a name="118789"> </a> 
</ul>
지금부터, MIDI 스펙의 2 개의 부분의 목적을 고찰하는 것으로써, 스트리밍과 시켄싱의 의미를 배웁니다.
<p></p><a name="118791"> </a> 
<h4> MIDI 와이어 프로토콜내의 스트리밍 데이터</h4>
<p><a name="118793"> </a>  MIDI 스펙의 2 개의 부분 가운데, 최초의 부분에는, 비공식의 이른바 「MIDI 와이어 프로토콜」에 대해 기술되고 있습니다. MIDI 와이어 프로토콜은, 당초부터 존재하는 MIDI 프로토콜로, MIDI 데이터가 MIDI 케이블 (와이어) 경유로 송신되고 있다고 하는 전제에 근거하고 있습니다. 케이블은, 어느 MIDI 디바이스로부터 다른 디바이스에 디지털 데이타를 송신합니다. 각 MIDI 디바이스는, 악기 또는 거기에 유사한 기기의 경우도 있으면, MIDI 대응의 사운드 카드나 MIDI 에의 접속용 시리얼 포트 인터페이스를 갖춘 범용적인 컴퓨터의 경우도 있습니다.
</p><p><a name="118795"> </a> MIDI 와이어 프로토콜의 정의에 따라, MIDI 데이터는 메세지에 편성됩니다. 종류가 다른 메세지는, 「상태 바이트」라고 불리는 메세지의 최초의 바이트로 식별됩니다 <em></em>(최상정도 비트가 1 으로 설정되는 바이트는 상태 바이트만). 메세지내에서 상태 바이트에 계속되는 바이트는, 「데이터 바이트」라고 불립니다. <em></em>「채널」메세지로 불리는 MIDI 메세지가 보관 유지하는 상태 바이트에서는, 그 중의 4 바이트로 채널 메세지의 종류를 지정해, 나머지의 4 바이트로 채널 번호를 지정합니다. <em></em>이 때문에, 16 의 MIDI 채널이 존재하게 됩니다. 이러한 가상 채널의 모두 또는 1 개(살)로 채널 메세지에 응답하도록(듯이), MIDI 메세지를 수신하는 디바이스를 설정할 수 있습니다. MIDI 채널을 오디오 채널과 혼동 하지 않게 해 주세요. 각 MIDI 채널은, 다른 악기음의 송신에 사용됩니다. 예를 들어, 일반적인 채널 메세지인 노트 온과 노트 오프를 생각해 봅시다. 이것들은 각각, 소리를 울리는 동작을 개시 및 정지하는 기능입니다. 이것들 2 개의 메세지는, 각각 2 개의 데이터 바이트를 보관 유지합니다. 최초의 데이터 바이트는 음표의 피치를, 2 번째의 데이터 바이트는 「속력」(키보드 악기의 경우, 키를 타건 하는 속도)을 지정합니다.
</p>
<p><a name="118799"> </a> MIDI 와이어 프로토콜은, MIDI 데이터용의 스트리밍 모델을 정의합니다. 이 프로토콜의 주된 기능은, MIDI 데이터의 바이트를 리얼타임에 건네주는 것, 즉 스트림 전달을 실시하는 것입니다. 데이터 자체에는 타이밍 정보는 포함되지 않습니다. 각 이벤트의 착신 시간은 정확하다라고 보여, 착신시에 처리됩니다. 이 모델은, 뮤지션이 생성하는 악보의 경우에는 문제 없습니다만, 나중에 재생하기 위해서 그러한 음표를 기억하거나 리얼타임 이외로 곡을 구성하는 경우에는 불충분합니다. 본래, MIDI 는, 많은 뮤지션이 컴퓨터를 사용하게 되기 전의 시대에, 악기 연주용 (키보드 연주자가 복수의 신디사이저를 제어하는 경우등)으로서 설계된 것을 생각하면(자), 이 제약의 이유를 이해할 수 있습니다. MIDI 스펙의 최초의 버젼은, 1984 년에 발표되었습니다.  
</p>
<a name="119349"> </a> 
<h4> 표준 MIDI 파일의 순서 데이터</h4>
<p><a name="119350"> </a>  MIDI 스펙내의 표준 MIDI 파일을 취급한 부분에, MIDI 와이어 프로토콜의 타이밍 제한에 관한 기술이 있습니다. 표준 MIDI 파일은, MIDI 「이벤트」를 포함한 디지털 파일입니다. <em></em>이벤트는, MIDI 와이어 프로토콜로 정의된 단순한 MIDI 메세지에, 이벤트의 타이밍을 지정하는 정보가 추가된 것입니다. 다만, 다음의 마디로 설명하도록(듯이), MIDI 와이어 프로토콜 메세지에 대응하지 않는 이벤트도 존재합니다. 추가의 타이밍 정보는, 메세지에 기술된 조작을 언제 실행하는지를 나타내는 바이트군입니다. 즉, 표준 MIDI 파일은, 재생하는 소리 만이 아니고, 각각을 정확하게 언제 재생하는지를 지정합니다. 이 때문에, 표준 MIDI 파일은 악보에 얼마인가 닮았습니다.
</p><p><a name="118806"> </a> 표준 MIDI 파일내의 정보는, 「순서」라고 불립니다. <em></em>표준 MIDI 파일에는, 1 개(살) 또는 복수의 「트럭」이 포함됩니다. <em></em>라이브 연주의 경우, 각 트럭에는, 1 개의 악기로 연주되는 소리가 포함됩니다. 시퀀서는, 순서를 읽어내, 읽어낸 MIDI 메세지를 적절한 타이밍에 전달할 수 있는 소프트웨어 또는 하드웨어 디바이스입니다. 시퀀서는, 오케스트라의 지휘자를 닮은 기능을 합니다. 즉, 모든 음표에 관한 정보 (타이밍도 포함한다)를 보관 유지해, 악보를 언제 연주해야할 것인가를 다른 실체에 통지합니다.
</p><a name="118810"> </a> 
<h3> Java Sound API 에서의 MIDI 데이터 표현</h3>
<p><a name="118812"> </a> 여기까지로, MIDI 스펙이 스트림 및 순서 대상의 음악 데이터를 처리하는 방법을 개관 했습니다. 지금부터, Java Sound API 가 음악 데이터를 표현하는 방법에 대해 고찰합니다.  
</p><a name="119522"> </a> 
<h4> MIDI 메세지</h4>
<p><a name="119523"> </a>  <code>MidiMessage</code> 는, 「raw」MIDI 메세지를 표현하는 추상 클래스입니다. 일반적으로, 「raw」MIDI 메세지는 MIDI 와이어 프로토콜에 의해 정의된 메세지입니다. MIDI 메세지를 표준 MIDI 파일 스펙에 의해 정의된 이벤트로 할 수도 있습니다만, 그 경우 이벤트의 타이밍 정보는 포함되지 않습니다. raw MIDI 메세지에는, 3 개의 카테고리가 존재합니다. 각 카테고리는, 다음의 3 개의 <code>MidiMessage</code> 서브 클래스에 의해 Java Sound API 로 표현됩니다.  
</p><ul><a name="118819"> </a> 
<li><code>ShortEvents</code> 는 가장 일반적인 메세지로, 상태 바이트의 후에 최대 2 데이터 바이트를 가집니다. 노트 온이나 노트 오프등의 채널 메세지, 및 다른 몇개의 메세지는, 모두 쇼트 메세지입니다.  <a name="118820"> </a> 
<li><code>SysexMessages</code> 에는, 「시스템 전용」의 MIDI 메세지가 포함됩니다. <em></em>이것들은 많은 바이트를 가지는 것이 가능해, 일반적으로, 메이커 고유의 지시가 포함됩니다.  <a name="118821"> </a> 
<li><code>MetaMessages</code> 는 MIDI 파일내에서 발생합니다만, MIDI 와이어 프로토콜내에서는 발생하지 않습니다. 메타멧세이지에는, 시퀀서에는 유용해도 일반적으로 신디사이저에는 무의미한 가사나 템포등의 설정 데이터가 포함됩니다.
</ul><a name="118823"> </a> 
<h4> MIDI 이벤트</h4>
<p><a name="119393"> </a> 벌써 설명한 것처럼, 표준 MIDI 파일에는, 「raw」 MIDI 메세지와 타이밍 정보의 래퍼로서 기능하는 이벤트가 포함됩니다. Java Sound API 의 <code>MidiEvent</code> 클래스의 인스턴스는, 표준 MIDI 파일에 포함 예정의 이벤트등을 나타냅니다.  
</p><p><a name="118827"> </a> <code>MidiEvent</code> 의 API 에는, 이벤트의 타이밍치를 설정 및 취득하는 메소드가 포함됩니다. <code>MidiMessage</code> 의 서브 클래스의 인스턴스인, 매입 raw MIDI 메세지를 취득하는 메소드도 존재합니다. 이 메소드에 대해서는, 후술 합니다. 매입 raw MIDI 메세지는,<code>MidiEvent</code> 의 구성시에게만 설정 가능합니다.
</p><a name="118829"> </a> 
<h4> 순서와 트럭</h4>
<p><a name="118831"> </a> 벌써 설명한 것처럼, 표준 MIDI 파일은, 트럭내에 배치하는 이벤트를 포함합니다. 일반적으로, 파일은 1 개의 음악 구성을 나타내, 각 트럭은 1 개의 악기의 연주 파트를 나타냅니다. 악기 연주자의 연주하는 각 음은, 소리의 개시를 나타내는 노트 온과 소리의 종료를 나타내는 노트 오프의 적어도 2 개의 이벤트에 의해 표현됩니다. 트럭에는, 상술의 메타이벤트등의, 소리에 관련하지 않는 이벤트도 포함됩니다.
</p><p><a name="118833"> </a> Java Sound API 는, 다음의 3 개의 계층에서 MIDI 데이터를 편성합니다.  
</p><ul><a name="118834"> </a> 
<li><code>Sequence</code> <a name="118835"> </a> 
<li><code>Track</code> <a name="118836"> </a> 
<li><code>MidiEvent</code>
<p><a name="118837"> </a> 
</ul>
<code>Track</code> 는 <code>MidiEvents</code> 의 컬렉션,<code>Sequence</code> 는 <code>Tracks</code> 의 컬렉션입니다. 이 계층은, 표준 MIDI 파일 스펙의 파일, 트럭, 및 이벤트를 반영하고 있습니다. 덧붙여 이것은, 포함 관계 및 소유권의 계층이며, 상속을 나타내는 클래스 계층이 아닙니다. <em></em>이것들 3 개의 클래스는 각각,<code>java.lang.Object</code> 를 직접 상속합니다. ) 
<p></p><p><a name="118839"> </a>  <code>Sequence</code> 는, MIDI 파일로부터 읽어들이는지, 제로로부터 작성하는 것이 가능해,<code>Sequence</code> 에 <code>Track</code> 를 추가 (또는 삭제)하는 것에 의해 편집할 수 있습니다. (와)과 같이 <code>MidiEvent</code> 는, 순서내의 트럭에 추가하는 일도, 트럭으로부터 삭제할 수도 있습니다.
</p><a name="118842"> </a> 
<h3> Java Sound API 에서의 MIDI 디바이스 표현</h3>
<p><a name="118844"> </a> 전의 마디에서는, Java Sound API 로 MIDI 메세지를 표현하는 방법을 설명했습니다. 다만, MIDI 메세지는, 진공중에 존재하고 있는 것은 아닙니다. 일반적으로, MIDI 메세지는 있는 디바이스로부터 다른 디바이스에 송신됩니다. Java Sound API 를 사용하는 프로그램은, MIDI 메세지를 새롭게 작성할 수 있습니다만, 시퀀서등의 소프트웨어 디바이스에 의해 메세지를 작성하거나 MIDI 입력 포트 경유로 컴퓨터의 외부로부터 메세지를 수신하는 (분)편이 보다 일반적입니다. 이러한 디바이스는, 일반적으로, 신디사이저나 MIDI 출력 포트등의 다른 디바이스에 메세지를 송신합니다.  
</p><a name="118846"> </a> 
<h4> MidiDevice 인터페이스</h4>
<p><a name="118848"> </a> 외부 MIDI 하드웨어 디바이스 중(안)에서 많은 디바이스가, MIDI 메세지를 다른 디바이스에 송신하거나 다른 디바이스로부터 메세지를 수신하거나 할 수 있습니다. 같이 Java Sound API 에서는,<code>MidiDevice</code> 인터페이스를 구현하는 소프트웨어 객체가 메세지의 송신과 수신을 실행할 수 있습니다. 이러한 객체는, 순수하게 소프트웨어로 구현하는 일도, 사운드 카드의 MIDI 기능등의 하드웨어에의 인터페이스로 하는 일도 가능합니다. 기본적인 <code>MidiDevice </code> 인터페이스는, 일반적으로 MIDI 입력 포트 또는 출력 포트가 필요로 하는 기능의 모든 것을 제공합니다. 다만, 신디사이저 및 시퀀서는 각각,<code>MidiDevice</code> 의 서브 인터페이스인<code>Synthesizer</code> 와 <code>Sequencer</code> 를 각각 구현합니다.
</p><p><a name="118850"> </a> <code>MidiDevice</code> 인터페이스에는, 디바이스를 오픈 및 클로즈하기 위한 API 가 포함됩니다. 또, 디바이스의 텍스트 표현 (이름, 벤더, 버젼등)을 제공하는 <code>MidiDevice.Info</code> 로 불리는 내부 클래스도 포함됩니다. 벌써 이 문서의 샘플링 오디오에 관한 기술에 대충 훑어보고 있는 독자는, 이 API 에 본 기억이 있다고 느낄 것입니다. 그것은, 이 API 의 설계가,<code> javax.sampled.Mixer</code> 인터페이스의 설계 와 유사하기 (위해)때문에입니다. <code> javax.sampled.Mixer</code> 인터페이스는, 오디오 디바이스를 나타내, 유사한 내부 클래스 <code>Mixer.Info</code> 를 보관 유지합니다.
</p><a name="118852"> </a> 
<h4> 트랜스미터와 리시버</h4>
<p><a name="118854"> </a> 대부분의 MIDI 디바이스는,<code>MidiMessages</code> 의 송신, 수신, 또는 그 양쪽 모두를 실행할 수 있습니다. 디바이스는, 소유하는 1 개(살) 또는 복수의 트랜스미터 객체를 개입시켜 데이터를 송신합니다. 같은 방법으로, 디바이스는 1 개 또는 복수의 리시버 객체를 개입시켜 데이터를 수신합니다. 트랜스미터 객체는 <code>Transmitter </code> 인터페이스를 구현해, 리시버는 <code>Receiver</code> 인터페이스를 구현합니다.
</p><p><a name="118856"> </a> 각 트랜스미터는 한 번에 1 개의 리시버에만 접속할 수 있습니다. 그 역도 같습니다. MIDI 메세지를 복수의 디바이스에 동시에 송신하는 디바이스는, 각각이 다른 디바이스에 접속된 복수의 트랜스미터를 보관 유지하는 것으로써, 이것을 가능하게 하고 있습니다. 같이 한 번에 복수의 소스로부터 MIDI 메세지를 수신 가능한 디바이스는, 복수의 리시버를 보관 유지하고 있습니다.
</p><a name="118858"> </a> 
<h4> 시퀀서</h4>
<p><a name="118860"> </a> 시퀀서는, MIDI 이벤트의 순서의 혼잡 및 재생을 실시하는 디바이스입니다. 시퀀서는, 트랜스미터를 보관 유지합니다. 이것은, 일반적으로 시퀀서는, 순서에 포함된 MIDI 메세지를 신디사이저나 MIDI 출력 포트등의 다른 디바이스에 송신하기 (위해)때문에입니다. 시퀀서는, 리시버도 보관 유지합니다. 이것은, MIDI 메세지의 혼잡 및 순서에의 포함을 실행하기 (위해)때문에입니다. <code>MidiDevice</code>,<code>Sequencer</code> 는, 이 슈퍼 인터페이스에 대해서, 기본적인 MIDI 순서 조작용의 메소드를 추가합니다. 시퀀서에서는, MIDI 파일로부터 순서를 로드해, 순서의 템포의 문의와 설정을 실시해, 다른 디바이스를 그 순서에 동기 시킬 수가 있습니다. 응용 프로그램은, 객체를 등록해 두어, 시퀀서가 특정의 종류의 이벤트를 처리할 때에 통지를 받도록(듯이) 할 수가 있습니다.  
</p><a name="118862"> </a> 
<h4> 신디사이저</h4>
<p><a name="119601"> </a> <code>Synthesizer</code> 는, 사운드를 생성하는 디바이스입니다. 이것은, 오디오 데이터를 생성하는 <code>javax.sound.midi</code> 패키지내의 유일한 객체입니다. 신디사이저 디바이스는, MIDI 채널 객체세트를 제어합니다.  일반적으로, MIDI 스펙에서는 16 의 MIDI 채널이 요구되고 있기 (위해)때문에, 이 세트는, 16 개의 MIDI 채널 객체로 구성됩니다. 이러한 MIDI 채널 객체는,<code>MidiChannel</code> 인터페이스를 구현하는 클래스의 인스턴스이며, 그 메소드는, MIDI 스펙의 「채널 음성 메세지」 및 「채널 모드 메시지」를 나타냅니다.  </p>
<p><a name="118866"> </a> 응용 프로그램은, 신디사이저의 MIDI 채널 객체의 메소드를 직접 호출하는 것으로, 사운드를 생성할 수 있습니다. 다만, 신디사이저가, 1 개(살) 또는 복수의 리시버에 송신된 메세지에의 응답으로서 사운드를 생성하는 경우가 일반적입니다. 예를 들어, 시퀀서 또는 MIDI 입력 포트로부터 이러한 메세지를 송신할 수 있습니다. 신디사이저는, 리시버가 취득한 각 메세지를 해석해, 일반적으로은 이벤트내로 지정된 MIDI 채널 번호에 응해, 대응하는 커멘드 (<code>noteOn</code> 나 <code>controlChange</code> 등)를 <code>MidiChannel</code> 객체의 1 개에 발송 합니다.
</p><p><a name="118868"> </a> <code>MidiChannel</code> 는, 이러한 메세지내의 소리 정보를 사용해 음악을 구성합니다. 예를 들어,<code>noteOn</code> 메세지는, 노트의 피치 및 「속력」(볼륨)을 지정합니다. 다만, 이 소리 정보는 충분하지는 않습니다. 신디사이저에는, 각 음에 대해서 오디오 신호를 작성하는 방법에 대한 정확한 지시도 필요합니다. 이러한 지시는,<code>Instrument</code> 에 의해 나타내집니다. 일반적으로, 각 <code>Instrument</code> 는, 실제로 있는 악기 또는 사운드 효과를 에뮤레이트 합니다. <code>Instruments</code> 는, 신디사이저로 미리 설정되어 있도록(듯이) 하는 일도, 사운드 뱅크 파일로부터 로드하도록(듯이) 하는 일도 가능합니다. 신디사이저에서는,<code>Instruments</code> 는, 뱅크 번호 (행) 및 프로그램 번호 (열)로 배치됩니다.  
</p><p><a name="118870"> </a> 이 장에서는, MIDI 데이터를 이해하는데 있어서 도움이 되는 기초적인 정보를 제공해, 또 Java Sound API 내의 MIDI 에 관련한 중요한 인터페이스 및 클래스를 소개했습니다. 차장으로부터는, 이러한 객체를 응용 프로그램으로부터 액세스 해 사용하는 방법에 대해 설명합니다.
</p>
<p>&nbsp;</p></body>
</html>
