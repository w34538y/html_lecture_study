<HTML>
<HEAD>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">

<TITLE>2 목표와 설계 방침 - xrath.com 에서 번역됨</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">

<P><TABLE summary="layout" WIDTH="100%" BORDER="0" CELLSPACING="2" CELLPADDING="0">
  <TR>
    <TD>
<A HREF="jndiTOC.html">목차</A>  | <A HREF="jndi.1.html">전의 항목</A>  | <A HREF="jndi.3.html">다음의 항목</A> </TD> 
    <TD ALIGN="RIGHT">
<I><FONT COLOR="#707070">JNDI API</FONT></I></TD> 
  </TR>
</TABLE><HR ALIGN=LEFT SIZE="8" WIDTH="35%" NOSHADE><p></P>

<H2 CLASS="chapter"><A NAME="pgfId=997857"></A> 2.  목표와 설계 방침</H2>

<BLOCKQUOTE>
<P CLASS="body"><A NAME="pgfId=997858"></A> API 의 설계는, 다음의 원칙 및 방침에 따라 실시했습니다. </P>
</BLOCKQUOTE>

<DIV>

<H3 CLASS="section"><A NAME="pgfId_997859"></A> 2.1 일관성이 있어요 셋집 들이마셔 설계를 실시한다</H3>

<BLOCKQUOTE>
<P CLASS="body"><A NAME="pgfId_997860"></A> 가능한 경우는 항상, Java 개발 환경외의 부분에서 사용되고 있는, 기존의 컴퍼넌트를 사용하고 있습니다. 이 원칙에 따르는 것으로, JNDI 와 Java 플랫폼의 기존의 코어 클래스와의 사이의 일관성이 유지될 뿐만 아니라, 클래스의 쓸데없는 증가를 억제 당합니다. </P>
<P CLASS="body"><A NAME="pgfId_997862"></A> Java 프로그램 언어는 객체 지향 언어이기 (위해)때문에, 단순하고 알기 쉬운 API 를 설계할 수 있습니다.  이 때문에, 디렉토리 서비스 기능은, 기본적인 네임 서비스 기능으로부터 무리없이 확장할 수가 있습니다. </P>
</BLOCKQUOTE>

</DIV><DIV>

<H3 CLASS="section"><A NAME="pgfId_997863"></A> 2.2 사용하는 기능인 만큼 집중한다</H3>

<BLOCKQUOTE>
<P CLASS="body"><A NAME="pgfId_997864"></A> API 는 계층 구조가 되어 있으므로, 어플리케이션을 작성할 경우에, 특정의 디렉토리 서비스 기능만을 사용하는 경우는, 고도의 기능에 대한 지식은 필요 없습니다. 고도의 기능은 상위의 계층에 배치하는 것에 의해, 하위의 계층은 단순하게 되어 있어 공통의 기능을 나타내게 되어 있습니다. </P>
</BLOCKQUOTE>

</DIV><DIV>

<H3 CLASS="section"><A NAME="pgfId_997865"></A> 2.3 일반적인 디렉토리 서비스, 네임 서비스, 및 프로토콜에 걸쳐 구현할 수 있다</H3>

<BLOCKQUOTE>
<P CLASS="body"><A NAME="pgfId_997866"></A> 이 방침은, 다음의 2 개의 점으로써 중요합니다. 1 번째는, Java 어플리케이션으로부터, DNS, NDS, NIS (YP), X. 500, LDAP 등의 기존의 다양한 네임 서비스 및 디렉토리 서비스의 정보를 이용할 수 있는 것입니다. 2 번째는, 임의의 구현 고유의 기능만을 API 에 갖게할 수가 있는 것입니다. </P>
<P CLASS="body"><A NAME="pgfId_997867"></A> 복수의 네임 서비스 및 디렉토리 서비스에 대해서 통일된 인터페이스가 제공되고 있습니다만, 특정의 서비스 고유의 기능에 액세스 할 수도 있습니다. 통합된 API 는, 일반적인 서비스를 사용하도록(듯이) 설계되고 있습니다만, 부하의 네임 서비스 또는 디렉토리 서비스의 명시적인 정보를 사용하고 있는 어플리케이션도 사용할 수 있습니다. 이 경우, API 가 사용되고 있는 공통 부분을 공유할 수도 있습니다. 이것은, 공통되어 사용되는 클래스를 공유하면서, 필요한 독자적인 기능을 서브 클래스화에 의해 추가하고 있는 어플리케이션의 경우 와 유사합니다. </P>
  </DIV><DIV>
</BLOCKQUOTE>

<H3 CLASS="section"><A NAME="pgfId_997868"></A> 2.4 심리스인 통합</H3>

<BLOCKQUOTE>
<P CLASS="body"><A NAME="pgfId_997869"></A> 심리스인 통합은, 중요한 방침입니다.  심리스인 통합에 의해, 인스톨 끝난 머신 중(안)에서 사용되고 있는 다양한 디렉토리 서비스 및 네임 서비스를 지원 가능할 뿐만 아니라, 새로운 Java 어플리케이션 및 서비스를 개발할 경우에, 통일한 방식에서 독자적인 이름 공간 및 디렉토리 객체를 export 할 수가 있습니다. </P>
<P CLASS="body"><A NAME="pgfId_997870"></A> 또, 어플리케이션으로부터 다양한 구현을 선택할 수 있도록(듯이) 해, 사용하는 구현을 고정시키지 않게 했습니다. 예를 들어, thin 클라이언트의 경우는, 특정의 네임 서비스 및 디렉토리 서비스에의 액세스를 1 대의 서버에 위탁한, 프록시형의 프로토콜이 적합합니다. 퍼포먼스가 중요해 자원이 풍부한 클라이언트의 경우는, 다양한 서버에 직접 액세스 하는 구현이 적합합니다. 그러나, 어플리케이션에서는, 이러한 구현은 선택하지 않습니다. 구현은 실행시에 선택합니다. </P>
</BLOCKQUOTE>

<P>&nbsp;</P>

<H3 CLASS="section"><A NAME="pgfId_998702"></A> 2.5 업계를 리드하는 표준을 지원한다</H3>

<BLOCKQUOTE>
<P CLASS="body"><A NAME="pgfId_998703"></A> Lightweight Directory Access Protocol (인터넷 RFC 2251)가, 프로토콜 레벨의 디렉토리 액세스의 표준으로서 보급하고 있습니다. 주요한 디렉토리 벤더의 제품에서는, 모두 이 프로토콜이 지원되고 있습니다. JNDI 를 사용하고 있는 어플리케이션에서는, Lightweight Directory Access Protocol 의 모든 기능에 액세스 할 수 없으면 안됩니다. 가능한 경우 JNDI 는, Lightweight Directory Access Protocol 에 정의 끝난 규약 (검색 쿼리 및 필터의 스펙등)도 지원해 주세요. </P>
</BLOCKQUOTE>

<P><HR ALIGN=LEFT><A HREF="jndiTOC.html">목차</A>  | <A  HREF="jndi.1.html">전의 항목</A>  | <A HREF="jndi.3.html">다음의 항목</A> <HR ALIGN=LEFT><I><FONT  SIZE="-2"><A HREF="../../../../../legal/SMICopyright.html">Copyright</A>  &COPY;1997-1999 Sun Microsystems, Inc.  All Rights Reserved. </FONT></I>

</div></BODY>
</HTML>
