<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><!-- GenHTML@14981-->
<head>
<META HTTP-EQUIV="Content-type" CONTENT="text/html; charset=UTF-8">
<title>4. &nbsp;&nbsp;플랫폼 MBean 서버와 플랫폼 MXBean 의 사용 - xrath.com 에서 번역됨</title>
<link rel="stylesheet" type="text/css" href="css/default.css">
<!--stopindex-->
<script language="javascript1.2" type="text/javascript" src="css/menucontent.js"></script>
<script language="javascript1.2" type="text/javascript" src="css/menucode.js"></script>
</head>

<body leftmargin="0" topmargin="0" marginheight="0" marginwidth="0" bgcolor="#ffffff" onload="prepmenus();" class="a0v0">
<a name="top"></a> 

<!-- BEGIN A1 COMPONENT V.0 -->
<div class="a1">
<div class="a1v0">
<table cellpadding="0" cellspacing="0" border="0" width="100%">
<tr valign="bottom">
<td nowrap="nowrap">
<span class="toolbarlinks"><a href="http://www.sun.com">sun.com</a>  <a href="http://docs.sun.com/" class="dividelink">docs.sun.com</a> </span>
</td><td align="right" nowrap="nowrap">
<span class="toolbarlinks"><a href="http://www.sun.com/MySun/">My Sun</a>  <a href="http://www.sun.com/worldwide/" class="dividelink">Worldwide Sites</a> </span>
</td></tr>
</table>
</div>
</div>
<!-- END A1 COMPONENT V.0 -->

<!-- BEGIN A2 COMPONENT V.0 -->
<div class="a2" id="a2v0">
<div class="cornerTL">
<div class="cornerTR">
<div class="cornerBL">
<div class="cornerBR">
<div class="a2topiclinks">
<table cellpadding="1" cellspacing="0" border="0">
<tr valign="bottom">
<td><a href="http://www.sun.com/" title="홈 페이지"><img src="css/a.gif" alt="홈 페이지" width="104" height="58" border="0" class="sunlogo"></a> </td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip1"></td>
<td class="navlinks" id="navlink1">
<div>
<a id="glink1" href="http://www.sun.com/products/">제품</a> 
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip2"></td>
<td class="navlinks" id="navlink2">
<div>
<a id="glink2" href="http://www.sun.com/downloads/">다운로드</a> 
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip3"></td><td class="navlinks" id="navlink3">
<div>
<a id="glink3" href="http://www.sun.com/service/">서비스 &amp; 솔루션</a> 
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip4"></td><td class="navlinks" id="navlink4">
<div>
<a id="glink4" href="http://www.sun.com/support/">테크니컬 지원</a> 
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip5"></td><td class="navlinks" id="navlink5">
<div>
<a id="glink5" href="http://www.sun.com/training/">트레이닝</a> 
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip6"></td><td class="navlinks" id="navlink6">
<div>
<a id="glink6" href="http://research.sun.com/">리서치</a> 
</div>
</td>
</tr>
</table>
</div>

</div></div></div></div>
</div>
<!-- END A2 COMPONENT V.0 -->

<!-- BEGIN BREADCRUMB -->
<div id="breadcrumb">
<A href="toc.html">Java SE 감시 및 관리 가이드</A> &nbsp;
</div><br /> <!-- END BREADCRUMB -->

<!-- BEGIN WRAPPER TABLE, 1 COLUMN, MAIN -->
<table border="0" cellpadding="0" cellspacing="10" width="100%">
<tr><td width="100%" valign="top">
<!-- BEGIN CENTRAL COLUMN COMPONENTS -->

<!-- BEGIN PAGE CONTROL ROW -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr class="grey1"><td></td><td align="right"><A HREF="jconsole.html"><IMG BORDER="0" ALT="전의 항목" SRC="graphics/prev.gif">전의 항목</A> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="toc.html">목차</A> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="snmp.html">다음의 항목<IMG BORDER="0" ALT="다음의 항목" SRC="graphics/next.gif"></A> </td></tr>
</table>
<!-- END PAGE CONTROL ROW -->

</td></tr>
<tr><td width="100%" valign="top">
<a name="skip2content"> </a> 

<!--startindex-->
<div class="maincontent">
<A NAME="mxbeans"></A> <b>제 4 장</b><h1>플랫폼 MBean 서버와 플랫폼 MXBean 의 사용</h1>
<p>이 장에서는, Java Platform, Standard Edition (Java SE 플랫폼)의 일부로서 제공되는 MBean 서버와 MXBean 에 대해 설명합니다. MBean 서버와 MXBean 는, 감시 및 관리의 목적으로 사용할 수 있습니다. Java Management Extensions (JMX) 테크놀러지의 MBean 와 MBean 서버에 대해서는,<A HREF="overview.html#overview">제 1 장 「Java SE 감시 및 관리의 개요」</a>에 개요가 기록되고 있습니다. JMX 테크놀러지에 대해 자세하게는, Java SE 플랫폼의 <A  HREF="http://java.sun.com/javase/6/docs/technotes/guides/jmx/index.html">JMX 테크놀러지 관련 문서</A>  를 참조해 주세요. </p>
<A NAME="toc-103"></A> <h2>플랫폼 MBean 서버의 사용</h2>
<p>MBean 서버는, 관리 어플리케이션으로부터 MBean 에 액세스 할 수 있도록(듯이) 하는 MBean 의 리포지터리(repository)입니다. 어플리케이션은, MBean 에 직접 액세스 하지 않습니다만, 그 일의의 <tt>ObjectName</tt> 를 개입시켜, MBean 서버 경유로 MBean 에 액세스 합니다. MBean 서버에는, 인터페이스 <tt>javax.management.MBeanServer</tt> 가 구현되고 있습니다. </p>
<p>「플랫폼 MBean 서버」는, Java 2 Platform, Standard Edition 5.0 에 도입되어 Java 가상 머신 (Java VM)에 짜넣어진 MBean 서버가 되고 있습니다. <i></i>플랫폼 MBean 서버는, Java VM 로 실행하는, 현재 관리하에 있는 모든 컴퍼넌트로 공유됩니다. <tt>java.lang.management.ManagementFactory</tt> 의 메소드 <tt>getPlatformMBeanServer</tt> 를 사용해, 플랫폼 MBean 서버에 액세스 합니다. 물론 <tt>javax.management.MBeanServerFactory</tt> 클래스를 사용해 독자적인 MBean 서버를 구축할 수도 있습니다. 다만, 일반적으로, MBean 서버가 복수 존재할 필요는 없기 때문에, 플랫폼 MBean 서버의 사용을 추천합니다. </p>
<A NAME="gdfbj"></A> <h2>플랫폼 MXBean 에의 액세스</h2>
<p>「플랫폼 MXBean」는, Java VM 의 감시 및 관리를 실시하는 MBean 입니다. <i></i>각 MXBean 에서는, VM 기능의 일부를 캡슐화합니다. <A HREF="overview.html#overview">제 1 장 「Java SE 감시 및 관리의 개요」</a>의<A HREF="overview.html#gdeuk">겉(표) 1-1</A>  에 플랫폼에서 제공하는 MXBean 를 모두 일람으로 가리키고 있습니다. </p>
<p>관리 어플리케이션에서는, 다음의 3 종류의 방법으로, 플랫폼 MXBean 에 액세스 할 수 있습니다. </p>
<ul><li><p>직접 액세스 (<tt>ManagementFactory</tt> 클래스 경유). </p>
</li>
<li><p>직접 액세스 (MXBean 프록시 경유). </p>
</li>
<li><p>간접 액세스 (<tt>MBeanServerConnection</tt> 클래스 경유). </p>
</li>
</ul>
<p>다음의 3 개의 섹션에서는, 이것들 3 종류의 액세스 방법에 대해 설명합니다. </p>
<A NAME="gdfap"></A> <h3><tt>ManagementFactory</tt> 클래스를 사용한 플랫폼 MXBean 에의 액세스</h3>
<p>어플리케이션은, 자신의 Java VM 와 동일 Java VM 로 가동하는 플랫폼 MXBean 의 메소드에 대해서 직접 호출을 실시할 수가 있습니다. 또한 직접 호출에는,<tt>ManagementFactory</tt> 클래스의 static 메소드를 사용할 수 있습니다. <tt>ManagementFactory</tt> 에는,<tt>getClassLoadingMXBean()</tt>,<tt>getGarbageCollectorMXBeans()</tt>,<tt>getRuntimeMXBean()</tt> 등이 다양한 플랫폼 MXBean 에 각각 대응하는 액세스용 메소드가 준비되어 있습니다. 플랫폼 MXBean 가 복수 존재하는 경우, 그 메소드는 검출한 플랫폼 MXBean 의 리스트를 돌려줍니다. </p>
<p>예를 들어,<A HREF="mxbeans.html#gdfar">예 4-1</A>  에서는,<tt>ManagementFactory</tt> 의 static 메소드를 사용해 플랫폼 MXBean 의 <tt>RuntimeMXBean</tt> 를 취득해, 한층 더 플랫폼 MXBean 로부터 벤더명을 가져옵니다. </p>
<A NAME="gdfar"></A> <p><b>예 4-1</b> <tt>ManagementFactory</tt> 클래스를 경유한 플랫폼 MXBean 에의 액세스</p>
<table cellpadding="4" border="1" cols="1" width="100%"><td><pre>RuntimeMXBean mxbean = ManagementFactory.getRuntimeMXBean();
String vendor = mxbean.getVmVendor(); </pre>
</td></table><br><A NAME="gdfaz"></A> <h3>MXBean 프록시를 경유한 플랫폼 MXBean 에의 액세스</h3>
<p>어플리케이션에서는, MXBean 프록시를 개입시켜 플랫폼 MXBean 메소드를 호출할 수도 있습니다. 이 호출을 실시하려면 , static 메소드 <tt>ManagementFactory.newPlatformMXBeanProxy()</tt> 를 호출해 기정의 MBean 서버에 메소드의 호출을 전송 하는 MXBean 프록시 인스턴스의 작성이 필요합니다. 어플리케이션에서는, 일반적으로별의 Java VM 의 플랫폼 MXBean 에 대한 원격 접근을 가능으로 하는 프록시를 작성합니다. </p>
<p>예를 들어,<A HREF="mxbeans.html#gdfby">예 4-2</A>  에서는,<A HREF="mxbeans.html#gdfar">예 4-1</A>  와 완전히 같은 처리를 실행합니다만, 이번은 MXBean 프록시를 사용합니다. </p>
<A NAME="gdfby"></A> <p><b>예 4-2</b> MXBean 프록시를 경유한 플랫폼 MXBean 에의 액세스</p>
<table cellpadding="4" border="1" cols="1" width="100%"><td><pre>MBeanServerConnection mbs;
...
// Get a MBean proxy for RuntimeMXBean interface
RuntimeMXBean proxy =
    ManagementFactory.newPlatformMXBeanProxy(mbs,
                                             ManagementFactory.RUNTIME_MXBEAN_NAME,
                                             RuntimeMXBean.class);
// Get standard attribute "VmVendor"
String vendor = proxy.getVmVendor();</pre>
</td></table><br><A NAME="gdfao"></A> <h3><tt>MBeanServerConnection</tt> 클래스를 사용한 플랫폼 MXBean 에의 액세스</h3>
<p>어플리케이션은, 다른 실행중의 Java VM 의 플랫폼 MBean 서버에 접속되고 있는 <tt>MBeanServerConnection</tt> 를 경유해 플랫폼 MXBean 메소드를 간접적으로 호출할 수가 있습니다. <tt>MBeanServerConnection</tt> 클래스의 <tt>getAttribute()</tt> 메소드를 사용해 플랫폼 MXBean 의 속성을 취득해, MBean 의 <tt>ObjectName</tt> 와 속성명을 파라미터로서 제공합니다. </p>
<p>예를 들어,<A HREF="mxbeans.html#gdfas">예 4-3</A>  에서는,<A HREF="mxbeans.html#gdfar">예 4-1</A>  와 <A HREF="mxbeans.html#gdfby">예 4-2</A>  의 같은 작업을 실행합니다만,<tt>MBeanServerConnection</tt> 를 개입시켜 간접적인 호출을 실시합니다. </p>
<A NAME="gdfas"></A> <p><b>예 4-3</b> <tt>MBeanServerConnection</tt> 클래스를 경유한 플랫폼 MXBean 에의 액세스</p>
<table cellpadding="4" border="1" cols="1" width="100%"><td><pre>MBeanServerConnection mbs;
...
try {
  ObjectName oname = new ObjectName(ManagementFactory.RUNTIME_MXBEAN_NAME);
  // Get standard attribute "VmVendor"
  String vendor = (String) mbs.getAttribute(oname, "VmVendor");
} catch (....) {
  // Catch the exceptions thrown by ObjectName constructor
  // and MBeanServer.getAttribute method
  ...
}</pre>
</td></table><br><A NAME="gdfbk"></A> <h2>Sun Microsystems 의 플랫폼 확장 기능의 사용</h2>
<p>Java VM 에서는, 플랫폼에 특화한 측정에 필요한 인터페이스와 관리 조작을 정의하는 것으로써 관리 인터페이스를 확장할 수 있습니다. <tt>ManagementFactory</tt> 클래스의 정적 팩토리 메소드는, 플랫폼 확장 기능을 갖춘 MBean 를 돌려줍니다.  </p>
<p><tt>com.sun.management</tt> 패키지에는, Sun Microsystems 의 플랫폼 확장 기능이 포함되어 있습니다. 이하의 마디에서는, Sun Microsystems 구현 (<tt>OperatingSystemMXBean</tt>)으로부터 플랫폼 고유의 속성에 액세스 하는 방법의 예에 대해 설명합니다. </p>
<A NAME="gdfbt"></A> <h3>MXBean 의 각종 속성에 대한 직접 액세스</h3>
<p><A HREF="mxbeans.html#gdfcf">예 4-4</A>  에서는, Sun Microsystems 의 MXBean 인터페이스의 1 개에 대해서 직접 액세스를 실시하고 있습니다. </p>
<A NAME="gdfcf"></A> <p><b>예 4-4</b> MXBean 속성에 대한 직접 액세스</p>
<table cellpadding="4" border="1" cols="1" width="100%"><td><pre>com.sun.management.OperatingSystemMXBean mxbean =
  (com.sun.management.OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();

// Get the number of processors
int numProcessors = mxbean.getAvailableProcessors();

// Get the Sun-specific attribute Process CPU time
long cpuTime = mxbean.getProcessCpuTime();</pre>
</td></table><br><A NAME="gdfcb"></A> <h3><tt>MBeanServerConnection</tt> 경유에 의한 MXBean 속성에의 액세스</h3>
<p><A HREF="mxbeans.html#gdfbq">예 4-5</A>  에서는, Sun Microsystems 의 MXBean 인터페이스의 1 개에 <tt>MBeanServerConnection</tt> 클래스 경유로 액세스 합니다. </p>
<A NAME="gdfbq"></A> <p><b>예 4-5</b> <tt>MBeanServerConnection</tt> 를 경유한 MXBean 속성에의 액세스</p>
<table cellpadding="4" border="1" cols="1" width="100%"><td><pre>MBeanServerConnection mbs;

// Connect to a running Java VM (or itself) and get MBeanServerConnection
// that has the MXBeans registered in it
...

try {
    // Assuming the OperatingSystem MXBean has been registered in mbs
    ObjectName oname = new ObjectName(ManagementFactory.OPERATING_SYSTEM_MXBEAN_NAME);

    // Get standard attribute "Name"
    String vendor = (String) mbs.getAttribute(oname, "Name");

    // Check if this MXBean contains Sun Microsystems' extension
    if (mbs.isInstanceOf(oname, "com.sun.management.OperatingSystemMXBean")) {
        // Get platform-specific attribute "ProcessCpuTime"
        long cpuTime = (Long) mbs.getAttribute(oname, "ProcessCpuTime");
    }
} catch (....) {
    // Catch the exceptions thrown by ObjectName constructor
    // and MBeanServer methods
    ...
}</pre>
</td></table><br><A NAME="gdfbw"></A> <h2>thread 컨텐션 및 CPU 시간의 감시</h2>
<p>플랫폼 MXBean 의 <tt>ThreadMXBean</tt> 에서는, thread 컨텐션과 thread의 CPU 시간의 감시를 지원합니다. </p>
<p>Sun HotSpot VM 에서는, thread 컨텐션 감시를 지원합니다. Java VM 로 thread 컨텐션 감시가 지원되고 있는지 어떤지를 판단하려면 ,<tt>ThreadMXBean.isThreadContentionMonitoringSupported()</tt> 메소드를 사용합니다. 디폴트시는, thread 컨텐션 감시가 무효가 되어 있습니다. 유효하게 하려면 ,<tt>setThreadContentionMonitoringEnabled()</tt> 메소드를 사용합니다. </p>
<p>Sun HotSpot VM 에서는, 대부분의 플랫폼에 대해 thread의 CPU 시간의 측정을 지원하고 있습니다. 이 인터페이스로 발생하는 CPU 시간은, 그 단위의 정밀도가 나노초가 되고 있습니다만, 여기에서는 이 정도의 정밀도는 요구되지 않습니다. </p>
<p>Java VM 가 어느 thread의 CPU 시간의 측정도 지원하고 있는 것을 판단하려면 ,<tt>isThreadCpuTimeSupported()</tt> 메소드를 사용합니다. Java VM 로 현thread의 CPU 시간을 측정할 수 있을지 어떨지를 판단하려면 ,<tt>isCurrentThreadCpuTimeSupported()</tt> 를 사용합니다. thread의 CPU 시간의 측정을 지원하는 Java VM 에서는, 현thread의 CPU 시간도 지원합니다. </p>
<p> Java VM 에서는, thread의 CPU 시간의 측정을 무효로 할 수도 있습니다. thread의 CPU 시간의 측정을 유효하게 하려면 ,<tt>isThreadCpuTimeEnabled()</tt> 메소드를 사용합니다. thread의 CPU 시간의 측정을 유효/무효로 하려면 ,<tt>setThreadCpuTimeEnabled()</tt> 메소드를 사용합니다. </p>
<A NAME="gdgsw"></A> <h2> operating system의 관리</h2>
<p>플랫폼 MXBean 의 <tt>OperatingSystem</tt> 에서는, 다음에 나타내는 것 같은  operating system의 자원 정보에 액세스 할 수가 있습니다. </p>
<ul><li><p>프로세스 CPU 시간. </p>
</li>
<li><p>물리 메모리의 총용량과 빈 용량. </p>
</li>
<li><p>가상 메모리-의 확정 용량 (프로세스의 실행에 사용 가능한 가상 메모리-의 용량). </p>
</li>
<li><p>스왑 공간의 총용량 및 빈 용량. </p>
</li>
<li><p>오픈 파일 기술자의 수 (UNIX 플랫폼만). </p>
</li>
</ul>
<p>「JConsole」의 「MBean」탭으로  operating system의 MXBean 를 선택하면(자), 그 플랫폼의 확장 기능을 포함한 모든 속성과 동작이 표시됩니다. 수치 속성의 값필드를 더블 클릭 하는 것으로써, 이 수치 속성이 장기에 걸치는 값의 변화를 감시할 수 있습니다. </p>
<A NAME="gdeul"></A> <h2>로깅의 관리</h2>
<p>Java SE 플랫폼에서는, 로깅을 목적으로 한 특수의 MXBean (<tt>LoggingMXBean</tt> 인터페이스)를 제공합니다. </p>
<p><tt>LoggingMXBean</tt> 에서는, 다음 일을 실현될 수 있습니다. </p>
<ul><li><p>지정한 로거와 관련지을 수 있고 있는 로그 레벨의 이름을 취득. </p>
</li>
<li><p>현재 등록을 마친 로거의 리스트를 취득. </p>
</li>
<li><p>지정한 로거의 부모의 이름을 취득. </p>
</li>
<li><p>지정의 새로운 레벨로 지정의 로거를 설정. </p>
</li>
</ul>
<p><tt>LoggingMXBean</tt> 의 일의의 <tt>ObjectName</tt> 는,<tt>java.util.logging:type=Logging</tt> 입니다. 이 객체명은,<tt>LogManager.LOGGING_MXBEAN_NAME</tt> 에 보존되고 있습니다. </p>
<p><tt>LogManager.getLoggingMXBean()</tt> 의 호출에 의해 취득이 가능한 단일의 글로벌 인스턴스 <tt>LoggingMXBean</tt> 가 준비되어 있습니다.  </p>
<p>MXBean 의 <tt>Logging</tt> 에서는, 로거이름의 리스트를 표시하는 <tt>LoggerNames</tt> 속성을 정의합니다. 사용중의 어플리케이션으로 로거의 리스트를 검출하려면 , 「MBean」탭으로 <tt>java.util.logging</tt> 도메인의 로깅 MXBean 를 선택해,<tt>LoggerNames</tt> 속성의 값필드를 더블 클릭 합니다. 로깅 MXBean 에서는, 다음의 2 종류의 처리도 지원하고 있습니다. </p>
<ul><li><p><tt>getLoggerLevel</tt>:기정의 로거의 로그 레벨을 돌려줍니다. </p>
</li>
<li><p><tt>setLoggerLevel</tt>:기정 로거의 로그 레벨을 새로운 레벨로 설정합니다. </p>
</li>
</ul>
<p>이러한 처리에서는, 로거이름을 제 1 파라미터로서 가져옵니다. 로거의 로그 레벨을 변경하려면 , 로거이름을 제 1 파라미터에 입력해, 그 레벨의 이름을 <tt>setLoggerLevel</tt> 의 제 2 파라미터에 입력합니다. </p>
<A NAME="gdfba"></A> <h2>low memory-의 검출</h2>
<p>메모리의 사용은, 메모리 시스템의 중요한 요소가 됩니다. 이것은, 다음의 문제의 가능성을 시사하고 있습니다. </p>
<ul><li><p>어플리케이션의 과도의 메모리 소비. </p>
</li>
<li><p>자동 메모리 관리 시스템에의 과도의 부하. </p>
</li>
<li><p>잠재적인 메모리 리크. </p>
</li>
</ul>
<p>low memory-상태의 검출에 사용 가능한 메모리의 임계치에는, 「사용량 임계치」와「컬렉션 사용량 임계치」의 2 종류가 준비되어 있습니다. <i>polling</i> 또는 <i>threshold notification</i> 로 이러한 임계치의 어느쪽이든을 사용해, low memory-상태를 검출할 수 있습니다. 이러한 개념에 대해서는 모두 다음의 항으로 설명합니다. </p>
<A NAME="gdfbx"></A> <h3>메모리 임계치</h3>
<p>메모리 풀에는, 사용량 임계치 및 컬렉션 사용량 임계치의 2 종류의 메모리 임계치를 설정할 수가 있습니다. 이러한 임계치의 어느 쪽인지 한편은, 특정의 메모리 풀에서 지원되지 않을 가능성이 있습니다. 사용량 임계치와 컬렉션 사용량 임계치의 값은, 「JConsole」의 「MBean」탭으로 설정할 수가 있습니다. </p>
<A NAME="gdfav"></A> <h4>사용량 임계치</h4>
<p>사용량 임계치란, 관리 가능한, 일부의 메모리 풀의 속성을 의미합니다. 오버헤드를 낮게 억제한 상태로 메모리의 사용 상황을 감시할 수가 있습니다. 임계치를 정의 값으로 설정하면(자), 메모리 풀은 사용량 임계치를 체크할 수가 있습니다. 사용량 임계치에 0 을 설정하면(자), 이 사용량 임계치의 체크 기능이 무효가 됩니다. 디폴트 값는, Java VM 로 준비되어 있습니다. </p>
<p>Java VM 는, 메모리 풀에 있어 거의 적절한 타이밍으로 (일반적으로 가베지 컬렉션이 발생하고 있는 동안에), 이 사용량 임계치의 체크 기능을 실행합니다. 각 메모리 풀은, 사용량이 임계치를 넘는 경우에 항상 그 사용량 임계치의 수를 증가합니다. </p>
<p>일부의 메모리 풀에는, 사용량 임계치가 적합하지 않는 것으로부터,<tt>isUsageThresholdSupported()</tt> 메소드를 사용해 메모리 풀이 사용량 임계치를 지원하고 있을지 어떨지를 확인합니다. 예를 들어, 세대별 가비지 컬렉터 (HotSpot VM 의 기능의 1 개,<A HREF="jconsole.html#jconsole">제 3 장 「JConsole 의 사용」</A>  의 「<A HREF="jconsole.html#gddzt">가베지 컬렉션</a>」을 참조)에 대해서는,Eden 메모리 풀로부터 대부분의 객체가 젊은 세대(분)편에 할당할 수 있습니다. 덧붙여 Eden 풀은 그 용량이 가득 되도록(듯이) 설정되어 있습니다. Eden 메모리 풀의 가베지 컬렉트에 의해, 그 메모리 영역의 대부분이 해제됩니다. 이것은, Eden 메모리 풀에 포함되는 객체의 대부분은, 가베지 컬렉션시에는 액세스 불가능한 단명인 객체라고 예상되기 때문입니다. 이 때문에, Eden 메모리 풀은, 사용량 임계치를 지원하는데 적합하지 않습니다. </p>
<A NAME="gdfbu"></A> <h4>컬렉션 사용량 임계치</h4>
<p>컬렉션 사용량 임계치란, 가베지 컬렉트된 일부의 메모리 풀의 속성을 의미해, 이 속성은 관리할 수 있게 되어 있습니다. Java VM 로 메모리 풀의 가베지 컬렉트를 실시하면, 그 메모리 풀안의 일부의 메모리는 그것 이후도 계속해 사용중 상태인 채됩니다. 컬렉션 사용량 임계치에 의해, 이 메모리의 값을 설정할 수가 있습니다. 메모리 풀에서 컬렉션 사용량 임계치가 지원되고 있는지 어떤지를 판단하려면 ,<tt>MemoryPoolMXBean</tt> 의 <tt>isCollectionUsageThresholdSupported()</tt> 메소드를 사용합니다. </p>
<p>Java VM 는, 가베지 컬렉션을 실시할 때, 메모리 풀에 있어서의 컬렉션 사용량 임계치를 체크하는 경우가 있습니다. 덧붙여 이 체크 기능을 유효하게 하려면 , 이 임계치에 정의 값을 설정합니다. 체크 기능을 무효로 하는 경우는, 이 값에 0 (디폴트 값)을 설정합니다. </p>
<p>사용량 임계치, 라고 컬렉션 사용량 임계치는, 모두 「JConsole」의 「MBean」탭으로 설정할 수가 있습니다.  </p>
<A NAME="gdfvy"></A> <h4>Memory MXBean</h4>
<p>플랫폼 <tt>MemoryMXBean</tt> 를 사용해 메모리의 여러가지 없음 임계치(threshold)를 관리할 수가 있습니다. <tt>MemoryMXBean</tt> 에서는, 다음의 4 개의 속성을 정의합니다. </p>
<ul><li><p><tt>HeapMemoryUsage</tt>:현재의 heap 메모리의 사용 상황을 나타내는 읽기 전용의 속성입니다. </p>
</li>
<li><p><tt>NonHeapMemoryUsage</tt>:비heap 메모리의 사용 상황을 나타내는 읽기 전용의 속성입니다. </p>
</li>
<li><p><tt>ObjectPendingFinalizationCount</tt>:finalize를 보류하고 있는 객체의 수를 나타내는 읽기 전용의 속성입니다. </p>
</li>
<li><p><tt>Verbose</tt>:가베지 컬렉션 (GC)의 장황 트레이스 설정을 나타내는 불형의 속성입니다. 이 값은 동적으로 설정할 수가 있습니다. GC 의 장황 트레이스는, Java VM 를 개시할 때로 지정한 위치에 표시됩니다. Hotspot VM 의 GC 장황 출력에 있어서의 디폴트의 위치는,<tt>stdout</tt> 가 됩니다.  </p>
</li>
</ul>
<p>메모리 MXBean 에서는, 처리 <tt>gc</tt> 를 1 개 지원하고 있습니다. 이것에 의해, 명시적으로 가베지 컬렉션을 요구할 수 있습니다. </p>
<p>메모리 MXBean 의 인터페이스에 관한 자세한 것은,<tt>java.lang.management.MemoryMXBean</tt> 스펙에 정의되고 있습니다. </p>
<A NAME="gdgrk"></A> <h4>Memory Pool MXBean</h4>
<p>플랫폼 MXBean 의 <tt>MemoryPoolMXBean</tt> 에서는, 메모리의 임계치를 관리하기 위해서 일련의 처리를 정의합니다. </p>
<ul><li><p><tt>getUsageThreshold()</tt></p>
</li>
<li><p><tt>setUsageThreshold(long threshold)</tt></p>
</li>
<li><p><tt>isUsageThresholdExceeded()</tt></p>
</li>
<li><p><tt>isUsageThresholdSupported()</tt></p>
</li>
<li><p><tt>getCollectionUsageThreshold()</tt></p>
</li>
<li><p><tt>setCollectionUsageThreshold(long threshold)</tt></p>
</li>
<li><p><tt>isCollectionUsageThresholdSupported()</tt></p>
</li>
<li><p><tt>isCollectionUsageThresholdExceeded()</tt></p>
</li>
</ul>
<p>각 메모리 풀에는, low memory-의 검출을 지원하는데 있어서, 사용량 임계치 및 컬렉션 사용량 임계치의 2 종류의 메모리 임계치가 준비되어 있습니다. 이러한 임계치의 어느 쪽인지 한편은, 특정의 메모리 풀에서 지원되지 않을 가능성이 있습니다. 자세하게는,<tt>MemoryPoolMXBean</tt> 클래스의 API 레퍼런스를 참조해 주세요. </p>
<A NAME="gdfbv"></A> <h3>폴링</h3>
<p>어플리케이션에서는, 모든 메모리 풀 공통의 <tt>getUsage()</tt> 메소드, 또는 사용량 임계치를 지원하는 메모리 풀 전용의 <tt>isUsageThresholdExceeded()</tt> 메소드를 호출하는 것으로, 어플리케이션 자체의 메모리 사용량을 계속적으로 감시할 수 있습니다. </p>
<p><A HREF="mxbeans.html#gdfay">예 4-6</A>  에서는, 태스크의 배치와 처리를 위해서(때문에) 설치된 thread가 사용되고 있습니다. 각 간격에서는, 메모리의 사용량에 근거해 새로운 태스크의 수취나 처리를 실시할지 어떨지를 판단합니다. 메모리의 사용량이 그 사용량 임계치를 웃도는 경우, 그 메모리의 사용량이 임계치 이하가 될 때까지 다른 VM 에 미처리의 태스크를 재배치해, 새로운 태스크를 받지 않게 합니다. </p>
<A NAME="gdfay"></A> <p><b>예 4-6</b> 폴링의 사용</p>
<table cellpadding="4" border="1" cols="1" width="100%"><td><pre>pool.setUsageThreshold(myThreshold);
....
boolean lowMemory = false;
while (true) {
  if (pool.isUsageThresholdExceeded()) {
    lowMemory = true;
    redistributeTasks();  // redistribute tasks to other VMs
    stopReceivingTasks();  // stop receiving new tasks
  } else {
    if (lowMemory) { // resume receiving tasks
      lowMemory = false;
      resumeReceivingTasks();
    }
    // processing outstanding task
    ...
  }
  // sleep for sometime
  try {
    Thread.sleep(sometime);
  } catch (InterruptedException e) {
    ...
  }
}      </pre>
</td></table><br><p><A HREF="mxbeans.html#gdfay">예 4-6</A>  에서는, 메모리의 사용량이 그 사용량 임계치를 일시적으로 밑도는 경우와 2 개의 반복간에 있어 메모리의 사용량이 임계치를 웃돈 채로 상태인 경우의 구별이 없습니다. <tt>getUsageThresholdCount()</tt> 로부터 반환되는 사용량 임계치의 수를 사용해, 메모리의 사용량이, 2 살의 폴간에 임계치를 밑도는 값을 돌려줄지 어떨지를 판단합니다. </p>
<p>대신에 컬렉션 사용량 임계치를 테스트하려면 , 전술과 같은 방법으로 <tt>isCollectionUsageThresholdSupported()</tt>,<tt>isCollectionThresholdExceeded()</tt>,<tt>getCollectionUsageThreshold()</tt> 메소드를 사용합니다. </p>
<A NAME="gdfbf"></A> <h3>임계치 통지</h3>
<p><tt>MemoryMXBean</tt> 로 메모리 풀의 사용량이 그 임계치에 도달하고 있는지, 웃돌고 있는 것이 검출되었을 경우는, 「사용량 임계치 초과」통지가 발행됩니다. <i></i>사용량이 임계치를 밑돌아, 다시 웃돌 때까지,<tt>MemoryMXBean</tt> 는, 다른 사용량 임계치 초과 통지를 발행하지 않습니다. 같이 가베지 컬렉션 후의 메모리의 사용량이, 컬렉션 사용량 임계치를 웃도는 경우,<tt>MemoryMXBean</tt> 에서는, 컬렉션 사용량 임계치 초과 통지를 발행합니다. </p>
<p><A HREF="mxbeans.html#gdfaq">예 4-7</A>  는,<A HREF="mxbeans.html#gdfay">예 4-6</A>  와 같은 논리를 사용하고 있습니다만, low memory-상태를 검출하기 위해서 사용량 임계치를 나타내는 통지를 실시하고 있습니다. 통지를 받으면(자), 청취자는, 미처리 태스크의 재배치, 신태스크의 수락 거부, 신태스크의 재수락등의 액션을 실행하기 위해서 다른 thread의 통지를 실시합니다. </p>
<p>일반적으로, 이후의 통지의 지연을 회피하기 위해서, 처리량을 최소한으로 하는 <tt>handleNotification</tt> 메소드를 설계할 필요가 있습니다. 시간을 낭비하는 액션은 다른 thread에 대해 실행하도록 해 주세요. 복수의 thread로 통지 청취자를 동시에 호출할 수가 있기 (위해)때문에, 청취자는, 태스크가 정상적으로 실행되도록(듯이) 그 태스크를 동기 시킬 필요가 있습니다. </p>
<A NAME="gdfaq"></A> <p><b>예 4-7</b> 임계치 통지의 사용</p>
<table cellpadding="4" border="1" cols="1" width="100%"><td><pre>class MyListener implements javax.management.NotificationListener {
  public void handleNotification(Notification notification, Object handback)  {
    String notifType = notification.getType();
    if (notifType.equals(MemoryNotificationInfo.MEMORY_THRESHOLD_EXCEEDED)) {
      // potential low memory, redistribute tasks to other VMs &amp; stop receiving new tasks.
      lowMemory = true;
      notifyAnotherThread(lowMemory);
    }
  }
}

// Register MyListener with MemoryMXBean
MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();
NotificationEmitter emitter = (NotificationEmitter) mbean;
MyListener listener = new MyListener();
emitter.addNotificationListener(listener, null, null);</pre>
</td></table><br><p>이 메모리 풀에서 사용량 임계치를 지원하는 것과 가정하는 경우, 임계치 (값을 웃돌면(자) 신태스크를 받아들이지 않게 되고 임계치(threshold))를 있는 값 (바이트 수의 표기)으로 설정할 수가 있습니다. </p>
<table cellpadding="4" border="1" cols="1" width="100%"><td><pre>pool.setUsageThreshold(myThreshold);</pre>
</td></table><br><p>이 후, 사용량 임계치의 검출이 유효가 되어,<tt>MyListener</tt> 로 통지를 하게 됩니다. </p>

</div>
<!--stopindex-->

<!-- END CENTRAL COLUMN COMPONENTS -->
</td></tr>

<!-- BEGIN SPACER ROW -->
<tr><td><img src="css/a.gif" width="780" height="1" border="0" alt="" /></td></tr>
<!-- END SPACER ROW -->

<tr><td>

<!-- BEGIN PAGE CONTROL ROW -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr class="suntab"><td></td><td align="right"><A HREF="jconsole.html"><IMG BORDER="0" ALT="전의 항목" SRC="graphics/prev.gif">전의 항목</A> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="toc.html">목차</A> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="snmp.html">다음의 항목<IMG BORDER="0" ALT="다음의 항목" SRC="graphics/next.gif"></A> </td></tr>
</table>
<!-- END PAGE CONTROL ROW -->
</td></tr>

</table>
<!-- END WRAPPER TABLE, 1 COLUMN, MAIN -->


<!-- BEGIN A5 COMPONENT V.0 -->
<div class="a5" id="a5v0">
<span class="footerlinks"><a href="http://www.sun.com/company/">회사 정보</a>  <a href="http://www.sun.com/contact/">연락처</a>  <a href="http://www.sun.com/share/text/termsofuse.html">이용 규약</a>  <a href="http://www.sun.com/privacy/">프라이버시</a> 

<span class="footercopy">Copyright 1994-2006 Sun Microsystems, Inc. </span></span>
</div>
<!-- END A5 COMPONENT V.0 -->

<script type="text/javascript">
printmenus();
</script>

</body>
</html>

