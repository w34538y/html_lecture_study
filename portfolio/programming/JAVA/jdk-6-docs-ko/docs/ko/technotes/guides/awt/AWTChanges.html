<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> 
  <head>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">

<title>AWT 의 확장 기능 - xrath.com 에서 번역됨</title>
  </head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#000077" ALINK="#FF0000">
<TABLE summary="layout" BORDER="0" WIDTH="100%">

<TR>

<TD WIDTH="60">

<IMG SRC="../../../images/javalogo52x88.gif" ALT="Java" BORDER=0 WIDTH=52 HEIGHT=88>

</TD>



<TD>

<center>

<h1>Java<sup><font size=-2>TM</font></sup> 2 SDK, v1. 4 에서의 AWT 의 확장 기능</h1>

</center>

</TD>



<TD ALIGN=RIGHT VALIGN=TOP>

<font size="-1"><a href="../../../index.html">문서의 목차</a> </font>

</TD>

</TR>

</TABLE>

<blockquote>
<blockquote>
<a href=#1.4.2bugfix>1.4. 2 버그의 수정</a> <br> <a href=#1.4.1bugfix>1.4. 1 버그의 수정</a> <br> <a href=#focus>새로운 포커스 하부조직</a> <br> <a href=#focusDeprecate>추천 되지 않는 Focus 메소드</a> <br> <a href=#actionEvents>타임 스탬프를 필요로 하는 ActionEvent ( 및 그 외의 이벤트)</a> <br> <a href=#headless>헷드레스사포트</a> <br> <a href=#windowCentering>멀티스크린의 지원에 필요한 윈도우의 중앙 배치</a> <br> <a href=#fullscreen>새로운 전화면 배타 모드 API</a> <br> <a href=#syncOutOfRange>Windows NT 에서의 비디오 드라이버의 Sync Out of Range 에러</a>  <a href=#undecorated>비장식 프레임</a> <br> <a href=#mousewheel>마우스 휠의 지원</a> <br> <a href=#zoom><code>Frame</code>의 프로그래밍 줌</a> <br> <a href=#dynamicLayout>사이즈 변경시의 동적인 레이아웃</a> <br> <a href=#listenerList>컴퍼넌트 청취자 리스트에의 액세스</a> <br> <a href=#dragndrop>드래그＆드롭의 변경점</a> <br> <a href=#64bit>64 비트 대응의 Solaris</a> <br> <a href=#inconsistentDLLs>일관성이 없는 DLL 경고</a> <br> <a href=#drawingSurface><code>DrawingSurface</code> API 의 삭제</a> <br> <a href=#inputEvent>새로운 InputEvent 키 수식자</a> <br> <a href=#choice>Choice 메뉴의 드롭 다운 동작의 변경점</a> <br> <a href=#choice2>선택 컴퍼넌트는 레이아웃 매니저 제한으로 적합</a> <br>
</blockquote>
<hr>

<a name=1.4.2bugfix><b>1.4. 2 버그의 수정</b></a> 
<blockquote>
<p><a href="http://developer.java.sun.com/developer/bugParade/bugs/4648702.html"><b>4648702</b></a> : Microsoft Windows 2000 및 Windows XP 상에서는,<code>SCROLLBARS_BOTH</code> 필드가,<code>true</code> 로 설정되어 있어도,<code>TextArea</code> 가, 수직 스크롤 바 밖에 표시되지 않는 경우가 있다
</blockquote>

<blockquote>
<p><a href="http://developer.java.sun.com/developer/bugParade/bugs/4636311.html"><b>4636311</b></a> : 릴리스 1.3. 1 및 1.4 상에서 <code>Runnable</code> 를 실행하면(자), 모덜 다이얼로그가 행업 하는 경우가 있다
</blockquote>

<blockquote>
<p><a href="http://developer.java.sun.com/developer/bugParade/bugs/4385243.html"><b>4385243</b></a> : ANSI code page (Hindi 등)를 포함하지 않는 Microsoft Windows 로케일에 텍스트를 입력할 수 없다
</blockquote>

<a name=1.4.1bugfix><b>1.4. 1 버그의 수정</b></a> 
<blockquote>
<p><a  href="http://developer.java.sun.com/developer/bugParade/bugs/4690831.html"><b>4690831</b></a> : 게임 애플릿이 Internet Explorer 에서는 정상적으로 재draw 할 수 없다
</blockquote>

<blockquote>
<p><a  href="http://developer.java.sun.com/developer/bugParade/bugs/4627627.html"><b>4627627</b></a> : 포커스 traversal 키가 awt.properties 로부터 Preferences API 에 이동한다
</blockquote>

<blockquote>
<p><a  href="http://developer.java.sun.com/developer/bugParade/bugs/4636548.html"><b>4636548</b></a> /<a href="http://developer.java.sun.com/developer/bugParade/bugs/4639735.html"><b>4639735</b></a> : Microsoft Windows 2000 으로 스크린 세이버가 기동하고 있는 경우 릴리스 1.4 가 크래쉬 한다
</blockquote>

<blockquote>
<p><a href="http://developer.java.sun.com/developer/bugParade/bugs/4379138.html"><b>4379138</b></a> : 몇개의 대드 키의 키 이벤트에 대한 리눅스상의 문제
</blockquote>

<blockquote>
<p><a href="http://developer.java.sun.com/developer/bugParade/bugs/4627542.html"><b>4627542</b></a> : Swing 어플리케이션은, Linux에서는 인터내셔널 키보드를 지원하지 않는다
</blockquote>

<blockquote>
<p><a href="http://developer.java.sun.com/developer/bugParade/bugs/4395157.html"><b>4395157</b></a> : Linux 의 1.3 에서는, 애플릿으로 「%」를 입력할 수 없다
</blockquote>

<blockquote>
<p><a href="http://developer.java.sun.com/developer/bugParade/bugs/4669873.html"><b>4669873</b></a> : Microsoft Windows 의 호퍼 베타에 보고되고 있는, 드래그＆드롭의 버그.  드래그＆드롭중에 어플리케이션이 단시간 다운 당한다.

</blockquote>

<a name=focus><b>새로운 포커스 하부조직</b></a>  
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4290675.html">4290675</A> .

<p>지금까지의 포커스 아키텍쳐(architecture)는, 포커스 하부조직에 새롭게 옮겨졌습니다. 새로운 포커스 하부조직은, 플랫폼이 다르기 위해서(때문에) 생기는 포커스 관련의 버그나, AWT 와 Swing 컴퍼넌트와의 비호환성에 대응하고 있습니다. 상세한 것에 대하여는,<a href="../../../api/java/awt/doc-files/FocusSpec.html"><b>「포커스 모델 스펙」</b></a> 을 참조해 주세요.

<p><a href="1.4/focusAPIChanges.html">여기로부터</a>  javadoc 를 참조해 주세요.
</blockquote>


<a name=headless></a>  <b>헷드레스사포트</b>
<blockquote>

<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4281163.html">4281163</A> .

<p>메인프레임이나 전용 서버와 같은 환경에서는, 많은 경우, 디스플레이, 키보드, 마우스를 지원하고 있습니다. <a href="../../../api/java/awt/GraphicsEnvironment.html"><code>GraphicsEnvironment</code></a>  의 신규 메소드 <code>isHeadless</code> 및 <code>isHeadlessInstance</code> 에 의해, 헷드레스사포트가 가능하게 되어 있습니다. 이러한 메소드에서는, 디스플레이, 키보드, 마우스가 그래픽 환경에서 지원될지 어떨지를 나타냅니다.

<p>헷드레스에는 다음과 같은 API 의 변경이 있습니다.
<ul>
<li>새로운 public exception 클래스인 <a href="../../../api/java/awt/HeadlessException.html"><code><b>java.awt.HeadlessException</b></code></a>  가 도입되고 있습니다. 이것은,<code>RuntimeException</code> 로부터 파생한<code>UnsupportedOperationException</code> 로부터 파생하고 있습니다. 이것에 의해, 새로운 예외를 throw 하는 메소드의 기존의 구현으로 시그니체를 변경할 필요가 없어집니다.

<li>다음의 2 개의 새로운 메소드가 <code>java.awt.GraphicsEnvironment</code> 에 추가되고 있습니다.

<pre>
    public static boolean <a href="../../../api/java/awt/GraphicsEnvironment.html#isHeadless()">isHeadless()</a> 

    public boolean <a href="../../../api/java/awt/GraphicsEnvironment.html#isHeadlessInstance()">isHeadlessInstance()</a> 
</pre>

<li>툴 킷이 구현되어도 디스플레이, 키보드, 마우스가 지원되지 않는 경우,<code>Applet</code> 의 생성자 과 중량 컴퍼넌트 (*)는 모두 <code>HeadlessException</code> 를 throw 하도록(듯이) 변경되고 있습니다. 모든 생성자 의 javadoc 태그는, 모두 이 <code>RuntimeException</code> 를 반영하도록(듯이) 변경되고 있습니다.

<li>툴 킷이 구현되어도 디스플레이, 키보드, 마우스가 지원되지 않는 경우,<code>Robot</code> 생성자 은 <code>AWTException</code> 를 throw 합니다.

<li><code>Toolkit</code> 와 <code>GraphicsEnvironment</code> 의 메소드 가운데, 폰트, 이미징, 및 인쇄를 제외한 많은 메소드가 변경되어, 디스플레이, 키보드, 마우스가 지원되지 않는 경우에 <code>HeadlessException</code> 를 throw 하게 되었습니다. 이러한 메소드의 javadoc 태그는 모두 이 <code>RuntimeException</code> 를 반영하도록(듯이) 변경되고 있습니다.

<li>디스플레이, 키보드, 마우스가 지원되어 있지 않기 위해(때문에) 영향을 받는 그 외의 메소드는,<code>HeadlessException</code> 를 throw 하도록(듯이) 변경되고 있습니다.

<li><code>isHeadless</code> 가 true 를 돌려주는 경우만,<code>HeadlessException</code> 가 throw 됩니다. 모든 javadoc 코멘트로 이것을 명기하도록 해 주세요.
</ul>

<p>(*)<code>Applet</code>,<code>Button</code>,<code>Checkbox</code>,
<code>Choice</code>,<code>FileDialog</code>,<code>Label</code>,
<code>List</code>,<code>Menu</code>,<code>MenuBar</code>,
<code>MenuComponent</code>,<code>MenuItem</code>,
<code>PopupMenu</code>,<code>Scrollbar</code>,
<code>ScrollPane</code>,<code>TextArea</code>,<code>TextComponent</code>,
<code>Frame</code>,<code>Window</code>,<code>Dialog</code>,
<code>JApplet</code>,<code>JFrame</code>,<code>JWindow</code>,
<code>JDialog</code>,<code>TextField</code>. <code>Canvas</code>및<code>Panel</code>는, 빈 상태(empty)의 피어를 할당해 경량 컴퍼넌트로서 취급할 수가 있으므로, 이러한 예외를 throw 할 필요가 없습니다.

<p>
헷드레스를 구현한 환경을 실행하려면 ,<code>java</code> 커멘드행에 다음의 프로퍼티을 지정합니다.

<pre>
  -Djava.awt.headless=true
</pre>

이 프로퍼티이 설정되지 않고, 디스플레이, 키보드, 및 마우스가 지원되지 않는 경우, 디폴트에서는 헷드레스 구현이 사용됩니다.
<p>
예외가 올바르고 캐치 되도록(듯이), 원시 코드로 헷드레스를 체크할 필요가 있습니다. 예를 들어, 헷드레스를 구현하기 이전의 <code>Foo</code> 클래스의 구현은 다음과 같습니다.

<pre>
class Foo {
  static Choice c = new Choice();  // could throw HeadlessException
}
</pre>

헷드레스 구현 후의 새로운 <code>Foo</code> 의 구현은, static 블록에 다음과 같이 기술합니다.

<pre>
class Foo {
  static Choice c;
  static {
    try {
      c = new Choice();
    catch (HeadlessException e) {
        ...
    }
  }
}
</pre>



</blockquote>

<p>
<a name=fullscreen><b>새로운 전화면 배타 모드 API</b></a> 
<blockquote> 
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4189326.html">4189326</A> .

<p>새로운 전화면 배타 모드의 API 는, 윈도우 시스템을 일시정지해 화면에 직접 draw 할 수 있는 고성능 그래픽스를 지원합니다. 전화면 모드란, AWT <code>프레임</code>,<code>윈도우</code>,<code>다이얼로그</code>를 화면에 맞추어 넓힐 뿐(만큼)의 기능과는 완전히 달라, 비데오메모리의 내용을 어플리케이션으로 완전하게 제어하는 그래픽 모드입니다. 어플리케이션측에서 그래픽 카드로 draw 내용, draw 방법, draw 타이밍을 지시합니다. 이 모드는 언제나 이용할 수 있는 것은 아닙니다.  operating system에 따라서는, 전혀 구현할 수 없는 것도 있습니다. 또,  operating system안에는, 그래픽 카드가 이 기능을 지원하고 있는 경우에게만 이용할 수 있는 것도 있습니다. 다만, 이 모드는 성능에 큰 영향을 주므로, Windows 에서는 하드웨어의 page-flipping 기능을 유효하게 해 둘 필요가 있습니다.

<p>전화면 배타 API 모드의 사용법과 코드예에 대해서는,<a href="http://java.sun.com/docs/books/tutorial/extra/fullscreen/">여기</a>를 참조해 주세요.

<p>API 의 변경
<ul>
<li>새로운 public final 클래스 <a href="../../../api/java/awt/DisplayMode.html"><code>java.awt.DisplayMode</code></a>  가 도입되고 있습니다.

<li><a href="../../../api/java/awt/GraphicsDevice.html"><code>java.awt.GraphicsDevice</code></a>  의 변경점:
<pre>
    public void <a href="../../../api/java/awt/GraphicsDevice.html#setFullScreenWindow(java.awt.Window)">setFullScreenWindow(Window w)</a> 

    public Window <a href="../../../api/java/awt/GraphicsDevice.html#getFullScreenWindow()">getFullScreenWindow()</a>  

    public boolean <a href="../../../api/java/awt/GraphicsDevice.html#isDisplayChangeSupported()">isDisplayChangeSupported()</a>  

    public void <a href="../../../api/java/awt/GraphicsDevice.html#setDisplayMode(java.awt.DisplayMode)">setDisplayMode(DisplayMode dm)</a> 

    public DisplayMode <a href="../../../api/java/awt/GraphicsDevice.html#getDisplayMode()">getDisplayMode()</a>  

    public DisplayMode[] <a href="../../../api/java/awt/GraphicsDevice.html#getDisplayModes()">getDisplayModes()</a>  
</pre>

<li>비디오 버퍼-를 직접 컨트롤 하는 알고리즘은, 신규 클래스 <a href="../../../api/java/awt/image/BufferStrategy.html"><code>java.awt.image.BufferStrategy</code></a>  의 내부에 구현되었습니다.

<li>신규 클래스 <a href="../../../api/java/awt/BufferCapabilities.html"><code>java.awt.BufferCapabilities</code></a>  를 사용해 버퍼 스트래터지를 작성할 수가 있습니다. 같이 신규 클래스 <a href="../../../api/java/awt/ImageCapabilities.html"><code>java.awt.ImageCapabilities</code></a>  를 사용해, 특정의 구성의 이미지 기능을 정의할 수가 있습니다.

<li>어플리케이션 프로그래머는,<code>Canvas</code> 또는 <code>Window</code> 로부터 버퍼 스트래터지를 작성 및 사용할 수 있습니다. protected 내부 클래스로서 지원되는 버퍼 스트래터지에는 다음의 2 개가 있습니다. <a href="../../../api/java/awt/Component.FlipBufferStrategy.html"><code>java.awt.Component.FlipBufferStrategy</code></a>  와 <a href="../../../api/java/awt/Component.BltBufferStrategy.html"><code>java.awt.Component.BltBufferStrategy</code></a>  입니다. <code>createBufferStrategy</code> 메소드가 불려 가면(자), 이 2 개의 내부 클래스의 어느 쪽인지가 <a href="../../../api/java/awt/Canvas.html"><code>Canvas</code></a>  또는 <a href="../../../api/java/awt/Window.html"><code>Window</code></a>  로 사용됩니다. 어느 쪽이 사용되는지는, (스트래터지가 있는 경우는) 스트래터지의 작성시에 제공되는 <code>BufferCapabilities</code> 객체에 의해 정해집니다. 특정의 컴퍼넌트로 사용되는 버퍼 스트래터지를 가져오려면 ,<code>getBufferStrategy</code> 메소드를 사용합니다.

</ul>
</blockquote>

<a name=syncOutOfRange><b>Windows NT 에서의 비디오 드라이버의 Sync Out of Range 에러</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4452207.html">4452207</A> .

<p>Intel 810 그래픽 콘트롤러 탑재의 Dell Optiplex GX110 로 Windows NT 를 사용하고 있는 경우에, 표시 모드를 고해상도(�여러 차례 변경하면(자), 비디오 드라이버로부터 「sync out of range」라고 하는 메세지가 표시되는 일이 있습니다. 이것은, (DirectX) 비디오 드라이버의 버그가 원인입니다. 이 문제에 대해서는, 다음과 같은 몇개의 회피 방법이 있습니다.
<ul>
<li>커멘드행에 <code>-Dsun.java2d.noddraw=true</code> 를 지정해 DirectDraw 를 무효로 한다
<li>이 하드웨어로 실행되는 프로그램의 존속 기간중에 디스플레이 해상도를 여러 차례 변경하지 않는다
<li>이 하드웨어에서는 다음의 표시 모드를 금지한다
<pre>
    1152 X 864     8       85
    1152 X 864     16      85
    1152 X 864     24      85

    1280 X 1024    8       70,72,75,85
    1280 X 1024    16      70,72,75,85
    1280 X 1024    24      70,75,85

    무효색 (기대대로 표시되지 않는 색)

    1024 X 768     8       60,70,72,75,85
</pre>
</ul>
</blockquote>

<p>
<a name=undecorated><b>비장식 프레임</b></a>  
<blockquote> 

<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4038769.html">4038769</A> .

<p>어플리케이션에 따라서는, 네이티브 프레임 장식이 없는 것이 좋은 경우가 있습니다. 예를 들어, 다양한 플랫폼에서 실행되는 어플리케이션으로 같은 Look＆Feel 가 필요한 경우나, 네이티브의  operating system 기능을 사용해 최종 사용자가 어플리케이션에 개입하는 것을 프로그래머가 바라지 않는 경우입니다.

<p>이 릴리스에서는, Java 어플리케이션을 사용해 프레임 장식의 작성 기능을 무효로 할 수 있습니다. 비장식 프레임 모드를 온으로 하면(자), 네이티브인 타이틀 바, 시스템 메뉴, 경계, 또는  operating system에 의존하는 그 외의 네이티브인 화면 컴퍼넌트는 표시되지 않습니다. AWT 와 Swing 컴퍼넌트는 투과적으로 기능합니다.

<p><a href="../../../api/java/awt/Frame.html"><code>java.awt.Frame</code></a>  의 변경점:
<pre>
    public void <a href="../../../api/java/awt/Frame.html#setUndecorated(boolean)">setUndecorated(boolean undecorated)</a> 

    public boolean <a href="../../../api/java/awt/Frame.html#isUndecorated()">isUndecorated()</a>  
</pre>

<p><a href="../../../api/java/awt/Dialog.html"><code>java.awt.Dialog</code></a>  의 변경점:

<pre>
    public void <a href="../../../api/java/awt/Dialog.html#setUndecorated(boolean)">setUndecorated(boolean undecorated)</a> 

    public boolean <a href="../../../api/java/awt/Dialog.html#isUndecorated()">isUndecorated()</a> 
</pre>
</blockquote>

<p>
<a name=mousewheel><b>마우스 휠의 지원</b></a>  
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4289845.html">4289845</A> .


<p>마우스 휠과는 중앙의 버튼 대신에 휠이 있어서 , 마우스 휠에 의한 스크롤 기능이 Java 의 편입 지원에 새롭게 더해졌습니다. The <a href="../../../api/java/awt/event/MouseWheelEvent.html"><code>java.awt.event.MouseWheelEvent</code></a>  클래스는, Java 어플리케이션으로 마우스 휠의 스크롤을 심리스에 지원하는 것을 가능하게 합니다.  이 때, 재컴파일은 필요 없습니다. 또, 새로운 인터페이스 <a href="../../../api/java/awt/event/MouseWheelListener.html"><code>java.awt.event.MouseWheelListener</code></a>  를 사용해 마우스 휠의 동작을 커스터마이즈 할 수도 있습니다.

<p>Linux 로 마우스 휠을 사용하는 경우는,<a href="#linuxMouseWheel">여기</a>를 참조해 주세요.

<ul>
<li><b>스크롤 동작</b>
<p>
<ul>
<li>스크롤 바가 표시되고 있어, 한편, 스크롤 하는 <code>Component</code> 에 한 번에 표시할 수 있는 양이상의 내용이 있는 경우 (스크롤 샘이 스크롤 바 전체를 점령하지 않는 것 같은 경우)에, 스크롤 바는 「스크롤 가능」이라고 보여집니다.
<li>스크롤 바가 표시되고 있어도, 스크롤 할 수 없는 경우도 있습니다. 일반적으로, 이 상태는, 스크롤 바를 항상 표시하는 설정이 되어 있을 때 발생합니다.
<li>마우스 휠로 스크롤 하는 대상의 스크롤 바는, 다음과 같이 판정됩니다.
<ul>
<li>스크롤 가능한 스크롤 바가 1 개만 있는 경우는, 그 스크롤 바가 스크롤 대상이 된다
<li>수평 스크롤 바와 수직 스크롤 바가 양쪽 모두 스크롤 가능한 경우는, 수직 스크롤 바가 스크롤 대상이 된다
</ul>
<li>휠에 의한 스크롤을 모두 무효로 하려면 ,<code>setWheelScrollEnabled(false)</code> 를 사용합니다.
<li>휠을 위에 (자신으로부터 멀어질 방향으로) 돌리면(자), 수직 스크롤 바는 위에, 수평 스크롤 바는 왼쪽으로 스크롤 합니다. 휠을 아래에 (자신에게) 돌리면(자), 반대의 방향으로 스크롤 합니다.
<li>스크롤 샘이 스크롤 바의 구석에 있을 때는 스크롤 하지 않습니다.
</ul>

<p>
<li><b>중량 지원</b>
<ul>
<p>
<li>스크롤 바가 통합되고 있는 네이티브 피어에는, 독자적으로 마우스 휠의 스크롤을 취급하는 것이 있습니다. Windows 의 예에서는 <code>TextArea</code>,<code>Choice</code>,<code>FileDialog</code>,<code>List</code> 가 있습니다. 이러한 컴퍼넌트에서는, 네이티브 피어에 의해 마우스 휠의 스크롤이 제어됩니다.

<li>네이티브의 마우스 휠의 동작을 상속하지 않는 <code>Component</code> 는,<code>MouseWheelEvent</code> 가 유효하게 되어 있는 <code>Container</code> 가 발견될 때까지 <code>Container</code> 계층에 마우스 휠의 이벤트를 전합니다. 일반적으로, 이것이 <code>ScrollPane</code> 입니다. 마우스 휠의 이벤트는,<code>MouseWheelEvent</code> 가 유효하게 되어 있는 <code>Component</code> 에게 전할 수 있습니다.

<li>또는, 클라이언트 프로그래머가 <code>MouseWheelListener</code> 를 추가해, 마우스가 <code>Component</code> 상에 있을 때 마우스 휠을 움직였을 경우의 동작을 커스터마이즈 할 수도 있습니다. 마우스 휠의 이벤트를 네이티브로 처리할 수 있는 <code>Component</code> 의 경우, 클라이언트는 마우스 휠의 이벤트를 사용해 네이티브인 처리를 피할 수가 있습니다.

<li><code>java.awt.ScrollPane</code> 는, 디폴트로 <code>MouseWheelEvent</code> 가 유효하게 되도록(듯이) 변경되고 있습니다. <code>ScrollPane</code> 가 <code>MouseWheelEvent</code> 을 받으면(자), 내부의 <code>Component</code> 가 올바르고 스크롤 됩니다. 이 기능은, 신규 메소드 <code>setWheelScrollingEnabled</code> 로 무효로 할 수도 있습니다.
</ul>
<p>

<li><p><b>경량 지원</b>
<ul>
<p>
<li>경량 컴퍼넌트는,<code>MouseWheelListener</code> 을 가지는 최초의 선조에게 마우스 휠의 이벤트를 전합니다.

<li><code>MouseWheelListener</code> 를 <code>JComponent</code> 에 추가해 커스텀 이벤트 처리를 실시할 수가 있습니다.

<li>표시된 컴퍼넌트가 올바르게 스크롤 할 수 있도록(듯이) <code>javax.swing.JScrollPane</code> 가 변경되고 있습니다. <code>java.awt.ScrollPane</code> 와 같이,<code>setWheelScrollingEnabled</code> 를 사용해, 이 기능을 무효로 할 수도 있습니다.
</ul>
<p>

<li><b>새로운 API</b>
<p>API 에서는, 마우스 휠을 지원하기 위해(때문에), 벌써 설명한 신규 클래스나 신규 인터페이스 이외에도 다음의 점이 변경되고 있습니다.

<ul>
<li><a href="../../../api/java/awt/AWTEvent.html"><code>java.awt.AWTEvent</code></a>  의 변경점:
<pre>
    public final static long <a href="../../../api/java/awt/AWTEvent.html#MOUSE_WHEEL_EVENT_MASK">MOUSE_WHEEL_EVENT_MASK;</a> 
</pre>

<li><a href="../../../api/java/awt/AWTEventMulticaster.html"><code>java.awt.AWTEventMulticaster</code></a>  의 변경점:
<pre>
    public void <a href="../../../api/java/awt/AWTEventMulticaster.html#mouseWheelMoved(java.awt.event.MouseWheelEvent)">mouseWheelMoved(MouseWheelEvent e)</a> 

    public static MouseWheelListener <a href="../../../api/java/awt/AWTEventMulticaster.html#add(java.awt.event.MouseWheelListener,%20java.awt.event.MouseWheelListener)">add(MouseWheelListener a, MouseWheelListener b)</a> 

    public static MouseWheelListener <a href="../../../api/java/awt/AWTEventMulticaster.html#remove(java.awt.event.MouseWheelListener,%20java.awt.event.MouseWheelListener)">remove(MouseWheelListener l, MouseWheelListener oldl)</a> 
</pre>

<li><a href="../../../api/java/awt/Component.html"><code>java.awt.Component</code></a>  의 변경점:
<pre>
    public synchronized void <a href="../../../api/java/awt/Component.html#addMouseWheelListener(java.awt.event.MouseWheelListener)">addMouseWheelListener(MouseWheelListener l)</a> 

    public synchronized void <a href="../../../api/java/awt/Component.html#removeMouseWheelListener(java.awt.event.MouseWheelListener)">removeMouseWheelListener(MouseWheelListener l)</a> 
</pre>

<li><a href="../../../api/java/awt/ScrollPane.html"><code>java.awt.ScrollPane</code></a>  의 변경점:
<pre>
    public void <a href="../../../api/java/awt/ScrollPane.html#setWheelScrollingEnabled(boolean)">setWheelScrollingEnabled(boolean handleWheel)</a> 

    public boolean <a href="../../../api/java/awt/ScrollPane.html#isWheelScrollingEnabled()">isWheelScrollingEnabled()</a> 
</pre>

<li><a href="../../../api/java/awt/Robot.html"><code>java.awt.Robot</code></a>  의 변경점:
<pre>
    public synchronized void <a href="../../../api/java/awt/Robot.html#mouseWheel(int)">mouseWheel(int wheelAmt)</a> 
</pre>

</ul>

<li><a name=linuxMouseWheel><b>Linux 에서의 마우스 휠의 지원</b></a> 
<p>Linux 로 마우스 휠을 인식시키려면 ,<code>/etc/X11/XF86Config</code> 파일에 2 개의 변경을 실시할 필요가 있습니다. 「포인터」섹션으로 다음과 같은 변경을 실시합니다.

<ul>
<li><p>다음의 코드를 추가합니다.
<pre>
    ZAxisMapping 4 5
</pre>
<li><p>프로토콜을 다음과 같이 변경합니다. 「imps/2」 (사용의 휠 마우스에 따라서 다릅니다)
</ul>

</ul>

</blockquote>

<p>
<a name=zoom><b><code>Frame</code> 의 프로그래밍 줌</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4071554.html">4071554</A> .

<p>지금까지는,<code>Frame</code> 를 프로그램상에서 줌 (최대화) 하는 방법은 없었습니다. 이 릴리스에서는, 이 기능이 추가되었습니다.


<p>신규 인터페이스 <a href="../../../api/java/awt/event/WindowStateListener.html"><code>java.awt.event.WindowStateListener</code></a>  가 도입되고 있습니다.

<p><a href="../../../api/java/awt/Frame.html"><code>java.awt.Frame</code></a>  의 변경점:

<pre>
    public static final int <a href="../../../api/java/awt/Frame.html#MAXIMIZED_HORIZ">MAXIMIZED_HORIZ;</a> 

    public static final int <a href="../../../api/java/awt/Frame.html#MAXIMIZED_VERT">MAXIMIZED_VERT;</a> 

    public static final int <a href="../../../api/java/awt/Frame.html#MAXIMIZED_BOTH">MAXIMIZED_BOTH;</a> 

    public synchronized void <a href="../../../api/java/awt/Frame.html#setMaximizedBounds(java.awt.Rectangle)">setMaximizedBounds(Rectangle bounds)</a> 

    public Rectangle <a href="../../../api/java/awt/Frame.html#getMaximizedBounds()">getMaximizedBounds()</a> 

    public synchronized void <a href="../../../api/java/awt/Frame.html#setExtendedState(int)">setExtendedState(int state)</a> 

    public synchronized int <a href="../../../api/java/awt/Frame.html#getExtendedState()">getExtendedState()</a> 
</pre>

<p><a href="../../../api/java/awt/event/WindowEvent.html"><code>java.awt.event.WindowEvent</code></a>  의 변경점:

<pre>
    public static final int <a href="../../../api/java/awt/event/WindowEvent.html#WINDOW_STATE_CHANGED">WINDOW_STATE_CHANGED;</a> 

    public <a href="../../../api/java/awt/event/WindowEvent.html#WindowEvent(java.awt.Window,%20int,%20java.awt.Window,%20int,%20int)">WindowEvent(Window source, int id, Window opposite, int oldState, int newState)</a> 

    public <a href="../../../api/java/awt/event/WindowEvent.html#WindowEvent(java.awt.Window,%20int,%20int,%20int)">WindowEvent(Window source, int id, int oldState, int newState)</a> 

    public int <a href="../../../api/java/awt/event/WindowEvent.html#getOldState()">getOldState()</a> 

    public int <a href="../../../api/java/awt/event/WindowEvent.html#getNewState()">getNewState()</a> 
</pre>

<p><a href="../../../api/java/awt/AWTEvent.html"><code>java.awt.AWTEvent</code></a>  의 변경점:

<pre>
    public final static long <a href="../../../api/java/awt/AWTEvent.html#WINDOW_STATE_EVENT_MASK">WINDOW_STATE_EVENT_MASK;</a> 
</pre>

<p><a href="../../../api/java/awt/Toolkit.html"><code>java.awt.Toolkit</code></a>  의 변경점:

<pre>
    public boolean <a href="../../../api/java/awt/Toolkit.html#isFrameStateSupported(int)">isFrameStateSupported(int state)</a>  throws HeadlessException
</pre>

<p><a href="../../../api/java/awt/Window.html"><code>java.awt.Window</code></a>  의 변경점:

<pre>
    public synchronized void <a href="../../../api/java/awt/Window.html#addWindowStateListener(java.awt.event.WindowStateListener)">addWindowStateListener(WindowStateListener l)</a> 

    public synchronized void <a href="../../../api/java/awt/Window.html#removeWindowStateListener(java.awt.event.WindowStateListener)">removeWindowStateListener(WindowStateListener l)</a> 

    public synchronized WindowStateListener[] <a href="../../../api/java/awt/Window.html#getWindowStateListeners()">getWindowStateListeners()</a> 

    protected void <a href="../../../api/java/awt/Window.html#processWindowStateEvent(java.awt.event.WindowEvent)">processWindowStateEvent(WindowEvent e)</a> 
</pre>

<p><a href="../../../api/java/awt/event/WindowAdapter.html"><code>java.awt.event.WindowAdapter</code></a>  의 변경점:

<pre>
    public void <a href="../../../api/java/awt/event/WindowAdapter.html#windowStateChanged(java.awt.event.WindowEvent)">windowStateChanged(WindowEvent e)</a> 
</pre>

<p><a href="../../../api/java/awt/AWTEventMulticaster.html"><code>java.awt.AWTEventMulticaster</code></a>  의 변경점:

<pre>
    public static WindowStateListener <a href="../../../api/java/awt/AWTEventMulticaster.html#add(java.awt.event.WindowStateListener,%20java.awt.event.WindowStateListener)">add(WindowStateListener a, WindowStateListener b)</a> 

    public static WindowStateListener <a href="../../../api/java/awt/AWTEventMulticaster.html#remove(java.awt.event.WindowStateListener,%20java.awt.event.WindowStateListener)">remove(WindowStateListener l, WindowStateListener oldl)</a> 
</pre>

</blockquote>

<p>
<a name=dynamicLayout><b>사이즈 변경시의 동적인 레이아웃</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4077991.html">4077991</A> .

<p>지금까지는, 어느 플랫폼으로도 윈도우의 크기의 동적인 변경은 지원되고 있지 않았습니다. 예를 들어 Windows NT 에서는 크기의 정적인 변경을 「온」으로 하면(자), 드래그가 종료했을 때에만 레이아웃이 재계산되어, 윈도우의 크기가 변경되었습니다. 이 릴리스에서는, 이 기능이 수정되어 신규 데스크탑 프로퍼티 <code>awt.dynamicLayoutSupported</code> 가 추가되었습니다. 동적 레이아웃이 유효한 때는,<code>Container</code> 는 크기의 변경에 수반해 컴퍼넌트를 연속적으로 배치합니다. 무효인 때는, 크기의 변경이 종료한 다음에 레이아웃이 검증됩니다.

<p><a href="../../../api/java/awt/Toolkit.html"><code>java.awt.Toolkit</code> 의 API 의 변경점:</a> 
<pre>
    public void <a href="../../../api/java/awt/Toolkit.html#setDynamicLayout(boolean)">setDynamicLayout(boolean dynamic)</a> 

    protected boolean <a href="../../../api/java/awt/Toolkit.html#isDynamicLayoutSet()">isDynamicLayoutSet()</a> 

    public boolean <a href="../../../api/java/awt/Toolkit.html#isDynamicLayoutActive()">isDynamicLayoutActive()</a> 
</pre>

</blockquote>

<p>
<a name=listenerList><b>컴퍼넌트 리스너 리스트에의 액세스</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4290704.html">4290704</A> .

<p>지금까지는, 기입해 가능한 모든 AWT 컴퍼넌트는 읽어낼 수도 있었습니다. 예를 들어, 컴퍼넌트 API 에는 기입해 전용의 프로퍼티은 없습니다. 이벤트 리스너는 완전한 예외였습니다. AWT 이벤트 리스너에는 다음과 같은 1 조의 메소드가 있어, JavaBeans<sup><font size="-2">TM</font></sup> 의 규칙에 따라 관리되고 있습니다. <code><i>XXX</i>EventListener</code> 인터페이스를 구현하는 리스너의 <code>add<i>XXX</i>Listener</code> 메소드와 <code>remove<i>XXX</i>Listener</code> 메소드.

<p>리스너 리스트 그 자체에의 액세스 기능은 제공되지 않았습니다. 리스너 리스트를 포함한 필드는 package private 로, 리스너 리스트의 내용을 되돌리는 메소드는 제공되지 않았습니다. 이것은 Swing 나 다른 AWT 클라이언트에 있어서의 문제의 원인이 되어 있었습니다.

<p>버젼 1.3 의 Java 2 SDK 의 문제를 가볍게 하기 위해서,<code>Component</code> 에 <code>getListeners</code> 메소드를 추가해, 리스너 리스트를 정의한 Swing 클래스에도 추가했습니다. <code>getListeners</code> 메소드는, 클래스를 사용해 특정의 리스너 리스트를 지정합니다. 예를 들어,<code>addFocusListener</code> 에 의해 추가된 모든 리스너를 얻기 위해서(때문에)는, 다음과 같이 기술합니다. <code>getListeners(FocusListener.class)</code>

<p>리스너 리스트를 공개하는 이 특정의 어프로치에 의해, AWT/Swing public API 전체의 변경을 최소한으로 할 수 있었습니다. 이것은 모든 JavaBeans 의 규칙으로 하기 위한 것은 아니고,<code>addPropertyChangeListener("myProperty", myListener)</code> 와 같은 단독의 프로퍼티에 추가할 수 있는 <code>PropertyChangeListener</code> 는 취급하지 않았습니다.

이 릴리스에서는, 이벤트 리스너에 액세스 할 수 있는, 보다 완성도의 높은 솔루션이 설계되고 있습니다. 개념상은, 다음의 2 점이 변경되고 있습니다.
<ul>
<li><code>getFooListeners</code> 메소드를 AWT 클래스와 Swing 클래스의 add/remove 규칙에 추가
<li>단독 프로퍼티을 대기하는 메소드를 포함한 <code>PropertyChangeListener</code> 및 <code>VetoableChangeListener</code> 의 지원.  신규 클래스 <a href="../../../api/java/util/EventListenerProxy.html"><code>java.util.EventListenerProxy</code></a>  를 사용합니다.
</ul>

<p>신규 클래스 <a href="../../../api/java/awt/event/AWTEventListenerProxy.html"><code>java.awt.event.AWTEventListenerProxy</code></a>  가 있습니다.

<p><a href="../../../api/java/awt/Toolkit.html"><code>java.awt.Toolkit</code></a>  의 API 의 변경점:

<pre>
    public PropertyChangeListener[] <a href="../../../api/java/awt/Toolkit.html#getPropertyChangeListeners()">getPropertyChangeListeners()</a> 

    public synchronized PropertyChangeListener[] <a href="../../../api/java/awt/Toolkit.html#getPropertyChangeListeners(java.lang.String)">getPropertyChangeListeners(String propertyName)</a> 

    public AWTEventListener[] <a href="../../../api/java/awt/Toolkit.html#getAWTEventListeners()">getAWTEventListeners()</a> 

    public AWTEventListener[] <a href="../../../api/java/awt/Toolkit.html#getAWTEventListeners(long)">getAWTEventListeners(long eventMask)</a> 
</pre>

</blockquote>

<p>
<a name=dragndrop><b>드래그＆드롭의 변경점</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트:<A href="http://developer.java.sun.com/developer/bugParade/bugs/4407057.html">
      4407057</A>  및 <A href="http://developer.java.sun.com/developer/bugParade/bugs/4426750.html"> 4426750</A> 

<p>Solaris 및 Linux 판의 Java 2 Standard Edition, SDK 1.3 에서는, 어플리케이션이 <code>java.awt.dnd API</code> 를 사용해 AWT 중량 <code>Components</code> 를 <code>DragSource</code> 로서 식별하지 않는 경우에서도, 마우스의 조절 버튼으로 디폴트의 드래그 동작을 나타내는 <code>Component</code> 가 몇개인가 있었습니다. 이러한 <code>Component</code> 는 Motif 피어를 사용해 구현되어 Motif 는 마우스의 조절 버튼의 드래그 동작을 디폴트로 이러한 피어에 제공합니다.

<p>AWT 의 설계상의 문제와 Motif 라이브러리의 버그를 위해서(때문에), 이 디폴트의 동작은 안정성에 관한 다양한 문제의 원인이 되어 있습니다. 향후도 AWT 와 드래그＆드롭의 안정성을 계속 위험에 처하는 것보다 는, 이 기능을 구현하지 않고 명확하게 무효로 하는 편이 좋다고 판단했습니다.

<p>그런데도 <code>java.awt.dnd API</code> 를 사용하면, 개발자는 어플리케이션의 <code>Component</code> 를 <code>DragSource</code> 라고 볼 수가 있습니다. 이것은 기능적이기도 해, 지원의 대상이기도 합니다. 이 어프로치는, 디폴트의 Motif 동작에 의존하는 것보다도, 항상 우수합니다. Solaris 와 Linux  만이 아니고, 모든 플랫폼에서 <code>Component</code> 의 드래그를 지원할 수 있기 때문입니다.
</blockquote>


<p>

<a name=64bit><b>64 비트 대응의 Solaris 머신</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4295833.html">4295833</A> .

<p>64 비트의 Solaris 어플리케이션은, 32 비트는 아니고 64 비트를 사용해 메모리에 액세스 합니다. 이것에 의해, 가상 메모리의 용량을 늘려 대용량의 어플리케이션을 사용할 수 있는신음합니다. 이 릴리스의 AWT 는 64 비트까지 대응하고 있습니다. 자세한 것은,<a href="../vm/index.html">여기</a>  를 참조해 주세요.
</blockquote>

<a name=inconsistentDLLs><b>일관성이 없는 DLL 경고</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4414004.html">4414004</A> .

<p>아시아계 언어판의 Windows NT 도 인스톨 되고 있는 머신에 영문판의 VC++ 6.0 을 인스톨 했을 경우,<code>TextArea</code> 컴퍼넌트에 아시아계 언어판의 텍스트를 사용하면(자), 문자가 변하고가 발생합니다. 이 문제는, 2 바이트 대응의 Windows NT 가 동작하고 있는 머신에 Microsoft Exchange 또는 Microsoft Office 97 을 인스톨 해도 발생합니다. 이 문제는 일본어판의 Windows NT 로 보고되었습니다만, 중국어나 한국어판이라고 하는 비라틴계 언어판에서도 발생한다고 생각됩니다.

<p>이 문제는, 프로그램의 인스톨시에 아시아계 언어판 Riched32.dll 가 영문판에 옮겨졌기 때문에 생겼습니다. Riched32.dll 를 아시아계 언어판에 옮겨놓으면(자), 문제는 해결합니다.
</blockquote>


<a name=drawingSurface><b>draw면 API 의 삭제</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4293646.html">4293646</A> .

<p><code>sun.awt.DrawingSurface</code> API 가 삭제되었습니다. 지금까지 공표되었던 적은 없습니다만, 사용하고 있는 개발자도 있습니다. 이 API 의 기능은 JAWT 로 옮겨지고 있습니다. 자세한 것은,<a href="AWT_Native_Interface.html">AWT Native Interface</a> 에 있는 설명을 참조해 주세요.

</blockquote>

<a name=windowCentering><b>멀티스크린의 지원에 필요한 윈도우의 중앙 배치 API</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4463949.html">4463949</A> .

<p>멀티 헤드 시스템으로 동작하는 Xinerama 대응의 어플리케이션으로 다양한 문제가 발생해, 버그 리포트가 작성되고 있습니다. 멀티 헤드 환경에서 경계의 작은 모니터를 사용하고 있는 경우는, 모니터 끼리가 서로 접촉해 , 그 결과 1 개(살)의 거대한 디스플레이와 같은 효과를 얻을 수 있습니다. 이 경우는, 「적절히」중앙 배치된 윈도우가 복수의 화면에 걸쳐 표시됩니다. 멀티 헤드 환경에서 일반적으로의 CRT 모니터를 사용하고 있는 경우는, 실제의 표시 영역 끼리의 사이에 수인치의 차이가 생깁니다. 이 경우, 윈도우를 드래그 할 수 없는 모니터 (Solaris 의 로그인 화면등)가 있는 경우는 특히, 복수의 화면에 걸치는 윈도우에 기묘한 효과가 발생합니다. 즉, Xinerama 환경의 어디를 중심으로 윈도우를 배치하는지를 지시할 방법이 없었습니다.

<p>이 문제에 대처하기 위해(때문에), X 그룹에 API 가 추가되었습니다. 이 API 를 사용해, Xinerama 의 사용자는 윈도우 배치의 중심을 지정할 수 있어 Xinerama 대응 어플리케이션의 개발자는 적절히 코딩 할 수 있게 되었습니다.

<p>이 릴리스 이전에는, 다음과 같이 디폴트의 <code>GraphicsDevice</code> 의 경계내에서 윈도우를 중앙 배치하고 있었습니다.

<pre>
    bounds = getDefaultScreenDevice(). getDefaultConfiguration(). getBounds();
    frame.setLocation(bounds / 2 - <i>윈도우 사이즈</i> / 2);
</pre>

이 코드에 의해, Xinerama 시스템의 윈도우가 Xinerama 전체의 좌표 공간에 올바르고 중앙 배치되고 있었습니다.

<p>이 릴리스 이후의 <a href="http://developer.java.sun.com/developer/bugParade/bugs/4356756.html"> 4356756</a>  수정이 끝난 JDK 에서는, Xinerama 시스템의 윈도우는, primary 디스플레이안에 올바르고 중앙 배치되게 됩니다.

<p>이것을 실현하기 위해서(때문에),<a href="../../../api/java/awt/GraphicsEnvironment.html#getCenterPoint()"><code>getCenterPoint</code></a>  메소드가 <a href="../../../api/java/awt/GraphicsEnvironment.html"><code>GraphicsEnvironment</code></a>  에 추가되었습니다.

<p>이 메소드는, 각종 플랫폼에서 다음과 같이 동작합니다.

<ul>
<li>Microsoft Windows/Macintosh:<br>이러한 플랫폼에서는, 모든 모니터가 단일의 가상 좌표 공간에 놓여집니다. 다만, 그 중의 1 개가 「primary」디스플레이가 됩니다.  primary 디스플레이에는, Microsoft Windows 에서는 태스크바가, Mac 에서는 도구모음이 표시됩니다. 여기에서는,<code>getCenterPoint</code> 는 primary 디스플레이의 중심 좌표를 돌려줍니다.
<p>

<li>Xinerama 이외의 X Window <br>각 디스플레이가 독자적인 좌표계를 가지고 있습니다.  각 디스플레이의 좌상구석이 0.0 입니다. 이 경우도, 「primary」디스플레이가 존재합니다. 여기에서는,<code>getCenterPoint</code> 는 primary 디스플레이의 중심 좌표를 돌려줍니다.
<p>

<li>Xinerama 의 X Window <br>Microsoft Windows 와 같게, 모든 모니터가 단일의 가상 좌표 공간을 공유합니다. 다만, 사용자가 X 자원을 통해 윈도우 배치의 중심을 지정할 수 있습니다. 이러한 자원이 설정되어 있는 경우,<code>getCenterPoint</code> 는 그 값을 돌려줍니다. 그 이외의 경우는, 가상 좌표 공간의 중심점을 돌려줍니다. (실제로는, CDE 가 이것을 디폴트로 설정하기 위해(때문에), 대부분의 경우는 설정되어 있습니다. )
</ul>

<p>JDK 1.4 로부터, 중앙 배치를 위한 올바른 코드는 다음과 같이 됩니다.

<pre>
    frame.setLocation(getCenterPoint() - <i>윈도우 사이즈</i> / 2);
</pre>

<p><code>GraphicsEnvironment</code> 에 추가된 이제(벌써) 1 개의 메소드는 <a href="../../../api/java/awt/GraphicsEnvironment.html#getMaximumWindowBounds()"><code>getMaximumWindowBounds</code></a>  입니다. <code><code>getCenterPoint</code> 와 <code>getMaximumWindowBounds</code> 는 어느쪽이나, 헷드레스모드 때에 <code>HeadlessException</code> 를 throw 합니다.
</blockquote>

<a name=inputEvent><b>새로운 InputEvent 키 수식자</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트:<A href="http://developer.java.sun.com/developer/bugParade/bugs/4387938.html"> 4387938</A>  및 <a href="http://developer.java.sun.com/developer/bugParade/bugs/4421515.html"> 4421515</a> 

<p>지금까지,<a href="../../../api/java/awt/event/InputEvent.html"><code>InputEvent</code></a>  수식자는, 키보드와 mouse button에 대해서 같은 값을 가지고 있었습니다. 상황에 따라서는, 어느 키나 버튼이 밀렸는지를 구별할 수 없는 것이나, 동시에 복수 밀렸을 때에 판별할 수 없는 것이 있었습니다. 이러한 상황으로서는, 동시에 복수의 mouse button가 밀렸을 때나, 마우스 이벤트가 수식자에 의해 변경되었을 때등이 있습니다.
<p>이 결함을 해결하기 위해서, 다음의 정수가 <code>InputEvent</code> 에 추가되었습니다.
  <ul>
<li><a href="../../../api/java/awt/event/InputEvent.html#SHIFT_DOWN_MASK"><code>SHIFT_DOWN_MASK</code></a> 
<li><a href="../../../api/java/awt/event/InputEvent.html#CTRL_DOWN_MASK"><code>CTRL_DOWN_MASK</code></a> 
<li><a href="../../../api/java/awt/event/InputEvent.html#META_DOWN_MASK"><code>META_DOWN_MASK</code></a> 
<li><a href="../../../api/java/awt/event/InputEvent.html#ALT_DOWN_MASK"><code>ALT_DOWN_MASK</code></a> 
<li><a href="../../../api/java/awt/event/InputEvent.html#ALT_GRAPH_DOWN_MASK"><code>ALT_GRAPH_DOWN_MASK</code></a> 
<li><a href="../../../api/java/awt/event/InputEvent.html#BUTTON1_DOWN_MASK"><code>BUTTON1_DOWN_MASK</code></a> 
<li><a href="../../../api/java/awt/event/InputEvent.html#BUTTON2_DOWN_MASK"><code>BUTTON2_DOWN_MASK</code></a> 
<li><a href="../../../api/java/awt/event/InputEvent.html#BUTTON3_DOWN_MASK"><code>BUTTON3_DOWN_MASK</code></a> 
  </ul>

<p>다음의 메소드가 <code>InputEvent</code> 에 추가되었습니다.
  <ul>
<li><a href="../../../api/java/awt/event/InputEvent.html#getModifiersEx()"><code>getModifiersEx</code></a> 
<li><a href="../../../api/java/awt/event/InputEvent.html#getModifiersExText(int)"><code>getModifiersExText</code></a> 
  </ul>

<p><a href="../../../api/java/awt/event/MouseEvent.html"><code>MouseEvent</code></a>  의 클래스 스펙이 갱신되었습니다. 다음의 정수도 <code>MouseEvent</code> 에 추가되었습니다.
  <ul>
<li><a href="../../../api/java/awt/event/MouseEvent.html#NOBUTTON"><code>NOBUTTON</code></a> 
<li><a href="../../../api/java/awt/event/MouseEvent.html#BUTTON1"><code>BUTTON1</code></a> 
<li><a href="../../../api/java/awt/event/MouseEvent.html#BUTTON2"><code>BUTTON2</code></a> 
<li><a href="../../../api/java/awt/event/MouseEvent.html#BUTTON3"><code>BUTTON3</code></a> 
  </ul>

<p>다음의 메소드가 <code>MouseEvent</code> 에 추가되었습니다.
  <ul>
<li><a href="../../../api/java/awt/event/MouseEvent.html#MouseEvent(java.awt.Component,%20int,%20long,%20int,%20int,%20int,%20int,%20boolean,%20int)"><code>MouseEvent(Component source, int id, long when, int modifiers, int x, int y, int clickCount, boolean popupTrigger, int button)</code></a> 
<li><a href="../../../api/java/awt/event/MouseEvent.html#getButton()"><code>getButton</code></a> 
<li><a href="../../../api/java/awt/event/MouseEvent.html#getMouseModifiersText(int)"><code>getMouseModifiersText</code></a> 
  </ul>

<p><a href="../../../api/java/awt/dnd/DragSourceDragEvent.html"><code>DragSourceDragEvent</code></a>  에 새로운 <a href="../../../api/java/awt/dnd/DragSourceDragEvent.html#getGestureModifiersEx()"><code>getGestureModifiersEx</code></a>  메소드가 추가되었습니다.
</blockquote>

<a name=choice><b>Choice 메뉴의 드롭 다운 동작의 변경점</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4462677.html">4462677</A> .

<p><code>Choice</code> 드롭 다운 메뉴의 동작이, JDK 1.3. 1 에서 1.4 의 사이에 변경되었습니다. 1.3. 1 에서는, Choice 바의 어디를 클릭해도 드롭 다운 메뉴가 표시되었습니다. 1.4 에서는,<code>Choice</code> 바의 오른쪽에 있는 화살표를 클릭할 필요가 있습니다. <code>Choice</code> 바의 다른 부분을 클릭해도 아무것도 일어나지 않습니다. <code>Choice</code> 바의 기호도, 바로부터 화살표와 바를 조합한 것으로 변경되었습니다. 마지막으로, 드롭 다운 메뉴가 전개되었을 때, 부모의 밖에 나와 있는 부분을 클릭하면(자), 그 아래에 있는 어플리케이션이 전면에 표시됩니다. 다만, 이것은 Solaris 에서의 동작이며, Windows 에서는 다릅니다.
</blockquote>

<a name=choice2><b>선택 컴퍼넌트는 레이아웃 매니저 제한으로 적합</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4288285.html">4288285</A> .

<p>1.4 보다 전의 릴리스에서는, AWT <code>Choice</code> 위젯는, 레이아웃 매니저가 지정한 사이즈를 무시하는 경우가 있었습니다. 이 릴리스에서는, 레이아웃 매니저의 제한에 따릅니다.
</blockquote>

<a name=focusDeprecate><b>추천 되지 않는 Focus 메소드</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4476300.html">4476300</A> .

<p>이 릴리스로 도입된 새로운 포커스 하부조직에서는, AWT 및 Swing 의 고도의 어플리케이션으로 키보드 포커스를 취급하기 위해서(때문에), 새로운 아키텍쳐(architecture)와 용어가 도입되었습니다. 이 프로젝트 이전에는, 포커스 관련의 API 가 많고로 사용법과 용어에 무결성이 없고, 문서에도 미비가 있었기 때문에, 불완전한 설계의 UI 로 연결되어 있었습니다. 새로운 아키텍쳐(architecture)가 도입된 현재는, 이러한 API 의 쳐 특히 사용을 피해야 할 것이 있습니다.

<p>다음의 정수와 메소드는 추천 되지 않게 되었습니다.
<ul>
<li><a href="../../../api/javax/swing/FocusManager.html#FOCUS_MANAGER_CLASS_PROPERTY"><code>javax.swing.FocusManager.FOCUS_MANAGER_CLASS_PROPERTY</code></a> 
<li><a href="../../../api/javax/swing/FocusManager.html#disableSwingFocusManager()"><code>javax.swing.FocusManager.disableSwingFocusManager()</code></a> 
<li><a href="../../../api/javax/swing/FocusManager.html#isFocusManagerEnabled()"><code>javax.swing.FocusManager.isFocusManagerEnabled()</code></a> 
<li><a href="../../../api/javax/swing/JComponent.html#requestDefaultFocus()"><code>javax.swing.JComponent.requestDefaultFocus()</code></a> 
<li><a href="../../../api/javax/swing/JComponent.html#isManagingFocus()"><code>javax.swing.JComponent.isManagingFocus()</code></a> 
<li><a href="../../../api/javax/swing/JComponent.html#setNextFocusableComponent(java.awt.Component)"><code>javax.swing.JComponent.setNextFocusableComponent(Component)</code></a> 
<li><a href="../../../api/javax/swing/JComponent.html#getNextFocusableComponent()"><code>javax.swing.JComponent.getNextFocusableComponent()</code></a> 
<li><a href="../../../api/java/awt/Component.html#isFocusTraversable()"><code>java.awt.Component.isFocusTraversable()</code></a> 
<li><a href="../../../api/java/awt/Component.html#hasFocus()"><code>java.awt.Component.hasFocus()</code></a> 
<li><a href="../../../api/javax/swing/SwingUtilities.html#findFocusOwner(java.awt.Component)"><code>javax.swing.SwingUtilities.findFocusOwner(Component)</code></a> 
</ul>

</blockquote>

<a name=actionEvents><b>타임 스탬프를 필요로 하는 ActionEvent ( 및 그 외의 이벤트)</b></a> 
<blockquote>
<p>이 변경에 관련하는 버그 추적 리포트: <A href="http://developer.java.sun.com/developer/bugParade/bugs/4434193.html">4434193</A> .

<p>새로운 포커스 아키텍쳐(architecture)에는, 앞치는 것 기구도 포함되어 있습니다. 이 기구에서는, 어느 <code>KeyEvent</code> 로 포커스 이동이 개시되면(자), 이동이 완료할 때까지, 후속의 <code>KeyEvent</code> 는 전달되지 않게 됩니다. 이 기능의 설계는, 각종 이벤트의 UTC 타임 스탬프에 근거하고 있습니다. 이동을 개시한 이벤트보다 후의 타임 스탬프를 가지는 이벤트는 이동의 기다리는 행렬에 넣어집니다만, 그것보다 전의 타임 스탬프를 가지는 이벤트는 넣을 수 있지 않습니다.

<p>이 기능을 실현하기 위해서(때문에), 포커스 코드에서는, 현재 처리중의 이벤트의 타임 스탬프를 항상 감시하고 있습니다. 이 처리중에 포커스 이동이 개시되었을 경우는, 그 타임 스탬프를 사용할 수 있습니다. 다만, 현재 처리중의 이벤트에 타임 스탬프가 없는 경우는, 시스템의 현재 시각이 사용됩니다. 현재 시각을 사용하는 경우, 일반적으로 이벤트가 실제로 발생했을 때 각보다 꽤 진행되고 있기 (위해)때문에, 실제로는 도움이 되지 않습니다. 결과적으로, 앞치는 것 기구는 실패해, 포커스 이동이 완료하기 전에 <code>KeyEvent</code> 가 전달됩니다.

<p>ActionEvent</code> 는, 기가 되는<code>InputEvent</code> 에 대응해 생성되는, 고레벨의 세만틱이벤트입니다. <code> InputEvent</code> 에는 타임 스탬프를 관련지을 수 있고 있었습니다만,<code>ActionEvent</code> 는 타임 스탬프를 가지고 있지 않았습니다. 따라서, 타임 스탬프를 포함할 수 있도록(듯이) <code>ActionEvent</code> API 가 확장되었습니다. 또, 구현도 갱신되어<code>ActionEvent</code> 의 타임 스탬프와 기반이 되는 <code>InputEvent</code> 의 타임 스탬프가 일치하게 되었습니다.

<p>다음의 메소드가 <a href="../../../api/java/awt/event/ActionEvent.html"><code>ActionEvent</code></a>  에 추가되었습니다.
  <ul>
<li><a href="../../../api/java/awt/event/ActionEvent.html#ActionEvent(java.lang.Object,%20int,%20java.lang.String,%20long,%20int)"><code>ActionEvent(Object source, int id, String command, long when, int modifiers)</code></a> 
<li><a href="../../../api/java/awt/event/ActionEvent.html#getWhen()"><code>getWhen</code></a> 
  </ul>

<p>다음의 <code>ActionEvent</code> 메소드가 변경되었습니다.
  <ul>
<li><a href="../../../api/java/awt/event/ActionEvent.html#ActionEvent(java.lang.Object,%20int,%20java.lang.String)"><code>ActionEvent(Object source, int id, String command)</code></a> 
<li><a href="../../../api/java/awt/event/ActionEvent.html#ActionEvent(java.lang.Object,%20int,%20java.lang.String,%20int)"><code>ActionEvent(Object source, int id, String command, int modifiers)</code></a> 
  </ul>

<p><a href="../../../api/java/awt/event/InvocationEvent.html#getWhen()"><code>getWhen</code></a>  메소드가 <a href="../../../api/java/awt/event/InvocationEvent.html"><code>InvocationEvent</code></a>  에 추가되었습니다.

<p><code>InvocationEvent</code> 의 <a href="../../../api/java/awt/event/InvocationEvent.html#InvocationEvent(java.lang.Object,%20java.lang.Runnable)"><code>InvocationEvent(Object, Runnable)</code></a>  생성자 과 <a href="../../../api/java/awt/event/InvocationEvent.html#InvocationEvent(java.lang.Object,%20java.lang.Runnable,%20java.lang.Object,%20boolean)"><code>InvocationEvent(Object, Runnable, Object, boolean)</code></a>  생성자 이 변경되었습니다.

<p>새로운 <a href="../../../api/java/awt/event/InputMethodEvent.html#InputMethodEvent(java.awt.Component,%20int,%20long,%20java.text.AttributedCharacterIterator,%20int,%20java.awt.font.TextHitInfo,%20java.awt.font.TextHitInfo)"><code>InputMethodEvent(Component, int, long, AttributedCharacterIterator, int, TextHitInfo, TextHitInfo)</code></a>  생성자 이 <a href="../../../api/java/awt/event/InputMethodEvent.html"><code>InputMethodEvent</code></a>  에 추가되었습니다. <a href="../../../api/java/awt/event/InputMethodEvent.html#getWhen()"><code> getWhen</code></a>  메소드도 추가되고 있습니다.

<p>다음의 <code>InputMethodEvent</code> 생성자 이 변경되었습니다.
  <ul>
<li><a href="../../../api/java/awt/event/InputMethodEvent.html#InputMethodEvent(java.awt.Component,%20int,%20java.text.AttributedCharacterIterator,%20int,%20java.awt.font.TextHitInfo,%20java.awt.font.TextHitInfo)"><code>InputMethodEvent(Component, int, AttributedCharacterIterator, int, TextHitInfo, TextHitInfo)</code></a> 
<li><a href="../../../api/java/awt/event/InputMethodEvent.html#InputMethodEvent(java.awt.Component,%20int,%20java.awt.font.TextHitInfo,%20java.awt.font.TextHitInfo)"><code>InputMethodEvent(Component, int, TextHitInfo, TextHitInfo). </code></a> 
  </ul>

<p>마지막으로, 다음의 메소드가 <a href="../../../api/java/awt/EventQueue.html"><code>EventQueue</code></a>  에 추가되었습니다.
   <ul>
<li><a href="../../../api/java/awt/EventQueue.html#getMostRecentEventTime()"><code>getMostRecentEventTime</code></a> 
<li><a href="../../../api/java/awt/EventQueue.html#getCurrentEvent()"><code>getCurrentEvent</code></a> 
   </ul>
</blockquote>

<!-- ============================================================== -->

<HR SIZE=3 NOSHADE>



<TABLE summary="layout" BORDER="0" WIDTH="100%">

<TR VALIGN=TOP>



<TD>

<P><FONT SIZE="-2">

<A HREF="../../../legal/SMICopyright.html">Copyright &#169;</A>  2001

<A HREF="http://www.sun.com/">Sun Microsystems, Inc. </A> 

All Rights Reserved. </FONT></P>

   <br>



<FONT SIZE="-1">코멘트의 송부처:<a href="mailto:java-awt@java.sun.com">java-awt@java.sun.com</a> </FONT>

</TD>



<TD ALIGN=RIGHT>

<IMG SRC="../../../images/sunlogo64x30.gif" ALT="Sun" BORDER=0 WIDTH=64 HEIGHT=30>



</TD>



</TR>

</TABLE>
  </blockquote></body>
</html>
