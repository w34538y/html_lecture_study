<html><head>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">
<title> - xrath.com 에서 번역됨</title>

</head>
<body bgcolor=#ffffff>
<hr>
<h1>제 12 장:사운드의 합성</h1>
<hr>
<form name="form1">
  <select name="menu1" onChange="Eminem_jumpMenu('parent',this,1)">
    <SCRIPT SRC="menu_script.js" language="JavaScript"></SCRIPT>
  </select>
</form>
<p>&nbsp;</p>
<p><a name="121725"> </a> Java<font size="-1"><sup>TM</sup></font> Sound API 의 MIDI 패키지를 이용하는 프로그램의 대부분이, 사운드를 합성하기 위해서 사용됩니다. MIDI 파일, 이벤트, 순서 및 시퀀서의 기능의 상세한 것에 대하여는 다른 장으로 설명했습니다만, 각각의 최종적인 목표는 음악 데이터를 신디사이저에 보내 오디오로 변환하는 것입니다. 예외로서 MIDI 데이터를 뮤지션이 읽을 수 있는 악보로 변환하는 프로그램이나, 믹싱 콘솔등의 외부의 MIDI 제어 디바이스에 메세지를 송신하는 프로그램이 있습니다.
</p><p><a name="121727"> </a> 따라서,<code>Synthesizer</code> 인터페이스가 MIDI 패키지의 기본이 됩니다. 이 장에서는, 신디사이저를 조작해 사운드를 재생하는 방법에 대해 설명합니다. 많은 프로그램에서는 시퀀서를 사용해 MIDI 파일 데이터를 신디사이저에 보낼 뿐(만큼)이므로, 많은 <code>Synthesizer</code> 메소드를 직접 호출할 필요는 없습니다. 그러나, 이 장의 마지막 (분)편으로 설명하도록(듯이), 시퀀서나 <code>MidiMessage</code> 객체를 사용하지 않고 직접 신디사이저를 제어하는 방법이 있습니다.
</p><p><a name="121729"> </a> MIDI 합성 아키텍쳐(architecture)는, MIDI 에 서투른 경우에는 복잡하게 느껴지는 것입니다만, 요약하면(자), MIDI 합성의 API 에는, 다음의 인터페이스가 있습니다.  
</p><ul><a name="121730"> </a> 
<li><code>Synthesizer</code> <a name="121731"> </a> 
<li><code>MidiChannel</code> <a name="121732"> </a> 
<li><code>Soundbank</code>
<p><a name="121733"> </a> 
</ul>
또, 다음의 4 개의 클래스가 있습니다.  
<ul>
<p></p><a name="121734"> </a> 
<li><code>Instrument</code> <a name="121735"> </a> 
<li><code>Patch</code> <a name="121736"> </a> 
<li><code>SoundbankResource</code> <a name="121737"> </a> 
<li><code>VoiceStatus</code>
<p><a name="121739"> </a> 
</ul>
이 모든 API 를 이해하기 위해서, 다음의 마디로 MIDI 합성에 대한 기본 사항을 몇개인가 들어, MIDI 합성과 Java Sound API 와의 관련성에 대해 설명합니다. 제 8 장<a href="chapter8.html">「MIDI 패키지의 개요」</a>의<a href="chapter8.html#118842">「Java Sound API 에서의 MIDI 디바이스 표현」</a>의,<a href="chapter8.html#118862">「신디사이저」</a>도  아울러 참조해 주세요. 그 이후의 마디에서는, API 에 대해 게다가 자세하게 설명합니다.  
<p></p><a name="121742"> </a> 
<h3> MIDI 합성에 대해 </h3>
<p><a name="121745"> </a> 신디사이저는, 어떻게 해 소리를 생성하는 것일까요. 구현에 따라서 다릅니다만, 신디사이저에는, 1 개(살) 또는 복수의 사운드 합성 기술이 사용되고 있습니다. 예를 들어, 많은 신디사이저에서는 Wavetable 합성을 사용합니다. Wavetable 신디사이저는 메모리에 보존되고 있는 오디오편을 읽어내, 다양한 샘플링 레이트로 재생해, 루프 시켜, 다양한 피치와 듀레이션을 만들어 냅니다. 예를 들어, 노트 C#4 (MIDI 노트 넘버 61)를 연주하는 색소폰의 소리를 합성하려면 , 중앙 C (MIDI 노트 넘버 60)의 색소폰 연주의 녹음으로부터 매우 짧은 단편을 이용해, 이 단편을, 녹음시보다 조금 빠른 샘플링 레이트로 반복하는 것으로, 약간 높은 피치의 롱 노트가 작성됩니다. 이 밖에, 보존된 오디오를 이용하지 않고, 다른 알고리즘을 사용해 오디오를 제로로부터 생성하는 주파수변조 (FM), 가산 합성, 물리 모델링 방식을 사용하는 신디사이저등이 있습니다.  
</p><a name="121747"> </a> 
<h4> 인스트르먼트</h4>
<p><a name="123181"> </a> 모든 합성 기술에 공통되는 것은, 많은 종류의 사운드를 합성할 수 있는 것입니다. 다른 알고리즘을 사용하거나 같은 알고리즘내에서 파라미터 설정을 바꾸거나 하는 것으로써, 다양한 사운드 합성이 가능하게 됩니다. 「인스트르먼트」는, 특정의 종류의 사운드를 합성하는 경우에 사용하는 스펙을 나타냅니다. <em></em>그 사운드는, 전통적인 악기 (피아노나 바이올린등)나 다른 종류의 음원 (전화나 헬리콥터의 소리등)을 에뮤레이트 하고 있는 경우도, 열매 세계의 소리는 전혀 에뮤레이트 하고 있지 않는 경우도 있습니다. General MIDI 로 불리는 스펙에는 128 의 인스트르먼트가 표준으로서 정의되고 있습니다만, 대부분의 신디사이저에서는 이외의 인스트르먼트의 소리도 합성할 수 있습니다. 많은 신디사이저에는, 상시 이용할 수 있는 다수의 인스트르먼트가 짜넣어지고 있어 일부의 신디사이저에는 추가의 인스트르먼트를 로드하기 위한 기구도 있습니다. </p>
<p><a name="123190"> </a> 인스트르먼트는 벤더 고유한 가능성이 있습니다.  즉, 1 개의 신디사이저에게만 적용 가능하거나 같은 벤더제의 복수의 모델의 신디사이저에 적용 가능해 있기도 합니다. 이 비호환성은, 2 개(살)이 다른 신디사이저로 다른 사운드 합성 기술을 사용하는 경우, 또는 기본적인 기술은 같아도 내부 알고리즘이나 내부 파라미터가 다른 경우에 발생합니다. 합성 기술의 세부는 독자성이 강한 일이 많기 때문에, 비호환성의 문제는 자주(잘) 발생합니다. Java Sound API 에는, 어느 신디사이저가 있는 인스트르먼트를 지원하고 있을지 어떨지를 조사할 방법이 준비되어 있습니다.  </p>
<p><a name="121753"> </a> 인스트르먼트는, 일반적으로, pre-set 되고 있는 것으로 간주할 수가 있기 (위해)때문에, 그 인스트르먼트의 소리를 작성하기 위한 합성 기술의 세부까지 알 필요는 없습니다. 그러나, 인스트르먼트의 소리를 여러가지 변화시킬 수 있습니다. 노트 온 메세지는, 각 노트의 피치와 볼륨을 지정합니다. 또, 콘트롤러 메세지나 시스템 전용 메세지 등, 다른 MIDI 커멘드를 사용해 사운드를 변경할 수도 있습니다.  
</p><a name="121755"> </a> 
<h4> 채널</h4>
<p><a name="121759"> </a> 많은 신디사이저는, 동시에 복수가 다른 인스트르먼트의 노트를 재생할 수 있다고 하는 의미로, 「마르치틴바 (multimbral)」또는 「포리틴바 (polytimbral)」라고 불립니다. <em></em><em></em>( 「음색 (timbre)」이란, 그것에 의해 청자가 악기의 소리를 다른 악기의 소리와 구별할 수 있는, 특징적인 소리의 성질입니다. <em></em>마르치틴바신세사이자는, 한 번에 1 개의 인스트르먼트 만이 아니고, 열매 세계의 악기 전체의 앙상블을 에뮤레이트 할 수 있습니다. MIDI 신디사이저는 일반적으로, 복수가 다른 MIDI 채널을 이용하는 것으로써 이 기능을 구현하고 있습니다. MIDI 채널은, MIDI 스펙에 의해 데이터의 송신이 허가되고 있는 채널입니다. 이 경우, 신디사이저는 실제는 복수의 음원 유니트의 집합이며, 각 유니트는 다른 인스트르먼트를 에뮤레이트 해, 다른 MIDI 채널로부터 받은 메세지에 개별적으로 응답합니다. MIDI 스펙으로 제공되는 채널의 수는 16 이므로, 일반적인 MIDI 신디사이저에서는 16 종류까지가 다른 인스트르먼트를 동시에 연주할 수 있습니다. 신디사이저는 MIDI 커멘드군의 스트림을 받습니다. 커멘드군의 상당수는 채널 커멘드입니다(채널 커멘드는, 특정의 MIDI 채널을 대상으로 하는 것. 자세한 것은, MIDI 스펙을 참조). 신디사이저가 마르치틴바의 경우는, 각각의 채널 커멘드를, 커멘드에 나타난 채널 번호에 따라 적정한 음원 유니트에 배송합니다.  
</p><p><a name="121761"> </a> Java Sound API 에서는, 이러한 음원 유니트는,<code>MidiChannel</code> 인터페이스를 구현하는 클래스의 인스턴스입니다. <code>synthesizer</code> 객체에는, 적어도 1 개의 <code>MidiChannel</code> 객체가 있습니다. 신디사이저가 마르치틴바의 경우는, 이 객체는 복수 (일반적으로은 16)입니다. 각각의 <code>MidiChannel</code> 는, 다른 음원 유니트를 나타냅니다.  
</p>
<p><a name="121763"> </a> 신디사이저의 <code>MidiChannel</code> 객체에는 다소 독자성이 있기 (위해)때문에, 모든 채널에 다른 인스트르먼트를 할당할 필요는 없습니다. 예를 들어, 16 대의 피아노의 앙상블과 같이, 16 채널의 모두에게 피아노의 음색을 재생시켜도 상관하지 않습니다. 예를 들어, 채널 1, 5, 8 이 기타, 채널 2 로 3 이 퍼크션, 채널 12 가 베이스의 음색을 재생한다고 하는 것처럼, 그룹 나누고 하는 일도 가능합니다. 특정의 MIDI 채널로 재생되고 있는 인스트르먼트를 동적으로 변경할 수도 있습니다. 이것은, 「프로그램 체인지 (program change)」라고 불립니다. <em></em> </p>
<p><a name="121765"> </a> 대부분의 신디사이저에서는, 지정 시간내에 액티브하게 할 수 있는 인스트르먼트의 수는 16 이하입니다만, 일반적으로는, 좀 더 많이 제공되고 있는 인스트르먼트중에서 선택해, 필요에 따라서 특정의 채널에 할당할 수가 있습니다.  
</p><a name="121767"> </a> 
<h4> 사운드 뱅크와 패치</h4>
<p><a name="121769"> </a> 인스트르먼트는 신디사이저 중(안)에서 계층적으로 편성되고 있습니다. 제 8 장<a href="chapter8.html">「MIDI 패키지의 개요」</a>로 설명한 것처럼, 인스트르먼트는 뱅크 번호와 프로그램 번호에 의해 배열되고 있습니다. 뱅크와 프로그램은, 2 차원의 인스트르먼트테이불의 행으로 열이라고 생각할 수가 있습니다. 뱅크는 프로그램의 집합입니다. MIDI 스펙에서는, 1 개의 뱅크에 128 까지의 프로그램을 허가하고 있어, 128 까지의 뱅크를 허가하고 있습니다. 다만, 신디사이저에 따라서는, 1 개(살)만 또는 소수의 뱅크 밖에 지원하지 않는 경우나, 1 개의 뱅크에서 지원되는 프로그램의 수가 128 보다 적은 경우도 있습니다.  </p>
<p><a name="121771"> </a> Java Sound API 에서는, 그 계층 구조의 것에 한층 더 상위의 레벨이 있습니다. 그것을 사운드 뱅크라고 부릅니다. 사운드 뱅크에는 128 까지의 뱅크를 수용할 수 있어 각각 128 까지의 인스트르먼트가 포함됩니다. 사운드 뱅크 전체를 메모리에 로드할 수 있는 신디사이저도 있습니다.  
</p>
<p><a name="121773"> </a> 현재의 사운드 뱅크로부터 인스트르먼트를 1 개 선택하려면 , 뱅크 번호와 프로그램 번호를 지정합니다. MIDI 스펙에서는, 이것을 2 개의 MIDI 커멘드, bank-select 와 program-change 를 사용해 실시합니다. Java Sound API 에서는, 뱅크 번호와 프로그램 번호의 편성은, <code>Patch</code> 객체에 캡슐화되고 있습니다. MIDI 채널의 현재의 인스트르먼트를 변경하려면 , 새로운 패치를 지정합니다. 패치는, 현재의 사운드 뱅크내에 있는 인스트르먼트의 2 차원 인덱스라고 생각할 수가 있습니다.  </p>
<p><a name="121775"> </a> 사운드 뱅크도 또, 수치에 의해 인덱스를 붙일 수 있고 있다고 생각될지도 모릅니다만, MIDI 스펙은, 이것에 대응하고 있습니다. Java Sound API 에서는,<code>Soundbank</code> 객체는 사운드 뱅크 파일을 읽어들이는 것에 의해 가져옵니다. 신디사이저가 사운드 뱅크를 지원하고 있는 경우는, 인스트르먼트를 신디사이저에 필요에 따라서 개별적으로 로드하는 일도, 한 번에 모두 로드할 수도 있습니다. 많은 신디사이저에는 디폴트의 편입 사운드 뱅크가 있습니다. 이 사운드 뱅크에 포함되는 인스트르먼트는 신디사이저로부터 언제라도 이용할 수 있습니다.  
</p><a name="121777"> </a> 
<h4> 음성</h4>
<p><a name="121779"> </a> 신디사이저를 동시에 재생할 수 있는 「음색」의 수와 「노트」의 수를 구별하는 것은 중요합니다. <em></em><em></em>음색에 대해서는, 벌써 「채널」로 설명했습니다. 동시에 복수의 노트를 재생하는 능력을 「다음」이라고 부릅니다. <em></em>마르치틴바가 아닌 신디사이저에서도, 일반적으로는 복수의 노트 (모든 것이 같은 음색으로, 피치가 다르다)를 동시에 연주할 수가 있습니다. 예를 들어, G 메이저 3 이나 B 마이너 7 과 같은 코드를 연주하려면 , 다음이 필요합니다. 리얼타임에 사운드를 생성하는 신디사이저에는, 동시에 합성할 수 있는 노트의 수에 제한이 있습니다. Java Sound API 에서는, 신디사이저의 이 제한은 <code>getMaxPolyphony</code> 메소드에 의해 보고됩니다.  </p>
<p><a name="121783"> </a> 「음성 (voice)」이란, 단일의 노트가 연속한 것으로, 예를 들어, 1 명이 노래할 수 있는 멜로디 등입니다. <em></em>다음은, 합창단이 노래하는 각 파트와 같은 복수의 음성으로 구성됩니다. 예를 들어 32 음성의 신디사이저는 동시에 32 의 노트를 연주할 수 있습니다. 다만, MIDI 의 문헌의 일부에서는, 「음성」이라고 하는 용어는 「인스트르먼트 (instrument)」나 「음색 (timbre)」이라고 닮은, 이것과 다른 의미로 사용되고 있습니다.
</p><p><a name="121785"> </a> 착신의 MIDI 노트를 특정의 음성에 할당하는 처리는, 「음성 어로케이션」이라고 불립니다. <em></em>신디사이저는 음성의 리스트를 보관 유지하고 있어, 어느 음성이 액티브 (현재 나와 있는 소리가 있다)인지를 추적합니다. 노트의 소리가 울어 그치면(자), 음성은 액티브하지 않게 됩니다. 즉, 신디사이저가 받는 요구로, 다음의 노트를 받아들일 수가 있습니다. MIDI 커멘드군의 착신 스트림이, 신디사이저를 생성할 수 있는 것보다도 많은 노트를 동시에 요구하는 것은 자주 있습니다. 신디사이저의 모든 음성이 액티브한 때는, 다음의 노트 온 요구를 어떻게 처리해야 할까요. 신디사이저에는, 다양한 기법을 구현할 수가 있습니다. 무엇보다 새롭게 요구된 노트를 무시하거나 가장 낡게 개시된 노트 등, 다른 노트를 중단하는 것에 의해 다음의 노트를 연주하거나 할 수가 있습니다.
</p><p><a name="121787"> </a> MIDI 스펙에서는 요구되고 있지 않습니다만, 신디사이저는 개개의 음성의 내용을 공개할 수가 있습니다. Java Sound API 에는, 이 목적을 위해서(때문에) <code>VoiceStatus</code> 클래스가 있습니다.
</p><p><a name="121788"> </a> <code>VoiceStatus</code> 는, 음성의 현재의 액티브/비액티브 상태, MIDI 채널, 뱅크 번호와 프로그램 번호, MIDI 노트 번호, MIDI 볼륨을 보고합니다.  
</p><p><a name="121790"> </a> 다음에, 이 배경 지식을 기초로 Java Sound API 의 소리의 합성의 스펙에 대해 고찰합니다.
</p><a name="121793"> </a> 
<h3> 인스트르먼트와 사운드 뱅크의 관리</h3>
<p><a name="121795"> </a> 많은 경우, 프로그램은 대부분의 합성 API 를 명시적으로 호출하는 일 없이,<code>Synthesizer</code> 객체를 이용할 수가 있습니다. 예를 들어, 표준의 MIDI 파일을 재생하는 경우를 생각합니다. 파일을 <code>Sequence</code> 객체에 로드해, 그 객체를 재생하기 위해서 그 시퀀서로부터 데이터를 디폴트의 신디사이저에 송신시킵니다. 순서내의 데이터는 수의에 신디사이저를 제어해, 올바른 시기에 올바른 노트를 재생합니다.
</p><p><a name="121797"> </a> 그러나, 이 간단한 시나리오에서는 불충분한 경우도 있습니다. 순서에는 올바른 음악이 포함되어 있는데 인스트르먼트가 올바르게 재생되지 않는 것이 있습니다. 이 상황은, MIDI 파일의 작성자의 의도한 인스트르먼트와 현재 신디사이저에 로드 되고 있는 인스트르먼트가 다른 경우에 일어납니다.  
</p><p><a name="123339"> </a> MIDI 1.0 스펙은, bank-selsect 커멘드와 program-change 커멘드에 대해 규정하고 있습니다. 이러한 커멘드는, 각 MIDI 채널로 현재 어느 인스트르먼트를 재생중일까에 관련합니다. 다만, 이 스펙에서는, 각 패치 위치 (뱅크 번호와 프로그램 번호)에 어느 인스트르먼트를 두어야할 것인가에 대해서는 정의하고 있습니다. 최신의 General MIDI 스펙에서는, 특정의 인스트르먼트의 사운드에 대응하는 128 의 프로그램을 포함한 뱅크를 정의하는 것으로써, 이 문제에 대처하고 있습니다. General MIDI 신디사이저는, 지정된 것과 동종의 128 의 인스트르먼트를 사용합니다. 스펙의 내용이 다른 General MIDI 의 신디사이저의 재생하는 사운드는, 같은 인스트르먼트를 재생하고 있을 생각의 경우에서도, 꽤 다른 일이 있습니다. 다만, 어느 스펙으로 General MIDI 신디사이저가 파일을 재생할까에 관계없이, MIDI 파일의 대부분에 임해서, 전혀 같지 않아도, 유사한 소리가 재생되지 않으면 안됩니다.  
</p><p><a name="123341"> </a> 그럼에도 불구하고, 모든 MIDI 파일 작성자가, General MIDI 로 정의된 128 의 음색의 제한내에 파일을 작성하려고 하는 것은 아닙니다. 여기에서는, 신디사이저가 디폴트로 가지고 있는 인스트르먼트세트를 변경하는 방법을 설명합니다. 신디사이저에 디폴트가 없다고 하는 것은, 신디사이저에 액세스 했을 때에 인스트르먼트가 로드되어 있지 않은 것을 나타내므로, 반드시 최초로 이 API 를 사용합니다.  
</p><a name="121803"> </a> 
<h4> 현재 로드 되고 있는 인스트르먼트의 확인</h4>
<p><a name="121805"> </a> 신디사이저에 현재 인스트르먼트가 로드 되고 있는지 어떤지를 확인하려면 , 다음의 <code>Synthesizer</code> 메소드를 호출합니다.
</p><blockquote><pre>Instrument[] getLoadedInstruments() 
</pre></blockquote>
다음에, 반환된 배열을 반복해 조사해 현재 로드 되고 있는 인스트르먼트를 확인합니다. 많은 어플리케이션에서는, 그 인스트르먼트의 이름을 사용자 인터페이스에 표시해 (<code>Instrument</code> 의 <code>getName</code> 메소드를 사용), 그 인스트르먼트를 사용할까 다른 인스트르먼트를 로드할지 어떨지를 사용자에게 확인합니다. <code>Instrument</code> API 에는, 인스트르먼트가 속하고 있는 사운드 뱅크를 보고하는 메소드가 있습니다. 사운드 뱅크의 이름은, 프로그램 또는 사용자가 인스트르먼트의 종류를 확인하는데 도움이 됩니다.
<p></p><p><a name="123382"> </a> 다음의 <code>Synthesizer</code> 메소드에 의해, 디폴트의 사운드 뱅크를 얻을 수 있습니다.
<blockquote><pre>Soundbank getDefaultSoundbank() 
</pre></blockquote>
<code>Soundbank</code> API 에는, 사운드 뱅크의 이름, 벤더, 버젼 번호를 검색하기 위한 메소드가 있어, 이것에 의해 프로그램 또는 사용자는 뱅크를 식별할 수가 있습니다. 다만, 그 신디사이저를 시작해 사용할 때는, 디폴트의 사운드 뱅크로부터 신디사이저에 인스트르먼트가 로드 되고 있는 것을 전제로 할 수 없습니다. 예를 들어, 어느 신디사이저에는 다종 다양한 편입 인스트르먼트가 준비되어 있어도, 메모리의 제약에 의해, 자동적으로는 로드 되지 않을 가능성도 있습니다.
<p></p><a name="121824"> </a> 
<h4> 다른 인스트르먼트의 로드</h4>
<p><a name="122802"> </a> 사용자의 결정에 의해, 현재 로드 되고 있는 것과는 다른 인스트르먼트를 로드하는 경우가 있습니다 (프로그램이 결정되는 경우도 있습니다). 다음의 메소드를 사용해, 신디사이저에 짜넣어지고 있는 (사운드 뱅크 파일로부터 로드할 필요가 없다) 인스트르먼트를 확인합니다.
<blockquote><pre>Instrument[] getAvailableInstruments()
</pre></blockquote>
이러한 인스트르먼트를 로드하려면 , 다음의 메소드를 호출합니다.
<blockquote><pre>boolean loadInstrument(Instrument instrument) 
</pre></blockquote>
이 인스트르먼트가 로드 되는 신디사이저내의 위치는, 그 인스트르먼트의 <code>Patch</code> 객체 (<code>Instrument</code> 의 <code>getPatch</code> 메소드에 의해 검색)로 지정됩니다.
<p></p><p><a name="121836"> </a> 다른 사운드 뱅크로부터 인스트르먼트를 로드하려면 , 우선,<code>Synthesizer</code> 의 <code>isSupportedSoundbank</code> 메소드를 호출해, 그 사운드 뱅크가 그 신디사이저에 대응할지 어떨지를 확인합니다. 대응하지 않는 경우는, 시스템내외의 신디사이저에 대해 반복해 조사해 그 사운드 뱅크를 지원하는 것을 찾습니다. 그 후, 다음의 어느 쪽인가의 메소드를 호출해, 사운드 뱅크로부터 인스트르먼트를 로드합니다.
<blockquote><pre>
boolean loadAllInstruments(Soundbank soundbank) 
boolean loadInstruments(Soundbank soundbank, 
  Patch[] patchList) 
</pre></blockquote>
이름이 가리키도록(듯이), 최초의 메소드는 지정된 사운드 뱅크로부터 모든 인스트르먼트를 로드해, 다음의 메소드는 지정된 인스트르먼트를 사운드 뱅크로부터 로드합니다. 또,<code>Soundbank</code> 의 <code>getInstruments</code> 메소드를 사용해 모든 인스트르먼트에 액세스 하고 나서,<code>loadInstrument</code> 를 사용해 1 개(살)씩 인스트르먼트를 선택해 로드할 수도 있습니다.
<p></p><p><a name="121843"> </a> 로드궥귡인스트르먼트가 모두 같은 사운드 뱅크에 속할 필요는 없습니다. <code>loadInstrument</code> 또는 <code>loadInstruments</code> 를 사용해, 어느 사운드 뱅크로부터 특정의 인스트르먼트의 조를 로드해, 다른 사운드 뱅크로부터 다른 인스트르먼트의 조를 로드해, 이하와 같이  다른 뱅크로부터도 로드할 수가 있습니다.
</p><p><a name="121846"> </a> 각 인스트르먼트에는, 그 인스트르먼트를 로드 해야 할 신디사이저내의 위치를 지정하는 <code>Patch</code> 객체가 있습니다. 위치는, 뱅크 번호와 프로그램 번호에 의해 정의됩니다. 위치를 변경하기 위해서 패치의 뱅크 번호 또는 프로그램 번호를 변경하는 API 는 없습니다.
</p><p><a name="121852"> </a> 다만, 어느 인스트르먼트를, 패치로 지정된 위치 이외에 로드하는 것은 가능해, 거기에는 다음의 <code>Synthesizer</code> 메소드를 사용합니다.
<blockquote><pre>boolean remapInstrument(Instrument from, Instrument to) 
</pre></blockquote>
이 메소드는, 신디사이저로부터 제 1 인수의 인스트르먼트를 언로드해, 제 1 인수의 인스트르먼트에 의해 차지할 수 있고 있던 패치 위치에 제 2 인수의 인스트르먼트를 로드합니다.  
<p></p><a name="121858"> </a> 
<h4> 인스트르먼트의 언로드</h4>
<p><a name="123434"> </a> 어느 프로그램 위치에 인스트르먼트를 로드하면(자), 그 위치에 먼저 로드 되고 있던 인스트르먼트는 자동적으로 언로드됩니다. 새로운 인스트르먼트에 자동적으로 옮겨놓지 말고, 명시적으로 인스트르먼트를 언로드할 수도 있습니다. <code>Synthesizer</code> 에는, 3 개의 로드 메소드에 대응하는 3 개의 언로드 메소드가 있습니다. 신디사이저가 프로그램 체인지 메세지를 받아들였을 때에, 그 메세지가 현재 인스트르먼트가 로드되어 있지 않은 프로그램 위치를 선택하고 있었을 경우는, 그 메세지가 송신된 MIDI 채널로부터는 사운드는 재생되지 않습니다.  
</p><a name="123435"> </a> 
<h4> 사운드 뱅크 자원에의 액세스</h4>
<p><a name="123439"> </a> 일부의 신디사이저는, 인스트르먼트에 속하는 그 외의 정보를 사운드 뱅크에 보존합니다. 예를 들어, Wavetable 신디사이저는, 1 개(살) 또는 복수의 인스트르먼트로부터 액세스 가능한 오디오 샘플을 보존합니다. 샘플은 복수의 인스트르먼트에 의해 공유되는 경우가 있으므로, 어느 인스트르먼트로부터도 독립해 사운드 뱅크에 보존됩니다. <code>Soundbank</code> 인터페이스와 <code>Instrument</code> 클래스의 어느 쪽에도,<code>getSoundbankResources</code> 를 호출하는 메소드가 제공되고 있습니다. 이 메소드에 의해,<code>SoundbankResource</code> 객체의 리스트가 돌려주어집니다. 이러한 객체의 세부는, 그 사운드 뱅크가 설계되고 있는 신디사이저에 고유하게 설정됩니다. Wavetable 합성에서는, 자원이, 1 개의 녹음의 단편으로부터 취득한 일련의 오디오 샘플을 포함한 객체인 경우가 있습니다. 다른 합성 기술을 사용하는 신디사이저에서는, 종류가 다른 객체는 신디사이저의 <code>SoundbankResources</code> 배열에 보존되는 경우가 있습니다.  
</p><a name="123441"> </a> 
<h3> 신디사이저의 기능과 현재의 상태의 문의</h3>
<p><a name="121873"> </a> <code>Synthesizer</code> 인터페이스에는, 신디사이저의 기능에 관한 정보를 돌려주는 메소드가 있습니다.
</p><blockquote><pre>    public long getLatency()
    public int getMaxPolyphony()
</pre></blockquote>
대기 시간 (latency)은, MIDI 메세지가 신디사이저에 배송될 때 각과 신디사이저가 거기에 대응하는 결과를 실제로 작성할 때 각과의 사이의 최악의 경우의 지연을 나타냅니다. 예를 들어, 어느 신디사이저에서는 노트 온 이벤트를 수신하고 나서 오디오를 생성하기까지 수밀리 세컨드를 필요로 합니다.
<p></p>
<p><a name="121880"> </a> <code>getMaxPolyphony</code> 메소드는, 그 신디사이저를 동시에 재생할 수 있는 노트의 수를 나타냅니다. 이것에 대해서는, 이 장의<a href="chapter12.html#121742">「MIDI 합성에 대하며」</a>의<a href="chapter12.html#121777">「음성」</a>으로 설명했습니다. 또, 벌써 설명한 것처럼, 신디사이저는 음성의 정보를 제공할 수가 있습니다. 이것을 실시하려면 , 다음의 메소드를 사용합니다.  
<blockquote><pre>
public VoiceStatus[] getVoiceStatus()
</pre></blockquote>
반환된 배열내의 각 <code>VoiceStatus</code> 는, 음성의 현재의 액티브/비액티브 상태, MIDI 채널, 뱅크 번호와 프로그램 번호, MIDI 노트 번호, MIDI 볼륨을 보고합니다. 일반적으로, 배열의 길이는 <code>getMaxPolyphony</code> 에 의해 반환되는 값과 같습니다. 신디사이저가 연주중이 아닌 경우는, 모든 <code>VoiceStatus</code> 객체의 액티브 상태 필드는,<code>false</code> 로 설정되어 있습니다.  
<p></p><p><a name="121886"> </a> 신디사이저의 현재의 상태에 대해,<code>MidiChannel</code> 객체를 검색해 그 상태를 문의해, 상태에 대한 부가 정보를 입수할 수가 있습니다. 이 기능에 대해서는, 다음의 마디로 한층 더 자세하게 설명합니다.
</p><a name="121890"> </a> 
<h3> 채널의 사용 방법</h3>
<p><a name="121892"> </a> 신디사이저의 <code>MidiChannel</code> 객체에 직접 액세스 하는 것이 편리한 경우나, 직접 액세스가 필요하게 되는 경우가 있습니다. 여기에서는, 그러한 경우에 대해 설명합니다.
</p><a name="121894"> </a> 
<h4> 시퀀서를 사용하지 않고 신디사이저를 제어하는 방법</h4>
<p><a name="121896"> </a> 순서 (MIDI 파일로부터 읽어낸 것 등)를 사용할 때는, 신디사이저에 MIDI 커멘드를 보낼 필요는 없습니다. 단지 그 순서를 시퀀서에 로드해, 시퀀서를 신디사이저에 접속해 실행시킬 뿐입니다. 이벤트의 스케줄링은 시퀀서가 처리해, 그 결과는 예측할 수 있는 음악 연주가 됩니다. 이것은, 갖고 싶은 음악이 사전 갑작스럽다고 있어, 음악을 파일로부터 읽어들이는 경우에 적절하고 있습니다.
</p><p><a name="121898"> </a> 다만, 연주의 진행중에 음악이 생성되는 경우도 있습니다. 예를 들어, 사용자 인터페이스에 음악용의 키보드나 기타의 후렛트보드가 표시되어 사용자가 마우스를 클릭해 자유롭게 노트를 재생시키는 경우가 있습니다. 또, 어플리케이션이, 음악을 연주하기 위해서는 아니고, 사용자의 동작에 응답해 사운드 효과를 생성하기 위해서 신디사이저를 사용하는 일이 있습니다. 이것은, 게임에서 일반적으로 사용되는 방법입니다. 또, 어플리케이션이 파일로부터 읽어들인 음악을 연주하고 있을 때, 사용자가 사용자 인터페이스로부터 대화 형식에서 동적으로 그 음악을 변경할 수 있도록(듯이) 하는 경우도 있습니다. 어느 경우에서도, MIDI 메세지는 장래가 정해진 시점에 스케줄 되는 것이 아니라, 즉시 배송될 필요가 있으므로, 어플리케이션은 신디사이저에 직접 커멘드를 보냅니다.
</p><p><a name="121900"> </a> 시퀀서를 사용하지 않고 MIDI 메세지를 보내는 방법은, 적어도 2 개 있습니다. 1 개(살)은,<code>MidiMessage</code> 를 구축해,<code>Receiver</code> 의 메소드를 사용해 신디사이저에 건네주는 방법입니다. 예를 들어, 중앙 C (MIDI 노트 넘버 60)를 MIDI 채널 5 (one-based)에 즉시 생성하려면 , 다음과 같이 합니다.
<blockquote><pre>    ShortMessage myMsg = new ShortMessage();
    // Play the note Middle C (60) moderately loud
    // (velocity = 93) on channel 4 (zero-based).
    myMsg.setMessage(ShortMessage.NOTE_ON, 4, 60, 93); 
    Synthesizer synth = MidiSystem.getSynthesizer();
    Receiver synthRcvr = synth.getReceiver();
    synthRcvr.send(myMsg, -1); // -1 means no time stamp
</pre></blockquote>
2 번째는, message-passing 층 (<code>MidiMessage</code> 와 <code>Receiver</code> API)을 양쪽 모두 우회도로 해, 신디사이저의 <code>MidiChannel</code> 객체와 직접 대화하는 방법입니다. 우선, 다음의 <code>Synthesizer</code> 메소드를 사용해 신디사이저의 <code>MidiChannel</code> 객체를 검색합니다.
<blockquote><pre>public MidiChannel[] getChannels()
</pre></blockquote>
다음에, 목적의 <code>MidiChannel</code> 메소드를 직접 호출합니다. 이것은, 대응하는 <code>MidiMessages</code> 를 신디사이저의 <code>Receiver</code> 에 보내, 신디사이저에 자신의 <code> MidiChannels</code> 를 사용해 통신을 처리시키는 것보다도, 보다 직접적인 방법입니다. 예를 들어, 전의 예에 대응하는 코드는 다음과 같이 됩니다.  
<blockquote><pre>
    Synthesizer synth = MidiSystem.getSynthesizer();
    MidiChannel chan[] = synth.getChannels(); 
    // Check for null; maybe not all 16 channels exist.
    if (chan[4] ! = null) {
         chan[4]. noteOn(60, 93); 
    }
</pre></blockquote><a name="121937"> </a> 
<h4> 채널의 현재 상태의 취득</h4>
<p><a name="121939"> </a> <code>MidiChannel</code> 인터페이스에는, MIDI 스펙으로 정해져 있는 「채널 음성」과「채널 모드」메세지에 1 대 1 으로 대응하는 메소드가 있습니다. noteOn 메소드의 사용 방법에 대해서는, 전술의 예로 설명했습니다. 이러한 표준 메소드 외에, Java Sound API 의 <code>MidiChannel</code> 인터페이스에는, 대응하는 음성 또는 모드의 "set" 메소드로 설정된 최신의 값을 검색하는 "get" 메소드가 추가되고 있습니다.
<blockquote>
  <pre>
    int       getChannelPressure()
    int       getController(int controller)
    boolean   getMono()
    boolean   getOmni() 
    int	      getPitchBend() 
    int	      getPolyPressure(int noteNumber)
    int	      getProgram()
</pre>
</blockquote>
이러한 메소드는 사용자에게 채널 상태를 표시하거나 계속되어 채널에 보내는 값을 결정하는 경우에 이용할 수 있습니다.
<p></p><a name="121953"> </a> 
<h4> 채널의 뮤트와 솔로</h4>
<p><a name="123492"> </a> MIDI 스펙에서는 요구되고 있지 않습니다만, Java Sound API 는, 채널 마다 솔로와 뮤트의 개념을 추가합니다. 이러한 개념은, MIDI 순서의 트럭상의 뮤트와 솔로를 닮아 있습니다. 제 11 장 「MIDI 순서의 재생, 기록, 및 편집」의 「순서내의 개별의 트럭의 뮤트 또는 솔로 기능」을 참조해 주세요.
</p><p><a name="123493"> </a> 뮤트가 온의 경우는, 이 채널은 무음이 됩니다만, 다른 채널에는 영향을 주지 않습니다. 솔로가 온의 경우는, 이 채널 및 솔로가 온이 되어 있는 것 외의 채널이 연주됩니다만 (뮤트 되고 있는 경우를 제외하다), 다른 채널은 무음이 됩니다. 솔로와 뮤트의 양쪽 모두가 온이 되어 있는 채널은 무음이 됩니다. <code>MidiChannel</code> API 에는, 다음의 4 개의 메소드가 있습니다.
</p><blockquote><pre>
    boolean	 getMute() 
    boolean	 getSolo()
    void	 setMute(boolean muteState) 
    void	 setSolo(boolean soloState)
</pre></blockquote><a name="121964"> </a> 
<h3> 합성음의 재생의 액세스권</h3>
<p><a name="123505"> </a> 인스톨 되고 있는 MIDI 신디사이저에 의해 생성되는 오디오는, 일반적으로 샘플링 오디오 시스템을 개입시켜 배송됩니다. 프로그램이 오디오 재생의 액세스권을 가지고 있지 않은 경우는, 신디사이저의 사운드를 (들)물을 수 없습니다. 이 경우, 시큐리티 예외가 throw 됩니다. 오디오의 액세스권의 자세한 것은, 제 3 장<a href="chapter3.html">「오디오 system resource에의 액세스」</a>의<a href="chapter3.html#113223">「오디오 자원을 사용하기 위한 액세스권」</a>을 참조해 주세요.  </p>
<p><a name="121968"> </a>  </p>
</body>
</html>
