<HTML>
<HEAD>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">

<title>Collections Framework 의 개요의 주석 - xrath.com 에서 번역됨</title>
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>

<TABLE summary="layout" BORDER="0" WIDTH="100%">
<TR>
<TD WIDTH=60>
<IMG SRC="../../../images/javalogo52x88.gif" ALT="Java" BORDER=0 WIDTH=52 HEIGHT=88>
</TD>

<TD>
<center>
<h1>Collections Framework 의 개요의 주석</h1>
</center>
</TD>

</TR>
</TABLE>

<!-- Body text begins here --> Collections Framework 는 이하의 요소로 구성됩니다.
<ul>
<li><strong>컬렉션 인터페이스</strong>- 컬렉션을 조작하는 주요한 수단
<ul>
<li><a href="../../../api/java/util/Collection.html"><strong>Collection</strong></a>  - 객체의 그룹. 컬렉션의 순서부 및 중복 하는 요소를 포함하고 있는지 어떤지에 대해서는 아무것도 고려하지 않는다

<li><a href="../../../api/java/util/Set.html"><strong>Set</strong></a>  - 자주(잘) 사용되는, 세트의 추상화. 요소의 중복은 허가되지 않는다. 순서부는 되고 있어도, 없어도 좋다. <tt>Collection</tt> 인터페이스를 확장한다

<li><a href="../../../api/java/util/List.html"><strong>List</strong></a>  - 순서 붙이고 된 컬렉션.  「순서」라고도 불린다. 일반적으로 중복은 허가된다. 위치에 의한 액세스를 허가한다. <tt>Collection</tt> 인터페이스를 확장한다

<li><a href="../../../api/java/util/Queue.html"><strong>Queue</strong></a>  - 처리를 실시하기 전에 요소를 보관 유지하기 위해서 설계된 컬렉션. 기본적인 <tt>Collection</tt> 조작 뿐만이 아니라, 큐는 추가적인 삽입, 예외 처리 및 검사라고 하는 조작을 제공한다

<li><a href="../../../api/java/util/Deque.html"><strong>Deque</strong></a>  - 이중 끝 큐. 양단에서의 요소의 삽입과 삭제를 지원합니다. <em></em><tt>Queue</tt> 인터페이스를 확장합니다.

<li><a href="../../../api/java/util/Map.html"><strong>Map</strong></a>  - 키로부터 값에의 매핑. 각 키를 1 개의 값에 매핑 할 수 있다

<li><a href="../../../api/java/util/SortedSet.html"><strong>SortedSet</strong></a>  - 「자연 순서」(<a href="../../../api/java/lang/Comparable.html"><tt>Comparable</tt></a>  인터페이스를 참조)에 의해, 또는 <tt>SortedSet</tt> 의 인스턴스의 생성시에 제공되는 <a href="../../../api/java/util/Comparator.html"><tt>Comparator</tt></a>  객체에 의해, 자동적으로 소트 되는 요소세트. <i></i>Set</tt> 인터페이스를 확장한다

<li><a href="../../../api/java/util/SortedMap.html"><strong>SortedMap</strong></a>  - 매핑이 키에 의해 자동적으로 소트 되는 맵.  소트는, 키의 「자연 순서」, 또는 <tt>SortedMap</tt> 의 인스턴스의 생성시에 제공되는 Comparator 에 의해 행해진다. <tt><tt>Map</tt> 인터페이스를 확장한다

<li><a href="../../../api/java/util/NavigableSet.html"><strong>NavigableSet</strong></a>  - 지정의 검색 타겟으로 가장 가까운 일치 내용을 보고하는 네비게이션 메소드로 확장된 <tt>SortedSet</tt>. 승순 또는 내림차순으로,<tt>NavigableSet</tt> 에 액세스 하거나<tt>NavigableSet</tt> 를 횡단(traverse) 하거나 할 수 있습니다.

<li><a href="../../../api/java/util/NavigableMap.html"><strong>NavigableMap</strong></a>  - 지정의 검색 타겟으로 가장 가까운 일치 내용을 돌려주는 네비게이션 메소드로 확장된 <tt>SortedMap</tt>. 승순 또는 내림차순의 키 순서로,<tt>NavigableMap</tt> 가 액세스 하거나 횡단(traverse) 하거나 할 수 있습니다.

<li><a href="../../../api/java/util/concurrent/BlockingQueue.html"><strong>BlockingQueue</strong></a>  - 요소를 꺼낼 때, 큐가 비우지 않기 위해(때문에) 대기하는 조작으로 사용하는 <tt>Queue</tt>. (이 인터페이스는,<tt><a href="../../../api/java/util/concurrent/package-summary.html">java.util.concurrent</a> </tt> 의 일부).

<li><a href="../../../api/java/util/concurrent/BlockingDeque.html"><strong>BlockingDeque</strong></a>  - 요소를 꺼낼 때, deque 가 빈 상태(empty)이 아니게 될 때까지 대기하거나 요소를 소트 할 경우에 deque 로 스페이스를 이용할 수 있게 될 때까지 대기하는 조작을 실시하는 <tt>Deque</tt>. <tt>Deque</tt> 및 <tt>BlockingQueue</tt> 인터페이스를 확장합니다

(이 인터페이스는,<tt><a href="../../../api/java/util/concurrent/package-summary.html">java.util.concurrent</a> </tt> 의 일부).

<li><a href="../../../api/java/util/concurrent/ConcurrentMap.html"><strong>ConcurrentMap</strong></a>  - 기본 메소드,<tt>putIfAbsent</tt>,<tt>remove</tt>, 및 <tt>replace</tt> 를 사용하는 <tt>Map</tt> (이 인터페이스는,<tt>java.util.concurrent</tt> 의 일부).

<li><a href="../../../api/java/util/concurrent/ConcurrentNavigableMap.html"><strong>ConcurrentNavigableMap</strong></a>  - <tt>NavigableMap</tt> 이기도 한 <tt>ConcurrentMap</tt>.

</ul>

<li><strong>범용의 구현</strong> - 컬렉션 인터페이스의 주구현

<ul>

<li><strong><a href="../../../api/java/util/HashSet.html">HashSet</a> </strong> - <tt>Set</tt> 인터페이스의 해시 테이블 구현. Set</tt> 인터페이스의, 가장 용도의 넓은 구현

<li>
<a href="../../../api/java/util/TreeSet.html"><strong>TreeSet</strong></a>  - <tt>NavigableSet</tt> 인터페이스의 적 - 흑트리 구현

<li><strong><a href="../../../api/java/util/LinkedHashSet.html">LinkedHashSet</a> </strong> - <tt>Set</tt> 인터페이스의 해시 테이블과 링크 리스트 구현. <tt>HashSet</tt> 와 동등의 실행 속도를 가지는, 삽입순서 <tt>Set</tt> 구현

<li><strong><a href="../../../api/java/util/ArrayList.html">ArrayList</a> </strong> - <tt>List</tt> 인터페이스의 사이즈 변경 가능한 배열 구현(본래, 동기를 잡지 않는 <tt>Vector</tt>). List</tt> 인터페이스의 가장 용도의 넓은 구현

<li><strong><a href="../../../api/java/util/ArrayDeque.html">ArrayDeque</a> </strong> -

<tt>Deque</tt> 인터페이스의 사이즈 변경이 가능한 효율적 배열의 구현.

<li>
<a href="../../../api/java/util/LinkedList.html"><strong>LinkedList</strong></a>  - <tt>List</tt> 인터페이스의, 더블 링크 리스트 구현. 요소가 리스트내에서 빈번하게 삽입 혹은 삭제되는 경우에는,<tt>ArrayList</tt> 보다 높은 퍼포먼스를 발휘하는 일이 있다. 또,<tt>Deque</tt> 인터페이스를 구현합니다. Queue</tt> 인터페이스를 개입시켜 액세스 되었을 경우,<tt>LinkedList</tt> 는 FIFO 큐로서 동작한다

<li><strong><a href="../../../api/java/util/PriorityQueue.html">PriorityQueue</a> </strong> - 안 바운드 형식의 우선도 큐의 heap 구현

<li><strong><a href="../../../api/java/util/HashMap.html">HashMap</a> </strong> - <tt>Map</tt> 인터페이스의 해시 테이블 구현(본래,<tt>null</tt> 키 및 값을 지원하는, 동기를 잡지 않는 <tt>Hashtable</tt>). <tt>Map</tt> 인터페이스의 가장 용도의 넓은 구현

<li>
<a href="../../../api/java/util/TreeMap.html"><strong>TreeMap</strong></a>  - <tt>NavigableMap</tt> 인터페이스의 적 - 흑트리 구현.

<li><strong><a href="../../../api/java/util/LinkedHashMap.html">LinkedHashMap</a> </strong> - <tt>Map</tt> 인터페이스의 해시 테이블과 링크 리스트 구현. 삽입순서에 실행되는 <tt>Map</tt> 구현이며,<tt>HashMap</tt> 와 같은 정도 고속으로  실행된다. 캐쉬를 구축하는 경우에도 도움이 되는 (<a href="../../../api/java/util/LinkedHashMap.html#removeEldestEntry(java.util.Map.Entry)">removeEldestEntry(Map.Entry)</a>  를 참조)

</ul>

<li><strong>래퍼 구현</strong> - 다른 구현과 병용 해 기능을 확장하기 위한 구현. static 팩토리 메소드를 개입시켜 단독으로 액세스 된다
<ul>
<li>
<a href="../../../api/java/util/Collections.html#unmodifiableCollection(java.util.Collection)"><strong>Collections.unmodifiable<i>Interface</i></strong></a>  - 사용자가 있는 컬렉션을 변경하려고 하면(자), 그 컬렉션의 변경할 수 없는 뷰를 돌려주어,<tt>UnsupportedOperationException</tt> 를 throw 한다

<li>
<a name="synchWrappers" href="../../../api/java/util/Collections.html#synchronizedCollection(java.util.Collection)"><strong>Collections.synchronized<i>Interface</i></strong></a>  - 지정된 (일반적으로는 동기를 잡지 않는다) 컬렉션에 근거하는, 동기화 된 컬렉션을 돌려준다. 기가 되는 컬렉션에의 액세스가 모두, 반환된 컬렉션을 통해 행해지는 한, thread의 안전성은 보증된다

<li>
<a href="../../../api/java/util/Collections.html#checkedCollection(java.util.Collection,%20java.lang.Class)"><strong>Collections.checked<i>Interface</i></strong></a>  - 있는 컬렉션의 동적형 보증 뷰를 돌려주어, 클라이언트가 잘못한 형태의 요소를 추가하려고 했을 경우 <tt>ClassCastException</tt> 를 throw 합니다. 언어에 있는 총칭의 기구에 의해 컴파일시에 정적인 형태 체크를 합니다만, 이 기구를 무효화하는 일도 가능. 동적형 보증 뷰는 이 가능성을 완전하게 해결한다

</ul>

<li><strong>간이 구현</strong> - 컬렉션 인터페이스의 고성능인 「미니 구현」
<ul>
<li>
<a href="../../../api/java/util/Arrays.html#asList(T...)"><strong>Arrays.asList</strong></a>  - 배열을 리스트로서 표시 가능하게 합니다.

<li><strong><a href="../../../api/java/util/Collections.html#EMPTY_SET">EMPTY_SET</a> ,<a href="../../../api/java/util/Collections.html#EMPTY_LIST">EMPTY_LIST</a>  및 <a href="../../../api/java/util/Collections.html#EMPTY_MAP">EMPTY_MAP</a> </strong> - 빈 상태(empty)세트 및 리스트를 나타내는 정수 (불변)

<li><strong><a href="../../../api/java/util/Collections.html#singleton(java.lang.Object)">singleton</a> ,<a href="../../../api/java/util/Collections.html#singletonList(java.lang.Object)">singletonList</a> , 및 <a href="../../../api/java/util/Collections.html#singletonMap(K,%20V)">singletonMap</a> </strong> - 지정된 객체 (또는 키치의 매핑)만을 포함한, 불변인 「단독」세트, 리스트, 또는 맵을 돌려줍니다.
<li>
<a href="../../../api/java/util/Collections.html#nCopies(int,%20T)"><strong>nCopies</strong></a>  - 지정된 객체의 n 개의 카피로부터 되는 불변인 리스트를 돌려줍니다.
</ul>

<li><strong>유산 구현</strong> - 이전부터 있는 컬렉션 클래스가 개량되어, 컬렉션 인터페이스를 구현하게 되었다
<ul>
<li>
<a href="../../../api/java/util/Vector.html"><strong>Vector</strong></a>  - 「유산 메소드」를 가지는 <tt>List</tt> 인터페이스의, 동기화 되어 사이즈 변경 가능한 배열 구현
<li>
<a href="../../../api/java/util/Hashtable.html"><strong>Hashtable</strong></a>  - <tt>Map</tt> 인터페이스의 동기화 된 해시 테이블 구현.  「유산 메소드」에서는,<tt>null</tt> 키 또는 <tt>null</tt> 치는 허가되지 않는다
</ul>

<li><strong>특수 목적의 구현</strong>
<ul>
<li>
<strong><a href="../../../api/java/util/WeakHashMap.html">WeakHashMap</a> </strong> -  키에의<a href="../../../api/java/lang/ref/WeakReference.html">약참조</a>만을 포함하는 <tt>Map</tt> 인터페이스의 구현. <i></i>약참조만을 포함하는 것으로써, 키가 <tt>WeakHashMap</tt> 의 외부로부터 참조되지 않게 되면(자), 키치의 페어를 가베지 컬렉트할 수가 있다. 이 클래스를 이용하면(자), 약참조를 가장 간단하게 이용할 수가 있다. 키가 어느 thread로부터도 액세스 할 수 없게 되면(자), 엔트리의 유용성이 없어지는 「레지스트리적」인 데이터 구조를 구현하는 경우에 도움이 된다

<li><strong><a href="../../../api/java/util/IdentityHashMap.html">IdentityHashMap</a> </strong> - 식별 정보 베이스의 Map 구현이며, 해시 테이블에 근거하고 있습니다. 직렬화나 딥 카피등과 같이, 위상기하학을 유지하면서 객체 그래프를 변형하는 경우에, 이 클래스는 편리합니다. 이러한 변형을 실시하려면 , 어느 객체가 표시가 끝난 상태인지를 추적하는 식별 정보 베이스의 「노드 테이블」을 보수할 필요가 있습니다. 동일성 베이스의 맵을 사용해, 동적인 디버거나 같은 시스템으로 객체와 메타 정보의 매핑을 보수할 수도 있습니다. 또, 동일성 베이스의 맵은 equals 메소드를 의도적으로 비뚤어지게 하는 것에 의해 발생하는 「부정행위」를 막는 경우에 유용합니다. (<tt>IdentityHashMap</tt> 가 키에 대해서 equals 메소드를 호출할 것은 없습니다. ) 이 구현의 이제(벌써) 1 개의 이점은, 고속이다고 하는 것입니다.

<li><strong><a href="../../../api/java/util/concurrent/CopyOnWriteArrayList.html">CopyOnWriteArrayList</a> </strong> - copy-on-write 배열을 기로 하는 <tt>List</tt> 구현. 모든 추이적 조작 (<tt>add</tt>,<tt>set</tt> 및 <tt>remove</tt> 등)은, 배열의 새로운 카피의 작성에 의해 구현된다. 반복 그 중에서 동기는 불필요하고, 반복자는 <tt>ConcurrentModificationException</tt> 를 throw 하지 않는 것이 보증된다. 이 구현은 이벤트 핸들러 리스트의 유지에 최적 (변경이 보기 드물어, traversal는 빈번하게 발생해, 시간이 걸릴 가능성이 있기 (위해)때문에)

<li><strong><a href="../../../api/java/util/concurrent/CopyOnWriteArraySet.html">CopyOnWriteArraySet</a> </strong> - copy-on-write 배열을 기로 하는 <tt>Set</tt> 구현. 이 구현은 <tt>CopyOnWriteArrayList</tt> 와 본질적으로 같습니다. 다른 대부분의 <tt>Set</tt> 구현과 달리,<tt>add</tt>,<tt>remove</tt>, 및 <tt>contains</tt> 메소드는 세트의 사이즈 에 비례하는 타임이 필요. 이 구현은, 중복을 회피할 필요가 있는 이벤트 핸들러 리스트의 유지에 최적

<li><strong><a href="../../../api/java/util/EnumSet.html">EnumSet</a> </strong> - bit-vector 를 기로 하는 고성능의 <tt>Set</tt> 구현. 각 <tt>EnumSet</tt> 인스턴스의 모든 요소는, 단일의 열거형의 요소가 아니면 안된다

<li><strong><a href="../../../api/java/util/EnumMap.html">EnumMap</a> </strong> - 배열을 기로 하는 고성능의 <tt>Map</tt> 구현. 각 <tt>EnumMap</tt> 인스턴스의 모든 키는 단일의 열거형의 요소가 아니면 안된다
</ul>

<li><strong>병렬 구현</strong> - 이러한 구현은 <tt>java.util.concurrent</tt> 의 일부입니다.
<ul>
<li><strong><a href="../../../api/java/util/concurrent/ConcurrentLinkedQueue.html">ConcurrentLinkedQueue</a> </strong> - 링크 노드에 근거하는 안 바운드 형식의 FIFO (선입선출) 큐

<li><a href="../../../api/java/util/concurrent/LinkedBlockingQueue.html"><strong>LinkedBlockingQueue</strong></a>  - 링크 노드를 기로 하는, 임의의 바운드 형식의 FIFO 블로킹 큐

<li><a href="../../../api/java/util/concurrent/ArrayBlockingQueue.html"><strong>ArrayBlockingQueue</strong></a>  - 배열을 기로 하는 바운드 형식의 FIFO 블로킹 큐

<li><a href="../../../api/java/util/concurrent/PriorityBlockingQueue.html"><strong>PriorityBlockingQueue</strong></a>  - 우선 순위 heap를 기로 하는, 안 바운드 형식의 블로킹 우선도 큐

<li><a href="../../../api/java/util/concurrent/DelayQueue.html"><strong>DelayQueue</strong></a>  - 우선 순위 heap를 기로 하는, 시간 베이스의 스케줄 큐

<li><a href="../../../api/java/util/concurrent/SynchronousQueue.html"><strong>SynchronousQueue</strong></a>  - <tt>BlockingQueue</tt> 인터페이스를 이용하는 간단한 인식 메카니즘

<li><a href="../../../api/java/util/concurrent/LinkedBlockingDeque.html"><strong>LinkedBlockingDeque</strong></a>  - 링크된 노드로 지원되어 임의에 의해 결합된 FIFO BlockingDeque.

<li><a href="../../../api/java/util/concurrent/ConcurrentHashMap.html"><strong>ConcurrentHashMap</strong></a>  - 해시 테이블에 근거하는, 고도로 병렬되어 고성능인<tt>ConcurrentMap</tt> 구현. 이 구현은 취득을 실행할 경우에 블록 하지 않고, 클라이언트가 갱신하는 동시성 처리의 레벨의 선택을 허가한다. 이것은,<tt><a href="../../../api/java/util/Hashtable.html">Hashtable</a> </tt> 에 대한 드롭 인식의 치환으로서 상정되었다. <tt>ConcurrentMap</tt> 를 구현하는 것에 가세해,<tt>Hashtable</tt> 에 고유의 모든 「유산」메소드를 지원한다

<li>
<a href="../../../api/java/util/concurrent/ConcurrentSkipListSet.html"><strong>ConcurrentSkipListSet</strong></a>  - <tt>NavigableSet</tt> 인터페이스의 스킵 리스트 구현.

<li>
<a href="../../../api/java/util/concurrent/ConcurrentSkipListMap.html"><strong>ConcurrentSkipListMap</strong></a>  - <tt>ConcurrentNavigableMap</tt> 인터페이스의 스킵 리스트 구현.

</ul>

<li>
<strong>추상 구현</strong> - 커스텀 구현을 용이하게 하는, 컬렉션 인터페이스의 골격 구현
<ul>
<li>
<a href="../../../api/java/util/AbstractCollection.html"><strong>AbstractCollection</strong></a>  - 세트도 리스트도 아닌 ( 「가방」이나 멀티 세트와 같은) <tt>Collection</tt> 의 골격 구현
<li>
<a href="../../../api/java/util/AbstractSet.html"><strong>AbstractSet</strong></a>  - <tt>Set</tt> 의 골격 구현
<li>
<a href="../../../api/java/util/AbstractList.html"><strong>AbstractList</strong></a>  - 랜덤 억세스 데이터의 포함 (배열등)을 기로 하는 <tt>List</tt> 의 골격 구현
<li>
<a href="../../../api/java/util/AbstractSequentialList.html"><strong>AbstractSequentialList</strong></a>  - 시퀸셜 액세스 데이터의 포함 (링크 설정된 리스트등)을 기로 하는 <tt>List</tt> 의 골격 구현
<li><a href="../../../api/java/util/AbstractQueue.html"><strong>AbstractQueue</strong></a>  - <tt>Queue</tt> 의 골격 구현
<li>
<a href="../../../api/java/util/AbstractMap.html"><strong>AbstractMap</strong></a>  - <tt>Map</tt> 의 골격 구현
</ul>


<li><strong>Algorithms</strong> - 이 <a href="../../../api/java/util/Collections.html"><strong>Collections</strong></a>  클래스에는, 다음의 편리한 static 메소드가 포함되어 있습니다.

<ul>
<li><strong> <a href="../../../api/java/util/Collections.html#sort(java.util.List)">sort(List)</a> </strong> - 머지 소트 알고리즘을 사용해 리스트를 소트 합니다. 이 알고리즘은, 고품질인 퀵 소트와 동일한 정도의 성능을 가집니다. 퀵 소트보다 우수한 점으로서 O(n*log n)를 보증하는 퍼포먼스와 안정성이 있습니다 <em></em>(안정된 소트는, 등가인 요소가 늘어놓고 바꾸고를 실시하지 않는다)

<li><strong> <a href="../../../api/java/util/Collections.html#binarySearch(java.util.List,%20T)"> binarySearch(List, Object)</a> </strong> - 바이너리 서치 알고리즘을 사용해 소트 된 리스트내의 요소를 검색합니다.

<li><strong><a href="../../../api/java/util/Collections.html#reverse(java.util.List)">reverse(List)</a> </strong> - 리스트내의 요소의 순서를 역전한다

<li><strong><a href="../../../api/java/util/Collections.html#shuffle(java.util.List)">shuffle(List)</a> </strong> - 리스트내의 요소를 랜덤에 늘어놓고 바꾼다

<li><strong><a href="../../../api/java/util/Collections.html#fill(java.util.List,%20T)">fill(List, Object)</a> </strong> - 리스트의 모든 요소를 지정의 값으로 덧쓰기합니다.

<li><strong><a href="../../../api/java/util/Collections.html#copy(java.util.List,%20java.util.List)">copy(List dest, List src)</a> </strong> - 원의 리스트를 행선지의 리스트에 카피한다

<li><strong> <a href="../../../api/java/util/Collections.html#min(java.util.Collection)">min(Collection)</a> </strong> - 컬렉션내의 최소 요소를 돌려준다

<li><strong> <a href="../../../api/java/util/Collections.html#max(java.util.Collection)">max(Collection)</a> </strong> - 컬렉션내의 최대 요소를 돌려준다

<li><strong><a href="../../../api/java/util/Collections.html#rotate(java.util.List,%20int)">rotate(List list, int distance)</a> </strong> - 리스트에 있는 모든 요소를, 지정한 거리만 회전 지난

<li><strong><a href="../../../api/java/util/Collections.html#replaceAll(java.util.List,%20T,%20T)">replaceAll(List list, Object oldVal, Object newVal)</a> </strong> - 지정한 값을 모두 다른 값에 옮겨놓습니다.

<li><strong><a href="../../../api/java/util/Collections.html#indexOfSubList(java.util.List,%20java.util.List)">indexOfSubList(List source, List target)</a> </strong> - 타겟과 동일한 소스의 최초의 사브리 파업의 인덱스를 돌려준다

<li><strong><a href="../../../api/java/util/Collections.html#lastIndexOfSubList(java.util.List,%20java.util.List)">lastIndexOfSubList(List source, List target)</a> </strong> - 타겟과 동일한 소스의 마지막 사브리 파업의 인덱스를 돌려준다

<li><strong><a href="../../../api/java/util/Collections.html#swap(java.util.List,%20int,%20int)">swap(List, int, int)</a> </strong> - 지정한 리스트내의 지정한 위치에 있는 요소를 스왑 한다

<li><strong><a href="../../../api/java/util/Collections.html#frequency(java.util.Collection,%20java.lang.Object)">frequency(Collection, Object)</a> </strong> - 있는 connection에 대해 지정한 요소가 발생한 회수를 계산한다

<li><strong><a href="../../../api/java/util/Collections.html#disjoint(java.util.Collection,%20java.util.Collection)">disjoint(Collection, Collection)</a> </strong> - 2 개의 컬렉션이 서로 무관계하다, 즉 일반적인 요소를 포함하지 않는지 어떤지를 판정한다

<li><strong><a href="../../../api/java/util/Collections.html#addAll(java.util.Collection,%20T...)">addAll(Collection&lt;?  super T&gt;, T...)</a> </strong> - 지정한 배열의 모든 요소를 지정한 컬렉션에 추가합니다.

<li><strong><a href="../../../api/java/util/Collections.html#newSetFromMap(java.util.Map)">newSetFromMap(Map)</a> </strong> - 범용의 <tt>Set</tt> 구현을 범용의 <tt>Map</tt> 구현으로부터 작성합니다.

<li><strong><a href="../../../api/java/util/Collections.html#asLifoQueue(java.util.Deque)">asLifoQueue(Deque)</a> </strong> - LIFO (Last in first out) <tt>큐</tt> 로서<tt>Deque</tt> 의 뷰를 돌려줍니다.

</ul>

<li><strong>인프라스트럭쳐(infrastructure)</strong>
<ul>
<li><strong>Iterators</strong> - <a href="../../../api/java/util/Enumeration.html">Enumeration</a>  인터페이스를 닮아 있지만, 보다 강력해, 메소드명이 개량되고 있다
<ul>
<li>
<a href="../../../api/java/util/Iterator.html"><strong>Iterator</strong></a>  - <tt>Enumeration</tt> 인터페이스의 기능에 가세해, 교묘하게 정의된 유용한 시멘틱스에 의해, 사용자가, 기본으로 되는 컬렉션으로부터 요소를 삭제할 수 있게 된다
<li>
<a href="../../../api/java/util/ListIterator.html"><strong>ListIterator</strong></a>  - 리스트에 대해서 사용하는 반복자. Iterator</tt> 인터페이스의 기능에 가세해, 쌍방향의 반복해, 요소의 치환, 요소의 삽입 및 인덱스의 취득을 지원한다
</ul>
<li><strong>순서 붙어라</strong>
<ul>
<li>
<a href="../../../api/java/lang/Comparable.html"><strong>Comparable</strong></a>  - 이것을 구현하는 클래스에 대해, 「자연 순서 붙이고」의 기능을 제공한다. 자연 순서부는, 리스트의 소트, 또 소트 된 세트나 맵내의 순서의 유지에 사용된다. 많은 클래스가, 이 인터페이스를 구현하기 위해서 개량되었다
<li>
<a href="../../../api/java/util/Comparator.html"><strong>Comparator</strong></a>  - 순서부의 관련을 나타내, 리스트의 소트, 또 소트 된 세트나 맵내의 순서의 유지에 사용된다. 어느 형태의 자연 순서부를 오버라이드(override) 하거나<tt>Comparable</tt> 인터페이스를 구현하고 있지 않는 형태의 객체의 순서부를 실시할 수가 있다
</ul>
<li><strong>실행시 예외</strong>
<ul>
<li><a href="../../../api/java/lang/UnsupportedOperationException.html"><strong>UnsupportedOperationException</strong></a>  -  지원하고 있지 않는 조작의 호출시에, 컬렉션에 의해 throw 된다<li><a href="../../../api/java/util/ConcurrentModificationException.html"><strong>ConcurrentModificationException</strong></a>  -  반복의 진행중에, 기본으로 되는 컬렉션에 대해서 예기치 않은 변경을 했을 경우, 반복자 및 리스트 반복자에 의해 throw 된다. 기본으로 되는 리스트에 예기치 않은 변경을 했을 경우도, 리스트의 사브리스트뷰에 의해 throw 된다
</ul>

<li><strong>퍼포먼스</strong>
<ul>
<li>
<strong><a href="../../../api/java/util/RandomAccess.html">RandomAccess</a> </strong> - <tt>List</tt> 의 구현이 고속 랜덤 억세스 (일반적으로은 일정시간)를 지원하고 있는 것을 나타내기 위한 마커 인터페이스입니다. 이것에 의해 범용 알고리즘이 랜덤 억세스 리스트 또는 차례차례 액세스 리스트의 어느 쪽인가에 적용될 때, 그 동작을 변경해 퍼포먼스를 향상할 수가 있습니다.
</ul>
</ul>

<li><strong>배열 유틸리티</strong>
<ul>
<li><a href="../../../api/java/util/Arrays.html"><strong>Arrays</strong></a>  - 프리미티브(primitive) 배열 및 객체 배열에 대해서, 소트, 검색, 비교, 해시, 카피, 사이즈 변경,<tt>String</tt> 에의 변환, 및 매입을 실시하는 static 메소드를 포함합니다.
</ul>
</ul>

<!-- Body text ends here --> <!-- ============================================================== -->

<HR SIZE=3 NOSHADE>

<TABLE summary="layout" BORDER="0" WIDTH="100%">
<TR VALIGN=TOP>

<TD>
<P><FONT SIZE="-2"><A HREF="../../../legal/SMICopyright.html">Copyright &#169;</A>  1995-2006 <A HREF="http://www.sun.com/">Sun Microsystems, Inc. </A> All Rights Reserved. </FONT></P>
   <br> <br>

<FONT SIZE="-1">코멘트의 송부처:<a href="mailto:collections-comments@java.sun.com">collections-comments@java.sun.com</a> </FONT>
</TD>

<TD ALIGN=RIGHT>
<IMG SRC="../../../images/sunlogo64x30.gif" ALT="Sun" BORDER=0 WIDTH=64 HEIGHT=30> <BR> <FONT SIZE="+1"><i>Java Software</i></FONT>
</TD>

</TR>
</TABLE>

</body>
</html>
