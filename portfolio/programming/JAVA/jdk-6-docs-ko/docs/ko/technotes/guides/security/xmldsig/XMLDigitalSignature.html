<? xml version="1.0" encoding="ISO-8859-1"? >
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<title>Java XML 디지털 서명 API - xrath.com 에서 번역됨</title>
<!-- <link rel="StyleSheet" href="document.css" type="text/css" media="all" />     <link rel="StyleSheet" href="catalog.css" type="text/css" media="all" />     <link rel="Table of Contents" href="JavaWSTutorialTOC.html" /> -->    
<!--
<link rel="Previous" href="../../../../technotes/guides/security/xmldsig/XWS-SecuritySamples10.html" />
    <link rel="Next" href="../../../../technotes/guides/security/xmldsig/XMLDigitalSignatureAPI2.html" />
    <link rel="Index" href="../../../../technotes/guides/security/xmldsig/JavaWSTutorialIX.html" /> 
-->

		<!--[if gte IE 5.5000]> 		<script language="JavaScript"> 			function correctPNG() { // correctly handle PNG transparency in Win IE 5.5 or higher.  				for(var i=0; i<document.images.length; i++) { 	  			var img = document.images[i] 	  			var imgName = img.src.toUpperCase() 	  			if (imgName.substring(imgName.length-3, imgName.length) == "PNG") { 						var imgID = (img.id) ? "id='" + img.id + "' " : "" 		 				var imgClass = (img.className) ? "class='" + img.className + "' " : "" 		 				var imgTitle = (img.title) ? "title='" + img.title + "' " : "title='" + img.alt + "' " 		 				var imgStyle = "display:inline-block;" + img.style.cssText 		 				if (img.align == "left") imgStyle = "float:left;" + imgStyle 		 				if (img.align == "right") imgStyle = "float:right;" + imgStyle 		 				if (img.parentElement.href) imgStyle = "cursor:hand;" + imgStyle 		 				var strNewHTML = "<span " + imgID + imgClass + imgTitle 		 				+ " style=\"" + "width:" + img.width + "px; height:" + img.height + "px;" + imgStyle + ";" 	     			+ "filter:progid:DXImageTransform.Microsoft.AlphaImageLoader" 		 				+ "(src=\'" + img.src + "\', sizingMethod='scale');\"></span>" 		 				img.outerHTML = strNewHTML 		 				i = i-1 	    		}       	}    		} 			window.attachEvent("onload", correctPNG); 		</script> 		<![endif]***** -->

  </head>

  <body>
<!--  		<div id="header"> 			<img src="images/tutorialTitle.png" width="300" height="50" alt="The Java (TM) Web Services Developer Pack 1.6 Tutorial"/> 			<div class="navigation"> 				<a accesskey="p" href="XWS-SecuritySamples10.html" title="Previous"><img id="LongDescNotReq1" src="images/previous.png" width="40" height="40" border="0" alt="Prev" /></a> <a accesskey="c" href="JavaWSTutorialFront.html" title="Beginning"><img id="LongDescNotReq1" src="images/up.png" width="40" height="40" border="0" alt="Beginning" /></a> <a accesskey="n" href="XMLDigitalSignatureAPI2.html" title="Next"><img id="LongDescNotReq3" src="images/next.png" width="40" height="40" border="0" alt="Next" /></a> <a accesskey="i" href="JavaWSTutorialIX.html"></a>  			</div> 			<div id="header-links"> 				<a href="index.html" target="_blank">Home</a>  | <a href="JavaWSTutorial.pdf" target="_blank">PDF</a>  | <a href="http://java.sun.com/webservices/docs/1.6/api/index.html" target="_blank">API</a>  | <a href="http://java.sun.com/webservices/docs/1.6/tutorial/information/faq.html" target="_blank">FAQ</a>  | <a href="http://java.sun.com/webservices/docs/1.6/tutorial/information/search.html" target="_blank">Search</a>  | <a href="http://java.sun.com/webservices/docs/1.6/tutorial/information/sendusmail.html" target="_blank">Feedback</a>  | <a href="http://java.sun.com/webservices/docs/1.6/tutorial/information/history.html" target="_blank">History</a>  			</div> 		</div> -->

<!-- **** table of contents **** -->
<center>
<h1>XML 디지털 서명 API</h1>
<h2>개요 및 튜토리얼</h2>
</center>
<hr size="1" />

<center>
<h2>목차 </h2>
</center>

<a href="#wp268799">
<h3>Java XML 디지털 서명 API </h3></a> 

<!--  <a href="#wp510646"> <h3>How XWS-Security and XML Digital Signature API Are Related</h3></a>   -->

<a href="#wp478867">
<h3>XML 시큐리티 스택</h3></a> 

<a href="#wp510709">
<h3>패키지 계층</h3></a> 

<a href="#wp510726">
<h3>서비스 프로바이더</h3></a> 

<a href="#wp510728">
<h3>XML 서명에 대해</h3></a> 

<a href="#wp511122">
<h3>XML 서명의 예</h3></a> 

<a href="#wp511406">
<h3>XML 디지털 서명 API 의 예</h3></a> 

<blockquote>

<p class="pBody">
<a href="#wp511427">검증의 예</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp512158">XML 서명의 검증</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511408">서명을 포함한 문서의 인스턴스화</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511502">검증하는 서명 요소의 지정</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511504">검증 문맥의 작성</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511418">XML 서명의 비정렬화</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511420">XML 서명의 검증</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511422">XML 서명의 검증에 실패했을 경우</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511424">KeySelector 의 사용</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511438">genenveloped 의 예</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511436">XML 서명의 생성</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511741">서명하는 문서의 인스턴스화</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511743">공개키의 페어의 작성</a> <bxr>
     
     
     </p><p class="pBody">
<a href="#wp511745">서명 문맥의 작성</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511747">XML 서명의 구축</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511749">XML 서명의 생성</a> <bxr>
     
     </p><p class="pBody">
<a href="#wp511751">생성되는 문서의 인쇄 또는 표시</a> <bxr>
     

     </p></blockquote>

<hr />

<!-- **** end table of contents **** -->


<a name="wp268799"> </a> <h2 class="pTitle">
Java XML 디지털 서명 API
</h2>
<a name="wp510622"> </a> <p class="pBody">
Java XML 디지털 서명 API 는, XML 서명을 생성 및 검증하기 위한 표준의 Java API 입니다. 이 API 는, Java Community Process 의 아래에서 JSR 105 로서 정의되었습니다 (<code class="cCode"><a  href="http://www.jcp.org/en/jsr/detail?id=105" target="_blank">http://jcp.org/en/jsr/detail? id=105</a> </code> 를 참조). 이 JSR 는 최종적인 것이며, 이 릴리스의 Java SE 에는, API 의 최종 버젼의 FCS 액세스 구현이 포함되어 있습니다.
</p>
<a name="wp510624"> </a> <p class="pBody">
XML 서명은, 임의의 타입의 데이터 (XML 또는 바이너리)에 적용할 수 있습니다 (<code class="cCode"><a  href="http://www.w3.org/TR/xmldsig-core/" target="_blank">http://www.w3.org/TR/xmldsig-core/</a> </code> 를 참조). 결과의 서명은, XML 로 나타내집니다. XML 서명은, 데이터를 보호하기 위해서 사용할 수 있어 데이터의 무결성, 메세지 인증, 및 서명자 인증을 제공합니다.
</p>
<a name="wp268803"> </a> <p class="pBody">
이 문서에서는, XML 서명과 XML 디지털 서명 API 의 개요를 설명한 후에, API 를 사용해 XML 서명을 검증 및 생성하는 방법을 나타내는 2 개의 예에 대해 설명합니다. 이 문서는, 독자에게 암호화 및 디지털 서명의 기본적인 지식이 있는 것을 전제로 하고 있습니다.
</p>
<a name="wp510648"> </a> <p class="pBody">
API 는, 「XML-Signature Syntax and Processing」에서의 W3C 권고의 필수 기능 또는 추천 기능을 모두 지원하도록(듯이) 설계되고 있습니다. API 는 확장 가능 및 플러그 인 가능하고, Java 암호화 서비스 프로바이더 아키텍쳐(architecture)에 근거하고 있습니다. API 는, 다음의 2 종류의 개발자전용으로 설계되고 있습니다.
</p>
<div class="pSmartList1"><ul class="pSmartList1">
<a name="wp510650"> </a> <div class="pSmartList1"><li>XML 디지털 서명 API 를 사용해 XML 서명을 생성 및 검증하는 개발자</li></div>
<a name="wp510651"> </a> <div class="pSmartList1"><li>XML 디지털 서명 API 의 고정 구현을 작성해,<code class="cCode"><a  href="../crypto/CryptoSpec.html#Provider" target="_blank">JCA 프로바이더</a> </code>의 암호화 서비스로서 등록하는 개발자</li></div>

</div>


		
<!-- *****api file 2 ***** -->

<!--  <a name="wp510646"> </a> <h2 class="pHeading1"> How XWS-Security and XML Digital Signature API Are Related </h2> <a name="wp510675"> </a> <p class="pBody"> Before getting into specifics, it is important to see how XWS-Security and XML Digital Signature API are related.  In this release of the Java SE, XWS-Security is based on non-standard XML Digital Signature APIs.  </p> <a name="wp511057"> </a> <p class="pBody">  Java applications and middleware that need to create or process XML Signatures should use this XML Digital Signature API.    It can be used by Web Services Security (the goal for a future release) and by non-Web Services technologies (for example, signing documents stored or transferred in XML).  Both JSR 105 and JSR 106 (XML Digital Encryption APIs) are core-XML security components.  (See <code class="cCode"><a  href="http://www.jcp.org/en/jsr/detail?id=106" target="_blank">http://www.jcp.org/en/jsr/detail? id=106</a> </code> for more information about JSR 106. ) </p> <a name="wp511059"> </a> <p class="pBody"> XWS-Security does not currently use the XML Digital Signature API or XML Digital Encryption APIs.  XWS-Security uses the Apache libraries for XML-DSig and XML-Enc.  The goal of XWS-Security is to move toward using these APIs in future releases.  </p> -->

<!-- *****api file 3 ***** --> <!-- ***** XML Security Stack section       commented out 12.02.05 *****  -->

<!--  <a name="wp478867"> </a> <h2 class="pHeading1"> XML Security Stack </h2> -->

<a name="wp510690"> </a> <p class="pBody">
<!-- broken link <a  href="#wp510707"> -->

<!-- Figure 6-1 --> <!-- </a>  --> <!--  shows how the XML Digital Signature API (JSR 105) interacts with security components today and how it will interact with other security components, including XML Digital Encryption API (JSR 106), in future releases.</p><div align="center"><img src= "XML-Security-stack.gif" height="428" width="446" alt="Java SE v1.4 Security Components" border="0" hspace="0" vspace="0"/> </div><p class="pBody"> -->

<!-- "images/XML-Security-stack.gif" ; old image link. Current working link is in local directory for testing only -->
<p></p>

<p>

<!--    <a name="510707"> </a> <strong><font >Figure 6-1    Java SE Security Components</font></strong> </p>  <a name="wp510862"> </a> <p class="pBody"> XWSS calls Apache XML-Security directly today.  In future releases, it will be able to call other pluggable security providers.  The Apache XML-Security provider and the Sun JCA Provider are both pluggable components.  Since JSR 105 is final today, the JSR 105 layer is standard now.  The JSR 106 layer will be standard after that JSR becomes final.  </p>   **** end XML Security Stack (commented out 12.02. 05 -->

<!-- *****api file 4 ***** --> <a name="wp510709"> </a> </p><h2 class="pHeading1">
패키지 계층
</h2>
<a name="wp510735"> </a> <p class="pBody">
다음에 나타내는 6 개의 패키지가, XML 디지털 서명 API 를 구성합니다.
</p>
<div class="pSmartList1"><ul class="pSmartList1">
<a name="wp510737"> </a> <div class="pSmartList1"><li><code class="cCode">javax.xml.crypto</code></li></div>
<a name="wp510738"> </a> <div class="pSmartList1"><li><code class="cCode">javax.xml.crypto.dsig</code></li></div>
<a name="wp510739"> </a> <div class="pSmartList1"><li><code class="cCode">javax.xml.crypto.dsig.keyinfo</code></li></div>
<a name="wp510740"> </a> <div class="pSmartList1"><li><code class="cCode">javax.xml.crypto.dsig.spec</code></li></div>
<a name="wp510741"> </a> <div class="pSmartList1"><li><code class="cCode">javax.xml.crypto.dom</code></li></div>
<a name="wp510742"> </a> <div class="pSmartList1"><li><code class="cCode">javax.xml.crypto.dsig.dom</code></li></div>
</ul></div>
<a name="wp510744"> </a> <p class="pBody">
<code class="cCode"><a  href="../../../../api/javax/xml/crypto/package-summary.html" target="_blank">javax.xml.crypto</a> </code> 패키지에는, XML 서명의 생성이나 XML 데이터의 암호화 등, XML 암호화 조작을 실시하는 경우에 사용하는 공통 클래스가 포함되어 있습니다. 이 패키지로 주의해야 할 2 개의 클래스 가운데 1 개는 <code class="cCode"><a  href="../../../../api/javax/xml/crypto/KeySelector.html" target="_blank">KeySelector</a> </code> 클래스에서, 개발자는,<code class="cCode">KeyInfo</code> 객체에 포함되는 정보를 사용해 열쇠를 찾아내 옵션으로 검증하는 구현을 제공할 수 있습니다. 이제(벌써) 1 개의 클래스는 <code class="cCode"><a  href="../../../../api/javax/xml/crypto/URIDereferencer.html" target="_blank">URIDereferencer</a> </code> 클래스에서, 개발자는, 구현을 간접 참조하는 독자적인 URI 를 작성 및 지정할 수 있습니다.
</p>
<a name="wp510746"> </a> <p class="pBody">
<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/package-summary.html" target="_blank">javax.xml.crypto.dsig</a> </code> 패키지에는, W3C XML 디지털 서명 스펙으로 정의되고 있는 코어 요소를 나타내는 인터페이스가 포함되어 있습니다. 무엇보다 중요한 것은 <code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/XMLSignature.html" target="_blank">XMLSignature</a> </code> 클래스입니다. 이 클래스를 사용하면(자), XML 디지털 서명의 서명 및 검증을 실시할 수가 있습니다. XML 서명 구조 또는 요소의 대부분은, 대응하는 인터페이스에 의해 나타내집니다 (<code class="cCode">KeyInfo</code> 구조를 제외하다. 이것은 독자적인 패키지에 포함되어 있어 다음의 단락으로 설명). 인터페이스는, 다음과 같습니다. <code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/SignedInfo.html" target="_blank">SignedInfo</a> </code>,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/CanonicalizationMethod.html" target="_blank">CanonicalizationMethod</a> </code>,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/SignatureMethod.html" target="_blank">SignatureMethod</a> </code>,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/Reference.html" target="_blank">Reference</a> </code>,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/Transform.html" target="_blank">Transform</a> </code>,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/DigestMethod.html" target="_blank">DigestMethod</a> </code>,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/XMLObject.html" target="_blank">XMLObject</a> </code>,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/Manifest.html" target="_blank">Manifest</a> </code>,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/SignatureProperty.html" target="_blank">SignatureProperty</a> </code>, 및 <code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/SignatureProperties.html" target="_blank">SignatureProperties</a> </code>. <code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/XMLSignatureFactory.html" target="_blank">XMLSignatureFactory</a> </code> 클래스는, 이러한 인터페이스를 구현하는 객체를 작성하는 경우에 사용하는 추상 팩토리입니다.
</p>
<a name="wp510748"> </a> <p class="pBody">
<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/keyinfo/package-summary.html" target="_blank">javax.xml.crypto.dsig.keyinfo</a> </code> 패키지에는, 디지털 서명 권고로 정의되고 있는 대부분의 <code class="cCode">KeyInfo</code> 구조를 나타내는 인터페이스가 포함되어 있습니다. 이 구조에는,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/keyinfo/KeyInfo.html" target="_blank">KeyInfo</a> </code>,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/keyinfo/KeyName.html" target="_blank">KeyName</a> </code>,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/keyinfo/KeyValue.html" target="_blank">KeyValue</a> </code>,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/keyinfo/X509Data.html" target="_blank">X509Data</a> </code>,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/keyinfo/X509IssuerSerial.html" target="_blank">X509IssuerSerial</a> </code>,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/keyinfo/RetrievalMethod.html" target="_blank">RetrievalMethod</a> </code>, 및 <code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/keyinfo/PGPData.html" target="_blank">PGPData</a> </code> 가 있습니다. <code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/keyinfo/KeyInfoFactory.html" target="_blank">KeyInfoFactory</a> </code> 클래스는, 이러한 인터페이스를 구현하는 객체를 작성하는 경우에 사용하는 추상 팩토리입니다.
</p>
<a name="wp510750"> </a> <p class="pBody">
<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/spec/package-summary.html" target="_blank">javax.xml.crypto.dsig.spec</a> </code> 패키지에는, 다이제스트, 서명, 변환, 또는 XML 서명의 처리로 사용되는 정규화 알고리즘용의 입력 파라미터를 나타내는 인터페이스 및 클래스가 포함되어 있습니다.
</p>
<a name="wp510725"> </a> <p class="pBody">
마지막으로,<code class="cCode"><a  href="../../../../api/javax/xml/crypto/dom/package-summary.html" target="_blank">javax.xml.crypto.dom</a> </code> 및 <code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/dom/package-summary.html" target="_blank">javax.xml.crypto.dsig.dom</a> </code> 패키지에는, 각각 <code class="cCode"><a  href="../../../../api/javax/xml/crypto/package-summary.html" target="_blank">javax.xml.crypto</a> </code> 및 <code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/package-summary.html" target="_blank">javax.xml.crypto.dsig</a> </code> 패키지용의 DOM 고유의 클래스가 포함되어 있습니다. DOM 베이스의 <code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/XMLSignatureFactory.html" target="_blank">XMLSignatureFactory</a> </code> 또는 <code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/keyinfo/KeyInfoFactory.html" target="_blank">KeyInfoFactory</a> </code> 구현을 작성 또는 사용하는 개발자 및 사용자만이, 이러한 패키지를 직접 사용할 필요가 있습니다.
</p>

<!-- *****api file 5 ***** -->

<a name="wp510726"> </a> <h2 class="pHeading1">
서비스 프로바이더
</h2>
<a name="wp510760"> </a> <p class="pBody">
JSR 105 암호화 서비스는, 추상 <code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/XMLSignatureFactory.html" target="_blank">XMLSignatureFactory</a> </code> 및 <code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/keyinfo/KeyInfoFactory.html" target="_blank">KeyInfoFactory</a> </code> 클래스의 고정 구현이며, XML 서명 및 <code class="cCode">KeyInfo</code> 구조를 해석, 생성, 검증하는 객체 및 알고리즘을 작성합니다. <code class="cCode">XMLSignatureFactory</code> 의 고정 구현은, XML 서명에 대해 W3C 권고로 지정되고 있도록(듯이), 필수 알고리즘 각각을 지원할 필요가 있습니다. 옵션으로, W3C 권고 또는 그 외의 스펙으로 정의되고 있도록(듯이), 그 외의 알고리즘을 지원할 수 있습니다.
</p>
<a name="wp510762"> </a> <p class="pBody">
JSR 105 는,<code class="cCode">XMLSignatureFactory</code> 및 <code class="cCode">KeyInfoFactory</code> 구현의 등록 및 로드에, JCA 프로바이더 모델을 이용합니다.
</p>
<a name="wp510764"> </a> <p class="pBody">
각각의 <code class="cCode">XMLSignatureFactory</code> 또는 <code class="cCode">KeyInfoFactory</code> 고정 구현은, 특정의 XML 기구 타입을 지원합니다. 이 XML 기구 타입은, XML 서명 및 <code class="cCode">KeyInfo</code> 구조를 해석해 생성하기 위해서 구현이 내부적으로 사용하는 XML 처리 기구를 식별합니다. 이 JSR 는, 1 개의 표준 형식인 DOM 를 지원합니다. Java SE 에 번들 되고 있는 XML 디지털 서명 프로바이더 구현은, DOM 기구를 지원합니다. JDOM 등이 새로운 표준 형식의 지원가, 장래적으로 추가될 가능성이 있습니다.
</p>
<a name="wp513449"> </a> <p class="pBody">
XML 디지털 서명 API 구현은,<code class="cCode"><a  href="../../../../api/java/security/Signature.html" target="_blank">java.security.Signature</a> </code> 나 <code class="cCode"><a  href="../../../../api/java/security/MessageDigest.html" target="_blank">java.security.MessageDigest</a> </code> 등, 기반이 되는 JCA 엔진 클래스를 사용해 암호화 조작을 실행하도록 해 주세요.
</p>
<a name="wp513458"> </a> <p class="pBody">
<code class="cCode">XMLSignatureFactory</code> 및 <code class="cCode">KeyInfoFactory</code> 클래스 이외에, JSR 105 는, 변환 및 정규화 알고리즘용의 서비스 프로바이더 인터페이스도 지원하고 있습니다. <code class="cCode"><a  href="../../../../api/javax/xml/crypto/dsig/TransformService.html" target="_blank">TransformService</a> </code> 클래스를 사용하면(자), 특정의 XML 기구용의 고유의 변환 또는 정규화 알고리즘의 구현을 개발 및 플러그 인 할 수가 있습니다. <code class="cCode">TransformService</code> 클래스는, 구현을 등록 및 로드할 때 표준 JCA 프로바이더 모델을 사용합니다. 각 JSR 105 구현은,<code class="cCode">TransformService</code> 클래스를 사용해, 생성 또는 검증하는 XML 서명내의 변환 및 정규화 알고리즘을 지원하는 프로바이더를 찾아내도록 해 주세요.  
</p>
<!-- *****api file 6 ***** --> <a name="wp510728"> </a> <h2 class="pHeading1">
XML 서명에 대해
</h2>
<a name="wp511121"> </a> <p class="pBody">
XML 서명을 사용하면(자), XML 인가 바이너리인가에 관계없이, 임의의 데이터에 서명할 수 있습니다. 데이터는 1 개 이상의 Reference 요소내의 URI 에 의해 식별됩니다. XML 서명은 분리, 내포, 또는 포함의 3 개의 형식 가운데, 1 개 이상의 형식에서 기술됩니다. 분리 서명은 외부, 즉 서명 요소 자체의 밖에 있는 데이터에 대하는 것입니다. 내포 서명은 서명 요소의 안쪽에 있는 데이터에 대한 서명입니다. 포함 서명은 서명 대상의 데이터내에 포함되는 서명입니다.  
</p>

<!-- *****api file 7 ***** --> <a name="wp511122"> </a> <h2 class="pHeading1">
XML 서명의 예
</h2>
<a name="wp511141"> </a> <p class="pBody">
XML 서명의 내용을 설명하는 가장 간단한 방법은, 실제의 샘플을 나타내, 각 컴퍼넌트에 대해 상세하게 설명하는 것입니다. 다음에, XML 문서의 내용에 대해서 생성되는 포함 XML 서명의 예를 나타냅니다. 서명되기 전의 문서의 내용은, 다음과 같습니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
&lt;Envelope xmlns=&quot;urn:envelope&quot;&gt;
&lt;/Envelope&gt;<a name="wp511143"> </a> 
</pre></div>
<a name="wp511146"> </a> <p class="pBody">
결과의 포함 XML 서명은 다음과 같습니다. 읽기 쉽게 하기 위해서, 인덴트 및 형식 설정되어 있습니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
&lt;? xml version=&quot;1. 0&quot; encoding=&quot;UTF-8&quot;? &gt;
&lt;Envelope xmlns=&quot;urn:envelope&quot;&gt;
  &lt;Signature xmlns=&quot;http://www.w3.org/2000/09/xmldsig#&quot;&gt;
    &lt;SignedInfo&gt;
      &lt;CanonicalizationMethod 
        Algorithm=&quot;http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments&quot;/&gt;
      &lt;SignatureMethod Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#dsa-sha1&quot;/&gt;
      &lt;Reference URI=&quot;&quot;&gt;
        &lt;Transforms&gt;
          &lt;Transform Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#enveloped-signature&quot;/&gt;
        &lt;/Transforms&gt;
        &lt;DigestMethod Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#sha1&quot;/&gt;
        &lt;DigestValue&gt;uooqbWYa5VCqcJCbuymBKqm17vY=&lt;/DigestValue&gt;
      &lt;/Reference&gt;
    &lt;/SignedInfo&gt;
    &lt;SignatureValue&gt;
      KedJuTob5gtvYx9qM3k3gm7kbLBwVbEQRl26S2tmXjqNND7MRGtoew==
    &lt;/SignatureValue&gt;
    &lt;KeyInfo&gt;
      &lt;KeyValue&gt;
        &lt;DSAKeyValue&gt;
          &lt;P&gt;
            /KaCzo4Syrom78z3EQ5SbbB4sF7ey80etKII864WF64B81uRpH5t9jQTxe
            Eu0ImbzRMqzVDZkVG9xD7nN1kuFw==
          &lt;/P&gt;
          &lt;Q&gt;li7dzDacuo67Jg7mtqEm2TRuOMU=&lt;/Q&gt;
          &lt;G&gt;
            Z4Rxsnqc9E7pGknFFH2xqaryRPBaQ01khpMdLRQnG541Awtx/
            XPaF5Bpsy4pNWMOHCBiNU0NogpsQW5QvnlMpA==
          &lt;/G&gt;
          &lt;Y&gt;
            qV38IqrWJG0V/mZQvRVi1OHw9Zj84nDC4jO8P0axi1gb6d+475yhMjSc/
            BrIVC58W3ydbkK+Ri4OKbaRZlYeRA==
          &lt;/Y&gt;
        &lt;/DSAKeyValue&gt;
      &lt;/KeyValue&gt;
    &lt;/KeyInfo&gt;
  &lt;/Signature&gt;
&lt;/Envelope&gt;<a name="wp511148"> </a> 
</pre></div>
<a name="wp511183"> </a> <p class="pBody">
<code class="cCode">Signature</code> 요소는 서명 대상의 내용에 삽입되고 있어 거기에 따라 포함 서명이 되어 있습니다. 필수의 <code class="cCode">SignedInfo</code> 요소에는, 실제로 서명되는 다음의 정보가 포함되어 있습니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
&lt;SignedInfo&gt;
  &lt;CanonicalizationMethod 
    Algorithm=&quot;http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments&quot;/&gt;
  &lt;SignatureMethod Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#dsa-sha1&quot;/&gt;
  &lt;Reference URI=&quot;&quot;&gt;
    &lt;Transforms&gt;
      &lt;Transform Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#enveloped-signature&quot;/&gt;
    &lt;/Transforms&gt;
    &lt;DigestMethod Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#sha1&quot;/&gt;
    &lt;DigestValue&gt;uooqbWYa5VCqcJCbuymBKqm17vY=&lt;/DigestValue&gt;
  &lt;/Reference&gt;
&lt;/SignedInfo&gt;<a name="wp511185"> </a> 
</pre></div>
<a name="wp511204"> </a> <p class="pBody">
필수의 <code class="cCode">CanonicalizationMethod</code> 요소는, 서명 또는 검증전에 <code class="cCode">SignedInfo</code> 요소를 정규화하기 위해서 사용되는 알고리즘을 정의합니다. 정규화란, 그 데이터에 대한 서명을 무효화할 가능성이 있는 변경을 고려하기 위해서, XML 의 내용을 정규형으로 변환하는 처리를 의미합니다. 정규화는, XML 의 성질 및 다른 프로세서와 중간적 존재에 의한 해석을 위해서(때문에) 필요합니다. 정규화에 의해, 서명이 무효가 되어도 서명된 데이터가 논리적으로 동등하도록 데이터를 변경할 수 있습니다.
</p>
<a name="wp511206"> </a> <p class="pBody">
필수의 <code class="cCode">SignatureMethod</code> 요소는, 서명의 생성에 사용되는 디지털 서명 알고리즘을 정의합니다. 이 경우는, SHA-1 를 사용하는 DSA 입니다.
</p>
<a name="wp511208"> </a> <p class="pBody">
1 개(살) 이상의 <code class="cCode">Reference</code> 요소가, 다이제스트 되는 데이터를 식별합니다. 각 <code class="cCode">Reference</code> 요소는, URI 에 의해 데이터를 식별합니다. 이 예에서는, URI 의 값은 빈 상태(empty)의 캐릭터 라인 (&quot;&quot;)으로, 이것은 문서의 루트를 나타냅니다. 옵션의 <code class="cCode">Transform</code> 요소에는, 1 개(살) 이상의 <code class="cCode">Transform</code> 요소의 리스트가 포함되어 있어 각각이 다이제스트전의 데이터의 변환에 사용되는 변환 알고리즘을 기술합니다. 이 예에서는, 포함 변환 알고리즘의 <code class="cCode">Transform</code> 요소가 1 개 있습니다. 포함 변환은, 서명치를 계산하기 전에 서명 요소 자체가 삭제되도록(듯이) 하기 위해서, 포함 서명에 필요합니다. 필수의 <code class="cCode">DigestMethod</code> 요소는, 데이터의 다이제스트에 사용되는 알고리즘을 정의합니다. 이 경우는, SHA1 입니다. 마지막으로, 필수의 <code class="cCode">DigestValue</code> 요소에는, 실제의 Base64 로 encode 된 다이제스트치가 포함되어 있습니다.
</p>
<a name="wp511210"> </a> <p class="pBody">
필수의 <code class="cCode">SignatureValue</code> 요소에는,<code class="cCode">SignedInfo</code> 요소에 대한 서명의 Base64- encode 된 서명치가 포함되어 있습니다.
</p>
<a name="wp511252"> </a> <p class="pBody">
옵션의 <code class="cCode">KeyInfo</code> 요소에는, 서명의 검증에 필요한 열쇠에 관한 정보가 포함되어 있습니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
&lt;KeyInfo&gt;
  &lt;KeyValue&gt;
    &lt;DSAKeyValue&gt;
      &lt;P&gt;
        /KaCzo4Syrom78z3EQ5SbbB4sF7ey80etKII864WF64B81uRpH5t9jQTxe
        Eu0ImbzRMqzVDZkVG9xD7nN1kuFw==
      &lt;/P&gt;
      &lt;Q&gt;li7dzDacuo67Jg7mtqEm2TRuOMU=&lt;/Q&gt;
      &lt;G&gt;
        Z4Rxsnqc9E7pGknFFH2xqaryRPBaQ01khpMdLRQnG541Awtx/
        XPaF5Bpsy4pNWMOHCBiNU0NogpsQW5QvnlMpA==
      &lt;/G&gt;
      &lt;Y&gt;
        qV38IqrWJG0V/mZQvRVi1OHw9Zj84nDC4jO8P0axi1gb6d+475yhMjSc/
        BrIVC58W3ydbkK+Ri4OKbaRZlYeRA==
      &lt;/Y&gt;
    &lt;/DSAKeyValue&gt;
  &lt;/KeyValue&gt;
&lt;/KeyInfo&gt;<a name="wp511374"> </a> 
</pre></div>
<a name="wp511202"> </a> <p class="pBody">
이 <code class="cCode">KeyInfo</code> 요소에는 <code class="cCode">KeyValue</code> 요소가 포함되어 있습니다. 이 요소에는, 서명의 검증에 필요한 공개키로 구성되는 <code class="cCode">DSAKeyValue</code> 요소가 포함되어 있습니다. <code class="cCode">KeyInfo</code> 에는, X. 509 증명서 및 PGP 열쇠 식별자 등, 다양한 내용을 포함할 수가 있습니다. 다양한 <code class="cCode">KeyInfo</code> 타입의 상세한 것에 대하여는, XML 서명 권고의 <code class="cCode"><a  href="http://www.w3.org/TR/xmldsig-core/#sec-KeyInfo" target="_blank">KeyInfo 의 항</a> </code>을 참조해 주세요.
</p>

<!-- *****api file 8 ***** -->

<a name="wp511406"> </a> <h2 class="pHeading1">
XML 디지털 서명 API 의 예
</h2>

<!-- *** note from developer about section ****  This section needs a little bit of changes because unlike JWSDP, Java SE does not ship ant with its tools. So we need to change the instructions for compiling and running the samples. In this case, we can just invoke javac and java directly. I also realized I need to add a couple of more files to the docs/technotes/guides/security/xmldsig directory for these samples to run correctly. I will do that ASAP.  -->



<a name="wp511426"> </a> <p class="pBody">
다음의 항에서는, XML 디지털 서명 API 를 사용하는 방법을 나타내는 2 개의 예에 대해 설명합니다.
</p>
<div class="pSmartList1"><ul class="pSmartList1">
<a name="wp511432"> </a> <div class="pSmartList1"><li>검증의 예</li></div>
<a name="wp511433"> </a> <div class="pSmartList1"><li>서명의 예</li></div>
</ul></div>

<!-- removed copy per email 12.-`02.05 ******   <a name="wp512249"> </a> <p class="pBody"> To run the sample applications using the supplied Ant <code class="cCode">build.xml</code> files, issue the following commands after you installed Java SE: </p> <a name="wp512250"> </a> <p class="pBody"> For Solaris/Linux: </p> <div class="pSmartList1"><ol type="1" class="pSmartList1"> <a name="wp512253"> </a> <div class="pSmartList1"><li><code class="cCode">% export JWSDP_HOME=&lt;</code><code class="cVariable">your Java SE installation directory</code><code class="cCode">&gt;</code></li></div> <a name="wp512254"> </a> <div class="pSmartList1"><li><code class="cCode">% export ANT_HOME=$JWSDP_HOME/apache-ant</code></li></div> <a name="wp512255"> </a> <div class="pSmartList1"><li>  <code class="cCode">% export PATH=$ANT_HOME/bin:$PATH</code></li></div> <a name="wp512256"> </a> <div class="pSmartList1"><li>  <code class="cCode">% cd $JWSDP_HOME/xmldsig/samples/&lt;</code><code class="cVariable">sample-name</code><code class="cCode">&gt;</code></li></div> </ol></div> <a name="wp512258"> </a> <p class="pBody"> For Windows 2000/XP: </p> <div class="pSmartList1"><ol type="1" class="pSmartList1"> <a name="wp512261"> </a> <div class="pSmartList1"><li><code class="cCode">&gt; set JWSDP_HOME=&lt;</code><code class="cVariable">your Java SE installation directory</code><code class="cCode">&gt;</code></li></div> <a name="wp512262"> </a> <div class="pSmartList1"><li><code class="cCode">&gt; set ANT_HOME=%JWSDP_HOME%\apache-ant</code></li></div> <a name="wp512263"> </a> <div class="pSmartList1"><li><code class="cCode">&gt; set PATH=%ANT_HOME%\bin;%PATH%</code></li></div> <a name="wp512264"> </a> <div class="pSmartList1"><li><code class="cCode">&gt; cd %JWSDP_HOME%\xmldsig\samples\&lt;</code><code class="cVariable">sample-name</code><code class="cCode">&gt;</code></li></div> </ol></div>  --> <a name="wp511427"> </a> <h3 class="pHeading2">
검증의 예
</h3>
<a name="wp512156"> </a> <p class="pBody">
이 항으로 가리키는 코드는,<!-- <code class="cVariable">JWSDP_HOME</code> --><code class="cCode"&gt;-->docs/technotes/guides/security/xmldsig</code> 디렉토리의 <code class="cCode">Validate.java</code> 파일에 있습니다. 처리의 토대가 되는 파일 <code class="cCode">envelopedSignature.xml</code> 는, 같은 디렉토리내에 있습니다.
</p>


<a name="wp512164"> </a> <p class="pBody">
이 예를 컴파일 해 실행하려면 ,<code class="cVariable">docs/technotes/guides/security/xmldsig</code> 디렉토리로부터 다음의 커멘드를 실행합니다. <br /><br />

<code>$ javac Validate.java <br /> $ java Validate signature.xml<br /></code>
</p>

샘플 프로그램은 현재의 작업 디렉토리내의 파일 <code>signature.xml</CODE> 의 서명을 검증합니다.  



<!-- <a name="wp512164"> </a> <p class="pBody"> To run the example, execute the following command from the <code class="cCode">&lt;</code><code class="cVariable">JWSDP_HOME</code><code class="cCode">&gt;/xmldsig/samples/validate</code> directory: </p> <div class="pPreformattedRelative"><pre class="pPreformattedRelative"> $ ant<a name="wp512165"> </a>  </pre></div> <a name="wp512167"> </a> <p class="pBody"> The sample program will validate the signature in the file <code class="cCode">envelopedSignature.xml</code> in the current working directory.  To validate a different signature, run the following command: </p> <div class="pPreformattedRelative"><pre class="pPreformattedRelative"> $ ant -Dsample.args=&quot;signature.xml&quot; <a name="wp512172"> </a>  </pre></div> <a name="wp512174"> </a> <p class="pBody"> where <code class="cCode">&quot;signature.xml&quot;</code> is the pathname of the file.  </p> --> <a name="wp512158"> </a> <h4 class="pHeading3">
XML 서명의 검증
</h4>
<a name="wp511454"> </a> <p class="pBody">
이 예에서는, JSR 105 API 를 사용해 XML 서명을 검증하는 방법을 나타냅니다. 이 예는 DOM (Document Object Model)를 사용해, 서명 요소를 포함한 XML 문서 및 JSR 105 DOM 구현을 해석해, 서명을 검증합니다.
</p>
<a name="wp511408"> </a> <h4 class="pHeading3">
서명을 포함한 문서의 인스턴스화
</h4>
<a name="wp511458"> </a> <p class="pBody">
최초로, JAXP <code class="cCode">DocumentBuilderFactory</code> 를 사용해, 서명을 포함한 XML 문서를 해석합니다. 어플리케이션은, 다음의 코드행을 호출하는 것에 의해,<code class="cCode">DocumentBuilderFactory</code> 의 디폴트 구현을 가져옵니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
DocumentBuilderFactory dbf = 
&nbsp;&nbsp;DocumentBuilderFactory.newInstance();<a name="wp511460"> </a> 
</pre></div>
<a name="wp511462"> </a> <p class="pBody">
팩토리 이름 공간 인식도 작성합니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
dbf.setNamespaceAware(true);<a name="wp511464"> </a> 
</pre></div>
<a name="wp511466"> </a> <p class="pBody">
다음에, 이 팩토리를 사용해 <code class="cCode">DocumentBuilder</code> 의 인스턴스를 가져옵니다. 이것은 문서의 해석으로 사용됩니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
DocumentBuilder builder = dbf.newDocumentBuilder();  
Document doc = builder.parse(new FileInputStream(argv[0]));<a name="wp511468"> </a> 
</pre></div>
<a name="wp511502"> </a> <h4 class="pHeading3">
검증하는 서명 요소의 지정
</h4>
<a name="wp511508"> </a> <p class="pBody">
문서에 복수 포함되어 있는 경우도 있기 (위해)때문에, 검증하는 <code class="cCode">Signature</code> 요소를 지정할 필요가 있습니다. DOM 메소드 <code class="cCode">Document.getElementsByTagNameNS</code> 를 사용해, 다음에 나타내도록(듯이),<code class="cCode">Signature</code> 요소의 XML 서명 이름 공간 URI 및 태그명을 메소드에 건네줍니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
NodeList nl = doc.getElementsByTagNameNS
&nbsp;&nbsp;(XMLSignature.XMLNS, &quot;Signature&quot;);
if (nl.getLength() == 0) {
&nbsp;&nbsp;throw new Exception(&quot;Cannot find Signature element&quot;);
}<a name="wp511510"> </a> 
</pre></div>
<a name="wp511503"> </a> <p class="pBody">
이것은, 문서내에 있는 모든 <code class="cCode">Signature</code> 요소의 리스트를 돌려줍니다. 이 예에서는 <code class="cCode">Signature</code> 요소는 1 개만입니다.
</p>
<a name="wp511504"> </a> <h4 class="pHeading3">
검증 문맥의 작성
</h4>
<a name="wp511524"> </a> <p class="pBody">
서명을 검증하기 위한 입력 파라미터를 포함한 <code class="cCode">XMLValidateContext</code> 인스턴스를 작성합니다. DOM 를 사용하고 있기 (위해)때문에,<code class="cCode">DOMValidateContext</code> 인스턴스 (<code class="cCode">XMLValidateContext</code> 의 서브 클래스)를 인스턴스화해, 2 개의 파라미터를 건네줍니다. 2 개의 파라미터란,<code class="cCode">KeyValueKeySelector</code> 객체와 먼저 생성한 <code class="cCode">NodeList</code> 의 최초의 엔트리인, 검증하는 <code class="cCode">Signature</code> 요소의 참조입니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
DOMValidateContext valContext = new DOMValidateContext
&nbsp;&nbsp;(new KeyValueKeySelector(), nl.item(0));<a name="wp511526"> </a> 
</pre></div>
<a name="wp511529"> </a> <p class="pBody">
<code class="cCode">KeyValueKeySelector</code> 에 대해서는,<a  href="#wp511424">「KeySelector 의 사용」</a>으로 상세하게 설명합니다.
</p>
<a name="wp511418"> </a> <h4 class="pHeading3">
XML 서명의 비정렬화
</h4>
<a name="wp511539"> </a> <p class="pBody">
<code class="cCode">Signature</code> 요소의 내용을 <code class="cCode">XMLSignature</code> 객체에 추출합니다. 이 처리는 비정렬화로 불립니다. <code class="cCode">Signature</code> 요소는 <code class="cCode">XMLSignatureFactory</code> 객체를 사용해 비정렬화 됩니다. 어플리케이션은 다음의 코드행을 호출하는 것에 의해,<code class="cCode">XMLSignatureFactory</code> 의 DOM 구현을 취득할 수 있습니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
XMLSignatureFactory factory = 
&nbsp;&nbsp;XMLSignatureFactory.getInstance(&quot;DOM&quot;);<a  name="wp511541"> </a> 
</pre></div>
<a name="wp511543"> </a> <p class="pBody">
다음에, 팩토리의 <code class="cCode">unmarshalXMLSignature</code> 메소드를 호출해 <code class="cCode">XMLSignature</code> 객체를 비정렬화해, 먼저 작성한 검증 문맥을 건네줍니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">

XMLSignature signature = 
&nbsp;&nbsp;factory.unmarshalXMLSignature(valContext);<a name="wp511419"> </a> 
</pre></div>
<a name="wp511420"> </a> <h4 class="pHeading3">
XML 서명의 검증
</h4>
<a name="wp511555"> </a> <p class="pBody">
이것으로, 서명을 검증할 준비가 갖추어졌습니다. <code class="cCode">XMLSignature</code> 객체로 <code class="cCode">validate</code> 메소드를 호출해, 다음에 나타내도록(듯이) 검증 문맥을 건네줍니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
boolean coreValidity = signature.validate(valContext);<a name="wp511557"> </a> 
</pre></div>
<a name="wp511421"> </a> <p class="pBody">
<code class="cCode">W3C XML 서명 권고</code>의<code class="cCode">코어 검증 규칙</code>에 따라 서명이 정상적으로 검증되면(자),<code class="cCode">validate</code> 메소드는 「true」를 돌려줍니다. 그 이외의 경우는 false 를 돌려줍니다.
</p>
<a name="wp511422"> </a> <h4 class="pHeading3">
XML 서명의 검증에 실패했을 경우
</h4>
<a name="wp511567"> </a> <p class="pBody">
<code class="cCode">XMLSignature.validate</code> 메소드가 false 를 돌려주었을 경우, 실패의 원인의 엄선을 시행할 수 있습니다. 코어 XML 서명 검증에는, 다음의 2 개의 국면이 있습니다.
</p>
<div class="pSmartList1"><ul class="pSmartList1">
<a name="wp512008"> </a> <div class="pSmartList1"><li><code class="cCode">서명의 검증</code> (서명의 암호 검증) </li></div>
<a name="wp512011"> </a> <div class="pSmartList1"><li><code class="cCode">참조의 검증</code> (서명내의 각 참조의 다이제스트의 검증)</li></div>
</ul></div>
<a name="wp512014"> </a> <p class="pBody">
서명이 유효하게 되려면 , 각각의 국면이 성공할 필요가 있습니다. 서명의 암호화의 검증이 실패했는지의 여부를 체크하기 위해서, 다음에 나타내도록(듯이) 상태를 체크할 수 있습니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
boolean sv = 
&nbsp;&nbsp;signature.getSignatureValue(). validate(valContext);
System.out.println(&quot;signature validation status: &quot; + sv);<a name="wp511569"> </a> 
</pre></div>
<a name="wp511572"> </a> <p class="pBody">
다음에 나타내도록(듯이), 참조에 대해서 반복해 실행해, 각 참조의 검증 상태를 체크할 수도 있습니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
Iterator i =
&nbsp;&nbsp;signature.getSignedInfo(). getReferences(). iterator();
for (int j=0; i.hasNext(); j++) {
&nbsp;&nbsp;boolean refValid = ((Reference) 
&nbsp;&nbsp;&nbsp;&nbsp;i.next()). validate(valContext);
&nbsp;&nbsp;System.out.println(&quot;ref[&quot;+j+&quot;] validity status: &quot; + 
&nbsp;&nbsp;&nbsp;&nbsp;refValid);
}<a name="wp511574"> </a> 
</pre></div>
<a name="wp511424"> </a> <h4 class="pHeading3">
KeySelector 의 사용
</h4>
<a name="wp511588"> </a> <p class="pBody">
<code class="cCode">KeySelectors</code> 은, XMLSignature 의 검증에 필요한 열쇠를 찾아내 선택하기 위해서 사용됩니다. 이전에는,<code class="cCode">DOMValidateContext</code> 객체를 작성했을 때는,<code class="cCode">KeySelector</code> 객체를 최초의 인수로서 건네주었습니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
DOMValidateContext valContext = new DOMValidateContext
&nbsp;&nbsp;(new KeyValueKeySelector(), nl.item(0));<a name="wp511590"> </a> 
</pre></div>
<a name="wp511593"> </a> <p class="pBody">
또, 서명의 검증에 필요한 열쇠를 벌써 알고 있는 경우는,<code class="cCode">PublicKey</code> 를 최초의 인수로서 건네줄 수도 있었습니다. 다만, 많은 경우는 모릅니다.
</p>
<a name="wp511425"> </a> <p class="pBody">
<code class="cCode">KeyValueKeySelector</code> 는, 추상 <code class="cCode">KeySelector</code> 클래스의 고정 구현입니다. <code class="cCode">KeyValueKeySelector</code> 구현은,<code class="cCode">XMLSignature</code> 의 <code class="cCode">KeyInfo</code> 요소의 <code class="cCode">KeyValue</code> 요소에 포함되는 데이터를 사용해, 적절한 검증열쇠를 찾아내려고 합니다. 열쇠를 신뢰할 수 있을지 어떨지는 판단하지 않습니다. 이것은, 단순한 <code class="cCode">KeySelector</code> 구현이며, 실제의 사용이라고 하는 것보다는 설명을 위해서(때문에) 설계되고 있습니다. <code class="cCode">KeySelector</code> 의 것보다 실용적인 예는,<code class="cCode">KeyInfo</code> 에 포함되는 <code class="cCode">X509Data</code> 정보 (<code class="cCode">X509SubjectName</code> 요소,<code class="cCode">X509IssuerSerial</code> 요소,<code class="cCode">X509SKI</code> 요소,<code class="cCode">X509Certificate</code> 요소등)에 일치하는 신뢰할 수 있는 열쇠로 <code class="cCode">KeyStore</code> 를 검색하는 예입니다.
</p>
<a name="wp511606"> </a> <p class="pBody">
<code class="cCode">KeyValueKeySelector</code> 의 구현은, 다음과 같습니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
private static class KeyValueKeySelector extends KeySelector {

&nbsp;&nbsp;public KeySelectorResult select(KeyInfo keyInfo,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KeySelector.Purpose purpose,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AlgorithmMethod method,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XMLCryptoContext context)
&nbsp;&nbsp;&nbsp;&nbsp;throws KeySelectorException {

&nbsp;&nbsp;&nbsp;&nbsp;if (keyInfo == null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new KeySelectorException(&quot;Null KeyInfo object! &quot;);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;SignatureMethod sm = (SignatureMethod) method;
&nbsp;&nbsp;&nbsp;&nbsp;List list = keyInfo.getContent();

&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; list.size(); i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XMLStructure xmlStructure = (XMLStructure) list.get(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (xmlStructure instanceof KeyValue) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PublicKey pk = null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pk = ((KeyValue) xmlStructure). getPublicKey();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (KeyException ke) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new KeySelectorException(ke);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// make sure algorithm is compatible with method
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (algEquals(sm.getAlgorithm(), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pk.getAlgorithm())) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new SimpleKeySelectorResult(pk);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;throw new KeySelectorException(&quot;No KeyValue element 
found! &quot;);
&nbsp;&nbsp;}

&nbsp;&nbsp;static boolean algEquals(String algURI, String algName) {
&nbsp;&nbsp;&nbsp;&nbsp;if (algName.equalsIgnoreCase(&quot;DSA&quot;) &amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;algURI.equalsIgnoreCase(SignatureMethod.DSA_SHA1)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;&nbsp;} else if (algName.equalsIgnoreCase(&quot;RSA&quot;) &amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;algURI.equalsIgnoreCase(SignatureMethod.RSA_SHA1)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}
}<a name="wp511608"> </a> 
</pre></div>



<a name="wp511438"> </a> <h3 class="pHeading2">
genenveloped 의 예
</h3>


<a name="wp511755"> </a> <p class="pBody">
이 항으로 설명하는 코드는,<!-- <code class="cVariable">JWSDP_HOME</code><code class="cCode">&gt;  --><code>docs/technotes/guides/security/xmldsig</code> 디렉토리의 <code class="cCode">GenEnveloped.java</code> 파일에 있습니다. 처리의 토대가 되는 파일 <code class="cCode">envelope.xml</code> 는, 같은 디렉토리내에 있습니다. 이 파일은, 파일 <code class="cCode">envelopedSignature.xml</code> 를 생성합니다.
</p>

<a name="wp512216"> </a> <p class="pBody">
이 샘플을 컴파일 해 실행하려면 ,<!-- <code class="cCode">&lt;</code><code class="cVariable">JWSDP_HOME</code><code class="cCode">&gt;  --><code>docs/technotes/guides/security/xmldsig</code> 디렉토리로부터 다음의 커멘드를 실행합니다. </p>
<code>$ javac GenEnveloped.java<br /> $ java GenEnveloped envelope.xml envelopedSignature.xml<br /></code>

<p>샘플 프로그램은 파일 envelope.xml 내의 문서의 포함 서명을 생성해, 현재의 작업 디렉토리내의 파일 <code>envelopedSignature.xml</code> 에 보존합니다.  </p>

<a name="wp511436"> </a> <h4 class="pHeading3">
XML 서명의 생성
</h4>
<a name="wp511919"> </a> <p class="pBody">
이 예에서는, XML 디지털 서명 API 를 사용해 XML 서명을 생성하는 방법을 나타냅니다. 보다 구체적으로는, 이 예는 XML 문서의 포함 XML 서명을 생성합니다. 포함 서명이란, 서명 대상의 내용에 포함되는 서명입니다. 이 예는 DOM (Document Object Model)를 사용해, 서명 대상의 XML 문서 및 JSR 105 DOM 구현을 해석해, 결과의 서명을 생성합니다.
</p>
<a name="wp511740"> </a> <p class="pBody">
XML 서명 및 그 다양한 컴퍼넌트의 기본적인 지식이, 이 항의 이해에 도움이 됩니다. 자세한 것은,<a  href="http://www.w3.org/TR/xmldsig-core/" target="_blank"><code class="cCode">http://www.w3.org/TR/xmldsig-core/</code></a>  를 참조해 주세요.  
</p> 
<a name="wp511741"> </a> <h4 class="pHeading3">
서명하는 문서의 인스턴스화
</h4>
<a name="wp511913"> </a> <p class="pBody">
최초로, JAXP <code class="cCode">DocumentBuilderFactory</code> 를 사용해, 서명하는 XML 문서를 해석합니다. 어플리케이션은, 다음의 코드행을 호출하는 것에 의해,<code class="cCode">DocumentBuilderFactory</code> 의 디폴트 구현을 가져옵니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
DocumentBuilderFactory dbf =
&nbsp;&nbsp;DocumentBuilderFactory.newInstance();<a name="wp513167"> </a> 
</pre></div>
<a name="wp511915"> </a> <p class="pBody">
팩토리 이름 공간 인식도 작성합니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
dbf.setNamespaceAware(true);<a name="wp511895"> </a> 
</pre></div>
<a name="wp511897"> </a> <p class="pBody">
다음에, 이 팩토리를 사용해 <code class="cCode">DocumentBuilder</code> 의 인스턴스를 가져옵니다. 이것은 문서의 해석으로 사용됩니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
DocumentBuilder builder = dbf.newDocumentBuilder();  
Document doc = builder.parse(new FileInputStream(argv[0]));<a name="wp511899"> </a> 
</pre></div>
<a name="wp511743"> </a> <h4 class="pHeading3">
공개키의 페어의 작성
</h4>
<a name="wp511875"> </a> <p class="pBody">
공개키의 페어를 생성합니다. 그리고의 예에서는, 비공개키를 사용해 서명을 생성합니다. <code class="cCode">KeyPairGenerator</code> 를 사용해, 열쇠의 페어를 작성합니다. 이 예에서는, 512 바이트의 길이의 DSA <code class="cCode">KeyPair</code> 를 작성합니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;DSA&quot;);
kpg.initialize(512);
KeyPair kp = kpg.generateKeyPair();<a name="wp511877"> </a> 
</pre></div>
<a name="wp511744"> </a> <p class="pBody">
실제로는, 비공개키는 일반적으로은 이전에 생성되어, 관련하는 공개키 증명서와 함께 <code class="cCode">KeyStore</code> 파일에 보존되고 있습니다.
</p>
<a name="wp511745"> </a> <h4 class="pHeading3">
서명 문맥의 작성
</h4>
<a name="wp511864"> </a> <p class="pBody">
서명을 생성하기 위한 입력 파라미터를 포함한, XML 디지털 서명 <code class="cCode">XMLSignContext</code> 를 작성합니다. DOM 를 사용하고 있으므로,<code class="cCode">DOMSignContext</code> (<code class="cCode">XMLSignContext</code> 의 서브 클래스)를 인스턴스화해, 2 개의 파라미터를 건네줍니다. 파라미터는, 문서의 서명에 사용되는 비공개키와 서명 대상의 문서의 루트입니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
DOMSignContext dsc = new DOMSignContext
&nbsp;&nbsp;(kp.getPrivate(), doc.getDocumentElement());<a name="wp511866"> </a> 
</pre></div>
<a name="wp511747"> </a> <h4 class="pHeading3">
XML 서명의 구축
</h4>
<a name="wp511799"> </a> <p class="pBody">
<code class="cCode">Signature</code> 요소의 다양한 부분을 조합해,<code class="cCode">XMLSignature</code> 객체로 합니다. 이러한 객체는 모두,<code class="cCode">XMLSignatureFactory</code> 객체를 사용해, 작성되고 조합할 수 있습니다. 어플리케이션은 다음의 코드행을 호출하는 것에 의해,<code class="cCode">XMLSignatureFactory</code> 의 DOM 구현을 가져옵니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
XMLSignatureFactory fac = 
&nbsp;&nbsp;XMLSignatureFactory.getInstance(&quot;DOM&quot;);<a name="wp511801"> </a> 
</pre></div>
<a name="wp511803"> </a> <p class="pBody">
다음에 나타내도록(듯이), 다양한 팩토리 메소드를 호출해 <code class="cCode">XMLSignature</code> 객체의 다양한 부분을 작성합니다. <code class="cCode">Reference</code> 객체를 작성해, 그 객체에 다음의 것을 건네줍니다.
</p>
<div class="pSmartList1"><ul class="pSmartList1">
<a name="wp512044"> </a> <div class="pSmartList1"><li>서명 대상의 객체의 URI (여기에서는, 문서의 루트를 나타내는 URI &quot;&quot; 를 지정)</li></div>
<a name="wp512049"> </a> <div class="pSmartList1"><li><code class="cCode">DigestMethod</code> (여기에서는, SHA1 를 사용)</li></div>
<a name="wp512050"> </a> <div class="pSmartList1"><li>1 개의 <code class="cCode">Transform</code>, 포함 <code class="cCode">Transform</code> (서명치의 계산전에 서명 자체가 삭제되도록(듯이), 포함 서명으로 필요)</li></div>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
Reference ref = fac.newReference
&nbsp;&nbsp;(&quot;&quot;, fac.newDigestMethod(DigestMethod.SHA1, null),
&nbsp;&nbsp;&nbsp;&nbsp;Collections.singletonList
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fac.newTransform(Transform.ENVELOPED,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(TransformParameterSpec) null)), null, null);<a name="wp511805"> </a> 
</pre></div>
</ul></div>
<a name="wp511811"> </a> <p class="pBody">
다음에,<code class="cCode">SignedInfo</code> 객체를 작성합니다. 이것은, 다음에 나타내도록(듯이), 실제로 서명되는 객체입니다. <code class="cCode">SignedInfo</code> 를 작성할 때는, 다음의 것을 파라미터로서 건네줍니다.
</p>
<div class="pSmartList1"><ul class="pSmartList1">
<a name="wp512056"> </a> <div class="pSmartList1"><li><code class="cCode">CanonicalizationMethod</code> (여기에서는, INCLUSIVE 를 사용해 코멘트를 보관 유지)</li></div>
<a name="wp512059"> </a> <div class="pSmartList1"><li><code class="cCode">SignatureMethod</code> (여기에서는, DSA 를 사용)</li></div>
<a name="wp512060"> </a> <div class="pSmartList1"><li><code class="cCode">References</code> 의 리스트 (이 경우는 1 개만)</li></div>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
SignedInfo si = fac.newSignedInfo
&nbsp;&nbsp;(fac.newCanonicalizationMethod
&nbsp;&nbsp;&nbsp;&nbsp;(CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(C14NMethodParameterSpec) null),
&nbsp;&nbsp;&nbsp;&nbsp;fac.newSignatureMethod(SignatureMethod.DSA_SHA1, null),
&nbsp;&nbsp;&nbsp;&nbsp;Collections.singletonList(ref));<a name="wp511813"> </a> 
</pre></div>
</ul></div>
<a name="wp511819"> </a> <p class="pBody">
다음에, 옵션의 <code class="cCode">KeyInfo</code> 객체를 작성합니다. 이 객체에는, 접수측이 서명의 검증에 필요한 열쇠를 찾아낼 수 있도록(듯이) 하는 정보가 포함되어 있습니다. 이 예에서는, 공개키를 포함한 <code class="cCode">KeyValue</code> 객체를 추가합니다. <code class="cCode">KeyInfo</code> 및 그 다양한 subtype을 작성하려면 ,<code class="cCode">KeyInfoFactory</code> 객체를 사용합니다. 이 객체는 다음에 나타내도록(듯이),<code class="cCode">XMLSignatureFactory</code> 의 <code class="cCode">getKeyInfoFactory</code> 메소드를 호출하는 것에 의해 취득할 수 있습니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
KeyInfoFactory kif = fac.getKeyInfoFactory();<a name="wp511822"> </a> 
</pre></div>
<a name="wp511824"> </a> <p class="pBody">
다음에,<code class="cCode">KeyInfoFactory</code> 을 사용해 <code class="cCode">KeyValue</code> 객체를 작성해,<code class="cCode">KeyInfo</code> 객체에 추가합니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
KeyValue kv = kif.newKeyValue(kp.getPublic());
KeyInfo ki = kif.newKeyInfo(Collections.singletonList(kv));<a name="wp511826"> </a> 
</pre></div>
<a name="wp511829"> </a> <p class="pBody">
마지막으로,<code class="cCode">XMLSignature</code> 객체를 작성해, 먼저 작성한 <code class="cCode">SignedInfo</code> 및 <code class="cCode">KeyInfo</code> 객체를 파라미터로서 건네줍니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
XMLSignature signature = fac.newXMLSignature(si, ki);<a name="wp511831"> </a> 
</pre></div>
<a name="wp511836"> </a> <p class="pBody">
아직 실제로는 서명을 생성하고 있습니다. 다음의 스텝에서 생성합니다.
</p>
<a name="wp511749"> </a> <h4 class="pHeading3">
XML 서명의 생성
</h4>
<a name="wp511787"> </a> <p class="pBody">
이것으로, 서명을 생성할 준비가 갖추어졌습니다. <code class="cCode">XMLSignature</code> 객체로 <code class="cCode">sign</code> 메소드를 호출해, 다음에 나타내도록(듯이) 서명 문맥을 건네줍니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
signature.sign(dsc);<a name="wp511789"> </a> 
</pre></div>
<a name="wp511750"> </a> <p class="pBody">
이것으로, 결과의 문서에는 서명이 포함되어 있습니다. 서명은, 루트 요소의 마지막 아이 요소로서 삽입되었습니다.
</p>
<a name="wp511751"> </a> <h4 class="pHeading3">
생성되는 문서의 인쇄 또는 표시
</h4>
<a name="wp511768"> </a> <p class="pBody">
다음의 코드를 사용해, 결과의 서명필 문서를 파일 또는 표준 출력에 인쇄할 수 있습니다.
</p>
<div class="pPreformattedRelative"><pre class="pPreformattedRelative">
OutputStream os;
if (args.length &gt; 1) {
&nbsp;&nbsp;os = new FileOutputStream(args[1]);
} else {
&nbsp;&nbsp;os = System.out;
}<a name="wp511770"> </a> 
TransformerFactory tf = TransformerFactory.newInstance();
Transformer trans = tf.newTransformer();
trans.transform(new DOMSource(doc), new StreamResult(os));<a name="wp511777"> </a> 
</pre></div>
<a name="wp511766"> </a> <p class="pBody">

</p>



<!-- *****  end appended files ***** -->
  </ul></body>
<!--
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script>
-->
</html>
