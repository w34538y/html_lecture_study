<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<html>
<head>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">

<title>Java 시큐리티 아키텍쳐(architecture):  - 
 - xrath.com 에서 번역됨</title>
</head>
<body bgcolor="#ffffff">
 
<table summary="layout" width="100%"><tr>
<td><!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. --> <!-- font size="-1" --> <a href=security-specTOC.fm.html>목차</a>  | <a href="security-spec.doc4.html">전의 항목</a>  | <a href="security-spec.doc6.html">다음의 항목</a>  <!-- | <a href="security-spec.doc.html">INDEX</a>   --> <!-- /font --></td><td align=right><i>Java 시큐리티 아키텍쳐(architecture)</i></td>
</tr></table>
<br>
 

<p>
<hr size="8" width="35%" align="left" noshade>

<h2><a name="20588"><i> 5 </i>안전한 클래스 로딩</a> </h2>

<blockquote>
<a name="28413"><!-- --></a> 동적인 클래스 로딩은 Java 가상 머신의 중요한 기능으로, Java 플랫폼상에서 소프트웨어 컴퍼넌트를 실행시에 인스톨 가능하게 합니다. 이 기능에는, 독특한 특장이 몇개인가 있습니다. 우선, 요구가 있어도 할 수 있는 한 직전까지 클래스가 로드 되지 않는, 지연 로딩이라고 하는 특징이 있습니다. 또, 동적인 클래스 로딩은, 링크 타임 체크를 추가하는 것에 의해, Java 가상 머신의 형태의 안전성을 유지합니다. 링크 타임 체크는, 특정의 런타임 체크와 옮겨져, 1 회만 실행됩니다. 게다가 프로그래머는, 특정의 클래스의 로드원이 되는 원격의 장소를 지정하거나 클래스에 적절한 시큐리티 속성을 할당하거나 하는 것 같은, 독자적인 클래스 로더를 정의할 수 있습니다. 또, 클래스 로더를 사용해, 다양한 소프트웨어 컴퍼넌트에 개별의 이름 공간을 제공할 수 있습니다. 예를 들어, 브라우저는, 다른 Web 페이지의 애플릿을 다른 클래스 로더를 사용해 로드할 수 있기 (위해)때문에, 이러한 애플릿 클래스간인 정도의 차단 레벨이 유지됩니다. 실제, 이러한 애플릿에 같은 이름의 클래스가 포함되어 있어도 괜찮습니다. 그것들은, Java 가상 머신에 따라서 다른 종류로서 다루어집니다. <p>
<a name="28430"><!-- --></a> 클래스 로딩의 기구는, Java 프로그램 언어의 동적 성질의 중심이 되고 있는 것 만으로는 아닙니다. 클래스 파일의 검색과 취득, 시큐리티 정책의 참조, 및 적절한 액세스권을 갖게한 클래스 객체의 정의는, 클래스 로더가 실시하기 (위해)때문에, 이 기구는, 시큐리티의 제공에도 중심적인 역할을 이루어 있습니다. <p>
</blockquote>
<br>
<h3>
<a name="28488"><!-- --></a>  <i>	5.1	 </i>클래스 로더의 클래스 계층
</h3>

<blockquote>
<a name="28490"><!-- --></a> 1 개의 Java 가상 머신에, 클래스 로더 객체의 복수의 인스턴스가 존재할 가능성이 있기 (위해)때문에, 클래스를 로드할 때, 사용하는 클래스 로더를 어떻게 결정할까는 중요한 문제입니다. Java 2 SDK 에서는, 다른 속성을 가진 복수의 클래스 로더의 클래스가 도입되었기 때문에, 어느 종류의 클래스 로더를 사용하는지도 큰 문제입니다. <p>
<a name="28505"><!-- --></a> 클래스 로더의 클래스 계층 루트는, java.lang.ClassLoader 라고 하는 추상 클래스에서, JDK 1.0 으로 정의된 이래 확장되어 왔습니다. Java 2 SDK v 1.2 로 도입된 java.security.SecureClassLoader 클래스는, 추상 ClassLoader 클래스의 서브 클래스 및 고정 구현입니다. java.net.URLClassLoader 클래스는, SecureClassLoader 의 서브 클래스입니다. <p>
<a name="28537"><!-- --></a> Appletviewer 라고 하는 유틸리티프로그램은, private 클래스인 sun.applet.AppletClassLoader 를 사용해 애플릿을 로드합니다. JDK 1.0 에서는, AppletClassLoader 는 ClassLoader 의 서브 클래스 및 고정 구현입니다. Java 2 SDK 에서는, AppletClassLoader 는 URLClassLoader 의 서브 클래스입니다. <p>
<a name="28538"><!-- --></a> 클래스 로더의 커스텀 클래스를 작성하는 경우는, 그 커스텀 클래스 로더 특유의 필요에 따라서, 상기의 임의의 클래스 로더 클래스의 서브 클래스로 하는 일도 가능합니다. AppletClassLoader 는, sun. * package 내에서 정의된 private 클래스에서, 지원되지 않고 변경될 가능성도 있으므로, AppletClassLoader 의 서브 클래스화는 실시하지 말아 주세요. <p>
</blockquote>
<br>
<h3>
<a name="28414"><!-- --></a>  <i>	5.2	 </i>최초의 클래스 로더
</h3>

<blockquote>
<a name="28553"><!-- --></a> 모든 클래스는, 클래스 로더에 의해 로드 됩니다. 클래스 로더 자체도 클래스에서, 다른 클래스 로더에 의해 로드 될 필요가 있기 (위해)때문에, 당연, 최초의 클래스 로더는 어디에서 로드 되는가 하는 「닭과 알의 문제」와 같은 문제가 생각됩니다. 이 때문에, 클래스의 로딩 프로세스를 bootstrap 하는 「초기」클래스 로더가 있습니다. 초기 클래스 로더는, 일반적으로는 C 등의 네이티브 언어로 기술되고 있어 Java 문맥내에는 나타나지 않습니다. 초기 클래스 로더는, 로컬의 파일 시스템으로부터 플랫폼에 의존한 방법으로 클래스를 로드하는 경우가 자주 있습니다. <p>
<a name="28564"><!-- --></a> 클래스에는, java. * package 내에서 정의된 클래스와 같이, Java 가상 머신과 실행 시스템이 올바르게 기능하기 위해서 불가결한 것이 있습니다. 그러한 클래스는 자주(잘), base class로 불립니다. 역사적인 이유로부터, 이러한 모든 클래스에는, NULL 의 클래스 로더가 존재합니다. 아마, 이 NULL 클래스 로더가, 초기 클래스 로더의 존재를 나타내는 유일한 표시입니다. 실제, NULL 클래스 로더를, 단지 초기 클래스 로더로서 간주하는 (분)편이 간단합니다. <p>
<a name="28656"><!-- --></a> 1 개의 Java 어플리케이션 환경에 모든 클래스가 있으면, 클래스의 로딩 관계를 반영하는 클래스 로딩의 트리를 간단하게 형성할 수 있습니다. 클래스 로더가 아닌 클래스는, 모두 잎노드입니다. 각 클래스의 친노드는 그 클래스의 클래스 로더로, NULL 클래스 로더는 루트 클래스입니다. 클래스 로더가 자신의 조상의 클래스 로더를 로드한다고 하는 순환은 있을 수  없기 때문에, 이 구조는 트리 구조가 됩니다. <p>
</blockquote>
<br>
<h3>
<a name="28657"><!-- --></a>  <i>	5.3	 </i>클래스 로더의 위양
</h3>

<blockquote>
<a name="28658"><!-- --></a> 클래스 로더에 클래스의 로드가 요구되면(자), 그 클래스 로더 자체가 클래스를 로드하는 경우와 그 클래스가 다른 클래스 로더에 로드를 실시하도록(듯이) 요구하는 경우가 있습니다. 즉, 1 번째의 클래스 로더는, 2 번째의 클래스 로더에 위양 할 수가 있습니다. 위양 관계는, 어느 클래스 로더가 다른 어느 클래스 로더를 로드하기에는  관계없다고 하는 점에서는 가상적입니다. 그러나 오히려 위양 관계는, 클래스 로더 객체의 작성시에, 부모와 자식 관계로서 형성됩니다. 다만, 시스템 클래스 로더는, 모든 클래스 로더의 위양 루트의 원형입니다. 위양 관계에 순환이 없게 주의해 주세요. 순환이 있으면(자), 위양 프로세스가 엔들레스 루프에 들어가는 일이 있습니다. <p>
</blockquote>
<br>
<h3>
<a name="28633"><!-- --></a>  <i>	5.4	 </i>클래스의 해석 처리 알고리즘
</h3>

<blockquote>
<a name="29062"><!-- --></a> Java 2 SDK ClassLoader 메소드의 디폴트 구현에서는, 클래스를 로드할 때, 다음의 순서로 클래스가 검색됩니다. <p>
</blockquote>
<blockquote>
<ul><li>
<a name="28682"><!-- --></a> 클래스가 이미 로드되어 있지 않은지 어떤지를 체크한다
</li>
<li>
<a name="28684"><!-- --></a> 현재의 클래스 로더에 위양 관계의 부모가 지정되고 있는 경우는, 그 부모에게 클래스의 로드를 위양 한다. 부모가 지정되어 있지 않은 경우는, 초기 클래스 로더에 위양 한다
</li>
<li>
<a name="28696"><!-- --></a> 커스터마이즈 가능한 메소드를 호출해, 다른 장소에 있는 클래스를 검색한다
</li>
</ul>
</blockquote>
<blockquote>
<a name="28698"><!-- --></a> 최초의 스텝에서는, 클래스 로더의 로컬 캐쉬 (또는 기능적으로 그것과 동등한, 글로벌 캐쉬등)로, 로드 된 클래스가 타겟 클래스와 일치할지 어떨지를 조사합니다. 마지막 스텝에서는, 클래스의 검색 기구의 커스터마이즈 기능이 제공되고 있습니다. 이 때문에, 커스텀 클래스 로더로, 이 메소드를 오버라이드(override) 해, 클래스의 검색 방법을 지정할 수 있습니다. 예를 들어, 애플릿의 클래스 로더로 이 메소드를 오버라이드(override) 해, 애플릿의 호스트에게 돌아와 클래스 파일을 검색해, 네트워크 넘어로 그 클래스 파일을 로드할 수 있습니다. <p>
<a name="28770"><!-- --></a> 이러한 스텝의 어디선가 클래스가 검색되면(자), 그것이 돌려주어집니다. 위의 스텝을 사용해 클래스가 발견되지 않는 경우는, ClassNotFound 예외가 throw 됩니다. <p>
<a name="28709"><!-- --></a> 형태의 안전성이기 때문에, 같은 클래스가 같은 클래스 로더에 의해 2 회 이상 로드 되지 않게 주의해 주세요. 클래스가 벌써 로드 된 클래스가 아닌 경우, 현재의 클래스 로더는, 태스크를 친클래스 로더에 위양 하려고 합니다. 이 프로세스는, 재귀적으로 실행되는 일도 있습니다. 이 때문에, 적절한 클래스 로더가 사용되는 것이 보증됩니다. 예를 들어, 시스템 클래스를 검색하는 경우, 시스템 클래스 로더에 가까스로 도착할 때까지 위양 프로세스가 반복해집니다. <p>
<a name="28779"><!-- --></a> 여기까지 이양 알고리즘을 봐 왔습니다. 그럼, 클래스명이 지정되어 그 클래스를 로드할 때, 어느 클래스 로더로부터 사용하기 시작하면 좋을까요. 클래스 로더를 특정하는 규칙은, 다음과 같습니다. <p>
</blockquote>
<blockquote>
<ul><li>
<a name="28790"><!-- --></a> 어플리케이션의 최초의 클래스를 로드하는 경우는, URLClassLoader 의 새로운 인스턴스가 사용된다
</li>
<li>
<a name="28801"><!-- --></a> 애플릿의 최초의 클래스를 로드하는 경우는, AppletClassLoader 의 새로운 인스턴스가 사용된다
</li>
<li>
<a name="28802"><!-- --></a> java.lang.Class.ForName 가 직접 불려 갔을 경우는, 초기 클래스 로더가 사용된다
</li>
<li>
<a name="28808"><!-- --></a> 클래스의 로드 요구가 기존의 클래스로부터 그 클래스에의 참조에 의해 발생했을 경우는, 기존의 클래스의 클래스 로더가 클래스를 로드하도록(듯이) 요구된다
</li>
</ul>
</blockquote>
<blockquote>
<a name="28818"><!-- --></a> URLClassLoader 의 인스턴스 및 AppletClassLoader 의 인스턴스의 사용에 대한 규칙에는 예외가 있어, 특정의 시스템 환경에 따라서는, 규칙이 바뀌는 경우가 있습니다. 예를 들어, 같은 Web 페이지로부터 복수의 애플릿 클래스를 로드하는 경우, Web 브라우저가 기존의 AppletClassLoader 를 반복해 사용하는 경우도 있습니다. <p>
<a name="28825"><!-- --></a> 클래스 로더의 능력에 의해, 클래스 로더의 인스턴스를 작성할 수 있는 프로그램의 종류는 크게 제한됩니다. 한편, URL 의 위치를 지정해, 거기에서 클래스를 로드하기 위한 편리한 기구를 어플리케이션 또는 애플릿에 대비하는 것은 바람직한 방법입니다. 어느 프로그램에서도 URLClassLoader 클래스의 인스턴스를 작성할 수 있도록(듯이)하기 위한 정적 메소드가 제공되고 있습니다. 다만, 그 외의 종류의 클래스 로더의 경우에는, 이것은 들어맞지 않습니다. <p>
<a name="28831"><!-- --></a> 
<p>
</blockquote>

<br>
<hr>
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. --> <!-- font size="-1" --> <a href=security-specTOC.fm.html>목차</a>  | <a href="security-spec.doc4.html">전의 항목</a>  | <a href="security-spec.doc6.html">다음의 항목</a>  <!-- | <a href="security-spec.doc.html">INDEX</a>   --> <!-- /font -->

<hr>
<font size="-1"><i><A HREF="../../../../legal/SMICopyright.html">Copyright</a>  &#169 1997-1999 Sun Microsystems, Inc.  All Rights Reserved. </i></font>





</body>
</html>
