<html><head>
<!-- Inserted by TRADOS: --><META HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">
<title> - xrath.com 에서 번역됨</title></head>
<body bgcolor=#ffffff>
 
<a href="spicover.frame.html">[선두의 항목]</a>  <a href="legend.frame.html">[전의 항목]</a>  [다음의 항목] [마지막 항목]
<hr><br>
 
<p><a name="150244"> </a> 
<center>
<h1>부록 C:JNDI 의 변경 이력</h1>
</center>
<p></p><a name="151997"> </a> 
<h1> JNDI 1.2:JNDI 1.1 이후의 변경</h1>
<ul><a name="152001"> </a> 
<li><code>javax.naming.event</code> 패키지를 추가 <a name="152002"> </a>  <a name="152002"> </a> 
<li><code>javax.naming.ldap</code> 패키지를 추가 <a name="152004"> </a>  <a name="152004"> </a> 
<li>resource file를 사용한 구성의 지원를 추가. <strong>JNDI API</strong> 문서의 제 6 장을 참조
</ul><a name="152008"> </a> 
<h2> API 관련의 변경</h2>
<ul><a name="152003"> </a> 
<li>열거의 취소해 또는 종료를 실시하기 위해서(때문에) <code>NamingEnumeration.close()</code> 를 추가 <a name="152014"> </a> 
<li>환경 프로퍼티이 다른 조회 문맥의 작성 및 재시행을 실시하기 위해서(때문에),<code>ReferralException.getReferralContext(Hashtable env)</code> 및 <code>ReferralException.retryReferral()</code> 를 추가 <a name="152015"> </a> 
<li><code>Name</code> 인수를 받는 문맥 메소드로,<code>CompositeName</code> 인수 및 <code>CompositeName</code> 이외의 인수의 처리를 명시적으로 정의. 특히,<code>CompositeName</code> 의 인스턴스는 합성명으로서 처리되어 그 외의 인스턴스는 모두 복합명으로서 처리된다
 <a name="152016"> </a> 
<li>문맥의 이름 공간에서 그 문맥의 풀네임을 취득하기 위해서,<code>Context.getNameInNamespace()</code> 를 추가 <a name="152018"> </a> 
<li><code>Reference</code> 객체의 클래스 팩토리 위치를 명시적으로 정의. 특히, 위치는 코드 베이스로, 공백에서 단락지어진 URL 의 리스트로 구성된다 <a name="152019"> </a> 
<li><code>Attribute</code> 및 <code>BasicAttribute</code> 에 대해서, 정리된 다가 속성의 지원를 추가 <a name="152053"> </a> 
<li><code>BasicAttributes.equals()</code> 및 <code>BasicAttributes.hashCode()</code> 를 추가 <a name="152020"> </a> 
<li><code>DirContext.getSchemaClassDefinition()</code> 의 시멘틱스를 재정의.  1 개의 (임의의) 클래스 정의를 돌려주지 않고 , 클래스 정의의 <code>DirContext</code> 객체가 포함되는 문맥을 돌려주도록(듯이) 변경 <a name="152037"> </a> 
<li>지연 초기화를 실시하기 위해서(때문에), protected <code>InitialContext</code> 및 <code>InitialDirContext</code> 생성자 을 추가. 서브 클래스의 구현에 사용한다
</ul><a name="152011"> </a> 
<h2> SPI 관련의 변경</h2>
<ul><a name="152061"> </a> 
<li>객체 상태를 변환하고 나서 객체를 네임 서비스 및 디렉토리 서비스에 바인드 하기 위해서,<code>StateFactory</code> 및 <code>NamingManager.getStateToBind()</code> 를 추가.  이것들은 <code>ObjectFactory</code> 및 <code>NamingManager.getObjectInstance()</code> 에 유사하고 있다.  <a name="152060"> </a> 
<li><code>DirContext</code> 인터페이스가 구현되고 있는 서비스 프로바이더의 지원를 향상시키기 위해서(때문에),<code>DirObjectFactory</code> 및 <code>DirStateFactory</code> 인터페이스를 추가. 이러한 인터페이스를 사용하기 위해서,<code>DirectoryManager.getObjectInstance()</code> 및 <code>DirectoryManager.getStateToStore()</code> 를 추가 <a name="152009"> </a> 
<li>URL 캐릭터 라인이 처리되지 않게,<code>NamingManager.getObjectInstance()</code> 의 정의를 변경. 이 때문에, URL 는,<code>RefAddr</code> 의 타입이 「URL」인 <code>Reference</code> 에 랩 해야 한다 <a name="152058"> </a> 
<li><code>ResolveResult</code> 에 <code>Serializable</code> 를 구현 <a name="152073"> </a> 
<li>「동적 연합」을 지원하기 위해서, Next Naming System (NNS) 참조로 불리는 특별한 형식의 <code>Reference</code> 를 정의. 이 참조에는, 「nns」의 <code>RefAddr</code> 타입과 해결 지음의 객체로 구성되는 컨텐츠가 포함되어 있다 <a name="152085"> </a> 
<li><code>NamingManager.getContinuationContext()</code> 및 <code>DirectoryManager.getContinuationContext()</code> 에 의해 프로퍼티 세트에 이름을 붙이는 <code>NamingManager.CPE</code> 캐릭터 라인 정수를 추가. 이 프로퍼티의 값은,<code>CannotProceedException</code> 의 인스턴스이다. CPE 를 연쇄시키는 것에 의해 연합을 구현하는 서비스 프로바이더로 사용한다 <a name="152100"> </a> 
<li>서비스 프로바이더가 환경 프로퍼티의 이름을 붙일 때 사용하는 규약을 정의. 6.1 절을 참조
</ul>
<hr><br>
 
<a href="spicover.frame.html">[선두의 항목]</a>  <a href="legend.frame.html">[전의 항목]</a>  [다음의 항목] [마지막 항목]
<hr><br>



<address>
<a href="mailto:jndi@java.sun.com">jndi@java.sun.com</a> 
</address>

<i><a href="copyright.html">Copyright</a>  &#169; 1999, Sun Microsystems, Inc.    All rights reserved. </i>


</body>
</html>
