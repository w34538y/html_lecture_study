<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JVM(TM) Tool Interface 1.1. 102 - xrath.com 에서 번역됨</title>
<style type="text/css">
          td.tableHeader {font-size: larger}
        </style>
</head>
<body>
<table border="0" width="100%">
<tr>
<td align="center">
<h1>
Java<sup><font size="-2">TM</font></sup> Virtual Machine Tool Interface
  </h1>
<h3>Version 1.1</h3>
</td>
</tr>
</table>
<ul>
<li>
<a href="#SpecificationIntro"><b>처음에</b></a> 
<ul>
<li>
<a href="#whatIs"><b>JVMTI 란</b></a> 
</li>
<li>
<a href="#architecture"><b>아키텍쳐(architecture)</b></a> 
</li>
<li>
<a href="#writingAgents"><b>에이전트의 작성</b></a> 
</li>
<li>
<a href="#deployingAgents"><b>에이전트의 배치</b></a> 
</li>
<li>
<a href="#starting"><b>JVMTI 에이전트의 커멘드행 옵션</b></a> 
</li>
<li>
<a href="#startup"><b>에이전트의 기동</b></a> 
</li>
<li>
<a href="#onload"><b>에이전트의 기동 (OnLoad 단계)</b></a> 
</li>
<li>
<a href="#onattach"><b>에이전트의 기동 (라이브 단계)</b></a> 
</li>
<li>
<a href="#onunload"><b>에이전트의 정지</b></a> 
</li>
<li>
<a href="#tooloptions"><b>JAVA_TOOL_OPTIONS</b></a> 
</li>
<li>
<a href="#environments"><b>JVMTI 환경</b></a> 
</li>
<li>
<a href="#bci"><b>바이트코드Instrumentation</b></a> 
</li>
<li>
<a href="#mUTF"><b>수정 UTF-8 의 캐릭터 라인 인코딩</b></a> 
</li>
<li>
<a href="#context"><b>스펙의 문맥</b></a> 
</li>
</ul>
</li>
<li>
<a href="#FunctionSection"><b>함수</b></a> 
<ul>
<li>
<a href="#jvmtiEnvAccess"><b>JVMTI 함수의 액세스</b></a> 
</li>
<li>
<a href="#functionReturn"><b>함수의 반환값</b></a> 
</li>
<li>
<a href="#refs"><b>JNI 객체 참조의 관리</b></a> 
</li>
<li>
<a href="#prereqState"><b>함수 호출의 필요 조건</b></a> 
</li>
<li>
<a href="#functionsExceptions"><b>예외와 함수</b></a> 
</li>
<li>
<a href="#FunctionIndex"><b>함수의 색인</b></a> 
<ul>
<li>
<a href="#memory"><b>메모리 관리</b></a> 
</li>
<li>
<a href="#threadCategory"><b>thread</b></a> 
</li>
<li>
<a href="#thread_groups"><b>thread 그룹</b></a> 
</li>
<li>
<a href="#stack"><b>스택 프레임</b></a> 
</li>
<li>
<a href="#ForceEarlyReturn"><b>조기 복귀의 강제</b></a> 
</li>
<li>
<a href="#Heap"><b>heap</b></a> 
</li>
<li>
<a href="#Heap_1_0"><b>heap (1.0)</b></a> 
</li>
<li>
<a href="#local"><b>국소 변수</b></a> 
</li>
<li>
<a href="#breakpointCategory"><b>breakpoint</b></a> 
</li>
<li>
<a href="#fieldWatch"><b>감시되는 필드</b></a> 
</li>
<li>
<a href="#class"><b>클래스</b></a> 
</li>
<li>
<a href="#object"><b>객체</b></a> 
</li>
<li>
<a href="#fieldCategory"><b>필드</b></a> 
</li>
<li>
<a href="#method"><b>메소드</b></a> 
</li>
<li>
<a href="#RawMonitors"><b>raw 모니터</b></a> 
</li>
<li>
<a href="#jniIntercept"><b>JNI 함수의 차단</b></a> 
</li>
<li>
<a href="#eventManagement"><b>이벤트 관리</b></a> 
</li>
<li>
<a href="#extension"><b>확장 기능 기구</b></a> 
</li>
<li>
<a href="#capability"><b>권한</b></a> 
</li>
<li>
<a href="#timers"><b>타이머</b></a> 
</li>
<li>
<a href="#classLoaderSearch"><b>클래스 로더 검색</b></a> 
</li>
<li>
<a href="#props"><b>시스템 프로퍼티</b></a> 
</li>
<li>
<a href="#general"><b>전반</b></a> 
</li>
</ul>
</li>
<li>
<a href="#ErrorSection"><b>에러 코드</b></a> 
</li>
</ul>
</li>
<li>
<a href="#EventSection"><b>이벤트</b></a> 
<ul>
<li>
<a href="#EventIndex"><b>이벤트의 색인</b></a> 
</li>
</ul>
</li>
<li>
<a href="#DataSection"><b>데이터형</b></a> 
<ul>
<li>
<a href="#jniTypes"><b>JVMTI 로 사용하는 JNI 의 형태</b></a> 
</li>
<li>
<a href="#jvmtiTypes"><b>JVMTI 기저형</b></a> 
</li>
<li>
<a href="#StructureTypeDefinitions"><b>구조형의 정의</b></a> 
</li>
<li>
<a href="#FunctionTypeDefinitions"><b>함수형의 정의</b></a> 
</li>
<li>
<a href="#EnumerationDefinitions"><b>열거형의 정의</b></a> 
</li>
<li>
<a href="#FunctionTable"><b>함수 테이블</b></a> 
</li>
</ul>
</li>
<li>
<a href="#ConstantIndex"><b>정수의 색인</b></a> 
</li>
<li>
<a href="#ChangeHistory"><b>변경 이력</b></a> 
</li>
</ul>
<p></p>
<hr noshade="noshade" size="3">
<p></p>
<p id="SpecificationIntro"></p>
<h4 id="whatIs">JVMTI 란</h4>
Java<sup style="font-size: xx-small">TM</sup> Virtual Machine Tool Interface (JVM<small style="font-size: xx-small">&nbsp;</small>TI)는, 개발툴이나 감시 툴로 사용되는 프로그래밍 인터페이스입니다. JVMTI 는, Java<sup><font  size="-2">TM</font></sup> 가상 머신 (VM)으로 동작하는 어플리케이션 상태 검사와 실행 제어의 양쪽 모두의 기능을 제공해,
    <p></p>
프로 파일링 툴, 디버그 툴, 감시 툴, thread 분석 툴, 커버리지(coverage) 분석 툴 등, VM 상태 그 외에 액세스 할 필요가 있는 각종 툴의 VM 인터페이스로서 기능합니다. <small style="font-size: xx-small"></small>
    <p></p>
JVMTI 는, Java<sup style="font-size: xx-small">TM</sup> 가상 머신의 모든 구현으로 사용할 수 있다고는 할 수 없습니다. <small style="font-size: xx-small"></small>
    <p></p>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 는, 쌍방향의 인터페이스입니다. 이하에서는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 클라이언트를 「에이전트」라고 부릅니다. 에이전트는,<a href="#EventSection">이벤트</a>로부터, 다양한 상태의 발생 통지를 받을 수가 있습니다. <i></i>JVM<small style="font-size: xx-small">&nbsp;</small>TI 는, 이벤트에 응답해, 또는 이벤트로부터는 독립해, 많은<a href="#FunctionSection">함수</a>를 사용해 어플리케이션에의 조회 및 제어를 실행할 수 있습니다.
    <p></p>
개개의 에이전트는 동일한 프로세스로 실행되어 검사 대상의 어플리케이션을 실행하는 가상 머신과 직접 통신합니다. 이 통신에는, 네이티브 인터페이스 (JVM<small style="font-size: xx-small">&nbsp;</small>TI)가 사용됩니다. 네이티브의 인 프로세스 인터페이스에 의해, 툴측에게로의 침입은 최소한으로 억제하면서, 최대한의 제어가 가능하게 됩니다. 일반적으로, 에이전트는 비교적 컴팩트합니다. 에이전트는, 타겟 어플리케이션의 일반적으로의 실행을 방해하는 일 없이, 툴의 기능의 대부분을 구현하는 다른 프로세스에 의해 제어할 수 있습니다.
<h4 id="architecture">아키텍쳐(architecture)</h4>
툴에의 기입은, JVM<small style="font-size: xx-small">&nbsp;</small>TI 를 사용해 직접 행해지는지, Java 플랫폼 툴 아키텍쳐(architecture)의 고도 인터페이스를 사용해 간접적으로 행해집니다. Java Platform Debugger Architecture 에는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 외에, 보다 높은 레벨의 아웃 프로세스 디버거 인터페이스도 포함되어 있습니다. 많은 툴에는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 보다 높은 레벨의 인터페이스가 적합합니다. Java Platform Debugger Architecture 의 상세한 것에 대하여는,<a href="http://java.sun.com/products/jpda/">Java Platform Debugger Architecture 의 Web 사이트</a>를 참조해 주세요.  
<h4 id="writingAgents">에이전트의 작성</h4>
에이전트의 작성에는, 각종 규칙과 C/C++ 의 정의를 호출하는 C 언어를 지원하는 임의의 네이티브 언어를 사용할 수 있습니다.
    <p></p>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 를 사용하기 위해서 필요한 함수, 이벤트, 데이터형, 정수의 정의는, 인클루드 파일 <code>jvmti.h</code> 로 정의됩니다. 이러한 정의를 사용하려면 , J2SE<sup style="font-size: xx-small">TM</sup> 인클루드 디렉토리를 인클루드 패스에 추가해,
    <blockquote>
<pre>
#include &lt;jvmti.h&gt;
    </pre>
</blockquote>
(을)를 원시 코드에 추가해 주세요.
<h4 id="deployingAgents">에이전트의 배치</h4>
에이전트는 플랫폼 고유의 방법으로 배치됩니다만, 일반적으로은 그 플랫폼에서 다이나믹 라이브러리에 상당하는 것이 됩니다. 예를 들어, Windows<sup style="font-size: xx-small">TM</sup>  operating system의 경우, 에이전트 라이브러리는 「동적 링크 라이브러리」(DLL)이 됩니다. Solaris<sup style="font-size: xx-small">TM</sup> 오퍼레이팅(operating) 환경의 경우, 에이전트 라이브러리는 공유 객체 (<code>. so</code> 파일)이 됩니다.
    <p></p>
VM 기동시에 에이전트를 기동하려면 ,<a href="#starting">커멘드행 옵션</a>을 사용해 에이전트 라이브러리의 이름을 지정합니다. 구현에 따라서는, 라이브<a href="#GetPhase">단계</a>에서<a href="#onattach">에이전트를 기동</a>하는 기구를 지원하고 있을 가능성이 있습니다. 그 기동 방법의 자세한 것은, 구현에 고유가 됩니다.
<h4 id="starting">JVMTI 에이전트의 커멘드행 옵션</h4>
이하의 「커멘드행 옵션」이라고 하는 말은, JNI 호출 API 의 <code>JNI_CreateJavaVM</code> 함수에 대해,<code>JavaVMInitArgs</code> 인수로 지정되는 옵션을 의미합니다.
    <p></p>
에이전트를 적절히 로드해 실행하려면 , VM 의 기동시에 다음의 몇개의 커멘드행 옵션이 필요합니다. 이러한 인수는, 에이전트를 포함한 라이브러리와 기동시에게 건네지는 옵션의 캐릭터 라인을 지정합니다.  
    <dl>
      
<dt>
<code>-agentlib:</code><i>&lt;agent-lib-name&gt;</i><code>=</code><i>&lt;options&gt;</i>
</dt>
      
<dd>
	<code>-agentlib:</code> 의 뒤에는, 로드하는 라이브러리의 이름을 지정합니다. 라이브러리의 풀네임과 장소의 검색 방법은, 플랫폼에 따라서 다릅니다. 일반적으로,<i>&lt;agent-lib-name&gt;</i> 는,  operating system 고유의 파일명에 전개됩니다. <i><options></i> (은)는, 기동시에 에이전트에게 건네집니다. 예를 들어, 옵션 <code>-agentlib:foo=opt1, opt2</code> 가 지정되었을 경우, VM 는, Windows<sup><font size="-2">TM</font></sup> 에서는 시스템 패스 <code>PATH</code> 로부터 공유 라이브러리 <code>foo.dll</code> 를 로드하려고 합니다. Solaris<sup><font size="-2">TM</font></sup> 오퍼레이팅(operating) 환경에서는,<code>LD_LIBRARY_PATH</code> 로부터 <code>libfoo.so</code> 를 로드하려고 합니다.
      </dd>
      
<dt>
<code>-agentpath:</code><i>&lt;path-to-agent&gt;</i><code>=</code><i>&lt;options&gt;</i>
</dt>
      
<dd>
	<code>-agentpath:</code> 의 뒤에는, 라이브러리를 로드하는 절대 패스를 지정합니다. 라이브러리명의 전개는 행해지지 않습니다. <i><options></i> (은)는, 기동시에 에이전트에게 건네집니다. 예를 들어, 옵션 <code>-agentpath:c:\myLibs\foo.dll=opt1, opt2</code> 가 지정되었을 경우, VM 는, 공유 라이브러리 <code>c:\myLibs\foo.dll</code> 를 로드하려고 합니다.
      </dd>
    
</dl>
라이브러리내의 기동 루틴 <a href="#onload"><code>Agent_OnLoad</code></a>  가 불려 갑니다.
    <p></p>
<a href="#bci">바이트코드Instrumentation (bytecode instrumentation)</a>  을 위해서(때문에) 필요한 경우, 툴내에서 Java 프로그램 언어 코드를 사용하기 쉽게하기 위해(때문에),<code>-agentlib:</code> 또는 <code>-agentpath:</code> 를 지정해 로드 된 라이브러리로부터, JNI 네이티브 메소드 구현이 검색됩니다.
    <p></p>
에이전트 라이브러리는, 그 외의 모든 라이브러리가 검색된 뒤 검색됩니다. 비에이전트 메소드의 네이티브 메소드 구현을 덧쓰기 또는 차단하는 에이전트는,<a href="#NativeMethodBind">NativeMethodBind 이벤트</a>를 사용할 수 있습니다.
    <p></p>
이러한 스윗치는, 상기의 처리만을 실시합니다. VM 나 JVM<small style="font-size: xx-small">&nbsp;</small>TI 상태를 변경할 것은 없습니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 나 JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 일부를 유효하게 하는 처리는,<a href="#capability">권한 (capability)</a>  에 의해, 프로그램을 통해 행해집니다. 커멘드행 옵션은 필요 없습니다.
<h4 id="startup">에이전트의 기동</h4>
VM 는, 기동 함수를 호출하는 것으로 각 에이전트를 기동합니다. <code>OnLoad</code> <a href="#GetPhase">단계</a>에서 에이전트를 기동하는 경우는, 함수 <a href="#onload"><code>Agent_OnLoad</code></a>  가 불려 갑니다. 라이브<a href="#GetPhase">단계</a>에서 에이전트를 기동하는 경우는, 함수 <a href="#onattach"><code>Agent_OnAttach</code></a>  가 불려 갑니다. 기동 함수의 호출은, 에이전트 마다 1 회만 행해집니다.   
<h4 id="onload">에이전트의 기동 (OnLoad 단계)</h4>
<code>OnLoad</code> 단계에서 에이전트를 기동하는 경우, 그 에이전트 라이브러리는 다음의 prototype를 가지는 기동 함수를 export 할 필요가 있습니다.
    <blockquote>
<pre>
JNIEXPORT jint JNICALL 
Agent_OnLoad(JavaVM *vm, char *options, void *reserved)</pre>
</blockquote>
VM 는, 이 함수를 호출하는 것으로 에이전트를 기동합니다. 이 호출은 VM 초기화의 빠른 단계에서 행해지기 (위해)때문에, 다음 일을 말할 수 있습니다.
    <ul type="disc">
      
<li>
<a href="#SetSystemProperty">시스템 프로퍼티</a>은,VM 의 기동으로 사용되기 전으로 설정할 수 있다</li>
      
<li>모든<a href="#capability">권한</a>을 사용할 수 있다 (다만, VM 를 구성하는 권한은 이 때 밖에 사용할 수 없다.  자세한 것은<a href="#capability">「권한 함수」섹션</a>을 참조)</li>
      
<li>바이트 코드가 실행되어 있지 않다</li>
      
<li>클래스가 로드되어 있지 않다</li>
      
<li>객체가 작성되어 있지 않다</li>
    
</ul>
    
<p></p>
VM 는, 2 번째의 인수로서 <i><options></i> 를 지정해 <code>Agent_OnLoad</code> 함수를 호출합니다. 즉, 커멘드행 옵션의 예를 사용해,<code>"opt1, opt2"</code> 는 <code>Agent_OnLoad</code> 의 <code>char *options</code> 인수에게 건네집니다. <code>options</code> 인수는,<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 됩니다. <i>=<options></i> 하지만 지정되어 있지 않은 경우,<code>options</code> 에는 길이 0 의 캐릭터 라인이 건네받습니다. <code>options</code> 캐릭터 라인은,<code>Agent_OnLoad</code> 호출동안 유효합니다. 필요한 경우는, 이 기간이 지나도, 캐릭터 라인 또는 캐릭터 라인의 일부를 카피할 필요가 있습니다. <code>Agent_OnLoad</code> 가 불려 가고 나서 종료할 때까지의 기간을 「로드 단계」라고 부릅니다. VM 는 로드<a href="#GetPhase">단계</a>에서는 초기화되지 않습니다. 이 때문에,<code>Agent_OnLoad</code> 내부에서 허가된 조작은 한정되고 있습니다 (이 시점에서 사용 가능한 기능에 대해서는 함수의 설명을 참조). 에이전트를 안전하게 실행할 수 있는 것은, 옵션의 처리나,<a href="#SetEventCallbacks"><code>SetEventCallbacks</code></a>  를 사용해 이벤트 콜백을 설정하는 처리입니다. VM 초기화 이벤트를 받고 나서 (즉,<a href="#VMInit">VMInit</a>  콜백이 불려 가고 나서), 에이전트는 초기화를 완료할 수 있습니다.
    <p style="color: purple">
원리의 설명:
      
빠른 단계에서의 기동이 필요한 것은, 에이전트가 필요한 권한을 설정할 수 있도록(듯이) 하기 (위해)때문에입니다. 많은 권한은, VM 의 초기화전으로 설정할 필요가 있습니다. JVMDI 에서는, -Xdebug 커멘드행 옵션으로 권한을 제어할 수 있었습니다. 다만, 이 제어는 매우 대범한 것입니다. JVMPI 구현은, 다양한 테크닉을 사용해 단일의 「JVMPI 온」스윗치를 제공합니다. 필요한 권한과 퍼포먼스에의 영향의 밸런스를 취하기 위해서(때문에) 필요한 세세한 제어를 제공하는데 적합한 커멘드행 옵션은 없습니다. 빠른 단계에서의 기동에는, 에이전트가 각종 기능을 인스톨 하기 위한(해), 파일 시스템이나 시스템 프로퍼티으로 변경을 더해 실행 환경을 제어할 수 있도록(듯이) 하는 목적도 있습니다.
    </p>
    
<p></p>
<code>Agent_OnLoad</code> 의 반환값은, 에러를 나타내기 위해서(때문에) 사용됩니다. 제로 이외의 값은 에러를 나타냅니다. 에러가 발생하면(자), VM 는 종료합니다.
<h4 id="onattach">에이전트의 기동 (라이브 단계)</h4>
VM 에 따라서는, 그 VM 내에서 라이브<a href="#GetPhase">단계</a>에서 에이전트를 기동하는 기구를 지원하고 있을 가능성이 있습니다. 그 지원 방법의 자세한 것은, 구현에 고유가 됩니다. 예를 들어, 어느 툴에서는, 하등의 플랫폼 고유의 기구나 구현 고유의 API 를 사용하는 것으로, 실행중의 VM 에 접속해 특정의 에이전트의 기동을 요구할 가능성이 있습니다.
    <p></p>
라이브 단계에서 에이전트를 기동하는 경우, 그 에이전트 라이브러리는 다음의 prototype를 가지는 기동 함수를 export 할 필요가 있습니다.
    <blockquote>
<pre>
JNIEXPORT jint JNICALL 
Agent_OnAttach(JavaVM* vm, char *options, void *reserved)</pre>
</blockquote>
    
<p></p>         
VM 는, 이 함수를 호출하는 것으로 에이전트를 기동합니다. 이 호출은, VM 에 접속된 thread의 문맥내에서 행해집니다. 제 1 인수의 것 <i><vm></i> 은, Java VM 입니다. <i><options></i> 인수는, 에이전트로 지정된 기동 옵션입니다. <i><options></i> (은)는,<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 됩니다. 기동 옵션이 지정되지 않았던 경우,<code>options</code> 에는 길이 0 의 캐릭터 라인이 건네받습니다. <code>options</code> 캐릭터 라인은,<code>Agent_OnAttach</code> 호출동안 유효합니다. 필요한 경우는, 이 기간이 지나도, 캐릭터 라인 또는 캐릭터 라인의 일부를 카피할 필요가 있습니다.
    <p></p>
라이브 단계에서는<a href="#capability">권한</a>의 일부를 사용할 수 없을 가능성이 있습니다.
    <p></p>
<code>Agent_OnAttach</code> 함수는, 에이전트를 초기화해, 에러가 발생했는지의 여부를 나타내는 값을 VM 에 돌려줍니다. 제로 이외의 값은 모두, 에러를 나타냅니다. 에러가 발생해도 VM 는 종료하지 않습니다. 대신에 VM 는, 그 에러를 무시하는지, 그 에러를 표준 에러에 출력하거나 시스템 로그에 기록하거나 하는 등, 하등의 구현 고유의 액션을 실행합니다.
<h4 id="onunload">에이전트의 정지</h4>
라이브러리는, 옵션으로, 다음의 prototype를 가지는 정지 함수를 export 할 수 있습니다.
    <blockquote>
<pre>
JNIEXPORT void JNICALL 
Agent_OnUnload(JavaVM *vm)</pre>
</blockquote>
이 함수는, 라이브러리의 언로드의 직전에 VM 에 의해 불려 갑니다. 플랫폼 고유의 기구에 문제가 있는 경우, 언로드가 일으켜져 이 함수가 불려 갑니다 (본서에서는 언로드 기구는 지정하지 않는다). 정상적인 처리 혹은 VM 의 장해 (기동시의 장해를 포함한다)에 의해 VM 가 종료되었을 경우, 라이브러리는 실제로 언로드됩니다. 물론, 제어할 수 없는 정지는, 이 규칙에 들어맞지 않습니다. 이 함수와 <a href="#VMDeath">VM Death 이벤트</a>에는 차이가 있습니다. VM Death 이벤트를 송신하기 위해서는, 초기화전에 VM 를 실행했던 적이 있어, VMDeath 의 콜백을 설정한 유효한 JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경이 존재해, 이벤트가 유효하게 되어 있을 필요가 있습니다. 이러한 조건은,<code>Agent_OnUnload</code> 에는 불필요합니다. 이 함수는, 라이브러리가 그 외의 이유에 의해 언로드되었을 때도 불려 갑니다. VM Death 이벤트는, 이 함수가 불려 가기 전에 송신됩니다 (이 함수가 VM 의 종료에 의해 불려 가는 경우). 이 함수를 사용해, 에이전트에 의해 할당할 수 있었던 자원을 클린 업 할 수가 있습니다.
<h4 id="tooloptions">JAVA_TOOL_OPTIONS</h4>
매입 VM 나 단지 스크립트내의 깊은 장소에서 기동되는 VM 등에서는, 커멘드행의 액세스나 변경이 항상 가능하다라고는 한정되지 않기 때문에,<code>JAVA_TOOL_OPTIONS</code> 변수가 준비되어 있습니다. 이것을 사용하면, 그러한 경우에서도 에이전트를 기동할 수 있습니다.
    <p></p>
환경 변수나 그 외의 이름 첨부 캐릭터 라인을 지원하는 플랫폼에서는,<code>JAVA_TOOL_OPTIONS</code> 변수에 대응하고 있는 경우가 있습니다. 이 변수는, 옵션을 공백 문자로 단락지은 캐릭터 라인입니다. 공백 문자에는, 스페이스, 탭, 복귀 (CR), 복귀 개행 (NL), 수직 탭, 용지 보내 (FF)등이 있습니다. 연속하는 공백 문자는 공백 문자 1 문자와 같다라고 보입니다. 옵션에 공백 문자를 포함하는 경우는, 인용부호로 다음과 같이 둘러싸 주세요.
    <ul type="disc">
        
<li>홑겹 인용부호의 조 ('')에 둘러싸인, 홑겹 인용부호를 제외한 모든 문자는 인용으로서 둘러싸인다. </li>
        
<li>홑겹 인용부호의 조의 내부에 있는 이중 인용부호에는, 특수한 의미는 없다. </li>
        
<li>이중 인용부호의 조 ('')에 둘러싸인, 이중 인용부호를 제외한 모든 문자는 인용으로서 둘러싸인다. </li>
        
<li>이중 인용부호의 조의 내부에 있는 홑겹 인용부호에는, 특수한 의미는 없다. </li>
        
<li>변수내의 임의의 장소를 인용부호로 둘러쌀 수가 있다. </li>
        
<li>인용부호로 둘러싸인 공백 문자에는, 특수한 의미는 없다. 그 외의 문자와 같게 옵션에 포함할 수가 있어 단락 문자로서 기능하지 않는다. </li>
        
<li>인용부호의 조자체는 옵션에 포함되지 않는다. </li>
    
</ul>
    
<code>JNI_CreateJavaVM</code> (JNI 호출 API 내)는, 이러한 옵션을 그 <code>JavaVMInitArgs</code> 인수로 지정된 옵션의 선두에 부가합니다. 플랫폼에 따라서는, 시큐리티상의 이유로써 이 기능을 무효로 하고 있습니다. 예를 들어 레퍼런스 구현에서는, 유효한 사용자 또는 그룹의 ID 가 실제의 ID 와 다른 경우에, Unix 시스템상에서 이 기능이 무효가 됩니다.  이 기능은 툴의 초기화, 특히 네이티브 또는 Java 프로그램 언어 에이전트의 기동을 지원하기 위한의 것입니다. 복수의 툴로 이 기능을 사용할 가능성이 있습니다. 그 때문에, 변수는 덧쓰기하지 않고, 옵션을 변수에 추가하도록 해 주세요. 변수가 처리되는 것은 JNI 호출 API 의 VM 작성 호출시이기 (위해)때문에, 기동측이 처리하는 옵션 (VM 선택 옵션등)은 다루어지지 않습니다.
<h4 id="environments">JVMTI 환경</h4>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 스펙은, 동시에 복수의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 에이전트를 사용하는 것을 허가합니다. 각 에이전트에는 고유의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경을 할당할 수 있습니다. 즉, JVM<small style="font-size: xx-small">&nbsp;</small>TI 상태는 에이전트 마다 차이가 납니다. 어느 환경으로 변경을 더해도, 그 외의 환경에 영향은 없습니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경에는, 다음 상태가 있습니다.
    <ul type="disc">
      
<li>
<a href="#SetEventCallbacks">이벤트 콜백</a> 
</li>
      
<li>
<a href="#SetEventNotificationMode">유효한 이벤트세트</a> 
</li>
      
<li>
<a href="#capability">권한</a> 
</li>
      
<li>
<a href="#memory">메모리의 할당/할당 해제 훅</a> 
</li>
    
</ul>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 상태는 독립하고 있습니다만, 에이전트는 VM 의 공유 상태를 검사해, 변경합니다. 또, 에이전트가 실행되는 네이티브 환경을 공유합니다. 이 때문에, 어느 에이전트가 그 외의 에이전트의 실행 결과에 영향을 미치거나 그 외의 에이전트의 실패의 원인이 되는 일이 있습니다. 에이전트의 작성자에게는, 이 에이전트와 그 외의 에이전트와의 호환성의 레벨을 지정할 책임이 있습니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 구현은, 에이전트간의 악영향을 막을 수 없습니다. 이러한 문제의 발생을 막는 기술에 대해서는, 본서에서는 설명하지 않습니다.
    <p></p>
에이전트는, JNI 호출 API 함수 <a href="http://java.sun.com/javase/6/docs/technotes/guides/jni/spec/invocation.html#GetEnv">GetEnv</a>  에 인터페이스 ID 로서 JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 버젼 정보를 건네주는 것에 의해, JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경을 작성합니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경의 작성과 사용의 상세한 것에 대하여는,<a href="#jvmtiEnvAccess">「JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수의 액세스」</a>를 참조해 주세요. 일반적으로, JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경은,<a href="#onload"><code>Agent_OnLoad</code></a>  로부터 <code>GetEnv</code> 를 호출하는 것에 의해 작성됩니다.
<h4 id="bci">바이트코드Instrumentation</h4>
이 인터페이스는, 프로 파일링을 지원하는 인터페이스로 발생하는 이벤트의 일부를 포함하지 않습니다. 해당하는 이벤트로서 객체 할당 이벤트나 풀 스피드 메소드 입력/출력 이벤트가 있습니다. 이 인터페이스는, 타겟 프로그램을 구성하는 Java 가상 머신의 바이트 코드 명령을 변경하는 「바이트코드Instrumentation (bytecode instrumentation)」기능을 지원합니다. 일반적으로, 이러한 변경에서는, 메소드의 코드에 「이벤트」가 추가됩니다. 예를 들어, 메소드의 선두에,<code>MyProfiler.methodEntered()</code> 의 호출이 추가됩니다. 변경은 순수하게 추가이기 (위해)때문에, 어플리케이션 상태나 동작을 변경할 필요는 없습니다. 삽입되는 에이전트 코드는 표준 바이트 코드이므로, VM 를 풀 스피드로 실행할 수 있습니다. 이 때문에, 타겟 프로그램 뿐만이 아니라, Instrumentation도 최적화됩니다. Instrumentation에 바이트 코드의 실행으로부터의 변환이 포함되지 않는 경우, 효율이 나쁜 상태의 변환은 불필요합니다. 결과적으로, 이벤트의 퍼포먼스는 높아집니다. 이 방법에서는, 에이전트를 완전하게 제어할 수 있습니다. Instrumentation은, 코드의 「중요한」부분 (최종 사용자의 코드등)에 한정 가능해, 조건부로 할 수 있습니다. Instrumentation은, 완전하게 Java 프로그램 언어 코드내에서 실행할 수 있습니다. 또는, 네이티브 에이전트내에서 호출할 수도 있습니다. Instrumentation은, 카운터를 보관 유지할 뿐(만큼)의 설정으로 해도, 이벤트의 통계 샘플을 취하는 설정으로 해도 괜찮습니다.
    <p></p>  
Instrumentation의 삽입은, 다음의 3 으로 우리 가운데 몇개의 방법으로 실시합니다.
    <ul type="disc">
      
<li>
	정적 Instrumentation: 클래스 파일은 VM 에 로드하기 전에 계측 됩니다. 이 때문에, 예를 들어, Instrumentation을 추가하기 위해서 변경되었다 <code>*. class</code> 파일의 중복 디렉토리를 작성할 수 있습니다. 이 방법은 매우 귀찮습니다. 일반적으로, 에이전트는 로드 되는 클래스 파일의 출처(소)를 인식하지 않습니다.
      </li>
      
<li>
	로드시의 Instrumentation: 클래스 파일이 VM 에 로드 될 때, 클래스 파일의 raw 바이트는, Instrumentation용으로서 에이전트에 송신됩니다. 클래스의 로드에 의해 발생한 <a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>  이벤트가, 이 기능을 제공합니다. 이 방법은 효율이 좋고, 1 회 한정의 Instrumentation에 완전하게 액세스 할 수 있습니다.
      </li>
      
<li>
	동적 Instrumentation: 벌써 로드 되어 경우에 따라서는 실행되고 있는 일도 있는 클래스를 변경합니다. 이 옵션 기능은,<a href="#RetransformClasses"><code>RetransformClasses</code></a>  함수의 호출에 의해 발생한 <a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>  이벤트에 의해 제공됩니다. 클래스는 몇회에서도 변경할 수 있습니다. 원 상태에 되돌리는 것도 간단합니다. 이 방법에서는, 실행중의 Instrumentation의 변경이 가능합니다.
      </li>
    
</ul>
    
<p></p>  
이 인터페이스에 준비된 클래스 변경 기능은, Instrumentation의 기구를 제공해 (<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>  이벤트와 <a href="#RetransformClasses"><code>RetransformClasses</code></a>  함수), 개발시에는 수정하면서 debug를 계속해 가는 (<a href="#RedefineClasses"><code>RedefineClasses</code></a>  함수) 위해(때문에) 준비되어 있습니다.
    <p></p>  
의존관계(dependencies)가 혼란하지 않게, 특히 코어 클래스를 계측 하는 경우는, 주의가 필요합니다. 예를 들어, 각 객체 할당의 통지를 받는 어프로치에서는,<code>Object</code> 로 생성자 을 계측 합니다. 생성자 이 처음은 빈 상태(empty)이다고 하면(자), 이 생성자 을 다음과 같이 변경합니다.
    <blockquote>
<pre>
      public Object() {
        MyProfiler.allocationTracker(this);
      }
    </pre>
</blockquote>
그러나,<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>  이벤트를 사용해 이 변경을 실시했을 경우는, 일반적으로의 VM 에 다음과 같은 영향이 있습니다. 최초로 작성된 객체가 생성자 을 호출해,<code>MyProfiler</code> 의 클래스가 로드 됩니다.  이것에 의해 객체가 작성됩니다만,<code>MyProfiler</code> 는 아직 로드되어 있지 않기 때문에, 무한 회귀가 발생해 버려, 스택 오버플로우가 됩니다. 이것을 변경해, 안전한 타이밍이 될 때까지 트랙킹 메소드의 호출을 늦춥니다. 예를 들어 <code>trackAllocations</code> 를 <code>VMInit</code> 이벤트의 핸들러로 설정할 수가 있습니다.
    <blockquote>
<pre>
      static boolean trackAllocations = false;

      public Object() {
        if (trackAllocations) {
          MyProfiler.allocationTracker(this);
        }
      }
    </pre>
</blockquote>
    
<p></p>
<a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>  를 사용하면, 래퍼 메소드에 의한 네이티브 메소드의 계측이 가능해집니다.
<h4 id="mUTF">수정 UTF-8 의 캐릭터 라인 인코딩</h4>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 는, 수정 UTF-8 를 사용해 캐릭터 라인을 encode 합니다. 이것은, JNI 가 사용하는 것과 같은 인코딩입니다. 수정 UTF-8 와 표준의 UTF-8 와의 차이는, 보조 문자와 null 문자의 표현 방법에 있습니다. 상세한 것에 대하여는, JNI 스펙의 <a href="http://java.sun.com/javase/6/docs/technotes/guides/jni/spec/types.html#wp16542">「Modified UTF-8 Strings」</a>섹션을 참조해 주세요.
<h4 id="context">스펙의 문맥</h4>
이 인터페이스는 Java 가상 머신으로 실행되는 어플리케이션 상태에 액세스 하기 위한(해), 용어는 Java<sup><font  size="-2">TM</font></sup> 플랫폼에 관한 것이며, 특히 언급하고 있는 경우를 제외해 네이티브 플랫폼에 관한 것이 아닙니다. 예를 나타냅니다.
    <ul type="disc">
      
<li>「thread」는 Java<sup><font size="-2">TM</font></sup> 프로그램 언어의 thread를 의미한다. </li>
      
<li>「스택 프레임」은 Java 가상 머신의 스택 프레임을 의미한다. </li>
      
<li>「클래스」는 Java 프로그램 언어의 클래스를 의미한다. </li>
      
<li>「heap」는 Java 가상 머신의 heap를 의미한다. </li>
      
<li>「모니터」는 Java 프로그램 언어의 객체 모니터를 의미한다. </li>
    
</ul>
    
<p></p>
Sun, Sun Microsystems, Sun 의 로고, Java, 및 JVM 는, 미국 및 그 외의 나라에 있어서의 미국 Sun Microsystems, Inc.  의 등록상표입니다.
  <p id="FunctionSection"></p>
<p></p>
<hr noshade="noshade" size="3">
<h2>함수</h2>
<h4 id="jvmtiEnvAccess">JVMTI 함수의 액세스</h4>
native code는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수를 호출해 JVM<small style="font-size: xx-small">&nbsp;</small>TI 기능에 액세스 합니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수에는,<a href="http://java.sun.com/javase/6/docs/technotes/guides/jni/spec/design.html">Java Native Interface (JNI) 함수</a>의 액세스시와 같게, 인터페이스 포인터를 사용해 액세스 합니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 인터페이스 포인터를 「환경 포인터」라고 부릅니다. <i></i>
    <p></p>
환경 포인터는,<code>jvmtiEnv*</code> 형의 환경에의 포인터입니다. 환경에는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 접속에 관한 정보가 있습니다. 환경내의 최초의 값은, 함수 테이블에의 포인터입니다. 함수 테이블은, JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수에의 포인터의 배열입니다. 어느 함수 포인터도 배열내의 사전에 정의된 오프셋(offset)에 있습니다.  
    <p></p>
C 언어로부터 사용되는 경우: 함수에의 액세스시에 이중 간접 지정이 사용됩니다. 즉 환경 포인터는, 문맥을 제공함과 함께, 각 함수 호출의 최초의 파라미터가 됩니다. 다음에 예를 나타냅니다.
    <blockquote>
<pre>
jvmtiEnv *jvmti;
...
jvmtiError err = (*jvmti)->GetLoadedClasses(jvmti, &class_count, &classes);
    </pre>
</blockquote>
    
<p></p>
C++ 언어로부터 사용되는 경우: 각 함수는 <code>jvmtiEnv</code> 의 멤버 함수로서 액세스 되어 환경 포인터가 함수 호출에게 건네질 것은 없습니다. 다음에 예를 나타냅니다.
    <blockquote>
<pre>
jvmtiEnv *jvmti;
...
jvmtiError err = jvmti->GetLoadedClasses(&class_count, &classes);
    </pre>
</blockquote>
특히 지정하지 않는 한, 이 스펙에 포함되는 예나 선언은 모두, C 언어를 사용하고 있습니다.
    <p></p>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경은, JNI 호출 API 의 <code>GetEnv</code> 함수를 사용해 취득할 수 있습니다.
    <blockquote>
<pre>
jvmtiEnv *jvmti;
...
(*jvm)->GetEnv(jvm, &jvmti, JVMTI_VERSION_1_0);
    </pre>
</blockquote>
<code>GetEnv</code> 를 호출할 때마다, 새로운 JVM<small style="font-size: xx-small">&nbsp;</small>TI 접속이 작성되어 새로운 JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경이 작성됩니다. <code>GetEnv</code> 는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 판의 <code>version</code> 인수를 필요로 합니다. 반환되는 환경의 버젼이 요구된 버젼과 다르고 있어도, 요구된 버젼과 호환성이 있으면, 문제는 없습니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 가 지원되어 있지 않은지, 현재의 VM 구성으로 JVM<small style="font-size: xx-small">&nbsp;</small>TI 가 지원되어 있지 않은 경우, 호환 버젼을 얻을 수  없으면<code>GetEnv</code> 는 <code>JNI_EVERSION</code> 를 돌려줍니다. 특정의 문맥에서는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경을 작성하기 위해서 그 외의 인터페이스를 추가할 수 있습니다. 각 환경에는, 고유 상태가 있습니다. 예를 들어,<a href="#SetEventNotificationMode">필수 이벤트</a>,<a href="#SetEventCallbacks">이벤트 처리 함수</a>,<a href="#AddCapabilities">권한 </a>등입니다. 환경은,<a href="#DisposeEnvironment"><code>DisposeEnvironment</code></a>  에 의해 릴리스 됩니다. 이 때문에, thread 마다 환경을 가지는 JNI 과는 달리, JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경은 동적으로 작성되어 복수의 thread에 걸쳐 기능합니다.
<h4 id="functionReturn">함수의 반환값</h4>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수는, 항상 <a href="#jvmtiError"><code>jvmtiError</code></a>  함수의 반환값으로부터<a href="#ErrorSection">에러 코드</a>를 돌려줍니다. 함수에 따라서는, 호출측의 함수로 지정된 포인터에 의해, 이외의 값을 돌려주는 일도 가능합니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 함수안에는 메모리를 할당하는 것이 있습니다만, 이 경우는 프로그램내에서 그 메모리를 명시적으로 해제하지 않으면 안됩니다. 이것에 대해서는, 개개의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수의 설명에 명기되어 있습니다. 빈 상태(empty)의 리스트, 배열, 순서 등은,<code>NULL</code> 로서 돌려주어집니다.
    <p></p>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수가 에러에 조우했을 경우는 (반환값이 <code>JVMTI_ERROR_NONE</code> 이외), 인수 포인터에 의해 참조되는 메모리치는 미정도리입니다. 그러나, 메모리 및 글로벌 참조는 아무것도 할당할 수 없습니다. 무효인 입력에 의해 에러가 발생했을 경우, 액션은 발생하지 않습니다.
<h4 id="refs">JNI 객체 참조의 관리</h4>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수는, JNI 참조 (<a href="#jobject"><code>jobject</code></a>  와 <a href="#jclass"><code>jclass</code></a> )와 그 파생 (<a href="#jthread"><code>jthread</code></a>  와 <a href="#jthreadGroup"><code>jthreadGroup</code></a> )에 의해 객체를 식별합니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 함수에게 건네지는 참조는, 글로벌에서도 로컬에서도 괜찮습니다가, 강한 참조가 아니면 안됩니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수로부터 반환되는 모든 참조는, 로컬 참조입니다. 이러한 로컬 참조는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 호출시에 작성됩니다. 로컬 참조는, 관리 대상으로 해야 할 자원입니다 (<a href="http://java.sun.com/javase/6/docs/guide/jni/spec/functions.html#wp18654">JNI 의 메뉴얼</a>을 참조). thread가 native code로부터 반환되는 경우, 모든 로컬 참조는 해제됩니다. 전형적인 에이전트 thread를 포함한 일부의 thread는, 결코 native code로부터는 돌려주어지지 않습니다. 각 thread는, 명시적 관리없이 16 개의 로컬 참조를 작성할 수가 있습니다. native code로부터 돌려주어지기 전에, 한정된 수의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 호출을 실행하는 thread (이벤트 처리 thread등)의 경우, 명시적 관리는 불필요하다라고 판단됩니다. 그러나, 장시간 실행되는 에이전트 thread는, 명시적 로컬 참조 관리를 필요로 합니다. 일반적으로, 이 관리에는, JNI 함수 <code>PushLocalFrame</code> 와 <code>PopLocalFrame</code> 를 사용합니다. 반대로 말하면, native code로부터 반환된 뒤도 참조를 보존하는 경우는, 글로벌 참조로 변환할 필요가 있습니다. 이러한 규칙은 <a href="#jmethodID"><code>jmethodID</code></a>  와 <a href="#jfieldID"><code>jfieldID</code></a>  에는 적용되지 않습니다. 이것들은 <a href="#jobject"><code>jobject</code></a>  는 아니기 때문입니다.
<h4 id="prereqState">함수 호출의 필요 조건</h4>
함수에, thread 또는 VM 를 특정 상태 (중단등)로 하는 것은 에이전트이라고 명시적으로 지정되어 있지 않은 한, 함수를 실행하기 위해서 VM 를 일정한 안전한 상태로 하는 것은, JVM<small style="font-size: xx-small">&nbsp;</small>TI 구현이 됩니다.
<h4 id="functionsExceptions">예외와 함수</h4>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수는 예외를 throw 하지 않습니다. 에러 상태의 전달은,<a href="#functionReturn">함수의 반환값</a>을 개입시켜 행해집니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수가 불려 가도, 그 전후로 기존의 예외 상태는 모두 보관 유지됩니다. 예외의 처리 방법에 대해서는, JNI 스펙의 <a href="http://java.sun.com/javase/6/docs/technotes/guides/jni/spec/design.html#wp770">「Java Exceptions」</a>섹션을 참조해 주세요.
<h3 id="FunctionIndex">함수의 색인</h3>
<ul>
<li>
<a href="#memory"><b>메모리 관리</b></a> 
<ul>
<li>
<a href="#Allocate">Allocate</a> 
</li>
<li>
<a href="#Deallocate">Deallocate</a> 
</li>
</ul>
</li>
<li>
<a href="#threadCategory"><b>thread</b></a> 
<ul>
<li>
<a href="#GetThreadState">thread 상태의 취득</a> 
</li>
<li>
<a href="#GetCurrentThread">현재의 thread의 취득</a> 
</li>
<li>
<a href="#GetAllThreads">모든 thread의 취득</a> 
</li>
<li>
<a href="#SuspendThread">thread의 중단</a> 
</li>
<li>
<a href="#SuspendThreadList">threaded list의 중단</a> 
</li>
<li>
<a href="#ResumeThread">thread의 재개</a> 
</li>
<li>
<a href="#ResumeThreadList">threaded list의 재개</a> 
</li>
<li>
<a href="#StopThread">thread의 정지</a> 
</li>
<li>
<a href="#InterruptThread">thread의 인터럽트</a> 
</li>
<li>
<a href="#GetThreadInfo">thread 정보의 취득</a> 
</li>
<li>
<a href="#GetOwnedMonitorInfo">소유 모니터 정보의 취득</a> 
</li>
<li>
<a href="#GetOwnedMonitorStackDepthInfo">소유 모니터의 스택의 깊이 정보의 취득</a> 
</li>
<li>
<a href="#GetCurrentContendedMonitor">현재 경합 하고 있는 모니터의 취득</a> 
</li>
<li>
<a href="#RunAgentThread">에이전트 thread의 실행</a> 
</li>
<li>
<a href="#SetThreadLocalStorage">thread 로컬인 기억 영역의 설정</a> 
</li>
<li>
<a href="#GetThreadLocalStorage">thread 로컬인 기억 영역의 취득</a> 
</li>
</ul>
</li>
<li>
<a href="#thread_groups"><b>thread 그룹</b></a> 
<ul>
<li>
<a href="#GetTopThreadGroups">톱 레벨의 thread 그룹의 취득</a> 
</li>
<li>
<a href="#GetThreadGroupInfo">thread 그룹 정보의 취득</a> 
</li>
<li>
<a href="#GetThreadGroupChildren">아이 thread 그룹의 취득</a> 
</li>
</ul>
</li>
<li>
<a href="#stack"><b>스택 프레임</b></a> 
<ul>
<li>
<a href="#GetStackTrace">스택 트레이스의 취득</a> 
</li>
<li>
<a href="#GetAllStackTraces">모든 스택 트레이스의 취득</a> 
</li>
<li>
<a href="#GetThreadListStackTraces">threaded list의 스택 트레이스의 취득</a> 
</li>
<li>
<a href="#GetFrameCount">프레임 카운트의 취득</a> 
</li>
<li>
<a href="#PopFrame">프레임의 팝</a> 
</li>
<li>
<a href="#GetFrameLocation">프레임의 위치의 취득</a> 
</li>
<li>
<a href="#NotifyFramePop">프레임의 팝의 통지</a> 
</li>
</ul>
</li>
<li>
<a href="#ForceEarlyReturn"><b>조기 복귀의 강제</b></a> 
<ul>
<li>
<a href="#ForceEarlyReturnObject">조기 복귀의 강제 - 객체형</a> 
</li>
<li>
<a href="#ForceEarlyReturnInt">조기 복귀의 강제 - 정수형</a> 
</li>
<li>
<a href="#ForceEarlyReturnLong">조기 복귀의 강제 - 장 정수형</a> 
</li>
<li>
<a href="#ForceEarlyReturnFloat">조기 복귀의 강제 - 부동 소수점수(실수)형</a> 
</li>
<li>
<a href="#ForceEarlyReturnDouble">조기 복귀의 강제 - 배정밀도 부동 소수점수(실수)형</a> 
</li>
<li>
<a href="#ForceEarlyReturnVoid">조기 복귀의 강제 - void 형</a> 
</li>
</ul>
</li>
<li>
<a href="#Heap"><b>heap</b></a> 
<ul>
<li>
<a href="#FollowReferences">참조의 추적</a> 
</li>
<li>
<a href="#IterateThroughHeap">heap내에서의 반복해</a> 
</li>
<li>
<a href="#GetTag">태그의 취득</a> 
</li>
<li>
<a href="#SetTag">태그의 설정</a> 
</li>
<li>
<a href="#GetObjectsWithTags">태그를 사용한 객체의 취득</a> 
</li>
<li>
<a href="#ForceGarbageCollection">가베지 컬렉션의 강제</a> 
</li>
</ul>
</li>
<li>
<a href="#Heap_1_0"><b>heap (1.0)</b></a> 
<ul>
<li>
<a href="#IterateOverObjectsReachableFromObject">객체로부터 도달 가능한 객체의 반복</a> 
</li>
<li>
<a href="#IterateOverReachableObjects">도달 가능한 객체의 반복</a> 
</li>
<li>
<a href="#IterateOverHeap">heap의 반복</a> 
</li>
<li>
<a href="#IterateOverInstancesOfClass">클래스의 인스턴스의 반복</a> 
</li>
</ul>
</li>
<li>
<a href="#local"><b>국소 변수</b></a> 
<ul>
<li>
<a href="#GetLocalObject">국소 변수의 취득 - 객체형</a> 
</li>
<li>
<a href="#GetLocalInt">국소 변수의 취득 - 정수형</a> 
</li>
<li>
<a href="#GetLocalLong">국소 변수의 취득 - 장 정수형</a> 
</li>
<li>
<a href="#GetLocalFloat">국소 변수의 취득 - 부동 소수점수(실수)형</a> 
</li>
<li>
<a href="#GetLocalDouble">국소 변수의 취득 - 배정밀도 부동 소수점수(실수)형</a> 
</li>
<li>
<a href="#SetLocalObject">국소 변수의 설정 - 객체형</a> 
</li>
<li>
<a href="#SetLocalInt">국소 변수의 설정 - 정수형</a> 
</li>
<li>
<a href="#SetLocalLong">국소 변수의 설정 - 장 정수형</a> 
</li>
<li>
<a href="#SetLocalFloat">국소 변수의 설정 - 부동 소수점수(실수)형</a> 
</li>
<li>
<a href="#SetLocalDouble">국소 변수의 설정 - 배정밀도 부동 소수점수(실수)형</a> 
</li>
</ul>
</li>
<li>
<a href="#breakpointCategory"><b>breakpoint</b></a> 
<ul>
<li>
<a href="#SetBreakpoint">breakpoint의 설정</a> 
</li>
<li>
<a href="#ClearBreakpoint">breakpoint의 해제</a> 
</li>
</ul>
</li>
<li>
<a href="#fieldWatch"><b>감시되는 필드</b></a> 
<ul>
<li>
<a href="#SetFieldAccessWatch">필드 액세스의 감시의 설정</a> 
</li>
<li>
<a href="#ClearFieldAccessWatch">필드 액세스의 감시의 해제</a> 
</li>
<li>
<a href="#SetFieldModificationWatch">필드 변경의 감시의 설정</a> 
</li>
<li>
<a href="#ClearFieldModificationWatch">필드 변경의 감시의 해제</a> 
</li>
</ul>
</li>
<li>
<a href="#class"><b>클래스</b></a> 
<ul>
<li>
<a href="#GetLoadedClasses">로드가 끝난 클래스의 취득</a> 
</li>
<li>
<a href="#GetClassLoaderClasses">클래스 로더 클래스의 취득</a> 
</li>
<li>
<a href="#GetClassSignature">클래스의 시그니챠의 취득</a> 
</li>
<li>
<a href="#GetClassStatus">클래스의 상태의 취득</a> 
</li>
<li>
<a href="#GetSourceFileName">원시 파일명의 취득</a> 
</li>
<li>
<a href="#GetClassModifiers">클래스의 수식자의 취득</a> 
</li>
<li>
<a href="#GetClassMethods">클래스의 메소드의 취득</a> 
</li>
<li>
<a href="#GetClassFields">클래스의 필드의 취득</a> 
</li>
<li>
<a href="#GetImplementedInterfaces">구현된 인터페이스의 취득</a> 
</li>
<li>
<a href="#GetClassVersionNumbers">클래스 버젼 번호의 취득</a> 
</li>
<li>
<a href="#GetConstantPool">정수 풀의 취득</a> 
</li>
<li>
<a href="#IsInterface">인터페이스인가 어떤가의 검사</a> 
</li>
<li>
<a href="#IsArrayClass">배열 클래스인가 어떤가의 검사</a> 
</li>
<li>
<a href="#IsModifiableClass">변경 가능 클래스인가 어떤가의 검사</a> 
</li>
<li>
<a href="#GetClassLoader">클래스 로더의 취득</a> 
</li>
<li>
<a href="#GetSourceDebugExtension">소스 디버그 확장 기능의 취득</a> 
</li>
<li>
<a href="#RetransformClasses">클래스의 재변환</a> 
</li>
<li>
<a href="#RedefineClasses">클래스의 재정의</a> 
</li>
</ul>
</li>
<li>
<a href="#object"><b>객체</b></a> 
<ul>
<li>
<a href="#GetObjectSize">객체 사이즈의 취득</a> 
</li>
<li>
<a href="#GetObjectHashCode">객체의 해시 코드의 취득</a> 
</li>
<li>
<a href="#GetObjectMonitorUsage">객체의 모니터의 이용 정보를 취득</a> 
</li>
</ul>
</li>
<li>
<a href="#fieldCategory"><b>필드</b></a> 
<ul>
<li>
<a href="#GetFieldName">필드의 이름과 시그니챠의 취득</a> 
</li>
<li>
<a href="#GetFieldDeclaringClass">필드의 선언 클래스의 취득</a> 
</li>
<li>
<a href="#GetFieldModifiers">필드의 수식자의 취득</a> 
</li>
<li>
<a href="#IsFieldSynthetic">합성 필드인가 어떤가의 검사</a> 
</li>
</ul>
</li>
<li>
<a href="#method"><b>메소드</b></a> 
<ul>
<li>
<a href="#GetMethodName">메소드의 이름과 시그니챠의 취득</a> 
</li>
<li>
<a href="#GetMethodDeclaringClass">메소드의 선언 클래스의 취득</a> 
</li>
<li>
<a href="#GetMethodModifiers">메소드의 수식자의 취득</a> 
</li>
<li>
<a href="#GetMaxLocals">국소 변수의 취득</a> 
</li>
<li>
<a href="#GetArgumentsSize">인수의 사이즈의 취득</a> 
</li>
<li>
<a href="#GetLineNumberTable">행 번호 테이블의 취득</a> 
</li>
<li>
<a href="#GetMethodLocation">메소드의 배치 위치의 취득</a> 
</li>
<li>
<a href="#GetLocalVariableTable">국소 변수 테이블의 취득</a> 
</li>
<li>
<a href="#GetBytecodes">바이트 코드의 취득</a> 
</li>
<li>
<a href="#IsMethodNative">네이티브 메소드인가 어떤가의 검사</a> 
</li>
<li>
<a href="#IsMethodSynthetic">합성 메소드인가 어떤가의 검사</a> 
</li>
<li>
<a href="#IsMethodObsolete">폐기된 메소드인가 어떤가의 검사</a> 
</li>
<li>
<a href="#SetNativeMethodPrefix">네이티브 메소드 접두사의 설정</a> 
</li>
<li>
<a href="#SetNativeMethodPrefixes">복수의 네이티브 메소드 접두사의 설정</a> 
</li>
</ul>
</li>
<li>
<a href="#RawMonitors"><b>raw 모니터</b></a> 
<ul>
<li>
<a href="#CreateRawMonitor">raw 모니터의 작성</a> 
</li>
<li>
<a href="#DestroyRawMonitor">raw 모니터의 파기</a> 
</li>
<li>
<a href="#RawMonitorEnter">raw 모니터의 개시</a> 
</li>
<li>
<a href="#RawMonitorExit">raw 모니터의 종료</a> 
</li>
<li>
<a href="#RawMonitorWait">raw 모니터의 대기</a> 
</li>
<li>
<a href="#RawMonitorNotify">raw 모니터의 통지</a> 
</li>
<li>
<a href="#RawMonitorNotifyAll">raw 모니터의 통지 (모두)</a> 
</li>
</ul>
</li>
<li>
<a href="#jniIntercept"><b>JNI 함수의 차단</b></a> 
<ul>
<li>
<a href="#SetJNIFunctionTable">JNI 함수 테이블의 설정</a> 
</li>
<li>
<a href="#GetJNIFunctionTable">JNI 함수 테이블의 취득</a> 
</li>
</ul>
</li>
<li>
<a href="#eventManagement"><b>이벤트 관리</b></a> 
<ul>
<li>
<a href="#SetEventCallbacks">이벤트 콜백의 설정</a> 
</li>
<li>
<a href="#SetEventNotificationMode">이벤트 통지 모드의 설정</a> 
</li>
<li>
<a href="#GenerateEvents">이벤트의 생성</a> 
</li>
</ul>
</li>
<li>
<a href="#extension"><b>확장 기능 기구</b></a> 
<ul>
<li>
<a href="#GetExtensionFunctions">확장 함수의 취득</a> 
</li>
<li>
<a href="#GetExtensionEvents">확장 이벤트의 취득</a> 
</li>
<li>
<a href="#SetExtensionEventCallback">확장 이벤트 콜백의 설정</a> 
</li>
</ul>
</li>
<li>
<a href="#capability"><b>권한</b></a> 
<ul>
<li>
<a href="#GetPotentialCapabilities">잠재적인 권한의 취득</a> 
</li>
<li>
<a href="#AddCapabilities">권한의 추가</a> 
</li>
<li>
<a href="#RelinquishCapabilities">권한의 방폐</a> 
</li>
<li>
<a href="#GetCapabilities">기능의 취득</a> 
</li>
</ul>
</li>
<li>
<a href="#timers"><b>타이머</b></a> 
<ul>
<li>
<a href="#GetCurrentThreadCpuTimerInfo">현재의 thread의 CPU 타이머 정보를 취득</a> 
</li>
<li>
<a href="#GetCurrentThreadCpuTime">현재의 thread의 CPU 시간을 취득</a> 
</li>
<li>
<a href="#GetThreadCpuTimerInfo">thread의 CPU 타이머 정보를 취득</a> 
</li>
<li>
<a href="#GetThreadCpuTime">thread의 CPU 시간을 취득</a> 
</li>
<li>
<a href="#GetTimerInfo">타이머 정보의 취득</a> 
</li>
<li>
<a href="#GetTime">시간의 취득</a> 
</li>
<li>
<a href="#GetAvailableProcessors">사용 가능한 프로세서의 취득</a> 
</li>
</ul>
</li>
<li>
<a href="#classLoaderSearch"><b>클래스 로더 검색</b></a> 
<ul>
<li>
<a href="#AddToBootstrapClassLoaderSearch">bootstrap 클래스 로더 검색의 추가</a> 
</li>
<li>
<a href="#AddToSystemClassLoaderSearch">시스템 클래스 로더 검색의 추가</a> 
</li>
</ul>
</li>
<li>
<a href="#props"><b>시스템 프로퍼티</b></a> 
<ul>
<li>
<a href="#GetSystemProperties">시스템 프로퍼티의 취득</a> 
</li>
<li>
<a href="#GetSystemProperty">시스템 프로퍼티의 취득</a> 
</li>
<li>
<a href="#SetSystemProperty">시스템 프로퍼티의 설정</a> 
</li>
</ul>
</li>
<li>
<a href="#general"><b>전반</b></a> 
<ul>
<li>
<a href="#GetPhase">단계의 취득</a> 
</li>
<li>
<a href="#DisposeEnvironment">환경의 파기</a> 
</li>
<li>
<a href="#SetEnvironmentLocalStorage">환경 로컬 기억 영역의 설정</a> 
</li>
<li>
<a href="#GetEnvironmentLocalStorage">환경 로컬 기억 영역의 취득</a> 
</li>
<li>
<a href="#GetVersionNumber">버젼 번호의 취득</a> 
</li>
<li>
<a href="#GetErrorName">에러명의 취득</a> 
</li>
<li>
<a href="#SetVerboseFlag">장황 플래그의 설정</a> 
</li>
<li>
<a href="#GetJLocationFormat">JLocation 형식의 취득</a> 
</li>
</ul>
</li>
</ul>
<p id="memory"></p>
<hr noshade="noshade" size="3">
<h2 align="center">메모리 관리</h2>메모리 관리 함수:
  <ul>
<li>
<a href="#Allocate">Allocate</a> 
</li>
<li>
<a href="#Deallocate">Deallocate</a> 
</li>
</ul>
이러한 함수는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 기능이 사용하는 메모리의 할당/할당 해제를 행하기 위한 기능을 제공합니다. 또, 이것들을 사용하면, 에이전트의 작업 메모리를 제공할 수 있습니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 가 관리하는 메모리와 다른 메모리 할당 라이브러리 및 기구에는, 호환성이 없습니다.
    <p></p>
<hr noshade="noshade" width="100%" size="1" id="Allocate">
<h3>Allocate</h3>
<blockquote>
<pre>jvmtiError
Allocate(jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)</pre>
</blockquote>
	JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 allocater를 사용해, 메모리의 영역을 할당합니다. 할당할 수 있었던 메모리는,<a href="#Deallocate"><code>Deallocate</code></a>  에 의해 해제해 주세요.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>46</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="Allocate.size">size</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    할당하는 바이트수.
	    <p style="color: purple">
원리의 설명:
      
	      <code>jlong</code> 는 JVMDI 와의 호환성을 실현하기 위해서(때문에) 사용된다.
	    </p>
	  
</td>
</tr>
<tr>
<td><code id="Allocate.mem_ptr">mem_ptr</code></td><td><code>unsigned char**</code></td><td>
	    돌아왔을 때, 할당할 수 있었던 메모리의 선두를 가리키는 포인터. size</code> 가 제로의 경우,<code>NULL</code> 가 반환된다.
	  <p></p>에이전트는 <code>unsigned char*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>unsigned char*</code> 는, 사이즈 <code>size</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OUT_OF_MEMORY"><code>JVMTI_ERROR_OUT_OF_MEMORY</code></a> </td><td>
	  메모리 요구를 이행할 수 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#Allocate.size"><code>size</code></a>  가 제로보다 작다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#Allocate.mem_ptr"><code>mem_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="Deallocate">
<h3>Deallocate</h3>
<blockquote>
<pre>jvmtiError
Deallocate(jvmtiEnv* env,
            unsigned char* mem)</pre>
</blockquote>
	JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 allocater를 사용해,<code>mem</code> 를 해제합니다. 이 함수는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 함수에 의해 할당할 수 있어 반환된 메모리 (<a href="#Allocate"><code>Allocate</code></a>  를 사용해 할당할 수 있었던 메모리를 포함한다)를 해제하기 위해서 사용합니다. 할당할 수 있던 모든 메모리를 해제할 때까지, 메모리를 재생할 수 없습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>47</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="Deallocate.mem">mem</code></td><td><code>unsigned char
	    
          *</code></td><td>
	    할당할 수 있었던 메모리의 선두를 가리키는 포인터. [On return, the elements are set] 는 무시해도 좋다.
              
	  <p></p>에이전트는 <code>unsigned char</code> 에 배열을 건네준다. 배열의 요소의 값은 무시된다. 돌아왔을 때, 요소가 설정되어 있다. <code>mem</code> 가 <code>NULL</code> 의 경우, 호출이 무시된다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>를 돌려준다</td>
</tr>
</table>
<p id="threadCategory"></p>
<hr noshade="noshade" size="3">
<h2 align="center">thread</h2>thread 함수:
  <ul>
<li>
<a href="#GetThreadState">thread 상태의 취득</a> 
</li>
<li>
<a href="#GetCurrentThread">현재의 thread의 취득</a> 
</li>
<li>
<a href="#GetAllThreads">모든 thread의 취득</a> 
</li>
<li>
<a href="#SuspendThread">thread의 중단</a> 
</li>
<li>
<a href="#SuspendThreadList">threaded list의 중단</a> 
</li>
<li>
<a href="#ResumeThread">thread의 재개</a> 
</li>
<li>
<a href="#ResumeThreadList">threaded list의 재개</a> 
</li>
<li>
<a href="#StopThread">thread의 정지</a> 
</li>
<li>
<a href="#InterruptThread">thread의 인터럽트</a> 
</li>
<li>
<a href="#GetThreadInfo">thread 정보의 취득</a> 
</li>
<li>
<a href="#GetOwnedMonitorInfo">소유 모니터 정보의 취득</a> 
</li>
<li>
<a href="#GetOwnedMonitorStackDepthInfo">소유 모니터의 스택의 깊이 정보의 취득</a> 
</li>
<li>
<a href="#GetCurrentContendedMonitor">현재 경합 하고 있는 모니터의 취득</a> 
</li>
<li>
<a href="#RunAgentThread">에이전트 thread의 실행</a> 
</li>
<li>
<a href="#SetThreadLocalStorage">thread 로컬인 기억 영역의 설정</a> 
</li>
<li>
<a href="#GetThreadLocalStorage">thread 로컬인 기억 영역의 취득</a> 
</li>
</ul>thread의 함수형:
    <ul>
<li>
<a href="#jvmtiStartFunction">에이전트 기동 함수</a> 
</li>
</ul>thread의 형태:
    <ul>
<li>
<a href="#jvmtiThreadInfo"><code>jvmtiThreadInfo</code></a>  - thread 정보 구조체</li>
<li>
<a href="#jvmtiMonitorStackDepthInfo"><code>jvmtiMonitorStackDepthInfo</code></a>  - 모니터 스택의 깊이 정보 구조체</li>
</ul>thread의 플래그 및 정수:
    <ul>
<li>
<a href="#jvmtiThreadState">thread 상태의 플래그</a> 
</li>
<li>
<a href="#jvmtiJavaLangThreadState">java.lang.Thread.State 변환 마스크</a> 
</li>
<li>
<a href="#jvmtiThreadPriority">thread 우선 순위 정수</a> 
</li>
</ul>
    
<p></p>
<hr noshade="noshade" width="100%" size="1" id="GetThreadState">
<h3>thread 상태의 취득</h3>
<blockquote>
<pre>jvmtiError
GetThreadState(jvmtiEnv* env,
            jthread thread,
            jint* thread_state_ptr)</pre>
</blockquote>
thread 상태를 가져옵니다. thread 상태는, 이하의 일련의 질문에 답하는 것으로 압니다.
          <ul type="circle">
            
<li>
<i>활동 상태인가</i>
              
<ul type="disc">
                
<li>활동 상태는 아니다
                  <ul type="circle">
                    
<li>
<i>왠지</i>
                      
<ul type="disc">
                        
<li>신규이기 (위해)때문에</li>
                        
<li>종료했기 때문에 (<a href="#JVMTI_THREAD_STATE_TERMINATED"><code>JVMTI_THREAD_STATE_TERMINATED</code></a> )</li>
                      
</ul>
                    
</li>
                  
</ul>
                
</li>
                
<li>활동 상태 (<a href="#JVMTI_THREAD_STATE_ALIVE"><code>JVMTI_THREAD_STATE_ALIVE</code></a> )
                  <ul type="circle">
                    
<li>
<i>중단했는지</i>
                      
<ul type="disc">
                        
<li>중단했다 (<a href="#JVMTI_THREAD_STATE_SUSPENDED"><code>JVMTI_THREAD_STATE_SUSPENDED</code></a> )</li>
                        
<li>중단하고 있지 않다</li>
                      
</ul>
                    
</li>
                    
<li>
<i>인터럽트인가</i>
                      
<ul type="disc">
                        
<li>인터럽트 (<a href="#JVMTI_THREAD_STATE_INTERRUPTED"><code>JVMTI_THREAD_STATE_INTERRUPTED</code></a> )</li>
                        
<li>인터럽트가 아니다</li>
                      
</ul>
                    
</li>
                    
<li>
<i>native code내인가</i>
                      
<ul type="disc">
                        
<li>native code내 (<a href="#JVMTI_THREAD_STATE_IN_NATIVE"><code>JVMTI_THREAD_STATE_IN_NATIVE</code></a> )</li>
                        
<li>Java 프로그램 언어 코드내</li>
                      
</ul>
                    
</li>
                    
<li>
<i>어느 활동 상태인가</i>
                      
<ul type="disc">
                        
<li>실행 가능 상태 (<a href="#JVMTI_THREAD_STATE_RUNNABLE"><code>JVMTI_THREAD_STATE_RUNNABLE</code></a> )</li>
                        
<li>블록 되고 있다 (<a href="#JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER"><code>JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER</code></a> )</li>
                        
<li>대기중 (<a href="#JVMTI_THREAD_STATE_WAITING"><code>JVMTI_THREAD_STATE_WAITING</code></a> )
                          <ul type="circle">
                            
<li>
<i>대기 시간은</i>
                              
<ul type="disc">
                                
<li>미정도리 (<a href="#JVMTI_THREAD_STATE_WAITING_INDEFINITELY"><code>JVMTI_THREAD_STATE_WAITING_INDEFINITELY</code></a> )
</li>
                                
<li>정의되고 있다 (<a href="#JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT"><code>JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</code></a> )</li>
                              
</ul>
                            
</li>
                            
<li>
<i>대기 이유는</i>
                              
<ul type="disc">
                                
<li>Object.wait (<a href="#JVMTI_THREAD_STATE_IN_OBJECT_WAIT"><code>JVMTI_THREAD_STATE_IN_OBJECT_WAIT</code></a> )</li>
                                
<li>LockSupport.park (<a href="#JVMTI_THREAD_STATE_PARKED"><code>JVMTI_THREAD_STATE_PARKED</code></a> )</li>
                                
<li>sleeve중 (<a href="#JVMTI_THREAD_STATE_SLEEPING"><code>JVMTI_THREAD_STATE_SLEEPING</code></a> )</li>
                              
</ul>
                            
</li>
                          
</ul>
                        
</li>
                      
</ul>
                    
</li>
                  
</ul>
                
</li>
              
</ul>
            
</li>
          
</ul>
        
<p></p>
	대답은다음의 비트 벡터로 나타내집니다.  
	<blockquote>
<a name="jvmtiThreadState"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">thread 상태의 플래그</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_ALIVE">JVMTI_THREAD_STATE_ALIVE</code></td><td align="right">0x0001</td><td>
	    thread는 활동 상태. thread가 신규 (기동하고 있지 않다) 또는 종료했을 경우는, 0.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_TERMINATED">JVMTI_THREAD_STATE_TERMINATED</code></td><td align="right">0x0002</td><td>
	    thread는 실행을 완료했다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_RUNNABLE">JVMTI_THREAD_STATE_RUNNABLE</code></td><td align="right">0x0004</td><td>
	    thread는 실행 가능.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER">JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER</code></td><td align="right">0x0400</td><td>
	    thread는 동기 블록 또는 메소드의 입력을 대기중. 또는 <code>Object.wait()</code> 의 나중에, 동기 블록 또는 메소드의 재입력을 대기중.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_WAITING">JVMTI_THREAD_STATE_WAITING</code></td><td align="right">0x0080</td><td>
	    thread는 대기중.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_WAITING_INDEFINITELY">JVMTI_THREAD_STATE_WAITING_INDEFINITELY</code></td><td align="right">0x0010</td><td>
	    thread는 타임 아웃없이 대기중. 예를 들어 <code>Object.wait()</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT">JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</code></td><td align="right">0x0020</td><td>
	    thread는, 지정된 최대 대기 시간에 대기중. 예를 들어 <code>Object.wait(long)</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_SLEEPING">JVMTI_THREAD_STATE_SLEEPING</code></td><td align="right">0x0040</td><td>
	    thread는 sleeve중 - <code>Thread.sleep(long)</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_IN_OBJECT_WAIT">JVMTI_THREAD_STATE_IN_OBJECT_WAIT</code></td><td align="right">0x0100</td><td>
	    thread는 객체 모니터를 대기중 - <code>Object.wait</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_PARKED">JVMTI_THREAD_STATE_PARKED</code></td><td align="right">0x0200</td><td>
	    thread는 일시정지중. 예를 들어 <code>LockSupport.park</code>,<code>LockSupport.parkUtil</code>, 및 <code>LockSupport.parkNanos</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_SUSPENDED">JVMTI_THREAD_STATE_SUSPENDED</code></td><td align="right">0x100000</td><td>
	    thread가 중단되었다. <code>java.lang.Thread.suspend()</code> 또는 JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 중단 함수 (<a href="#SuspendThread"><code>SuspendThread</code></a>  등)가 thread로 불려 갔다. 이 비트가 설정되었을 경우, 그 외의 비트는, thread의 중단전 상태를 참조한다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_INTERRUPTED">JVMTI_THREAD_STATE_INTERRUPTED</code></td><td align="right">0x200000</td><td>
	    thread 인터럽트가 발생했다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_IN_NATIVE">JVMTI_THREAD_STATE_IN_NATIVE</code></td><td align="right">0x400000</td><td>
thread는 native code내에 있다. 즉, VM 또는 Java 프로그램 언어 코드에 귀환시켜지지 않았던 네이티브 메소드가 실행중.
            <p></p>
이 플래그는, VM 로 컴파일 된 Java 프로그램 언어 코드의 실행중, VM 코드의 실행중, VM 지원 코드의 실행중은 설정되지 않는 JNI 및 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수등의 네이티브 VM 인터페이스 함수는, VM 코드로서 구현하는 일도 가능.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_VENDOR_1">JVMTI_THREAD_STATE_VENDOR_1</code></td><td align="right">0x10000000</td><td>
VM 벤더가 정의한다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_VENDOR_2">JVMTI_THREAD_STATE_VENDOR_2</code></td><td align="right">0x20000000</td><td>
VM 벤더가 정의한다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_VENDOR_3">JVMTI_THREAD_STATE_VENDOR_3</code></td><td align="right">0x40000000</td><td>
VM 벤더가 정의한다.
	  </td>
</tr>
</table>
</blockquote>
다음의 정의는, JVM<small style="font-size: xx-small">&nbsp;</small>TI thread 상태를 <code>java.lang.Thread.State</code> 형식 상태로 변환하기 위해서(때문에) 사용합니다.
	<blockquote>
<a name="jvmtiJavaLangThreadState"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">java.lang.Thread.State 변환 마스크</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_MASK">JVMTI_JAVA_LANG_THREAD_STATE_MASK</code></td><td align="right">JVMTI_THREAD_STATE_TERMINATED | JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</td><td>
	    비교전에, 이 값으로 상태를 마스크 한다
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_NEW">JVMTI_JAVA_LANG_THREAD_STATE_NEW</code></td><td align="right">0</td><td>
	    <code>java.lang.Thread.State.NEW</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED">JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED</code></td><td align="right">JVMTI_THREAD_STATE_TERMINATED</td><td>
	    <code>java.lang.Thread.State.TERMINATED</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE">JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE</code></td><td align="right">JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE</td><td>
	    <code>java.lang.Thread.State.RUNNABLE</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED">JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED</code></td><td align="right">JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER</td><td>
	    <code>java.lang.Thread.State.BLOCKED</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_WAITING">JVMTI_JAVA_LANG_THREAD_STATE_WAITING</code></td><td align="right">JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY</td><td>
	    <code>java.lang.Thread.State.WAITING</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING">JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING</code></td><td align="right">JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</td><td>
	    <code>java.lang.Thread.State.TIMED_WAITING</code>
	  </td>
</tr>
</table>
</blockquote>
        
<b>규칙</b>
        
<p></p>
의문에 대한 회답은 1 개 이상은 없습니다만, 회답이 없는 것도 있습니다. 그것은 회답을 모르는지, 들어맞지 않는가, 회답의 어느 것도 올바르지 않기 때문입니다. 답은, 괄호내의 회답이 일치했을 때에만 설정됩니다. 즉, 다음의 어느쪽이든 1 개(살) 이상은 설정할 수 없습니다.
          <ul type="circle">
              
<li>
<code>JVMTI_THREAD_STATE_RUNNABLE</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_WAITING</code>
</li>
          
</ul>
<code>JVMTI_THREAD_STATE_ALIVE</code> 가 설정되어 있는 경우, J2SE<sup><font  size="-2">TM</font></sup> 준거 구현에서는, 이상중 한쪽이 항상 설정됩니다. 어느쪽이든가 설정되어 있는 경우는, 괄호에 둘러싸인 회답 <code>JVMTI_THREAD_STATE_ALIVE</code> 가 설정됩니다. 이하의 어느쪽이든 1 개(살) 이상은 설정할 수 없습니다.
          <ul type="circle">
              
<li>
<code>JVMTI_THREAD_STATE_WAITING_INDEFINITELY</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</code>
</li>
          
</ul>
<code>JVMTI_THREAD_STATE_WAITING</code> 가 설정되어 있는 경우, J2SE<sup><font  size="-2">TM</font></sup> 준거 구현에서는, 이상중 한쪽이 항상 설정됩니다. 어느쪽이든가 설정되어 있는 경우, 괄호에 둘러싸인 답 <code>JVMTI_THREAD_STATE_ALIVE</code> 및 <code>JVMTI_THREAD_STATE_WAITING</code> 가 설정됩니다. 이하의 어느쪽이든 1 개(살) 이상은 설정할 수 없습니다.
          <ul type="circle">
              
<li>
<code>JVMTI_THREAD_STATE_IN_OBJECT_WAIT</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_PARKED</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_SLEEPING</code>
</li>
          
</ul>
어느쪽이든가 설정되어 있는 경우, 괄호에 둘러싸인 회답 <code>JVMTI_THREAD_STATE_ALIVE</code> 및 <code>JVMTI_THREAD_STATE_WAITING</code> 가 설정됩니다. 또 <code>JVMTI_THREAD_STATE_SLEEPING</code> 가 설정되어 있는 경우는,<code>JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</code> 가 설정됩니다. 상태 <i>A</i> 가 상태 <i>B</i> 의 기구를 사용해 구현되고 있는 경우, 이 함수로 반환되는 것은 상태 <i>A</i> 입니다. 예를 들어 <code>Thread.sleep(long)</code> 가 <code>Object.wait(long)</code> 를 사용해 구현되고 있는 경우는, 반환되는 것은 <code>JVMTI_THREAD_STATE_SLEEPING</code> 인 채입니다. 이하는 복수 설정할 수 있습니다.
          <ul type="circle">
              
<li>
<code>JVMTI_THREAD_STATE_SUSPENDED</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_INTERRUPTED</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_IN_NATIVE</code>
</li>
          
</ul>
다만, 어느쪽이든가 설정되면(자),<code>JVMTI_THREAD_STATE_ALIVE</code> 가 설정됩니다.
        <p></p>
그리고,<code>JVMTI_THREAD_STATE_TERMINATED</code> 는 <code>JVMTI_THREAD_STATE_ALIVE</code> 가 설정될 때까지는 설정되지 않습니다.   
        <p></p>
thread 상태의 표현은, 장래의 스펙으로 확장되는 것을 고려해 설계되고 있습니다. thread 상태의 값은, 거기에 응해 사용 되는 것이 당연해, 서수로서는 사용하지 말아 주세요. 대부분의 조회는, 단일 비트를 테스트해 행해지고 있습니다.  switch 문으로 사용하는 경우는, 해당하는 비트로 상태 비트를 마스크 해 주세요. 상기로 정의되어 있지 않은 모든 비트는, 장래 사용하기 위해서 예약되고 있습니다. 현재의 스펙에 호환의 VM 에서는, 예약 비트를 0 으로 설정할 필요가 있습니다. 에이전트는 예약 비트를 무시하지 않으면 안됩니다. 예약 비트는 0 이라고 상정하지 말아 주세요. 또 그 때문에 비교에는 포함하지 말아 주세요.
        <p></p>
        
<b>례</b>
        
<p></p>
지금부터 설명하는 값은, 예약 비트와 벤더 비트를 제외하고 있습니다.
        <p></p>
<code>synchronized</code> 문으로 블록 된 thread 상태는 다음과 같이 됩니다.
        <blockquote>
<pre>
            JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER
        </pre>
</blockquote>
개시하고 있지 않는 thread 상태는 다음과 같이 됩니다.
        <blockquote>
<pre>
            0
        </pre>
</blockquote>
<code>Object.wait(3000)</code> 에 의한 thread 상태는 다음과 같이 됩니다.
        <blockquote>
<pre>
            JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_WAITING + 
                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT + 
                JVMTI_THREAD_STATE_MONITOR_WAITING
        </pre>
</blockquote>
실행 가능중에 중단된 thread 상태는 다음과 같이 됩니다.
        <blockquote>
<pre>
            JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE + JVMTI_THREAD_STATE_SUSPENDED
        </pre>
</blockquote>
        
<p></p>
        
<b>상태의 테스트</b>
        
<p></p>
대부분의 경우, thread 상태는 해당하는 상태에 대응하는 1 비트를 테스트하면 판명됩니다. 예를 들어, thread가 sleeve 상태인가 어떤가를 테스트하는 코드는 다음과 같습니다.
        <blockquote>
<pre>
	jint state;
	jvmtiError err;

	err = (*jvmti)->GetThreadState(jvmti, thread, &state);
	if (err == JVMTI_ERROR_NONE) {
	   if (state & JVMTI_THREAD_STATE_SLEEPING) {  ...
        </pre>
</blockquote>
        
<p></p>
대기중 (<code>Object.wait</code>, 일시정지중, 또는 sleeve중)의 경우는, 다음과 같습니다.
        <blockquote>
<pre>
	   if (state & JVMTI_THREAD_STATE_WAITING) {  ...
        </pre>
</blockquote>
상태에 따라서는, 복수 비트를 테스트할 필요가 있습니다.  thread가 개시하고 있지 않는지 어떤지를 테스트하는 경우 등입니다.
        <blockquote>
<pre>
	   if ((state & (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_TERMINATED)) == 0)  {  ...
        </pre>
</blockquote>
시간 지정했을 경우로 하고 있지 않은 경우의 <code>Object.wait</code> 를 구별하려면 , 다음과 같이 합니다.
        <blockquote>
<pre>
	   if (state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT)  {  
             if (state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT)  {
               printf("in Object.wait(long timeout) \n");
             } else {
               printf("in Object.wait() \n");
             }
           }
        </pre>
</blockquote>
        
<p></p>
        
<b><code>java.lang.Thread.State</code> 와의 관계</b>
        
<p></p>
<code>java.lang.Thread.getState()</code> 로부터 반환되는 <code>java.lang.Thread.State</code> 로 나타나는 thread 상태는, 이 함수로부터 반환되는 정보의 부분집합입니다. 대응하는 <code>java.lang.Thread.State</code> 는, 지정된 변환 마스크를 사용해 결정할 수 있습니다. 예를 들어, 다음의 코드는 <code>java.lang.Thread.State</code> thread 상태의 이름을 돌려줍니다.
        <blockquote>
<pre>
	    err = (*jvmti)->GetThreadState(jvmti, thread, &state);
	    abortOnError(err);
            switch (state & JVMTI_JAVA_LANG_THREAD_STATE_MASK) {
            case JVMTI_JAVA_LANG_THREAD_STATE_NEW:
              return "NEW";
            case JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED:
              return "TERMINATED";
            case JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE:
              return "RUNNABLE";
            case JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED:
              return "BLOCKED";
            case JVMTI_JAVA_LANG_THREAD_STATE_WAITING:
              return "WAITING";
            case JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING:
              return "TIMED_WAITING";
            }
        </pre>
</blockquote>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>17</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetThreadState.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      조회하는 thread.  
	    
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetThreadState.thread_state_ptr">thread_state_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때,<a href="#jvmtiThreadState">thread 상태 플래그</a>의 정의에 따라 상태 플래그를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetThreadState.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetThreadState.thread_state_ptr"><code>thread_state_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetCurrentThread">
<h3>현재의 thread의 취득</h3>
<blockquote>
<pre>jvmtiError
GetCurrentThread(jvmtiEnv* env,
            jthread* thread_ptr)</pre>
</blockquote>
현재의 thread를 가져옵니다. 현재의 thread란, 이 함수를 호출한 Java 프로그램 언어 thread입니다.
        <p></p>
thread를 인수에 취하는 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수의 대부분은,<code>NULL</code> 를 현재의 thread를 의미하는 것으로서 받아들입니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>18</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetCurrentThread.thread_ptr">thread_ptr</code></td><td><code><a href="#jthread">jthread</a> *</code></td><td>
	     돌아왔을 때, 현재의 thread를 포인트 한다. 	  
<p></p>에이전트는 <code>jthread</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jthread</code> 가 설정되어 있다. <code>thread_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetCurrentThread.thread_ptr"><code>thread_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetAllThreads">
<h3>모든 thread의 취득</h3>
<blockquote>
<pre>jvmtiError
GetAllThreads(jvmtiEnv* env,
            jint* threads_count_ptr,
            jthread** threads_ptr)</pre>
</blockquote>
모든 라이브 thread를 가져옵니다. thread는, Java 프로그램 언어의 thread, 즉 VM 에 접속된 thread입니다. thread가 라이브 thread라면,<code>java.lang.Thread.isAlive()</code> 의 반환값은 <code>true</code> 가 됩니다.  이 경우, thread는, 기동된 뒤, 아직 종료하고 있습니다. thread의 영역은, JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경의 문맥에 의해 결정됩니다. 일반적으로, VM 에 접속된 모든 thread가 대상이 됩니다. 이것에는 JVM<small style="font-size: xx-small">&nbsp;</small>TI 에이전트의 thread도 포함됩니다 (<a href="#RunAgentThread"><code>RunAgentThread</code></a>  를 참조).
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>4</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetAllThreads.threads_count_ptr">threads_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, throw 되는 예외의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetAllThreads.threads_ptr">threads_ptr</code></td><td><code><a href="#jthread">jthread</a> **</code></td><td>
	      돌아왔을 때, 참조 (실행중의 thread 마다 1 개(살)씩)의 배열을 포인트 한다.
	    <p></p>에이전트는 <code>jthread*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jthread*</code> 는, 사이즈 <code>*threads_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>threads_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetAllThreads.threads_count_ptr"><code>thread_count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetAllThreads.threads_ptr"><code>threads__ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SuspendThread">
<h3>thread의 중단</h3>
<blockquote>
<pre>jvmtiError
SuspendThread(jvmtiEnv* env,
            jthread thread)</pre>
</blockquote>
지정된 thread를 중단합니다. 호출측 thread가 지정되고 있는 경우, 이 함수는, 다른 thread가 <a href="#ResumeThread"><code>ResumeThread</code></a>  를 호출할 때까지 돌아오지 않습니다. thread가 현재 중단되고 있는 경우, 이 함수는 아무것도 실시하지 않고, 에러를 돌려줍니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>5</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a> </td><td>
	  thread를 중단해, 재개할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SuspendThread.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      중단하는 thread.  
	    
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다
  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_SUSPENDED"><code>JVMTI_ERROR_THREAD_SUSPENDED</code></a> </td><td>
thread는 벌써 중단되고 있다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#SuspendThread.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#SuspendThread.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SuspendThreadList">
<h3>threaded list의 중단</h3>
<blockquote>
<pre>jvmtiError
SuspendThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)</pre>
</blockquote>
<a href="#SuspendThreadList.request_list"><code>request_list</code></a>  배열로 지정된 thread <a href="#SuspendThreadList.request_count"><code>request_count</code></a>  를 중단합니다. thread의 재개에는,<a href="#ResumeThreadList"><code>ResumeThreadList</code></a>  또는 <a href="#ResumeThread"><code>ResumeThread</code></a>  를 사용합니다. <a href="#SuspendThreadList.request_list"><code>request_list</code></a>  배열에 호출해 옆thread가 지정되고 있는 경우, 이 함수는, 다른 thread에 의해 재개될 때까지 돌아오지 않습니다. thread의 중단중에 발생한 에러는, 이 함수의 반환값은 아니고<b></b>,<a href="#SuspendThreadList.results"><code>results</code></a>  배열내에 돌려주어집니다. 현재 중단하고 있는 thread 상태는 바뀌지 않습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>92</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a> </td><td>
	  thread를 중단해, 재개할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SuspendThreadList.request_count">request_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    중단하는 thread의 수.
	  </td>
</tr>
<tr>
<td><code id="SuspendThreadList.request_list">request_list</code></td><td><code>const <a href="#jthread">jthread</a> *</code></td><td>
	      중단하는 thread의 리스트.
	    <p></p>에이전트는 <code>jthread</code> 의 <code>request_count</code> 요소의 배열을 건네준다.  </td>
</tr>
<tr>
<td><code id="SuspendThreadList.results">results</code></td><td><code><a href="#jvmtiError">jvmtiError</a> *</code></td><td>
	    에이전트에 의해 제공된 <a href="#SuspendThreadList.request_count"><code>request_count</code></a>  요소의 배열. 돌아왔을 때, 대응하는 thread의 중단의 에러 코드가 들어가 있다. thread가 이 호출에 의해 중단했을 경우, 에러 코드는 <a href="#JVMTI_ERROR_NONE"><code>JVMTI_ERROR_NONE</code></a> . 그 외의 에러 코드는,<a href="#SuspendThread"><code>SuspendThread</code></a>  로 지정된 에러 코드.
	  <p></p>에이전트는,<code>jvmtiError</code> 의 <code>request_count</code> 요소를 충분히 보관 유지할 수 있는 크기의 배열을 건네준다. 배열의 요소의 값은 무시된다. 돌아왔을 때, 요소가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#SuspendThreadList.request_count"><code>request_count</code></a>  가 <code>0</code> 보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#SuspendThreadList.request_list"><code>request_list</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#SuspendThreadList.results"><code>results</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="ResumeThread">
<h3>thread의 재개</h3>
<blockquote>
<pre>jvmtiError
ResumeThread(jvmtiEnv* env,
            jthread thread)</pre>
</blockquote>
중단되고 있는 thread의 실행을 재개합니다. 현재 JVM<small style="font-size: xx-small">&nbsp;</small>TI 중단 함수 (<a href="#SuspendThread"><code>SuspendThread</code></a>  등) 또는 <code>java.lang.Thread.suspend()</code> 에 의해 중단되고 있는 thread의 실행을 재개합니다. 그 외의 thread에는 영향은 없습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>6</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a> </td><td>
	  thread를 중단해, 재개할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ResumeThread.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      재개하는 thread.
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a> </td><td>
thread는 중단되어 있지 않다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_TYPESTATE"><code>JVMTI_ERROR_INVALID_TYPESTATE</code></a> </td><td>
thread 상태가 변경되었기 때문에, 부정합이 생기고 있다.  
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#ResumeThread.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#ResumeThread.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="ResumeThreadList">
<h3>threaded list의 재개</h3>
<blockquote>
<pre>jvmtiError
ResumeThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)</pre>
</blockquote>
<a href="#ResumeThreadList.request_list"><code>request_list</code></a>  배열로 지정된 thread <a href="#ResumeThreadList.request_count"><code>request_count</code></a>  를 재개합니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 중단 함수 (<a href="#SuspendThreadList"><code>SuspendThreadList</code></a>  등) 또는 <code>java.lang.Thread.suspend()</code> 에 의해 중단되고 있는 thread의 실행을 재개합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>93</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a> </td><td>
	  thread를 중단해, 재개할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ResumeThreadList.request_count">request_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    재개하는 thread의 수.
	  </td>
</tr>
<tr>
<td><code id="ResumeThreadList.request_list">request_list</code></td><td><code>const <a href="#jthread">jthread</a> *</code></td><td>
	      재개하는 thread.
	    <p></p>에이전트는 <code>jthread</code> 의 <code>request_count</code> 요소의 배열을 건네준다.  </td>
</tr>
<tr>
<td><code id="ResumeThreadList.results">results</code></td><td><code><a href="#jvmtiError">jvmtiError</a> *</code></td><td>
	    에이전트에 의해 제공된 <a href="#ResumeThreadList.request_count"><code>request_count</code></a>  요소의 배열. 돌아왔을 때, 대응하는 thread의 재개의 에러 코드가 들어가 있다. thread가 이 호출에 의해 중단했을 경우, 에러 코드는 <a href="#JVMTI_ERROR_NONE"><code>JVMTI_ERROR_NONE</code></a> . 그 외의 에러 코드는,<a href="#ResumeThread"><code>ResumeThread</code></a>  로 지정된 에러 코드.
	  <p></p>에이전트는,<code>jvmtiError</code> 의 <code>request_count</code> 요소를 충분히 보관 유지할 수 있는 크기의 배열을 건네준다. 배열의 요소의 값은 무시된다. 돌아왔을 때, 요소가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#ResumeThreadList.request_count"><code>request_count</code></a>  가 <code>0</code> 보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#ResumeThreadList.request_list"><code>request_list</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#ResumeThreadList.results"><code>results</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="StopThread">
<h3>thread의 정지</h3>
<blockquote>
<pre>jvmtiError
StopThread(jvmtiEnv* env,
            jthread thread,
            jobject exception)</pre>
</blockquote>
	지정된 비동기의 예외가 지정된 thread에 보냅니다 (<code>java.lang.Thread.stop</code> 와 같이). 일반적으로, 이 함수는, 지정된 thread를, 예외 <code>ThreadDeath</code> 의 인스턴스를 사용해 종료시키기 위해서(때문에) 사용합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>7</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_signal_thread"><code>can_signal_thread</code></a> </td><td>
	  thread에 정지 또는 끼어들어 신호를 송신할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="StopThread.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      정지하는 thread.
	    </td>
</tr>
<tr>
<td><code id="StopThread.exception">exception</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	      비동기의 예외 객체.
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_signal_thread"><code>can_signal_thread</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#StopThread.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#StopThread.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a> </td><td>
	  <a href="#StopThread.exception"><code>exception</code></a>  가 객체는 아니다.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="InterruptThread">
<h3>thread의 인터럽트</h3>
<blockquote>
<pre>jvmtiError
InterruptThread(jvmtiEnv* env,
            jthread thread)</pre>
</blockquote>
	지정된 thread에 끼어듭니다 (<code>java.lang.Thread.interrupt</code> 와 같이).
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>8</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_signal_thread"><code>can_signal_thread</code></a> </td><td>
	  thread에 정지 또는 끼어들어 신호를 송신할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="InterruptThread.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      끼어드는 thread.
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_signal_thread"><code>can_signal_thread</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#InterruptThread.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#InterruptThread.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetThreadInfo">
<h3>thread 정보의 취득</h3>
<blockquote>
<pre>typedef struct {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
} jvmtiThreadInfo;</pre>
<pre>jvmtiError
GetThreadInfo(jvmtiEnv* env,
            jthread thread,
            jvmtiThreadInfo* info_ptr)</pre>
</blockquote>
	thread 정보를 가져옵니다. <a href="#jvmtiThreadInfo"><code>jvmtiThreadInfo</code></a>  구조체의 필드에, 지정된 thread의 상세가 들어갑니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>9</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p id="jvmtiThreadInfo"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiThreadInfo</code> - thread 정보 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiThreadInfo.name">name</code></td><td><code>char *</code></td><td>
	    thread명. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadInfo.priority">priority</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    thread의 우선 순위. thread 우선 순위 정수 <a href="#jvmtiThreadPriority"><code>jvmtiThreadPriority</code></a>  를 참조.
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadInfo.is_daemon">is_daemon</code></td><td><code><a href="#jboolean">jboolean</a> </code></td><td>
	    demon thread인가 어떤가
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadInfo.thread_group">thread_group</code></td><td><code><a href="#jthreadGroup">jthreadGroup</a> </code></td><td>
	    이 thread가 속하는 thread 그룹. thread가 정지하고 있는 경우는 <code>NULL</code>.
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadInfo.context_class_loader">context_class_loader</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	      이 thread에 관련지을 수 있었던 문맥 클래스 로더.
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetThreadInfo.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      조회하는 thread.
	    
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetThreadInfo.info_ptr">info_ptr</code></td><td><code><a href="#jvmtiThreadInfo">jvmtiThreadInfo</a> *</code></td><td>
	    돌아왔을 때, 지정된 thread에 대한 정보가 들어가 있다.
	    <p></p>
	    문맥 클래스 로더를 인식하지 않는 JDK 1.1 의 구현의 경우,<code>context_class_loader</code> 필드는 NULL.
	  <p></p>에이전트는 <code>jvmtiThreadInfo</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiThreadInfo</code> 가 설정되어 있다. <code>jvmtiThreadInfo</code> 의 <code>name</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiThreadInfo</code> 의 <code>thread_group</code> 필드에 반환되는 객체는, JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다. <code>jvmtiThreadInfo</code> 의 <code>context_class_loader</code> 필드에 반환되는 객체는, JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetThreadInfo.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetThreadInfo.info_ptr"><code>info_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetOwnedMonitorInfo">
<h3>소유 모니터 정보의 취득</h3>
<blockquote>
<pre>jvmtiError
GetOwnedMonitorInfo(jvmtiEnv* env,
            jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr)</pre>
</blockquote>
	지정된 thread가 소유하는 모니터에 대한 정보를 가져옵니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>10</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_owned_monitor_info"><code>can_get_owned_monitor_info</code></a> </td><td>
	  모니터의 소유에 관한 정보를 취득할 수 있는 - <a href="#GetOwnedMonitorInfo"><code>GetOwnedMonitorInfo</code></a> 
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetOwnedMonitorInfo.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      조회하는 thread.
	    
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetOwnedMonitorInfo.owned_monitor_count_ptr">owned_monitor_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    반환되는 모니터의 수.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetOwnedMonitorInfo.owned_monitors_ptr">owned_monitors_ptr</code></td><td><code><a href="#jobject">jobject</a> **</code></td><td>
	      소유되는 모니터의 배열.
	    <p></p>에이전트는 <code>jobject*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jobject*</code> 는, 사이즈 <code>*owned_monitor_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.
<code>owned_monitors_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_owned_monitor_info"><code>can_get_owned_monitor_info</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetOwnedMonitorInfo.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#GetOwnedMonitorInfo.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetOwnedMonitorInfo.owned_monitor_count_ptr"><code>owned_monitor_count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetOwnedMonitorInfo.owned_monitors_ptr"><code>owned_monitor_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetOwnedMonitorStackDepthInfo">
<h3>소유 모니터의 스택의 깊이 정보의 취득</h3>
<blockquote>
<pre>typedef struct {
    jobject monitor;
    jint stack_depth;
} jvmtiMonitorStackDepthInfo;</pre>
<pre>jvmtiError
GetOwnedMonitorStackDepthInfo(jvmtiEnv* env,
            jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr)</pre>
</blockquote>
	지정된 thread가 소유하는 모니터에 관한 정보와 그러한 모니터를 잠그고 있는 스택 프레임의 깊이를 가져옵니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>153</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_owned_monitor_stack_depth_info"><code>can_get_owned_monitor_stack_depth_info</code></a> </td><td>
	  소유되고 있는 모니터에 관한 정보와 스택의 깊이를 취득할 수 있는 - <a href="#GetOwnedMonitorStackDepthInfo"><code>GetOwnedMonitorStackDepthInfo</code></a> 
	</td>
</tr>
</table>
<p id="jvmtiMonitorStackDepthInfo"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiMonitorStackDepthInfo</code> - 모니터 스택의 깊이 정보 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiMonitorStackDepthInfo.monitor">monitor</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	      소유되는 모니터.
	    </td>
</tr>
<tr>
<td><code id="jvmtiMonitorStackDepthInfo.stack_depth">stack_depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    스택의 깊이. <a href="#stack">스택 프레임 함수</a>로 사용되는 스택의 깊이에 대응하고 있다. 즉, 0 은 현재의 프레임을, 1 은 현재의 프레임을 호출한 프레임을 각각 나타낸다. 또, 구현이 스택의 깊이를 판단할 수  없는 경우는 - 1 이 된다 (JNI 의 <code>MonitorEnter</code> 를 사용해 취득된 모니터의 경우 등).
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetOwnedMonitorStackDepthInfo.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      조회하는 thread.
	    
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetOwnedMonitorStackDepthInfo.monitor_info_count_ptr">monitor_info_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    반환되는 모니터의 수.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetOwnedMonitorStackDepthInfo.monitor_info_ptr">monitor_info_ptr</code></td><td><code><a href="#jvmtiMonitorStackDepthInfo">jvmtiMonitorStackDepthInfo</a>  **</code></td><td>
	    소유되는 모니터의 깊이 정보의 배열.
	  <p></p>에이전트는 <code>jvmtiMonitorStackDepthInfo*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiMonitorStackDepthInfo*</code> 는, 사이즈 <code>*owned_monitor_depth_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiThreadGroupInfo</code> 의 <code>monitor</code> 필드에 반환되는 객체는, JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_owned_monitor_stack_depth_info"><code>can_get_owned_monitor_stack_depth_info</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetOwnedMonitorStackDepthInfo.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#GetOwnedMonitorStackDepthInfo.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetOwnedMonitorStackDepthInfo.monitor_info_count_ptr"><code>monitor_info_count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetOwnedMonitorStackDepthInfo.monitor_info_ptr"><code>monitor_info_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetCurrentContendedMonitor">
<h3>현재 경합 하고 있는 모니터의 취득</h3>
<blockquote>
<pre>jvmtiError
GetCurrentContendedMonitor(jvmtiEnv* env,
            jthread thread,
            jobject* monitor_ptr)</pre>
</blockquote>
	지정된 thread가,<code>java.lang.Object.wait</code> 를 사용해 객체의 모니터에 들어가는지, 모니터를 다시 하는 것 를 대기하고 있는 경우에, 그 객체를 가져옵니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>11</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_current_contended_monitor"><code>can_get_current_contended_monitor</code></a> </td><td>
	  <a href="#GetCurrentContendedMonitor"><code>GetCurrentContendedMonitor</code></a>  를 실행할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetCurrentContendedMonitor.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      조회하는 thread.
	    
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetCurrentContendedMonitor.monitor_ptr">monitor_ptr</code></td><td><code><a href="#jobject">jobject</a> *</code></td><td>
	      돌아왔을 때, 현재 경합 하고 있는 모니터가 들어가 있다. 그러한 모니터가 없는 경우는 NULL 가 들어가 있다.
	    <p></p>에이전트는 <code>jobject</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jobject</code> 가 설정되어 있다. <code>monitors_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_current_contended_monitor"><code>can_get_current_contended_monitor</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetCurrentContendedMonitor.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#GetCurrentContendedMonitor.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetCurrentContendedMonitor.monitor_ptr"><code>monitor_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="jvmtiStartFunction">
<h3>에이전트 기동 함수</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env, 
     JNIEnv* jni_env, 
     void* arg);</pre>
</blockquote>
에이전트에 의해 제공되는 콜백 함수. 이 함수는,<a href="#RunAgentThread"><code>RunAgentThread</code></a>  로 개시되는 에이전트 thread의 엔트리 포인트가 됩니다.
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="jvmtiStartFunction.jvmti_env">jvmti_env</code></td><td><code><a href="#jvmtiEnv">jvmtiEnv</a>  *</code></td><td>
	      JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경.
	    </td>
</tr>
<tr>
<td><code id="jvmtiStartFunction.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
JNI 환경
            </td>
</tr>
<tr>
<td><code id="jvmtiStartFunction.arg">arg</code></td><td><code>void *</code></td><td>
<a href="#RunAgentThread"><code>RunAgentThread</code></a>  에게 건네진 <code>arg</code> 파라미터.
              </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="RunAgentThread">
<h3>에이전트 thread의 실행</h3>
<blockquote>
<pre>jvmtiError
RunAgentThread(jvmtiEnv* env,
            jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority)</pre>
</blockquote>
	지정된 네이티브 함수를 사용해, 에이전트 thread의 실행을 개시합니다. 파라미터 <a href="#RunAgentThread.arg"><code>arg</code></a>  는<a href="#jvmtiStartFunction">기동 함수</a>  (<a href="#RunAgentThread.proc"><code>proc</code></a>  로 지정)의 단일의 인수로서 전송 됩니다. 이 함수에 의해,<code>java.lang.Thread</code> 의 특별한 서브 클래스나 <code>java.lang.Runnable</code> 의 구현측을 로드하지 않고 , 다른 프로세스와의 통신 처리 또는 이벤트 처리용의 에이전트 thread를 작성할 수 있습니다. 그 대신해, 작성된 thread는 완전하게 native code내에서 실행할 수 있습니다. 다만, 작성하는 thread에는,<code>java.lang.Thread</code> 의 새롭게 작성된 인스턴스 (인수 <code>thread</code> 에 의해 참조된다)가 필요해, 그 인스턴스에 thread를 관련짓습니다. thread 객체는, JNI 호출로 작성할 수 있습니다.
	<p></p>
	다음에 일반적인 thread 우선 순위를 참고로서 가리킵니다.
	<blockquote>
<a name="jvmtiThreadPriority"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">thread 우선 순위 정수</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_MIN_PRIORITY">JVMTI_THREAD_MIN_PRIORITY</code></td><td align="right">1</td><td>
	    제일 낮은 우선 순위
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_NORM_PRIORITY">JVMTI_THREAD_NORM_PRIORITY</code></td><td align="right">5</td><td>
	    중간의 우선 순위
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_MAX_PRIORITY">JVMTI_THREAD_MAX_PRIORITY</code></td><td align="right">10</td><td>
	    제일 높은 우선 순위
	  </td>
</tr>
</table>
</blockquote>
	
<p></p>
	새로운 thread는, 지정의<a href="#RunAgentThread.priority"><code>우선 순위</code></a> 로, demon thread로서 기동됩니다. 유효한 경우는,<a href="#ThreadStart"><code>ThreadStart</code></a>  이벤트가 송신됩니다.
	<p></p>
thread의 기동이 완료하고 있기 (위해)때문에, 이 thread는 이 함수가 돌아올 때에 라이브 상태가 되어 있습니다. 다만, 이 thread가 곧바로 종료했을 경우는 제외합니다.
	<p></p>
이 thread의 thread 그룹은 무시됩니다. 구체적으로는, 이 thread는, thread 그룹에 추가되지 않고, Java 프로그램 언어, JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 어느 레벨에서도 thread 그룹의 쿼리에는 표시되지 않습니다.
	<p></p>
이 thread는, Java 프로그램 언어의 쿼리에서는 표시됩니다만,<a href="#GetAllThreads"><code>GetAllThreads</code></a>  나 <a href="#GetAllStackTraces"><code>GetAllStackTraces</code></a>  등, JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 쿼리에는 포함됩니다.
	<p></p>
	<code>proc</code> 의 실행시에, 새로운 thread는 VM 에 접속됩니다. JNI 의 메뉴얼의<a href="http://java.sun.com/javase/6/docs/technotes/guides/jni/spec/invocation.html#wp1060">「Attaching to the VM」</a>를 참조해 주세요.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>12</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="RunAgentThread.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      실행하는 thread.
	    </td>
</tr>
<tr>
<td><code id="RunAgentThread.proc">proc</code></td><td><code><a href="#jvmtiStartFunction">jvmtiStartFunction</a> </code></td><td>
	    기동 함수
	  <p></p>
</td>
</tr>
<tr>
<td><code id="RunAgentThread.arg">arg</code></td><td><code>const void
            
          *</code></td><td>
	    기동 함수의 인수.
	  <p></p>에이전트가 포인터를 건네준다. <code>arg</code> 가 <code>NULL</code> 의 경우, 기동 함수에 <code>NULL</code> 가 건네받는다.
</td>
</tr>
<tr>
<td><code id="RunAgentThread.priority">priority</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    개시되는 thread의 우선 순위. <code>java.lang.Thread.setPriority</code> 로 허가되고 있는 thread 우선 순위를 사용할 수 있다 (<a href="#jvmtiThreadPriority"><code>jvmtiThreadPriority</code></a>  의 우선 순위를 포함한다).
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_PRIORITY"><code>JVMTI_ERROR_INVALID_PRIORITY</code></a> </td><td> 
<a href="#RunAgentThread.priority"><code>priority</code></a>  가 <a href="#JVMTI_THREAD_MIN_PRIORITY"><code>JVMTI_THREAD_MIN_PRIORITY</code></a>  보다 낮은가 <a href="#JVMTI_THREAD_MAX_PRIORITY"><code>JVMTI_THREAD_MAX_PRIORITY</code></a>  보다 높다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#RunAgentThread.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#RunAgentThread.proc"><code>proc</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetThreadLocalStorage">
<h3>thread 로컬인 기억 영역의 설정</h3>
<blockquote>
<pre>jvmtiError
SetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            const void* data)</pre>
</blockquote>
	VM 는, 개개의 환경 thread 페어에 관련지을 수 있었던 포인터치를 포함합니다. 이 포인터치를 「thread 로컬인 기억 영역」이라고 부릅니다. 이 함수로 설정되지 않는 경우, 값은 <code>NULL</code> 가 됩니다. 에이전트는, thread 고유의 정보를 포함하기 위해(때문에), 메모리를 할당할 수가 있습니다. thread 로컬인 기억 영역을 설정하는 것으로써,<a href="#GetThreadLocalStorage"><code>GetThreadLocalStorage</code></a>  를 사용해 액세스 할 수 있게 됩니다.
	<p></p>
이 함수는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 thread 로컬인 기억 영역의 값을 설정하기 위해(때문에), 에이전트에 의해 불려 갑니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 는, 에이전트에 대해서, thread마다의 정보를 기록하기 위해서 이용할 수 있는, 포인터 사이즈의 thread 로컬인 기억 영역을 제공합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>103</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetThreadLocalStorage.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      이 thread를 포함한다.
	    
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="SetThreadLocalStorage.data">data</code></td><td><code>const void 
	     
	  *</code></td><td>
	    thread 로컬인 기억 영역에 입력하는 값.
	  <p></p>에이전트가 포인터를 건네준다. <code>data</code> 가 <code>NULL</code> 의 경우, 값은 <code>NULL</code> 로 설정된다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#SetThreadLocalStorage.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#SetThreadLocalStorage.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetThreadLocalStorage">
<h3>thread 로컬인 기억 영역의 취득</h3>
<blockquote>
<pre>jvmtiError
GetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            void** data_ptr)</pre>
</blockquote>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 thread 로컬인 기억 영역의 값을 취득하기 위해(때문에), 에이전트에 의해 불려 갑니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>102</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetThreadLocalStorage.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      이 thread로부터 취득한다.
	    
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetThreadLocalStorage.data_ptr">data_ptr</code></td><td><code>void**</code></td><td>
	    thread 로컬인 기억 영역의 값을 돌려주는 포인터. thread 로컬인 기억 영역이 <a href="#SetThreadLocalStorage"><code>SetThreadLocalStorage</code></a>  로 설정되어 있지 않은 경우, 반환되는 포인터는 <code>NULL</code>.
	  <p></p>
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetThreadLocalStorage.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#GetThreadLocalStorage.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetThreadLocalStorage.data_ptr"><code>data_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<p id="thread_groups"></p>
<hr noshade="noshade" size="3">
<h2 align="center">thread 그룹</h2>thread 그룹 함수:
  <ul>
<li>
<a href="#GetTopThreadGroups">톱 레벨의 thread 그룹의 취득</a> 
</li>
<li>
<a href="#GetThreadGroupInfo">thread 그룹 정보의 취득</a> 
</li>
<li>
<a href="#GetThreadGroupChildren">아이 thread 그룹의 취득</a> 
</li>
</ul>thread 그룹의 형태:
    <ul>
<li>
<a href="#jvmtiThreadGroupInfo"><code>jvmtiThreadGroupInfo</code></a>  - thread 그룹 정보 구조체</li>
</ul>
    
<p></p>
<hr noshade="noshade" width="100%" size="1" id="GetTopThreadGroups">
<h3>톱 레벨의 thread 그룹의 취득</h3>
<blockquote>
<pre>jvmtiError
GetTopThreadGroups(jvmtiEnv* env,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)</pre>
</blockquote>
	VM 내의 톱 레벨의 (부모가 없다) thread 그룹을 모두 돌려줍니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>13</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetTopThreadGroups.group_count_ptr">group_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 톱 레벨의 thread 그룹의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetTopThreadGroups.groups_ptr">groups_ptr</code></td><td><code><a href="#jthreadGroup">jthreadGroup</a> **</code></td><td>
	      돌아왔을 때, 톱 레벨의 thread 그룹의 배열을 가리키는 포인터를 참조한다.
	    <p></p>에이전트는 <code>jthreadGroup*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jthreadGroup*</code> 는, 사이즈 <code>*group_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>groups_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetTopThreadGroups.group_count_ptr"><code>group_count_ptr</code></a> 이 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetTopThreadGroups.groups_ptr"><code>groups_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetThreadGroupInfo">
<h3>thread 그룹 정보의 취득</h3>
<blockquote>
<pre>typedef struct {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
} jvmtiThreadGroupInfo;</pre>
<pre>jvmtiError
GetThreadGroupInfo(jvmtiEnv* env,
            jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr)</pre>
</blockquote>
	thread 그룹의 정보를 가져옵니다. <a href="#jvmtiThreadGroupInfo"><code>jvmtiThreadGroupInfo</code></a>  구조체의 필드에, 지정된 thread 그룹의 상세가 들어갑니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>14</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p id="jvmtiThreadGroupInfo"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiThreadGroupInfo</code> - thread 그룹 정보 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiThreadGroupInfo.parent">parent</code></td><td><code><a href="#jthreadGroup">jthreadGroup</a> </code></td><td>
	    친thread 그룹.
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadGroupInfo.name">name</code></td><td><code>char *</code></td><td>
	    thread 그룹의 이름. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadGroupInfo.max_priority">max_priority</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    이 thread 그룹의 최고의 우선 순위.
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadGroupInfo.is_daemon">is_daemon</code></td><td><code><a href="#jboolean">jboolean</a> </code></td><td>
	    demon thread 그룹인가 어떤가.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetThreadGroupInfo.group">group</code></td><td><code><a href="#jthreadGroup">jthreadGroup</a> </code></td><td>
	    조회하는 thread 그룹.
	  </td>
</tr>
<tr>
<td><code id="GetThreadGroupInfo.info_ptr">info_ptr</code></td><td><code><a href="#jvmtiThreadGroupInfo">jvmtiThreadGroupInfo</a> *</code></td><td>
	    돌아왔을 때, 지정된 thread 그룹에 대한 정보가 들어가 있다.  
	  <p></p>에이전트는 <code>jvmtiThreadGroupInfo</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiThreadGroupInfo</code> 가 설정되어 있다. <code>jvmtiThreadGroupInfo</code> 의 <code>parent</code> 필드에 반환되는 객체는, JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다. <code>jvmtiThreadGroupInfo</code> 의 <code>name</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD_GROUP"><code>JVMTI_ERROR_INVALID_THREAD_GROUP</code></a> </td><td>
	  <a href="#GetThreadGroupInfo.group"><code>group</code></a>  는 thread 그룹 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetThreadGroupInfo.info_ptr"><code>info_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetThreadGroupChildren">
<h3>아이 thread 그룹의 취득</h3>
<blockquote>
<pre>jvmtiError
GetThreadGroupChildren(jvmtiEnv* env,
            jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)</pre>
</blockquote>
	이 thread 그룹내의 액티브 thread와 액티브 소그룹을 가져옵니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>15</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetThreadGroupChildren.group">group</code></td><td><code><a href="#jthreadGroup">jthreadGroup</a> </code></td><td>
	    조회하는 그룹.
	  </td>
</tr>
<tr>
<td><code id="GetThreadGroupChildren.thread_count_ptr">thread_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 이 thread 그룹내의 액티브 thread의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetThreadGroupChildren.threads_ptr">threads_ptr</code></td><td><code><a href="#jthread">jthread</a> **</code></td><td>
	      돌아왔을 때, 이 thread 그룹내의 액티브 thread의 배열을 포인트 한다.
	    <p></p>에이전트는 <code>jthread*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jthread*</code> 는, 사이즈 <code>*thread_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>threads_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
<tr>
<td><code id="GetThreadGroupChildren.group_count_ptr">group_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 액티브한 아이 thread 그룹의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetThreadGroupChildren.groups_ptr">groups_ptr</code></td><td><code><a href="#jthreadGroup">jthreadGroup</a> **</code></td><td>
	      돌아왔을 때, 액티브한 아이 thread 그룹의 배열을 포인트 한다.
	    <p></p>에이전트는 <code>jthreadGroup*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jthreadGroup*</code> 는, 사이즈 <code>*group_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>groups_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD_GROUP"><code>JVMTI_ERROR_INVALID_THREAD_GROUP</code></a> </td><td>
	  <a href="#GetThreadGroupChildren.group"><code>group</code></a>  는 thread 그룹 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetThreadGroupChildren.thread_count_ptr"><code>thread_count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetThreadGroupChildren.threads_ptr"><code>threads__ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetThreadGroupChildren.group_count_ptr"><code>group_count_ptr</code></a> 이 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetThreadGroupChildren.groups_ptr"><code>groups_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<p id="stack"></p>
<hr noshade="noshade" size="3">
<h2 align="center">스택 프레임</h2>스택 프레임 함수:
  <ul>
<li>
<a href="#GetStackTrace">스택 트레이스의 취득</a> 
</li>
<li>
<a href="#GetAllStackTraces">모든 스택 트레이스의 취득</a> 
</li>
<li>
<a href="#GetThreadListStackTraces">threaded list의 스택 트레이스의 취득</a> 
</li>
<li>
<a href="#GetFrameCount">프레임 카운트의 취득</a> 
</li>
<li>
<a href="#PopFrame">프레임의 팝</a> 
</li>
<li>
<a href="#GetFrameLocation">프레임의 위치의 취득</a> 
</li>
<li>
<a href="#NotifyFramePop">프레임의 팝의 통지</a> 
</li>
</ul>스택 프레임의 형태:
    <ul>
<li>
<a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a>  - 스택 프레임 정보 구조체</li>
<li>
<a href="#jvmtiStackInfo"><code>jvmtiStackInfo</code></a>  - 스택 정보 구조체</li>
</ul>
이러한 함수는, thread의 스택에 관한 정보를 제공합니다. 스택 프레임은, 깊이로 참조됩니다. 깊이 제로의 프레임이 현재의 프레임입니다.
        <p></p>
스택 프레임에 대해서는,<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a  href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/Overview.doc.html#17257">「Frames」</a>섹션에 기재되어 있습니다. 즉, 이러한 프레임은, 네이티브 메소드를 포함한 메소드의 호출에 대응하고 있지만, 플랫폼 고유의 프레임이나 VM 내부의 프레임에는 대응하고 있습니다.
        <p></p>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 구현이 메소드 호출을 사용해 thread를 기동해, 이러한 함수가 제공하는 스택내에, 대응하는 프레임을 포함할 수가 있습니다. 즉,<code>main()</code> 나 <code>run()</code> 보다 깊은 위치에 표시되는 프레임이 존재하게 됩니다. 다만, 이 제공은, 스택 프레임 또는 스택의 깊이를 사용하는 모든 JVM<small style="font-size: xx-small">&nbsp;</small>TI 기능과 무결성이 잡힌 것이 아니면 안됩니다.
<h4 id="jvmtiFrameInfo">스택 프레임 정보 구조체</h4>
스택 프레임에 관한 정보는 다음의 구조체로 되돌려집니다.
        <p></p>
<blockquote>
<pre>typedef struct {
    jmethodID method;
    jlocation location;
} jvmtiFrameInfo;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiFrameInfo</code> - 스택 프레임 정보 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiFrameInfo.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      이 프레임내에서 실행되고 있는 메소드.
	    </td>
</tr>
<tr>
<td><code id="jvmtiFrameInfo.location">location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	    이 프레임내에서 실행되고 있는 명령의 인덱스. 프레임이 네이티브 메소드를 실행하고 있는 경우는 <code>-1</code>.
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiStackInfo">스택 정보 구조체</h4>
스택 프레임 세트에 관한 정보는 다음의 구조체로 되돌려집니다.
        <p></p>
<blockquote>
<pre>typedef struct {
jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
} jvmtiStackInfo;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiStackInfo</code> - 스택 정보 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiStackInfo.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    돌아왔을 때, 트레이스 된 thread.
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackInfo.state">state</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    돌아왔을 때, thread 상태. <a href="#GetThreadState"><code>「GetThreadState」</code></a> 를 참조.
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackInfo.frame_buffer">frame_buffer</code></td><td><code><a href="#jvmtiFrameInfo">jvmtiFrameInfo</a>  *</code></td><td>
	      돌아왔을 때, 이 에이전트에 의해 할당할 수 있었던 버퍼에, 스택 프레임 정보가 들어가 있다.   
	    </td>
</tr>
<tr>
<td><code id="jvmtiStackInfo.frame_count">frame_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    돌아왔을 때, 레코드수가 <code>frame_buffer</code> 에 들어가 있다. 이것은 min(<code>max_frame_count</code>, <i>stackDepth</i>)가 된다.
	  </td>
</tr>
</table>
</blockquote>
<p></p>
<hr noshade="noshade" width="100%" size="1" id="GetStackTrace">
<h3>스택 트레이스의 취득</h3>
<blockquote>
<pre>jvmtiError
GetStackTrace(jvmtiEnv* env,
            jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr)</pre>
</blockquote>
thread의 스택에 관한 정보를 가져옵니다. <a href="#GetStackTrace.max_frame_count"><code>max_frame_count</code></a>  가 스택의 깊이보다 작은 경우,<a href="#GetStackTrace.max_frame_count"><code>max_frame_count</code></a>  의 맨 위의 프레임이 돌려주어집니다. 그 이외의 경우, 스택 전체가 돌려주어집니다. 마지막에 불려 간 프레임인 최상정도 프레임이, 반환되는 버퍼의 선두가 됩니다.
        <p></p>
다음의 예에서는, 맨 위의 프레임으로부터 5 개째까지의 프레임이 돌려주어집니다. 게다가 프레임이 있는 경우는, 현재 실행하고 있는 메소드의 이름이 출력됩니다.
        <blockquote>
<pre>
jvmtiFrameInfo frames[5];
jint count;
jvmtiError err;

err = (*jvmti)->GetStackTrace(jvmti, aThread, 0, 5, 
                               &frames, &count);
if (err == JVMTI_ERROR_NONE && count >= 1) {
   char *methodName;
   err = (*jvmti)->GetMethodName(jvmti, frames[0]. method, 
                       &methodName, NULL);
   if (err == JVMTI_ERROR_NONE) {
      printf("Executing method: %s", methodName);
   }
}
        </pre>
</blockquote>
        
        
<p></p>
<a href="#GetStackTrace.thread"><code>thread</code></a>  는, 중단하는 일 없이, 이 함수를 호출할 수가 있습니다.   
        <p></p>
위치와 행 번호의 매핑에는,<a href="#GetLineNumberTable"><code>GetLineNumberTable</code></a>  함수를 사용할 수 있습니다. 이 매핑은, 지연 해도 괜찮습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>104</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetStackTrace.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      이 thread의 스택 트레이스를 페치 한다.
	    
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetStackTrace.start_depth">start_depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    이 깊이로 프레임의 취득을 개시한다. 부의 수가 아닌 경우, 현재의 프레임으로부터 카운트 한다. 깊이가 <code>start_depth</code> 의 프레임이 최초로 취득된다. 예를 들어, 0 의 경우, 현재의 프레임으로부터 개시한다.  1 의 경우, 현재의 프레임의 호출측으로부터 개시한다.  2 의 경우, 현재의 프레임의 호출측의 호출측으로부터 개시한다. 부의 수의 경우, 제일 낡은 프레임아래로부터 카운트 한다.  깊이가 <i>stackDepth</i><code>+ start_depth</code> (<i>stackDepth</i> 는 스택상의 프레임의 카운트)의 프레임이 최초로 취득된다. 예를 들어,-1 의 경우, 제일 낡은 프레임만이 취득된다.  -2 의 경우, 제일 낡은 프레임에 의해 불려 간 프레임으로부터 개시한다.
	  </td>
</tr>
<tr>
<td><code id="GetStackTrace.max_frame_count">max_frame_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    취득하는 <a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a>  레코드의 최대수.
	  </td>
</tr>
<tr>
<td><code id="GetStackTrace.frame_buffer">frame_buffer</code></td><td><code><a href="#jvmtiFrameInfo">jvmtiFrameInfo</a>  *</code></td><td>
	      돌아왔을 때, 이 에이전트에 의해 할당할 수 있었던 버퍼에, 스택 프레임 정보가 들어가 있다.   
	    <p></p>에이전트는,<code>jvmtiFrameInfo</code> 의 <code>max_frame_count</code> 요소를 충분히 보관 유지할 수 있는 크기의 배열을 건네준다. 배열의 요소의 값은 무시된다. 돌아왔을 때, 요소의 <code>*count_ptr</code> 가 설정된다.  </td>
</tr>
<tr>
<td><code id="GetStackTrace.count_ptr">count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 정보가 입력되는 레코드의 수를 포인트 한다. <code> start_depth</code> 가 부의 수가 아닌 경우, min(<code>max_frame_count</code>, <i>stackDepth</i><code> - start_depth</code>). <code>start_depth</code> 가 부의 수의 경우, min(<code>max_frame_count</code>, <code>-start_depth</code>).
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetStackTrace.start_depth"><code>start_depth</code></a>  가 정으로,<i>stackDepth</i> 와 동일한가 그것보다 크다. 또는,<a href="#GetStackTrace.start_depth"><code>start_depth</code></a>  가 부로,<i>-stackDepth</i> 보다 작다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetStackTrace.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#GetStackTrace.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetStackTrace.max_frame_count"><code>max_frame_count</code></a>  가 <code>0</code> 보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetStackTrace.frame_buffer"><code>frame_buffer</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetStackTrace.count_ptr"><code>count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetAllStackTraces">
<h3>모든 스택 트레이스의 취득</h3>
<blockquote>
<pre>jvmtiError
GetAllStackTraces(jvmtiEnv* env,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr)</pre>
</blockquote>
모든 라이브 thread의 스택에 관한 정보를 가져옵니다 (<a href="#RunAgentThread">에이전트 thread</a>를 포함한다). <a href="#GetAllStackTraces.max_frame_count"><code>max_frame_count</code></a>  가 스택의 깊이보다 작은 경우, 그 thread에 대해 <a href="#GetAllStackTraces.max_frame_count"><code>max_frame_count</code></a>  의 맨 위의 프레임이 돌려주어집니다. 그 이외의 경우, 스택 전체가 돌려주어집니다. 마지막에 불려 간 프레임인 최상정도 프레임이, 반환되는 버퍼의 선두가 됩니다.
        <p></p>
모든 스택은, 동시에 수집됩니다. 즉, 어느 thread의 샘플링과 다음의 thread의 샘플링과의 사이에는, thread 상태 또는 스택으로 변경은 발생하지 않습니다. thread를 중단할 필요는 없습니다.
        
        <blockquote>
<pre>
jvmtiStackInfo *stack_info;
jint thread_count;
int ti;
jvmtiError err;

err = (*jvmti)->GetAllStackTraces(jvmti, MAX_FRAMES, &stack_info, &thread_count); 
if (err ! = JVMTI_ERROR_NONE) {
   ...   
}
for (ti = 0; ti < thread_count; ++ti) {
   jvmtiStackInfo *infop = &stack_info[ti];
   jthread thread = infop->thread;
   jint state = infop->state;
   jvmtiFrameInfo *frames = infop->frame_buffer;
   int fi;

   myThreadAndStatePrinter(thread, state);
   for (fi = 0; fi < infop->frame_count; fi++) {
      myFramePrinter(frames[fi]. method, frames[fi]. location);
   }
}
/* this one Deallocate call frees all data allocated by GetAllStackTraces */
err = (*jvmti)->Deallocate(jvmti, stack_info); 
        </pre>
</blockquote>
        

      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>100</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetAllStackTraces.max_frame_count">max_frame_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    thread 마다 취득하는 <a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a>  레코드의 최대수.
	  </td>
</tr>
<tr>
<td><code id="GetAllStackTraces.stack_info_ptr">stack_info_ptr</code></td><td><code><a href="#jvmtiStackInfo">jvmtiStackInfo</a>  **</code></td><td>
	      돌아왔을 때에, 이 버퍼에 각 thread의 스택 정보가 들어가 있다. <a href="#jvmtiStackInfo"><code>jvmtiStackInfo</code></a>  의 레코드수는,<a href="#GetAllStackTraces.thread_count_ptr"><code>thread_count_ptr</code></a>  로 결정된다.
              <p></p>
이 버퍼는,<a href="#jvmtiStackInfo.frame_buffer"><code>jvmtiStackInfo.frame_buffer</code></a>  로 포인트 된 <a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a>  버퍼를 포함하도록(듯이) 할당할 수 있고 있다. 이러한 버퍼는, 따로 따로 해제해서는 안 된다.
	    <p></p>에이전트는 <code>jvmtiStackInfo*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiStackInfo*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiStackInfo</code> 의 <code>thread</code> 필드에 반환되는 객체는, JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
<tr>
<td><code id="GetAllStackTraces.thread_count_ptr">thread_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    트레이스 된 thread의 수.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetAllStackTraces.max_frame_count"><code>max_frame_count</code></a>  가 <code>0</code> 보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetAllStackTraces.stack_info_ptr"><code>stack_info_ptr</code></a>  이 <code>NULL</code>.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetAllStackTraces.thread_count_ptr"><code>thread_count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetThreadListStackTraces">
<h3>threaded list의 스택 트레이스의 취득</h3>
<blockquote>
<pre>jvmtiError
GetThreadListStackTraces(jvmtiEnv* env,
            jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr)</pre>
</blockquote>
지정된 thread의 스택에 관한 정보를 가져옵니다. <a href="#GetThreadListStackTraces.max_frame_count"><code>max_frame_count</code></a>  가 스택의 깊이보다 작은 경우, 그 thread에 대해 <a href="#GetThreadListStackTraces.max_frame_count"><code>max_frame_count</code></a>  의 맨 위의 프레임이 돌려주어집니다. 그 이외의 경우, 스택 전체가 돌려주어집니다. 마지막에 불려 간 프레임인 최상정도 프레임이, 반환되는 버퍼의 선두가 됩니다.
        <p></p>
모든 스택은, 동시에 수집됩니다. 즉, 어느 thread의 샘플링과 다음의 thread의 샘플링과의 사이에는, thread 상태 또는 스택으로 변경은 발생하지 않습니다. thread를 중단할 필요는 없습니다.
        <p></p>
thread가 아직 기동되어 있지 않은지, 스택 정보가 수집되기 전에 thread가 종료했을 경우는, 길이 0 의 스택 (<a href="#jvmtiStackInfo.state"><code>jvmtiStackInfo.frame_count</code></a>  가 0)이 돌려주어지기 (위해)때문에, thread <a href="#jvmtiStackInfo.frame_count"><code>jvmtiStackInfo.state</code></a>  를 체크할 수 있습니다.
        <p></p>
예는, 동일한 함수 <a href="#GetAllStackTraces"><code>GetAllStackTraces</code></a>  를 참조해 주세요.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>101</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetThreadListStackTraces.thread_count">thread_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    트레이스 하는 thread의 수.
	  </td>
</tr>
<tr>
<td><code id="GetThreadListStackTraces.thread_list">thread_list</code></td><td><code>const <a href="#jthread">jthread</a> *</code></td><td>
	      트레이스 하는 thread의 리스트.
	    <p></p>에이전트는 <code>jthread</code> 의 <code>thread_count</code> 요소의 배열을 건네준다.  </td>
</tr>
<tr>
<td><code id="GetThreadListStackTraces.max_frame_count">max_frame_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    thread 마다 취득하는 <a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a>  레코드의 최대수.
	  </td>
</tr>
<tr>
<td><code id="GetThreadListStackTraces.stack_info_ptr">stack_info_ptr</code></td><td><code><a href="#jvmtiStackInfo">jvmtiStackInfo</a>  **</code></td><td>
	      돌아왔을 때에, 이 버퍼에 각 thread의 스택 정보가 들어가 있다. <a href="#jvmtiStackInfo"><code>jvmtiStackInfo</code></a>  의 레코드수는,<a href="#GetThreadListStackTraces.thread_count"><code>thread_count</code></a>  로 결정된다.
              <p></p>
이 버퍼는,<a href="#jvmtiStackInfo.frame_buffer"><code>jvmtiStackInfo.frame_buffer</code></a>  로 포인트 된 <a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a>  버퍼를 포함하도록(듯이) 할당할 수 있고 있다. 이러한 버퍼는, 따로 따로 해제해서는 안 된다.
	    <p></p>에이전트는 <code>jvmtiStackInfo*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>vmtiStackInfo*</code> 는, 사이즈 <code>*threads_count</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiStackInfo</code> 의 <code>thread</code> 필드에 반환되는 객체는, JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  thread 객체가 아닌 요소가 <a href="#GetThreadListStackTraces.thread_list"><code>thread_list</code></a>  내에 존재한다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetThreadListStackTraces.thread_count"><code>thread_count</code></a>  가 <code>0</code> 보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetThreadListStackTraces.thread_list"><code>thread_list</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetThreadListStackTraces.max_frame_count"><code>max_frame_count</code></a>  가 <code>0</code> 보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetThreadListStackTraces.stack_info_ptr"><code>stack_info_ptr</code></a>  이 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetFrameCount">
<h3>프레임 카운트의 취득</h3>
<blockquote>
<pre>jvmtiError
GetFrameCount(jvmtiEnv* env,
            jthread thread,
            jint* count_ptr)</pre>
</blockquote>
	지정된 thread의 호출 스택에 현재 들어가 있는 프레임의 수를 가져옵니다.
	<p></p>
	액티브하게 바이트 코드를 실행하고 있는 thread (현재의 thread는 아니고, 중단되어 있지 않은 thread등)를 위해서(때문에) 이 함수가 불려 갔을 경우, 일시적인 정보가 돌려주어집니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>16</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetFrameCount.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      조회하는 thread.
	    
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetFrameCount.count_ptr">count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 호출 스택내의 프레임의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetFrameCount.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#GetFrameCount.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetFrameCount.count_ptr"><code>count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="PopFrame">
<h3>프레임의 팝</h3>
<blockquote>
<pre>jvmtiError
PopFrame(jvmtiEnv* env,
            jthread thread)</pre>
</blockquote>
	<code>thread</code> 스택의 현재의 프레임을 팝 합니다. 프레임을 팝 하면(자), 직전의 프레임에 돌아옵니다. thread가 재개되면(자), thread의 실행 상태는, 메소드가 불려 가기 직전 상태에 리셋 됩니다. <a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의 용어로 설명하면(자), 다음과 같이 됩니다. <i></i>
	  <ul type="disc">
	    
<li>현재의 프레임이 파기되어 이전의 프레임이 현재의 프레임이 된다</li>
	    
<li>오퍼랜드 스택이 회복한다. 인수의 값이 재차 추가되어 호출이 <code>invokestatic</code> 가 아닌 경우는 <code>objectref</code> 도 재차 추가된다</li>
	    
<li>Java 가상 머신의 PC 가 호출해 명령의 조작 코드 (opcode)에 회복한다</li>
	  
</ul>
	다만, 호출처의 메소드로 발생한 인수의 변경 내용은 보관 유지됩니다. 실행을 속행하면(자), 최초의 실행 지시가 호출이 됩니다.   
	<p></p>
	<code>PopFrame</code> 의 호출과 thread의 재개동안, 스택 상태는 미정도리입니다. 최초의 프레임보다 전에 프레임을 팝 하려면 , 다음의 3 개의 순서를 반복할 필요가 있습니다.
	<ul type="disc">
	  
<li>이벤트를 통해서 thread를 중단한다 (스텝, breakpoint 등)</li>
	  
<li><code>PopFrame</code> 를 호출한다
</li>
	  
<li>thread를 재개한다</li>
	
</ul>
	
<p></p>
	피호방편 메소드를 호출하는 것에 의해 획득된 락 (이것이 <code>synchronized</code> 메소드의 경우)과 피호방편 메소드내의 <code>synchronized</code> 블록에 들어가는 것에 의해 획득된 락은 해제됩니다. 주:이것은, 네이티브 락이나 <code>java.util.concurrent.locks</code> 락에는 적용되지 않습니다.
	<p></p>
	최종적으로, 블록은 실행되지 않습니다.
	<p></p>
	글로벌 상태에의 변경에는 대응하지 않기 때문에, 변경은 행해지지 않습니다.
	<p></p>
	지정된 thread는 중단되어 있지 않으면 안됩니다. 이것은, 그 thread가 현재의 thread여선 안 되는 것을 의미합니다.
	<p></p>
	피호방편 메소드라고 불러 방편측의 메소드의 어느쪽이나, 비네이티브의 Java 프로그램 언어의 메소드로 합니다.
	<p></p>
	이 함수는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 이벤트를 생성하지 않습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>80</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_pop_frame"><code>can_pop_frame</code></a> </td><td>
	  스택으로부터 프레임을 팝 할 수 있는 - <a href="#PopFrame"><code>PopFrame</code></a> 
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="PopFrame.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      팝 하는 현재의 프레임의 thread.
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_pop_frame"><code>can_pop_frame</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td>
	  호출처 메소드 또는 호출해 옆메소드가 네이티브 메소드이다. 구현이 이 프레임을 팝 할 수 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a> </td><td>
	  thread는 중단되어 있지 않다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  호출 스택상의 스택 프레임의 수가, 2 개보다 적다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#PopFrame.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#PopFrame.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetFrameLocation">
<h3>프레임의 위치의 취득</h3>
<blockquote>
<pre>jvmtiError
GetFrameLocation(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr)</pre>
</blockquote>
	
<p></p>
	Java 프로그램 언어의 프레임에 대해, 현재 실행중의 명령의 위치를 돌려줍니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>19</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetFrameLocation.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    조회하는 프레임의 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetFrameLocation.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    조회하는 프레임의 깊이.
	  </td>
</tr>
<tr>
<td><code id="GetFrameLocation.method_ptr">method_ptr</code></td><td><code><a href="#jmethodID">jmethodID</a> *</code></td><td>
	      돌아왔을 때, 현재의 위치의 메소드를 포인트 한다.
	    <p></p>에이전트는 <code>jmethodID</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jmethodID</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetFrameLocation.location_ptr">location_ptr</code></td><td><code><a href="#jlocation">jlocation</a> *</code></td><td>
	    돌아왔을 때, 현재 실행중의 명령의 인덱스를 포인트 한다. 프레임이 네이티브 메소드를 실행하고 있는 경우는 <code>-1</code> 으로 설정된다.
	  <p></p>에이전트는 <code>jlocation</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jlocation</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetFrameLocation.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#GetFrameLocation.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetFrameLocation.depth"><code>depth</code></a>  가 제로보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  지정된 <a href="#GetFrameLocation.depth"><code>depth</code></a>  에 스택 프레임이 존재하지 않는다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetFrameLocation.method_ptr"><code>method_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetFrameLocation.location_ptr"><code>location_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="NotifyFramePop">
<h3>프레임의 팝의 통지</h3>
<blockquote>
<pre>jvmtiError
NotifyFramePop(jvmtiEnv* env,
            jthread thread,
            jint depth)</pre>
</blockquote>
	깊이 <a href="#NotifyFramePop.depth"><code>depth</code></a>  의 프레임이 스택으로부터 팝 되었을 때,<a href="#FramePop"><code>FramePop</code></a>  이벤트를 생성합니다. 자세한 것은,<a href="#FramePop"><code>FramePop</code></a>  이벤트의 설명을 참조해 주세요. 비네이티브 Java 프로그램 언어의 메소드에 대응하는 프레임만이 통지를 수신할 수 있습니다.
        <p></p>
지정한 thread는 현재의 thread인지, thread가 중단했는지의 어느 쪽인지입니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>20</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_frame_pop_events"><code>can_generate_frame_pop_events</code></a> </td><td>
	  <a href="#FramePop"><code>FramePop</code></a>  이벤트를<a href="#NotifyFramePop">설정</a>해, 취득할 수가 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="NotifyFramePop.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    프레임의 팝 이벤트가 생성되는 프레임의 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="NotifyFramePop.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    프레임의 팝 이벤트가 생성되는 프레임의 깊이.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_generate_frame_pop_events"><code>can_generate_frame_pop_events</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td> 
	  <code>depth</code> 의 프레임은 네이티브 메소드를 실행하고 있다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a> </td><td>
	  thread는 중단되지 않고, 현재의 thread는 아니었다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#NotifyFramePop.thread"><code>thread</code></a>  는 thread 객체는 아니다. 	  
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#NotifyFramePop.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다). 	  
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#NotifyFramePop.depth"><code>depth</code></a>  가 제로보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  지정된 <a href="#NotifyFramePop.depth"><code>depth</code></a>  에 스택 프레임이 존재하지 않는다.
	  
	</td>
</tr>
</table>
<p id="ForceEarlyReturn"></p>
<hr noshade="noshade" size="3">
<h2 align="center">조기 복귀의 강제</h2>조기 복귀의 강제의 함수:
  <ul>
<li>
<a href="#ForceEarlyReturnObject">조기 복귀의 강제 - 객체형</a> 
</li>
<li>
<a href="#ForceEarlyReturnInt">조기 복귀의 강제 - 정수형</a> 
</li>
<li>
<a href="#ForceEarlyReturnLong">조기 복귀의 강제 - 장 정수형</a> 
</li>
<li>
<a href="#ForceEarlyReturnFloat">조기 복귀의 강제 - 부동 소수점수(실수)형</a> 
</li>
<li>
<a href="#ForceEarlyReturnDouble">조기 복귀의 강제 - 배정밀도 부동 소수점수(실수)형</a> 
</li>
<li>
<a href="#ForceEarlyReturnVoid">조기 복귀의 강제 - void 형</a> 
</li>
</ul>
이러한 함수를 사용하면(자), 에이전트는, 실행중의 임의의 포인트에서의 복귀를 메소드에 강제할 수 있습니다. 조기 복귀하는 메소드를 「피호방편 메소드」라고 부릅니다. <i></i>피호방편 메소드는,<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/Overview.doc.html#17257">「Frames」</a>섹션에 정의되고 있는 대로, 함수의 호출시에, 지정된 thread의 현재의 메소드가 됩니다.
      <p></p>
지정된 thread는, 중단되고 있는지, 현재의 thread가 아니면 안됩니다. 메소드의 복귀는, Java 프로그램 언어의 코드의 실행이 이 thread상에서 재개되었을 때에 행해집니다. 이러한 함수의 어느쪽이든을 호출하고 나서 thread의 실행이 재개될 때까지 의 스택 상태는 미정도리입니다.   
      <p></p>
피호방편 메소드에서는, 더 이상의 명령은 실행되지 않습니다. 특히, 최종적으로 블록은 실행되지 않습니다. 주:이것에 의해, 어플리케이션내에서 무결성이 없는 상태가 발생하는 일이 있습니다.
      <p></p>
피호방편 메소드를 호출하는 것에 의해 획득된 락 (이것이 <code>synchronized</code> 메소드의 경우)과 피호방편 메소드내의 <code>synchronized</code> 블록에 들어가는 것에 의해 획득된 락은 해제됩니다. 주:이것은, 네이티브 락이나 <code>java.util.concurrent.locks</code> 락에는 적용되지 않습니다.
      <p></p>
일반적으로 복귀의 경우와 같게,<a href="#MethodExit"><code>MethodExit</code></a>  등의 이벤트가 생성됩니다.
      <p></p>
피호방편 메소드는, 비네이티브의 Java 프로그램 언어의 메소드로 합니다. 스택상에 프레임이 1 개만 있는 상태로 thread에의 강제 복귀를 행했을 경우, thread가 재개시에 종료합니다.
    <p></p>
<hr noshade="noshade" width="100%" size="1" id="ForceEarlyReturnObject">
<h3>조기 복귀의 강제 - 객체형</h3>
<blockquote>
<pre>jvmtiError
ForceEarlyReturnObject(jvmtiEnv* env,
            jthread thread,
            jobject value)</pre>
</blockquote>
	이 함수를 사용하면(자), 결과의 형태가 <code>Object</code> 또는 <code>Object</code> 의 서브 클래스인 메소드로부터 복귀할 수 있습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>81</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a> </td><td>
	  <a href="#ForceEarlyReturn">조기 복귀의 강제의 카테고리</a>로 설명하고 있도록(듯이), 메소드로부터 조기 복귀할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnObject.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    현재의 프레임이 조기 복귀하는 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnObject.value">value</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	    피호방편 프레임의 반환값. 객체 또는 <code>NULL</code>.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td>
	  네이티브 메소드에 대응하는 프레임으로부터의 조기 복귀가 시도되었다. 또는, 구현이 이 프레임상에서 이 기능을 제공할 수 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  피호방편 메소드의 결과의 형태가,<code>Object</code> 에서도,<code>Object</code> 의 서브 클래스도 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  지정된<a href="#ForceEarlyReturnObject.value"><code>값</code></a> 과 피호방편 메소드의 결과의 형태에 호환성이 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a> </td><td>
	  thread가 현재의 thread는 아니고, 중단되어 있지 않았다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  호출 스택에 더 이상의 프레임이 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#ForceEarlyReturnObject.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#ForceEarlyReturnObject.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a> </td><td>
	  <a href="#ForceEarlyReturnObject.value"><code>value</code></a>  가 객체는 아니다.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="ForceEarlyReturnInt">
<h3>조기 복귀의 강제 - 정수형</h3>
<blockquote>
<pre>jvmtiError
ForceEarlyReturnInt(jvmtiEnv* env,
            jthread thread,
            jint value)</pre>
</blockquote>
	이 함수를 사용하면(자), 결과의 형태가 <code>int</code>,<code>short</code>,<code>char</code>,<code>byte</code>,<code>boolean</code> 의 언젠가인 메소드로부터 복귀할 수 있습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>82</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a> </td><td>
	  <a href="#ForceEarlyReturn">조기 복귀의 강제의 카테고리</a>로 설명하고 있도록(듯이), 메소드로부터 조기 복귀할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnInt.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    현재의 프레임이 조기 복귀하는 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnInt.value">value</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    피호방편 프레임의 반환값.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td>
	  네이티브 메소드에 대응하는 프레임으로부터의 조기 복귀가 시도되었다. 또는, 구현이 이 프레임상에서 이 기능을 제공할 수 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  피호방편 메소드의 결과의 형태가 <code>int</code>,<code>short</code>,<code>char</code>,<code>byte</code>,<code>boolean</code> 의 머지않아도 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a> </td><td>
	  thread가 현재의 thread는 아니고, 중단되어 있지 않았다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  호출 스택에 프레임이 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#ForceEarlyReturnInt.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#ForceEarlyReturnInt.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="ForceEarlyReturnLong">
<h3>조기 복귀의 강제 - 장 정수형</h3>
<blockquote>
<pre>jvmtiError
ForceEarlyReturnLong(jvmtiEnv* env,
            jthread thread,
            jlong value)</pre>
</blockquote>
	이 함수를 사용하면(자), 결과의 형태가 <code>long</code> 인 메소드로부터 복귀할 수 있습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>83</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a> </td><td>
	  <a href="#ForceEarlyReturn">조기 복귀의 강제의 카테고리</a>로 설명하고 있도록(듯이), 메소드로부터 조기 복귀할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnLong.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    현재의 프레임이 조기 복귀하는 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnLong.value">value</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    피호방편 프레임의 반환값.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><SUP></SUP><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td>
	  네이티브 메소드에 대응하는 프레임으로부터의 조기 복귀가 시도되었다. 또는, 구현이 이 프레임상에서 이 기능을 제공할 수 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  피호방편 메소드의 결과의 형태가 <code>long</code> 가 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a> </td><td>
	  thread가 현재의 thread는 아니고, 중단되어 있지 않았다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  호출 스택에 프레임이 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#ForceEarlyReturnLong.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#ForceEarlyReturnLong.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="ForceEarlyReturnFloat">
<h3>조기 복귀의 강제 - 부동 소수점수(실수)형</h3>
<blockquote>
<pre>jvmtiError
ForceEarlyReturnFloat(jvmtiEnv* env,
            jthread thread,
            jfloat value)</pre>
</blockquote>
	이 함수를 사용하면(자), 결과의 형태가 <code>float</code> 인 메소드로부터 복귀할 수 있습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>84</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a> </td><td>
	  <a href="#ForceEarlyReturn">조기 복귀의 강제의 카테고리</a>로 설명하고 있도록(듯이), 메소드로부터 조기 복귀할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnFloat.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    현재의 프레임이 조기 복귀하는 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnFloat.value">value</code></td><td><code><a href="#jfloat">jfloat</a> </code></td><td>
	    피호방편 프레임의 반환값.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td>
	  네이티브 메소드에 대응하는 프레임으로부터의 조기 복귀가 시도되었다. 또는, 구현이 이 프레임상에서 이 기능을 제공할 수 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  피호방편 메소드의 결과의 형태가 <code>float</code> 가 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a> </td><td>
	  thread가 현재의 thread는 아니고, 중단되어 있지 않았다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  호출 스택에 프레임이 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#ForceEarlyReturnFloat.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#ForceEarlyReturnFloat.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="ForceEarlyReturnDouble">
<h3>조기 복귀의 강제 - 배정밀도 부동 소수점수(실수)형</h3>
<blockquote>
<pre>jvmtiError
ForceEarlyReturnDouble(jvmtiEnv* env,
            jthread thread,
            jdouble value)</pre>
</blockquote>
	이 함수를 사용하면(자), 결과의 형태가 <code>double</code> 인 메소드로부터 복귀할 수 있습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>85</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a> </td><td>
	  <a href="#ForceEarlyReturn">조기 복귀의 강제의 카테고리</a>로 설명하고 있도록(듯이), 메소드로부터 조기 복귀할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnDouble.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    현재의 프레임이 조기 복귀하는 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnDouble.value">value</code></td><td><code><a href="#jdouble">jdouble</a> </code></td><td>
	    피호방편 프레임의 반환값.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td>
	  네이티브 메소드에 대응하는 프레임으로부터의 조기 복귀가 시도되었다. 또는, 구현이 이 프레임상에서 이 기능을 제공할 수 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  피호방편 메소드의 결과의 형태가 <code>double</code> 가 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a> </td><td>
	  thread가 현재의 thread는 아니고, 중단되어 있지 않았다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  호출 스택에 프레임이 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#ForceEarlyReturnDouble.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#ForceEarlyReturnDouble.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="ForceEarlyReturnVoid">
<h3>조기 복귀의 강제 - void 형</h3>
<blockquote>
<pre>jvmtiError
ForceEarlyReturnVoid(jvmtiEnv* env,
            jthread thread)</pre>
</blockquote>
	이 함수를 사용하면(자), 결과의 형태를 가지지 않는 메소드로부터 복귀할 수 있습니다. 즉, 피호방편 메소드가 <code>void</code> 와 선언되어 있지 않으면 안됩니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>86</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a> </td><td>
	  <a href="#ForceEarlyReturn">조기 복귀의 강제의 카테고리</a>로 설명하고 있도록(듯이), 메소드로부터 조기 복귀할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnVoid.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    현재의 프레임이 조기 복귀하는 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td>
	  네이티브 메소드에 대응하는 프레임으로부터의 조기 복귀가 시도되었다. 또는, 구현이 이 프레임상에서 이 기능을 제공할 수 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  피호방편 메소드가 결과의 형태를 가지고 있다.   
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a> </td><td>
	  thread가 현재의 thread는 아니고, 중단되어 있지 않았다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  호출 스택에 프레임이 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#ForceEarlyReturnVoid.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#ForceEarlyReturnVoid.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
</table>
<p id="Heap"></p>
<hr noshade="noshade" size="3">
<h2 align="center">heap</h2>heap 함수:
  <ul>
<li>
<a href="#FollowReferences">참조의 추적</a> 
</li>
<li>
<a href="#IterateThroughHeap">heap내에서의 반복해</a> 
</li>
<li>
<a href="#GetTag">태그의 취득</a> 
</li>
<li>
<a href="#SetTag">태그의 설정</a> 
</li>
<li>
<a href="#GetObjectsWithTags">태그를 사용한 객체의 취득</a> 
</li>
<li>
<a href="#ForceGarbageCollection">가베지 컬렉션의 강제</a> 
</li>
</ul>heap의 함수형:
    <ul>
<li>
<a href="#jvmtiHeapIterationCallback">heap 반복 콜백</a> 
</li>
<li>
<a href="#jvmtiHeapReferenceCallback">heap 참조 콜백</a> 
</li>
<li>
<a href="#jvmtiPrimitiveFieldCallback">프리미티브(primitive) 필드 콜백</a> 
</li>
<li>
<a href="#jvmtiArrayPrimitiveValueCallback">배열 프리미티브(primitive)치 콜백</a> 
</li>
<li>
<a href="#jvmtiStringPrimitiveValueCallback">캐릭터 라인 프리미티브(primitive)치 콜백</a> 
</li>
<li>
<a href="#jvmtiReservedCallback">장래 사용하기 위해서 예약된 콜백</a> 
</li>
</ul>heap의 형태:
    <ul>
<li>
<a href="#jvmtiHeapReferenceKind"><code>jvmtiHeapReferenceKind</code></a>  - heap 참조의 열거</li>
<li>
<a href="#jvmtiPrimitiveType"><code>jvmtiPrimitiveType</code></a>  - 원시형의 열거</li>
<li>
<a href="#jvmtiHeapReferenceInfoField"><code>jvmtiHeapReferenceInfoField</code></a>  - 필드 참조용의 참조 정보 구조체</li>
<li>
<a href="#jvmtiHeapReferenceInfoArray"><code>jvmtiHeapReferenceInfoArray</code></a>  - 배열 참조용의 참조 정보 구조체</li>
<li>
<a href="#jvmtiHeapReferenceInfoConstantPool"><code>jvmtiHeapReferenceInfoConstantPool</code></a>  - 정수 풀 참조용의 참조 정보 구조체</li>
<li>
<a href="#jvmtiHeapReferenceInfoStackLocal"><code>jvmtiHeapReferenceInfoStackLocal</code></a>  - 국소 변수 참조용의 참조 정보 구조체</li>
<li>
<a href="#jvmtiHeapReferenceInfoJniLocal"><code>jvmtiHeapReferenceInfoJniLocal</code></a>  - JNI 로컬 참조용의 참조 정보 구조체</li>
<li>
<a href="#jvmtiHeapReferenceInfoReserved"><code>jvmtiHeapReferenceInfoReserved</code></a>  - 그 외의 참조용의 참조 정보 구조체</li>
<li>
<a href="#jvmtiHeapReferenceInfo"><code>jvmtiHeapReferenceInfo</code></a>  - 참조 정보 구조체</li>
<li>
<a href="#jvmtiHeapCallbacks"><code>jvmtiHeapCallbacks</code></a>  - heap 콜백 함수 구조체</li>
</ul>heap의 플래그 및 정수:
    <ul>
<li>
<a href="#jvmtiHeapFilter">heap 필터 플래그</a> 
</li>
<li>
<a href="#jvmtiHeapVisitControl">히프비짓트 제어 플래그</a> 
</li>
</ul>
이러한 함수는, heap의 분석에 사용됩니다. heap내의 객체의 표시, 이러한 객체에의 태그부등의 기능이 있습니다.
<h4 id="objectTags">객체의 태그</h4>
「태그」는, 객체에 관련지을 수 있는 값입니다. 태그는, 에이전트에 의해,<a href="#SetTag"><code>태그의 설정</code></a> 함수를 사용해 명시적으로 설정됩니다. 또는,<a href="#jvmtiHeapIterationCallback"><code>jvmtiHeapIterationCallback</code></a>  등의 콜백 함수에 의해 설정됩니다.     
      <p></p>
태그는 환경에 대해서 로컬입니다. 즉, 어느 환경의 태그를 다른 환경에서 표시할 수 없습니다.
      <p></p>
태그는 <code>jlong</code> 치입니다. 이 값을 사용해, 객체에 마크를 붙이거나 상세 정보의 포인터를 포함하거나 할 수 있습니다. 태그 붙이고되어 있지 않은 객체에는, 제로의 태그가 붙어 있습니다. 태그를 제로로 설정하는 것으로써, 객체의 태그부를 해제할 수 있습니다.
<h4 id="heapCallbacks">heap 콜백 함수</h4>
heap 함수는, heap내에서의 반복 처리와 객체 참조의 재귀적인 추적을 실시해, 에이전트가 지정한 콜백 함수를 사용해 정보 제공을 실시합니다.
        <p></p>
이러한 heap 콜백 함수는, 다음의 제한에 따릅니다. 이러한 콜백으로 JNI 함수는 사용하지 말아 주세요. 이러한 콜백에서는, 특별히 사용이 허가되고 있는 「콜백 안전」인 함수 이외의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수를 사용할 수 없습니다 (raw 모니터 함수, 메모리 관리 함수, 환경 로컬 기억 영역 함수를 참조). <i></i>
        <p></p>
구현은, 내부 thread상 또는 반복해 함수를 호출한 thread상에서, 콜백을 호출할 수가 있습니다. heap 콜백은 싱글스 레드입니다. 복수의 콜백이 동시에 불려 갈 것은 없습니다.
        <p></p>
heap 필터 플래그를 사용하면(자), 객체 또는 그 클래스의 태그 상태에 근거해 보고를 실시하지 않게 할 수가 있습니다. 플래그가 설정되어 있지 않은 경우 (<code>jint</code> 가 제로의 경우), 객체의 필터링은 행해지지 않습니다.

        <blockquote>
<a name="jvmtiHeapFilter"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">heap 필터 플래그</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_FILTER_TAGGED">JVMTI_HEAP_FILTER_TAGGED</code></td><td align="right">0x4</td><td>
	    태그 첨부의 객체를 필터링 한다. 태그가 붙은 객체가 제외된다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_FILTER_UNTAGGED">JVMTI_HEAP_FILTER_UNTAGGED</code></td><td align="right">0x8</td><td>
	    태그 없음의 객체를 필터링 한다. 태그가 붙지 않은 객체가 제외된다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_FILTER_CLASS_TAGGED">JVMTI_HEAP_FILTER_CLASS_TAGGED</code></td><td align="right">0x10</td><td>
	    태그 첨부의 클래스를 가지는 객체를 필터링 한다. 태그가 붙은 클래스의 객체가 제외된다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_FILTER_CLASS_UNTAGGED">JVMTI_HEAP_FILTER_CLASS_UNTAGGED</code></td><td align="right">0x2;</td><td>
	    태그 없음의 클래스를 가지는 객체를 필터링 한다. 태그가 붙지 않은 클래스의 객체가 제외된다.
	  </td>
</tr>
</table>
</blockquote>

        
<p></p>
heap 콜백에 의해 반환되는 히프비짓트 제어 플래그를 사용하면(자), 반복 처리를 중지할 수 있습니다. 또,<a href="#jvmtiHeapReferenceCallback">heap 참조 콜백</a>은, 횡단(traverse) 대상이 되는 참조의 그래프를 없애기 위해서(때문에) 사용할 수도 있습니다 (<code>JVMTI_VISIT_OBJECTS</code> 를 설정하지 않는다).

        <blockquote>
<a name="jvmtiHeapVisitControl"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">히프비짓트 제어 플래그</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_VISIT_OBJECTS">JVMTI_VISIT_OBJECTS</code></td><td align="right">0x100</td><td>
어느 객체를 비짓트 할 때에 이 콜백이 <a href="#FollowReferences"><code>FollowReferences</code></a>  에 의해 기동된 것이었을 경우, 그 객체의 참조를 횡단(traverse) 한다. 그 이외의 경우는 무시된다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VISIT_ABORT">JVMTI_VISIT_ABORT</code></td><td align="right">0x8000</td><td>
	    반복 처리를 중지. 다른 모든 비트를 무시한다.
	  </td>
</tr>
</table>
</blockquote>

        
<p></p>
heap 참조의 열거는, 보고 대상의 참조의 종류를 기술하는 목적으로,<a href="#jvmtiHeapReferenceCallback">heap 참조 콜백</a>과<a href="#jvmtiPrimitiveFieldCallback">프리미티브(primitive) 필드 콜백</a>에 의해 제공됩니다.

        <blockquote>
<a name="jvmtiHeapReferenceKind"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">heap 참조의 열거 (<code>jvmtiHeapReferenceKind</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_CLASS">JVMTI_HEAP_REFERENCE_CLASS</code></td><td align="right">1</td><td>
	    객체로부터 그 클래스에의 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_FIELD">JVMTI_HEAP_REFERENCE_FIELD</code></td><td align="right">2</td><td>
	    객체로부터, 그 객체의 몇개의 인스턴스 필드치에의 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT">JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT</code></td><td align="right">3</td><td>
	    배열로부터, 그 배열의 몇개의 요소에의 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_CLASS_LOADER">JVMTI_HEAP_REFERENCE_CLASS_LOADER</code></td><td align="right">4</td><td>
	    클래스로부터 그 클래스 로더에의 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_SIGNERS">JVMTI_HEAP_REFERENCE_SIGNERS</code></td><td align="right">5</td><td>
	    클래스로부터 그 서명자의 배열에의 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN">JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN</code></td><td align="right">6</td><td>
	    클래스로부터 그 보호 도메인에의 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_INTERFACE">JVMTI_HEAP_REFERENCE_INTERFACE</code></td><td align="right">7</td><td>
클래스로부터, 그 클래스의 몇개의 인터페이스에의 참조. 주:인터페이스는 정수 풀 참조 경유로 정의되기 (위해)때문에, 참조된 인터페이스는 참조의 종류가 <code>JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code> 로 보고될 가능성도 있다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_STATIC_FIELD">JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></td><td align="right">8</td><td>
	    클래스로부터 그 몇개의 static 필드치에의 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_CONSTANT_POOL">JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code></td><td align="right">9</td><td>
	    클래스로부터 정수 풀내의 해결 지음 엔트리에의 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_SUPERCLASS">JVMTI_HEAP_REFERENCE_SUPERCLASS</code></td><td align="right">10</td><td>
클래스로부터 그 슈퍼 클래스에의 참조. 슈퍼 클래스가 <code>java.lang.Object</code> 의 경우, 콜백은 송신되지 않는다. 주:로드 된 클래스는 정수 풀 참조 경유로 슈퍼 클래스를 정의하기 위해(때문에), 참조된 슈퍼 클래스는 참조의 종류가 <code>JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code> 로 보고될 가능성도 있다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_JNI_GLOBAL">JVMTI_HEAP_REFERENCE_JNI_GLOBAL</code></td><td align="right">21</td><td>
	    heap 루트 참조 :JNI 글로벌 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_SYSTEM_CLASS">JVMTI_HEAP_REFERENCE_SYSTEM_CLASS</code></td><td align="right">22</td><td>
	    heap 루트 참조:시스템 클래스.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_MONITOR">JVMTI_HEAP_REFERENCE_MONITOR</code></td><td align="right">23</td><td>
	    heap 루트 참조:모니터.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_STACK_LOCAL">JVMTI_HEAP_REFERENCE_STACK_LOCAL</code></td><td align="right">24</td><td>
	    heap 루트 참조:스택상의 국소 변수.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_JNI_LOCAL">JVMTI_HEAP_REFERENCE_JNI_LOCAL</code></td><td align="right">25</td><td>
	    heap 루트 참조 :JNI 로컬 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_THREAD">JVMTI_HEAP_REFERENCE_THREAD</code></td><td align="right">26</td><td>
	    heap 루트 참조:thread.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_OTHER">JVMTI_HEAP_REFERENCE_OTHER</code></td><td align="right">27</td><td>
	    heap 루트 참조:다른 heap 루트 참조.
	  </td>
</tr>
</table>
</blockquote>

        
<p></p>
원시형의 단일 문자형 기술자의 정의.

        <blockquote>
<a name="jvmtiPrimitiveType"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">원시형의 열거 (<code>jvmtiPrimitiveType</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_BOOLEAN">JVMTI_PRIMITIVE_TYPE_BOOLEAN</code></td><td align="right">90</td><td>
「Z」 - Java 프로그램 언어의 <code>boolean</code> - JNI 의 <code>jboolean</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_BYTE">JVMTI_PRIMITIVE_TYPE_BYTE</code></td><td align="right">66</td><td>
「B」 - Java 프로그램 언어의 <code>byte</code> - JNI 의 <code>jbyte</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_CHAR">JVMTI_PRIMITIVE_TYPE_CHAR</code></td><td align="right">67</td><td>
「C」 - Java 프로그램 언어의 <code>char</code> - JNI 의 <code>jchar</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_SHORT">JVMTI_PRIMITIVE_TYPE_SHORT</code></td><td align="right">83</td><td>
「S」 - Java 프로그램 언어의 <code>short</code> - JNI 의 <code>jshort</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_INT">JVMTI_PRIMITIVE_TYPE_INT</code></td><td align="right">73</td><td>
「I」 - Java 프로그램 언어의 <code>int</code> - JNI 의 <code>jint</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_LONG">JVMTI_PRIMITIVE_TYPE_LONG</code></td><td align="right">74</td><td>
「J」 - Java 프로그램 언어의 <code>long</code> - JNI 의 <code>jlong</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_FLOAT">JVMTI_PRIMITIVE_TYPE_FLOAT</code></td><td align="right">70</td><td>
「F」 - Java 프로그램 언어의 <code>float</code> - JNI 의 <code>jfloat</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_DOUBLE">JVMTI_PRIMITIVE_TYPE_DOUBLE</code></td><td align="right">68</td><td>
「D」 - Java 프로그램 언어의 <code>double</code> - JNI 의 <code>jdouble</code>
	  </td>
</tr>
</table>
</blockquote>
    
<h4 id="jvmtiHeapReferenceInfoField">필드 참조용의 참조 정보 구조체</h4>
<a href="#JVMTI_HEAP_REFERENCE_FIELD"><code>JVMTI_HEAP_REFERENCE_FIELD</code></a>  및 <a href="#JVMTI_HEAP_REFERENCE_STATIC_FIELD"><code>JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></a>  참조에 대해서 반환되는 참조 정보.
        <p></p>
<blockquote>
<pre>typedef struct {
    jint index;
} jvmtiHeapReferenceInfoField;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfoField</code> - 필드 참조용의 참조 정보 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoField.index">index</code></td><td><code><a href="#jint">jint</a> </code></td><td>	    
<a href="#JVMTI_HEAP_REFERENCE_FIELD"><code>JVMTI_HEAP_REFERENCE_FIELD</code></a>  의 경우, 참조측 객체는 클래스에서도 인터페이스이기도 하지 않습니다. 이 경우,<code>index</code> 는, 참조측 객체의 클래스에 포함되는 필드의 인덱스입니다. 이후, 이 클래스를 <i>C</i> 라고 부릅니다.
            <p></p>
<a href="#JVMTI_HEAP_REFERENCE_STATIC_FIELD"><code>JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></a>  의 경우, 참조측 객체는, 클래스 (이후 <i>C</i> 라고 부른다)와 인터페이스 (이후 <i>I</i> 라고 부른다)의 어느 쪽인가에 됩니다. 이 경우,<code>index</code> 는, 그 클래스 또는 인터페이스에 포함되는 필드의 인덱스입니다.
            <p></p>
참조측 객체가 인터페이스가 아닌 경우, 필드의 인덱스는 다음과 같이 해 결정됩니다.  
            <ul type="disc">
              
<li><i>C</i> 와 그 슈퍼 클래스에 포함되는 모든 필드의 리스트가 작성됩니다. 이 리스트는,<code>java.lang.Object</code> 내의 모든 필드에서 시작되어,<i>C</i> 내의 모든 필드에서 끝납니다. </li>
              
<li>이 리스트내에서, 지정된 클래스의 필드가 <a href="#GetClassFields"><code>GetClassFields</code></a>  로부터 반환된 차례로 늘어놓을 수 있습니다. </li>
              
<li>이 리스트내의 필드에, 인덱스 <i>n</i>,<i>n</i>+1,... 하지만 순서에 할당할 수 있습니다. <i>n</i> 는,<i>C</i> 가 구현하는 모든 인터페이스에 포함되는 필드의 카운트수입니다. <i>C</i> 는, 그 슈퍼 클래스가 직접 구현하는 모든 인터페이스와 그것들 인터페이스의 모든 슈퍼 인터페이스를 구현하고 있습니다. </li>
            
</ul>
참조측 객체가 인터페이스인 경우, 필드의 인덱스는 다음과 같이 해 결정됩니다.
            <ul type="disc">
              
<li><i>I</i> 내에서 직접 선언되고 있는 필드의 리스트가 작성됩니다. </li>
              
<li>이 리스트내의 필드가 <a href="#GetClassFields"><code>GetClassFields</code></a>  로부터 반환된 차례로 늘어놓을 수 있습니다. </li>
              
<li>이 리스트내의 필드에, 인덱스 <i>n</i>,<i>n</i>+1,... 하지만 순서에 할당할 수 있습니다. <i>n</i> 는,<i>I</i> 의 모든 슈퍼 인터페이스에 포함되는 필드의 카운트수입니다. </li>
            
</ul>
이 계산에는, 필드 수식자 (static, public, private 등)의 종류에 관계없이, 모든 필드가 포함됩니다.
            <p></p>
예를 들어, 다음과 같은 클래스와 인터페이스가 지정되고 있다고 합니다.
            <blockquote>
<pre>
interface I0 {
    int p = 0;
}

interface I1 extends I0 {
int x = 1;
}

interface I2 extends I0 {
    int y = 2;
}

class C1 implements I1 {
    public static int a = 3;
    private int b = 4;
}

class C2 extends C1 implements I2 {
    static int q = 5;
    final int r = 6;
}
            </pre>
</blockquote>
<code>C1</code> 로 불려 간 <a href="#GetClassFields"><code>GetClassFields</code></a>  로부터,<code>C1</code> 의 필드 a, b 가 이 차례로 돌려주어져<code>C2</code> 의 필드 q, r 가 이 차례로 반환되는 것으로 합니다. 클래스 <code>C1</code> 의 인스턴스의 필드 인덱스는, 다음과 같이 됩니다.
            <dl>
<dd>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
              
<tr>
                
<td align="center">
a
                </td>
                <td align="center">
                  2
                </td>
                <td align="left">
<code>C1</code> 가 구현하는 인터페이스내의 필드의 카운트수는 2 (<i>n</i>=2)입니다. 즉,<code>I0</code> 의 <code>p</code> 와 <code>I1</code> 의 <code>x</code> 입니다.
                </td>
              
</tr>
              
<tr>
                
<td align="center">
                  b
                </td>
                <td align="center">
                  3
                </td>
                <td align="left">
후속의 인덱스.
                </td>
              
</tr>
            
</table>
</dd>
</dl>
클래스 <code>C1</code> 도 같은 필드 인덱스를 가집니다.
            <p></p>
클래스 <code>C2</code> 의 인스턴스의 필드 인덱스는, 다음과 같이 됩니다.
            <dl>
<dd>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
              
<tr>
                
<td align="center">
a
                </td>
                <td align="center">
                  3
                </td>
                <td align="left">
<code>C2</code> 가 구현하는 인터페이스내의 필드의 카운트수는 3 (<i>n</i>=3)입니다. 즉,<code>I0</code> 의 <code>p</code>,<code>I1</code> 의 <code>x</code>, 및 <code>I2</code> 의 <code>y</code> (<code>C2</code> 의 인터페이스)입니다. <code>I0</code> 의 필드 <code>p</code> 는 한 번 밖에 포함되지 않습니다.
                </td>
              
</tr>
              
<tr>
                
<td align="center">
                  b
                </td>
                <td align="center">
                  4
                </td>
                <td align="left">
「a」에 계속되는 인덱스.
                </td>
              
</tr>
              
<tr>
                
<td align="center">
                  q
                </td>
                <td align="center">
                  5
                </td>
                <td align="left">
「b」에 계속되는 인덱스.
                </td>
              
</tr>
              
<tr>
                
<td align="center">
                  r
                </td>
                <td align="center">
                  6
                </td>
                <td align="left">
「q」에 계속되는 인덱스.
                </td>
              
</tr>
            
</table>
</dd>
</dl>
클래스 <code>C2</code> 도 같은 필드 인덱스를 가집니다. 상기의 필드 「a」와 같이, 같은 필드가, 참조측 객체 마다 다른 인덱스를 가질 가능성이 있습니다. 또, 콜백으로부터 모든 필드 인덱스가 가시가 되는 것은 아닙니다만, 여기에서는 설명을 위해서(때문에) 모든 인덱스를 나타내고 있습니다.
            <p></p>
인터페이스 <code>I1</code> 도 같은 필드 인덱스를 가집니다.
            <dl>
<dd>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
              
<tr>
                
<td align="center">
x
                </td>
                <td align="center">
                  1
                </td>
                <td align="left">
<code>I1</code> 의 슈퍼 인터페이스내의 필드의 카운트수는 1 (<i>n</i>=1)입니다. 즉,<code>I0</code> 의 <code>p</code> 입니다.
                </td>
              
</tr>
            
</table>
</dd>
</dl>
	  
</td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapReferenceInfoArray">배열 참조용의 참조 정보 구조체</h4>
<a href="#JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT"><code>JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT</code></a>  참조에 대해서 반환되는 참조 정보.
        <p></p>
<blockquote>
<pre>typedef struct {
    jint index;
} jvmtiHeapReferenceInfoArray;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfoArray</code> - 배열 참조용의 참조 정보 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoArray.index">index</code></td><td><code><a href="#jint">jint</a> </code></td><td>	    
	    배열의 인덱스.
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapReferenceInfoConstantPool">정수 풀 참조용의 참조 정보 구조체</h4>
<a href="#JVMTI_HEAP_REFERENCE_CONSTANT_POOL"><code>JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code></a>  참조에 대해서 반환되는 참조 정보.
        <p></p>
<blockquote>
<pre>typedef struct {
    jint index;
} jvmtiHeapReferenceInfoConstantPool;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfoConstantPool</code> - 정수 풀 참조용의 참조 정보 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoConstantPool.index">index</code></td><td><code><a href="#jint">jint</a> </code></td><td>	    
	    클래스의 정수 풀내의 인덱스. <a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#20080">「Constant Pool」</a>섹션을 참조해 주세요. <i></i>
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapReferenceInfoStackLocal">국소 변수 참조용의 참조 정보 구조체</h4>
<a href="#JVMTI_HEAP_REFERENCE_STACK_LOCAL"><code>JVMTI_HEAP_REFERENCE_STACK_LOCAL</code></a>  참조에 대해서 반환되는 참조 정보.
        <p></p>
<blockquote>
<pre>typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
} jvmtiHeapReferenceInfoStackLocal;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfoStackLocal</code> - 국소 변수 참조용의 참조 정보 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoStackLocal.thread_tag">thread_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    이 스택에 대응하는 thread의 태그.  태그 붙이고되어 있지 않은 경우는 제로.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoStackLocal.thread_id">thread_id</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    이 스택에 대응하는 thread의 일의의 thread ID.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoStackLocal.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    프레임의 깊이.  
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoStackLocal.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    이 프레임내에서 실행되고 있는 메소드.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoStackLocal.location">location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	    이 프레임내에서 현재 실행되고 있는 위치.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoStackLocal.slot">slot</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    국소 변수의 슬롯 번호.
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapReferenceInfoJniLocal">JNI 로컬 참조용의 참조 정보 구조체</h4>
<a href="#JVMTI_HEAP_REFERENCE_JNI_LOCAL"><code>JVMTI_HEAP_REFERENCE_JNI_LOCAL</code></a>  참조에 대해서 반환되는 참조 정보.
        <p></p>
<blockquote>
<pre>typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
} jvmtiHeapReferenceInfoJniLocal;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfoJniLocal</code> - JNI 로컬 참조용의 참조 정보 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoJniLocal.thread_tag">thread_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    이 스택에 대응하는 thread의 태그.  태그 붙이고되어 있지 않은 경우는 제로.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoJniLocal.thread_id">thread_id</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    이 스택에 대응하는 thread의 일의의 thread ID.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoJniLocal.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    프레임의 깊이.  
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoJniLocal.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    이 프레임내에서 실행되고 있는 메소드.
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapReferenceInfoReserved">그 외의 참조용의 참조 정보 구조체</h4>
그 외의 참조에 대해서 반환되는 참조 정보.
        <p></p>
<blockquote>
<pre>typedef struct {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
} jvmtiHeapReferenceInfoReserved;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfoReserved</code> - 그 외의 참조용의 참조 정보 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved1">reserved1</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved2">reserved2</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved3">reserved3</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved4">reserved4</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved5">reserved5</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved6">reserved6</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved7">reserved7</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved8">reserved8</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapReferenceInfo">참조 정보 구조체</h4>
참조 측에 관계해 반환되는 정보. 각종 참조 정보의 공용체로서 나타내집니다.
        <p></p>
<blockquote>
<pre>typedef union {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
} jvmtiHeapReferenceInfo;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfo</code> - 참조 정보 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfo.field">field</code></td><td><code><a href="#jvmtiHeapReferenceInfoField">jvmtiHeapReferenceInfoField</a> </code></td><td>	    
	    <a href="#JVMTI_HEAP_REFERENCE_FIELD"><code>JVMTI_HEAP_REFERENCE_FIELD</code></a>  및 <a href="#JVMTI_HEAP_REFERENCE_STATIC_FIELD"><code>JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></a>  참조의 참조측 정보.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfo.array">array</code></td><td><code><a href="#jvmtiHeapReferenceInfoArray">jvmtiHeapReferenceInfoArray</a> </code></td><td>	    
	    <a href="#JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT"><code>JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT</code></a>  참조의 참조측 정보.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfo.constant_pool">constant_pool</code></td><td><code><a href="#jvmtiHeapReferenceInfoConstantPool">jvmtiHeapReferenceInfoConstantPool</a> </code></td><td>	    
	    <a href="#JVMTI_HEAP_REFERENCE_CONSTANT_POOL"><code>JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code></a>  참조의 참조측 정보.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfo.stack_local">stack_local</code></td><td><code><a href="#jvmtiHeapReferenceInfoStackLocal">jvmtiHeapReferenceInfoStackLocal</a> </code></td><td>	    
	    <a href="#JVMTI_HEAP_REFERENCE_STACK_LOCAL"><code>JVMTI_HEAP_REFERENCE_STACK_LOCAL</code></a>  참조의 참조측 정보.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfo.jni_local">jni_local</code></td><td><code><a href="#jvmtiHeapReferenceInfoJniLocal">jvmtiHeapReferenceInfoJniLocal</a> </code></td><td>	    
	    <a href="#JVMTI_HEAP_REFERENCE_JNI_LOCAL"><code>JVMTI_HEAP_REFERENCE_JNI_LOCAL</code></a>  참조의 참조측 정보.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfo.other">other</code></td><td><code><a href="#jvmtiHeapReferenceInfoReserved">jvmtiHeapReferenceInfoReserved</a> </code></td><td>	    
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapCallbacks">heap 콜백 함수 구조체</h4>
<blockquote>
<pre>typedef struct {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
} jvmtiHeapCallbacks;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapCallbacks</code> - heap 콜백 함수 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.heap_iteration_callback">heap_iteration_callback</code></td><td><code><a href="#jvmtiHeapIterationCallback">jvmtiHeapIterationCallback</a> </code></td><td>
	    heap내의 객체를 기술하기 위해서 불려 가는 콜백. <a href="#IterateThroughHeap"><code>IterateThroughHeap</code></a>  함수에 의해 사용되어<a href="#FollowReferences"><code>FollowReferences</code></a>  함수에 의해 무시된다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.heap_reference_callback">heap_reference_callback</code></td><td><code><a href="#jvmtiHeapReferenceCallback">jvmtiHeapReferenceCallback</a> </code></td><td>
	    객체 참조를 기술하기 위해서 불려 가는 콜백. <a href="#FollowReferences"><code>FollowReferences</code></a>  함수에 의해 사용되어<a href="#IterateThroughHeap"><code>IterateThroughHeap</code></a>  함수에 의해 무시된다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.primitive_field_callback">primitive_field_callback</code></td><td><code><a href="#jvmtiPrimitiveFieldCallback">jvmtiPrimitiveFieldCallback</a> </code></td><td>
프리미티브(primitive) 필드를 기술하기 위해서 불려 가는 콜백.
          </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.array_primitive_value_callback">array_primitive_value_callback</code></td><td><code><a href="#jvmtiArrayPrimitiveValueCallback">jvmtiArrayPrimitiveValueCallback</a> </code></td><td>
	    프리미티브(primitive)치의 배열을 기술하기 위해서 불려 가는 콜백.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.string_primitive_value_callback">string_primitive_value_callback</code></td><td><code><a href="#jvmtiStringPrimitiveValueCallback">jvmtiStringPrimitiveValueCallback</a> </code></td><td>
	    String 치를 기술하기 위해서 불려 가는 콜백.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved5">reserved5</code></td><td><code><a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved6">reserved6</code></td><td><code><a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved7">reserved7</code></td><td><code><a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved8">reserved8</code></td><td><code><a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved9">reserved9</code></td><td><code><a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved10">reserved10</code></td><td><code><a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved11">reserved11</code></td><td><code><a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved12">reserved12</code></td><td><code><a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved13">reserved13</code></td><td><code><a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved14">reserved14</code></td><td><code><a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved15">reserved15</code></td><td><code><a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	  </td>
</tr>
</table>
</blockquote>
      
<p style="color: purple">
원리의 설명:
      
	heap 덤프 기능 (아래와 같이)은, 각 객체에 콜백을 사용합니다. 버퍼 방식 쪽이 throughput가 높다고 생각됩니다만, 테스트에서는, 그러한 결과는 얻을 수 있지 않습니다. 메모리 참조의 장소 또는 배열 액세스의 오바헷드에 의하는 것이라고 생각됩니다.
      </p>

      

      

    
<p></p>
<hr noshade="noshade" width="100%" size="1" id="jvmtiHeapIterationCallback">
<h3>heap 반복 콜백</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     jint length, 
     void* user_data);</pre>
</blockquote>
에이전트에 의해 제공되는 콜백 함수. heap내의 객체를 기술합니다만, 값은 건네주지 않습니다.
        <p></p>
이 함수는, 필요한<a href="#jvmtiHeapVisitControl">비짓트 제어 플래그</a>의 비트 벡터를 돌려줍니다. 이것에 의해, 반복 처리의 전체를 중지해야할 것인가 제발이 정해집니다 (<code>JVMTI_VISIT_OBJECTS</code> 플래그는 무시된다).
        <p></p>
<a href="#heapCallbacks">heap 콜백 함수의 제한</a>을 참조해 주세요.
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="jvmtiHeapIterationCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    객체의 클래스의 태그 (태그 붙이고되어 있지 않은 클래스의 경우는 제로). 객체가 실행시 클래스를 나타내는 경우,<code>class_tag</code> 는 <code>java.lang.Class</code> 에 관련짓고 된 태그 (<code>java.lang.Class</code> 가 태그 붙이고되어 있지 않은 경우는 제로).
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapIterationCallback.size">size</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    객체의 사이즈 (바이트 단위). <a href="#GetObjectSize"><code>GetObjectSize</code></a>  를 참조.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapIterationCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    객체의 태그치. 태그 붙이고되어 있지 않은 객체의 경우는 제로. 객체와 관련짓는 태그의 값을 설정하기 위해(때문에), 에이전트는 파라미터에 의해 포인트 되는 <code>jlong</code> 를 설정한다.  
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapIterationCallback.length">length</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    이 객체가 배열인 경우는 그 배열의 길이. 그 이외의 경우는 마이너스 1 (-1).
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapIterationCallback.user_data">user_data</code></td><td><code>void *</code></td><td>
	    사용자가 입력해, 반복 함수에게 건네진 데이터.  
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="jvmtiHeapReferenceCallback">
<h3>heap 참조 콜백</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind, 
     const jvmtiHeapReferenceInfo* reference_info, 
     jlong class_tag, 
     jlong referrer_class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     jlong* referrer_tag_ptr, 
     jint length, 
     void* user_data);</pre>
</blockquote>
에이전트에 의해 제공되는 콜백 함수. 어느 객체 또는 VM (참조측)로부터 다른 객체 (참조처)에의 참조, 또는 있는 heap 루트로부터 있는 참조처에의 참조를 기술합니다.
        <p></p>
이 함수는, 필요한<a href="#jvmtiHeapVisitControl">비짓트 제어 플래그</a>의 비트 벡터를 돌려줍니다. 이것에 의해, 참조처가 참조하고 있는 객체를 비짓트해야할 것인가 제발이나, 반복 처리의 전체를 중지해야할 것인가 제발이 정해집니다.
        <p></p>
<a href="#heapCallbacks">heap 콜백 함수의 제한</a>을 참조해 주세요.
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.reference_kind">reference_kind</code></td><td><code><a href="#jvmtiHeapReferenceKind">jvmtiHeapReferenceKind</a> </code></td><td>
	    참조의 종류.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.reference_info">reference_info</code></td><td><code>const <a href="#jvmtiHeapReferenceInfo">jvmtiHeapReferenceInfo</a>  *</code></td><td>
	    참조에 관한 상세. <a href="#.reference_kind"><code>reference_kind</code></a>  가 <a href="#JVMTI_HEAP_REFERENCE_FIELD"><code>JVMTI_HEAP_REFERENCE_FIELD</code></a> ,<a href="#JVMTI_HEAP_REFERENCE_STATIC_FIELD"><code>JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></a> ,<a href="#JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT"><code>JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT</code></a> ,<a href="#JVMTI_HEAP_REFERENCE_CONSTANT_POOL"><code>JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code></a> ,<a href="#JVMTI_HEAP_REFERENCE_STACK_LOCAL"><code>JVMTI_HEAP_REFERENCE_STACK_LOCAL</code></a> , 또는 <a href="#JVMTI_HEAP_REFERENCE_JNI_LOCAL"><code>JVMTI_HEAP_REFERENCE_JNI_LOCAL</code></a>  의 경우로 설정된다. 그 이외의 경우는 <code>NULL</code>.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    참조되는 객체의 클래스의 태그 (태그 붙이고되어 있지 않은 클래스의 경우는 제로). 참조된 객체가 실행시 클래스를 나타내는 경우,<code>class_tag</code> 는 <code>java.lang.Class</code> 에 관련짓고 된 태그 (<code>java.lang.Class</code> 가 태그 붙이고되어 있지 않은 경우는 제로).
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.referrer_class_tag">referrer_class_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
참조측 객체의 클래스의 태그 (클래스에 태그가 붙지 않은가 참조처가 heap 루트인 경우는 제로). 참조측 객체가 실행시 클래스를 나타내는 경우,<code>referrer_class_tag</code> 는 <code>java.lang.Class</code> 에 관련짓고 된 태그 (<code>java.lang.Class</code> 가 태그 붙이고되어 있지 않은 경우는 제로).
          </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.size">size</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    참조되는 객체의 사이즈 (바이트 단위). <a href="#GetObjectSize"><code>GetObjectSize</code></a>  를 참조.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    참조되는 객체의 태그치를 포인트 한다. 태그 붙이고되어 있지 않은 객체의 경우는 제로를 포인트 한다. 객체와 관련짓는 태그의 값을 설정하기 위해(때문에), 에이전트는 파라미터에 의해 포인트 되는 <code>jlong</code> 를 설정한다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.referrer_tag_ptr">referrer_tag_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    참조측 객체의 태그를 포인트 한다. 참조측 객체가 태그 붙이고되어 있지 않은 경우는 제로를 포인트 한다. 참조측이 객체가 아닌 (즉, 이 콜백의 보고 대상이 heap 루트이다) 경우는 <code>NULL</code>. 참조측 객체와 관련짓는 태그치를 설정하기 위해(때문에), 에이전트는 파라미터에 의해 포인트 되는 <code>jlong</code> 를 설정한다. 이 콜백의 보고 대상이, 어느 객체로부터 그 객체 자신에게로의 참조인 경우는,<code>referrer_tag_ptr == tag_ptr</code> 가 된다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.length">length</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    이 객체가 배열인 경우는 그 배열의 길이. 그 이외의 경우는 마이너스 1 (-1).
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.user_data">user_data</code></td><td><code>void *</code></td><td>
	    사용자가 입력해, 반복 함수에게 건네진 데이터.  
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="jvmtiPrimitiveFieldCallback">
<h3>프리미티브(primitive) 필드 콜백</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind, 
     const jvmtiHeapReferenceInfo* info, 
     jlong object_class_tag, 
     jlong* object_tag_ptr, 
     jvalue value, 
     jvmtiPrimitiveType value_type, 
     void* user_data);</pre>
</blockquote>
어느 객체 ( 「객체」)의 프리미티브(primitive) 필드를 기술하는, 에이전트에 의해 제공되는 콜백 함수. <i></i>프리미티브(primitive) 필드란, 형태가 원시형인 필드입니다. 이 콜백은, 객체가 클래스의 경우는 static 필드를, 그 이외의 경우는 인스턴스 필드를 각각 기술합니다.
        <p></p>
이 함수는, 필요한<a href="#jvmtiHeapVisitControl">비짓트 제어 플래그</a>의 비트 벡터를 돌려줍니다. 이것에 의해, 반복 처리의 전체를 중지해야할 것인가 제발이 정해집니다 (<code>JVMTI_VISIT_OBJECTS</code> 플래그는 무시된다).
        <p></p>
<a href="#heapCallbacks">heap 콜백 함수의 제한</a>을 참조해 주세요.
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.kind">kind</code></td><td><code><a href="#jvmtiHeapReferenceKind">jvmtiHeapReferenceKind</a> </code></td><td>
	    필드의 종류 -- 인스턴스 또는 static (<a href="#JVMTI_HEAP_REFERENCE_FIELD"><code>JVMTI_HEAP_REFERENCE_FIELD</code></a>  또는 <a href="#JVMTI_HEAP_REFERENCE_STATIC_FIELD"><code>JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></a> ).
	  </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.info">info</code></td><td><code>const <a href="#jvmtiHeapReferenceInfo">jvmtiHeapReferenceInfo</a>  *</code></td><td>
	    어느 필드인가 (필드의 인덱스).
	  </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.object_class_tag">object_class_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
객체의 클래스의 태그 (태그 붙이고되어 있지 않은 클래스의 경우는 제로). 객체가 실행시 클래스를 나타내는 경우,<code>object_class_tag</code> 는 <code>java.lang.Class</code> 에 관련짓고 된 태그 (<code>java.lang.Class</code> 가 태그 붙이고되어 있지 않은 경우는 제로).
	  </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.object_tag_ptr">object_tag_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    객체의 태그를 포인트 한다. 태그 붙이고되어 있지 않은 객체의 경우는 제로를 포인트 한다. 객체와 관련짓는 태그의 값을 설정하기 위해(때문에), 에이전트는 파라미터에 의해 포인트 되는 <code>jlong</code> 를 설정한다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.value">value</code></td><td><code><a href="#jvalue">jvalue</a> </code></td><td>
	    필드의 값.
	  </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.value_type">value_type</code></td><td><code><a href="#jvmtiPrimitiveType">jvmtiPrimitiveType</a> </code></td><td>
	    필드의 형태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.user_data">user_data</code></td><td><code>void *</code></td><td>
	    사용자가 입력해, 반복 함수에게 건네진 데이터.  
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="jvmtiArrayPrimitiveValueCallback">
<h3>배열 프리미티브(primitive)치 콜백</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     jint element_count, 
     jvmtiPrimitiveType element_type, 
     const void* elements, 
     void* user_data);</pre>
</blockquote>
에이전트에 의해 제공되는 콜백 함수. 어느 원시형의 배열내의 값을 기술합니다.
        <p></p>
이 함수는, 필요한<a href="#jvmtiHeapVisitControl">비짓트 제어 플래그</a>의 비트 벡터를 돌려줍니다. 이것에 의해, 반복 처리의 전체를 중지해야할 것인가 제발이 정해집니다 (<code>JVMTI_VISIT_OBJECTS</code> 플래그는 무시된다).
        <p></p>
<a href="#heapCallbacks">heap 콜백 함수의 제한</a>을 참조해 주세요.
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    배열 객체의 클래스의 태그 (태그 붙이고되어 있지 않은 클래스의 경우는 제로).  
	  </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.size">size</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    배열의 사이즈 (바이트 단위). <a href="#GetObjectSize"><code>GetObjectSize</code></a>  를 참조.
	  </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    배열 객체의 태그를 포인트 한다. 태그 붙이고되어 있지 않은 객체의 경우는 제로를 포인트 한다. 객체와 관련짓는 태그의 값을 설정하기 위해(때문에), 에이전트는 파라미터에 의해 포인트 되는 <code>jlong</code> 를 설정한다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.element_count">element_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    프리미티브(primitive) 배열의 길이.
	  </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.element_type">element_type</code></td><td><code><a href="#jvmtiPrimitiveType">jvmtiPrimitiveType</a> </code></td><td>
	    배열의 요소의 형태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.elements">elements</code></td><td><code>const void*</code></td><td>
	    배열의 요소. 이 배열은,<code>element_type</code> 의 사이즈를 가지는 <code>element_count</code> 개의 항목으로부터 완성되는 팩 배열이 된다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.user_data">user_data</code></td><td><code>void *</code></td><td>
	    사용자가 입력해, 반복 함수에게 건네진 데이터.  
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="jvmtiStringPrimitiveValueCallback">
<h3>캐릭터 라인 프리미티브(primitive)치 콜백</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     const jchar* value, 
     jint value_length, 
     void* user_data);</pre>
</blockquote>
에이전트에 의해 제공되는 콜백 함수. java.lang.String 의 값을 기술합니다.
        <p></p>
이 함수는, 필요한<a href="#jvmtiHeapVisitControl">비짓트 제어 플래그</a>의 비트 벡터를 돌려줍니다. 이것에 의해, 반복 처리의 전체를 중지해야할 것인가 제발이 정해집니다 (<code>JVMTI_VISIT_OBJECTS</code> 플래그는 무시된다).
        <p></p>
<a href="#heapCallbacks">heap 콜백 함수의 제한</a>을 참조해 주세요.
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="jvmtiStringPrimitiveValueCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    String 클래스의 클래스의 태그 (태그 붙이고되어 있지 않은 클래스의 경우는 제로).  
            
	  </td>
</tr>
<tr>
<td><code id="jvmtiStringPrimitiveValueCallback.size">size</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    캐릭터 라인의 사이즈 (바이트 단위). <a href="#GetObjectSize"><code>GetObjectSize</code></a>  를 참조.
	  </td>
</tr>
<tr>
<td><code id="jvmtiStringPrimitiveValueCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    String 객체의 태그를 포인트 한다. 태그 붙이고되어 있지 않은 객체의 경우는 제로를 포인트 한다. 객체와 관련짓는 태그의 값을 설정하기 위해(때문에), 에이전트는 파라미터에 의해 포인트 되는 <code>jlong</code> 를 설정한다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiStringPrimitiveValueCallback.value">value</code></td><td><code>const <a href="#jchar">jchar</a> *</code></td><td>
	    String 의 값. Unicode 캐릭터 라인으로서 encode 된다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiStringPrimitiveValueCallback.value_length">value_length</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    캐릭터 라인의 길이. 이 길이는, 캐릭터 라인내의 16 비트 Unicode 문자의 수에 동일해진다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiStringPrimitiveValueCallback.user_data">user_data</code></td><td><code>void *</code></td><td>
	    사용자가 입력해, 반복 함수에게 건네진 데이터.  
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="jvmtiReservedCallback">
<h3>장래 사용하기 위해서 예약된 콜백</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jint (JNICALL *jvmtiReservedCallback)
    ();</pre>
</blockquote>
플레이스홀더- -- 장래의 사용을 위해서(때문에) 예약이 끝난 상태입니다.
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="FollowReferences">
<h3>참조의 추적</h3>
<blockquote>
<pre>jvmtiError
FollowReferences(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)</pre>
</blockquote>	
이 함수는, 지정된 객체로부터 직접적, 간접적으로 도달 가능한 객체의 traversal를 개시합니다. <code>initial_object</code> 가 지정되지 않았던 경우는, heap 루트로부터 도달 가능한 모든 객체가 대상이 됩니다. heap 루트는, 시스템 클래스, JNI 글로벌, thread 스택으로부터의 참조, 가베지 컬렉션의 목적으로 루트로서 사용되는 그 외의 객체세트입니다.  
        <p></p>
이 함수는, 참조 그래프를 횡단(traverse) 하는 것으로 동작합니다. <i>A</i>,<i>B</i>,... 하지만 객체를 나타낸다고 합니다. <i>A</i> 로부터 <i>B</i> 에의 참조가 횡단(traverse) 되었을 경우, heap 루트로부터 <i>B</i> 에의 참조가 횡단(traverse) 되었을 경우, 또는 <i>B</i> 가 <a href="#FollowReferences.initial_object"><code>initial_object</code></a>  로서 지정되었을 경우에,<i>B</i> 가 「비짓트」되었다고 합니다. <i></i><i>A</i> 로부터 <i>B</i> 에의 참조가 횡단(traverse) 되는 것은,<i>A</i> 의 비짓트 다음에. 참조의 보고 순서는, 참조의 횡단(traverse) 순서와 같게 됩니다. 객체 참조의 보고는, 에이전트로부터 제공되는 콜백 함수 <a href="#jvmtiHeapReferenceCallback"><code>jvmtiHeapReferenceCallback</code></a>  를 호출하는 것으로 행해집니다. <i>A</i> 로부터 <i>B</i> 에의 참조로,<i>A</i> 는 「참조측」,<i>B</i> 는 「참조처」라고 불립니다. <i></i><i></i>콜백은, 참조 측에서의 참조마다 1 회만 불려 갑니다. 참조 사이클이나, 참조측인 패스가 복수 존재하는 경우도 같습니다. 참조측과 참조처와의 사이에 참조가 복수 존재할 가능성이 있습니다만, 그 경우는, 각각의 참조가 보고됩니다. 이러한 참조를 구별하려면 ,<a href="#jvmtiHeapReferenceCallback"><code>jvmtiHeapReferenceCallback</code></a>  콜백의 <a href="#jvmtiHeapReferenceCallback.reference_kind"><code>reference_kind</code></a>  및 <a href="#jvmtiHeapReferenceCallback.reference_info"><code>reference_info</code></a>  파라미터를 확인합니다.
	<p></p>
이 함수가 보고하는 것은, 객체 참조의 Java 프로그라밍뙻뚭뷰이며, 가상 머신 구현 뷰가 아닙니다. null 이외의 다음의 객체 참조가 보고됩니다.
        <ul type="disc">
          
<li>인스턴스 객체는, 각 비프리미티브(primitive) 인스턴스 필드 (상속된 필드도 포함한다)에의 참조를 보고합니다. </li>
          
<li>인스턴스 객체는, 그 객체의 형태 (클래스)에의 참조를 보고합니다. </li>
          
<li>클래스는, 슈퍼 클래스에의 참조와 직접 구현 또는 확장한 인터페이스에의 참조를 보고합니다. </li>
          
<li>클래스는, 클래스 로더, 보호 도메인, 서명자, 및 정수 풀내의 해결 지음 엔트리에의 참조를 보고합니다. </li>
          
<li>클래스는, 직접 선언된 각 비프리미티브(primitive) static 필드에의 참조를 보고합니다. </li>
          
<li>배열은, 그 배열의 형태 (클래스)와 각 배열 요소에의 참조를 보고한다. </li>
          
<li>프리미티브(primitive) 배열은, 그 배열의 형태에의 참조를 보고합니다. </li>
        
</ul>
        
<p></p>
또, 이 함수를 사용하면(자), 프리미티브(primitive) (객체 이외) 치를 조사할 수도 있습니다. 배열 또는 String 의 프리미티브(primitive)치의 보고는, 객체의 비짓트의 완료 후에 행해집니다. 그 보고시에는, 에이전트가 제공하는 콜백 함수 <a href="#jvmtiArrayPrimitiveValueCallback"><code>jvmtiArrayPrimitiveValueCallback</code></a>  또는 <a href="#jvmtiStringPrimitiveValueCallback"><code>jvmtiStringPrimitiveValueCallback</code></a>  가 불려 갑니다. 어느 프리미티브(primitive) 필드의 보고는, 그 필드를 포함한 객체의 비짓트의 완료 후에 행해집니다. 그 보고시에는, 에이전트가 제공하는 콜백 함수 <a href="#jvmtiPrimitiveFieldCallback"><code>jvmtiPrimitiveFieldCallback</code></a>  가 불려 갑니다.
        <p></p>
콜백이 제공될까 <code>NULL</code> 일까는, 그 콜백이 불려 갈지 어떨지만을 결정합니다. 어느 객체가 비짓트 될까나, 다른 콜백이 불려 갈지 어떨지에 영향을 줄 것은 없습니다. 다만,<a href="#jvmtiHeapReferenceCallback"><code>jvmtiHeapReferenceCallback</code></a>  로부터 반환되는<a href="#jvmtiHeapVisitControl">비짓트 제어 플래그</a>는, 현재의 객체가 참조하고 있는 객체를 비짓트 할지 어떨지를 결정합니다. 이 함수의 파라미터로서 지정되는<a href="#jvmtiHeapFilter">heap 필터 플래그</a>와 <a href="#FollowReferences.klass"><code>klass</code></a>  는, 비짓트 되는 객체는 제어합니다만, 콜백에 의해 보고되는 객체 및 프리미티브(primitive)치는 제어합니다. 예를 들어, 설정된 유일한 콜백이<a href="#FollowReferences.array_primitive_value_callback"><code>배열 프리미티브(primitive)치 콜백</code></a> 이며,<code>klass</code> 가 바이트 배열의 클래스로 설정되었을 경우, 바이트 배열만이 보고됩니다. 이상을 정리했던 것이 다음의 겉(표)입니다.
        <p></p>
        
<table border="1" cellpadding="3" cellspacing="0" width="100%">
          
<tr>
            
<th bgcolor="#EEEEFF" align="center"></th>
            <th bgcolor="#EEEEFF" align="center">
비짓트 대상 객체를 제어한다
            </th>
            <th bgcolor="#EEEEFF" align="center">
보고 대상 객체를 제어한다
            </th>
            <th bgcolor="#EEEEFF" align="center">
보고 대상 프리미티브(primitive)을 제어한다
            </th>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
<a href="#jvmtiHeapReferenceCallback"><code>jvmtiHeapReferenceCallback</code></a>  로부터 반환되는 <a href="#jvmtiHeapVisitControl">히프비짓트 제어 플래그</a> 
            </th>
            <td align="center">
<b>네</b>
            </td>
            <td align="center">
<b>네</b>. 비짓트가 제어되기 (위해)때문에
            </td>
            <td align="center">
<b>네</b>. 비짓트가 제어되기 (위해)때문에
            </td>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
<a href="#FollowReferences.callbacks"><code>callbacks</code></a>  세트내의 <a href="#jvmtiHeapCallbacks.object_reference_callback"><code>object_reference_callback</code></a> 
            </th>
            <td align="center">
아니오
            </td>
            <td align="center">
<b>네</b>
            </td>
            <td align="center">
아니오
            </td>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
<a href="#FollowReferences.heap_filter"><code>heap_filter</code></a> 
            </th>
            <td align="center">
아니오
            </td>
            <td align="center">
<b>네</b>
            </td>
            <td align="center">
<b>네</b>
            </td>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
<a href="#FollowReferences.klass"><code>klass</code></a> 
            </th>
            <td align="center">
아니오
            </td>
            <td align="center">
<b>네</b>
            </td>
            <td align="center">
<b>네</b>
            </td>
          
</tr>
        
</table>
        
<p></p>
이 함수의 실행중, heap의 상태는 변화하지 않습니다. 객체의 할당이나 가베지 컬렉션은 행해지지 않습니다. 따라서, 객체 (포함되고 있는 값도 포함한다)는 변경되지 않습니다. 결과적으로, Java 프로그램 언어의 코드를 실행하는 thread, Java 프로그램 언어의 코드의 실행을 재개하려고 하고 있는 thread, JNI 함수를 실행하려고 하고 있는 thread는, 정지합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>115</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a> </td><td>
	  <a href="#Heap">heap의 카테고리</a>에 설명되고 있도록(듯이), 태그를 설정해, 취득할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="FollowReferences.heap_filter">heap_filter</code></td><td><code><a href="#jint">jint</a> </code></td><td>
이<a href="#jvmtiHeapFilter">heap 필터 플래그</a>의 비트 벡터는, 콜백 함수의 호출 대상이 되는 객체를 제한한다. 이것은 객체 콜백과 프리미티브(primitive) 콜백의 양쪽 모두에 들어맞는다.
          </td>
</tr>
<tr>
<td><code id="FollowReferences.klass">klass</code></td><td><code><a href="#jclass">jclass</a> 
            
          </code></td><td>
콜백이 보고하는 것은, 객체가 이 클래스의 인스턴스인 경우 뿐이다. 객체가 <code>klass</code> 의 슈퍼 클래스의 인스턴스인 경우, 그 객체는 보고되지 않는다. <code>klass</code> 가 인터페이스의 경우, 객체의 보고는 행해지지 않는다. 이것은 객체 콜백과 프리미티브(primitive) 콜백의 양쪽 모두에 들어맞는다.
          <p></p>
<code>klass</code> 가 <code>NULL</code> 의 경우, 콜백은 특정의 클래스의 인스턴스에 제한되지 않는다.
</td>
</tr>
<tr>
<td><code id="FollowReferences.initial_object">initial_object</code></td><td><code><a href="#jobject">jobject</a> 
            
          </code></td><td>
추적하는 객체
          <p></p>
<code>initial_object</code> 가 <code>NULL</code> 의 경우, heap 루트로부터 참조의 추적을 한다.
</td>
</tr>
<tr>
<td><code id="FollowReferences.callbacks">callbacks</code></td><td><code>const <a href="#jvmtiHeapCallbacks">jvmtiHeapCallbacks</a>  *</code></td><td>
일련의 콜백 함수를 정의하는 구조체.
<p></p>에이전트는 <code>jvmtiHeapCallbacks</code> 에 포인터를 건네준다.  </td>
</tr>
<tr>
<td><code id="FollowReferences.user_data">user_data</code></td><td><code>const void
            
          *</code></td><td>
사용자가 입력해, 콜백에게 건네지는 데이터.  
<p></p>에이전트가 포인터를 건네준다. <code>user_data</code> 가 <code>NULL</code> 의 경우,<code>NULL</code> 가 사용자 지정 데이터로서 건네받는다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
<a href="#FollowReferences.klass"><code>klass</code></a>  는 유효한 클래스는 아니다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a> </td><td>
<a href="#FollowReferences.initial_object"><code>initial_object</code></a>  는 유효한 객체는 아니다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
<a href="#FollowReferences.callbacks"><code>callbacks</code></a>  가 <code>NULL</code>.
          
        </td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="IterateThroughHeap">
<h3>heap내에서의 반복해</h3>
<blockquote>
<pre>jvmtiError
IterateThroughHeap(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)</pre>
</blockquote>        
heap내의 모든 객체에 대한 반복 처리를 기동합니다. 도달 가능한 객체도, 그렇지 않은 객체도 포함됩니다. 객체의 비짓트는 특정의 차례에서는 행해지지 않습니다.
        <p></p>
heap 객체의 보고는, 에이전트로부터 제공되는 콜백 함수 <a href="#jvmtiHeapIterationCallback"><code>jvmtiHeapIterationCallback</code></a>  를 호출하는 것으로 행해집니다. 객체간의 참조는 보고되지 않습니다. 도달 가능한 객체만이 필요한 경우나, 객체 참조의 정보가 필요한 경우에는,<a href="#FollowReferences"><code>FollowReferences</code></a>  를 사용해 주세요.
        <p></p>
또, 이 함수를 사용하면(자), 프리미티브(primitive) (객체 이외) 치를 조사할 수도 있습니다. 배열 또는 String 의 프리미티브(primitive)치의 보고는, 객체의 비짓트의 완료 후에 행해집니다. 그 보고시에는, 에이전트가 제공하는 콜백 함수 <a href="#jvmtiArrayPrimitiveValueCallback"><code>jvmtiArrayPrimitiveValueCallback</code></a>  또는 <a href="#jvmtiStringPrimitiveValueCallback"><code>jvmtiStringPrimitiveValueCallback</code></a>  가 불려 갑니다. 어느 프리미티브(primitive) 필드의 보고는, 그 필드를 포함한 객체의 비짓트의 완료 후에 행해집니다. 그 보고시에는, 에이전트가 제공하는 콜백 함수 <a href="#jvmtiPrimitiveFieldCallback"><code>jvmtiPrimitiveFieldCallback</code></a>  가 불려 갑니다.
        <p></p>
콜백으로부터 반환되는<a href="#jvmtiHeapVisitControl">히프비짓트 제어 플래그</a>에 의해 반복 처리가 중지되지 않는 한, heap내의 모든 객체가 비짓트 됩니다. 콜백이 제공될까 <code>NULL</code> 일까는, 그 콜백이 불려 갈지 어떨지만을 결정합니다. 어느 객체가 비짓트 될까나, 다른 콜백이 불려 갈지 어떨지에 영향을 줄 것은 없습니다. 이 함수의 파라미터로서 지정되는<a href="#jvmtiHeapFilter">heap 필터 플래그</a>와 <a href="#IterateThroughHeap.klass"><code>klass</code></a>  는, 비짓트 되는 객체는 제어합니다만, 콜백에 의해 보고되는 객체 및 프리미티브(primitive)치는 제어합니다. 예를 들어, 설정된 유일한 콜백이<a href="#IterateThroughHeap.array_primitive_value_callback"><code>배열 프리미티브(primitive)치 콜백</code></a> 이며,<code>klass</code> 가 바이트 배열의 클래스로 설정되었을 경우, 바이트 배열만이 보고됩니다. 이상을 정리했던 것이 다음의 겉(표)입니다. 이것을 <a href="#FollowReferences"><code>FollowReferences</code></a>  와 비교해 주세요.
        <p></p>
        
<table border="1" cellpadding="3" cellspacing="0" width="100%">
          
<tr>
            
<th bgcolor="#EEEEFF" align="center"></th>
            <th bgcolor="#EEEEFF" align="center">
비짓트 대상 객체를 제어한다
            </th>
            <th bgcolor="#EEEEFF" align="center">
보고 대상 객체를 제어한다
            </th>
            <th bgcolor="#EEEEFF" align="center">
보고 대상 프리미티브(primitive)을 제어한다
            </th>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
<a href="#jvmtiHeapIterationCallback"><code>jvmtiHeapIterationCallback</code></a>  로부터 반환되는 <a href="#jvmtiHeapVisitControl">히프비짓트 제어 플래그</a> 
            </th>
            <td align="center">
아니오<br>(다만, 반복 처리가 중지되는 경우는 제외하다)
            </td>
            <td align="center">
아니오<br>(다만, 반복 처리가 중지되는 경우는 제외하다)
            </td>
            <td align="center">
아니오<br>(다만, 반복 처리가 중지되는 경우는 제외하다)
            </td>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
<a href="#IterateThroughHeap.callbacks"><code>callbacks</code></a>  세트내의 <a href="#jvmtiHeapCallbacks.object_callback"><code>object_callback</code></a> 
            </th>
            <td align="center">
아니오
            </td>
            <td align="center">
<b>네</b>
            </td>
            <td align="center">
아니오
            </td>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
<a href="#IterateThroughHeap.heap_filter"><code>heap_filter</code></a> 
            </th>
            <td align="center">
아니오
            </td>
            <td align="center">
<b>네</b>
            </td>
            <td align="center">
<b>네</b>
            </td>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
<a href="#IterateThroughHeap.klass"><code>klass</code></a> 
            </th>
            <td align="center">
아니오
            </td>
            <td align="center">
<b>네</b>
            </td>
            <td align="center">
<b>네</b>
            </td>
          
</tr>
        
</table>
        
<p></p>
이 함수의 실행중, heap의 상태는 변화하지 않습니다. 객체의 할당이나 가베지 컬렉션은 행해지지 않습니다. 따라서, 객체 (포함되고 있는 값도 포함한다)는 변경되지 않습니다. 결과적으로, Java 프로그램 언어의 코드를 실행하는 thread, Java 프로그램 언어의 코드의 실행을 재개하려고 하고 있는 thread, JNI 함수를 실행하려고 하고 있는 thread는, 정지합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>116</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a> </td><td>
	  <a href="#Heap">heap의 카테고리</a>에 설명되고 있도록(듯이), 태그를 설정해, 취득할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="IterateThroughHeap.heap_filter">heap_filter</code></td><td><code><a href="#jint">jint</a> </code></td><td>
이<a href="#jvmtiHeapFilter">heap 필터 플래그</a>의 비트 벡터는, 콜백 함수의 호출 대상이 되는 객체를 제한한다. 이것은 객체 콜백과 프리미티브(primitive) 콜백의 양쪽 모두에 들어맞는다.
          </td>
</tr>
<tr>
<td><code id="IterateThroughHeap.klass">klass</code></td><td><code><a href="#jclass">jclass</a> 
            
          </code></td><td>
콜백이 보고하는 것은, 객체가 이 클래스의 인스턴스인 경우 뿐이다. 객체가 <code>klass</code> 의 슈퍼 클래스의 인스턴스인 경우, 그 객체는 보고되지 않는다. <code>klass</code> 가 인터페이스의 경우, 객체의 보고는 행해지지 않는다. 이것은 객체 콜백과 프리미티브(primitive) 콜백의 양쪽 모두에 들어맞는다.
          <p></p>
<code>klass</code> 가 <code>NULL</code> 의 경우, 콜백은 특정의 클래스의 인스턴스에 제한되지 않는다.
</td>
</tr>
<tr>
<td><code id="IterateThroughHeap.callbacks">callbacks</code></td><td><code>const <a href="#jvmtiHeapCallbacks">jvmtiHeapCallbacks</a>  *</code></td><td>
일련의 콜백 함수를 정의하는 구조체.
<p></p>에이전트는 <code>jvmtiHeapCallbacks</code> 에 포인터를 건네준다.  </td>
</tr>
<tr>
<td><code id="IterateThroughHeap.user_data">user_data</code></td><td><code>const void
            
          *</code></td><td>
사용자가 입력해, 콜백에게 건네지는 데이터.  
<p></p>에이전트가 포인터를 건네준다. <code>user_data</code> 가 <code>NULL</code> 의 경우,<code>NULL</code> 가 사용자 지정 데이터로서 건네받는다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
<a href="#IterateThroughHeap.klass"><code>klass</code></a>  는 유효한 클래스는 아니다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
<a href="#IterateThroughHeap.callbacks"><code>callbacks</code></a>  가 <code>NULL</code>.
          
        </td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetTag">
<h3>태그의 취득</h3>
<blockquote>
<pre>jvmtiError
GetTag(jvmtiEnv* env,
            jobject object,
            jlong* tag_ptr)</pre>
</blockquote>
객체에 관련지을 수 있었던 태그를 가져옵니다. 태그는 장 정수치로, 일반적으로, 객체 정보의 일의의 식별자 또는 포인터를 포함하기 위해서 사용됩니다. 태그의 설정에는,<a href="#SetTag"><code>SetTag</code></a>  함수를 사용합니다. 태그가 설정되어 있지 않은 객체는, 태그치로서 제로를 돌려줍니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>106</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a> </td><td>
	  <a href="#Heap">heap의 카테고리</a>에 설명되고 있도록(듯이), 태그를 설정해, 취득할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetTag.object">object</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	      태그가 취득되는 객체.
	    </td>
</tr>
<tr>
<td><code id="GetTag.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    돌아왔을 때, 참조되는 장 정수치에 태그치가 설정되어 있다.
	  <p></p>에이전트는 <code>jlong</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jlong</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a> </td><td>
	  <a href="#GetTag.object"><code>object</code></a>  가 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetTag.tag_ptr"><code>tag_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetTag">
<h3>태그의 설정</h3>
<blockquote>
<pre>jvmtiError
SetTag(jvmtiEnv* env,
            jobject object,
            jlong tag)</pre>
</blockquote>
객체에 관련지을 수 있었던 태그를 설정합니다. 태그는 장 정수치로, 일반적으로, 객체 정보의 일의의 식별자 또는 포인터를 포함하기 위해서 사용됩니다. 태그의 표시에는,<a href="#GetTag"><code>GetTag</code></a>  함수를 사용합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>107</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a> </td><td>
	  <a href="#Heap">heap의 카테고리</a>에 설명되고 있도록(듯이), 태그를 설정해, 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetTag.object">object</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	      태그가 설정되는 객체.
	    </td>
</tr>
<tr>
<td><code id="SetTag.tag">tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    태그의 새로운 값.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a> </td><td>
	  <a href="#SetTag.object"><code>object</code></a>  가 객체는 아니다.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetObjectsWithTags">
<h3>태그를 사용한 객체의 취득</h3>
<blockquote>
<pre>jvmtiError
GetObjectsWithTags(jvmtiEnv* env,
            jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr)</pre>
</blockquote>
	heap내의 지정된 태그를 가지는 객체를 돌려줍니다. 객체와 태그의 병행 배열의 형식이 됩니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>114</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a> </td><td>
	  <a href="#Heap">heap의 카테고리</a>에 설명되고 있도록(듯이), 태그를 설정해, 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetObjectsWithTags.tag_count">tag_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	      주사 하는 태그의 수.
	    </td>
</tr>
<tr>
<td><code id="GetObjectsWithTags.tags">tags</code></td><td><code>const <a href="#jlong">jlong</a>  *</code></td><td>
	      이러한 태그를 붙일 수 있었던 객체를 주사 한다. 이 배열내에서는, 제로는 사용할 수 없다.
	    <p></p>에이전트는 <code>jlong</code> 의 <code>tag_count</code> 요소의 배열을 건네준다.  </td>
</tr>
<tr>
<td><code id="GetObjectsWithTags.count_ptr">count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	      <a href="#GetObjectsWithTags.tags"><code>tags</code></a>  내의 임의의 태그를 가지는 객체의 수를 돌려준다.
	    <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetObjectsWithTags.object_result_ptr">object_result_ptr</code></td><td><code><a href="#jobject">jobject</a> 
	    
	  **</code></td><td>
	      <a href="#GetObjectsWithTags.tags"><code>tags</code></a>  내의 임의의 태그를 가지는 객체의 배열을 돌려준다.
	    <p></p>에이전트는 <code>jobject*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jobject*</code> 는, 사이즈 <code>*count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>object_result_ptr</code> 가 <code>NULL</code> 의 경우, 이 정보는 돌려주어지지 않다. <code>object_result_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
<tr>
<td><code id="GetObjectsWithTags.tag_result_ptr">tag_result_ptr</code></td><td><code><a href="#jlong">jlong</a> 
	    
	  **</code></td><td>
	      <a href="#GetObjectsWithTags.object_result_ptr"><code>object_result_ptr</code></a>  내의 각 객체에 대해서, 대응하는 인덱스의 태그를 돌려준다.
	    <p></p>에이전트는 <code>jlong*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jlong*</code> 는, 사이즈 <code>*count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>tag_result_ptr</code> 가 <code>NULL</code> 의 경우, 이 정보는 돌려주어지지 않다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetObjectsWithTags.tags"><code>tags</code></a>  내에 제로가 존재한다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetObjectsWithTags.tag_count"><code>tag_count</code></a>  가 <code>0</code> 보다 작다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetObjectsWithTags.tags"><code>tags</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetObjectsWithTags.count_ptr"><code>count_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="ForceGarbageCollection">
<h3>가베지 컬렉션의 강제</h3>
<blockquote>
<pre>jvmtiError
ForceGarbageCollection(jvmtiEnv* env)</pre>
</blockquote>
VM 에 가베지 컬렉션의 실행을 강제합니다. 가베지 컬렉션은 가능한 한 완전하게 행해집니다. 이 함수는, 파이나라이자를 실행시키지 않습니다. 이 함수는, 가베지 컬렉션이 완료할 때까지 종료하지 않습니다.
        <p></p>
가베지 컬렉션은 가능한 한 완전하게 실행됩니다만, 이 함수가 돌아오기까지 모든 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트가 송신되고 있다고 하는 보증은 없습니다. 특히, finalize 기다리는 객체가 해제되지 않을 가능성이 있습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>108</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>를 돌려준다</td>
</tr>
</table>
<p id="Heap_1_0"></p>
<hr noshade="noshade" size="3">
<h2 align="center">heap (1.0)</h2>heap (1.0)의 함수:
  <ul>
<li>
<a href="#IterateOverObjectsReachableFromObject">객체로부터 도달 가능한 객체의 반복</a> 
</li>
<li>
<a href="#IterateOverReachableObjects">도달 가능한 객체의 반복</a> 
</li>
<li>
<a href="#IterateOverHeap">heap의 반복</a> 
</li>
<li>
<a href="#IterateOverInstancesOfClass">클래스의 인스턴스의 반복</a> 
</li>
</ul>heap (1.0)의 함수형:
    <ul>
<li>
<a href="#jvmtiHeapObjectCallback">heap 객체의 콜백</a> 
</li>
<li>
<a href="#jvmtiHeapRootCallback">heap 루트 객체의 콜백</a> 
</li>
<li>
<a href="#jvmtiStackReferenceCallback">스택 참조 객체의 콜백</a> 
</li>
<li>
<a href="#jvmtiObjectReferenceCallback">객체 참조의 콜백</a> 
</li>
</ul>heap (1.0)의 형태:
    <ul>
<li>
<a href="#jvmtiHeapObjectFilter"><code>jvmtiHeapObjectFilter</code></a>  - heap 객체의 필터의 열거</li>
<li>
<a href="#jvmtiHeapRootKind"><code>jvmtiHeapRootKind</code></a>  - heap 루트의 종류의 열거</li>
<li>
<a href="#jvmtiObjectReferenceKind"><code>jvmtiObjectReferenceKind</code></a>  - 객체 참조의 열거</li>
<li>
<a href="#jvmtiIterationControl"><code>jvmtiIterationControl</code></a>  - 반복 제어의 열거</li>
</ul>
      
<b>이러한 함수 및 데이터형은 원의 JVM<small style="font-size: xx-small">&nbsp;</small>TI Version 1.0 으로 도입된 것이어, 보다</b> <a href="#Heap"><b>강력해 유연성의 높은 버젼</b></a> 으로 옮겨놓을 수 있었습니다. 새로운 버젼의 특징을 다음에 나타냅니다. <b></b>
      
<ul type="disc">
        
<li>
          
<b>프리미티브(primitive)치 (Strings, 배열, 및 프리미티브(primitive) 필드의 값)에의 액세스를 가능하게 한다</b>
        
</li>
        
<li>
          
<b>참조측의 태그를 설정할 수 있도록(듯이) 한다. 이 때문에, 보다 효율적인 로컬라이즈 된 참조 그래프의 구축이 가능해진다</b>
        
</li>
        
<li>
          
<b>보다 광범위한 필터링 기능을 제공한다</b>
        
</li>
        
<li>
          
<b>확장 가능하다. 이 때문에, JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 장래의 버젼으로 확장을 베풀 수가 있다</b>
        
</li>
      
</ul>
      
<p></p>
      
<b></b> <a href="#Heap"><b>현재의 heap 함수</b></a> 를 사용해 주세요.
        <p></p>
        
<blockquote>
<a name="jvmtiHeapObjectFilter"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">heap 객체의 필터의 열거 (<code>jvmtiHeapObjectFilter</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_OBJECT_TAGGED">JVMTI_HEAP_OBJECT_TAGGED</code></td><td align="right">1</td><td>
	    태그 첨부 객체만.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_OBJECT_UNTAGGED">JVMTI_HEAP_OBJECT_UNTAGGED</code></td><td align="right">2</td><td>
	    태그 없음 객체만.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_OBJECT_EITHER">JVMTI_HEAP_OBJECT_EITHER</code></td><td align="right">3</td><td>
	    태그 첨부 객체 또는 태그 없음 객체.
	  </td>
</tr>
</table>
</blockquote>

        
<blockquote>
<a name="jvmtiHeapRootKind"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">heap 루트의 종류의 열거 (<code>jvmtiHeapRootKind</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_JNI_GLOBAL">JVMTI_HEAP_ROOT_JNI_GLOBAL</code></td><td align="right">1</td><td>
	    JNI 글로벌 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_SYSTEM_CLASS">JVMTI_HEAP_ROOT_SYSTEM_CLASS</code></td><td align="right">2</td><td>
	    시스템 클래스.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_MONITOR">JVMTI_HEAP_ROOT_MONITOR</code></td><td align="right">3</td><td>
	    모니터.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_STACK_LOCAL">JVMTI_HEAP_ROOT_STACK_LOCAL</code></td><td align="right">4</td><td>
	    스택 로컬.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_JNI_LOCAL">JVMTI_HEAP_ROOT_JNI_LOCAL</code></td><td align="right">5</td><td>
	    JNI 로컬 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_THREAD">JVMTI_HEAP_ROOT_THREAD</code></td><td align="right">6</td><td>
	    thread
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_OTHER">JVMTI_HEAP_ROOT_OTHER</code></td><td align="right">7</td><td>
	    그 외.
	  </td>
</tr>
</table>
</blockquote>

        
<blockquote>
<a name="jvmtiObjectReferenceKind"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">객체 참조의 열거 (<code>jvmtiObjectReferenceKind</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_CLASS">JVMTI_REFERENCE_CLASS</code></td><td align="right">1</td><td>
	    객체로부터 그 클래스의 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_FIELD">JVMTI_REFERENCE_FIELD</code></td><td align="right">2</td><td>
	    객체로부터, 그 객체의 몇개의 인스턴스 필드의 값에의 참조. 이런 종류의 참조의 경우,<a href="#jvmtiObjectReferenceCallback">jvmtiObjectReferenceCallback</a>  의 <code>referrer_index</code> 파라미터는 인스턴스 필드의 인덱스. 인덱스는, 모든 객체의 필드의 순서가 기본으로 된다. 클래스에서 직접 선언된 static 및 인스턴스 필드가 포함되는 것 외에 슈퍼 클래스 및 슈퍼 인터페이스로 선언된 모든 필드 (public 와 private 의 양쪽 모두)가 포함된다. 그 때문에 인덱스는, 직접 선언된 클래스에 있는 필드의 인덱스 (<a href="#GetClassFields"><code>「GetClassFields」</code></a>  참조)와 모든 슈퍼 클래스 및 슈퍼 인터페이스로 선언된 필드 (public 와 private 의 양쪽 모두)를 서로 더한 것으로 계산된다. 인덱스는 0 으로부터 시작된다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_ARRAY_ELEMENT">JVMTI_REFERENCE_ARRAY_ELEMENT</code></td><td align="right">3</td><td>
	    배열로부터, 이 배열의 몇개의 요소에의 참조. 이런 종류의 참조의 경우,<a href="#jvmtiObjectReferenceCallback">jvmtiObjectReferenceCallback</a>  의 <code>referrer_index</code> 파라미터는 배열의 인덱스.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_CLASS_LOADER">JVMTI_REFERENCE_CLASS_LOADER</code></td><td align="right">4</td><td>
	    클래스로부터 그 클래스 로더에의 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_SIGNERS">JVMTI_REFERENCE_SIGNERS</code></td><td align="right">5</td><td>
	    클래스로부터 그 서명자의 배열에의 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_PROTECTION_DOMAIN">JVMTI_REFERENCE_PROTECTION_DOMAIN</code></td><td align="right">6</td><td>
	    클래스로부터 그 보호 도메인에의 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_INTERFACE">JVMTI_REFERENCE_INTERFACE</code></td><td align="right">7</td><td>
	    클래스로부터, 그 클래스의 몇개의 인터페이스에의 참조.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_STATIC_FIELD">JVMTI_REFERENCE_STATIC_FIELD</code></td><td align="right">8</td><td>
	    클래스로부터, 그 클래스의 몇개의 static 필드의 값에의 참조. 이런 종류의 참조의 경우,<a href="#jvmtiObjectReferenceCallback">jvmtiObjectReferenceCallback</a>  의 <code>referrer_index</code> 파라미터는 static 필드의 인덱스. 인덱스는, 모든 객체의 필드의 순서가 기본으로 된다. 클래스에서 직접 선언된 static 및 인스턴스 필드가 포함되는 것 외에 슈퍼 클래스 및 슈퍼 인터페이스로 선언된 모든 필드 (public 와 private 의 양쪽 모두)가 포함된다. 그 때문에 인덱스는, 직접 선언된 클래스에 있는 필드의 인덱스 (<a href="#GetClassFields"><code>「GetClassFields」</code></a>  참조)와 모든 슈퍼 클래스 및 슈퍼 인터페이스로 선언된 필드 (public 와 private 의 양쪽 모두)를 서로 더한 것으로 계산된다. 인덱스는 0 으로부터 시작된다. 주:이 정의는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 1.0 스펙에서의 정의와 다르다.
            <p style="color: purple">
원리의 설명:기존의 구현 속에서, 1.0 의 정의를 사용한 것은 없다. </p>
	  
</td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_CONSTANT_POOL">JVMTI_REFERENCE_CONSTANT_POOL</code></td><td align="right">9</td><td>
	    클래스로부터 정수 풀내의 해결 지음 엔트리의 참조. 이런 종류의 참조의 경우,<a href="#jvmtiObjectReferenceCallback">jvmtiObjectReferenceCallback</a>  의 <code>referrer_index</code> 파라미터는, 클래스의 정수 풀 테이블의 인덱스로, 1 으로부터 시작된다. <a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#20080">「Constant Pool」</a>섹션을 참조. <i></i>
	  </td>
</tr>
</table>
</blockquote>

        
<blockquote>
<a name="jvmtiIterationControl"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">반복 제어의 열거 (<code>jvmtiIterationControl</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_ITERATION_CONTINUE">JVMTI_ITERATION_CONTINUE</code></td><td align="right">1</td><td>
	    반복 처리를 계속. 참조의 반복 처리의 경우, 이 객체의 참조에 따른다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_ITERATION_IGNORE">JVMTI_ITERATION_IGNORE</code></td><td align="right">2</td><td>
	    반복 처리를 계속. 참조의 반복 처리의 경우, 이 객체의 참조를 무시한다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_ITERATION_ABORT">JVMTI_ITERATION_ABORT</code></td><td align="right">0</td><td>
	    반복 처리를 중지.
	  </td>
</tr>
</table>
</blockquote>
    
<p></p>
<hr noshade="noshade" width="100%" size="1" id="jvmtiHeapObjectCallback">
<h3>heap 객체의 콜백</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     void* user_data);</pre>
</blockquote>
에이전트에 의해 제공되는 콜백 함수. heap내의 객체를 기술합니다만, 값은 건네주지 않습니다.
        <p></p>
반복 처리를 계속하는 경우, 반환값은 <code>JVMTI_ITERATION_CONTINUE</code> 입니다. 반복 처리를 정지하는 경우, 반환값은 <code>JVMTI_ITERATION_ABORT</code> 입니다.
        <p></p>
<a href="#heapCallbacks">heap 콜백 함수의 제한</a>을 참조해 주세요.
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="jvmtiHeapObjectCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    객체의 클래스의 태그 (태그 붙이고되어 있지 않은 클래스의 경우는 제로). 객체가 실행시 클래스를 나타내는 경우,<code>class_tag</code> 는 <code>java.lang.Class</code> 에 관련짓고 된 태그 (<code>java.lang.Class</code> 가 태그 붙이고되어 있지 않은 경우는 제로).
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapObjectCallback.size">size</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    객체의 사이즈 (바이트 단위). <a href="#GetObjectSize"><code>GetObjectSize</code></a>  를 참조.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapObjectCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    객체의 태그치. 태그 붙이고되어 있지 않은 객체의 경우는 제로. 객체와 관련짓는 태그의 값을 설정하기 위해(때문에), 에이전트는 파라미터에 의해 포인트 되는 <code>jlong</code> 를 설정한다.  
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapObjectCallback.user_data">user_data</code></td><td><code>void *</code></td><td>
	    사용자가 입력해, 반복 함수에게 건네진 데이터.  
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="jvmtiHeapRootCallback">
<h3>heap 루트 객체의 콜백</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind, 
     jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     void* user_data);</pre>
</blockquote>
에이전트에 의해 제공되는 콜백 함수. 가베지 컬렉션의 목적으로, 루트 객체에 대해 설명합니다만, 값은 건네주지 않습니다.
        <p></p>
반복 처리를 계속하는 경우, 반환값은 <code>JVMTI_ITERATION_CONTINUE</code> 입니다.  참조 객체로부터의 참조를 속행하지 않고 반복 처리를 계속하는 경우, 반환값은 <code>JVMTI_ITERATION_IGNORE</code> 입니다.  반복 처리를 정지하는 경우, 반환값은 <code>JVMTI_ITERATION_ABORT</code> 입니다.
        <p></p>
<a href="#heapCallbacks">heap 콜백 함수의 제한</a>을 참조해 주세요.
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="jvmtiHeapRootCallback.root_kind">root_kind</code></td><td><code><a href="#jvmtiHeapRootKind">jvmtiHeapRootKind</a> </code></td><td>
	    heap 루트의 종류
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapRootCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    객체의 클래스의 태그 (태그 붙이고되어 있지 않은 클래스의 경우는 제로). 객체가 실행시 클래스를 나타내는 경우,<code>class_tag</code> 는 <code>java.lang.Class</code> 에 관련짓고 된 태그 (<code>java.lang.Class</code> 가 태그 붙이고되어 있지 않은 경우는 제로).
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapRootCallback.size">size</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    객체의 사이즈 (바이트 단위). <a href="#GetObjectSize"><code>GetObjectSize</code></a>  를 참조.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapRootCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    객체의 태그치. 태그 붙이고되어 있지 않은 객체의 경우는 제로. 객체와 관련짓는 태그의 값을 설정하기 위해(때문에), 에이전트는 파라미터에 의해 포인트 되는 <code>jlong</code> 를 설정한다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapRootCallback.user_data">user_data</code></td><td><code>void *</code></td><td>
	    사용자가 입력해, 반복 함수에게 건네진 데이터.  
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="jvmtiStackReferenceCallback">
<h3>스택 참조 객체의 콜백</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind, 
     jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     jlong thread_tag, 
     jint depth, 
     jmethodID method, 
     jint slot, 
     void* user_data);</pre>
</blockquote>
에이전트에 의해 제공되는 콜백 함수. 가베지 컬렉션의 목적으로, 스택상의 루트 객체에 대해 설명합니다만, 값은 건네주지 않습니다.
        <p></p>
반복 처리를 계속하는 경우, 반환값은 <code>JVMTI_ITERATION_CONTINUE</code> 입니다.  참조 객체로부터의 참조를 속행하지 않고 반복 처리를 계속하는 경우, 반환값은 <code>JVMTI_ITERATION_IGNORE</code> 입니다.  반복 처리를 정지하는 경우, 반환값은 <code>JVMTI_ITERATION_ABORT</code> 입니다.
        <p></p>
<a href="#heapCallbacks">heap 콜백 함수의 제한</a>을 참조해 주세요.
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.root_kind">root_kind</code></td><td><code><a href="#jvmtiHeapRootKind">jvmtiHeapRootKind</a> </code></td><td>
	    루트의 종류 (<code>JVMTI_HEAP_ROOT_STACK_LOCAL</code> 또는 <code>JVMTI_HEAP_ROOT_JNI_LOCAL</code>).
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
객체의 클래스의 태그 (태그 붙이고되어 있지 않은 클래스의 경우는 제로). 객체가 실행시 클래스를 나타내는 경우,<code>class_tag</code> 는 <code>java.lang.Class</code> 에 관련짓고 된 태그 (<code>java.lang.Class</code> 가 태그 붙이고되어 있지 않은 경우는 제로).
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.size">size</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    객체의 사이즈 (바이트 단위). <a href="#GetObjectSize"><code>GetObjectSize</code></a>  를 참조.
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    객체의 태그치. 태그 붙이고되어 있지 않은 객체의 경우는 제로. 객체와 관련짓는 태그의 값을 설정하기 위해(때문에), 에이전트는 파라미터에 의해 포인트 되는 <code>jlong</code> 를 설정한다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.thread_tag">thread_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    이 스택에 대응하는 thread의 태그. 태그 붙이고되어 있지 않은 경우는 제로.
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    프레임의 깊이.  
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    이 프레임내에서 실행되고 있는 메소드.
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.slot">slot</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    슬롯 번호.
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.user_data">user_data</code></td><td><code>void *</code></td><td>
	    사용자가 입력해, 반복 함수에게 건네진 데이터.  
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="jvmtiObjectReferenceCallback">
<h3>객체 참조의 콜백</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind, 
     jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     jlong referrer_tag, 
     jint referrer_index, 
     void* user_data);</pre>
</blockquote>
에이전트에 의해 제공되는 콜백 함수. 어느 객체 (참조측)로부터 다른 객체 (참조처)의 참조에 대해 설명합니다.
        <p></p>
반복 처리를 계속하는 경우, 반환값은 <code>JVMTI_ITERATION_CONTINUE</code> 입니다.  참조 객체로부터의 참조를 속행하지 않고 반복 처리를 계속하는 경우, 반환값은 <code>JVMTI_ITERATION_IGNORE</code> 입니다.  반복 처리를 정지하는 경우, 반환값은 <code>JVMTI_ITERATION_ABORT</code> 입니다.
        <p></p>
<a href="#heapCallbacks">heap 콜백 함수의 제한</a>을 참조해 주세요.
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.reference_kind">reference_kind</code></td><td><code><a href="#jvmtiObjectReferenceKind">jvmtiObjectReferenceKind</a> </code></td><td>
	    참조형.
	  </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    참조되는 객체의 클래스의 태그 (태그 붙이고되어 있지 않은 클래스의 경우는 제로). 참조된 객체가 실행시 클래스를 나타내는 경우,<code>class_tag</code> 는 <code>java.lang.Class</code> 에 관련짓고 된 태그 (<code>java.lang.Class</code> 가 태그 붙이고되어 있지 않은 경우는 제로).
	  </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.size">size</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    참조되는 객체의 사이즈 (바이트 단위). <a href="#GetObjectSize"><code>GetObjectSize</code></a>  를 참조.
	  </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    참조되는 객체의 태그치.  태그 붙이고되어 있지 않은 객체의 경우는 제로. 객체와 관련짓는 태그의 값을 설정하기 위해(때문에), 에이전트는 파라미터에 의해 포인트 되는 <code>jlong</code> 를 설정한다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.referrer_tag">referrer_tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    참조측의 객체의 태그치.  태그 붙이고되어 있지 않은 객체의 경우는 제로.
	  </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.referrer_index">referrer_index</code></td><td><code><a href="#jint">jint</a> </code></td><td>	    
	    <code>JVMTI_REFERENCE_FIELD</code> 형 또는 <code>JVMTI_REFERENCE_STATIC_FIELD</code> 형의 참조의 경우, 참조측 객체의 필드의 인덱스. 인덱스는 객체의 모든 필드의 순서가 기본으로 된다. 상세한 설명에 대해서는,<a href="#JVMTI_REFERENCE_FIELD">JVMTI_REFERENCE_FIELD</a>  또는 <a href="#JVMTI_REFERENCE_STATIC_FIELD">JVMTI_REFERENCE_STATIC_FIELD</a>  를 참조.
	    <p></p>
	    형태 <code>JVMTI_REFERENCE_ARRAY_ELEMENT</code> 의 참조의 경우는, 배열 인덱스. 상세한 설명에 대해서는,<a href="#JVMTI_REFERENCE_ARRAY_ELEMENT">JVMTI_REFERENCE_ARRAY_ELEMENT</a>  를 참조.
	    <p></p>
	    형태 <code>JVMTI_REFERENCE_CONSTANT_POOL</code> 의 참조의 경우는, 클래스의 정수 풀에 대한 인덱스.  상세한 설명에 대해서는,<a href="#JVMTI_REFERENCE_CONSTANT_POOL">JVMTI_REFERENCE_CONSTANT_POOL</a>  를 참조.
	    <p></p>
	    그 외의 참조의 경우,<code>referrer_index</code> 는 <code>-1</code>.
	  </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.user_data">user_data</code></td><td><code>void *</code></td><td>
	    사용자가 입력해, 반복 함수에게 건네진 데이터.  
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="IterateOverObjectsReachableFromObject">
<h3>객체로부터 도달 가능한 객체의 반복</h3>
<blockquote>
<pre>jvmtiError
IterateOverObjectsReachableFromObject(jvmtiEnv* env,
            jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data)</pre>
</blockquote>	
이 함수는, 지정된 객체로부터 직접 또는 간접적으로 도달 가능한 모든 객체에 대해서 반복 처리를 실시합니다. 객체 B 를 참조하는 각 객체 A (참조측 객체)에 대해서, 지정된 콜백 함수가 불려 가 객체 참조에 대해 설명합니다. 콜백은, 참조 측에서의 참조마다 1 회만 불려 갑니다. 참조 사이클이나, 참조측인 패스가 복수 존재하는 경우도 같습니다. 참조측과 참조되는 측의 사이에, 복수의 참조가 존재하는 경우가 있습니다. 이러한 식별에는,<a href="#jvmtiObjectReferenceCallback.reference_kind"><code>jvmtiObjectReference.reference_ (종류)</code></a>  와 <a href="#jvmtiObjectReferenceCallback.referrer_index"><code>jvmtiObjectReference.referrer_ (인덱스)</code></a>  를 사용합니다. 객체의 콜백은, 항상 참조측의 콜백의 나중에 행해지겠습니다.
        <p></p>
보고되는 객체 참조에 대해서는,<a href="#FollowReferences"><code>FollowReferences</code></a>  를 참조해 주세요.
        <p></p>
이 함수의 실행중, heap의 상태는 변화하지 않습니다. 객체의 할당이나 가베지 컬렉션은 행해지지 않습니다. 따라서, 객체 (포함되고 있는 값도 포함한다)는 변경되지 않습니다. 결과적으로, Java 프로그램 언어의 코드를 실행하는 thread, Java 프로그램 언어의 코드의 실행을 재개하려고 하고 있는 thread, JNI 함수를 실행하려고 하고 있는 thread는, 정지합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>109</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a> </td><td>
	  <a href="#Heap">heap의 카테고리</a>에 설명되고 있도록(듯이), 태그를 설정해, 취득할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="IterateOverObjectsReachableFromObject.object">object</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	      객체
	    </td>
</tr>
<tr>
<td><code id="IterateOverObjectsReachableFromObject.object_reference_callback">object_reference_callback</code></td><td><code><a href="#jvmtiObjectReferenceCallback">jvmtiObjectReferenceCallback</a> </code></td><td>
	      각 객체 참조를 기술하기 위해서 불려 가는 콜백.
	    <p></p>
</td>
</tr>
<tr>
<td><code id="IterateOverObjectsReachableFromObject.user_data">user_data</code></td><td><code>const void
	    
	  *</code></td><td>
	    사용자가 입력해, 콜백에게 건네지는 데이터.  
	  <p></p>에이전트가 포인터를 건네준다. <code>user_data</code> 가 <code>NULL</code> 의 경우,<code>NULL</code> 가 사용자 지정 데이터로서 건네받는다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a> </td><td>
	  <a href="#IterateOverObjectsReachableFromObject.object"><code>object</code></a>  가 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#IterateOverObjectsReachableFromObject.object_reference_callback"><code>object_reference_callback</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="IterateOverReachableObjects">
<h3>도달 가능한 객체의 반복</h3>
<blockquote>
<pre>jvmtiError
IterateOverReachableObjects(jvmtiEnv* env,
            jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data)</pre>
</blockquote>
이 함수는, 루트 객체와 루트 객체로부터 직접 또는 간접적으로 도달 가능한 모든 객체에 대해서 반복 처리를 실시합니다. 루트 객체는, 시스템 클래스, JNI 글로벌, thread 스택으로부터의 참조, 가베지 컬렉션의 목적으로 루트로서 사용되는 그 외의 객체세트로 구성됩니다.  
	<p></p>
	각 루트에,<a href="#IterateOverReachableObjects.heap_root_callback"><code>heap_root_callback</code></a> 또는<a href="#IterateOverReachableObjects.stack_ref_callback"><code>stack_root_callback</code></a> 가 불려 갑니다. 객체는, 1 개(살) 이상의 이유로써 루트 객체가 될 수가 있습니다. 이 경우, 개개의 이유에 대해서 적절한 콜백이 불려 갑니다.
	<p></p>
	각 객체 참조에,<a href="#IterateOverReachableObjects.object_ref_callback"><code>object_ref_callback</code></a> 함수가 불려 가 객체 참조에 대해 설명합니다. 콜백은, 참조 측에서의 참조마다 1 회만 불려 갑니다. 참조 사이클이나, 참조측인 패스가 복수 존재하는 경우도 같습니다. 참조측과 참조되는 측의 사이에, 복수의 참조가 존재하는 경우가 있습니다. 이러한 식별에는,<a href="#jvmtiObjectReferenceCallback.reference_kind"><code>jvmtiObjectReference.reference_ (종류)</code></a>  와 <a href="#jvmtiObjectReferenceCallback.referrer_index"><code>jvmtiObjectReference.referrer_ (인덱스)</code></a>  를 사용합니다. 객체의 콜백은, 항상 참조측의 콜백의 나중에 행해지겠습니다.
        <p></p>
보고되는 객체 참조에 대해서는,<a href="#FollowReferences"><code>FollowReferences</code></a>  를 참조해 주세요.
	<p></p>
	루트는, 항상, 객체 참조가 보고되기 전에, 프로 filer에 보고됩니다. 즉,<a href="#IterateOverReachableObjects.object_ref_callback"><code>object_ref_callback</code></a> 는, 모든 루트에 대해서 적절한 콜백이 불려 갈 때까지, 불려 가지 않습니다. <a href="#IterateOverReachableObjects.object_ref_callback"><code>object_ref_callback</code></a> 가 <code>NULL</code> 와 지정되고 있는 경우, 이 함수는, 프로 filer에 루트 객체를 보고한 뒤, 종료합니다.
        <p></p>
이 함수의 실행중, heap의 상태는 변화하지 않습니다. 객체의 할당이나 가베지 컬렉션은 행해지지 않습니다. 따라서, 객체 (포함되고 있는 값도 포함한다)는 변경되지 않습니다. 결과적으로, Java 프로그램 언어의 코드를 실행하는 thread, Java 프로그램 언어의 코드의 실행을 재개하려고 하고 있는 thread, JNI 함수를 실행하려고 하고 있는 thread는, 정지합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>110</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a> </td><td>
	  <a href="#Heap">heap의 카테고리</a>에 설명되고 있도록(듯이), 태그를 설정해, 취득할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="IterateOverReachableObjects.heap_root_callback">heap_root_callback</code></td><td><code><a href="#jvmtiHeapRootCallback">jvmtiHeapRootCallback</a> 
	    
	  </code></td><td>
	      <code>JVMTI_HEAP_ROOT_JNI_GLOBAL</code>,<code>JVMTI_HEAP_ROOT_SYSTEM_CLASS</code>,<code>JVMTI_HEAP_ROOT_MONITOR</code>,<code>JVMTI_HEAP_ROOT_THREAD</code>, 또는 <code>JVMTI_HEAP_ROOT_OTHER</code> 형의 각 heap 루트를 위해서(때문에) 불려 가는 콜백 함수.
	    <p></p>
<code>heap_root_callback</code> 가 <code>NULL</code> 의 경우, heap 루트의 보고는 실시하지 않는다.
</td>
</tr>
<tr>
<td><code id="IterateOverReachableObjects.stack_ref_callback">stack_ref_callback</code></td><td><code><a href="#jvmtiStackReferenceCallback">jvmtiStackReferenceCallback</a> 
	    
	  </code></td><td>
	      <code>JVMTI_HEAP_ROOT_STACK_LOCAL</code> 또는 <code>JVMTI_HEAP_ROOT_JNI_LOCAL</code> 의 각 heap 루트를 위해서(때문에) 불려 가는 콜백 함수.
	    <p></p>
<code>stack_ref_callback</code> 가 <code>NULL</code> 의 경우, 스택 참조의 보고는 실시하지 않는다.
</td>
</tr>
<tr>
<td><code id="IterateOverReachableObjects.object_ref_callback">object_ref_callback</code></td><td><code><a href="#jvmtiObjectReferenceCallback">jvmtiObjectReferenceCallback</a> 
	    
	  </code></td><td>
	      각 객체 참조를 위해서(때문에) 불려 가는 콜백.
	    <p></p>
<code>object_ref_callback</code> 가 <code>NULL</code> 의 경우, 루트 객체로부터의 참조에는 따르지 않는다.
</td>
</tr>
<tr>
<td><code id="IterateOverReachableObjects.user_data">user_data</code></td><td><code>const void
	    
	  *</code></td><td>
	    사용자가 입력해, 콜백에게 건네지는 데이터.  
	  <p></p>에이전트가 포인터를 건네준다. <code>user_data</code> 가 <code>NULL</code> 의 경우,<code>NULL</code> 가 사용자 지정 데이터로서 건네받는다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="IterateOverHeap">
<h3>heap의 반복</h3>
<blockquote>
<pre>jvmtiError
IterateOverHeap(jvmtiEnv* env,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)</pre>
</blockquote>        
heap내의 모든 객체에 대해서 반복 처리를 실시합니다. 도달 가능한 객체도, 그렇지 않은 객체도 포함됩니다.
	<p></p>
	<a href="#IterateOverHeap.object_filter"><code>object_filter</code></a>  파라미터는, 어느 객체를 위해서(때문에) 콜백 함수가 불려 가는지를 나타냅니다. 파라미터가 <code>JVMTI_HEAP_OBJECT_TAGGED</code> 의 경우, 콜백은, 모든 태그 첨부 객체 에 대해서만 불려 갑니다. 파라미터가 <code>JVMTI_HEAP_OBJECT_UNTAGGED</code> 의 경우, 콜백은, 모든 태그 없음 객체 에 대해서만 불려 갑니다. 파라미터가 <code>JVMTI_HEAP_OBJECT_EITHER</code> 의 경우, 콜백은, 태그가 붙어 있는지 어떤지에 관계없이, heap내의 모든 객체에 대해서 불려 갑니다.
        <p></p>
이 함수의 실행중, heap의 상태는 변화하지 않습니다. 객체의 할당이나 가베지 컬렉션은 행해지지 않습니다. 따라서, 객체 (포함되고 있는 값도 포함한다)는 변경되지 않습니다. 결과적으로, Java 프로그램 언어의 코드를 실행하는 thread, Java 프로그램 언어의 코드의 실행을 재개하려고 하고 있는 thread, JNI 함수를 실행하려고 하고 있는 thread는, 정지합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>111</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a> </td><td>
	  <a href="#Heap">heap의 카테고리</a>에 설명되고 있도록(듯이), 태그를 설정해, 취득할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="IterateOverHeap.object_filter">object_filter</code></td><td><code><a href="#jvmtiHeapObjectFilter">jvmtiHeapObjectFilter</a> </code></td><td>
	    어느 객체에 대해서 콜백 함수가 불려 가는지를 나타낸다.
	  </td>
</tr>
<tr>
<td><code id="IterateOverHeap.heap_object_callback">heap_object_callback</code></td><td><code><a href="#jvmtiHeapObjectCallback">jvmtiHeapObjectCallback</a> </code></td><td>
	      <a href="#IterateOverHeap.object_filter"><code>object_filter</code></a>  에 일치하는 각 객체에 대해서 불려 가는 반복 함수.
	    <p></p>
</td>
</tr>
<tr>
<td><code id="IterateOverHeap.user_data">user_data</code></td><td><code>const void
	    
	  *</code></td><td>
	    사용자가 입력해, 콜백에게 건네지는 데이터.  
	  <p></p>에이전트가 포인터를 건네준다. <code>user_data</code> 가 <code>NULL</code> 의 경우,<code>NULL</code> 가 사용자 지정 데이터로서 건네받는다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#IterateOverHeap.object_filter"><code>object_filter</code></a>  가 jvmtiHeapObjectFilter 이 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#IterateOverHeap.heap_object_callback"><code>heap_object_callback</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="IterateOverInstancesOfClass">
<h3>클래스의 인스턴스의 반복</h3>
<blockquote>
<pre>jvmtiError
IterateOverInstancesOfClass(jvmtiEnv* env,
            jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)</pre>
</blockquote>
지정된 클라이언트의 인스턴스가 되어 있는, heap내의 모든 객체에 대해서 반복 처리를 실시합니다. 이것에는, 지정된 클래스의 직접적인 인스턴스와 지정된 클래스의 모든 서브 클래스의 인스턴스가 포함됩니다. 도달 가능한 객체도, 그렇지 않은 객체도 포함됩니다.
	<p></p>
	<a href="#IterateOverInstancesOfClass.object_filter"><code>object_filter</code></a>  파라미터는, 어느 객체를 위해서(때문에) 콜백 함수가 불려 가는지를 나타냅니다. 파라미터가 <code>JVMTI_HEAP_OBJECT_TAGGED</code> 의 경우, 콜백은, 모든 태그 첨부 객체 에 대해서만 불려 갑니다. 파라미터가 <code>JVMTI_HEAP_OBJECT_UNTAGGED</code> 의 경우, 콜백은, 모든 태그 없음 객체 에 대해서만 불려 갑니다. 파라미터가 <code>JVMTI_HEAP_OBJECT_EITHER</code> 의 경우, 콜백은, 태그가 붙어 있는지 어떤지에 관계없이, heap내의 모든 객체에 대해서 불려 갑니다.
	<p></p>
	이 함수의 실행중, heap의 상태는 변화하지 않습니다. 객체의 할당이나 가베지 컬렉션은 행해지지 않습니다. 따라서, 객체 (포함되고 있는 값도 포함한다)는 변경되지 않습니다. 결과적으로, Java 프로그램 언어의 코드를 실행하는 thread, Java 프로그램 언어의 코드의 실행을 재개하려고 하고 있는 thread, JNI 함수를 실행하려고 하고 있는 thread는, 정지합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>112</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a> </td><td>
	  <a href="#Heap">heap의 카테고리</a>에 설명되고 있도록(듯이), 태그를 설정해, 취득할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="IterateOverInstancesOfClass.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      이 클래스의 객체 에 대해서만 반복 처리를 실시한다.
	    </td>
</tr>
<tr>
<td><code id="IterateOverInstancesOfClass.object_filter">object_filter</code></td><td><code><a href="#jvmtiHeapObjectFilter">jvmtiHeapObjectFilter</a> </code></td><td>
	    어느 객체에 대해서 콜백 함수가 불려 가는지를 나타낸다.
	  </td>
</tr>
<tr>
<td><code id="IterateOverInstancesOfClass.heap_object_callback">heap_object_callback</code></td><td><code><a href="#jvmtiHeapObjectCallback">jvmtiHeapObjectCallback</a> </code></td><td>
	      <a href="#IterateOverInstancesOfClass.object_filter"><code>object_filter</code></a>  에 일치하는 각 <a href="#IterateOverInstancesOfClass.klass"><code>klass</code></a>  인스턴스에 대해서 불려 가는 반복 함수.
	    <p></p>
</td>
</tr>
<tr>
<td><code id="IterateOverInstancesOfClass.user_data">user_data</code></td><td><code>const void
	    
	  *</code></td><td>
	    사용자가 입력해, 콜백에게 건네지는 데이터.  
	  <p></p>에이전트가 포인터를 건네준다. <code>user_data</code> 가 <code>NULL</code> 의 경우,<code>NULL</code> 가 사용자 지정 데이터로서 건네받는다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#IterateOverInstancesOfClass.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#IterateOverInstancesOfClass.object_filter"><code>object_filter</code></a>  가 jvmtiHeapObjectFilter 이 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#IterateOverInstancesOfClass.heap_object_callback"><code>heap_object_callback</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<p id="local"></p>
<hr noshade="noshade" size="3">
<h2 align="center">국소 변수</h2>국소 변수 함수:
  <ul>
<li>
<a href="#GetLocalObject">국소 변수의 취득 - 객체형</a> 
</li>
<li>
<a href="#GetLocalInt">국소 변수의 취득 - 정수형</a> 
</li>
<li>
<a href="#GetLocalLong">국소 변수의 취득 - 장 정수형</a> 
</li>
<li>
<a href="#GetLocalFloat">국소 변수의 취득 - 부동 소수점수(실수)형</a> 
</li>
<li>
<a href="#GetLocalDouble">국소 변수의 취득 - 배정밀도 부동 소수점수(실수)형</a> 
</li>
<li>
<a href="#SetLocalObject">국소 변수의 설정 - 객체형</a> 
</li>
<li>
<a href="#SetLocalInt">국소 변수의 설정 - 정수형</a> 
</li>
<li>
<a href="#SetLocalLong">국소 변수의 설정 - 장 정수형</a> 
</li>
<li>
<a href="#SetLocalFloat">국소 변수의 설정 - 부동 소수점수(실수)형</a> 
</li>
<li>
<a href="#SetLocalDouble">국소 변수의 설정 - 배정밀도 부동 소수점수(실수)형</a> 
</li>
</ul>
이러한 함수는, 국소 변수의 값을 취득 또는 설정하기 위해서 사용합니다. 변수는, 변수의 값을 포함하고 있는 프레임의 깊이와 그 프레임내의 변수의 슬롯 번호에 의해 식별됩니다. 변수로부터 슬롯 번호에의 매핑은, 함수 <a href="#GetLocalVariableTable"><code>GetLocalVariableTable</code></a>  를 사용해 취득할 수 있습니다.
    <p></p>
<hr noshade="noshade" width="100%" size="1" id="GetLocalObject">
<h3>국소 변수의 취득 - 객체형</h3>
<blockquote>
<pre>jvmtiError
GetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr)</pre>
</blockquote>
	이 함수를 사용하면(자), 형태가 <code>Object</code> 또는 <code>Object</code> 의 서브 클래스인 국소 변수의 값을 취득할 수 있습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>21</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a> </td><td>
	  국소 변수를 설정해, 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetLocalObject.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    변수의 값을 포함한 프레임의 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetLocalObject.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 값을 포함한 프레임의 깊이.
	  </td>
</tr>
<tr>
<td><code id="GetLocalObject.slot">slot</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 슬롯 번호.
	  </td>
</tr>
<tr>
<td><code id="GetLocalObject.value_ptr">value_ptr</code></td><td><code><a href="#jobject">jobject</a> *</code></td><td>
	      돌아왔을 때, 변수의 값을 포인트 한다.  
	    <p></p>에이전트는 <code>jobject</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jobject</code> 가 설정되어 있다. <code>value_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a> </td><td>
	  <code>slot</code> 가 무효.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
변수의 형태가 <code>Object</code> 에서도 <code>Object</code> 의 서브 클래스도 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td> 
	  가시의 프레임은 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetLocalObject.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#GetLocalObject.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetLocalObject.depth"><code>depth</code></a>  가 제로보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  지정된 <a href="#GetLocalObject.depth"><code>depth</code></a>  에 스택 프레임이 존재하지 않는다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetLocalObject.value_ptr"><code>value__ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetLocalInt">
<h3>국소 변수의 취득 - 정수형</h3>
<blockquote>
<pre>jvmtiError
GetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr)</pre>
</blockquote>
	이 함수를 사용하면(자), 형태가 <code>int</code>,<code>short</code>,<code>char</code>,<code>byte</code>,<code>boolean</code> 의 언젠가인 국소 변수의 값을 취득할 수 있습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>22</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a> </td><td>
	  국소 변수를 설정해, 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetLocalInt.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    변수의 값을 포함한 프레임의 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetLocalInt.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 값을 포함한 프레임의 깊이.
	  </td>
</tr>
<tr>
<td><code id="GetLocalInt.slot">slot</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 슬롯 번호.
	  </td>
</tr>
<tr>
<td><code id="GetLocalInt.value_ptr">value_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 변수의 값을 포인트 한다.  
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a> </td><td>
	  <code>slot</code> 가 무효.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  변수의 형태가 <code>int</code>,<code>short</code>,<code>char</code>,<code>byte</code>,<code>boolean</code> 의 머지않아도 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td> 
	  가시의 프레임은 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetLocalInt.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#GetLocalInt.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetLocalInt.depth"><code>depth</code></a>  가 제로보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  지정된 <a href="#GetLocalInt.depth"><code>depth</code></a>  에 스택 프레임이 존재하지 않는다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetLocalInt.value_ptr"><code>value__ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetLocalLong">
<h3>국소 변수의 취득 - 장 정수형</h3>
<blockquote>
<pre>jvmtiError
GetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr)</pre>
</blockquote>
	이 함수를 사용하면(자), 형태가 <code>long</code> 인 국소 변수의 값을 취득할 수 있습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>23</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a> </td><td>
	  국소 변수를 설정해, 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetLocalLong.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    변수의 값을 포함한 프레임의 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetLocalLong.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 값을 포함한 프레임의 깊이.
	  </td>
</tr>
<tr>
<td><code id="GetLocalLong.slot">slot</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 슬롯 번호.
	  </td>
</tr>
<tr>
<td><code id="GetLocalLong.value_ptr">value_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    돌아왔을 때, 변수의 값을 포인트 한다.  
	  <p></p>에이전트는 <code>jlong</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jlong</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a> </td><td>
	  <code>slot</code> 가 무효.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  변수의 형태가 <code>long</code> 가 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td> 
	  가시의 프레임은 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetLocalLong.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#GetLocalLong.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetLocalLong.depth"><code>depth</code></a>  가 제로보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  지정된 <a href="#GetLocalLong.depth"><code>depth</code></a>  에 스택 프레임이 존재하지 않는다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetLocalLong.value_ptr"><code>value__ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetLocalFloat">
<h3>국소 변수의 취득 - 부동 소수점수(실수)형</h3>
<blockquote>
<pre>jvmtiError
GetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr)</pre>
</blockquote>
	이 함수를 사용하면(자), 형태가 <code>float</code> 인 국소 변수의 값을 취득할 수 있습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>24</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a> </td><td>
	  국소 변수를 설정해, 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetLocalFloat.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    변수의 값을 포함한 프레임의 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetLocalFloat.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 값을 포함한 프레임의 깊이.
	  </td>
</tr>
<tr>
<td><code id="GetLocalFloat.slot">slot</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 슬롯 번호.
	  </td>
</tr>
<tr>
<td><code id="GetLocalFloat.value_ptr">value_ptr</code></td><td><code><a href="#jfloat">jfloat</a> *</code></td><td>
	    돌아왔을 때, 변수의 값을 포인트 한다.  
	  <p></p>에이전트는 <code>jfloat</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jfloat</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a> </td><td>
	  <code>slot</code> 가 무효.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  변수의 형태가 <code>float</code> 가 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td> 
	  가시의 프레임은 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetLocalFloat.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#GetLocalFloat.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetLocalFloat.depth"><code>depth</code></a>  가 제로보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  지정된 <a href="#GetLocalFloat.depth"><code>depth</code></a>  에 스택 프레임이 존재하지 않는다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetLocalFloat.value_ptr"><code>value__ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetLocalDouble">
<h3>국소 변수의 취득 - 배정밀도 부동 소수점수(실수)형</h3>
<blockquote>
<pre>jvmtiError
GetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr)</pre>
</blockquote>
	이 함수를 사용하면(자), 형태가 <code>long</code> 인 국소 변수의 값을 취득할 수 있습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>25</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a> </td><td>
	  국소 변수를 설정해, 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetLocalDouble.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    변수의 값을 포함한 프레임의 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetLocalDouble.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 값을 포함한 프레임의 깊이.
	  </td>
</tr>
<tr>
<td><code id="GetLocalDouble.slot">slot</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 슬롯 번호.
	  </td>
</tr>
<tr>
<td><code id="GetLocalDouble.value_ptr">value_ptr</code></td><td><code><a href="#jdouble">jdouble</a> *</code></td><td>
	    돌아왔을 때, 변수의 값을 포인트 한다.  
	  <p></p>에이전트는 <code>jdouble</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jdouble</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a> </td><td>
	  <code>slot</code> 가 무효.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  변수의 형태가 <code>double</code> 가 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td> 
	  가시의 프레임은 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetLocalDouble.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#GetLocalDouble.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetLocalDouble.depth"><code>depth</code></a>  가 제로보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  지정된 <a href="#GetLocalDouble.depth"><code>depth</code></a>  에 스택 프레임이 존재하지 않는다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetLocalDouble.value_ptr"><code>value__ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetLocalObject">
<h3>국소 변수의 설정 - 객체형</h3>
<blockquote>
<pre>jvmtiError
SetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject value)</pre>
</blockquote>
	이 함수를 사용하면(자), 형태가 <code>Object</code> 또는 <code>Object</code> 의 서브 클래스인 국소 변수의 값을 설정할 수 있습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>26</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a> </td><td>
	  국소 변수를 설정해, 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetLocalObject.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    변수의 값을 포함한 프레임의 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="SetLocalObject.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 값을 포함한 프레임의 깊이.
	  </td>
</tr>
<tr>
<td><code id="SetLocalObject.slot">slot</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 슬롯 번호.
	  </td>
</tr>
<tr>
<td><code id="SetLocalObject.value">value</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	      변수의 새로운 값.
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a> </td><td>
	  <code>slot</code> 가 무효.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td>
	  변수의 형태가 <code>Object</code> 에서도 <code>Object</code> 의 서브 클래스도 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td>
	  지정된 <a href="#SetLocalObject.value"><code>value</code></a>  와 변수의 형태에 호환성이 없다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td>
	  가시의 프레임은 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#SetLocalObject.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#SetLocalObject.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#SetLocalObject.depth"><code>depth</code></a>  가 제로보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  지정된 <a href="#SetLocalObject.depth"><code>depth</code></a>  에 스택 프레임이 존재하지 않는다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a> </td><td>
	  <a href="#SetLocalObject.value"><code>value</code></a>  가 객체는 아니다.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetLocalInt">
<h3>국소 변수의 설정 - 정수형</h3>
<blockquote>
<pre>jvmtiError
SetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint value)</pre>
</blockquote>
	이 함수를 사용하면(자), 형태가 <code>int</code>,<code>short</code>,<code>char</code>,<code>byte</code>,<code>boolean</code> 의 언젠가인 국소 변수의 값을 설정할 수 있습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>27</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a> </td><td>
	  국소 변수를 설정해, 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetLocalInt.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    변수의 값을 포함한 프레임의 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="SetLocalInt.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 값을 포함한 프레임의 깊이.
	  </td>
</tr>
<tr>
<td><code id="SetLocalInt.slot">slot</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 슬롯 번호.
	  </td>
</tr>
<tr>
<td><code id="SetLocalInt.value">value</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 새로운 값.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a> </td><td>
	  <code>slot</code> 가 무효.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  변수의 형태가 <code>int</code>,<code>short</code>,<code>char</code>,<code>byte</code>,<code>boolean</code> 의 머지않아도 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td>
	  가시의 프레임은 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#SetLocalInt.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#SetLocalInt.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#SetLocalInt.depth"><code>depth</code></a>  가 제로보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  지정된 <a href="#SetLocalInt.depth"><code>depth</code></a>  에 스택 프레임이 존재하지 않는다.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetLocalLong">
<h3>국소 변수의 설정 - 장 정수형</h3>
<blockquote>
<pre>jvmtiError
SetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong value)</pre>
</blockquote>
	이 함수를 사용하면(자), 형태가 <code>long</code> 인 국소 변수의 값을 설정할 수 있습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>28</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a> </td><td>
	  국소 변수를 설정해, 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetLocalLong.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    변수의 값을 포함한 프레임의 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="SetLocalLong.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 값을 포함한 프레임의 깊이.
	  </td>
</tr>
<tr>
<td><code id="SetLocalLong.slot">slot</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 슬롯 번호.
	  </td>
</tr>
<tr>
<td><code id="SetLocalLong.value">value</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    변수의 새로운 값.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a> </td><td>
	  <code>slot</code> 가 무효.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  변수의 형태가 <code>long</code> 가 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td>
	  가시의 프레임은 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#SetLocalLong.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#SetLocalLong.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#SetLocalLong.depth"><code>depth</code></a>  가 제로보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  지정된 <a href="#SetLocalLong.depth"><code>depth</code></a>  에 스택 프레임이 존재하지 않는다.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetLocalFloat">
<h3>국소 변수의 설정 - 부동 소수점수(실수)형</h3>
<blockquote>
<pre>jvmtiError
SetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat value)</pre>
</blockquote>
	이 함수를 사용하면(자), 형태가 <code>float</code> 인 국소 변수의 값을 설정할 수 있습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>29</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a> </td><td>
	  국소 변수를 설정해, 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetLocalFloat.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    변수의 값을 포함한 프레임의 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="SetLocalFloat.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 값을 포함한 프레임의 깊이.
	  </td>
</tr>
<tr>
<td><code id="SetLocalFloat.slot">slot</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 슬롯 번호.
	  </td>
</tr>
<tr>
<td><code id="SetLocalFloat.value">value</code></td><td><code><a href="#jfloat">jfloat</a> </code></td><td>
	    변수의 새로운 값.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a> </td><td>
	  <code>slot</code> 가 무효.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  변수의 형태가 <code>float</code> 가 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td>
	  가시의 프레임은 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#SetLocalFloat.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#SetLocalFloat.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#SetLocalFloat.depth"><code>depth</code></a>  가 제로보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  지정된 <a href="#SetLocalFloat.depth"><code>depth</code></a>  에 스택 프레임이 존재하지 않는다.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetLocalDouble">
<h3>국소 변수의 설정 - 배정밀도 부동 소수점수(실수)형</h3>
<blockquote>
<pre>jvmtiError
SetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble value)</pre>
</blockquote>
	이 함수를 사용하면(자), 형태가 <code>double</code> 인 국소 변수의 값을 설정할 수 있습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>30</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a> </td><td>
	  국소 변수를 설정해, 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetLocalDouble.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    변수의 값을 포함한 프레임의 thread.
	  
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="SetLocalDouble.depth">depth</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 값을 포함한 프레임의 깊이.
	  </td>
</tr>
<tr>
<td><code id="SetLocalDouble.slot">slot</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    변수의 슬롯 번호.
	  </td>
</tr>
<tr>
<td><code id="SetLocalDouble.value">value</code></td><td><code><a href="#jdouble">jdouble</a> </code></td><td>
	    변수의 새로운 값.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a> </td><td>
	  <code>slot</code> 가 무효.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a> </td><td> 
	  변수의 형태가 <code>double</code> 가 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a> </td><td>
	  가시의 프레임은 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#SetLocalDouble.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#SetLocalDouble.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#SetLocalDouble.depth"><code>depth</code></a>  가 제로보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a> </td><td>
	  지정된 <a href="#SetLocalDouble.depth"><code>depth</code></a>  에 스택 프레임이 존재하지 않는다.
	  
	</td>
</tr>
</table>
<p id="breakpointCategory"></p>
<hr noshade="noshade" size="3">
<h2 align="center">breakpoint</h2>breakpoint 함수:
  <ul>
<li>
<a href="#SetBreakpoint">breakpoint의 설정</a> 
</li>
<li>
<a href="#ClearBreakpoint">breakpoint의 해제</a> 
</li>
</ul>
    
<p></p>
<hr noshade="noshade" width="100%" size="1" id="SetBreakpoint">
<h3>breakpoint의 설정</h3>
<blockquote>
<pre>jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)</pre>
</blockquote>
	<code>method</code> 및 <code>location</code> 로 지정된 명령에 breakpoint를 설정합니다. 1 개의 명령에 대해서 설정할 수 있는 breakpoint는 1 개 뿐입니다.
	<p></p>
	지정한 명령이 실행되기 직전에,<a href="#Breakpoint"><code>Breakpoint</code></a>  이벤트가 생성됩니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>38</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_breakpoint_events"><code>can_generate_breakpoint_events</code></a> </td><td>
	  <a href="#Breakpoint"><code>Breakpoint</code></a>  이벤트를<a href="#SetBreakpoint">설정</a>해, 취득할 수가 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetBreakpoint.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      breakpoint를 설정하는 메소드
	    </td>
</tr>
<tr>
<td><code id="SetBreakpoint.location">location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	    breakpoint를 설정하는 명령의 인덱스

	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_generate_breakpoint_events"><code>can_generate_breakpoint_events</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_DUPLICATE"><code>JVMTI_ERROR_DUPLICATE</code></a> </td><td> 
	  지정된 바이트 코드에는 breakpoint가 벌써 설정되어 있다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#SetBreakpoint.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_LOCATION"><code>JVMTI_ERROR_INVALID_LOCATION</code></a> </td><td>
	  <a href="#SetBreakpoint.location"><code>location</code></a>  는 유효한 위치는 아니다.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="ClearBreakpoint">
<h3>breakpoint의 해제</h3>
<blockquote>
<pre>jvmtiError
ClearBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)</pre>
</blockquote>
	<code>method</code> 및 <code>location</code> 로 지정된 바이트 코드로 설정되어 있는 breakpoint를 해제합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>39</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_breakpoint_events"><code>can_generate_breakpoint_events</code></a> </td><td>
	  <a href="#Breakpoint"><code>Breakpoint</code></a>  이벤트를<a href="#SetBreakpoint">설정</a>해, 취득할 수가 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ClearBreakpoint.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      breakpoint를 해제하는 메소드
	    </td>
</tr>
<tr>
<td><code id="ClearBreakpoint.location">location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	    breakpoint를 해제하는 명령의 인덱스
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_generate_breakpoint_events"><code>can_generate_breakpoint_events</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_FOUND"><code>JVMTI_ERROR_NOT_FOUND</code></a> </td><td> 
	  지정된 바이트 코드에는 breakpoint가 설정되어 있지 않다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#ClearBreakpoint.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_LOCATION"><code>JVMTI_ERROR_INVALID_LOCATION</code></a> </td><td>
	  <a href="#ClearBreakpoint.location"><code>location</code></a>  는 유효한 위치는 아니다.
	  
	</td>
</tr>
</table>
<p id="fieldWatch"></p>
<hr noshade="noshade" size="3">
<h2 align="center">감시되는 필드</h2>감시되는 필드 함수:
  <ul>
<li>
<a href="#SetFieldAccessWatch">필드 액세스의 감시의 설정</a> 
</li>
<li>
<a href="#ClearFieldAccessWatch">필드 액세스의 감시의 해제</a> 
</li>
<li>
<a href="#SetFieldModificationWatch">필드 변경의 감시의 설정</a> 
</li>
<li>
<a href="#ClearFieldModificationWatch">필드 변경의 감시의 해제</a> 
</li>
</ul>
    
<p></p>
<hr noshade="noshade" width="100%" size="1" id="SetFieldAccessWatch">
<h3>필드 액세스의 감시의 설정</h3>
<blockquote>
<pre>jvmtiError
SetFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)</pre>
</blockquote>
	<code>klass</code> 및 <code>field</code> 로 지정된 필드가 액세스 되려고 한 시점에서,<a href="#FieldAccess"><code>FieldAccess</code></a>  이벤트를 생성합니다. 이벤트는,<a href="#ClearFieldAccessWatch"><code>ClearFieldAccessWatch</code></a>  를 사용해 삭제될 때까지, 필드가 액세스 될 때마다 생성됩니다. Java 프로그램 언어 코드 또는 JNI 코드로부터의 필드 액세스가 감시되어 다른 수단으로 변경되는 필드는 감시되지 않습니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 사용자는, 자기 자신의 필드 액세스에 의해 감시 이벤트가 트리거되는 것에 주의해 주세요. 1 개의 필드에 대해, 필드 액세스의 감시를 1 개만 설정할 수 있습니다. 필드의 변경은 액세스라고는 보이지 않습니다. 변경을 감시하려면 ,<a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a>  을 사용합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>41</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_access_events"><code>can_generate_field_access_events</code></a> </td><td>
	  필드 액세스에 시계 포인트를 설정할 수 있는 - <a href="#SetFieldAccessWatch"><code>SetFieldAccessWatch</code></a> 
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetFieldAccessWatch.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      감시하는 필드를 포함한 클래스
	    </td>
</tr>
<tr>
<td><code id="SetFieldAccessWatch.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a> </code></td><td>
	      감시하는 필드

	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_generate_field_access_events"><code>can_generate_field_access_events</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_DUPLICATE"><code>JVMTI_ERROR_DUPLICATE</code></a> </td><td> 
	  지정된 필드는 벌써 액세스가 감시되고 있다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#SetFieldAccessWatch.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a> </td><td>
	  <a href="#SetFieldAccessWatch.field"><code>field</code></a>  가 jfieldID 는 아니다.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="ClearFieldAccessWatch">
<h3>필드 액세스의 감시의 해제</h3>
<blockquote>
<pre>jvmtiError
ClearFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)</pre>
</blockquote>
	<a href="#SetFieldAccessWatch"><code>SetFieldAccessWatch</code></a>  를 사용해 이전으로 설정한,<code>klass</code> 및 <code>field</code> 로 지정되는 필드에 대한 필드 액세스의 감시를 취소합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>42</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_access_events"><code>can_generate_field_access_events</code></a> </td><td>
	  필드 액세스에 시계 포인트를 설정할 수 있는 - <a href="#SetFieldAccessWatch"><code>SetFieldAccessWatch</code></a> 
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ClearFieldAccessWatch.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      감시하는 필드를 포함한 클래스
	    </td>
</tr>
<tr>
<td><code id="ClearFieldAccessWatch.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a> </code></td><td>
	      감시하는 필드

	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_generate_field_access_events"><code>can_generate_field_access_events</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_FOUND"><code>JVMTI_ERROR_NOT_FOUND</code></a> </td><td> 
	  지정된 필드는 액세스가 감시되어 있지 않다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#ClearFieldAccessWatch.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a> </td><td>
	  <a href="#ClearFieldAccessWatch.field"><code>field</code></a>  가 jfieldID 는 아니다.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetFieldModificationWatch">
<h3>필드 변경의 감시의 설정</h3>
<blockquote>
<pre>jvmtiError
SetFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)</pre>
</blockquote>
	<code>klass</code> 및 <code>field</code> 로 지정된 필드가 변경되려고 한 시점에서,<a href="#FieldModification"><code>FieldModification</code></a>  이벤트를 생성합니다. 이벤트는,<a href="#ClearFieldModificationWatch"><code>ClearFieldModificationWatch</code></a>  를 사용해 삭제될 때까지, 필드가 변경될 때마다 생성됩니다. Java 프로그램 언어 코드 또는 JNI 코드로부터의 필드 변경이 감시되어 다른 수단으로 변경되는 필드는 감시되지 않습니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 사용자는, 자기 자신으로 실행하는 필드 변경에 의해 감시 이벤트가 트리거되는 것에 주의해 주세요. 1 개의 필드에 대해, 필드 변경의 감시를 1 개만 설정할 수 있습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>43</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_modification_events"><code>can_generate_field_modification_events</code></a> </td><td>
	  필드의 변경에 시계 포인트를 설정할 수 있는 - <a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a> 
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetFieldModificationWatch.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      감시하는 필드를 포함한 클래스
	    </td>
</tr>
<tr>
<td><code id="SetFieldModificationWatch.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a> </code></td><td>
	      감시하는 필드

	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_generate_field_modification_events"><code>can_generate_field_modification_events</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_DUPLICATE"><code>JVMTI_ERROR_DUPLICATE</code></a> </td><td> 
	  지정된 필드는 벌써 변경이 감시되고 있다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#SetFieldModificationWatch.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a> </td><td>
	  <a href="#SetFieldModificationWatch.field"><code>field</code></a>  가 jfieldID 는 아니다.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="ClearFieldModificationWatch">
<h3>필드 변경의 감시의 해제</h3>
<blockquote>
<pre>jvmtiError
ClearFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)</pre>
</blockquote>

	<code>klass</code> 및 <code>field</code> 로 지정되는 필드에 대해서,<a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a>  를 사용해 이전으로 설정한 필드 변경의 감시를 취소합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>44</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_modification_events"><code>can_generate_field_modification_events</code></a> </td><td>
	  필드의 변경에 시계 포인트를 설정할 수 있는 - <a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a> 
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ClearFieldModificationWatch.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      감시하는 필드를 포함한 클래스
	    </td>
</tr>
<tr>
<td><code id="ClearFieldModificationWatch.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a> </code></td><td>
	      감시하는 필드

	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_generate_field_modification_events"><code>can_generate_field_modification_events</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_FOUND"><code>JVMTI_ERROR_NOT_FOUND</code></a> </td><td> 
	  지정된 필드는 변경이 감시되어 있지 않다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#ClearFieldModificationWatch.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a> </td><td>
	  <a href="#ClearFieldModificationWatch.field"><code>field</code></a>  가 jfieldID 는 아니다.
	    
	</td>
</tr>
</table>
<p id="class"></p>
<hr noshade="noshade" size="3">
<h2 align="center">클래스</h2>클래스 함수:
  <ul>
<li>
<a href="#GetLoadedClasses">로드가 끝난 클래스의 취득</a> 
</li>
<li>
<a href="#GetClassLoaderClasses">클래스 로더 클래스의 취득</a> 
</li>
<li>
<a href="#GetClassSignature">클래스의 시그니챠의 취득</a> 
</li>
<li>
<a href="#GetClassStatus">클래스의 상태의 취득</a> 
</li>
<li>
<a href="#GetSourceFileName">원시 파일명의 취득</a> 
</li>
<li>
<a href="#GetClassModifiers">클래스의 수식자의 취득</a> 
</li>
<li>
<a href="#GetClassMethods">클래스의 메소드의 취득</a> 
</li>
<li>
<a href="#GetClassFields">클래스의 필드의 취득</a> 
</li>
<li>
<a href="#GetImplementedInterfaces">구현된 인터페이스의 취득</a> 
</li>
<li>
<a href="#GetClassVersionNumbers">클래스 버젼 번호의 취득</a> 
</li>
<li>
<a href="#GetConstantPool">정수 풀의 취득</a> 
</li>
<li>
<a href="#IsInterface">인터페이스인가 어떤가의 검사</a> 
</li>
<li>
<a href="#IsArrayClass">배열 클래스인가 어떤가의 검사</a> 
</li>
<li>
<a href="#IsModifiableClass">변경 가능 클래스인가 어떤가의 검사</a> 
</li>
<li>
<a href="#GetClassLoader">클래스 로더의 취득</a> 
</li>
<li>
<a href="#GetSourceDebugExtension">소스 디버그 확장 기능의 취득</a> 
</li>
<li>
<a href="#RetransformClasses">클래스의 재변환</a> 
</li>
<li>
<a href="#RedefineClasses">클래스의 재정의</a> 
</li>
</ul>클래스의 형태:
    <ul>
<li>
<a href="#jvmtiClassDefinition"><code>jvmtiClassDefinition</code></a>  - 클래스의 재정의의 설명</li>
</ul>클래스의 플래그 및 정수:
    <ul>
<li>
<a href="#jvmtiClassStatus">클래스의 상태 플래그</a> 
</li>
</ul>
    
<p></p>
<hr noshade="noshade" width="100%" size="1" id="GetLoadedClasses">
<h3>로드가 끝난 클래스의 취득</h3>
<blockquote>
<pre>jvmtiError
GetLoadedClasses(jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)</pre>
</blockquote>
	가상 머신에 로드 되고 있는 전클래스의 배열을 돌려줍니다. 배열내의 클래스의 수는 <code>class_count_ptr</code>, 배열 자체는 <code>classes_ptr</code> 에 의해 돌려주어집니다.
	<p></p>
	반환되는 리스트에는, 모든 형태의 배열 클래스 (원시형의 배열을 포함한다)가 포함됩니다. 프리미티브(primitive) 클래스 (예를 들어,<code>java.lang.Integer.TYPE</code>)는, 이 리스트에는 포함되지 않습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>78</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetLoadedClasses.class_count_ptr">class_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 클래스의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetLoadedClasses.classes_ptr">classes_ptr</code></td><td><code><a href="#jclass">jclass</a> **</code></td><td>
	      돌아왔을 때, 각 클래스에의 참조 (클래스 마다 1 개(살)씩)의 배열을 포인트 한다.
	    <p></p>에이전트는 <code>jclass*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jclass*</code> 는, 사이즈 <code>*class_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>classes_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetLoadedClasses.class_count_ptr"><code>class_count_ptr</code></a>  이 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetLoadedClasses.classes_ptr"><code>classes_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetClassLoaderClasses">
<h3>클래스 로더 클래스의 취득</h3>
<blockquote>
<pre>jvmtiError
GetClassLoaderClasses(jvmtiEnv* env,
            jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr)</pre>
</blockquote>
	이 클래스 로더가 기동 로더로서 기록되고 있는 클래스의 배열을 돌려줍니다. 반환되는 배열내의 각 클래스는, 이 클래스 로더에 의해 직접 정의되어 작성된 것인가, 또는 다른 클래스 로더에 위양 해 작성된 것입니다. <a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ConstantPool.doc.html#72007">「Creation and Loading」</a>섹션을 참조해 주세요. <i></i>
	<p></p>
	JDK 1.1 의 구현에서는, 기동 클래스 로더와 정의 클래스 로더의 구별이 인식되지 않기 때문에, 이 함수는, 가상 머신에 로드 된 모든 클래스를 돌려줍니다. 배열내의 클래스의 수는 <code>class_count_ptr</code>, 배열 자체는 <code>classes_ptr</code> 에 의해 돌려주어집니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>79</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetClassLoaderClasses.initiating_loader">initiating_loader</code></td><td><code><a href="#jobject">jobject</a> 
	    
          </code></td><td>
	      기동 클래스 로더.
	    <p></p>
<code>initiating_loader</code> 가 <code>NULL</code> 의 경우, bootstrap loader에 의해 기동된 클래스가 반환된다.
</td>
</tr>
<tr>
<td><code id="GetClassLoaderClasses.class_count_ptr">class_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 클래스의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetClassLoaderClasses.classes_ptr">classes_ptr</code></td><td><code><a href="#jclass">jclass</a> **</code></td><td>
	      돌아왔을 때, 각 클래스에의 참조 (클래스 마다 1 개(살)씩)의 배열을 포인트 한다.
	    <p></p>에이전트는 <code>jclass*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jclass*</code> 는, 사이즈 <code>*class_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>classes_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetClassLoaderClasses.class_count_ptr"><code>class_count_ptr</code></a>  이 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetClassLoaderClasses.classes_ptr"><code>classes_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetClassSignature">
<h3>클래스의 시그니챠의 취득</h3>
<blockquote>
<pre>jvmtiError
GetClassSignature(jvmtiEnv* env,
            jclass klass,
            char** signature_ptr,
            char** generic_ptr)</pre>
</blockquote>
<code>klass</code> 로 지정된 클래스에,<a href="http://java.sun.com/javase/6/docs/guide/jni/spec/types.html#wp16432">JNI 형의 시그니챠</a>와 클래스의 총칭 시그니챠를 돌려줍니다. 예를 들어,<code>java.util.List</code> 가 <code>"Ljava/util/List;"</code> 로,<code>int[]</code> 가 <code>"[I"</code> 의 경우, 반환되는 프리미티브(primitive) 클래스의 이름은, 대응하는 원시형의 형태 시그니챠 문자가 됩니다. 예를 들어,<code>java.lang.Integer.TYPE</code> 는 <code>"I"</code> 입니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>48</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetClassSignature.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetClassSignature.signature_ptr">signature_ptr</code></td><td><code> char           
            
          **</code></td><td>
	    돌아왔을 때, 클래스의 JNI 형 시그니챠 (<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다)를 포인트 한다.
	  <p></p>에이전트는 <code>char*</code> 에 포인터를 건네준다. <code>char*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>signature_ptr</code> 가 <code>NULL</code> 의 경우, 시그니챠는 돌려주어지지 않다.
</td>
</tr>
<tr>
<td><code id="GetClassSignature.generic_ptr">generic_ptr</code></td><td><code> char           
            
          **</code></td><td>
	    돌아왔을 때, 클래스의 총칭 시그니챠 (<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다)를 포인트 한다. 클래스의 총칭 시그니챠 속성이 존재하지 않는 경우는, 돌아왔을 때 <code>NULL</code> 를 포인트 한다.  
	  <p></p>에이전트는 <code>char*</code> 에 포인터를 건네준다. <code>char*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>generic_ptr</code> 가 <code>NULL</code> 의 경우, 총칭 시그니챠는 돌려주어지지 않다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetClassSignature.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetClassStatus">
<h3>클래스의 상태의 취득</h3>
<blockquote>
<pre>jvmtiError
GetClassStatus(jvmtiEnv* env,
            jclass klass,
            jint* status_ptr)</pre>
</blockquote>
	클래스의 상태를 가져옵니다. 다음의 비트 가운데, 0 개 이상의 비트가 세트 됩니다.
	<blockquote>
<a name="jvmtiClassStatus"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">클래스의 상태 플래그</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_CLASS_STATUS_VERIFIED">JVMTI_CLASS_STATUS_VERIFIED</code></td><td align="right">1</td><td>
	    클래스의 바이트 코드가 검증되었다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_CLASS_STATUS_PREPARED">JVMTI_CLASS_STATUS_PREPARED</code></td><td align="right">2</td><td>
	    클래스의 준비가 완료했다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_CLASS_STATUS_INITIALIZED">JVMTI_CLASS_STATUS_INITIALIZED</code></td><td align="right">4</td><td>
	    클래스의 초기화가 완료했다. 정적인 초기화자가 실행되었다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_CLASS_STATUS_ERROR">JVMTI_CLASS_STATUS_ERROR</code></td><td align="right">8</td><td>
	    초기화중의 에러에 의해 클래스를 사용할 수 없다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_CLASS_STATUS_ARRAY">JVMTI_CLASS_STATUS_ARRAY</code></td><td align="right">16</td><td>
	    클래스는 배열. 설정되어 있는 경우, 그 외의 모든 비트는 제로.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_CLASS_STATUS_PRIMITIVE">JVMTI_CLASS_STATUS_PRIMITIVE</code></td><td align="right">32</td><td>
	    클래스는 프리미티브(primitive) 클래스 (<code>java.lang.Integer.TYPE</code> 등). 설정되어 있는 경우, 그 외의 모든 비트는 제로.
	  </td>
</tr>
</table>
</blockquote>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>49</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetClassStatus.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetClassStatus.status_ptr">status_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 이 클래스의 현재 상태로서<a href="#jvmtiClassStatus">클래스의 상태 플래그</a>를 1 개 이상 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetClassStatus.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetClassStatus.status_ptr"><code>status_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetSourceFileName">
<h3>원시 파일명의 취득</h3>
<blockquote>
<pre>jvmtiError
GetSourceFileName(jvmtiEnv* env,
            jclass klass,
            char** source_name_ptr)</pre>
</blockquote>
	<code>klass</code> 로 지정된 클래스에 도착해,<code>source_name_ptr</code> 를 개입시켜 원시 파일명을 돌려줍니다. 반환되는 캐릭터 라인은, 파일명만으로, 디렉토리명은 포함되지 않습니다.  
	<p></p>
	프리미티브(primitive) 클래스 (예를 들어,<code>java.lang.Integer.TYPE</code>) 및 배열의 경우, 이 함수는 <a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a>  를 돌려줍니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>50</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_source_file_name"><code>can_get_source_file_name</code></a> </td><td>
	  클래스의 원시 파일의 이름을 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetSourceFileName.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetSourceFileName.source_name_ptr">source_name_ptr</code></td><td><code>char**</code></td><td>
	    돌아왔을 때, 클래스의 원시 파일명 (<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다)을 포인트 한다.
	  <p></p>에이전트는 <code>char*</code> 에 포인터를 건네준다. <code>char*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_source_file_name"><code>can_get_source_file_name</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a> </td><td> 
	  클래스 정보에, 원시 파일명이 포함되지 않았다. 이것에는, 클래스가 배열 클래스 또는 프리미티브(primitive) 클래스인 경우가 포함된다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetSourceFileName.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetSourceFileName.source_name_ptr"><code>source_name_ptr</code></a>  이 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetClassModifiers">
<h3>클래스의 수식자의 취득</h3>
<blockquote>
<pre>jvmtiError
GetClassModifiers(jvmtiEnv* env,
            jclass klass,
            jint* modifiers_ptr)</pre>
</blockquote>
	<code>klass</code> 로 지정된 클래스의 액세스 플래그를,<code>modifiers_ptr</code> 를 개입시켜 돌려줍니다. 액세스 플래그에 대해서는,<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html">「Class File Format」</a>의 장으로 정의되고 있습니다. <i></i>
	<p></p>
	클래스가 배열 클래스의 경우, 그 public, private 및 protected 수식자는, 그 컴퍼넌트형의 수식자와 같습니다. 원시형의 배열의 경우, 이 컴퍼넌트형은, 프리미티브(primitive) 클래스의 1 개 (예를 들어,<code>java.lang.Integer.TYPE</code>)로 표현됩니다.  
	<p></p>
	클래스가 프리미티브(primitive) 클래스의 경우, 그 public 수식자는 항상 true 가 됩니다. 또, 그 protected 수식자 및 private 수식자는 항상 false 가 됩니다.  
	<p></p>
	클래스가 배열 클래스 또는 프리미티브(primitive) 클래스의 경우, 그 final 수식자는 항상 true 가 되어, interface 수식자는 항상 false 가 됩니다. 그 외의 수식자의 값은, 이 스펙에서는 판정되지 않습니다.  

      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>51</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetClassModifiers.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetClassModifiers.modifiers_ptr">modifiers_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 이 클래스의 현재의 액세스 플래그를 포인트 한다.

	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetClassModifiers.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetClassModifiers.modifiers_ptr"><code>modifiers_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetClassMethods">
<h3>클래스의 메소드의 취득</h3>
<blockquote>
<pre>jvmtiError
GetClassMethods(jvmtiEnv* env,
            jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr)</pre>
</blockquote>
	<code>klass</code> 로 지정된 클래스에 포함되는 메소드의 수를 <code>method_count_ptr</code> 을 개입시켜 돌려주어, 메소드 ID 의 리스트를 <code>methods_ptr</code> 를 개입시켜 돌려줍니다. 메소드의 리스트에는, 본래의 메소드 뿐만이 아니라, 생성자  및 static 초기화자도 포함됩니다. 직접 선언된 메소드만이 돌려주어집니다 (상속한 메소드는 돌려주어지지 않다). 배열 클래스 및 프리미티브(primitive) 클래스 (예를 들어,<code>java.lang.Integer.TYPE</code>)의 경우, 빈 상태(empty)의 메소드 리스트가 돌려주어집니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>52</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
임의의 기능
        </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_maintain_original_method_order"><code>can_maintain_original_method_order</code></a> </td><td>
	  클래스 파일내에 출현하는 순서로 메소드를 돌려줄 수가 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetClassMethods.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetClassMethods.method_count_ptr">method_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 이 클래스에서 선언되고 있는 메소드의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetClassMethods.methods_ptr">methods_ptr</code></td><td><code><a href="#jmethodID">jmethodID</a> **</code></td><td>
	      돌아왔을 때, 메소드 ID 의 배열을 포인트 한다.
	    <p></p>에이전트는 <code>jmethodID*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jmethodID*</code> 는, 사이즈 <code>*method_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_CLASS_NOT_PREPARED"><code>JVMTI_ERROR_CLASS_NOT_PREPARED</code></a> </td><td>
	  <a href="#GetClassMethods.klass"><code>klass</code></a>  가 준비되어 있지 않다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetClassMethods.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetClassMethods.method_count_ptr"><code>method_count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetClassMethods.methods_ptr"><code>methods_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetClassFields">
<h3>클래스의 필드의 취득</h3>
<blockquote>
<pre>jvmtiError
GetClassFields(jvmtiEnv* env,
            jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr)</pre>
</blockquote>
	<code>klass</code> 로 지정된 클래스에 포함되는 필드의 수를 <code>field_count_ptr</code> 를 개입시켜 돌려주어, 필드 ID 의 리스트를 <code>fields_ptr</code> 를 개입시켜 돌려줍니다. 직접 선언된 필드만이 돌려주어집니다 (상속한 필드는 돌려주어지지 않다). 필드는, 클래스 파일내에 출현하는 순서로 돌려주어집니다. 배열 클래스 및 프리미티브(primitive) 클래스 (예를 들어,<code>java.lang.Integer.TYPE</code>)의 경우, 빈 상태(empty)의 필드 리스트가 돌려주어집니다. JNI 를 사용해, 배열의 길이를 판별해 주세요.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>53</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetClassFields.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetClassFields.field_count_ptr">field_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 이 클래스에서 선언되고 있는 필드의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetClassFields.fields_ptr">fields_ptr</code></td><td><code><a href="#jfieldID">jfieldID</a> **</code></td><td>
	      돌아왔을 때, 필드 ID 의 배열을 포인트 한다.
	    <p></p>에이전트는 <code>jfieldID*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jfieldID*</code> 는, 사이즈 <code>*field_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_CLASS_NOT_PREPARED"><code>JVMTI_ERROR_CLASS_NOT_PREPARED</code></a> </td><td> 
	  <a href="#GetClassFields.klass"><code>klass</code></a>  가 준비되어 있지 않다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetClassFields.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetClassFields.field_count_ptr"><code>field_count_ptr</code></a>  이 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetClassFields.fields_ptr"><code>fields_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetImplementedInterfaces">
<h3>구현된 인터페이스의 취득</h3>
<blockquote>
<pre>jvmtiError
GetImplementedInterfaces(jvmtiEnv* env,
            jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr)</pre>
</blockquote>
	이 클래스의 직접적인 슈퍼 인터페이스를 돌려줍니다. 클래스에 대해서는, 이 함수는,<code>implements</code> 절로 선언되고 있는 인터페이스를 돌려줍니다. 인터페이스에 대해서는, 이 함수는,<code>extends</code> 절로 선언되고 있는 인터페이스를 돌려줍니다. 배열 클래스 및 프리미티브(primitive) 클래스 (예를 들어,<code>java.lang.Integer.TYPE</code>)의 경우, 빈 상태(empty)의 인터페이스 리스트가 돌려주어집니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>54</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetImplementedInterfaces.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetImplementedInterfaces.interface_count_ptr">interface_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 인터페이스의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetImplementedInterfaces.interfaces_ptr">interfaces_ptr</code></td><td><code><a href="#jclass">jclass</a> **</code></td><td>
	      돌아왔을 때, 인터페이스의 배열을 포인트 한다.
	    <p></p>에이전트는 <code>jclass*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jclass*</code> 는, 사이즈 <code>*interface_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>interfaces_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_CLASS_NOT_PREPARED"><code>JVMTI_ERROR_CLASS_NOT_PREPARED</code></a> </td><td> 
	  <a href="#GetImplementedInterfaces.klass"><code>klass</code></a>  가 준비되어 있지 않다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetImplementedInterfaces.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetImplementedInterfaces.interface_count_ptr"><code>interface_count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetImplementedInterfaces.interfaces_ptr"><code>interface_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetClassVersionNumbers">
<h3>클래스 버젼 번호의 취득</h3>
<blockquote>
<pre>jvmtiError
GetClassVersionNumbers(jvmtiEnv* env,
            jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr)</pre>
</blockquote>
<code>klass</code> 로 지정된 클래스에 대해서는,<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html">「Class File Format」</a>의 장으로 정의되고 있도록(듯이), 마이너 버젼 번호와 메이저 버젼 번호를 돌려줍니다. <i></i>
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>145</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetClassVersionNumbers.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetClassVersionNumbers.minor_version_ptr">minor_version_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 클래스 파일 형식의 <code>minor_version</code> 항목의 값을 포인트 한다. 주:클래스 파일 형식과의 일관성을 유지하기 위해서(때문에), 마이너 버젼 번호가 최초의 파라미터가 되어 있다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetClassVersionNumbers.major_version_ptr">major_version_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 클래스 파일 형식의 <code>major_version</code> 항목의 값을 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a> </td><td> 
	  클래스가 프리미티브(primitive) 또는 배열 클래스이다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetClassVersionNumbers.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetClassVersionNumbers.minor_version_ptr"><code>minor_version_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetClassVersionNumbers.major_version_ptr"><code>major_version_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetConstantPool">
<h3>정수 풀의 취득</h3>
<blockquote>
<pre>jvmtiError
GetConstantPool(jvmtiEnv* env,
            jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr)</pre>
</blockquote>
	<code>klass</code> 로 나타난 클래스에 대해서는,<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html">「Class File Format」</a>에 기재된 <code>constant_pool</code> 항목의 형식에서 정수 풀의 raw 바이트를 돌려줍니다. <i></i>정수 풀의 형식은, 클래스 파일 형식의 버젼에 따라서 다를 가능성이 있으므로,<a href="#GetClassVersionNumbers">클래스의 메이저 버젼 번호 및 마이너 버젼 번호</a>에 호환성이 있는 것을 확인하도록 해 주세요.
        <p></p>
반환되는 정수 풀의 레이아웃이나 내용이, 정의원의 클래스 파일내의 정수 풀과 같지 않은 것도 있습니다. GetConstantPool()로부터 반환되는 정수 풀의 엔트리수는, 정의원의 정수 풀의 엔트리수와 다른 경우가 있습니다. 엔트리의 순서가 다른 경우도 있습니다. GetConstantPool()로부터 반환되는 정수 풀은,<a href="#GetBytecodes">GetBytecodes()</a>  가 사용하는 정수 풀에 일치합니다. 즉, GetBytecodes()로부터 반환되는 바이트 코드에 포함되는 정수 풀 인덱스는, GetConstantPool()로부터 반환되는 정수 풀의 엔트리를 참조합니다. <a href="#RetransformClasses"><code>RetransformClasses</code></a>  및 <a href="#RedefineClasses"><code>RedefineClasses</code></a>  는 정수 풀을 변경할 수 있기 (위해)때문에, 이 함수로부터 반환되는 정수 풀은, 거기에 응해 변경될 가능성이 있습니다. 따라서, 도중에 클래스의 재변환 또는 재정의를 했을 경우는, GetConstantPool()와 GetBytecodes()의 사이의 대응 관계가 유지되지 않습니다. 어느 특정의 바이트 코드가 사용하는 정수 풀 엔트리의 값은, 정의원클래스 파일의 대응하는 값에 일치합니다 (인덱스가 일치하지 않는 경우에서도). 바이트 코드가 직접적으로도 간접적으로도 사용하지 않는 정수 풀 엔트리 (주석에 관련지을 수 있었던 UTF-8 캐릭터 라인등)는, 반환된 정수 풀내에 존재하고 있지 않아도 괜찮습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>146</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_constant_pool"><code>can_get_constant_pool</code></a> </td><td>
	  어느 클래스의 정수 풀을 취득할 수 있는 - <a href="#GetConstantPool"><code>GetConstantPool</code></a> 
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetConstantPool.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetConstantPool.constant_pool_count_ptr">constant_pool_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 정수 풀 테이블내의 엔트리의 수 + 1 을 포인트 한다. 이것은, 클래스 파일 형식의 <code>constant_pool_count</code> 항목에 대응하고 있다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetConstantPool.constant_pool_byte_count_ptr">constant_pool_byte_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 반환된 raw 정수 풀내의 바이트수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetConstantPool.constant_pool_bytes_ptr">constant_pool_bytes_ptr</code></td><td><code>unsigned char**</code></td><td>
	      돌아왔을 때, raw 정수 풀을 포인트 한다. 이것은, 클래스 파일 형식의 <code>constant_pool</code> 항목으로 정의된 바이트가 된다.
	    <p></p>에이전트는 <code>unsigned char*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>unsigned char*</code> 는, 사이즈 <code>*constant_pool_byte_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_constant_pool"><code>can_get_constant_pool</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a> </td><td> 
	  클래스가 프리미티브(primitive) 또는 배열 클래스이다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetConstantPool.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetConstantPool.constant_pool_count_ptr"><code>constant_pool_count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetConstantPool.constant_pool_byte_count_ptr"><code>constant_pool_byte_count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetConstantPool.constant_pool_bytes_ptr"><code>constant_pool_bytes_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="IsInterface">
<h3>인터페이스인가 어떤가의 검사</h3>
<blockquote>
<pre>jvmtiError
IsInterface(jvmtiEnv* env,
            jclass klass,
            jboolean* is_interface_ptr)</pre>
</blockquote>
	클래스 객체 참조가 인터페이스를 나타내고 있는지 어떤지를 판정합니다. 클래스가 실제로 인터페이스인 경우,<code>jboolean</code> 는 <code>JNI_TRUE</code> 를 돌려주어, 인터페이스가 아닌 경우에는 <code>JNI_FALSE</code> 를 돌려줍니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>55</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="IsInterface.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="IsInterface.is_interface_ptr">is_interface_ptr</code></td><td><code><a href="#jboolean">jboolean</a> *</code></td><td>
	    돌아왔을 때, 이 함수의 boolean 형의 결과를 포인트 한다.

	  <p></p>에이전트는 <code>jboolean</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jboolean</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#IsInterface.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#IsInterface.is_interface_ptr"><code>is_interface_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="IsArrayClass">
<h3>배열 클래스인가 어떤가의 검사</h3>
<blockquote>
<pre>jvmtiError
IsArrayClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_array_class_ptr)</pre>
</blockquote>
	클래스 객체 참조가 배열을 나타내고 있는지 어떤지를 판정합니다. <code>jboolean</code> 는, 클래스가 배열인 경우는 <code>JNI_TRUE</code> 가 되어, 그가 아닌 경우는 <code>JNI_FALSE</code> 가 됩니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>56</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="IsArrayClass.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="IsArrayClass.is_array_class_ptr">is_array_class_ptr</code></td><td><code><a href="#jboolean">jboolean</a> *</code></td><td>
	    돌아왔을 때, 이 함수의 boolean 형의 결과를 포인트 한다.

	  <p></p>에이전트는 <code>jboolean</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jboolean</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#IsArrayClass.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#IsArrayClass.is_array_class_ptr"><code>is_array_class_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="IsModifiableClass">
<h3>변경 가능 클래스인가 어떤가의 검사</h3>
<blockquote>
<pre>jvmtiError
IsModifiableClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_modifiable_class_ptr)</pre>
</blockquote>
	클래스가 변경 가능한가 어떤가를 판정합니다. 클래스가 변경 가능한 경우 (<a href="#IsModifiableClass.is_modifiable_class_ptr"><code>is_modifiable_class_ptr</code></a>  가 <code>JNI_TRUE</code> 를 돌려주었을 경우), 그 클래스는,<a href="#RedefineClasses"><code>RedefineClasses</code></a>  를 사용해 재정의하거나 (에이전트가 <a href="#jvmtiCapabilities.can_redefine_classes"><code>can_redefine_classes</code></a>  권한을 소유하고 있으면(자) 가정),<a href="#RetransformClasses"><code>RetransformClasses</code></a>  를 사용해 재변환하거나 (에이전트가 <a href="#jvmtiCapabilities.can_retransform_classes"><code>can_retransform_classes</code></a>  권한을 소유하고 있으면(자) 가정) 할 수 있습니다. 어느 클래스가 변경 불가능한 경우 (<a href="#IsModifiableClass.is_modifiable_class_ptr"><code>is_modifiable_class_ptr</code></a>  가 <code>JNI_FALSE</code> 를 돌려주었을 경우), 그 클래스는 재정의하는 일도 재변환할 수도 있습니다.
        <p></p>
프리미티브(primitive) 클래스 (<code>java.lang.Integer.TYPE</code> 등)와 배열 클래스가 변경 가능하게 될 것은 없습니다.  
        <p></p>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>45</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
임의의 기능
        </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_redefine_any_class"><code>can_redefine_any_class</code></a> </td><td>
이것을 소유하면(자), 모든 클래스 (프리미티브(primitive) 클래스와 배열 클래스는 제외하다)가 변경 가능하게 된다.
        </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_redefine_classes"><code>can_redefine_classes</code></a> </td><td>
이 함수의 결과에 어떤 영향도 주지 않는다. 다만, 이것을 추가로 소유하고 있지 않으면<a href="#RedefineClasses"><code>RedefineClasses</code></a>  를 사용해 클래스를 변경할 수 없다.
        </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_retransform_classes"><code>can_retransform_classes</code></a> </td><td>
이 함수의 결과에 어떤 영향도 주지 않는다. 다만, 이것을 추가로 소유하고 있지 않으면<a href="#RetransformClasses"><code>RetransformClasses</code></a>  을 사용해 클래스를 변경할 수 없다.
        </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="IsModifiableClass.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="IsModifiableClass.is_modifiable_class_ptr">is_modifiable_class_ptr</code></td><td><code><a href="#jboolean">jboolean</a> *</code></td><td>
	    돌아왔을 때, 이 함수의 boolean 형의 결과를 포인트 한다.
	  <p></p>에이전트는 <code>jboolean</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jboolean</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#IsModifiableClass.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#IsModifiableClass.is_modifiable_class_ptr"><code>is_modifiable_class_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetClassLoader">
<h3>클래스 로더의 취득</h3>
<blockquote>
<pre>jvmtiError
GetClassLoader(jvmtiEnv* env,
            jclass klass,
            jobject* classloader_ptr)</pre>
</blockquote>
	<code>klass</code> 로 지정된 클래스의 클래스 로더의 참조를,<code>classloader_ptr</code> 를 개입시켜 돌려줍니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>57</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetClassLoader.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetClassLoader.classloader_ptr">classloader_ptr</code></td><td><code><a href="#jobject">jobject</a> *</code></td><td>
	      돌아왔을 때, 이 클래스를 로드한 클래스 로더를 포인트 한다. 클래스가 클래스 로더로 작성되어 있지 않은 경우, 또는 클래스 로더가 bootstrap 클래스 로더가 아닌 경우는,<code>NULL</code> 를 포인트 한다.
	    <p></p>에이전트는 <code>jobject</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jobject</code> 가 설정되어 있다. <code>classloader_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetClassLoader.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetClassLoader.classloader_ptr"><code>classloader_ptr</code></a>  이 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetSourceDebugExtension">
<h3>소스 디버그 확장 기능의 취득</h3>
<blockquote>
<pre>jvmtiError
GetSourceDebugExtension(jvmtiEnv* env,
            jclass klass,
            char** source_debug_extension_ptr)</pre>
</blockquote>
	<code>klass</code> 로 지정된 클래스의 디버그 확장 기능을,<code>source_debug_extension_ptr</code> 를 개입시켜 돌려줍니다. 반환되는 캐릭터 라인에는,<code>klass</code> 의 클래스 파일에 존재하는 디버그 확장 정보가 그대로 포함됩니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>90</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_source_debug_extension"><code>can_get_source_debug_extension</code></a> </td><td>
	  클래스의 소스 디버그 확장 기능을 취득할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetSourceDebugExtension.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetSourceDebugExtension.source_debug_extension_ptr">source_debug_extension_ptr</code></td><td><code>char**</code></td><td>
	    돌아왔을 때, 클래스의 debug 확장 기능 (<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다)을 포인트 한다.
	  <p></p>에이전트는 <code>char*</code> 에 포인터를 건네준다. <code>char*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_source_debug_extension"><code>can_get_source_debug_extension</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a> </td><td> 
	  클래스 정보에, 디버그 확장이 포함되지 않았다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetSourceDebugExtension.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetSourceDebugExtension.source_debug_extension_ptr"><code>source_debug_extension_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="RetransformClasses">
<h3>클래스의 재변환</h3>
<blockquote>
<pre>jvmtiError
RetransformClasses(jvmtiEnv* env,
            jint class_count,
            const jclass* classes)</pre>
</blockquote>
이 함수는, 벌써 로드 끝난 클래스의<a href="#bci">바이트코드Instrumentation</a>을 용이하게 합니다. 수정하면서 디버그를 계속하기 위해서(때문에) 소스로부터 재컴파일 하는 경우와 같이, 기존의 바이트 코드를 참조하는 것 없이 클래스 정의를 치환하는 경우는, 대신에 <a href="#RedefineClasses"><code>RedefineClasses</code></a>  함수를 사용하도록 해 주세요.
        <p></p>
클래스가 처음 로드 될 때나<a href="#RedefineClasses">재정의</a>될 때에, 그 초기 클래스 파일 바이트를 <a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>  이벤트 경유로 변환할 수가 있습니다. 이 함수는, 이전에 변환을 했는지 어떠했는지에는 관계없이, 변환 처리를 재실행합니다. 이 재변환은 다음의 순서로 행해집니다.
        <ul type="disc">
          
<li>초기 클래스 파일 바이트로부터 처리가 개시됩니다.
          </li>
          
<li>전회의 로드 또는 재정의시에 <code>ClassFileLoadHook</code> 이벤트를 수신한<a href="#jvmtiCapabilities.can_retransform_classes">재변환 불가능 </a>에이전트 마다, 에이전트가 (<code>new_class_data</code> 파라미터 경유로) 돌려준 바이트가 변환의 출력으로서 재사용됩니다. 이것은,<code>ClassFileLoadHook</code> 이벤트가 이러한 에이전트에 송신되지 않는 점을 제외하면, 전회의 변환을 변경없이 재적용하는 것과 등가입니다. <b></b>
          </li>
          
<li><a href="#jvmtiCapabilities.can_retransform_classes">재변환 가능 </a>에이전트 마다,<code>ClassFileLoadHook</code> 이벤트가 송신됩니다. 이것에 의해, 새로운 변환을 적용할 수 있게 됩니다.
          </li>
          
<li>변환된 클래스 파일 바이트가 클래스의 새로운 정의로서 인스톨 됩니다.
          </li>
        
</ul>
자세한 것은 <a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>  이벤트를 참조해 주세요.
        <p></p>
초기 클래스 파일 바이트는,<code>ClassLoader.defineClass</code> 또는 <code>RedefineClasses</code> 에게 건네진 바이트 (변환의 적용전)를 나타냅니다. 다만, 양자가 엄밀하게는 일치하지 않는 것이 있습니다. <a href="#GetConstantPool"><code>GetConstantPool</code></a>  로 설명한 것처럼, 정수 풀이 다른 경우가 있습니다. 메소드의 바이트 코드내의 정수 풀 인덱스는 대응합니다. 일부의 속성이 존재하지 않을 가능성이 있습니다. 순서가 중요하지 않은 경우 (메소드의 순서 등), 순서가 유지되지 않는 경우가 있습니다.
        <p></p>
재변환을 실시하면, 새로운 버젼의 메소드가 인스톨 될 가능성이 있습니다. 낡은 메소드 버젼은<a href="#obsoleteMethods">폐지</a>되어 그 후의 호출에서는 새로운 메소드 버젼이 사용됩니다. 재정의된 메소드에 액티브한 스택 프레임이 있으면(자), 그 액티브 프레임은 원의 메소드의 바이트 코드의 실행을 속행합니다.  
        <p></p>
이 함수에 의해, 일반적인 JVM 시멘틱스의 아래에서 행해지는 이외의 초기화는 일어나지 않습니다. 즉, 클래스를 재변환해도, 그 클래스의 초기화는 실행되지 않습니다. static 필드의 값은, 호출전 상태인 채입니다.
        <p></p>
thread를 중단할 필요는 없습니다.
        <p></p>
클래스내의 breakpoint는 해제됩니다.
        <p></p>
속성은 모두 갱신됩니다.
        <p></p>
재변환된 클래스의 인스턴스는 영향을 받지 않습니다. 필드는 이전의 값을 보관 유지합니다. 인스턴스상의<a href="#GetTag">태그</a>도 영향을 받지 않습니다.
        <p></p>
이 호출에의 응답으로서<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>  이외의 이벤트가 송신될 것은 없습니다.
        <p></p>
재변환에 의해, 메소드의 본체, 정수 풀, 속성이 변경되는 일이 있습니다. 재변환에 의해, 필드나 메소드의 추가, 삭제, 이름의 변경, 메소드의 시그니챠의 변경, 수식자의 변경, 상속의 변경이 일어나지 않게 할 필요가 있습니다. 이러한 제한은, 장래의 버젼으로 해제될 가능성이 있습니다. 지원되어 있지 않은 재변환이 시행되었을 때 반환되는 에러 코드에 대해서는, 아래와 같은 에러 반환값의 설명을 참조해 주세요. 클래스 파일의 바이트가 검증 또는 인스톨 되는 것은, 그러한 바이트가 <a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>  이벤트의 체인을 통과 혀 후입니다. 따라서, 변환의 결과가, 반환되는 에러 코드에 반영됩니다. <code>JVMTI_ERROR_NONE</code> 이외의 에러 코드가 돌려주어졌을 경우, 재변환 대상 클래스의 어느 것에도 새로운 정의는 인스톨 되지 않습니다. 이 함수가 (에러 코드 <code>JVMTI_ERROR_NONE</code> 로) 돌아왔을 경우, 재변환 대상의 모든 클래스에 새로운 정의가 인스톨 됩니다.         
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>152</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_retransform_classes"><code>can_retransform_classes</code></a> </td><td>
	  <a href="#RetransformClasses"><code>RetransformClasses</code></a>  로 클래스를 재변환할 수 있다. 특정의 구현에 의한 이 권한의 제한 (<a href="#capability">「권한」</a>섹션을 참조)에 가세해 이 권한은, 이 환경에서 <a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>  이벤트가 처음 유효화 되기 전으로 설정해야 한다. <code>ClassFileLoadHook</code> 가 처음 유효화 된 시점에서 이 권한을 소유하고 있는 환경을 「재변환 가능」이라고 부른다. <i></i><code>ClassFileLoadHook</code> 가 처음 유효화 된 시점에서 이 권한을 소유하고 있지 않는 환경은 「재변환 불가능」이라고 부른다. <i></i>
	</td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
임의의 기능
        </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_retransform_any_class"><code>can_retransform_any_class</code></a> </td><td>
<a href="#RetransformClasses"><code>RetransformClasses</code></a>  를 임의의 클래스에서 호출할 수 있다 (<a href="#jvmtiCapabilities.can_retransform_classes"><code>can_retransform_classes</code></a>  도 설정할 필요가 있다)
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="RetransformClasses.class_count">class_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
재변환되는 클래스의 수.
          </td>
</tr>
<tr>
<td><code id="RetransformClasses.classes">classes</code></td><td><code>const <a href="#jclass">jclass</a> *</code></td><td>
재변환되는 클래스의 배열.
<p></p>에이전트는 <code>jclass</code> 의 <code>class_count</code> 요소의 배열을 건네준다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_retransform_classes"><code>can_retransform_classes</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNMODIFIABLE_CLASS"><code>JVMTI_ERROR_UNMODIFIABLE_CLASS</code></a> </td><td>
변경 불가능한 클래스가 <a href="#RetransformClasses.classes"><code>classes</code></a>  에 포함되어 있다. <a href="#IsModifiableClass"><code>IsModifiableClass</code></a>  를 참조.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
<a href="#RetransformClasses.classes"><code>classes</code></a>  중 한쪽이 유효한 클래스가 아니다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_VERSION"><code>JVMTI_ERROR_UNSUPPORTED_VERSION</code></a> </td><td>
재변환되는 클래스 파일의 버젼 번호가 이 VM 로 지원되어 있지 않다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS_FORMAT"><code>JVMTI_ERROR_INVALID_CLASS_FORMAT</code></a> </td><td>
재변환되는 클래스 파일의 형식이 올바르지 않다 (VM <code>ClassFormatError</code> 를 돌려준다).
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION"><code>JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION</code></a> </td><td>
재변환되는 클래스 파일의 정의가 순환 정의가 된다 (VM 는 <code>ClassCircularityError</code> 를 돌려준다).
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_FAILS_VERIFICATION"><code>JVMTI_ERROR_FAILS_VERIFICATION</code></a> </td><td>
재변환되는 클래스 파일의 바이트가 검증에 실패한다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NAMES_DONT_MATCH"><code>JVMTI_ERROR_NAMES_DONT_MATCH</code></a> </td><td>
재변환되는 클래스 파일내에서 정의된 클래스명이, 구클래스 객체내의 이름과 다르다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED</code></a> </td><td>
재변환되는 클래스 파일로 메소드의 추가가 필요.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED</code></a> </td><td>
재변환되는 클래스 파일에 의해 필드가 변경된다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED</code></a> </td><td>
재변환되는 클래스 파일의 직접 슈퍼 클래스가 다르다, 또는 직접 구현되고 있는 인터페이스가 다르다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED</code></a> </td><td>
재변환되는 클래스 파일에서는 구클래스의 버젼으로 선언한 메소드를 선언하지 않는다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED</code></a> </td><td>
재변환된 클래스 파일에 다른 클래스 수식자가 포함되어 있다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED</code></a> </td><td>
재변환되는 클래스 파일의 메소드의 수식자가 구클래스의 버젼의 수식자와 다르다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
<a href="#RetransformClasses.class_count"><code>class_count</code></a>  가 <code>0</code> 보다 작다.
          
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
<a href="#RetransformClasses.classes"><code>classes</code></a>  가 <code>NULL</code>.
          
        </td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="RedefineClasses">
<h3>클래스의 재정의</h3>
<blockquote>
<pre>typedef struct {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
} jvmtiClassDefinition;</pre>
<pre>jvmtiError
RedefineClasses(jvmtiEnv* env,
            jint class_count,
            const jvmtiClassDefinition* class_definitions)</pre>
</blockquote>
	지정된 클래스는 모두, 제공되는 정의에 따라 재정의됩니다. 이 함수는, 어느 클래스의 정의를 새로운 정의로 옮겨놓는 경우에 사용됩니다. 그러한 조작은, 수정하면서 디버그를 계속해 가는 경우에 필요하게 되는 일이 있습니다. <a href="#bci">바이트코드Instrumentation</a>을 실시하는 경우 등, 기존의 클래스 파일의 바이트를 변환할 필요가 있는 경우는,<a href="#RetransformClasses"><code>RetransformClasses</code></a>  를 사용해 주세요.
	<p></p>
	재정의를 실시하면, 새로운 버젼의 메소드가 인스톨 될 가능성이 있습니다. 낡은 메소드 버젼은<a href="#obsoleteMethods">폐지</a>되어 그 후의 호출에서는 새로운 메소드 버젼이 사용됩니다. 재정의된 메소드에 액티브한 스택 프레임이 있으면(자), 그 액티브 프레임은 원의 메소드의 바이트 코드의 실행을 속행합니다. 스택 프레임을 리셋 하는 경우는, 파기된 메소드와 함께 <a href="#PopFrame"><code>PopFrame</code></a>  를 사용해, 프레임을 팝 해 주세요.
	<p></p>
	이 함수에 의해, 일반적인 JVM 시멘틱스의 아래에서 행해지는 이외의 초기화는 일어나지 않습니다. 즉, 클래스를 재정의해도, 그 클래스의 초기화는 실행되지 않습니다. static 필드의 값은, 호출전 상태인 채입니다.
	<p></p>
	thread를 중단할 필요는 없습니다.
	<p></p>
	클래스내의 breakpoint은 해제됩니다.
	<p></p>
	속성은 모두 갱신됩니다.
	<p></p>
재정의된 클래스의 인스턴스는 영향을 받지 않습니다. 필드는 이전의 값을 보관 유지합니다. 인스턴스상의<a href="#GetTag">태그</a>도, 영향을 받지 않습니다.
	<p></p>
	이 호출에 대답해, JVM<small style="font-size: xx-small">&nbsp;</small>TI 이벤트로서<a href="#ClassFileLoadHook">클래스 파일 로드 훅</a>이 송신됩니다 (유효한 경우). 그러나, 그 외의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 이벤트는 송신되지 않습니다.
        <p></p>
재정의에 의해, 메소드의 본체, 정수 풀, 속성이 변경되는 일이 있습니다. 재정의에 의해, 필드나 메소드의 추가, 삭제, 이름의 변경, 메소드의 시그니챠의 변경, 수식자의 변경, 상속의 변경이 일어나지 않게 할 필요가 있습니다. 이러한 제한은, 장래의 버젼으로 해제될 가능성이 있습니다. 지원되어 있지 않은 재정의가 시행되었을 때 반환되는 에러 코드에 대해서는, 아래와 같은 에러 반환값의 설명을 참조해 주세요. 클래스 파일의 바이트가 검증 또는 인스톨 되는 것은, 그러한 바이트가 <a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>  이벤트의 체인을 통과 혀 후입니다. 따라서,<a href="#RedefineClasses.class_definitions"><code>class_definitions</code></a>  에게 건네진 바이트에 적용된 변환의 결과가, 반환되는 에러 코드에 반영됩니다. <code>JVMTI_ERROR_NONE</code> 이외의 에러 코드가 돌려주어졌을 경우, 재정의 대상 클래스의 어느 것에도 새로운 정의는 인스톨 되지 않습니다. 이 함수가 (에러 코드 <code>JVMTI_ERROR_NONE</code> 로) 돌아왔을 경우, 재정의 대상의 모든 클래스에 새로운 정의가 인스톨 됩니다.         
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>87</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_redefine_classes"><code>can_redefine_classes</code></a> </td><td>
	  <a href="#RedefineClasses"><code>RedefineClasses</code></a>  로 클래스를 재정의할 수 있다.
	</td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
임의의 기능
        </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_redefine_any_class"><code>can_redefine_any_class</code></a> </td><td>
프리미티브(primitive) 클래스에서도 배열 클래스도 아닌 임의의 클래스를 변경 (재변환 또는 재정의)할 수 있다. <a href="#IsModifiableClass"><code>IsModifiableClass</code></a>  를 참조.
	</td>
</tr>
</table>
<p id="jvmtiClassDefinition"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiClassDefinition</code> - 클래스의 재정의의 설명</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiClassDefinition.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      이 클래스의 클래스 객체
	    </td>
</tr>
<tr>
<td><code id="jvmtiClassDefinition.class_byte_count">class_byte_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    정의하는 클래스의 바이트수
	  </td>
</tr>
<tr>
<td><code id="jvmtiClassDefinition.class_bytes">class_bytes</code></td><td><code>const unsigned char*</code></td><td>
클래스를 정의하는 바이트 (<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html">「Class File Format」</a>의 설명을 참조)<i></i>
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="RedefineClasses.class_count">class_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    <code>class_definitions</code> 로 지정된 클래스의 수
	  </td>
</tr>
<tr>
<td><code id="RedefineClasses.class_definitions">class_definitions</code></td><td><code>const <a href="#jvmtiClassDefinition">jvmtiClassDefinition</a> *</code></td><td>
	    새로운 클래스 정의의 배열수
	  <p></p>에이전트는 <code>jvmtiClassDefinition</code> 의 <code>class_count</code> 요소의 배열을 건네준다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_redefine_classes"><code>can_redefine_classes</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  을 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  몇개의 <code>class_bytes</code> 가 <code>NULL</code>.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNMODIFIABLE_CLASS"><code>JVMTI_ERROR_UNMODIFIABLE_CLASS</code></a> </td><td>
	  <code>class_definitions</code> 의 요소는 변경할 수 없다. <a href="#IsModifiableClass"><code>IsModifiableClass</code></a>  를 참조.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <code>class_definitions</code> 의 요소가 유효한 클래스는 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_VERSION"><code>JVMTI_ERROR_UNSUPPORTED_VERSION</code></a> </td><td>
	  새로운 클래스 파일의 버젼이 이 VM 로 지원되어 있지 않다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS_FORMAT"><code>JVMTI_ERROR_INVALID_CLASS_FORMAT</code></a> </td><td>
	  새로운 클래스 파일의 형식이 올바르지 않다 (VM <code>ClassFormatError</code> 를 돌려준다).
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION"><code>JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION</code></a> </td><td>
	  새로운 클래스 파일의 정의가 순환 정의가 된다 (VM 는 <code>ClassCircularityError</code> 를 돌려준다).
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_FAILS_VERIFICATION"><code>JVMTI_ERROR_FAILS_VERIFICATION</code></a> </td><td>
	  클래스 바이트가 검증에 실패한다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NAMES_DONT_MATCH"><code>JVMTI_ERROR_NAMES_DONT_MATCH</code></a> </td><td>
	  새로운 클래스 파일내에서 정의된 클래스명이, 구클래스 객체내의 이름과 다르다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED</code></a> </td><td>
	  새로운 클래스 파일로 메소드의 추가가 필요.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED</code></a> </td><td>
	  새로운 클래스의 버젼에 의해 필드가 변경된다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED</code></a> </td><td>
	  새로운 클래스의 버젼의 직접 슈퍼 클래스가 다르다, 또는 직접 구현되고 있는 인터페이스가 다르다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED</code></a> </td><td>
	  새로운 클래스의 버젼에서는 구클래스의 버젼으로 선언한 메소드를 선언하지 않는다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED</code></a> </td><td>
	  새로운 클래스의 버젼의 수식자가 다르다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED</code></a> </td><td>
	  새로운 클래스의 버젼의 메소드의 수식자가 구클래스의 버젼의 수식자와 다르다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#RedefineClasses.class_count"><code>class_count</code></a>  가 <code>0</code> 보다 작다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#RedefineClasses.class_definitions"><code>classes_definitions</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<p id="object"></p>
<hr noshade="noshade" size="3">
<h2 align="center">객체</h2>객체 함수:
  <ul>
<li>
<a href="#GetObjectSize">객체 사이즈의 취득</a> 
</li>
<li>
<a href="#GetObjectHashCode">객체의 해시 코드의 취득</a> 
</li>
<li>
<a href="#GetObjectMonitorUsage">객체의 모니터의 이용 정보를 취득</a> 
</li>
</ul>객체의 형태:
    <ul>
<li>
<a href="#jvmtiMonitorUsage"><code>jvmtiMonitorUsage</code></a>  - 객체 모니터의 사용 정보</li>
</ul>
<p></p>
<hr noshade="noshade" width="100%" size="1" id="GetObjectSize">
<h3>객체 사이즈의 취득</h3>
<blockquote>
<pre>jvmtiError
GetObjectSize(jvmtiEnv* env,
            jobject object,
            jlong* size_ptr)</pre>
</blockquote>
	<code>object</code> 로 지정된 객체의 사이즈를,<code>size_ptr</code> 를 개입시켜 돌려줍니다. 이 사이즈는, 이 객체에 의해 소비되는 기억 영역의 용량의 근사치이며, 구현 마다 다릅니다. 일부 또는 모든 객체의 오버헤드를 포함할 수가 있습니다. 이 때문에, 구현내에서의 비교에는 적합합니다만, 구현간에서의 비교에는 적합하지 않습니다. 예상치는, JVM 를 1 회 호출하는 동안으로 변경되는 일이 있습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>154</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetObjectSize.object">object</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	      조회하는 객체.
	    </td>
</tr>
<tr>
<td><code id="GetObjectSize.size_ptr">size_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    돌아왔을 때, 객체의 사이즈 (바이트 단위)를 포인트 한다.
	  <p></p>에이전트는 <code>jlong</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jlong</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a> </td><td>
	  <a href="#GetObjectSize.object"><code>object</code></a>  가 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetObjectSize.size_ptr"><code>size_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetObjectHashCode">
<h3>객체의 해시 코드의 취득</h3>
<blockquote>
<pre>jvmtiError
GetObjectHashCode(jvmtiEnv* env,
            jobject object,
            jint* hash_code_ptr)</pre>
</blockquote>
	<code>object</code> 로 지정된 객체의 해시 코드를,<code>hash_code_ptr</code> 를 개입시켜 돌려줍니다. 객체 참조의 해시 테이블을 관리하기 위해서, 이 해시 코드를 사용할 수 있습니다. 그러나, 일부의 구현에서는, 퍼포먼스가 큰폭으로 저감 할 가능성이 있습니다. 대부분의 경우, 정보와 객체의 관련지어에는,<a href="#Heap">태그</a>를 사용하는 편이 효과적입니다. 이 함수는, 특정의 객체의 지속 기간중 쭉, 그 객체의 해시 코드값가 같은 것을 보증합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>58</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetObjectHashCode.object">object</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	      조회하는 객체.
	    </td>
</tr>
<tr>
<td><code id="GetObjectHashCode.hash_code_ptr">hash_code_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 객체의 해시 코드를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a> </td><td>
	  <a href="#GetObjectHashCode.object"><code>object</code></a>  가 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetObjectHashCode.hash_code_ptr"><code>hash_code_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetObjectMonitorUsage">
<h3>객체의 모니터의 이용 정보를 취득</h3>
<blockquote>
<pre>typedef struct {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
} jvmtiMonitorUsage;</pre>
<pre>jvmtiError
GetObjectMonitorUsage(jvmtiEnv* env,
            jobject object,
            jvmtiMonitorUsage* info_ptr)</pre>
</blockquote>
	객체의 모니터에 관한 정보를 가져옵니다. <a href="#jvmtiMonitorUsage"><code>jvmtiMonitorUsage</code></a>  구조체의 필드에, 모니터의 사용에 관한 정보가 들어갑니다.
	  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>59</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_monitor_info"><code>can_get_monitor_info</code></a> </td><td>
<a href="#GetObjectMonitorUsage"><code>GetObjectMonitorUsage</code></a>  를 실행할 수 있다.
      </td>
</tr>
</table>
<p id="jvmtiMonitorUsage"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiMonitorUsage</code> - 객체 모니터의 사용 정보</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiMonitorUsage.owner">owner</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      이 모니터를 소유하고 있는 thread. 이 모니터가 사용되어 있지 않은 경우는 <code>NULL</code>.
	    </td>
</tr>
<tr>
<td><code id="jvmtiMonitorUsage.entry_count">entry_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    이 모니터를 소유하는 thread가 모니터를 사용한 회수
	  </td>
</tr>
<tr>
<td><code id="jvmtiMonitorUsage.waiter_count">waiter_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    이 모니터를 소유하는 차례를 기다리고 있는 thread의 수
	  </td>
</tr>
<tr>
<td><code id="jvmtiMonitorUsage.waiters">waiters</code></td><td><code><a href="#jthread">jthread</a> *</code></td><td>
	      <code>waiter_count</code> 대기 thread
	    </td>
</tr>
<tr>
<td><code id="jvmtiMonitorUsage.notify_waiter_count">notify_waiter_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    이 모니터로부터 통지를 받는 대기 thread의 수
	  </td>
</tr>
<tr>
<td><code id="jvmtiMonitorUsage.notify_waiters">notify_waiters</code></td><td><code><a href="#jthread">jthread</a> *</code></td><td>
	      통지를 기다리고 있는 <code>notify_waiter_count</code> thread
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetObjectMonitorUsage.object">object</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	      조회하는 객체.
	    </td>
</tr>
<tr>
<td><code id="GetObjectMonitorUsage.info_ptr">info_ptr</code></td><td><code><a href="#jvmtiMonitorUsage">jvmtiMonitorUsage</a> *</code></td><td>
	    돌아왔을 때, 지정된 객체의 모니터 정보가 들어가 있다.
	  <p></p>에이전트는 <code>jvmtiMonitorUsage</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiMonitorUsage</code> 가 설정되어 있다. <code>jvmtiMonitorUsage</code> 의 <code>owner</code> 필드에 반환되는 객체는, JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다. <code>jvmtiMonitorUsage</code> 의 <code>waiters</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiMonitorUsage</code> 의 <code>waiters</code> 필드에 반환되는 객체는, JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다. <code>jvmtiMonitorUsage</code> 의 <code>notify_waiters</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiMonitorUsage</code> 의 <code>notify_waiters</code> 필드에 반환되는 객체는, JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_monitor_info"><code>can_get_monitor_info</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a> </td><td>
	  <a href="#GetObjectMonitorUsage.object"><code>object</code></a>  가 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetObjectMonitorUsage.info_ptr"><code>info_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<p id="fieldCategory"></p>
<hr noshade="noshade" size="3">
<h2 align="center">필드</h2>필드 함수:
  <ul>
<li>
<a href="#GetFieldName">필드의 이름과 시그니챠의 취득</a> 
</li>
<li>
<a href="#GetFieldDeclaringClass">필드의 선언 클래스의 취득</a> 
</li>
<li>
<a href="#GetFieldModifiers">필드의 수식자의 취득</a> 
</li>
<li>
<a href="#IsFieldSynthetic">합성 필드인가 어떤가의 검사</a> 
</li>
</ul>
    
<p></p>
<hr noshade="noshade" width="100%" size="1" id="GetFieldName">
<h3>필드의 이름과 시그니챠의 취득</h3>
<blockquote>
<pre>jvmtiError
GetFieldName(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)</pre>
</blockquote>
	<a href="#GetFieldName.klass"><code>klass</code></a>  와 <a href="#GetFieldName.field"><code>field</code></a>  로 지정된 필드에 도착해, 이름을 <a href="#GetFieldName.name_ptr"><code>name_ptr</code></a>  로 돌려주어, 시그니챠를 <a href="#GetFieldName.signature_ptr"><code>signature_ptr</code></a>  로 돌려줍니다.
	<p></p>
필드의 시그니챠는 JNI 스펙으로 정의되고 있어<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>에서는<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#14152">필드 기술자</a>로 불리고 있습니다. <i></i>
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>60</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetFieldName.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 필드의 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetFieldName.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a> </code></td><td>
	      조회하는 필드.
	    </td>
</tr>
<tr>
<td><code id="GetFieldName.name_ptr">name_ptr</code></td><td><code> char
	    
	  **</code></td><td>
	    돌아왔을 때, 필드명 (<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다)을 포인트 한다.
	  <p></p>에이전트는 <code>char*</code> 에 포인터를 건네준다. <code>char*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>name_ptr</code> 가 <code>NULL</code> 의 경우, 이름은 돌려주어지지 않다.
</td>
</tr>
<tr>
<td><code id="GetFieldName.signature_ptr">signature_ptr</code></td><td><code> char
	    
	  **</code></td><td>
	    돌아왔을 때, 필드의 시그니챠 (<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다)를 포인트 한다.
	  <p></p>에이전트는 <code>char*</code> 에 포인터를 건네준다. <code>char*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>signature_ptr</code> 가 <code>NULL</code> 의 경우, 시그니챠는 돌려주어지지 않다.
</td>
</tr>
<tr>
<td><code id="GetFieldName.generic_ptr">generic_ptr</code></td><td><code> char           
            
          **</code></td><td>
	    돌아왔을 때, 필드의 총칭 시그니챠 (<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다)를 포인트 한다. 필드의 총칭 시그니챠 속성이 존재하지 않는 경우는, 돌아왔을 때 <code>NULL</code> 를 포인트 한다.  
	  <p></p>에이전트는 <code>char*</code> 에 포인터를 건네준다. <code>char*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>generic_ptr</code> 가 <code>NULL</code> 의 경우, 총칭 시그니챠는 돌려주어지지 않다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetFieldName.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a> </td><td>
	  <a href="#GetFieldName.field"><code>field</code></a>  가 jfieldID 는 아니다.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetFieldDeclaringClass">
<h3>필드의 선언 클래스의 취득</h3>
<blockquote>
<pre>jvmtiError
GetFieldDeclaringClass(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr)</pre>
</blockquote>
	<code>klass</code> 와 <code>field</code> 로 지정된 필드에 도착해, 그 필드를 정의하고 있는 클래스를 <code>declaring_class_ptr</code> 를 개입시켜 돌려줍니다. 선언하고 있는 클래스는,<code>klass</code>, 슈퍼 클래스, 또는 구현된 인터페이스의 머지않아인가입니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>61</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetFieldDeclaringClass.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetFieldDeclaringClass.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a> </code></td><td>
	      조회하는 필드.
	    </td>
</tr>
<tr>
<td><code id="GetFieldDeclaringClass.declaring_class_ptr">declaring_class_ptr</code></td><td><code><a href="#jclass">jclass</a> *</code></td><td>
	      돌아왔을 때, 선언하는 클래스를 포인트 한다.
	    <p></p>에이전트는 <code>jclass</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jclass</code> 가 설정되어 있다. <code>declaring_class_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetFieldDeclaringClass.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a> </td><td>
	  <a href="#GetFieldDeclaringClass.field"><code>field</code></a>  가 jfieldID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetFieldDeclaringClass.declaring_class_ptr"><code>declaring_class_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetFieldModifiers">
<h3>필드의 수식자의 취득</h3>
<blockquote>
<pre>jvmtiError
GetFieldModifiers(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jint* modifiers_ptr)</pre>
</blockquote>
	<code>klass</code> 와 <code>field</code> 로 지정된 필드의 액세스 플래그를,<code>modifiers_ptr</code> 를 개입시켜 돌려줍니다. 액세스 플래그에 대해서는,<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html">「Class File Format」</a>의 장으로 정의되고 있습니다. <i></i>
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>62</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetFieldModifiers.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 클래스.
	    </td>
</tr>
<tr>
<td><code id="GetFieldModifiers.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a> </code></td><td>
	      조회하는 필드.
	    </td>
</tr>
<tr>
<td><code id="GetFieldModifiers.modifiers_ptr">modifiers_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 액세스 플래그를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#GetFieldModifiers.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a> </td><td>
	  <a href="#GetFieldModifiers.field"><code>field</code></a>  가 jfieldID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetFieldModifiers.modifiers_ptr"><code>modifiers_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="IsFieldSynthetic">
<h3>합성 필드인가 어떤가의 검사</h3>
<blockquote>
<pre>jvmtiError
IsFieldSynthetic(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr)</pre>
</blockquote>
	<code>klass</code> 및 <code>field</code> 로 지정된 필드에 대해,<code>is_synthetic_ptr</code> 를 개입시켜 그 필드가 합성일지 어떨지를 나타내는 값을 돌려줍니다. 합성 필드는 컴파일러에 의해 생성됩니다만, 원의 원시 코드내에는 존재하지 않습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>63</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_synthetic_attribute"><code>can_get_synthetic_attribute</code></a> </td><td>
	  합성 필드 또는 합성 메소드일지 어떨지를 테스트할 수 있는 - <a href="#IsFieldSynthetic"><code>IsFieldSynthetic</code></a>  와 <a href="#IsMethodSynthetic"><code>IsMethodSynthetic</code></a> 
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="IsFieldSynthetic.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	      조회하는 필드의 클래스.
	    </td>
</tr>
<tr>
<td><code id="IsFieldSynthetic.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a> </code></td><td>
	      조회하는 필드.
	    </td>
</tr>
<tr>
<td><code id="IsFieldSynthetic.is_synthetic_ptr">is_synthetic_ptr</code></td><td><code><a href="#jboolean">jboolean</a> *</code></td><td>
	    돌아왔을 때, 이 함수의 boolean 형의 결과를 포인트 한다.
	  <p></p>에이전트는 <code>jboolean</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jboolean</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_synthetic_attribute"><code>can_get_synthetic_attribute</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a> </td><td>
	  <a href="#IsFieldSynthetic.klass"><code>klass</code></a>  가 클래스 객체가 아닌지, 클래스가 언로드되고 있다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a> </td><td>
	  <a href="#IsFieldSynthetic.field"><code>field</code></a>  가 jfieldID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#IsFieldSynthetic.is_synthetic_ptr"><code>is_synthetic_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<p id="method"></p>
<hr noshade="noshade" size="3">
<h2 align="center">메소드</h2>메소드 함수:
  <ul>
<li>
<a href="#GetMethodName">메소드의 이름과 시그니챠의 취득</a> 
</li>
<li>
<a href="#GetMethodDeclaringClass">메소드의 선언 클래스의 취득</a> 
</li>
<li>
<a href="#GetMethodModifiers">메소드의 수식자의 취득</a> 
</li>
<li>
<a href="#GetMaxLocals">국소 변수의 취득</a> 
</li>
<li>
<a href="#GetArgumentsSize">인수의 사이즈의 취득</a> 
</li>
<li>
<a href="#GetLineNumberTable">행 번호 테이블의 취득</a> 
</li>
<li>
<a href="#GetMethodLocation">메소드의 배치 위치의 취득</a> 
</li>
<li>
<a href="#GetLocalVariableTable">국소 변수 테이블의 취득</a> 
</li>
<li>
<a href="#GetBytecodes">바이트 코드의 취득</a> 
</li>
<li>
<a href="#IsMethodNative">네이티브 메소드인가 어떤가의 검사</a> 
</li>
<li>
<a href="#IsMethodSynthetic">합성 메소드인가 어떤가의 검사</a> 
</li>
<li>
<a href="#IsMethodObsolete">폐기된 메소드인가 어떤가의 검사</a> 
</li>
<li>
<a href="#SetNativeMethodPrefix">네이티브 메소드 접두사의 설정</a> 
</li>
<li>
<a href="#SetNativeMethodPrefixes">복수의 네이티브 메소드 접두사의 설정</a> 
</li>
</ul>메소드의 형태:
    <ul>
<li>
<a href="#jvmtiLineNumberEntry"><code>jvmtiLineNumberEntry</code></a>  - 행 번호 테이블의 엔트리</li>
<li>
<a href="#jvmtiLocalVariableEntry"><code>jvmtiLocalVariableEntry</code></a>  - 국소 변수 테이블의 엔트리</li>
</ul>
이러한 함수는, 어느 메소드 (<a href="#jmethodID"><code>jmethodID</code></a>  로서 표현)에 관한 정보를 제공하거나 메소드의 처리 방법을 설정하거나 합니다.
<h4 id="obsoleteMethods">폐지 메소드</h4>
함수 <a href="#RetransformClasses"><code>RetransformClasses</code></a>  및 <a href="#RedefineClasses"><code>RedefineClasses</code></a>  를 호출하면(자), 새로운 버젼의 메소드가 인스톨 됩니다. 원의 메소드와 재정의한 메소드가 동등으로 간주해지는 것은, 다음과 같은 경우입니다.
      <ul type="disc">
        
<li>쌍방의 메소드의 바이트 코드가 같다 (정수 풀의 인덱스를 제외하다) </li>
        
<li>참조 정수가 동일하다</li>
      
</ul>
새로운 메소드 버젼과 등가가 아닌 원의 메소드 버젼은 「폐지」라고 불려 새로운 메소드 ID 를 할당할 수 있습니다. 그리고, 원의 메소드 ID 는 새로운 메소드 버젼을 참조하게 됩니다. 폐기된 메소드인가 어떤가를 테스트하려면 ,<a href="#IsMethodObsolete"><code>IsMethodObsolete</code></a>  를 사용합니다.
    <p></p>
<hr noshade="noshade" width="100%" size="1" id="GetMethodName">
<h3>메소드의 이름과 시그니챠의 취득</h3>
<blockquote>
<pre>jvmtiError
GetMethodName(jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)</pre>
</blockquote>
	<code>method</code> 로 지정된 메소드의 이름을 <code>name_ptr</code> 를 개입시켜 돌려주어, 메소드의 시그니챠를 <code>signature_ptr</code> 를 개입시켜 돌려줍니다.
        <p></p>
메소드의 시그니챠는 JNI 스펙으로 정의되고 있어<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>에서는<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#7035">메소드 기술자</a>로 불리고 있습니다. <i></i>「Java 언어 스펙」에 정의된 메소드의 시그니챠와는 다른 점에 주의해 주세요.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>64</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetMethodName.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      조회하는 메소드.
	    </td>
</tr>
<tr>
<td><code id="GetMethodName.name_ptr">name_ptr</code></td><td><code> char
	    
	  **</code></td><td>
	    돌아왔을 때, 메소드명 (<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다)을 포인트 한다.
	  <p></p>에이전트는 <code>char*</code> 에 포인터를 건네준다. <code>char*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>name_ptr</code> 가 <code>NULL</code> 의 경우, 이름은 돌려주어지지 않다.
</td>
</tr>
<tr>
<td><code id="GetMethodName.signature_ptr">signature_ptr</code></td><td><code> char
	    
	  **</code></td><td>
	    돌아왔을 때, 메소드시그니챠 (<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다)를 포인트 한다.
	  <p></p>에이전트는 <code>char*</code> 에 포인터를 건네준다. <code>char*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>signature_ptr</code> 가 <code>NULL</code> 의 경우, 시그니챠는 돌려주어지지 않다.
</td>
</tr>
<tr>
<td><code id="GetMethodName.generic_ptr">generic_ptr</code></td><td><code> char           
            
          **</code></td><td>
	    돌아왔을 때, 메소드의 총칭 시그니챠 (<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다)를 포인트 한다. 메소드의 총칭 시그니챠 속성이 존재하지 않는 경우는, 돌아왔을 때 <code>NULL</code> 를 포인트 한다.  
	  <p></p>에이전트는 <code>char*</code> 에 포인터를 건네준다. <code>char*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>generic_ptr</code> 가 <code>NULL</code> 의 경우, 총칭 시그니챠는 돌려주어지지 않다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#GetMethodName.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetMethodDeclaringClass">
<h3>메소드의 선언 클래스의 취득</h3>
<blockquote>
<pre>jvmtiError
GetMethodDeclaringClass(jvmtiEnv* env,
            jmethodID method,
            jclass* declaring_class_ptr)</pre>
</blockquote>
	<code>method</code> 로 지정된 메소드를 정의하는 클래스를,<code>declaring_class_ptr</code> 를 개입시켜 돌려줍니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>65</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetMethodDeclaringClass.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      조회하는 메소드.
	    </td>
</tr>
<tr>
<td><code id="GetMethodDeclaringClass.declaring_class_ptr">declaring_class_ptr</code></td><td><code><a href="#jclass">jclass</a> *</code></td><td>
	      돌아왔을 때, 선언하는 클래스를 포인트 한다.
	    <p></p>에이전트는 <code>jclass</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jclass</code> 가 설정되어 있다. <code>declaring_class_ptr</code> 로부터 반환되는 객체는 JNI 로컬 참조이며,<a href="#refs">관리</a>할 필요가 있다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#GetMethodDeclaringClass.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetMethodDeclaringClass.declaring_class_ptr"><code>declaring_class_ptr</code></a>  가 <code>NULL</code>.
	    
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetMethodModifiers">
<h3>메소드의 수식자의 취득</h3>
<blockquote>
<pre>jvmtiError
GetMethodModifiers(jvmtiEnv* env,
            jmethodID method,
            jint* modifiers_ptr)</pre>
</blockquote>
	<code>method</code> 로 지정된 메소드의 액세스 플래그를,<code>modifiers_ptr</code> 를 개입시켜 돌려줍니다. 액세스 플래그에 대해서는,<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html">「Class File Format」</a>의 장으로 정의되고 있습니다. <i></i>
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>66</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetMethodModifiers.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      조회하는 메소드.
	    </td>
</tr>
<tr>
<td><code id="GetMethodModifiers.modifiers_ptr">modifiers_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 액세스 플래그를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#GetMethodModifiers.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetMethodModifiers.modifiers_ptr"><code>modifiers_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetMaxLocals">
<h3>국소 변수의 취득</h3>
<blockquote>
<pre>jvmtiError
GetMaxLocals(jvmtiEnv* env,
            jmethodID method,
            jint* max_ptr)</pre>
</blockquote>
	  <code>method</code> 로 지정된 메소드에 의해 사용되는 국소 변수 (호출시에 메소드에 파라미터를 건네주기 위해서(때문에) 사용되는 국소 변수를 포함한다)의 슬롯수를 돌려줍니다.  
	  <p></p>
	  <a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#1546">「Code Attribute」</a>섹션의 <code>max_locals</code> 의 설명을 참조해 주세요. <i></i>
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>68</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetMaxLocals.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      조회하는 메소드.
	    </td>
</tr>
<tr>
<td><code id="GetMaxLocals.max_ptr">max_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 국소 변수의 슬롯의 최대수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#GetMaxLocals.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NATIVE_METHOD"><code>JVMTI_ERROR_NATIVE_METHOD</code></a> </td><td>
	  <a href="#GetMaxLocals.method"><code>method</code></a>  는 네이티브 메소드.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetMaxLocals.max_ptr"><code>max_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetArgumentsSize">
<h3>인수의 사이즈의 취득</h3>
<blockquote>
<pre>jvmtiError
GetArgumentsSize(jvmtiEnv* env,
            jmethodID method,
            jint* size_ptr)</pre>
</blockquote>
	<code>method</code> 로 지정된 메소드의 인수에 의해 사용되는 국소 변수의 슬롯수를,<code>max_ptr</code> 를 개입시켜 돌려줍니다. 덧붙여 2 워드의 인수는, 슬롯을 2 개 사용합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>69</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetArgumentsSize.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      조회하는 메소드.
	    </td>
</tr>
<tr>
<td><code id="GetArgumentsSize.size_ptr">size_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 인수의 슬롯의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#GetArgumentsSize.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NATIVE_METHOD"><code>JVMTI_ERROR_NATIVE_METHOD</code></a> </td><td>
	  <a href="#GetArgumentsSize.method"><code>method</code></a>  는 네이티브 메소드.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetArgumentsSize.size_ptr"><code>size_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetLineNumberTable">
<h3>행 번호 테이블의 취득</h3>
<blockquote>
<pre>typedef struct {
    jlocation start_location;
    jint line_number;
} jvmtiLineNumberEntry;</pre>
<pre>jvmtiError
GetLineNumberTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr)</pre>
</blockquote>
	<code>method</code> 로 지정된 메소드에 대해, 소스행 번호의 엔트리로부터 완성되는 테이블을 돌려줍니다. 테이블의 사이즈는 <code>entry_count_ptr</code>, 테이블 자체는 <code>table_ptr</code> 를 개입시켜 돌려주어집니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>70</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_line_numbers"><code>can_get_line_numbers</code></a> </td><td>
	  메소드의 행 번호 테이블을 취득할 수 있다
	</td>
</tr>
</table>
<p id="jvmtiLineNumberEntry"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiLineNumberEntry</code> - 행 번호 테이블의 엔트리</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiLineNumberEntry.start_location">start_location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	    행을 개시하는 <a href="#jlocation"><code>jlocation</code></a> 
	  </td>
</tr>
<tr>
<td><code id="jvmtiLineNumberEntry.line_number">line_number</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    행 번호
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetLineNumberTable.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      조회하는 메소드.
	    </td>
</tr>
<tr>
<td><code id="GetLineNumberTable.entry_count_ptr">entry_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 테이블내의 엔트리의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetLineNumberTable.table_ptr">table_ptr</code></td><td><code><a href="#jvmtiLineNumberEntry">jvmtiLineNumberEntry</a> **</code></td><td>
	    돌아왔을 때, 행 번호 테이블의 포인터를 포인트 한다.
	  <p></p>에이전트는 <code>jvmtiLineNumberEntry*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiLineNumberEntry*</code> 는, 사이즈 <code>*entry_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_line_numbers"><code>can_get_line_numbers</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a> </td><td> 
	  클래스의 정보에 행 번호가 포함되지 않았다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#GetLineNumberTable.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NATIVE_METHOD"><code>JVMTI_ERROR_NATIVE_METHOD</code></a> </td><td>
	  <a href="#GetLineNumberTable.method"><code>method</code></a>  는 네이티브 메소드.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetLineNumberTable.entry_count_ptr"><code>entry_count_ptr</code></a>  이 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetLineNumberTable.table_ptr"><code>table__ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetMethodLocation">
<h3>메소드의 배치 위치의 취득</h3>
<blockquote>
<pre>jvmtiError
GetMethodLocation(jvmtiEnv* env,
            jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr)</pre>
</blockquote>
	<code>method</code> 로 지정된 메소드에 대해, 그 개시 주소와 종료 주소를 <code>start_location_ptr</code> 와 <code>end_location_ptr</code> 를 개입시켜 돌려줍니다. 종래의 바이트 코드 인덱스 schema에서는,<code>start_location_ptr</code> 는 항상 제로를,<code>end_location_ptr</code> 는 항상 바이트 코드로부터 1 을 뺀 값을 포인트 합니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>71</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetMethodLocation.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      조회하는 메소드.
	    </td>
</tr>
<tr>
<td><code id="GetMethodLocation.start_location_ptr">start_location_ptr</code></td><td><code><a href="#jlocation">jlocation</a> *</code></td><td>
	    돌아왔을 때, 최초의 위치를 포인트 한다. 위치 정보를 얻을 수  없는 경우는 <code>-1</code> 을 포인트 한다. 정보의 사용이 가능해,<a href="#GetJLocationFormat"><code>GetJLocationFormat</code></a>  가 <a href="#JVMTI_JLOCATION_JVMBCI"><code>JVMTI_JLOCATION_JVMBCI</code></a>  를 돌려주는 경우, 항상 제로가 된다.
	  <p></p>에이전트는 <code>jlocation</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jlocation</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetMethodLocation.end_location_ptr">end_location_ptr</code></td><td><code><a href="#jlocation">jlocation</a> *</code></td><td>
	    돌아왔을 때, 마지막 위치를 포인트 한다. 위치 정보를 얻을 수  없는 경우는 <code>-1</code> 을 포인트 한다.
	  <p></p>에이전트는 <code>jlocation</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jlocation</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a> </td><td> 
	  클래스 정보에 메소드의 사이즈가 포함되지 않았다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#GetMethodLocation.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NATIVE_METHOD"><code>JVMTI_ERROR_NATIVE_METHOD</code></a> </td><td>
	  <a href="#GetMethodLocation.method"><code>method</code></a>  는 네이티브 메소드.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetMethodLocation.start_location_ptr"><code>start_location_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetMethodLocation.end_location_ptr"><code>end_location_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetLocalVariableTable">
<h3>국소 변수 테이블의 취득</h3>
<blockquote>
<pre>typedef struct {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
} jvmtiLocalVariableEntry;</pre>
<pre>jvmtiError
GetLocalVariableTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)</pre>
</blockquote>
	국소 변수의 정보를 돌려줍니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>72</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a> </td><td>
	  국소 변수를 설정해, 취득할 수 있다
	</td>
</tr>
</table>
<p id="jvmtiLocalVariableEntry"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiLocalVariableEntry</code> - 국소 변수 테이블의 엔트리</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiLocalVariableEntry.start_location">start_location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	    이 국소 변수가 처음 유효하게 되는 코드 배열 인덱스 (즉, 이 국소 변수는 거기서 값을 가지고 있지 않으면 안 된다).
	  </td>
</tr>
<tr>
<td><code id="jvmtiLocalVariableEntry.length">length</code></td><td><code><a href="#jint">jint</a> </code></td><td>
이 국소 변수의 유효 부분의 길이. 이 국소 변수가 유효하다 마지막 코드 배열 인덱스는,<code>start_location + length</code> 가 된다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiLocalVariableEntry.name">name</code></td><td><code>char *</code></td><td>
	    국소 변수명. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiLocalVariableEntry.signature">signature</code></td><td><code>char *</code></td><td>
	    국소 변수의 형태 시그니챠. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다. 이 시그니챠의 형식은,<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#14152">「Field Descriptors」</a>섹션으로 정의된 형식과 같게 된다. <i></i>
	  </td>
</tr>
<tr>
<td><code id="jvmtiLocalVariableEntry.generic_signature">generic_signature</code></td><td><code>char *</code></td><td>
	    국소 변수의 총칭 시그니챠. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다. 국소 변수가 총칭형을 가지지 않는 경우, 이 필드의 값은 <code>NULL</code>.
	  </td>
</tr>
<tr>
<td><code id="jvmtiLocalVariableEntry.slot">slot</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    국소 변수의 슬롯. <a href="#local">「국소 변수」</a>를 참조.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetLocalVariableTable.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      조회하는 메소드.
	    </td>
</tr>
<tr>
<td><code id="GetLocalVariableTable.entry_count_ptr">entry_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 테이블내의 엔트리의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetLocalVariableTable.table_ptr">table_ptr</code></td><td><code><a href="#jvmtiLocalVariableEntry">jvmtiLocalVariableEntry</a> **</code></td><td>
	    돌아왔을 때, 국소 변수 테이블의 엔트리의 배열을 포인트 한다.
	  <p></p>에이전트는 <code>jvmtiLocalVariableEntry*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiLocalVariableEntry*</code> 는, 사이즈 <code>*entry_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiLocalVariableEntry</code> 의 <code>name</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiLocalVariableEntry</code> 의 <code>signature</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiLocalVariableEntry</code> 의 <code>generic_signature</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a> </td><td>
	  클래스 정보에 국소 변수의 정보가 포함되지 않았다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#GetLocalVariableTable.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NATIVE_METHOD"><code>JVMTI_ERROR_NATIVE_METHOD</code></a> </td><td>
	  <a href="#GetLocalVariableTable.method"><code>method</code></a>  는 네이티브 메소드.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetLocalVariableTable.entry_count_ptr"><code>entry_count_ptr</code></a>  이 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetLocalVariableTable.table_ptr"><code>table__ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetBytecodes">
<h3>바이트 코드의 취득</h3>
<blockquote>
<pre>jvmtiError
GetBytecodes(jvmtiEnv* env,
            jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr)</pre>
</blockquote>
	<code>method</code> 로 지정된 메소드를 구현하는 바이트 코드를 돌려줍니다. 바이트 코드의 수는,<code>bytecode_count_ptr</code> 를 개입시켜 돌려주어집니다. 바이트 코드 자체는,<code>bytecodes_ptr</code> 를 개입시켜 돌려주어집니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>75</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_bytecodes"><code>can_get_bytecodes</code></a> </td><td>
	  메소드 <a href="#GetBytecodes"><code>GetBytecodes</code></a>  의 바이트 코드를 취득할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetBytecodes.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      조회하는 메소드.
	    </td>
</tr>
<tr>
<td><code id="GetBytecodes.bytecode_count_ptr">bytecode_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 바이트 코드의 배열의 길이를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetBytecodes.bytecodes_ptr">bytecodes_ptr</code></td><td><code>unsigned char**</code></td><td>
	    돌아왔을 때, 바이트 코드 배열에의 포인터를 포인트 한다.
	  <p></p>에이전트는 <code>unsigned char*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>unsigned char*</code> 는, 사이즈 <code>*bytecode_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_bytecodes"><code>can_get_bytecodes</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#GetBytecodes.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NATIVE_METHOD"><code>JVMTI_ERROR_NATIVE_METHOD</code></a> </td><td>
	  <a href="#GetBytecodes.method"><code>method</code></a>  는 네이티브 메소드.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetBytecodes.bytecode_count_ptr"><code>bytecode_count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetBytecodes.bytecodes_ptr"><code>bytecode_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="IsMethodNative">
<h3>네이티브 메소드인가 어떤가의 검사</h3>
<blockquote>
<pre>jvmtiError
IsMethodNative(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_native_ptr)</pre>
</blockquote>
	<code>method</code> 로 지정된 메소드가 네이티브 메소드인가 어떤가를 나타내는 값을,<code>is_native_ptr</code> 를 개입시켜 돌려줍니다.
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>76</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="IsMethodNative.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      조회하는 메소드.
	    </td>
</tr>
<tr>
<td><code id="IsMethodNative.is_native_ptr">is_native_ptr</code></td><td><code><a href="#jboolean">jboolean</a> *</code></td><td>
	    돌아왔을 때, 이 함수의 boolean 형의 결과를 포인트 한다.
	  <p></p>에이전트는 <code>jboolean</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jboolean</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#IsMethodNative.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#IsMethodNative.is_native_ptr"><code>is_native_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="IsMethodSynthetic">
<h3>합성 메소드인가 어떤가의 검사</h3>
<blockquote>
<pre>jvmtiError
IsMethodSynthetic(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_synthetic_ptr)</pre>
</blockquote>
	<code>method</code> 로 지정된 메소드가 합성 메소드인가 어떤가를 나타내는 값을,<code>is_synthetic_ptr</code> 를 개입시켜 돌려줍니다. 합성 메소드는, 컴파일러에 의해 생성됩니다만, 원의 원시 코드내에는 존재하지 않습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>77</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_synthetic_attribute"><code>can_get_synthetic_attribute</code></a> </td><td>
	  합성 필드 또는 합성 메소드일지 어떨지를 테스트할 수 있는 - <a href="#IsFieldSynthetic"><code>IsFieldSynthetic</code></a>  와 <a href="#IsMethodSynthetic"><code>IsMethodSynthetic</code></a> 
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="IsMethodSynthetic.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      조회하는 메소드.
	    </td>
</tr>
<tr>
<td><code id="IsMethodSynthetic.is_synthetic_ptr">is_synthetic_ptr</code></td><td><code><a href="#jboolean">jboolean</a> *</code></td><td>
	    돌아왔을 때, 이 함수의 boolean 형의 결과를 포인트 한다.
	  <p></p>에이전트는 <code>jboolean</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jboolean</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_synthetic_attribute"><code>can_get_synthetic_attribute</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#IsMethodSynthetic.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#IsMethodSynthetic.is_synthetic_ptr"><code>is_synthetic_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="IsMethodObsolete">
<h3>폐기된 메소드인가 어떤가의 검사</h3>
<blockquote>
<pre>jvmtiError
IsMethodObsolete(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_obsolete_ptr)</pre>
</blockquote>
메소드 ID 가<a href="#obsoleteMethods">폐지 </a>메소드 버젼을 참조하고 있을지 어떨지를 판정합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>91</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="IsMethodObsolete.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	      조회하는 메소드 ID.
	    </td>
</tr>
<tr>
<td><code id="IsMethodObsolete.is_obsolete_ptr">is_obsolete_ptr</code></td><td><code><a href="#jboolean">jboolean</a> *</code></td><td>
	    돌아왔을 때, 이 함수의 boolean 형의 결과를 포인트 한다.
	  <p></p>에이전트는 <code>jboolean</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jboolean</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a> </td><td>
	  <a href="#IsMethodObsolete.method"><code>method</code></a>  가 jmethodID 는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#IsMethodObsolete.is_obsolete_ptr"><code>is_obsolete_ptr</code></a>  이 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetNativeMethodPrefix">
<h3>네이티브 메소드 접두사의 설정</h3>
<blockquote>
<pre>jvmtiError
SetNativeMethodPrefix(jvmtiEnv* env,
            const char* prefix)</pre>
</blockquote>
	이 함수는, 이름에 접두사를 적용해 재시행할 수 있도록(듯이) 하는 것으로써, 네이티브 메소드 해결의 에러 처리를 변경합니다. 이것을 <a href="#ClassFileLoadHook">ClassFileLoadHook 이벤트</a>와 조합해 사용하면, 네이티브 메소드의<a href="#bci">계측</a>이 가능하게 됩니다.
        <p></p>
네이티브 메소드는 바이트 코드를 가지지 않기 때문에, 직접 계측 할 수 없습니다. 따라서, 계측 가능한 네이티브가 아닌 메소드로 네이티브 메소드를 랩 할 필요가 있습니다. 예를 들어, 다음과 같은 메소드가 있다고 합니다.
        <blockquote>
<pre>
native boolean foo(int x);</pre>
</blockquote>
        
<p></p>
이것이 다음과 같이 되도록(듯이), (ClassFileLoadHook 이벤트를 사용해) 클래스 파일을 변환할 수 있습니다.
        <blockquote>
<pre>
boolean foo(int x) {
  <i>... record entry to foo ...</i>
  return wrapped_foo(x);
}

native boolean wrapped_foo(int x);</pre>
</blockquote>
        
<p></p>
여기서, foo 는 실제의 네이티브 메소드의 래퍼로, 접두사 「wrapped_」가 부가되고 있습니다. 다만, 「wrapped_」는 기존의 메소드의 이름의 일부로서 사용되고 있을 가능성이 있기 (위해)때문에, 접두사로서는 좋은 선택사항이 아닙니다. 「$$$MyAgentWrapped$$$_」와 같은 접두사 쪽이 적절합니다만, 그렇다면 이 예가 읽기 어려워져 버립니다.
        <p></p>
이 래퍼를 사용하면, 네이티브 메소드의 호출시에 데이터를 수집할 수가 있습니다. 그런데 그 경우, 이 랩이 끝난 메소드를 네이티브 구현에 링크할 때에 문제가 생깁니다. 즉, 메소드 <code>wrapped_foo</code> 는, 다음과 같은 네이티브 구현 <code>foo</code> 에 해결할 필요가 있습니다.
        <blockquote>
<pre>
Java_somePackage_someClass_foo(JNIEnv* env, jint x)</pre>
</blockquote>
        
<p></p>
이 함수를 사용하면(자), 접두사를 지정해, 적절한 해결을 하도록(듯이) 할 수가 있습니다. 구체적으로는, 표준의 해결이 실패하면(자), 접두사를 고려해 해결이 재시행됩니다. 해결에는 2 개의 방법이 있습니다. JNI 함수 <code>RegisterNatives</code> 를 사용한 명시적인 해결과 일반적으로의 자동 해결입니다. <code>RegisterNatives</code> 의 경우, VM 는 다음이 관련짓고를 시도합니다.
        <blockquote>
<pre>
method(foo) -> nativeImplementation(foo)</pre>
</blockquote>
        
<p></p>
이것에 실패하면(자), 지정된 접두사를 메소드명의 선두에 추가해 해결이 재시행되어 다음과 같은 올바른 해결을 얻을 수 있습니다.
        <blockquote>
<pre>
method(wrapped_foo) -> nativeImplementation(foo)</pre>
</blockquote>
        
<p></p>
자동 해결의 경우, VM 는 다음을 시도합니다.
        <blockquote>
<pre>
method(wrapped_foo) -> nativeImplementation(wrapped_foo)</pre>
</blockquote>
        
<p></p>
이것에 실패하면(자), 지정된 접두사를 구현명으로부터 삭제해 해결이 재시행되어 다음의 올바른 해결을 얻을 수 있습니다.
        <blockquote>
<pre>
method(wrapped_foo) -> nativeImplementation(foo)</pre>
</blockquote>
        
<p></p>
접두사가 사용되는 것은 표준의 해결이 실패했을 경우만이므로, 네이티브 메소드의 랩은 선택적으로 실시할 수 있습니다.
        <p></p>
각 JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경은 독립하고 있어, 각각이 독자적인 바이트 코드 변환을 실시할 수 있기 (위해)때문에, 복수의 층의 래퍼가 적용될 가능성이 있습니다. 따라서, 환경 마다 다른 접두사가 필요하게 됩니다. 변환은 차례로 적용되기 (위해)때문에, 접두사를 적용하는 경우, 접두사는 변환과 같은 차례로 적용됩니다. 변환의 적용순서에 대해서는,<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>  이벤트를 참조해 주세요. 즉, 3 개의 환경이 래퍼를 적용했을 경우,<code>foo</code> 는 <code>$env3_$env2_$env1_foo</code> 와 같이 됩니다. 그러나, 예를 들어 2 번째의 환경이 <code>foo</code> 에 래퍼를 적용하지 않았던 경우는, 단지 <code>$env3_$env1_foo</code> 가 됩니다. 접두사의 순서를 효율적으로 결정할 수 있도록(듯이) 하기 위한(해), 도중의 접두사는, 그 네이티브가 아닌 래퍼가 존재하는 경우에게만 적용됩니다. 즉 이 예에서는,<code>$env1_foo</code> 가 네이티브 메소드가 아니어도,<code>$env1_foo</code> 가 존재하기 위해(때문에),<code>$env1_</code> 접두사가 적용됩니다.
        <p></p>
접두사는 해결시에 사용됩니다만, 그 해결은 언제라도 지연 될 가능성이 있습니다. 따라서, 네이티브 메소드의 접두사는, 대응하는 접두사 첨부의 네이티브 메소드가 존재하고 있는 한, 설정된 채로 해 둘 필요가 있습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
아니오
    </td><td>73</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_set_native_method_prefix"><code>can_set_native_method_prefix</code></a> </td><td>
	  네이티브 메소드를 해결할 수 없는 경우에 적용해야 할 접두사를 설정할 수 있는 - <a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>  및 <a href="#SetNativeMethodPrefixes"><code>SetNativeMethodPrefixes</code></a> 
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetNativeMethodPrefix.prefix">prefix</code></td><td><code>const char
	    
	  *</code></td><td>
	    적용하는 접두사. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다.
	  <p></p>에이전트는,<code>char</code> 의 배열을 건네준다. <code>prefix</code> 가 <code>NULL</code> 의 경우, 이 환경의 기존의 접두사가 삭제된다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_set_native_method_prefix"><code>can_set_native_method_prefix</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetNativeMethodPrefixes">
<h3>복수의 네이티브 메소드 접두사의 설정</h3>
<blockquote>
<pre>jvmtiError
SetNativeMethodPrefixes(jvmtiEnv* env,
            jint prefix_count,
            char** prefixes)</pre>
</blockquote>
	 일반적으로의 에이전트의 경우,<a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>  가, 네이티브 메소드의 접두사 설정에 필요하게 되는 모든 기능을 제공합니다. 복수의 독립한 클래스 파일 변환을 실행하는 메타에이젠트 (다른 층의 에이전트의 프록시로서의 에이전트등)의 경우, 이 함수를 사용하면(자), 각 변환에 독자적인 접두사를 할당할 수가 있습니다. 접두사는, 지정된 차례로 적용되어<a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>  로 설명한, 복수의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경으로부터의 접두사의 적용 방법과 같은 방법으로 처리됩니다.
         <p></p>
이전의 접두사는 모두 치환됩니다. 따라서,<a href="#SetNativeMethodPrefixes.prefix_count"><code>prefix_count</code></a>  에 <code>0</code> 을 지정해 이 함수를 호출하면(자), 이 환경의 접두사 기능이 무효가 됩니다.
         <p></p>
         
<a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>  곳의 함수가, 접두사를 설정하기 위한 2 개의 방법입니다. 1 개의 접두사를 지정해 <code>SetNativeMethodPrefix</code> 를 호출하는 것은,<a href="#SetNativeMethodPrefixes.prefix_count"><code>prefix_count</code></a>  에 <code>1</code> 을 지정해 이 함수를 호출하는 것과 같습니다. <code>NULL</code> 를 지정해 <code>SetNativeMethodPrefix</code> 를 호출하는 것은,<a href="#SetNativeMethodPrefixes.prefix_count"><code>prefix_count</code></a>  에 <code>0</code> 을 지정해 이 함수를 호출하는 것과 같습니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
아니오
    </td><td>74</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_set_native_method_prefix"><code>can_set_native_method_prefix</code></a> </td><td>
	  네이티브 메소드를 해결할 수 없는 경우에 적용해야 할 접두사를 설정할 수 있는 - <a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>  및 <a href="#SetNativeMethodPrefixes"><code>SetNativeMethodPrefixes</code></a> 
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetNativeMethodPrefixes.prefix_count">prefix_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	      적용하는 접두사의 수.
	    </td>
</tr>
<tr>
<td><code id="SetNativeMethodPrefixes.prefixes">prefixes</code></td><td><code>char**</code></td><td>
	    이 환경에서 적용하는 접두사. 각각 <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다.
	  <p></p>
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_set_native_method_prefix"><code>can_set_native_method_prefix</code></a>  을 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#SetNativeMethodPrefixes.prefix_count"><code>prefix_count</code></a>  가 <code>0</code> 보다 작다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#SetNativeMethodPrefixes.prefixes"><code>prefixes</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<p id="RawMonitors"></p>
<hr noshade="noshade" size="3">
<h2 align="center">raw 모니터</h2>raw 모니터 함수:
  <ul>
<li>
<a href="#CreateRawMonitor">raw 모니터의 작성</a> 
</li>
<li>
<a href="#DestroyRawMonitor">raw 모니터의 파기</a> 
</li>
<li>
<a href="#RawMonitorEnter">raw 모니터의 개시</a> 
</li>
<li>
<a href="#RawMonitorExit">raw 모니터의 종료</a> 
</li>
<li>
<a href="#RawMonitorWait">raw 모니터의 대기</a> 
</li>
<li>
<a href="#RawMonitorNotify">raw 모니터의 통지</a> 
</li>
<li>
<a href="#RawMonitorNotifyAll">raw 모니터의 통지 (모두)</a> 
</li>
</ul>
<p></p>
<hr noshade="noshade" width="100%" size="1" id="CreateRawMonitor">
<h3>raw 모니터의 작성</h3>
<blockquote>
<pre>jvmtiError
CreateRawMonitor(jvmtiEnv* env,
            const char* name,
            jrawMonitorID* monitor_ptr)</pre>
</blockquote>
	raw 모니터를 작성합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>31</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="CreateRawMonitor.name">name</code></td><td><code>const char*</code></td><td>
	    모니터를 식별하는 이름. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다.
	  <p></p>에이전트는,<code>char</code> 의 배열을 건네준다.  </td>
</tr>
<tr>
<td><code id="CreateRawMonitor.monitor_ptr">monitor_ptr</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a> *</code></td><td>
	    돌아왔을 때, 작성된 모니터를 포인트 한다.
	  <p></p>에이전트는 <code>jrawMonitorID</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jrawMonitorID</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#CreateRawMonitor.name"><code>name</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#CreateRawMonitor.monitor_ptr"><code>monitor_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="DestroyRawMonitor">
<h3>raw 모니터의 파기</h3>
<blockquote>
<pre>jvmtiError
DestroyRawMonitor(jvmtiEnv* env,
            jrawMonitorID monitor)</pre>
</blockquote>
	raw 모니터를 파기합니다. 파기되는 모니터가 이 thread에 의해 입력되었을 경우, 파기되기 전에 종료합니다. 파기되는 모니터가 다른 thread에 의해 입력되었을 경우, 에러가 돌려주어져 모니터의 파기는 행해지지 않습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>32</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="DestroyRawMonitor.monitor">monitor</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a> </code></td><td>
	    모니터
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_MONITOR_OWNER"><code>JVMTI_ERROR_NOT_MONITOR_OWNER</code></a> </td><td> 
	  모니터의 소유자는 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_MONITOR"><code>JVMTI_ERROR_INVALID_MONITOR</code></a> </td><td>
	  <a href="#DestroyRawMonitor.monitor"><code>monitor</code></a>  가 jrawMonitorID 는 아니다.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="RawMonitorEnter">
<h3>raw 모니터의 개시</h3>
<blockquote>
<pre>jvmtiError
RawMonitorEnter(jvmtiEnv* env,
            jrawMonitorID monitor)</pre>
</blockquote>
	raw 모니터의 배타적 소유권을 가져옵니다. 같은 thread로 여러 차례 모니터를 입력할 수가 있습니다. thread는, 모니터를 입력 회수분만큼<a href="#RawMonitorExit">종료</a>할 필요가 있습니다. 모니터가 <code>OnLoad</code> (접속된 thread가 생성되기 전)의 단계에서 입력되어 접속된 thread가 생성된 시점에서 종료하고 있지 않는 경우, 입력은 메인 thread로 행해졌다고 인식됩니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>33</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="RawMonitorEnter.monitor">monitor</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a> </code></td><td>
	    모니터
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_MONITOR"><code>JVMTI_ERROR_INVALID_MONITOR</code></a> </td><td>
	  <a href="#RawMonitorEnter.monitor"><code>monitor</code></a>  가 jrawMonitorID 는 아니다.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="RawMonitorExit">
<h3>raw 모니터의 종료</h3>
<blockquote>
<pre>jvmtiError
RawMonitorExit(jvmtiEnv* env,
            jrawMonitorID monitor)</pre>
</blockquote>
	raw 모니터의 배타적 소유권을 해제합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>34</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="RawMonitorExit.monitor">monitor</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a> </code></td><td>
	    모니터
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_MONITOR_OWNER"><code>JVMTI_ERROR_NOT_MONITOR_OWNER</code></a> </td><td> 
	  모니터의 소유자는 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_MONITOR"><code>JVMTI_ERROR_INVALID_MONITOR</code></a> </td><td>
	  <a href="#RawMonitorExit.monitor"><code>monitor</code></a>  가 jrawMonitorID 는 아니다.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="RawMonitorWait">
<h3>raw 모니터의 대기</h3>
<blockquote>
<pre>jvmtiError
RawMonitorWait(jvmtiEnv* env,
            jrawMonitorID monitor,
            jlong millis)</pre>
</blockquote>
raw 모니터의 통지를 기다립니다.
        <p></p>
다른 thread가 지정된 raw 모니터의 <a href="#RawMonitorNotify"><code>RawMonitorNotify</code></a>  또는 <a href="#RawMonitorNotifyAll"><code>RawMonitorNotifyAll</code></a>  를 호출하는지, 지정된 <a href="#RawMonitorWait.millis">timeout</a>  가 경과할 때까지, 현재의 thread를 대기시킵니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>35</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="RawMonitorWait.monitor">monitor</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a> </code></td><td>
	    모니터
	  </td>
</tr>
<tr>
<td><code id="RawMonitorWait.millis">millis</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    타임 아웃 (밀리 세컨드 단위). 타임 아웃이 제로의 경우, 실제의 시간은 고려되지 않고, thread는 단지 통지될 때까지 대기한다.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_MONITOR_OWNER"><code>JVMTI_ERROR_NOT_MONITOR_OWNER</code></a> </td><td> 
	  모니터의 소유자는 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INTERRUPT"><code>JVMTI_ERROR_INTERRUPT</code></a> </td><td> 
	  대기중에 인터럽트가 발생했기 때문에, 재시행의 필요 있어.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_MONITOR"><code>JVMTI_ERROR_INVALID_MONITOR</code></a> </td><td>
	  <a href="#RawMonitorWait.monitor"><code>monitor</code></a>  가 jrawMonitorID 는 아니다.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="RawMonitorNotify">
<h3>raw 모니터의 통지</h3>
<blockquote>
<pre>jvmtiError
RawMonitorNotify(jvmtiEnv* env,
            jrawMonitorID monitor)</pre>
</blockquote>
	raw 모니터를 대기중의 1 개의 thread에 통지합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>36</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="RawMonitorNotify.monitor">monitor</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a> </code></td><td>
	    모니터
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_MONITOR_OWNER"><code>JVMTI_ERROR_NOT_MONITOR_OWNER</code></a> </td><td>
	  모니터의 소유자는 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_MONITOR"><code>JVMTI_ERROR_INVALID_MONITOR</code></a> </td><td>
	  <a href="#RawMonitorNotify.monitor"><code>monitor</code></a>  가 jrawMonitorID 는 아니다.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="RawMonitorNotifyAll">
<h3>raw 모니터의 통지 (모두)</h3>
<blockquote>
<pre>jvmtiError
RawMonitorNotifyAll(jvmtiEnv* env,
            jrawMonitorID monitor)</pre>
</blockquote>
	raw 모니터를 대기중의 모든 thread에 통지합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>37</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="RawMonitorNotifyAll.monitor">monitor</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a> </code></td><td>
	    모니터
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_MONITOR_OWNER"><code>JVMTI_ERROR_NOT_MONITOR_OWNER</code></a> </td><td> 
	  모니터의 소유자는 아니다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_MONITOR"><code>JVMTI_ERROR_INVALID_MONITOR</code></a> </td><td>
	  <a href="#RawMonitorNotifyAll.monitor"><code>monitor</code></a>  가 jrawMonitorID 는 아니다.
	  
	</td>
</tr>
</table>
<p id="jniIntercept"></p>
<hr noshade="noshade" size="3">
<h2 align="center">JNI 함수의 차단</h2>JNI 함수의 차단 함수:
  <ul>
<li>
<a href="#SetJNIFunctionTable">JNI 함수 테이블의 설정</a> 
</li>
<li>
<a href="#GetJNIFunctionTable">JNI 함수 테이블의 취득</a> 
</li>
</ul>
Java Native Interface (JNI) 함수 테이블의 조작에 의해, JNI 함수 호출의 차단 및 재발송신의 기능을 제공합니다. 「Java Native Interface 스펙」의<a href="http://java.sun.com/javase/6/docs/guide/jni/spec/functions.html">「JNI 함수」</a>의 설명을 참조해 주세요. <i></i>
      <p></p>
다음에, 카운트 참조의 작성순서에 JNI 호출 <code>NewGlobalRef</code> 를 차단하는 예를 나타냅니다.
      <blockquote>
<pre>
JNIEnv original_jni_Functions;
JNIEnv redirected_jni_Functions;
int my_global_ref_count = 0;

jobject
MyNewGlobalRef(JNIEnv *jni_env, jobject lobj) {
   ++my_global_ref_count;
   return originalJNIFunctions->NewGlobalRef(env, lobj);
}

void
myInit() {
   jvmtiError err;

   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &original_jni_Functions);
   if (err ! = JVMTI_ERROR_NONE) {
      die();
   }
   err = (*jvmti_env)->GetJNIFunctionTable(jvmti_env, &redirected_jni_Functions);
   if (err ! = JVMTI_ERROR_NONE) {
      die();
   }
   redirectedJNIFunctions->NewGlobalRef = MyNewGlobalRef;
      err = (*jvmti_env)->SetJNIFunctionTable(jvmti_env, redirected_jni_Functions);
   if (err ! = JVMTI_ERROR_NONE) {
      die();
   }
}
      </pre>
</blockquote>
<code>myInit</code> 를 호출한 뒤, 사용자의 JNI 코드가 실행되어 새로운 글로벌 참조를 작성하는 호출을 하는 일이 있습니다. 이 호출은, 일반적으로의 JNI 구현은 아니고,<code>myNewGlobalRef</code> 에게 건네집니다. 데이터의 수집 후도 일반적으로의 JNI 함수를 호출할 수 있도록(듯이), 원의 함수 테이블의 카피는 보관 유지됩니다. 또, 덧쓰기되지 않는 JNI 함수의 동작은, 일반적으로 대로입니다.
      
    <p></p>
<hr noshade="noshade" width="100%" size="1" id="SetJNIFunctionTable">
<h3>JNI 함수 테이블의 설정</h3>
<blockquote>
<pre>jvmtiError
SetJNIFunctionTable(jvmtiEnv* env,
            const jniNativeInterface* function_table)</pre>
</blockquote>
현재 그리고 장래의 모든 JNI 환경의 JNI 함수 테이블을 설정합니다. 결과적으로, 장래 행해지는 모든 JNI 호출은, 지정의 함수에게 건네집니다. 이 함수에게 건네지는 함수 테이블을 가져오려면 ,<a href="#GetJNIFunctionTable"><code>GetJNIFunctionTable</code></a>  를 사용합니다. 이 함수가 유효하게 되기 위해서(때문에)는, JNI 클라이언트로, 갱신된 테이블 엔트리를 사용할 필요가 있습니다. 이 테이블은 <code>const</code> 로서 정의되기 (위해)때문에, 일부의 컴파일러는 이 테이블에의 액세스를 최적화할 가능성이 있습니다. 그 경우, 이 함수는 유효하게 되지 않습니다. 테이블의 카피가 작성됩니다. 테이블의 로컬 카피로 변경을 더해도, 원의 테이블에 영향은 없습니다. 이 함수는, 함수 테이블인 만큼 영향을 미칩니다. 환경의 그 외의 부분에는, 일절 영향을 미치지 않습니다. <a href="#jniIntercept">상기</a>의 예를 참조해 주세요.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>120</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetJNIFunctionTable.function_table">function_table</code></td><td><code>const <a href="#jniNativeInterface">jniNativeInterface</a>  *</code></td><td>
	    새로운 JNI 함수 테이블을 포인트 한다.
	  <p></p>에이전트는 <code>jniNativeInterface</code> 에 포인터를 건네준다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#SetJNIFunctionTable.function_table"><code>function_table</code></a>  이 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetJNIFunctionTable">
<h3>JNI 함수 테이블의 취득</h3>
<blockquote>
<pre>jvmtiError
GetJNIFunctionTable(jvmtiEnv* env,
            jniNativeInterface** function_table)</pre>
</blockquote>
JNI 함수 테이블을 가져옵니다. JNI 함수 테이블은, 할당할 수 있었던 메모리에 카피됩니다. <a href="#SetJNIFunctionTable"><code>SetJNIFunctionTable</code></a>  가 불려 갔을 경우, 변경된 함수 테이블 (원의 함수 테이블은 아니다)이 돌려주어집니다. 카피되는 것은 함수 테이블 뿐입니다. 환경의 그 외의 부분은 일절 카피되지 않습니다. <a href="#jniIntercept">상기</a>의 예를 참조해 주세요.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>121</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetJNIFunctionTable.function_table">function_table</code></td><td><code><a href="#jniNativeInterface">jniNativeInterface</a>  **</code></td><td>
	    돌아왔을 때,<code>*function_table</code> 는 새롭게 할당할 수 있었던 JNI 함수 테이블의 카피를 포인트 한다.
	  <p></p>에이전트는 <code>jniNativeInterface*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jniNativeInterface*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetJNIFunctionTable.function_table"><code>function_table</code></a>  이 <code>NULL</code>.
          
	</td>
</tr>
</table>
<p id="eventManagement"></p>
<hr noshade="noshade" size="3">
<h2 align="center">이벤트 관리</h2>이벤트 관리 함수:
  <ul>
<li>
<a href="#SetEventCallbacks">이벤트 콜백의 설정</a> 
</li>
<li>
<a href="#SetEventNotificationMode">이벤트 통지 모드의 설정</a> 
</li>
<li>
<a href="#GenerateEvents">이벤트의 생성</a> 
</li>
</ul>이벤트 관리의 형태:
    <ul>
<li>
<a href="#jvmtiEventMode"><code>jvmtiEventMode</code></a>  - 이벤트의 유효화와 무효화</li>
</ul>
<p></p>
<hr noshade="noshade" width="100%" size="1" id="SetEventCallbacks">
<h3>이벤트 콜백의 설정</h3>
<blockquote>
<pre>jvmtiError
SetEventCallbacks(jvmtiEnv* env,
            const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks)</pre>
</blockquote>
이벤트 마다 불려 가는 함수를 설정합니다. 대체 함수 테이블을 제공하는 것으로써, 콜백이 지정됩니다. 함수 테이블의 카피가 작성됩니다. 테이블의 로컬 카피로 변경을 더해도, 원의 테이블에 영향은 없습니다. 이것은 불가분인 처리입니다. 모든 콜백이 동시에 설정됩니다. 이 함수가 불려 갈 때까지, 이벤트는 송신되지 않습니다. 엔트리가 <code>NULL</code> 의 경우, 또는 이벤트가 <a href="#SetEventCallbacks.size_of_callbacks"><code>size_of_callbacks</code></a>  의 사이즈를 넘었을 경우, 이벤트의 송신은 행해지지 않습니다. 이벤트의 자세한 것은, 이 문서로<a href="#EventSection">후술 </a>합니다. 이벤트는, 유효해, 송신된 순서에 콜백을 가지고 있을 필요가 있습니다. 이 함수로 <a href="#SetEventNotificationMode"><code>SetEventNotificationMode</code></a>  가 불려 간 차례는, 결과에 영향을 미치지 않습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>122</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetEventCallbacks.callbacks">callbacks</code></td><td><code>const <a href="#jvmtiEventCallbacks">jvmtiEventCallbacks</a> 
	    
	  *</code></td><td>
	    새로운 이벤트 콜백.
	  <p></p>에이전트는 <code>jvmtiEventCallbacks</code> 에 포인터를 건네준다. <code>callbacks</code> 가 <code>NULL</code> 의 경우, 기존의 호출은 삭제된다.
</td>
</tr>
<tr>
<td><code id="SetEventCallbacks.size_of_callbacks">size_of_callbacks</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	    <code>sizeof(jvmtiEventCallbacks)</code>-- 버젼간의 호환성을 실현.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#SetEventCallbacks.size_of_callbacks"><code>size_of_callbacks</code></a>  가 <code>0</code> 보다 작다.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetEventNotificationMode">
<h3>이벤트 통지 모드의 설정</h3>
<blockquote>
<pre>
typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;</pre>
<pre>jvmtiError
SetEventNotificationMode(jvmtiEnv* env,
            jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...)</pre>
</blockquote>
	이벤트의 생성을 제어합니다.  
	<blockquote>
<a name="jvmtiEventMode"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">이벤트의 유효화와 무효화 (<code>jvmtiEventMode</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_ENABLE">JVMTI_ENABLE</code></td><td align="right">1</td><td>
	    <a href="#SetEventNotificationMode.mode"><code>mode</code></a>  가 <code>JVMTI_ENABLE</code> 의 경우, 이벤트 <a href="#SetEventNotificationMode.event_type"><code>event_type</code></a>  가 유효화 된다
	  </td>
</tr>
<tr>
<td><code id="JVMTI_DISABLE">JVMTI_DISABLE</code></td><td align="right">0</td><td>
	    <a href="#SetEventNotificationMode.mode"><code>mode</code></a>  가 <code>JVMTI_DISABLE</code> 의 경우, 이벤트 <a href="#SetEventNotificationMode.event_type"><code>event_type</code></a>  가 무효화된다
	  </td>
</tr>
</table>
</blockquote>
	<code>thread</code> 가 <code>NULL</code> 의 경우는, 이 이벤트는 글로벌하게 유효 또는 무효로 됩니다. 그렇지 않은 경우는, 특정의 thread에 대해 유효 또는 무효로 됩니다. 특정의 thread에 대해 이벤트가 생성되는 것은, 이벤트가 thread 레벨 또는 글로벌 레벨의 어느 쪽인지로 유효하게 되고 있는 경우입니다.  
	<p></p>
	개개의 이벤트에 대한 정보는,<a href="#EventIndex">후술 하는 설명</a>을 참조해 주세요.
	<p></p>
	다음의 이벤트는, 이 함수를 사용해 thread 레벨에서는 제어할 수 없습니다.  
	<ul type="disc">
	  
<li>
<a href="#VMInit"><code>VMInit</code></a> 
</li>
	  
<li>
<a href="#VMStart"><code>VMStart</code></a> 
</li>
	  
<li>
<a href="#VMDeath"><code>VMDeath</code></a> 
</li>
	  
<li>
<a href="#ThreadStart"><code>ThreadStart</code></a> 
</li>
	  
<li>
<a href="#CompiledMethodLoad"><code>CompiledMethodLoad</code></a> 
</li>
	  
<li>
<a href="#CompiledMethodUnload"><code>CompiledMethodUnload</code></a> 
</li>
	  
<li>
<a href="#DynamicCodeGenerated"><code>DynamicCodeGenerated</code></a> 
</li>
	  
<li>
<a href="#DataDumpRequest"><code>DataDumpRequest</code></a> 
</li>
	
</ul>
	
<p></p>
	처음은, thread 레벨로 유효하게 되고 있는 이벤트도, 글로벌 레벨로 유효하게 되고 있는 이벤트도 없습니다.
	<p></p>
이 함수를 호출하기 전에, 필요한 권한 (후술의 「이벤트를 유효화하는 권한」을 참조)을 소유하고 있을 필요가 있습니다.
        <p></p>
	이벤트의 상세한 것에 대하여는,<a href="#EventSection">후술 </a>합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>2</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
이벤트를 유효화하는 권한
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
      </td><td>
이벤트
      </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_modification_events"><code>can_generate_field_modification_events</code></a> </td><td><a href="#FieldModification"><code>FieldModification</code></a>  <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_access_events"><code>can_generate_field_access_events</code></a> </td><td><a href="#FieldAccess"><code>FieldAccess</code></a>  <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_single_step_events"><code>can_generate_single_step_events</code></a> </td><td><a href="#SingleStep"><code>SingleStep</code></a>  <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_exception_events"><code>can_generate_exception_events</code></a> </td><td><a href="#Exception"><code>Exception</code></a>  <br> <a href="#ExceptionCatch"><code>ExceptionCatch</code></a>  <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_frame_pop_events"><code>can_generate_frame_pop_events</code></a> </td><td><a href="#FramePop"><code>FramePop</code></a>  <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_breakpoint_events"><code>can_generate_breakpoint_events</code></a> </td><td><a href="#Breakpoint"><code>Breakpoint</code></a>  <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_method_entry_events"><code>can_generate_method_entry_events</code></a> </td><td><a href="#MethodEntry"><code>MethodEntry</code></a>  <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_method_exit_events"><code>can_generate_method_exit_events</code></a> </td><td><a href="#MethodExit"><code>MethodExit</code></a>  <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_compiled_method_load_events"><code>can_generate_compiled_method_load_events</code></a> </td><td><a href="#CompiledMethodLoad"><code>CompiledMethodLoad</code></a>  <br> <a href="#CompiledMethodUnload"><code>CompiledMethodUnload</code></a>  <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_monitor_events"><code>can_generate_monitor_events</code></a> </td><td><a href="#MonitorContendedEnter"><code>MonitorContendedEnter</code></a>  <br> <a href="#MonitorContendedEntered"><code>MonitorContendedEntered</code></a>  <br> <a href="#MonitorWait"><code>MonitorWait</code></a>  <br> <a href="#MonitorWaited"><code>MonitorWaited</code></a>  <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_vm_object_alloc_events"><code>can_generate_vm_object_alloc_events</code></a> </td><td><a href="#VMObjectAlloc"><code>VMObjectAlloc</code></a>  <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_native_method_bind_events"><code>can_generate_native_method_bind_events</code></a> </td><td><a href="#NativeMethodBind"><code>NativeMethodBind</code></a>  <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_garbage_collection_events"><code>can_generate_garbage_collection_events</code></a> </td><td><a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  <br> <a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_object_free_events"><code>can_generate_object_free_events</code></a> </td><td><a href="#ObjectFree"><code>ObjectFree</code></a>  <br>
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetEventNotificationMode.mode">mode</code></td><td><code><a href="#jvmtiEventMode">jvmtiEventMode</a> </code></td><td>
	    <code>JVMTI_ENABLE</code> 또는 <code>JVMTI_DISABLE</code>
	  </td>
</tr>
<tr>
<td><code id="SetEventNotificationMode.event_type">event_type</code></td><td><code><a href="#jvmtiEvent">jvmtiEvent</a> </code></td><td>
	    제어하는 이벤트
	  </td>
</tr>
<tr>
<td><code id="SetEventNotificationMode.event_thread">event_thread</code></td><td><code><a href="#jthread">jthread</a> 
	    
	  </code></td><td>
	      제어하는 thread
	    <p></p>
<code>event_thread</code> 가 <code>NULL</code> 의 경우, 이벤트는 글로벌 레벨로 제어된다.
</td>
</tr>
<tr>
<td><code id="SetEventNotificationMode....">...</code></td><td><code>...</code></td><td>
장래의 확장용
            </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
<a href="#SetEventNotificationMode.event_thread"><code>event_thread</code></a>  가 <code>NULL</code> 이외로, 유효한 thread가 아니다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
<a href="#SetEventNotificationMode.event_thread"><code>event_thread</code></a>  가 <code>NULL</code> 이외로, 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  thread 레벨의 제어가 허가되어 있지 않은 이벤트로, thread 레벨의 제어가 시행되었다.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td> 
필요한 이벤트를 유효화하는 권한을 가지고 있지 않다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#SetEventNotificationMode.mode"><code>mode</code></a>  가 jvmtiEventMode 는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_EVENT_TYPE"><code>JVMTI_ERROR_INVALID_EVENT_TYPE</code></a> </td><td>
	  <a href="#SetEventNotificationMode.event_type"><code>event_type</code></a>  가 jvmtiEvent 는 아니다.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GenerateEvents">
<h3>이벤트의 생성</h3>
<blockquote>
<pre>jvmtiError
GenerateEvents(jvmtiEnv* env,
            jvmtiEvent event_type)</pre>
</blockquote>
현재의 VM 의 상태를 나타내는 이벤트를 생성합니다. 예를 들어,<a href="#GenerateEvents.event_type"><code>event_type</code></a>  가 <code>JVMTI_EVENT_COMPILED_METHOD_LOAD</code> 의 경우, 최근 컴파일 된 각 메소드에 <a href="#CompiledMethodLoad"><code>CompiledMethodLoad</code></a>  이벤트가 송신됩니다. 로드 되고 나서, 아직 언로드되어 있지 않은 메소드는 송신되지 않습니다. 이전에 송신된 이벤트의 이력은, 이 함수에 의해 송신되는 이벤트에 영향을 미치지 않습니다. 예를 들어, 이 함수가 불려 갈 때마다, 최근 컴파일 된 모든 메소드가 송신됩니다.
        <p></p>
	에이전트가 프로그램의 실행 개시 후에 접속된 것에 의해, 이벤트가 없어졌을 경우는, 이 함수를 사용해 없어진 이벤트를 생성할 수 있습니다.
	<p></p>
	Java 프로그램 언어 코드 또는 JNI 함수의 실행은, 이 함수가 종료할 때까지 일시정지할 수가 있습니다. 그 때문에, 어느쪽이나 이벤트를 송신하는 thread로부터 불려 가지 않게 할 필요가 있습니다. 이 함수는, 없어진 이벤트가 송신되어 처리되어 종료할 때까지 종료하지 않습니다. 이벤트가, 발생원의 thread와는 다른 thread에 송신되는 일이 있습니다. 이벤트를 발생시키기 위해서(때문에)는,<a href="#SetEventCallbacks"><code>SetEventCallbacks</code></a>  로 이벤트의 콜백을 설정해,<a href="#SetEventNotificationMode"><code>SetEventNotificationMode</code></a>  로 이벤트를 유효하게 할 필요가 있습니다. 요구된 이벤트의 일부 또는 모든 것을 생성하기 위해서 필요한 정보가 VM 로부터 없어졌을 경우, 이벤트는 송신되지 않고, 에러도 돌려주어지지 않습니다.
	<p></p>
	지원되는 이벤트는 다음과 같습니다.
	<ul type="disc">
	  
<li>
<a href="#CompiledMethodLoad"><code>CompiledMethodLoad</code></a> 
</li>
	  
<li>
<a href="#DynamicCodeGenerated"><code>DynamicCodeGenerated</code></a> 
</li>
	
</ul>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>123</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
임의의 기능
        </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_compiled_method_load_events"><code>can_generate_compiled_method_load_events</code></a> </td><td>
	  메소드의 컴파일시 또는 언로드시에 이벤트를 생성할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GenerateEvents.event_type">event_type</code></td><td><code><a href="#jvmtiEvent">jvmtiEvent</a> </code></td><td>
	    생성하는 이벤트의 형태. 다음의 어느쪽이든으로 한다.
	    <ul type="disc">
	      
<li>
<a href="#CompiledMethodLoad"><code>JVMTI_EVENT_COMPILED_METHOD_LOAD</code></a> 
</li>
	      
<li>
<a href="#DynamicCodeGenerated"><code>JVMTI_EVENT_DYNAMIC_CODE_GENERATED</code></a> 
</li>
	    
</ul>
	  
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td> 
<a href="#GenerateEvents.event_type"><code>event_type</code></a>  가 <a href="#CompiledMethodLoad"><code>JVMTI_EVENT_COMPILED_METHOD_LOAD</code></a>  로,<a href="#jvmtiCapabilities.can_generate_compiled_method_load_events"><code>can_generate_compiled_method_load_events</code></a>  가 <code>false</code>.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td> 
<a href="#GenerateEvents.event_type"><code>event_type</code></a>  가 <a href="#CompiledMethodLoad"><code>JVMTI_EVENT_COMPILED_METHOD_LOAD</code></a>  도 <a href="#DynamicCodeGenerated"><code>JVMTI_EVENT_DYNAMIC_CODE_GENERATED</code></a>  도 아니다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_EVENT_TYPE"><code>JVMTI_ERROR_INVALID_EVENT_TYPE</code></a> </td><td>
	  <a href="#GenerateEvents.event_type"><code>event_type</code></a>  가 jvmtiEvent 는 아니다.
	  
	</td>
</tr>
</table>
<p id="extension"></p>
<hr noshade="noshade" size="3">
<h2 align="center">확장 기능 기구</h2>확장 기능 기구 함수:
  <ul>
<li>
<a href="#GetExtensionFunctions">확장 함수의 취득</a> 
</li>
<li>
<a href="#GetExtensionEvents">확장 이벤트의 취득</a> 
</li>
<li>
<a href="#SetExtensionEventCallback">확장 이벤트 콜백의 설정</a> 
</li>
</ul>확장 기능 기구의 함수형:
    <ul>
<li>
<a href="#jvmtiExtensionFunction">확장 함수</a> 
</li>
<li>
<a href="#jvmtiExtensionEvent">확장 이벤트</a> 
</li>
</ul>확장 기능 기구의 형태:
    <ul>
<li>
<a href="#jvmtiParamTypes"><code>jvmtiParamTypes</code></a>  - 확장 함수/이벤트 파라미터의 형태</li>
<li>
<a href="#jvmtiParamKind"><code>jvmtiParamKind</code></a>  - 확장 함수/이벤트 파라미터의 종류</li>
<li>
<a href="#jvmtiParamInfo"><code>jvmtiParamInfo</code></a>  - 확장 함수/이벤트 파라미터 정보</li>
<li>
<a href="#jvmtiExtensionFunctionInfo"><code>jvmtiExtensionFunctionInfo</code></a>  - 확장 함수 정보</li>
<li>
<a href="#jvmtiExtensionEventInfo"><code>jvmtiExtensionEventInfo</code></a>  - 확장 이벤트 정보</li>
</ul>
	JVM<small style="font-size: xx-small">&nbsp;</small>TI 구현은, 이러한 함수를 사용해, 이 스펙에 정의되어 있지 않은 함수 및 이벤트를 제공합니다.
	<p></p>
	확장 함수와 확장 이벤트의 파라미터는, 각각 다음의 겉(표)에 나타내는 「형태」와「종류」를 가집니다.

	<blockquote>
<a name="jvmtiParamTypes"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">확장 함수/이벤트 파라미터의 형태 (<code>jvmtiParamTypes</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JBYTE">JVMTI_TYPE_JBYTE</code></td><td align="right">101</td><td>
	    Java 프로그램 언어 원시형 - <code>byte</code>. JNI 형 <code>jbyte</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JCHAR">JVMTI_TYPE_JCHAR</code></td><td align="right">102</td><td>
	    Java 프로그램 언어 원시형 - <code>char</code>. JNI 형 <code>jchar</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JSHORT">JVMTI_TYPE_JSHORT</code></td><td align="right">103</td><td>
	    Java 프로그램 언어 원시형 - <code>short</code>. JNI 형 <code>jshort</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JINT">JVMTI_TYPE_JINT</code></td><td align="right">104</td><td>
	    Java 프로그램 언어 원시형 - <code>int</code>. JNI 형 <a href="#jint"><code>jint</code></a> .
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JLONG">JVMTI_TYPE_JLONG</code></td><td align="right">105</td><td>
	    Java 프로그램 언어 원시형 - <code>long</code>. JNI 형 <a href="#jlong"><code>jlong</code></a> .
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JFLOAT">JVMTI_TYPE_JFLOAT</code></td><td align="right">106</td><td>
	    Java 프로그램 언어 원시형 - <code>float</code>. JNI 형 <a href="#jfloat"><code>jfloat</code></a> .
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JDOUBLE">JVMTI_TYPE_JDOUBLE</code></td><td align="right">107</td><td>
	    Java 프로그램 언어 원시형 - <code>double</code>. JNI 형 <a href="#jdouble"><code>jdouble</code></a> .
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JBOOLEAN">JVMTI_TYPE_JBOOLEAN</code></td><td align="right">108</td><td>
	    Java 프로그램 언어 원시형 - <code>boolean</code>. JNI 형 <a href="#jboolean"><code>jboolean</code></a> .
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JOBJECT">JVMTI_TYPE_JOBJECT</code></td><td align="right">109</td><td>
	    Java 프로그램 언어 객체형 - <code>java.lang.Object</code>. JNI 형 <a href="#jobject"><code>jobject</code></a> . 반환값은 JNI 로컬 참조로, 관리 대상.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JTHREAD">JVMTI_TYPE_JTHREAD</code></td><td align="right">110</td><td>
	    Java 프로그램 언어 객체형 - <code>java.lang.Thread</code>. JVM<small style="font-size: xx-small">&nbsp;</small>TI 형 <a href="#jthread"><code>jthread</code></a> . 반환값은 JNI 로컬 참조로, 관리 대상.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JCLASS">JVMTI_TYPE_JCLASS</code></td><td align="right">111</td><td>
	    Java 프로그램 언어 객체형 - <code>java.lang.Class</code>. JNI 형 <a href="#jclass"><code>jclass</code></a> . 반환값은 JNI 로컬 참조로, 관리 대상.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JVALUE">JVMTI_TYPE_JVALUE</code></td><td align="right">112</td><td>
	    모든 Java 프로그램 언어 원시형 및 객체형의 화집합 - JNI 형 <a href="#jvalue"><code>jvalue</code></a> . 반환값은 객체형의 JNI 로컬 참조로, 관리 대상.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JFIELDID">JVMTI_TYPE_JFIELDID</code></td><td align="right">113</td><td>
	    Java 프로그램 언어 필드 식별자 - JNI 형 <a href="#jfieldID"><code>jfieldID</code></a> .
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JMETHODID">JVMTI_TYPE_JMETHODID</code></td><td align="right">114</td><td>
	    Java 프로그램 언어 메소드 식별자 - JNI 형 <a href="#jmethodID"><code>jmethodID</code></a> .
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_CCHAR">JVMTI_TYPE_CCHAR</code></td><td align="right">115</td><td>
	    C 프로그램 언어형 - <code>char</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_CVOID">JVMTI_TYPE_CVOID</code></td><td align="right">116</td><td>
	    C 프로그램 언어형 - <code>void</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JNIENV">JVMTI_TYPE_JNIENV</code></td><td align="right">117</td><td>
	    JNI 환경 <code>JNIEnv</code>. 포인터형으로 하려면 , 적절한 <a href="#jvmtiParamKind"><code>jvmtiParamKind</code></a>  와 함께 사용할 필요가 있다.
	  </td>
</tr>
</table>
</blockquote>

	
<blockquote>
<a name="jvmtiParamKind"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">확장 함수/이벤트 파라미터의 종류 (<code>jvmtiParamKind</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_IN">JVMTI_KIND_IN</code></td><td align="right">91</td><td>
	    입력 인수 - <code>foo</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_IN_PTR">JVMTI_KIND_IN_PTR</code></td><td align="right">92</td><td>
	    입력 포인터 인수 - <code>const foo*</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_IN_BUF">JVMTI_KIND_IN_BUF</code></td><td align="right">93</td><td>
	    입력 배열 인수 - <code>const foo*</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_ALLOC_BUF">JVMTI_KIND_ALLOC_BUF</code></td><td align="right">94</td><td>
	    할당하고가 끝난 출력 배열 인수 - <code>foo**</code>. <code>Deallocate</code> 로 해제.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_ALLOC_ALLOC_BUF">JVMTI_KIND_ALLOC_ALLOC_BUF</code></td><td align="right">95</td><td>
	    할당하고가 끝난 배열 인수의 할당이 끝난 출력 배열 - <code>foo***</code>. <code>Deallocate</code> 로 해제.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_OUT">JVMTI_KIND_OUT</code></td><td align="right">96</td><td>
	    출력 인수 - <code>foo*</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_OUT_BUF">JVMTI_KIND_OUT_BUF</code></td><td align="right">97</td><td>
	    출력 배열 인수 (에이전트에 의해 사전에 할당하고가 끝난) - <code>foo*</code>. <code>Deallocate</code> 는 불가.
	  </td>
</tr>
</table>
</blockquote>

      
<h4 id="jvmtiParamInfo">확장 함수/이벤트 파라미터 정보</h4>
<blockquote>
<pre>typedef struct {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
} jvmtiParamInfo;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiParamInfo</code> - 확장 함수/이벤트 파라미터 정보</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiParamInfo.name">name</code></td><td><code>char *</code></td><td>
	      파라미터명. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로 encode 된다.
	    </td>
</tr>
<tr>
<td><code id="jvmtiParamInfo.kind">kind</code></td><td><code><a href="#jvmtiParamKind">jvmtiParamKind</a> </code></td><td>
	    파라미터의 종류 - 형 수식자
	  </td>
</tr>
<tr>
<td><code id="jvmtiParamInfo.base_type">base_type</code></td><td><code><a href="#jvmtiParamTypes">jvmtiParamTypes</a> </code></td><td>
	    파라미터의 기저형 - <code>kind</code> 에 의해 변경이 끝난 상태.
	  </td>
</tr>
<tr>
<td><code id="jvmtiParamInfo.null_ok">null_ok</code></td><td><code><a href="#jboolean">jboolean</a> </code></td><td>
	      <code>NULL</code> 인수를 허가할까. 포인터형과 객체형에만 적용.
	    </td>
</tr>
</table>
</blockquote>
<p></p>
<hr noshade="noshade" width="100%" size="1" id="jvmtiExtensionFunction">
<h3>확장 함수</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env, 
      ...);</pre>
</blockquote>
	  구현 고유의 확장 함수입니다.
	<p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunction.jvmti_env">jvmti_env</code></td><td><code><a href="#jvmtiEnv">jvmtiEnv</a>  *</code></td><td>
	      JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경은, 확장 함수의 유일한 고정 파라미터.
	    </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunction....">...</code></td><td><code>...</code></td><td>
		확장 함수 고유의 파라미터.
	      </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetExtensionFunctions">
<h3>확장 함수의 취득</h3>
<blockquote>
<pre>typedef struct {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
} jvmtiExtensionFunctionInfo;</pre>
<pre>jvmtiError
GetExtensionFunctions(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions)</pre>
</blockquote>
	  확장 함수세트를 돌려줍니다.
	<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>124</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p id="jvmtiExtensionFunctionInfo"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiExtensionFunctionInfo</code> - 확장 함수 정보</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.func">func</code></td><td><code><a href="#jvmtiExtensionFunction">jvmtiExtensionFunction</a> </code></td><td>
	      불려 가는 실제의 함수
	    </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.id">id</code></td><td><code>char *</code></td><td>
		확장 함수의 식별자. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로 encode 된다. 패키지의 명명 규칙에 따른다. 예를 들어,<code>com.sun.hotspot.bar</code>
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.short_description">short_description</code></td><td><code>char *</code></td><td>
		함수를 1 문으로 설명. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로 encode 된다.
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.param_count">param_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
		<code>jvmtiEnv *jvmti_env</code> 를 제외하는 파라미터수
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.params">params</code></td><td><code><a href="#jvmtiParamInfo">jvmtiParamInfo</a>  *</code></td><td>
	      <a href="#jvmtiExtensionFunctionInfo.param_count"><code>param_count</code></a>  파라미터의 배열 (<code>jvmtiEnv *jvmti_env</code> 를 제외한다)
	    </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.error_count">error_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
		에러 반환값의 수 (범용 에러를 제외하다)
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.errors">errors</code></td><td><code><a href="#jvmtiError">jvmtiError</a> *</code></td><td>
	      <a href="#jvmtiExtensionFunctionInfo.error_count"><code>error_count</code></a>  의 에러의 배열
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetExtensionFunctions.extension_count_ptr">extension_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
		돌아왔을 때, 확장 함수의 수를 포인트 한다.
	      <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetExtensionFunctions.extensions">extensions</code></td><td><code><a href="#jvmtiExtensionFunctionInfo">jvmtiExtensionFunctionInfo</a> **</code></td><td>
	      확장 함수 정보의 배열을, 함수 마다 1 개(살)씩 돌려준다.
	    <p></p>에이전트는 <code>jvmtiExtensionFunctionInfo*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiExtensionFunctionInfo*</code> 는, 사이즈 <code>*extension_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiExtensionFunctionInfo</code> 의 <code>id</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiExtensionFunctionInfo</code> 의 <code>short_description</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiExtensionFunctionInfo</code> 의 <code>params</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiParamInfo</code> 의 <code>name</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiExtensionFunctionInfo</code> 의 <code>errors</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	    <a href="#GetExtensionFunctions.extension_count_ptr"><code>extension_count_ptr</code></a>  가 <code>NULL</code>.
	      
	  </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	    <a href="#GetExtensionFunctions.extensions"><code>extensions</code></a>  가 <code>NULL</code>.
	    
	  </td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetExtensionEvents">
<h3>확장 이벤트의 취득</h3>
<blockquote>
<pre>typedef struct {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
} jvmtiExtensionEventInfo;</pre>
<pre>jvmtiError
GetExtensionEvents(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions)</pre>
</blockquote>
	  확장 이벤트세트를 돌려줍니다.
	<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>125</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p id="jvmtiExtensionEventInfo"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiExtensionEventInfo</code> - 확장 이벤트 정보</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEventInfo.extension_event_index">extension_event_index</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	      이벤트를 식별하는 인덱스
	    </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEventInfo.id">id</code></td><td><code>char *</code></td><td>
		확장 이벤트의 식별자. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다. 패키지의 명명 규칙에 따른다. 예를 들어,<code>com.sun.hotspot.bar</code>
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEventInfo.short_description">short_description</code></td><td><code>char *</code></td><td>
		이벤트를 1 문으로 설명. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다.
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEventInfo.param_count">param_count</code></td><td><code><a href="#jint">jint</a> </code></td><td>
		<code>jvmtiEnv *jvmti_env</code> 를 제외하는 파라미터수
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEventInfo.params">params</code></td><td><code><a href="#jvmtiParamInfo">jvmtiParamInfo</a>  *</code></td><td>
	      <a href="#jvmtiExtensionEventInfo.param_count"><code>param_count</code></a>  파라미터의 배열 (<code>jvmtiEnv *jvmti_env</code> 를 제외한다)
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetExtensionEvents.extension_count_ptr">extension_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
		돌아왔을 때, 확장 이벤트의 수를 포인트 한다.
	      <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetExtensionEvents.extensions">extensions</code></td><td><code><a href="#jvmtiExtensionEventInfo">jvmtiExtensionEventInfo</a> **</code></td><td>
	      확장 이벤트 정보의 배열을, 이벤트 마다 1 개(살)씩 돌려준다.
	    <p></p>에이전트는 <code>jvmtiExtensionEventInfo*</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiExtensionEventInfo*</code> 는, 사이즈 <code>*extension_count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiExtensionEventInfo</code> 의 <code>id</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiExtensionEventInfo</code> 의 <code>short_description</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiExtensionEventInfo</code> 의 <code>params</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. <code>jvmtiParamInfo</code> 의 <code>name</code> 필드에 반환되는 포인터는, 새롭게 할당할 수 있었던 배열. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	    <a href="#GetExtensionEvents.extension_count_ptr"><code>extension_count_ptr</code></a>  가 <code>NULL</code>.
	      
	  </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	    <a href="#GetExtensionEvents.extensions"><code>extensions</code></a>  가 <code>NULL</code>.
	    
	  </td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="jvmtiExtensionEvent">
<h3>확장 이벤트</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env, 
      ...);</pre>
</blockquote>
	  구현 고유의 이벤트입니다. 이벤트 핸들러의 설정에는,<a href="#SetExtensionEventCallback"><code>SetExtensionEventCallback</code></a>  를 사용합니다.
          <p></p>
확장 이벤트의 이벤트 핸들러는, 이 정의에 일치하는 것 같은 선언형의 가변 인수가 아니면 안됩니다. 선언형의 가변 인수가 아닌 경우, 일부의 플랫폼에서, 일치하지 않는 규약의 호출이나 미정도리의 동작이 발생할 가능성이 있습니다.
          <p></p>
예를 들어,<a href="#GetExtensionEvents"><code>GetExtensionEvents</code></a>  로부터 반환된 <code>jvmtiParamInfo</code> 에,<code>jint</code> 파라미터의 존재가 나타나고 있는 경우, 이벤트 핸들러를 다음과 같이 선언할 필요가 있습니다.
<blockquote>
<pre>
    void JNICALL myHandler(jvmtiEnv* jvmti_env, jint myInt, ...)
</pre>
</blockquote>
<code>...</code>」(은)는 가변 인수를 나타냅니다.
	<p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEvent.jvmti_env">jvmti_env</code></td><td><code><a href="#jvmtiEnv">jvmtiEnv</a>  *</code></td><td>
	      JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경은, 확장 이벤트의 유일한 고정 파라미터.
	    </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEvent....">...</code></td><td><code>...</code></td><td>
		확장 이벤트 고유의 파라미터
	      </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetExtensionEventCallback">
<h3>확장 이벤트 콜백의 설정</h3>
<blockquote>
<pre>jvmtiError
SetExtensionEventCallback(jvmtiEnv* env,
            jint extension_event_index,
            jvmtiExtensionEvent callback)</pre>
</blockquote>
	  확장 이벤트에 콜백 함수를 설정해, 이벤트를 유효하게 합니다. 콜백이 <code>NULL</code> 의 경우, 이벤트를 무효로 합니다. 표준 이벤트와는 달라, 콜백을 설정해 이벤트를 유효하게 하는 처리는 단일의 조작입니다.
	<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>126</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetExtensionEventCallback.extension_event_index">extension_event_index</code></td><td><code><a href="#jint">jint</a> </code></td><td>
		설정하는 콜백을 식별한다. 이 인덱스는,<a href="#jvmtiExtensionEventInfo"><code>jvmtiExtensionEventInfo</code></a>  의 <a href="#jvmtiExtensionEventInfo.extension_event_index"><code>extension_event_index</code></a>  필드.
	      </td>
</tr>
<tr>
<td><code id="SetExtensionEventCallback.callback">callback</code></td><td><code><a href="#jvmtiExtensionEvent">jvmtiExtensionEvent</a> 
	      
	    </code></td><td>
	      <code>callback</code> 가 <code>NULL</code> 이외의 경우,<code>callback</code> 를 이벤트 콜백 함수로 설정해, 이벤트를 유효하게 한다.
	    <p></p>
<code>callback</code> 가 <code>NULL</code> 의 경우, 이벤트를 무효로 한다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td> 
<a href="#SetExtensionEventCallback.extension_event_index"><code>extension_event_index</code></a>  가 <a href="#GetExtensionEvents"><code>GetExtensionEvents</code></a>  로부터 반환된 <a href="#jvmtiExtensionEventInfo.extension_event_index"><code>extension_event_index</code></a>  이 아니다.
        </td>
</tr>
</table>
<p id="capability"></p>
<hr noshade="noshade" size="3">
<h2 align="center">권한</h2>권한 함수:
  <ul>
<li>
<a href="#GetPotentialCapabilities">잠재적인 권한의 취득</a> 
</li>
<li>
<a href="#AddCapabilities">권한의 추가</a> 
</li>
<li>
<a href="#RelinquishCapabilities">권한의 방폐</a> 
</li>
<li>
<a href="#GetCapabilities">기능의 취득</a> 
</li>
</ul>권한의 형태:
    <ul>
<li>
<a href="#jvmtiCapabilities"><code>jvmtiCapabilities</code></a>  - 권한의 구조체</li>
</ul>
권한 함수에서는, JVM<small style="font-size: xx-small">&nbsp;</small>TI 를 사용할 수 있는 기능 (어느 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수를 호출할 수 있는지, 어떤 이벤트를 생성할 수 있는지, 이러한 이벤트나 함수가 어떤 기능을 제공할 수 있을까 등)을 변경할 수 있습니다.
      <p></p>
각 함수 및 이벤트의 「권한」의 섹션에는, 관련지을 수 있고 있는 권한의 설명이 기재되어 있습니다 (존재하는 경우). 「필요한 기능」은, 사용 가능하고, 권한을 추가하지 않아도 사용할 수 있는 것을 나타내고 있습니다. 「임의의 기능」은, 사용하기 위해서는 에이전트에 권한이 필요한 것을 나타내고 있습니다. 권한을 가지기 위해서(때문에)는, 에이전트는<a href="#AddCapabilities">권한을 추가</a>할 필요가 있습니다. 「임의의 기능」에는, 기능 세트를 확장하는 권한의 설명이 기재되어 있습니다.
        <p></p>
각 JVM<small style="font-size: xx-small">&nbsp;</small>TI 구현을 잠재적으로 사용할 수 있는 권한은 다릅니다. 구현에 의해, 다음과 같은 일을 말할 수 있습니다.
        <ul type="disc">
          
<li>결코 추가해서는 안 되는 권한이 있다</li>
          
<li>모든 환경에서, 어느 권한을 <code>OnLoad</code> 또는 라이브 단계에서 추가할 수 있다</li>
          
<li>어느 권한을 <code>OnLoad</code> 단계에서 밖에 추가할 수 없다</li>
          
<li>어느 권한을 복수의 환경에서 동시에 소유할 수 없다</li>
          
<li>어느 권한을 복수의 환경에서 동시에 소유할 수 없다. 또,<code>OnLoad</code> 단계에서 밖에 소유할 수 없다</li>
          
<li>그 외</li>
        
</ul>
자주, 권한을 추가하는 것에 의해, 실행 속도, 기동 시간, 메모리 사용량(footprint) 등에 영향이 나오는 일이 있습니다. 권한을 사용하는 오버헤드는, 권한을 소유하는 오버헤드와는 완전히 다른 점에 주의해 주세요. 예로서 스텝 실행에 대해 생각해 봅시다. 스텝 실행이 유효한 경우는 (이벤트가 유효해, 액티브하게 이벤트를 송신하고 있는 상태), 어느 구현에서도, 각 명령으로 이벤트를 송신해, 처리하는 오버헤드가 커집니다. 한편, 권한을 소유하는 오버헤드는, 구현에 의해 크기도 하고 작거나 합니다. 또, 권한을 잠재적으로 사용할 수 있을지 어떨지도, 구현에 따라서 다릅니다. 사용예를 다음에 나타냅니다.
      <ul type="disc">
	
<li>어느 VM 는, 바이트 코드를 native code에 컴파일 하는 것에 의해 모든 것을 실행해, 스텝 실행 명령을 생성할 수 없게 되고 있다. 이 구현에서는, 권한은 추가할 수 없다. </li>
	
<li>다른 VM 는, 실행을 스텝 실행 interpreter에 언제라도 교체된다. 이 구현에서는, 권한을 소유하는 것으로 오버헤드는 생기지 않고, 권한은 언제라도 추가할 수 있다. </li>
	
<li>한층 더 다른 VM 는, 바이트 코드의 컴파일 또는 스텝 실행 가능한 해석이 끝난 실행 엔진을 기동시에 선택할 수 있지만, 이것들을 바꿀 수 없다. 이 구현에서는,<code>OnLoad</code> 단계 (바이트 코드의 실행을 개시하기 전)에서 권한을 추가할 필요가 있다.  스텝 실행을 사용했던 적이 없는 경우에서도, 실행 속도에는 상당한 영향이 있다. </li>
	
<li>한층 더 다른 VM 는, 컴파일이 끝난 바이트 코드 또는 생성이 끝난 interpreter에 [is single stepping on] 체크를 추가할 수 있다. 이 구현에서도,<code>OnLoad</code> 단계에서 권한을 추가할 필요가 있지만, 오버헤드 ( 각 명령의 테스트와 브랜치(branch))는 꽤 낮아진다. </li>
      
</ul>
      
<p></p>
JVM<small style="font-size: xx-small">&nbsp;</small>TI <a href="#environments">환경 </a>마다, 고유의 권한 세트가 있습니다. 최초, 이 세트는 빈 상태(empty)입니다. 필요한 권한이 있으면, 추가합니다. 가능하면, 권한은 <code>OnLoad</code> 단계에서 추가합니다. 대부분의 가상 머신에서는, 특정의 권한에는, 가상 머신용의 특별한 설정이 필요합니다. 이 설정은, 가상 머신의 실행을 개시하기 전에,<code>OnLoad</code> 단계에서 실시할 필요가 있습니다. 추가한 권한을 삭제할 수 있는 것은, 환경에 의해 명시적으로 방폐되었을 경우만입니다.
      <p></p>
에이전트는,<a href="#GetPotentialCapabilities">이 VM 를 잠재적으로 제공할 수 있는 권한을 특정해</a>,<a href="#AddCapabilities">사용하는 권한을 추가해</a>,<a href="#RelinquishCapabilities">불필요하게 된 권한을 해제해</a>,<a href="#GetCapabilities">현재 사용 가능한 권한을 조사할 수가 </a>있습니다.
<h4 id="capabilityExamples">권한의 예</h4>
예를 들어,<code>OnLoad</code> 함수로 신규에 기동한 에이전트로, 사용 가능한 모든 권한을 유효하게 하는 경우가 있습니다. 사용하고 있지 않는 기능에 의해 에이전트의 퍼포먼스가 저감 할 가능성이 있기 (위해)때문에, 일반적으로 이 설정은 추천하지 않습니다. 다음에, C 로 기술한 코드예를 나타냅니다.
      <blockquote>
<pre>
	jvmtiCapabilities capa;
	jvmtiError err;

	err = (*jvmti)->GetPotentialCapabilities(jvmti, &capa);
	if (err == JVMTI_ERROR_NONE) {
	   err = (*jvmti)->AddCapabilities(jvmti, &capa);
      </pre>
</blockquote>
예를 들어, 에이전트로, 메소드의 바이트 코드를 취득할 수 있을지 어떨지 체크하는 경우 (이전에 이 권한을 추가해, 아직 방폐하고 있지 않는지 어떤지를 체크하는 경우), C 로 기술한 코드는 다음과 같이 됩니다.
      <blockquote>
<pre>
	jvmtiCapabilities capa;
	jvmtiError err;

	err = (*jvmti)->GetCapabilities(jvmti, &capa);
	if (err == JVMTI_ERROR_NONE) {
   	   if (capa.can_get_bytecodes) { ... } } 
      </pre>
</blockquote>
    
<h4 id="jvmtiCapabilities">권한의 구조체</h4>
이 카테고리에 포함되는 함수는, 다음의 권한 구조체를 사용합니다. 이 구조체에는, 각 권한으로 대응하는 불형 플래그가 포함되어 있습니다.
      <p></p>
<blockquote>
<blockquote>
<pre>typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int : 7;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;</pre>
</blockquote>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiCapabilities</code> - 권한의 구조체</td>
</tr>
<tr bgcolor="#EEEEFF">
<td colspan="3">
모든 형태는 <code>unsigned int : 1</code></td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
설명
</td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td><code>can_tag_objects</code></td><td><a name="jvmtiCapabilities.can_tag_objects"></a> <a href="#Heap">heap의 카테고리</a>에 설명되고 있도록(듯이), 태그를 설정해, 취득할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate_field_modification_events</code></td><td><a name="jvmtiCapabilities.can_generate_field_modification_events"></a> 필드의 변경에 감시 포인트를 설정할 수 있는 - <a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a> 
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate_field_access_events</code></td><td><a name="jvmtiCapabilities.can_generate_field_access_events"></a> 필드 액세스에 감시 포인트를 설정할 수 있는 - <a href="#SetFieldAccessWatch"><code>SetFieldAccessWatch</code></a> 
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_bytecodes</code></td><td><a name="jvmtiCapabilities.can_get_bytecodes"></a> 메소드 <a href="#GetBytecodes"><code>GetBytecodes</code></a>  의 바이트 코드를 취득할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_synthetic_attribute</code></td><td><a name="jvmtiCapabilities.can_get_synthetic_attribute"></a> 합성 필드 또는 합성 메소드일지 어떨지를 테스트할 수 있는 - <a href="#IsFieldSynthetic"><code>IsFieldSynthetic</code></a>  와 <a href="#IsMethodSynthetic"><code>IsMethodSynthetic</code></a> 
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_owned_monitor_info</code></td><td><a name="jvmtiCapabilities.can_get_owned_monitor_info"></a> 모니터의 소유에 관한 정보를 취득할 수 있는 - <a href="#GetOwnedMonitorInfo"><code>GetOwnedMonitorInfo</code></a> 
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_current_contended_monitor</code></td><td><a name="jvmtiCapabilities.can_get_current_contended_monitor"></a> <a href="#GetCurrentContendedMonitor"><code>GetCurrentContendedMonitor</code></a>  를 실행할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_monitor_info</code></td><td><a name="jvmtiCapabilities.can_get_monitor_info"></a> <a href="#GetObjectMonitorUsage"><code>GetObjectMonitorUsage</code></a>  를 실행할 수 있다.
      </td><td>1.0</td>
</tr>
<tr>
<td><code>can_pop_frame</code></td><td><a name="jvmtiCapabilities.can_pop_frame"></a> 스택으로부터 프레임을 팝 할 수 있는 - <a href="#PopFrame"><code>PopFrame</code></a> 
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_redefine_classes</code></td><td><a name="jvmtiCapabilities.can_redefine_classes"></a> <a href="#RedefineClasses"><code>RedefineClasses</code></a>  로 클래스를 재정의할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_signal_thread</code></td><td><a name="jvmtiCapabilities.can_signal_thread"></a> thread에 정지 또는 끼어들어 신호를 송신할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_source_file_name</code></td><td><a name="jvmtiCapabilities.can_get_source_file_name"></a> 클래스의 원시 파일의 이름을 취득할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_line_numbers</code></td><td><a name="jvmtiCapabilities.can_get_line_numbers"></a> 메소드의 행 번호 테이블을 취득할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_source_debug_extension</code></td><td><a name="jvmtiCapabilities.can_get_source_debug_extension"></a> 클래스의 소스 디버그 확장 기능을 취득할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_access_local_variables</code></td><td><a name="jvmtiCapabilities.can_access_local_variables"></a> 국소 변수를 설정해, 취득할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_maintain_original_method_order</code></td><td><a name="jvmtiCapabilities.can_maintain_original_method_order"></a> 클래스 파일내에 출현하는 순서로 메소드를 돌려줄 수가 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate_single_step_events</code></td><td><a name="jvmtiCapabilities.can_generate_single_step_events"></a> <a href="#SingleStep">스텝 실행 </a>이벤트를 취득할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate_exception_events</code></td><td><a name="jvmtiCapabilities.can_generate_exception_events"></a> <a href="#Exception">throw 된 예외</a>와<a href="#ExceptionCatch">예외 캐치 </a>이벤트를 취득할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate_frame_pop_events</code></td><td><a name="jvmtiCapabilities.can_generate_frame_pop_events"></a> <a href="#FramePop"><code>FramePop</code></a>  이벤트를<a href="#NotifyFramePop">설정</a>해, 취득할 수가 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate_breakpoint_events</code></td><td><a name="jvmtiCapabilities.can_generate_breakpoint_events"></a> <a href="#Breakpoint"><code>Breakpoint</code></a>  이벤트를<a href="#SetBreakpoint">설정</a>해, 취득할 수가 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_suspend</code></td><td><a name="jvmtiCapabilities.can_suspend"></a> thread를 중단해, 재개할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_redefine_any_class</code></td><td><a name="jvmtiCapabilities.can_redefine_any_class"></a>  프리미티브(primitive) 클래스에서도 배열 클래스도 아닌 임의의 클래스를 변경 (재변환 또는 재정의)할 수 있다. <a href="#IsModifiableClass"><code>IsModifiableClass</code></a>  를 참조.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_current_thread_cpu_time</code></td><td><a name="jvmtiCapabilities.can_get_current_thread_cpu_time"></a>  현재의 thread CPU 시간을<a href="#GetCurrentThreadCpuTime">취득</a>할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_thread_cpu_time</code></td><td><a name="jvmtiCapabilities.can_get_thread_cpu_time"></a>  thread CPU 시간을<a href="#GetThreadCpuTime">취득</a>할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br> _method_entry_events</code></td><td><a name="jvmtiCapabilities.can_generate_method_entry_events"></a>  메소드의 입력시에 메소드 입력 이벤트를 생성할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br> _method_exit_events</code></td><td><a name="jvmtiCapabilities.can_generate_method_exit_events"></a>  메소드의 종료시에 메소드 종료 이벤트를 생성할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br> _all_class_hook_events</code></td><td><a name="jvmtiCapabilities.can_generate_all_class_hook_events"></a>  로드 된 모든 클래스에 대해서, ClassFileLoadHook 이벤트를 생성할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br> _compiled_method_load_events</code></td><td><a name="jvmtiCapabilities.can_generate_compiled_method_load_events"></a> 메소드의 컴파일시 또는 언로드시에 이벤트를 생성할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br> _monitor_events</code></td><td><a name="jvmtiCapabilities.can_generate_monitor_events"></a>  모니터의 사용율에 관한 이벤트를 생성할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br> _vm_object_alloc_events</code></td><td><a name="jvmtiCapabilities.can_generate_vm_object_alloc_events"></a>  객체의 VM 할당해에 관한 이벤트를 생성할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br> _native_method_bind_events</code></td><td><a name="jvmtiCapabilities.can_generate_native_method_bind_events"></a>  네이티브 메소드가 구현에 바인드 되고 있을 때 이벤트를 생성할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br> _garbage_collection_events</code></td><td><a name="jvmtiCapabilities.can_generate_garbage_collection_events"></a>  가베지 컬렉션의 개시 또는 종료시에 이벤트를 생성할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br> _object_free_events</code></td><td><a name="jvmtiCapabilities.can_generate_object_free_events"></a>  가비지 컬렉터가 객체를 해제할 경우에 이벤트를 생성할 수 있다.
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_force_early_return</code></td><td><a name="jvmtiCapabilities.can_force_early_return"></a>  <a href="#ForceEarlyReturn">조기 복귀의 강제의 카테고리</a>로 설명하고 있도록(듯이), 메소드로부터 조기 복귀할 수 있다.
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_get_owned_monitor_stack_depth_info</code></td><td><a name="jvmtiCapabilities.can_get_owned_monitor_stack_depth_info"></a>  소유되고 있는 모니터에 관한 정보와 스택의 깊이를 취득할 수 있는 - <a href="#GetOwnedMonitorStackDepthInfo"><code>GetOwnedMonitorStackDepthInfo</code></a> 
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_get_constant_pool</code></td><td><a name="jvmtiCapabilities.can_get_constant_pool"></a>  있는 클래스의 정수 풀을 취득할 수 있는 - <a href="#GetConstantPool"><code>GetConstantPool</code></a> 
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_set_native_method_prefix</code></td><td><a name="jvmtiCapabilities.can_set_native_method_prefix"></a>  네이티브 메소드를 해결할 수 없는 경우에 적용해야 할 접두사를 설정할 수 있는 - <a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>  및 <a href="#SetNativeMethodPrefixes"><code>SetNativeMethodPrefixes</code></a> 
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_retransform_classes</code></td><td><a name="jvmtiCapabilities.can_retransform_classes"></a> <a href="#RetransformClasses"><code>RetransformClasses</code></a>  으로 클래스를 재변환할 수 있다. 특정의 구현에 의한 이 권한의 제한 (<a href="#capability">「권한」</a>섹션을 참조)에 가세해 이 권한은, 이 환경에서 <a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>  이벤트가 처음 유효화 되기 전으로 설정해야 한다. <code>ClassFileLoadHook</code> 가 처음 유효화 된 시점에서 이 권한을 소유하고 있는 환경을 「재변환 가능」이라고 부른다. <i></i><code>ClassFileLoadHook</code> 가 처음 유효화 된 시점에서 이 권한을 소유하고 있지 않는 환경은 「재변환 불가능」이라고 부른다. <i></i>
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_retransform_any_class</code></td><td><a name="jvmtiCapabilities.can_retransform_any_class"></a>  <a href="#RetransformClasses"><code>RetransformClasses</code></a>  를 임의의 클래스에서 호출할 수 있다 (<a href="#jvmtiCapabilities.can_retransform_classes"><code>can_retransform_classes</code></a>  도 설정할 필요가 있다).
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_generate_resource_exhaustion_heap_events</code></td><td><a name="jvmtiCapabilities.can_generate_resource_exhaustion_heap_events"></a>  VM 가 Java<sup style="font-size: xx-small">TM</sup> 플랫폼 heap로부터 메모리의 할당을 실시할 수 없는 경우에, 이벤트를 생성할 수 있다. <a href="#ResourceExhausted"><code>ResourceExhausted</code></a>  를 참조.
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_generate_resource_exhaustion_threads_events</code></td><td><a name="jvmtiCapabilities.can_generate_resource_exhaustion_threads_events"></a>  VM 가 thread를 작성할 수 없는 경우에 이벤트를 생성할 수 있다. <a href="#ResourceExhausted"><code>ResourceExhausted</code></a>  를 참조.
	</td><td>1.1</td>
</tr>
</table>
</blockquote>
<p></p>
<hr noshade="noshade" width="100%" size="1" id="GetPotentialCapabilities">
<h3>잠재적인 권한의 취득</h3>
<blockquote>
<pre>jvmtiError
GetPotentialCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)</pre>
</blockquote>
<a href="#GetPotentialCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>  를 개입시켜, 현시점에서 이 환경을 소유할 수 있는 JVM<small style="font-size: xx-small">&nbsp;</small>TI 기능을 돌려줍니다. 반환되는 기능이, VM 가 구현하는 완전한 권한 세트와는 다른 경우가 있습니다. 해당하는 것은, 다른 환경이, 복수의 환경에 의한 소유를 허가되어 있지 않은 권한을 소유하고 있는 경우, 그리고 현재의<a href="#GetPhase">단계</a>가 라이브 단계에서, 특정의 권한은 <code>OnLoad</code> 단계에서 밖에 추가할 수 없는 경우입니다. 이러한 권한의 일부 또는 모든 것을 설정하려면 ,<a href="#AddCapabilities"><code>AddCapabilities</code></a>  함수를 사용할 수 있습니다. 현재 소유되고 있는 권한이 포함됩니다.
        <p></p>
일반적으로, 이 함수는,<code>OnLoad</code> 함수로 사용됩니다. 일부의 가상 머신에서는, 라이브 단계에서 추가할 수 있는 권한세트가 제한되고 있습니다. 이 경우, 잠재적으로 사용 가능한 권한세트가,<code>OnLoad</code> 단계세트와는 다릅니다.
        <p></p>
<a href="#capabilityExamples">「권한의 예」</a>를 참조해 주세요.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>140</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetPotentialCapabilities.capabilities_ptr">capabilities_ptr</code></td><td><code><a href="#jvmtiCapabilities">jvmtiCapabilities</a> *</code></td><td>
	    돌아왔을 때, 추가 가능한 JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 기능을 포인트 한다.
	  <p></p>에이전트는 <code>jvmtiCapabilities</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiCapabilities</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetPotentialCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="AddCapabilities">
<h3>권한의 추가</h3>
<blockquote>
<pre>jvmtiError
AddCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)</pre>
</blockquote>
<code>*</code><a href="#AddCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>  내에서 값이 <code>1</code> 으로 설정되어 있는 권한을 추가하는 것으로, 새로운 권한을 설정합니다. 이전의 권한은 모두 보관 유지됩니다. 일반적으로, 이 함수는,<code>OnLoad</code> 함수로 사용됩니다. 일부의 가상 머신에서는, 라이브 단계에서 추가할 수 있는 권한세트가 제한되고 있습니다.
        <p></p>
<a href="#capabilityExamples">「권한의 예」</a>를 참조해 주세요.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>142</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="AddCapabilities.capabilities_ptr">capabilities_ptr</code></td><td><code>const <a href="#jvmtiCapabilities">jvmtiCapabilities</a> *</code></td><td>
	    추가하는 JVM<small style="font-size: xx-small">&nbsp;</small>TI 권한을 포인트 한다.
	  <p></p>에이전트는 <code>jvmtiCapabilities</code> 에 포인터를 건네준다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_AVAILABLE"><code>JVMTI_ERROR_NOT_AVAILABLE</code></a> </td><td> 
필요한 권한이 잠재적으로 사용 가능한 권한이 아니다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#AddCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="RelinquishCapabilities">
<h3>권한의 방폐</h3>
<blockquote>
<pre>jvmtiError
RelinquishCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)</pre>
</blockquote>
<code>*</code><a href="#RelinquishCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>  내에서 값이 <code>1</code> 으로 설정되어 있는 권한을 방폐합니다. 구현에 따라서는, 단일의 환경 밖에 권한의 소유가 허가되지 않는 경우가 있습니다 (<a href="#capability">「권한의 개요」</a>를 참조). 이 함수는, 그 외의 에이전트를 사용할 수 있도록(듯이), 권한을 해제합니다. 그 외의 모든 권한은 보관 유지됩니다. 권한은,<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터는 없어집니다. 에이전트가 소유하고 있지 않는 권한을 방폐하려고 해도, 에러는 발생하지 않습니다.
          
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>143</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="RelinquishCapabilities.capabilities_ptr">capabilities_ptr</code></td><td><code>const <a href="#jvmtiCapabilities">jvmtiCapabilities</a> *</code></td><td>
	    방폐하는 JVM<small style="font-size: xx-small">&nbsp;</small>TI 권한을 포인트 한다.
	  <p></p>에이전트는 <code>jvmtiCapabilities</code> 에 포인터를 건네준다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#RelinquishCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetCapabilities">
<h3>기능의 취득</h3>
<blockquote>
<pre>jvmtiError
GetCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)</pre>
</blockquote>
<a href="#GetCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>  를 개입시켜, 이 환경이 현재 소유하고 있는 임의의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 기능을 돌려줍니다. 소유하고 있는 각 권한은,<a href="#jvmtiCapabilities">권한 구조체</a>의 대응하는 필드의 <code>1</code> 에 의해 나타납니다. 환경은,<a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용해 추가에 성공할 때까지, 권한을 소유하지 않습니다. 환경은,<a href="#RelinquishCapabilities"><code>RelinquishCapabilities</code></a>  를 사용해 방폐하지 않는 한, 권한을 잃지 않습니다. 따라서, 이 함수는,<code>AddCapabilities</code> 호출과 <code>RelinquishCapabilities</code> 호출의 최종 결과를 돌려줍니다.
          <p></p>
<a href="#capabilityExamples">「권한의 예」</a>를 참조해 주세요.
        <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
아니오
    </td><td>89</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetCapabilities.capabilities_ptr">capabilities_ptr</code></td><td><code><a href="#jvmtiCapabilities">jvmtiCapabilities</a> *</code></td><td>
	    돌아왔을 때, JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 기능을 포인트 한다.
	  <p></p>에이전트는 <code>jvmtiCapabilities</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiCapabilities</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<p id="timers"></p>
<hr noshade="noshade" size="3">
<h2 align="center">타이머</h2>타이머 함수:
  <ul>
<li>
<a href="#GetCurrentThreadCpuTimerInfo">현재의 thread의 CPU 타이머 정보를 취득</a> 
</li>
<li>
<a href="#GetCurrentThreadCpuTime">현재의 thread의 CPU 시간을 취득</a> 
</li>
<li>
<a href="#GetThreadCpuTimerInfo">thread의 CPU 타이머 정보를 취득</a> 
</li>
<li>
<a href="#GetThreadCpuTime">thread의 CPU 시간을 취득</a> 
</li>
<li>
<a href="#GetTimerInfo">타이머 정보의 취득</a> 
</li>
<li>
<a href="#GetTime">시간의 취득</a> 
</li>
<li>
<a href="#GetAvailableProcessors">사용 가능한 프로세서의 취득</a> 
</li>
</ul>타이머의 형태:
    <ul>
<li>
<a href="#jvmtiTimerInfo"><code>jvmtiTimerInfo</code></a>  - 타이머 정보</li>
<li>
<a href="#jvmtiTimerKind"><code>jvmtiTimerKind</code></a>  - 타이머의 종류</li>
</ul>
	이러한 함수는, 타이밍 정보를 제공합니다. 시간이 갱신되는 정밀도는 지정되고 있지 않습니다. 나노초단위의 정밀도가 제공됩니다만, 반드시 나노초단위의 정밀도를 얻을 수 있다고는 할 수 없습니다. 최대치 등, 타이머의 상세 정보에는, 타이머 정보 함수를 사용해 액세스 할 수 있습니다.   
<h4 id="jvmtiTimerInfo">타이머 정보</h4>
각 타이머의 정보 함수는, 이 데이터 구조체를 돌려줍니다.
        <p></p>
<blockquote>
<pre>typedef struct {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
} jvmtiTimerInfo;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiTimerInfo</code> - 타이머 정보</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiTimerInfo.max_value">max_value</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	      타이머를 도달할 수 있는 최대치. 이 값에 도달하면(자), 타이머의 값은 제로에 돌아온다. 이것은 부호 없음의 값이다. jlong (부호 첨0 보다 작은 값)로서 테스트 또는 출력했을 경우, 부의 수치로서 표시되는 경우가 있다.
	    </td>
</tr>
<tr>
<td><code id="jvmtiTimerInfo.may_skip_forward">may_skip_forward</code></td><td><code><a href="#jboolean">jboolean</a> </code></td><td>
	    true 의 경우, 타이머는 외부에서 조정되어 결과적으로 전에 스킵 한다. false 의 경우, 타이머의 값이 실제의 시간보다 빠르게 증가할 것은 없다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiTimerInfo.may_skip_backward">may_skip_backward</code></td><td><code><a href="#jboolean">jboolean</a> </code></td><td>
	    true 의 경우, 타이머는 외부에서 조정되어 결과적으로 뒤에 스킵 한다. false 의 경우, 타이머의 값은 일정해 증가한다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiTimerInfo.kind">kind</code></td><td><code><a href="#jvmtiTimerKind">jvmtiTimerKind</a> </code></td><td>
	    타이머의 종류. 사용자 타임과 시스템 타임을 구별하지 않는 플랫폼에서는,<a href="#JVMTI_TIMER_TOTAL_CPU"><code>JVMTI_TIMER_TOTAL_CPU</code></a>  가 반환된다.
	  </td>
</tr>
<tr>
<td><code id="jvmtiTimerInfo.reserved1">reserved1</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	      장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	    </td>
</tr>
<tr>
<td><code id="jvmtiTimerInfo.reserved2">reserved2</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	      장래의 사용을 위해서(때문에) 예약이 끝난 상태.
	    </td>
</tr>
</table>
</blockquote>
	타이머의 종류는 다음과 같습니다.

        <blockquote>
<a name="jvmtiTimerKind"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">타이머의 종류 (<code>jvmtiTimerKind</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_TIMER_USER_CPU">JVMTI_TIMER_USER_CPU</code></td><td align="right">30</td><td>
thread가 사용자 모드인 CPU 시간.
          </td>
</tr>
<tr>
<td><code id="JVMTI_TIMER_TOTAL_CPU">JVMTI_TIMER_TOTAL_CPU</code></td><td align="right">31</td><td>
thread가 사용자 모드 또는 시스템 모드인 CPU 시간.
          </td>
</tr>
<tr>
<td><code id="JVMTI_TIMER_ELAPSED">JVMTI_TIMER_ELAPSED</code></td><td align="right">32</td><td>
경과시간.
          </td>
</tr>
</table>
</blockquote>
      
<p></p>
<hr noshade="noshade" width="100%" size="1" id="GetCurrentThreadCpuTimerInfo">
<h3>현재의 thread의 CPU 타이머 정보를 취득</h3>
<blockquote>
<pre>jvmtiError
GetCurrentThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)</pre>
</blockquote>
	<a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>  타이머의 정보를 가져옵니다. <a href="#jvmtiTimerInfo"><code>jvmtiTimerInfo</code></a>  구조체의 필드에, 타이머의 상세가 들어갑니다. 이 정보는, 플랫폼과 <a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>  의 구현에 고유해서, thread 마다 변화하거나 VM 의 호출중에 변화할 것은 없습니다.
        <p></p>
<a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>  과 <a href="#GetThreadCpuTime"><code>GetThreadCpuTime</code></a>  의 구현이 다른 경우,<code>GetCurrentThreadCpuTimerInfo</code> 와 <a href="#GetThreadCpuTimerInfo"><code>GetThreadCpuTimerInfo</code></a>  에 의해 반환되는 값은 다른 일이 있습니다. 상세한 것에 대하여는,<a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>  를 참조해 주세요.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>134</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_current_thread_cpu_time"><code>can_get_current_thread_cpu_time</code></a> </td><td>
	    현재의 thread CPU 시간을 취득할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetCurrentThreadCpuTimerInfo.info_ptr">info_ptr</code></td><td><code><a href="#jvmtiTimerInfo">jvmtiTimerInfo</a> *</code></td><td>
	    돌아왔을 때,<a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>  에 의해 반환되는 시간을 설명하는 정보가 들어가 있다.
	  <p></p>에이전트는 <code>jvmtiTimerInfo</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiTimerInfo</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_current_thread_cpu_time"><code>can_get_current_thread_cpu_time</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetCurrentThreadCpuTimerInfo.info_ptr"><code>info_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetCurrentThreadCpuTime">
<h3>현재의 thread의 CPU 시간을 취득</h3>
<blockquote>
<pre>jvmtiError
GetCurrentThreadCpuTime(jvmtiEnv* env,
            jlong* nanos_ptr)</pre>
</blockquote>
현재의 thread에 의해 사용되고 있는 CPU 시간을 돌려줍니다.   
            <p></p>
<a href="#GetThreadCpuTime"><code>GetThreadCpuTime</code></a>  함수는, 현재의 thread를 포함한 모든 thread의 CPU 시간을 제공합니다. <code>GetCurrentThreadCpuTime</code> 은, 현재의 thread 또는 현재의 thread보다 정밀한 정보를 가지는 thread 이외의 thread의 CPU 시간을 제공할 수 없는 플랫폼을 지원합니다 (<a href="#GetCurrentThreadCpuTimerInfo"><code>GetCurrentThreadCpuTimerInfo</code></a>  와 <a href="#GetThreadCpuTimerInfo"><code>GetThreadCpuTimerInfo</code></a>  를 참조). 많은 플랫폼에서는, 이 호출은 다음의 코드와 동등합니다.
<blockquote>
<pre>
  GetThreadCpuTime(env, NULL, nanos_ptr)
</pre>
</blockquote>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>135</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_current_thread_cpu_time"><code>can_get_current_thread_cpu_time</code></a> </td><td>
	    현재의 thread CPU 시간을 취득할 수 있다.
            <p></p>
	    이 권한이 thread의 개시 후에 유효하게 되었을 경우, 구현은, 권한이 유효하게 된 시간까지의 임의의 시간을, CPU 시간의 수집을 개시하는 포인트로서 선택할 수 있다.
            <p></p>
이 권한은,<a href="#jvmtiCapabilities.can_get_thread_cpu_time"><code>can_get_thread_cpu_time</code></a>  를 잠재적으로 사용할 수 있는 모든 플랫폼에서 잠재적으로 사용 가능.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetCurrentThreadCpuTime.nanos_ptr">nanos_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    돌아왔을 때, 이 thread에 의해 사용되는 CPU 시간 (나노초단위)을 포인트 하는 이것은 부호 없음의 값. jlong (부호 첨0 보다 작은 값)로서 테스트 또는 출력했을 경우, 부의 수치로서 표시되는 경우가 있다.
	  <p></p>에이전트는 <code>jlong</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jlong</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_current_thread_cpu_time"><code>can_get_current_thread_cpu_time</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetCurrentThreadCpuTime.nanos_ptr"><code>nanos_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetThreadCpuTimerInfo">
<h3>thread의 CPU 타이머 정보를 취득</h3>
<blockquote>
<pre>jvmtiError
GetThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)</pre>
</blockquote>
	<a href="#GetThreadCpuTime"><code>GetThreadCpuTime</code></a>  타이머의 정보를 가져옵니다. <a href="#jvmtiTimerInfo"><code>jvmtiTimerInfo</code></a>  구조체의 필드에, 타이머의 상세가 들어갑니다. 이 정보는, 플랫폼과 <a href="#GetThreadCpuTime"><code>GetThreadCpuTime</code></a>  의 구현에 고유해서, thread 마다 변화하거나 VM 의 호출중에 변화할 것은 없습니다.
        <p></p>
<a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>  과 <a href="#GetThreadCpuTime"><code>GetThreadCpuTime</code></a>  의 구현이 다른 경우,<a href="#GetCurrentThreadCpuTimerInfo"><code>GetCurrentThreadCpuTimerInfo</code></a>  와 <code>GetThreadCpuTimerInfo</code> 에 의해 반환되는 값은 다른 일이 있습니다. 상세한 것에 대하여는,<a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>  를 참조해 주세요.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>136</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_thread_cpu_time"><code>can_get_thread_cpu_time</code></a> </td><td>
	    thread CPU 시간을 취득할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetThreadCpuTimerInfo.info_ptr">info_ptr</code></td><td><code><a href="#jvmtiTimerInfo">jvmtiTimerInfo</a> *</code></td><td>
	    돌아왔을 때,<a href="#GetThreadCpuTime"><code>GetThreadCpuTime</code></a>  에 의해 반환되는 시간을 설명하는 정보가 들어가 있다.
	  <p></p>에이전트는 <code>jvmtiTimerInfo</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiTimerInfo</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_thread_cpu_time"><code>can_get_thread_cpu_time</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetThreadCpuTimerInfo.info_ptr"><code>info_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetThreadCpuTime">
<h3>thread의 CPU 시간을 취득</h3>
<blockquote>
<pre>jvmtiError
GetThreadCpuTime(jvmtiEnv* env,
            jthread thread,
            jlong* nanos_ptr)</pre>
</blockquote>
지정의 thread에 의해 사용되고 있는 CPU 시간을 돌려줍니다.  
          <p></p>
	  <a href="#GetThreadCpuTimerInfo"><code>GetThreadCpuTimerInfo</code></a>  에 의해, 이 타이머의 정보를 가져옵니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>137</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 함수를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_thread_cpu_time"><code>can_get_thread_cpu_time</code></a> </td><td>
	    thread CPU 시간을 취득할 수 있다.
            <p></p>
	    이 권한이 thread의 개시 후에 유효하게 되었을 경우, 구현은, 권한이 유효하게 된 시간까지의 임의의 시간을, CPU 시간의 수집을 개시하는 포인트로서 선택할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetThreadCpuTime.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	      조회하는 thread.
	    
<code>thread</code> 가 <code>NULL</code> 의 경우, 현재의 thread가 사용된다.
  </td>
</tr>
<tr>
<td><code id="GetThreadCpuTime.nanos_ptr">nanos_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    돌아왔을 때, 지정된 thread에 의해 사용되는 CPU 시간 (나노초단위)을 포인트 하는 이것은 부호 없음의 값. jlong (부호 첨0 보다 작은 값)로서 테스트 또는 출력했을 경우, 부의 수치로서 표시되는 경우가 있다.
	  <p></p>에이전트는 <code>jlong</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jlong</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a> </td><td>
환경은 권한 <a href="#jvmtiCapabilities.can_get_thread_cpu_time"><code>can_get_thread_cpu_time</code></a>  를 가지지 않는다. <a href="#AddCapabilities"><code>AddCapabilities</code></a>  를 사용한다.
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a> </td><td>
	  <a href="#GetThreadCpuTime.thread"><code>thread</code></a>  는 thread 객체는 아니다.
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a> </td><td>
	  <a href="#GetThreadCpuTime.thread"><code>thread</code></a>  가 라이브 thread는 아니다 ( 아직 기동하고 있지 않는지, 벌써 종료하고 있다).
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetThreadCpuTime.nanos_ptr"><code>nanos_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetTimerInfo">
<h3>타이머 정보의 취득</h3>
<blockquote>
<pre>jvmtiError
GetTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)</pre>
</blockquote>
	<a href="#GetTime"><code>GetTime</code></a>  타이머의 정보를 가져옵니다. <a href="#jvmtiTimerInfo"><code>jvmtiTimerInfo</code></a>  구조체의 필드에, 타이머의 상세가 들어갑니다. 이 정보는, VM 의 호출중으로 변경되지 않습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>138</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetTimerInfo.info_ptr">info_ptr</code></td><td><code><a href="#jvmtiTimerInfo">jvmtiTimerInfo</a> *</code></td><td>
	    돌아왔을 때,<a href="#GetTime"><code>GetTime</code></a> 에 의해 반환되는 시간을 설명하는 정보가 들어가 있다.
	  <p></p>에이전트는 <code>jvmtiTimerInfo</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiTimerInfo</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetTimerInfo.info_ptr"><code>info_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetTime">
<h3>시간의 취득</h3>
<blockquote>
<pre>jvmtiError
GetTime(jvmtiEnv* env,
            jlong* nanos_ptr)</pre>
</blockquote>
시스템 타이머-의 현재의 값 (나노초단위)을 돌려줍니다.  
          <p></p>
반환되는 값은, 고정된 임의의 시간부터의 경과시간 (나노초)입니다.  장래적으로, 값이 부의 수가 될 가능성이 있습니다. 이 함수에서는, 나노초단위의 정밀도가 제공됩니다만, 반드시 나노초단위의 정밀도를 얻을 수 있다고는 할 수 없습니다. 값의 변경 빈도는 보증되지 않습니다.
          <p></p>
	  <a href="#GetTimerInfo"><code>GetTimerInfo</code></a>  에 의해, 이 타이머의 정보를 가져옵니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>139</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetTime.nanos_ptr">nanos_ptr</code></td><td><code><a href="#jlong">jlong</a> *</code></td><td>
	    돌아왔을 때, 나노초단위로 시간을 포인트 한다. 이것은 부호 없음의 값. jlong (부호 첨0 보다 작은 값)로서 테스트 또는 출력했을 경우, 부의 수치로서 표시되는 경우가 있다.
	  <p></p>에이전트는 <code>jlong</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jlong</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetTime.nanos_ptr"><code>nanos_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetAvailableProcessors">
<h3>사용 가능한 프로세서의 취득</h3>
<blockquote>
<pre>jvmtiError
GetAvailableProcessors(jvmtiEnv* env,
            jint* processor_count_ptr)</pre>
</blockquote>
Java 가상 머신을 사용할 수 있는 프로세서의 수를 돌려줍니다.
          <p></p>
이 값은, 가상 머신의 호출중으로 변경될 가능성이 있습니다. 이 때문에, 사용 가능한 프로세서의 수에 영향을 받는 어플리케이션은, 가끔 이 프로퍼티을 폴링 할 필요가 있습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
아니오
    </td><td>144</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetAvailableProcessors.processor_count_ptr">processor_count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 가상 머신을 사용할 수 있는 최대 프로세서수를 포인트 한다 (반드시 1 이상).   
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetAvailableProcessors.processor_count_ptr"><code>processor_count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<p id="classLoaderSearch"></p>
<hr noshade="noshade" size="3">
<h2 align="center">클래스 로더 검색</h2>클래스 로더 검색의 함수:
  <ul>
<li>
<a href="#AddToBootstrapClassLoaderSearch">bootstrap 클래스 로더 검색의 추가</a> 
</li>
<li>
<a href="#AddToSystemClassLoaderSearch">시스템 클래스 로더 검색의 추가</a> 
</li>
</ul>
이러한 함수를 사용하면, 에이전트는, 클래스 로더가 클래스를 검색할 때의 장소를 추가할 수 있습니다. 이것은, 올바른 클래스 로더로 Instrumentation을 인스톨 할 때에 편리합니다.
    <p></p>
<hr noshade="noshade" width="100%" size="1" id="AddToBootstrapClassLoaderSearch">
<h3>bootstrap 클래스 로더 검색의 추가</h3>
<blockquote>
<pre>jvmtiError
AddToBootstrapClassLoaderSearch(jvmtiEnv* env,
            const char* segment)</pre>
</blockquote>
이 함수에서는, bootstrap 클래스 로더를 사용해 Instrumentation크라스를 정의할 수 있습니다. <a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ConstantPool.doc.html#79383">「Loading Using the Bootstrap Class Loader」</a>를 참조해 주세요. <i></i>bootstrap 클래스 로더가 클래스의 검색에 실패한 뒤, 지정된 플랫폼 의존의 검색 패스<a href="#AddToBootstrapClassLoaderSearch.segment"><code>세그먼트(segment)</code></a> 를 검색합니다. <a href="#AddToBootstrapClassLoaderSearch.segment"><code>segment</code></a>  로 지정할 수 있는 세그먼트(segment)는, 1 개(살) 뿐입니다. 복수의 세그먼트(segment)를 추가하는 경우, 이 함수를 여러 차례 호출할 수가 있습니다.  세그먼트(segment)는, 이 함수가 불려 간 순서에 검색됩니다.
	  <p></p>
	  <code>OnLoad</code> 단계에서 이 함수를 사용하면(자), bootstrap 클래스 로더가 클래스의 검색에 실패했을 때에, 추가로 검색하는 임의의 플랫폼 의존의 검색 패스 세그먼트(segment)를 지정할 수 있습니다. 이 세그먼트(segment)는 일반적으로, 디렉토리와 JAR 파일의 어느 쪽인가에 됩니다.
	  <p></p>	  
	  라이브 단계에서 <a href="#AddToBootstrapClassLoaderSearch.segment"><code>segment</code></a>  를 사용하면(자), 임의의 플랫폼 의존의 <a href="http://java.sun.com/javase/6/docs/guide/jar/jar.html">JAR 파일</a>에의 패스를 지정할 수 있습니다. bootstrap 클래스 로더가 Instrumentation 목적으로 정의하는 클래스나 자원 이외의 것이 JAR 파일에 포함되지 않게, 에이전트로 확인하도록 해 주세요.
          <p></p>
<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>에 의하면,Java 가상 머신이 이전에 상징적 참조를 해결하려고 해 실패했을 경우, 그 후 이 상징적 참조를 해결하려고 해도 반드시 실패해, 최초로 해결하려고 한 결과적으로 throw 된 에러와 같은 에러가 됩니다. 따라서, Java 가상 머신이 참조를 해결할 수 없었던 클래스에 대응하는 엔트리가 JAR 파일에 포함되는 경우, 그 참조를 해결하려고 해도 최초의 에러와 같은 에러로 실패합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>149</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="AddToBootstrapClassLoaderSearch.segment">segment</code></td><td><code>const char*</code></td><td>
	    플랫폼 의존의 검색 패스 세그먼트(segment). <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다.
	  <p></p>에이전트는,<code>char</code> 의 배열을 건네준다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>   
<a href="#AddToBootstrapClassLoaderSearch.segment"><code>segment</code></a>  가 무효인 패스. 라이브 단계에서는, 기존의 JAR 파일 이외는 모두 무효인 패스가 된다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#AddToBootstrapClassLoaderSearch.segment"><code>segment</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="AddToSystemClassLoaderSearch">
<h3>시스템 클래스 로더 검색의 추가</h3>
<blockquote>
<pre>jvmtiError
AddToSystemClassLoaderSearch(jvmtiEnv* env,
            const char* segment)</pre>
</blockquote>
	  이 함수에서는, 시스템 클래스 로더를 사용해 Instrumentation크라스를 정의할 수 있습니다. <a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>의<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ConstantPool.doc.html#79441">「Loading Using a User-defined Class Loader」</a>를 참조해 주세요. <i></i>클래스 로더가 클래스의 검색에 실패한 뒤, 지정된 플랫폼 의존의 검색 패스<a href="#AddToSystemClassLoaderSearch.segment"><code>세그먼트(segment)</code></a> 를 검색합니다. <a href="#AddToSystemClassLoaderSearch.segment"><code>segment</code></a>  로 지정할 수 있는 세그먼트(segment)는, 1 개(살) 뿐입니다. 복수의 세그먼트(segment)를 추가하는 경우, 이 함수를 여러 차례 호출할 수가 있습니다.  세그먼트(segment)는, 이 함수가 불려 간 순서에 검색됩니다.
	  <p></p>
	  <code>OnLoad</code> 단계에서 이 함수를 사용하면(자), 시스템 클래스 로더가 클래스의 검색에 실패했을 때에, 추가로 검색하는 임의의 플랫폼 의존의 검색 패스 세그먼트(segment)를 지정할 수 있습니다. 이 세그먼트(segment)는 일반적으로, 디렉토리와 JAR 파일의 어느 쪽인가에 됩니다.
	  <p></p>	  
	  라이브 단계에서는,<a href="#AddToSystemClassLoaderSearch.segment"><code>segment</code></a>  는, 시스템 클래스 로더가 클래스의 검색에 실패했을 때에, 추가로 검색하는 플랫폼 의존의 <a href="http://java.sun.com/javase/6/docs/guide/jar/jar.html">JAR 파일</a>에의 패스가 됩니다. 시스템 클래스 로더가 Instrumentation 목적으로 정의하는 클래스나 자원 이외의 것이 JAR 파일에 포함되지 않게, 에이전트로 확인하도록 해 주세요.
          <p></p>
	  라이브 단계에서 시스템 클래스 로더가 검색 대상 JAR 파일의 추가를 지원하는 것은,<code>java.lang.String</code> 형의 단일 파라미터를 취하는 <code>appendToClassPathForInstrumentation</code> 라는 이름의 메소드를 시스템 클래스 로더가 구현하고 있는 경우입니다. 이 메소드는,<code>public</code> 액세스를 갖추지 않아도 괜찮습니다.  
	  <p></p>
<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>에 의하면,Java 가상 머신이 이전에 상징적 참조를 해결하려고 해 실패했을 경우, 그 후 이 상징적 참조를 해결하려고 해도 반드시 실패해, 최초로 해결하려고 한 결과적으로 throw 된 에러와 같은 에러가 됩니다. 따라서, Java 가상 머신이 참조를 해결할 수 없었던 클래스에 대응하는 엔트리가 JAR 파일에 포함되는 경우, 그 참조를 해결하려고 해도 최초의 에러와 같은 에러로 실패합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>151</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="AddToSystemClassLoaderSearch.segment">segment</code></td><td><code>const char*</code></td><td>
플랫폼 의존의 검색 패스 세그먼트(segment). <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다.
<p></p>에이전트는,<code>char</code> 의 배열을 건네준다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
<a href="#AddToSystemClassLoaderSearch.segment"><code>segment</code></a>  가 무효인 패스. 라이브 단계에서는, 기존의 JAR 파일 이외는 모두 무효인 패스가 된다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED"><code>JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED</code></a> </td><td>
	  시스템 클래스 로더가 지원하지 않는 조작.
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
<a href="#AddToSystemClassLoaderSearch.segment"><code>segment</code></a>  가 <code>NULL</code>.
          
        </td>
</tr>
</table>
<p id="props"></p>
<hr noshade="noshade" size="3">
<h2 align="center">시스템 프로퍼티</h2>시스템 프로퍼티 함수:
  <ul>
<li>
<a href="#GetSystemProperties">시스템 프로퍼티의 취득</a> 
</li>
<li>
<a href="#GetSystemProperty">시스템 프로퍼티의 취득</a> 
</li>
<li>
<a href="#SetSystemProperty">시스템 프로퍼티의 설정</a> 
</li>
</ul>
이러한 함수는, 시스템 프로퍼티을 취득 및 설정합니다.
    <p></p>
<hr noshade="noshade" width="100%" size="1" id="GetSystemProperties">
<h3>시스템 프로퍼티의 취득</h3>
<blockquote>
<pre>jvmtiError
GetSystemProperties(jvmtiEnv* env,
            jint* count_ptr,
            char*** property_ptr)</pre>
</blockquote>
<a href="#GetSystemProperty"><code>GetSystemProperty</code></a>  로 사용 가능한 VM 시스템 프로퍼티 키의 리스트가 돌려주어집니다. 가상 머신이 다음의 프로퍼티 키를 제공하도록(듯이) 하는 것을 강하게 추천합니다.
        <ul type="disc">
          
<li>
<code>java.vm.vendor</code>
</li>
          
<li>
<code>java.vm.version</code>
</li>
          
<li>
<code>java.vm.name</code>
</li>
          
<li>
<code>java.vm.info</code>
</li>
          
<li>
<code>java.library.path</code>
</li>
          
<li>
<code>java.class.path</code>
</li>
        
</ul>
VM 에 의해 정의되어 사용되는 시스템 프로퍼티에의 액세스를 제공합니다. 커멘드행으로 설정된 프로퍼티도 포함됩니다. 이것에 의해, 이러한 프로퍼티을, VM 가 바이트 코드의 실행을 개시하기 전에 취득, 설정할 수 있습니다. 이것은 시스템 프로퍼티의 VM 뷰이므로, 사용 가능한 프로퍼티세트는, 일반적으로,<code>java.lang.System.getProperties</code> 내의 프로퍼티 세트와는 다릅니다. <code>java.lang.System.getProperties</code> 의 액세스에는, JNI 메소드 호출을 사용할 수 있습니다.
        <p></p>
프로퍼티세트는, 실행중에 증가하는 일이 있습니다. 	  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>130</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetSystemProperties.count_ptr">count_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, 반환되는 프로퍼티 키의 수를 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
<tr>
<td><code id="GetSystemProperties.property_ptr">property_ptr</code></td><td><code>char***</code></td><td>
	    돌아왔을 때, 프로퍼티 키의 배열 (<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다)을 포인트 한다.
	  <p></p>에이전트는 <code>char**</code> 에 포인터를 건네준다. 돌아왔을 때,<code>char**</code> 는, 사이즈 <code>*count_ptr</code> 의 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다. 각 요소는,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetSystemProperties.count_ptr"><code>count_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetSystemProperties.property_ptr"><code>property_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetSystemProperty">
<h3>시스템 프로퍼티의 취득</h3>
<blockquote>
<pre>jvmtiError
GetSystemProperty(jvmtiEnv* env,
            const char* property,
            char** value_ptr)</pre>
</blockquote>
프로퍼티 키에 의해 지정된 VM 시스템 프로퍼티을 돌려줍니다.   
        <p></p>
	함수 <a href="#GetSystemProperties"><code>GetSystemProperties</code></a>  는, 사용 가능한 프로퍼티 키세트를 돌려줍니다. 취득 가능한 프로퍼티은, 실행중에 증가하는 일이 있습니다.
        <p></p>
	이것은 시스템 프로퍼티의 VM 뷰이므로, 프로퍼티의 값은,<code>java.lang.System.getProperty(String)</code> 에 의해 반환되는 프로퍼티의 값과는 다릅니다. 일반적으로의 VM 는, 클래스의 초기화중에, VM 시스템 프로퍼티의 값을 <code>java.lang.System</code> 에 포함되고 있는 <code>Properties</code> 에 카피할 수 있습니다. 그 후,<a href="#SetSystemProperty"><code>SetSystemProperty</code></a>  를 사용해 VM 시스템 프로퍼티을 변경하거나<code>java.lang.System.setProperty(String, String)</code> 를 사용해 <code>java.lang.System</code> 시스템 프로퍼티을 변경하거나 하면(자), 값이 변경됩니다. <code>java.lang.System.getProperty(String)</code> 의 액세스에는, JNI 메소드 호출을 사용할 수 있습니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 또는 라이브 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>131</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetSystemProperty.property">property</code></td><td><code>const char*</code></td><td>
	    취득되는 프로퍼티의 키. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다.
	  <p></p>에이전트는,<code>char</code> 의 배열을 건네준다.  </td>
</tr>
<tr>
<td><code id="GetSystemProperty.value_ptr">value_ptr</code></td><td><code>char**</code></td><td>
	    돌아왔을 때, 프로퍼티의 값 (<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다)을 포인트 한다.
	  <p></p>에이전트는 <code>char*</code> 에 포인터를 건네준다. <code>char*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_AVAILABLE"><code>JVMTI_ERROR_NOT_AVAILABLE</code></a> </td><td> 
이 프로퍼티을 사용할 수 없다. <a href="#GetSystemProperties"><code>GetSystemProperties</code></a>  를 사용해, 사용 가능한 프로퍼티을 검색한다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetSystemProperty.property"><code>property</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetSystemProperty.value_ptr"><code>value__ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetSystemProperty">
<h3>시스템 프로퍼티의 설정</h3>
<blockquote>
<pre>jvmtiError
SetSystemProperty(jvmtiEnv* env,
            const char* property,
            const char* value)</pre>
</blockquote>
VM 시스템 프로퍼티의 값을 설정합니다.   
        <p></p>
	함수 <a href="#GetSystemProperties"><code>GetSystemProperties</code></a>  는, 프로퍼티 키세트를 돌려줍니다. 그 중의 몇개인가는 설정 가능합니다. <a href="#GetSystemProperty"><code>GetSystemProperty</code></a>  를 참조해 주세요.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
OnLoad 단계에서 밖에 호출할 수 없다
</td><td>
아니오
    </td><td>132</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetSystemProperty.property">property</code></td><td><code>const char*</code></td><td>
	    프로퍼티의 키. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다.
	  <p></p>에이전트는,<code>char</code> 의 배열을 건네준다.  </td>
</tr>
<tr>
<td><code id="SetSystemProperty.value">value</code></td><td><code>const char
	    
	  *</code></td><td>
	    설정하는 프로퍼티치. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다.
	  <p></p>에이전트는,<code>char</code> 의 배열을 건네준다. <code>value</code> 가 <code>NULL</code> 의 경우는 값이 설정되지 않지만, 프로퍼티이 기입해 가능하지 않은 경우는 <a href="#JVMTI_ERROR_NOT_AVAILABLE"><code>JVMTI_ERROR_NOT_AVAILABLE</code></a>  가 반환된다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_AVAILABLE"><code>JVMTI_ERROR_NOT_AVAILABLE</code></a> </td><td> 
이 프로퍼티을 사용할 수 없는, 또는 이 프로퍼티은 기입해 가능하지 않다.
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#SetSystemProperty.property"><code>property</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<p id="general"></p>
<hr noshade="noshade" size="3">
<h2 align="center">전반</h2>전반 함수:
  <ul>
<li>
<a href="#GetPhase">단계의 취득</a> 
</li>
<li>
<a href="#DisposeEnvironment">환경의 파기</a> 
</li>
<li>
<a href="#SetEnvironmentLocalStorage">환경 로컬 기억 영역의 설정</a> 
</li>
<li>
<a href="#GetEnvironmentLocalStorage">환경 로컬 기억 영역의 취득</a> 
</li>
<li>
<a href="#GetVersionNumber">버젼 번호의 취득</a> 
</li>
<li>
<a href="#GetErrorName">에러명의 취득</a> 
</li>
<li>
<a href="#SetVerboseFlag">장황 플래그의 설정</a> 
</li>
<li>
<a href="#GetJLocationFormat">JLocation 형식의 취득</a> 
</li>
</ul>전반의 형태:
    <ul>
<li>
<a href="#jvmtiPhase"><code>jvmtiPhase</code></a>  - 실행의 단계</li>
<li>
<a href="#jvmtiVerboseFlag"><code>jvmtiVerboseFlag</code></a>  - 장황 플래그의 열거</li>
<li>
<a href="#jvmtiJlocationFormat"><code>jvmtiJlocationFormat</code></a>  - JLocation 의 형식의 열거</li>
</ul>전반의 플래그 및 정수:
    <ul>
<li>
<a href="#jvmtiVersionInterfaceTypes">버젼의 인터페이스의 형태</a> 
</li>
<li>
<a href="#jvmtiVersionMasks">버젼 마스크</a> 
</li>
<li>
<a href="#jvmtiVersionShifts">버젼 쉬프트</a> 
</li>
</ul>
    
<p></p>
<hr noshade="noshade" width="100%" size="1" id="GetPhase">
<h3>단계의 취득</h3>
<blockquote>
<pre>
typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;</pre>
<pre>jvmtiError
GetPhase(jvmtiEnv* env,
            jvmtiPhase* phase_ptr)</pre>
</blockquote>
VM 실행의 현재의 단계를 돌려줍니다. 단계는 다음의 순서로 진행합니다.
          <blockquote>
<a name="jvmtiPhase"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">실행의 단계 (<code>jvmtiPhase</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_PHASE_ONLOAD">JVMTI_PHASE_ONLOAD</code></td><td align="right">1</td><td>
<code>OnLoad</code> 단계:<a href="#onload"><code>Agent_OnLoad</code></a>  함수내.
            </td>
</tr>
<tr>
<td><code id="JVMTI_PHASE_PRIMORDIAL">JVMTI_PHASE_PRIMORDIAL</code></td><td align="right">2</td><td>
초기 단계:<code>Agent_OnLoad</code> 가 돌려주어지고 나서 <code>VMStart</code> 이벤트가 개시될 때까지.
            </td>
</tr>
<tr>
<td><code id="JVMTI_PHASE_START">JVMTI_PHASE_START</code></td><td align="right">6</td><td>
개시 단계:<a href="#VMStart"><code>VMStart</code></a>  이벤트가 송신되었을 때와 <code>VMInit</code> 이벤트가 송신될 때까지.
            </td>
</tr>
<tr>
<td><code id="JVMTI_PHASE_LIVE">JVMTI_PHASE_LIVE</code></td><td align="right">4</td><td>
라이브 단계:<a href="#VMInit"><code>VMInit</code></a>  이벤트가 송신되었을 때와 <a href="#VMDeath"><code>VMDeath</code></a>  이벤트가 돌려주어질 때까지.
            </td>
</tr>
<tr>
<td><code id="JVMTI_PHASE_DEAD">JVMTI_PHASE_DEAD</code></td><td align="right">8</td><td>
데드 단계:<a href="#VMDeath"><code>VMDeath</code></a>  이벤트가 돌려주어지고 나서, 또는 기동에 실패하고 나서.
            </td>
</tr>
</table>
</blockquote>
기동에 실패했을 경우, VM 는 중간의 단계를 생략 해 직접 데드 단계로 나아갑니다. 이 경우,<code>VMInit</code> 이벤트도 <code>VMDeath</code> 이벤트도 송신되지 않습니다.
          <p></p>
대부분의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수는, 라이브 단계에서 밖에 동작하지 않습니다. 다음의 함수는,<code>OnLoad</code> 단계에서도 라이브 단계에서도 동작합니다.
          <ul>
<li>
<a href="#CreateRawMonitor"><b>CreateRawMonitor</b></a> 
</li>
<li>
<a href="#DestroyRawMonitor"><b>DestroyRawMonitor</b></a> 
</li>
<li>
<a href="#SetEventCallbacks"><b>SetEventCallbacks</b></a> 
</li>
<li>
<a href="#SetEventNotificationMode"><b>SetEventNotificationMode</b></a> 
</li>
<li>
<a href="#GetExtensionFunctions"><b>GetExtensionFunctions</b></a> 
</li>
<li>
<a href="#GetExtensionEvents"><b>GetExtensionEvents</b></a> 
</li>
<li>
<a href="#SetExtensionEventCallback"><b>SetExtensionEventCallback</b></a> 
</li>
<li>
<a href="#GetPotentialCapabilities"><b>GetPotentialCapabilities</b></a> 
</li>
<li>
<a href="#AddCapabilities"><b>AddCapabilities</b></a> 
</li>
<li>
<a href="#RelinquishCapabilities"><b>RelinquishCapabilities</b></a> 
</li>
<li>
<a href="#AddToBootstrapClassLoaderSearch"><b>AddToBootstrapClassLoaderSearch</b></a> 
</li>
<li>
<a href="#AddToSystemClassLoaderSearch"><b>AddToSystemClassLoaderSearch</b></a> 
</li>
<li>
<a href="#GetSystemProperties"><b>GetSystemProperties</b></a> 
</li>
<li>
<a href="#GetSystemProperty"><b>GetSystemProperty</b></a> 
</li>
</ul>
다음의 함수는,<code>OnLoad</code> 단계에서만 동작합니다.
          <ul>
<li>
<a href="#SetSystemProperty"><b>SetSystemProperty</b></a> 
</li>
</ul>
다음의 함수는, 개시 단계에서도 라이브 단계에서도 동작합니다.
          <ul>
<li>
<a href="#GetCurrentThread"><b>GetCurrentThread</b></a> 
</li>
<li>
<a href="#SetThreadLocalStorage"><b>SetThreadLocalStorage</b></a> 
</li>
<li>
<a href="#GetThreadLocalStorage"><b>GetThreadLocalStorage</b></a> 
</li>
<li>
<a href="#GetTag"><b>GetTag</b></a> 
</li>
<li>
<a href="#SetTag"><b>SetTag</b></a> 
</li>
<li>
<a href="#GetClassSignature"><b>GetClassSignature</b></a> 
</li>
<li>
<a href="#GetClassStatus"><b>GetClassStatus</b></a> 
</li>
<li>
<a href="#GetSourceFileName"><b>GetSourceFileName</b></a> 
</li>
<li>
<a href="#GetClassModifiers"><b>GetClassModifiers</b></a> 
</li>
<li>
<a href="#GetClassMethods"><b>GetClassMethods</b></a> 
</li>
<li>
<a href="#GetClassFields"><b>GetClassFields</b></a> 
</li>
<li>
<a href="#GetImplementedInterfaces"><b>GetImplementedInterfaces</b></a> 
</li>
<li>
<a href="#GetClassVersionNumbers"><b>GetClassVersionNumbers</b></a> 
</li>
<li>
<a href="#GetConstantPool"><b>GetConstantPool</b></a> 
</li>
<li>
<a href="#IsInterface"><b>IsInterface</b></a> 
</li>
<li>
<a href="#IsArrayClass"><b>IsArrayClass</b></a> 
</li>
<li>
<a href="#IsModifiableClass"><b>IsModifiableClass</b></a> 
</li>
<li>
<a href="#GetClassLoader"><b>GetClassLoader</b></a> 
</li>
<li>
<a href="#GetSourceDebugExtension"><b>GetSourceDebugExtension</b></a> 
</li>
<li>
<a href="#GetObjectSize"><b>GetObjectSize</b></a> 
</li>
<li>
<a href="#GetObjectHashCode"><b>GetObjectHashCode</b></a> 
</li>
<li>
<a href="#GetFieldName"><b>GetFieldName</b></a> 
</li>
<li>
<a href="#GetFieldDeclaringClass"><b>GetFieldDeclaringClass</b></a> 
</li>
<li>
<a href="#GetFieldModifiers"><b>GetFieldModifiers</b></a> 
</li>
<li>
<a href="#IsFieldSynthetic"><b>IsFieldSynthetic</b></a> 
</li>
<li>
<a href="#GetMethodName"><b>GetMethodName</b></a> 
</li>
<li>
<a href="#GetMethodDeclaringClass"><b>GetMethodDeclaringClass</b></a> 
</li>
<li>
<a href="#GetMethodModifiers"><b>GetMethodModifiers</b></a> 
</li>
<li>
<a href="#GetMaxLocals"><b>GetMaxLocals</b></a> 
</li>
<li>
<a href="#GetArgumentsSize"><b>GetArgumentsSize</b></a> 
</li>
<li>
<a href="#GetLineNumberTable"><b>GetLineNumberTable</b></a> 
</li>
<li>
<a href="#GetMethodLocation"><b>GetMethodLocation</b></a> 
</li>
<li>
<a href="#GetBytecodes"><b>GetBytecodes</b></a> 
</li>
<li>
<a href="#IsMethodNative"><b>IsMethodNative</b></a> 
</li>
<li>
<a href="#IsMethodSynthetic"><b>IsMethodSynthetic</b></a> 
</li>
<li>
<a href="#IsMethodObsolete"><b>IsMethodObsolete</b></a> 
</li>
<li>
<a href="#SetJNIFunctionTable"><b>SetJNIFunctionTable</b></a> 
</li>
<li>
<a href="#GetJNIFunctionTable"><b>GetJNIFunctionTable</b></a> 
</li>
<li>
<a href="#GetCurrentThreadCpuTimerInfo"><b>GetCurrentThreadCpuTimerInfo</b></a> 
</li>
<li>
<a href="#GetCurrentThreadCpuTime"><b>GetCurrentThreadCpuTime</b></a> 
</li>
</ul>
다음의 함수는, 어느 단계에서도 동작합니다.
          <ul>
<li>
<a href="#Allocate"><b>Allocate</b></a> 
</li>
<li>
<a href="#Deallocate"><b>Deallocate</b></a> 
</li>
<li>
<a href="#SetNativeMethodPrefix"><b>SetNativeMethodPrefix</b></a> 
</li>
<li>
<a href="#SetNativeMethodPrefixes"><b>SetNativeMethodPrefixes</b></a> 
</li>
<li>
<a href="#RawMonitorEnter"><b>RawMonitorEnter</b></a> 
</li>
<li>
<a href="#RawMonitorExit"><b>RawMonitorExit</b></a> 
</li>
<li>
<a href="#RawMonitorWait"><b>RawMonitorWait</b></a> 
</li>
<li>
<a href="#RawMonitorNotify"><b>RawMonitorNotify</b></a> 
</li>
<li>
<a href="#RawMonitorNotifyAll"><b>RawMonitorNotifyAll</b></a> 
</li>
<li>
<a href="#GetCapabilities"><b>GetCapabilities</b></a> 
</li>
<li>
<a href="#GetTimerInfo"><b>GetTimerInfo</b></a> 
</li>
<li>
<a href="#GetTime"><b>GetTime</b></a> 
</li>
<li>
<a href="#GetAvailableProcessors"><b>GetAvailableProcessors</b></a> 
</li>
<li>
<a href="#GetPhase"><b>GetPhase</b></a> 
</li>
<li>
<a href="#DisposeEnvironment"><b>DisposeEnvironment</b></a> 
</li>
<li>
<a href="#SetEnvironmentLocalStorage"><b>SetEnvironmentLocalStorage</b></a> 
</li>
<li>
<a href="#GetEnvironmentLocalStorage"><b>GetEnvironmentLocalStorage</b></a> 
</li>
<li>
<a href="#GetVersionNumber"><b>GetVersionNumber</b></a> 
</li>
<li>
<a href="#GetErrorName"><b>GetErrorName</b></a> 
</li>
<li>
<a href="#SetVerboseFlag"><b>SetVerboseFlag</b></a> 
</li>
<li>
<a href="#GetJLocationFormat"><b>GetJLocationFormat</b></a> 
</li>
</ul>
JNI 함수 (호출 API 를 제외한다)는, 개시 단계 또는 라이브 단계에서 사용할 필요가 있습니다.
          <p></p>
대부분의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 이벤트는, 라이브 단계에서 밖에 송신되지 않습니다. 다음의 이벤트는, 그 외의 단계에서 다루어집니다.
          <ul>
<li>
<a href="#ThreadStart"><b>ThreadStart</b></a> 
</li>
<li>
<a href="#ThreadEnd"><b>ThreadEnd</b></a> 
</li>
<li>
<a href="#ClassLoad"><b>ClassLoad</b></a> 
</li>
<li>
<a href="#ClassPrepare"><b>ClassPrepare</b></a> 
</li>
<li>
<a href="#VMStart"><b>VMStart</b></a> 
</li>
</ul>          
          
<ul>
<li>
<a href="#NativeMethodBind"><b>NativeMethodBind</b></a> 
</li>
<li>
<a href="#ClassFileLoadHook"><b>ClassFileLoadHook</b></a> 
</li>
<li>
<a href="#DynamicCodeGenerated"><b>DynamicCodeGenerated</b></a> 
</li>
</ul>          
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
아니오
    </td><td>133</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetPhase.phase_ptr">phase_ptr</code></td><td><code><a href="#jvmtiPhase">jvmtiPhase</a> *</code></td><td>
	    돌아왔을 때, 단계를 포인트 한다.
	  <p></p>에이전트는 <code>jvmtiPhase</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiPhase</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetPhase.phase_ptr"><code>phase__ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="DisposeEnvironment">
<h3>환경의 파기</h3>
<blockquote>
<pre>jvmtiError
DisposeEnvironment(jvmtiEnv* env)</pre>
</blockquote>
JNI <code>GetEnv</code> 로 작성된 JVM<small style="font-size: xx-small">&nbsp;</small>TI 접속을 정지합니다 (<a href="#environments">「JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경」</a>을 참조). 환경이 보관 유지하고 있던 모든 자원을 파기합니다.   
        
이 환경에 의해 중단된 thread는, 이 호출에 의해 재개되지 않습니다. 이것은 에이전트가 명시적으로 실시할 필요가 있습니다. 이 환경이 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수를 호출하는 것으로 할당한 메모리는, 해제되지 않습니다. 이것은, 에이전트가 <a href="#Deallocate"><code>Deallocate</code></a>  를 호출하는 것으로 명시적으로 실시할 수 있습니다. 이 환경에 의해 작성된 raw 모니터는 파기되지 않습니다. 이것은, 에이전트가 <a href="#DestroyRawMonitor"><code>DestroyRawMonitor</code></a>  를 호출하는 것으로 명시적으로 실시할 수 있습니다. 이 환경에 의해 작성된 raw 모니터상에서 대기하고 있는 thread 상태는, 어떤 영향도 받지 않습니다.
        <p></p>
이 환경의<a href="#SetNativeMethodPrefix">네이티브 메소드 접두사</a>는 모두 설정 해제됩니다. 에이전트는, 파기를 호출하기 전에 접두사 첨부 네이티브 메소드를 모두 삭제하지 않으면 안됩니다.
        <p></p>
이 환경에서 보관 유지되고 있는<a href="#capability">권한</a>은 모두 방폐됩니다.
        <p></p>
이 환경에 의해 유효화 된 이벤트는, 송신되지 않게 됩니다. 다만, 현재 실행중의 이벤트 핸들러는, 계속 실행됩니다. 실행중에 환경이 파기되어 무효가 될 가능성이 있는 이벤트 핸들러를 설계하려면 , 충분히 주의해 주세요.
        <p></p>
이 환경은, 이 호출뒤는 사용할 수 없습니다. 이 호출은 호출해 원래대로 돌아갑니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
아니오
    </td><td>127</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>를 돌려준다</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetEnvironmentLocalStorage">
<h3>환경 로컬 기억 영역의 설정</h3>
<blockquote>
<pre>jvmtiError
SetEnvironmentLocalStorage(jvmtiEnv* env,
            const void* data)</pre>
</blockquote>
	VM 는, 개개의 환경에 관련지을 수 있었던 포인터치를 포함합니다. 이 포인터치를 「환경 로컬인 기억 영역」이라고 부릅니다. 이 함수로 설정되지 않는 경우, 값은 <code>NULL</code> 가 됩니다. 에이전트는, 환경 고유의 정보를 포함하기 위해(때문에), 메모리를 할당할 수가 있습니다. 환경 로컬인 기억 영역을 설정하는 것으로써,<a href="#GetEnvironmentLocalStorage"><code>GetEnvironmentLocalStorage</code></a>  를 사용해 액세스 할 수 있게 됩니다.
	<p></p>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 환경 로컬인 기억 영역의 값을 설정하기 위해(때문에), 에이전트에 의해 불려 갑니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 는, 에이전트에 대해서, 환경마다의 정보를 기록하기 위해서 이용할 수 있는, 포인터 사이즈의 환경 로컬인 기억 영역을 제공합니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>148</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetEnvironmentLocalStorage.data">data</code></td><td><code>const void 
	     
	  *</code></td><td>
	    환경 로컬인 기억 영역에 입력하는 값.
	  <p></p>에이전트가 포인터를 건네준다. <code>data</code> 가 <code>NULL</code> 의 경우, 값은 <code>NULL</code> 로 설정된다.
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>를 돌려준다</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetEnvironmentLocalStorage">
<h3>환경 로컬 기억 영역의 취득</h3>
<blockquote>
<pre>jvmtiError
GetEnvironmentLocalStorage(jvmtiEnv* env,
            void** data_ptr)</pre>
</blockquote>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 환경 로컬인 기억 영역의 값을 취득하기 위해(때문에), 에이전트에 의해 불려 갑니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
이 함수는,<a href="#Heap">heap </a>반복 함수의 콜백으로부터 호출할 수 있다. <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  이벤트,<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  이벤트, 및 <a href="#ObjectFree"><code>ObjectFree</code></a>  이벤트의 이벤트 핸들러로부터의 호출도 가능하다.
    </td><td>147</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetEnvironmentLocalStorage.data_ptr">data_ptr</code></td><td><code>void**</code></td><td>
	    환경 로컬인 기억 영역의 값을 돌려주는 포인터. 환경 로컬인 기억 영역이 <a href="#SetEnvironmentLocalStorage"><code>SetEnvironmentLocalStorage</code></a>  로 설정되어 있지 않은 경우, 반환되는 포인터는 <code>NULL</code>.
	  <p></p>
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetEnvironmentLocalStorage.data_ptr"><code>data_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetVersionNumber">
<h3>버젼 번호의 취득</h3>
<blockquote>
<pre>jvmtiError
GetVersionNumber(jvmtiEnv* env,
            jint* version_ptr)</pre>
</blockquote>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 버젼이 <code>version_ptr</code> 에 의해 돌려주어집니다. 반환값은 버젼 식별자입니다. 버젼 식별자에는, 인터페이스의 형태와 메이저 버젼 번호, 마이너 버젼 번호, 마이크로 버젼 번호가 포함됩니다.
	<blockquote>
<a name="jvmtiVersionInterfaceTypes"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">버젼의 인터페이스의 형태</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_INTERFACE_JNI">JVMTI_VERSION_INTERFACE_JNI</code></td><td align="right">0x00000000</td><td>
	    JNI 의 <code>JVMTI_VERSION_MASK_INTERFACE_TYPE</code> 의 값.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_INTERFACE_JVMTI">JVMTI_VERSION_INTERFACE_JVMTI</code></td><td align="right">0x30000000</td><td>
	    JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 <code>JVMTI_VERSION_MASK_INTERFACE_TYPE</code> 의 값.
	  </td>
</tr>
</table>
</blockquote>
	
<blockquote>
<a name="jvmtiVersionMasks"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">버젼 마스크</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_MASK_INTERFACE_TYPE">JVMTI_VERSION_MASK_INTERFACE_TYPE</code></td><td align="right">0x70000000</td><td>
	    마스크에 의해, 인터페이스의 형태를 추출한다. 이것은 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수이므로,<code>JVMTI_VERSION_MASK_INTERFACE_TYPE</code> 로 마스크 된, 이 함수에 의해 반환되는 버젼의 값은, 항상 <code>JVMTI_VERSION_INTERFACE_JVMTI</code>.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_MASK_MAJOR">JVMTI_VERSION_MASK_MAJOR</code></td><td align="right">0x0FFF0000</td><td>
	    마스크에 의해, 메이저 버젼 번호를 추출한다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_MASK_MINOR">JVMTI_VERSION_MASK_MINOR</code></td><td align="right">0x0000FF00</td><td>
	    마스크에 의해, 마이너 버젼 번호를 추출한다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_MASK_MICRO">JVMTI_VERSION_MASK_MICRO</code></td><td align="right">0x000000FF</td><td>
	    마스크에 의해, 마이크로 버젼 번호를 추출한다.
	  </td>
</tr>
</table>
</blockquote>
	
<blockquote>
<a name="jvmtiVersionShifts"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">버젼 쉬프트</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_SHIFT_MAJOR">JVMTI_VERSION_SHIFT_MAJOR</code></td><td align="right">16</td><td>
	    쉬프트에 의해, 메이저 버젼 번호를 추출한다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_SHIFT_MINOR">JVMTI_VERSION_SHIFT_MINOR</code></td><td align="right">8</td><td>
	    쉬프트에 의해, 마이너 버젼 번호를 추출한다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_SHIFT_MICRO">JVMTI_VERSION_SHIFT_MICRO</code></td><td align="right">0</td><td>
	    쉬프트에 의해, 마이크로 버젼 번호를 추출한다.
	  </td>
</tr>
</table>
</blockquote>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
아니오
    </td><td>88</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetVersionNumber.version_ptr">version_ptr</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	    돌아왔을 때, JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 버젼을 포인트 한다.
	  <p></p>에이전트는 <code>jint</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jint</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetVersionNumber.version_ptr"><code>version_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetErrorName">
<h3>에러명의 취득</h3>
<blockquote>
<pre>jvmtiError
GetErrorName(jvmtiEnv* env,
            jvmtiError error,
            char** name_ptr)</pre>
</blockquote>
<a href="#ErrorSection">에러 코드</a>의 상징적명을 돌려줍니다.   
        <p></p>
	예를 들어,<code>GetErrorName(env, JVMTI_ERROR_NONE, &err_name)</code> 는,<code>err_name</code> 에 캐릭터 라인 <code>"JVMTI_ERROR_NONE"</code> 를 돌려줍니다.
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
아니오
    </td><td>128</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetErrorName.error">error</code></td><td><code><a href="#jvmtiError">jvmtiError</a> </code></td><td>
	    에러 코드.
	  </td>
</tr>
<tr>
<td><code id="GetErrorName.name_ptr">name_ptr</code></td><td><code>char**</code></td><td>
	    돌아왔을 때, 에러명을 포인트 한다. 이름은,<a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 되지만, ASCII 부분집합에 제한된다.
	  <p></p>에이전트는 <code>char*</code> 에 포인터를 건네준다. <code>char*</code> 는, 새롭게 할당할 수 있었던 배열을 포인트 한다. 이 배열은,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 해제할 필요가 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#GetErrorName.error"><code>error</code></a>  는 jvmtiError 는 아니다.
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetErrorName.name_ptr"><code>name_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="SetVerboseFlag">
<h3>장황 플래그의 설정</h3>
<blockquote>
<pre>
typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;</pre>
<pre>jvmtiError
SetVerboseFlag(jvmtiEnv* env,
            jvmtiVerboseFlag flag,
            jboolean value)</pre>
</blockquote>
	
<blockquote>
<a name="jvmtiVerboseFlag"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">장황 플래그의 열거 (<code>jvmtiVerboseFlag</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_VERBOSE_OTHER">JVMTI_VERBOSE_OTHER</code></td><td align="right">0</td><td>
	    장황 출력 (이하를 제외하다).
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERBOSE_GC">JVMTI_VERBOSE_GC</code></td><td align="right">1</td><td>
	    장황 가비지 컬렉터 출력 (<code>-verbose:gc</code> 로 지정된 것과 같이).
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERBOSE_CLASS">JVMTI_VERBOSE_CLASS</code></td><td align="right">2</td><td>
	    장황 클래스 로드 출력 (<code>-verbose:class</code> 로 지정된 것과 같이).
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERBOSE_JNI">JVMTI_VERBOSE_JNI</code></td><td align="right">4</td><td>
	    장황 JNI 출력 (<code>-verbose:jni</code> 로 지정된 것과 같이).
	  </td>
</tr>
</table>
</blockquote>
	장황 출력을 제어합니다. 이것은, 일반적으로 <code>stderr</code> 에 송신되는 출력입니다.  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
아니오
    </td><td>150</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SetVerboseFlag.flag">flag</code></td><td><code><a href="#jvmtiVerboseFlag">jvmtiVerboseFlag</a> </code></td><td>
	    어느 장황 플래그를 설정할까.
	  </td>
</tr>
<tr>
<td><code id="SetVerboseFlag.value">value</code></td><td><code><a href="#jboolean">jboolean</a> </code></td><td>
	    플래그의 새로운 값.
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a> </td><td>
	  <a href="#SetVerboseFlag.flag"><code>flag</code></a>  는 jvmtiVerboseFlag 는 아니다.
	  
	</td>
</tr>
</table>
<hr noshade="noshade" width="100%" size="1" id="GetJLocationFormat">
<h3>JLocation 형식의 취득</h3>
<blockquote>
<pre>
typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;</pre>
<pre>jvmtiError
GetJLocationFormat(jvmtiEnv* env,
            jvmtiJlocationFormat* format_ptr)</pre>
</blockquote>
가상 머신의 바이트 코드 인덱스를 참조하는 위치 정보로부터 최대의 기능을 얻을 수 있습니다만,<code>jlocation</code> 의 정의는, 이 정보를 가지지 않는 VM 구현을 허가하기 위해(때문에), 의도적으로 제약을 받고 있지 않습니다.
        <p></p>
이 함수는, 이 VM 로 사용되는 <code>jlocation</code> 의 표현을 설명합니다. 반환되는 형식이 <a href="#JVMTI_JLOCATION_JVMBCI"><code>JVMTI_JLOCATION_JVMBCI</code></a>  의 경우,<code>jlocation</code> 를,<a href="#GetBytecodes"><code>GetBytecodes</code></a>  로부터 반환되는 배열의 인덱스로서 사용할 수 있습니다.   
	<blockquote>
<a name="jvmtiJlocationFormat"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">JLocation 의 형식의 열거 (<code>jvmtiJlocationFormat</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_JLOCATION_JVMBCI">JVMTI_JLOCATION_JVMBCI</code></td><td align="right">1</td><td>
	    <code>jlocation</code> 의 값은, 가상 머신의 바이트 코드 인덱스를 나타낸다. 즉, 메소드의 가상 머신 코드의 오프셋(offset).
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JLOCATION_MACHINEPC">JVMTI_JLOCATION_MACHINEPC</code></td><td align="right">2</td><td>
	    <code>jlocation</code> 의 값은, 네이티브 머신의 프로그램 카운터치를 나타낸다.
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JLOCATION_OTHER">JVMTI_JLOCATION_OTHER</code></td><td align="right">0</td><td>
	    <code>jlocation</code> 의 값은, 그 외의 표현을 가진다.
	  </td>
</tr>
</table>
</blockquote>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#heapCallbacks">콜백 안전</a> </td><td><a href="#FunctionTable">위치</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
어느 단계에서도 호출할 수 있다
</td><td>
아니오
    </td><td>129</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="GetJLocationFormat.format_ptr">format_ptr</code></td><td><code><a href="#jvmtiJlocationFormat">jvmtiJlocationFormat</a> *</code></td><td>
	    돌아왔을 때,<code>jlocation</code> 치의 형식 식별자를 포인트 한다.
	  <p></p>에이전트는 <code>jvmtiJlocationFormat</code> 에 포인터를 건네준다. 돌아왔을 때,<code>jvmtiJlocationFormat</code> 가 설정되어 있다.  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
에러
      </td>
</tr>
<tr>
<td colspan="2">
이 함수는,<a href="#universal-error">범용 에러</a>, 또는 다음의 에러의 어느쪽이든을 돌려준다
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
에러
          </td><td>
설명
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a> </td><td>
	  <a href="#GetJLocationFormat.format_ptr"><code>format_ptr</code></a>  가 <code>NULL</code>.
	  
	</td>
</tr>
</table>
<p id="ErrorSection"></p>
<p></p>
<hr noshade="noshade" size="3">
<h2>
에러
  </h2>
<p></p>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수는 모두,<b><code>jvmtiError</code></b> 에러 코드를 돌려줍니다.
    <p></p>
에이전트는, 유효한 파라미터를 가지는 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수를, 적절한 문맥 (예를 들어, 호출측 thread가 접속되고 있어, 단계가 적절)으로 호출합니다. 구현에 의해, 일부의 에러 조건의 검출이 곤란하거나 비효율적이거나 불가능해 있기도 합니다. 구현은,<a href="#reqerrors">「함수 고유의 필수 에러」</a>에 일람 되고 있는 에러를 검출할 필요가 있습니다. 그 외의 에러는, 에러 조건에 대한 추천 되고 있는 응답을 나타냅니다.  
  <p></p>
<h3 id="universal-error">범용 에러</h3>
다음의 에러는, 어느 함수로부터도 돌려주어질 가능성이 있는 에러입니다.
    <p></p>
<dl>
<dt>
<code id="JVMTI_ERROR_NONE">JVMTI_ERROR_NONE (0)</code>
</dt>
<dd>
에러는 발생하지 않았다. 함수의 실행이 정상적으로 종료했을 때에 반환되는 에러 코드.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NULL_POINTER">JVMTI_ERROR_NULL_POINTER (100)</code>
</dt>
<dd>
포인터가 <code>NULL</code>.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_OUT_OF_MEMORY">JVMTI_ERROR_OUT_OF_MEMORY (110)</code>
</dt>
<dd>
함수로 메모리의 할당이 시행되었지만, 더 이상 할당할 수 있는 메모리가 없었다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_ACCESS_DENIED">JVMTI_ERROR_ACCESS_DENIED (111)</code>
</dt>
<dd>
이 가상 머신에서는 필요한 기능이 유효하게 되지 않았다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNATTACHED_THREAD">JVMTI_ERROR_UNATTACHED_THREAD (115)</code>
</dt>
<dd>
이 함수의 호출에 사용되고 있는 thread가, 가상 머신에 접속되어 있지 않다. 호출은, 접속된 thread로부터 실시할 필요가 있다. JNI 호출 API 의 <code>AttachCurrentThread</code> 를 참조.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_ENVIRONMENT">JVMTI_ERROR_INVALID_ENVIRONMENT (116)</code>
</dt>
<dd>
지정된 JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경은 이제 접속되어 있지 않은, 또는 환경은 아니다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_WRONG_PHASE">JVMTI_ERROR_WRONG_PHASE (112)</code>
</dt>
<dd>
현재의<a href="#GetPhase">단계</a>에서는, 필요한 기능을 사용할 수 없다. 가상 머신이 실행을 완료하고 있는 경우, 항상 반환된다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INTERNAL">JVMTI_ERROR_INTERNAL (113)</code>
</dt>
<dd>
예기치 않은 내부 에러가 발생했다.
    <p></p>
</dd>
</dl>
<p></p>
<h3 id="reqerrors">함수 고유의 필수 에러</h3>
일부의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수는, 다음의 에러를 돌려줍니다. 이러한 에러는, 조건이 채워졌을 때, 구현에 의해 돌려주어질 필요가 있습니다.
    <p></p>
<dl>
<dt>
<code id="JVMTI_ERROR_INVALID_PRIORITY">JVMTI_ERROR_INVALID_PRIORITY (12)</code>
</dt>
<dd>
무효인 우선 순위.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_THREAD_NOT_SUSPENDED">JVMTI_ERROR_THREAD_NOT_SUSPENDED (13)</code>
</dt>
<dd>
thread는 중단되어 있지 않다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_THREAD_SUSPENDED">JVMTI_ERROR_THREAD_SUSPENDED (14)</code>
</dt>
<dd>
thread는 벌써 중단되고 있다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_THREAD_NOT_ALIVE">JVMTI_ERROR_THREAD_NOT_ALIVE (15)</code>
</dt>
<dd>
이 조작을 실시하려면 , thread가 활동중 (개시되어 아직 종료하고 있지 않다)이 아니면 안된다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_CLASS_NOT_PREPARED">JVMTI_ERROR_CLASS_NOT_PREPARED (22)</code>
</dt>
<dd>
클래스가 로드 되고 있지만, 아직 준비되어 있지 않다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NO_MORE_FRAMES">JVMTI_ERROR_NO_MORE_FRAMES (31)</code>
</dt>
<dd>
지정된 깊이에, Java 프로그램 언어 또는 JNI 스택 프레임이 존재하지 않는다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_OPAQUE_FRAME">JVMTI_ERROR_OPAQUE_FRAME (32)</code>
</dt>
<dd>
프레임의 정보를 입수할 수 없다 (네이티브 프레임의 경우 등).
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_DUPLICATE">JVMTI_ERROR_DUPLICATE (40)</code>
</dt>
<dd>
벌써 설정된 항목.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NOT_FOUND">JVMTI_ERROR_NOT_FOUND (41)</code>
</dt>
<dd>
목적의 요소 (필드나 breakpoint등)가 발견되지 않는다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NOT_MONITOR_OWNER">JVMTI_ERROR_NOT_MONITOR_OWNER (51)</code>
</dt>
<dd>
이 thread는 raw 모니터를 소유하고 있지 않다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INTERRUPT">JVMTI_ERROR_INTERRUPT (52)</code>
</dt>
<dd>
호출의 완료전에 끼어들어졌다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNMODIFIABLE_CLASS">JVMTI_ERROR_UNMODIFIABLE_CLASS (79)</code>
</dt>
<dd>
클래스는 변경할 수 없다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NOT_AVAILABLE">JVMTI_ERROR_NOT_AVAILABLE (98)</code>
</dt>
<dd>
이 기능은 이 가상 머신에서는 사용할 수 없다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_ABSENT_INFORMATION">JVMTI_ERROR_ABSENT_INFORMATION (101)</code>
</dt>
<dd>
요구된 정보를 입수할 수 없다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_EVENT_TYPE">JVMTI_ERROR_INVALID_EVENT_TYPE (102)</code>
</dt>
<dd>
지정된 이벤트형의 ID 가 인식되지 않는다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NATIVE_METHOD">JVMTI_ERROR_NATIVE_METHOD (104)</code>
</dt>
<dd>
요구된 정보가 네이티브 메소드로 사용할 수 없다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED">JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED (106)</code>
</dt>
<dd>
클래스 로더가 이 조작을 지원하지 않는다.
    <p></p>
</dd>
</dl>
<p></p>
<h3 id="function-specific-errors">함수 고유의 에이전트 에러</h3>
다음의 에러는, 일부의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수로부터 돌려주어질 가능성이 있는 에러입니다. 이러한 에러는, 에이전트에 의해 무효인 파라미터가 건네받았을 경우나, 무효인 문맥으로 사용되었을 경우에 돌려주어집니다. 이러한 에러는, 구현없이 검출할 수 있습니다.
    <p></p>
<dl>
<dt>
<code id="JVMTI_ERROR_INVALID_THREAD">JVMTI_ERROR_INVALID_THREAD (10)</code>
</dt>
<dd>
건네받은 thread는 유효한 thread는 아니다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_FIELDID">JVMTI_ERROR_INVALID_FIELDID (25)</code>
</dt>
<dd>
무효인 필드.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_METHODID">JVMTI_ERROR_INVALID_METHODID (23)</code>
</dt>
<dd>
무효인 메소드.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_LOCATION">JVMTI_ERROR_INVALID_LOCATION (24)</code>
</dt>
<dd>
무효인 위치.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_OBJECT">JVMTI_ERROR_INVALID_OBJECT (20)</code>
</dt>
<dd>
무효인 객체.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_CLASS">JVMTI_ERROR_INVALID_CLASS (21)</code>
</dt>
<dd>
무효인 클래스.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_TYPE_MISMATCH">JVMTI_ERROR_TYPE_MISMATCH (34)</code>
</dt>
<dd>
사용한 함수와 변수의 형태가 맞지 않는다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_SLOT">JVMTI_ERROR_INVALID_SLOT (35)</code>
</dt>
<dd>
무효인 슬롯.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_MUST_POSSESS_CAPABILITY">JVMTI_ERROR_MUST_POSSESS_CAPABILITY (99)</code>
</dt>
<dd>
이 환경에서 사용되는 권한이 false.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_THREAD_GROUP">JVMTI_ERROR_INVALID_THREAD_GROUP (11)</code>
</dt>
<dd>
thread 그룹이 무효.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_MONITOR">JVMTI_ERROR_INVALID_MONITOR (50)</code>
</dt>
<dd>
무효인 raw 모니터.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_ILLEGAL_ARGUMENT">JVMTI_ERROR_ILLEGAL_ARGUMENT (103)</code>
</dt>
<dd>
부정한 인수.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_TYPESTATE">JVMTI_ERROR_INVALID_TYPESTATE (65)</code>
</dt>
<dd>
thread 상태가 변경되었기 때문에, 부정합이 생기고 있다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_VERSION">JVMTI_ERROR_UNSUPPORTED_VERSION (68)</code>
</dt>
<dd>
새로운 클래스 파일의 버젼이 이 VM 로 지원되어 있지 않다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_CLASS_FORMAT">JVMTI_ERROR_INVALID_CLASS_FORMAT (60)</code>
</dt>
<dd>
새로운 클래스 파일의 형식이 올바르지 않다 (VM <code>ClassFormatError</code> 를 돌려준다).
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION">JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION (61)</code>
</dt>
<dd>
새로운 클래스 파일의 정의가 순환 정의가 된다 (VM 는 <code>ClassCircularityError</code> 를 돌려준다).
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED">JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED (63)</code>
</dt>
<dd>
새로운 클래스 파일로 메소드의 추가가 필요.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED">JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED (64)</code>
</dt>
<dd>
새로운 클래스의 버젼에 의해 필드가 변경된다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_FAILS_VERIFICATION">JVMTI_ERROR_FAILS_VERIFICATION (62)</code>
</dt>
<dd>
클래스 바이트가 검증에 실패한다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED">JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED (66)</code>
</dt>
<dd>
새로운 클래스의 버젼의 직접 슈퍼 클래스가 다르다, 또는 직접 구현되고 있는 인터페이스가 다르다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED">JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED (67)</code>
</dt>
<dd>
새로운 클래스의 버젼에서는 구클래스의 버젼으로 선언한 메소드를 선언하지 않는다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NAMES_DONT_MATCH">JVMTI_ERROR_NAMES_DONT_MATCH (69)</code>
</dt>
<dd>
새로운 클래스 파일내에서 정의된 클래스명이, 구클래스 객체내의 이름과 다르다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED">JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED (70)</code>
</dt>
<dd>
새로운 클래스의 버젼의 수식자가 다르다.
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED">JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED (71)</code>
</dt>
<dd>
새로운 클래스의 버젼의 메소드의 수식자가 구클래스의 버젼의 수식자와 다르다.
    <p></p>
</dd>
</dl>
<p></p>
<p></p>
<p id="DataSection"></p>
<p></p>
<hr noshade="noshade" size="3">
<h2>
데이터형
  </h2>
<p></p>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 는, JNI 에 의해 정의된 데이터형을 확장합니다.
  <p id="jniTypes"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">JVMTI 로 사용하는 JNI 의 형태</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code>jboolean</code></td><td><a name="jboolean"></a>  Java 프로그램 언어 <code>boolean</code> 를 보관 유지한다. 부호 없음 8 비트.
      </td>
</tr>
<tr>
<td><code>jint</code></td><td><a name="jint"></a>  Java 프로그램 언어 <code>int</code> 를 보관 유지한다. 부호 첨부 32 비트.
      </td>
</tr>
<tr>
<td><code>jlong</code></td><td><a name="jlong"></a>  Java 프로그램 언어 <code>long</code> 를 보관 유지한다. 부호 첨부 64 비트.
      </td>
</tr>
<tr>
<td><code>jfloat</code></td><td><a name="jfloat"></a>  Java 프로그램 언어 <code>float</code> 를 보관 유지한다. 32 비트.
      </td>
</tr>
<tr>
<td><code>jdouble</code></td><td><a name="jdouble"></a>  Java 프로그램 언어 <code>double</code> 를 보관 유지한다. 64 비트.
      </td>
</tr>
<tr>
<td><code>jobject</code></td><td><a name="jobject"></a>  Java 프로그램 언어 객체를 보관 유지한다.  
      </td>
</tr>
<tr>
<td><code>jclass</code></td><td><a name="jclass"></a>  Java 프로그램 언어 클래스를 보관 유지한다.  
      </td>
</tr>
<tr>
<td><code>jvalue</code></td><td><a name="jvalue"></a>  모든 원시형 및 <code>jobject</code> 의 화집합이다. 즉, Java 프로그램 언어의 임의의 값을 보관 유지한다.  
      </td>
</tr>
<tr>
<td><code>jfieldID</code></td><td><a name="jfieldID"></a>  Java 프로그램 언어의 필드를 식별한다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 함수나 이벤트로부터 반환된 <code>jfieldID</code> 는, 안전하게 포함할 수 있다.
      </td>
</tr>
<tr>
<td><code>jmethodID</code></td><td><a name="jmethodID"></a>  Java 프로그램 언어 메소드, 이니샤라이자, 또는 생성자 을 식별한다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 함수나 이벤트로부터 반환된 <code>jmethodID</code> 는, 안전하게 포함할 수 있다. 다만, 클래스가 언로드되었을 경우, 그것들은 무효가 되므로 사용해선 안 된다.
      </td>
</tr>
<tr>
<td><code>JNIEnv</code></td><td><a name="JNIEnv"></a>  JNI 함수 테이블의 포인터. <code>JNIEnv *</code> 의 포인터는 JNI 환경.  
      </td>
</tr>
</table>
<p id="jvmtiTypes"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">JVMTI 기저형</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code>jvmtiEnv *</code></td><td><a name="jvmtiEnv"></a>  JVM<small style="font-size: xx-small">&nbsp;</small>TI <a href="#environments">환경</a>의 포인터. <a href="#FunctionSection">「함수」</a>를 참조. <code>jvmtiEnv</code> 는<a href="#FunctionTable">함수 테이블</a>의 포인터를 포인트 한다.
      </td>
</tr>
<tr>
<td rowspan="2"><code>jthread</code></td><td><a name="jthread"></a>  thread를 보관 유지하는 <a href="#jobject"><code>jobject</code></a>  의 subtype.
      </td>
</tr>
<tr>
<td>
<pre>typedef jobject jthread;</pre>
</td>
</tr>
<tr>
<td rowspan="2"><code>jthreadGroup</code></td><td><a name="jthreadGroup"></a>  thread 그룹을 보관 유지하는 <a href="#jobject"><code>jobject</code></a>  의 subtype.
      </td>
</tr>
<tr>
<td>
<pre>typedef jobject jthreadGroup;</pre>
</td>
</tr>
<tr>
<td rowspan="2"><code>jlocation</code></td><td><a name="jlocation"></a> 64 비트의 값으로, 메소드내에서 단조롭게 증가하는 실행 가능 위치를 나타낸다. <code>-1</code> (은)는 네이티브 메소드를 나타낸다. 지정의 VM 의 형식에 대해서는,<a href="#GetJLocationFormat"><code>GetJLocationFormat</code></a>  를 참조.
      </td>
</tr>
<tr>
<td>
<pre>typedef jlong jlocation;</pre>
</td>
</tr>
<tr>
<td rowspan="2"><code>jrawMonitorID</code></td><td><a name="jrawMonitorID"></a> raw 모니터.
      </td>
</tr>
<tr>
<td>
<pre>struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;</pre>
</td>
</tr>
<tr>
<td><code>jvmtiError</code></td><td><a name="jvmtiError"></a>  귀가 에러 코드를 보관 유지한다. 가능한 값에 대해서는,<a href="#ErrorSection">「에러」</a>를 참조.
	<blockquote>
<pre>
typedef enum { 
    JVMTI_ERROR_NONE = 0,  
    JVMTI_ERROR_INVALID_THREAD = 10,
      ... 
} jvmtiError;
</pre>
</blockquote>
      
</td>
</tr>
<tr>
<td><code>jvmtiEvent</code></td><td><a name="jvmtiEvent"></a>  이벤트형의 식별자. 가능한 값에 대해서는,<a href="#EventSection">「이벤트」</a>를 참조. 이 스펙의 장래의 버젼에서는, 이벤트형 식별자로서 제로를 할당할 수 없는 것이 보증된다.
<blockquote>
<pre>
typedef enum { 
    JVMTI_EVENT_SINGLE_STEP = 1, 
    JVMTI_EVENT_BREAKPOINT = 2, 
      ... 
} jvmtiEvent;
</pre>
</blockquote>
      
</td>
</tr>
<tr>
<td><code>jvmtiEventCallbacks</code></td><td><a name="jvmtiEventCallbacks"></a>  이벤트용 콜백.
<blockquote>
<pre>
typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
      ... 
} jvmtiEventCallbacks;
</pre>
</blockquote>
완전한 구조에 대해서는<a href="#jvmtiEventCallbacks">이벤트 콜백</a>을 참조.
        <p></p>
예를 들어, VM 초기화 콜백은 다음과 같이 정의된다.
<blockquote>
<pre>
typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env, 
     JNIEnv* jni_env,
     jthread thread);
</pre>
</blockquote>
콜백 함수의 정의에 대해서는 개개의 이벤트를 참조.
      </td>
</tr>
<tr>
<td rowspan="2"><code>jniNativeInterface</code></td><td><a name="jniNativeInterface"></a> <a href="http://java.sun.com/javase/6/docs/guide/jni/spec/functions.html#wp23720">JNI 스펙</a>으로 정의된 JNI 함수 테이블 <code>JNINativeInterface</code> 의 형태 식별자. JNI 참조 구현에서는, 밑줄 첨부로 정의된다.
      </td>
</tr>
<tr>
<td>
<pre>typedef struct JNINativeInterface_ jniNativeInterface;</pre>
</td>
</tr>
</table>
<p></p>
<a name="StructureTypeDefinitions"></a> 
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
구조형의 정의
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><a href="#jvmtiAddrLocationMap"><code>jvmtiAddrLocationMap</code></a> </td><td>위치 엔트리의 네이티브 주소</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities"><code>jvmtiCapabilities</code></a> </td><td>권한의 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiClassDefinition"><code>jvmtiClassDefinition</code></a> </td><td>클래스의 재정의의 설명</td>
</tr>
<tr>
<td><a href="#jvmtiExtensionEventInfo"><code>jvmtiExtensionEventInfo</code></a> </td><td>확장 이벤트 정보</td>
</tr>
<tr>
<td><a href="#jvmtiExtensionFunctionInfo"><code>jvmtiExtensionFunctionInfo</code></a> </td><td>확장 함수 정보</td>
</tr>
<tr>
<td><a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a> </td><td>스택 프레임 정보 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiHeapCallbacks"><code>jvmtiHeapCallbacks</code></a> </td><td>heap 콜백 함수 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfo"><code>jvmtiHeapReferenceInfo</code></a> </td><td>참조 정보 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfoArray"><code>jvmtiHeapReferenceInfoArray</code></a> </td><td>배열 참조용의 참조 정보 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfoConstantPool"><code>jvmtiHeapReferenceInfoConstantPool</code></a> </td><td>정수 풀 참조용의 참조 정보 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfoField"><code>jvmtiHeapReferenceInfoField</code></a> </td><td>필드 참조용의 참조 정보 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfoJniLocal"><code>jvmtiHeapReferenceInfoJniLocal</code></a> </td><td>JNI 로컬 참조용의 참조 정보 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfoReserved"><code>jvmtiHeapReferenceInfoReserved</code></a> </td><td>그 외의 참조용의 참조 정보 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfoStackLocal"><code>jvmtiHeapReferenceInfoStackLocal</code></a> </td><td>국소 변수 참조용의 참조 정보 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiLineNumberEntry"><code>jvmtiLineNumberEntry</code></a> </td><td>행 번호 테이블의 엔트리</td>
</tr>
<tr>
<td><a href="#jvmtiLocalVariableEntry"><code>jvmtiLocalVariableEntry</code></a> </td><td>국소 변수 테이블의 엔트리</td>
</tr>
<tr>
<td><a href="#jvmtiMonitorStackDepthInfo"><code>jvmtiMonitorStackDepthInfo</code></a> </td><td>모니터 스택 깊이 정보 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiMonitorUsage"><code>jvmtiMonitorUsage</code></a> </td><td>객체 모니터의 사용 정보</td>
</tr>
<tr>
<td><a href="#jvmtiParamInfo"><code>jvmtiParamInfo</code></a> </td><td>확장 함수/이벤트 파라미터 정보</td>
</tr>
<tr>
<td><a href="#jvmtiStackInfo"><code>jvmtiStackInfo</code></a> </td><td>스택 정보 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiThreadGroupInfo"><code>jvmtiThreadGroupInfo</code></a> </td><td>thread 그룹 정보 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiThreadInfo"><code>jvmtiThreadInfo</code></a> </td><td>thread 정보 구조체</td>
</tr>
<tr>
<td><a href="#jvmtiTimerInfo"><code>jvmtiTimerInfo</code></a> </td><td>타이머 정보</td>
</tr>
</table>
<p></p>
<a name="FunctionTypeDefinitions"></a> 
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
함수형의 정의
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><a href="#jvmtiArrayPrimitiveValueCallback"><code>jvmtiArrayPrimitiveValueCallback</code></a> </td><td>배열 프리미티브(primitive)치 콜백</td>
</tr>
<tr>
<td><a href="#jvmtiExtensionEvent"><code>jvmtiExtensionEvent</code></a> </td><td>확장 이벤트</td>
</tr>
<tr>
<td><a href="#jvmtiExtensionFunction"><code>jvmtiExtensionFunction</code></a> </td><td>확장 함수</td>
</tr>
<tr>
<td><a href="#jvmtiHeapIterationCallback"><code>jvmtiHeapIterationCallback</code></a> </td><td>heap 반복 콜백</td>
</tr>
<tr>
<td><a href="#jvmtiHeapObjectCallback"><code>jvmtiHeapObjectCallback</code></a> </td><td>heap 객체의 콜백</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceCallback"><code>jvmtiHeapReferenceCallback</code></a> </td><td>heap 참조 콜백</td>
</tr>
<tr>
<td><a href="#jvmtiHeapRootCallback"><code>jvmtiHeapRootCallback</code></a> </td><td>heap 루트 객체의 콜백</td>
</tr>
<tr>
<td><a href="#jvmtiObjectReferenceCallback"><code>jvmtiObjectReferenceCallback</code></a> </td><td>객체 참조의 콜백</td>
</tr>
<tr>
<td><a href="#jvmtiPrimitiveFieldCallback"><code>jvmtiPrimitiveFieldCallback</code></a> </td><td>프리미티브(primitive) 필드 콜백</td>
</tr>
<tr>
<td><a href="#jvmtiReservedCallback"><code>jvmtiReservedCallback</code></a> </td><td>장래 사용하기 위해서 예약된 콜백</td>
</tr>
<tr>
<td><a href="#jvmtiStackReferenceCallback"><code>jvmtiStackReferenceCallback</code></a> </td><td>스택 참조 객체의 콜백</td>
</tr>
<tr>
<td><a href="#jvmtiStartFunction"><code>jvmtiStartFunction</code></a> </td><td>에이전트 기동 함수</td>
</tr>
<tr>
<td><a href="#jvmtiStringPrimitiveValueCallback"><code>jvmtiStringPrimitiveValueCallback</code></a> </td><td>캐릭터 라인 프리미티브(primitive)치 콜백</td>
</tr>
</table>
<p></p>
<a name="EnumerationDefinitions"></a> 
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
열거형의 정의
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><a href="#jvmtiEventMode"><code>jvmtiEventMode</code></a> </td><td>이벤트의 유효화와 무효화</td>
</tr>
<tr>
<td><a href="#jvmtiHeapObjectFilter"><code>jvmtiHeapObjectFilter</code></a> </td><td>heap 객체의 필터의 열거</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceKind"><code>jvmtiHeapReferenceKind</code></a> </td><td>heap 참조의 열거</td>
</tr>
<tr>
<td><a href="#jvmtiHeapRootKind"><code>jvmtiHeapRootKind</code></a> </td><td>heap 루트의 종류의 열거</td>
</tr>
<tr>
<td><a href="#jvmtiIterationControl"><code>jvmtiIterationControl</code></a> </td><td>반복 제어의 열거</td>
</tr>
<tr>
<td><a href="#jvmtiJlocationFormat"><code>jvmtiJlocationFormat</code></a> </td><td>JLocation 의 형식의 열거</td>
</tr>
<tr>
<td><a href="#jvmtiObjectReferenceKind"><code>jvmtiObjectReferenceKind</code></a> </td><td>객체 참조의 열거</td>
</tr>
<tr>
<td><a href="#jvmtiParamKind"><code>jvmtiParamKind</code></a> </td><td>확장 함수/이벤트 파라미터의 종류</td>
</tr>
<tr>
<td><a href="#jvmtiParamTypes"><code>jvmtiParamTypes</code></a> </td><td>확장 함수/이벤트 파라미터의 형태</td>
</tr>
<tr>
<td><a href="#jvmtiPhase"><code>jvmtiPhase</code></a> </td><td>실행의 단계</td>
</tr>
<tr>
<td><a href="#jvmtiPrimitiveType"><code>jvmtiPrimitiveType</code></a> </td><td>원시형의 열거</td>
</tr>
<tr>
<td><a href="#jvmtiTimerKind"><code>jvmtiTimerKind</code></a> </td><td>타이머의 종류</td>
</tr>
<tr>
<td><a href="#jvmtiVerboseFlag"><code>jvmtiVerboseFlag</code></a> </td><td>장황 플래그의 열거</td>
</tr>
</table>
<p></p>
<a name="FunctionTable"></a> 
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
함수 테이블의 레이아웃
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
위치
      </td><td>
기능
      </td><td>
선언
      </td>
</tr>
<tr>
<td align="right">  1</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved1;</pre>
</td>
</tr>
<tr>
<td align="right">  2</td><td><a href="#SetEventNotificationMode">이벤트 통지 모드의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env, 
                       jvmtiEventMode mode, 
                       jvmtiEvent event_type, 
                       jthread event_thread, 
                        ...);</pre>
</td>
</tr>
<tr>
<td align="right">  3</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved3;</pre>
</td>
</tr>
<tr>
<td align="right">  4</td><td><a href="#GetAllThreads">모든 thread의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env, 
                       jint* threads_count_ptr, 
                       jthread** threads_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  5</td><td><a href="#SuspendThread">thread의 중단</a> </td><td>
<pre>jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env, 
                       jthread thread);</pre>
</td>
</tr>
<tr>
<td align="right">  6</td><td><a href="#ResumeThread">thread의 재개</a> </td><td>
<pre>jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env, 
                       jthread thread);</pre>
</td>
</tr>
<tr>
<td align="right">  7</td><td><a href="#StopThread">thread의 정지</a> </td><td>
<pre>jvmtiError (JNICALL *StopThread) (jvmtiEnv* env, 
                       jthread thread, 
                       jobject exception);</pre>
</td>
</tr>
<tr>
<td align="right">  8</td><td><a href="#InterruptThread">thread의 인터럽트</a> </td><td>
<pre>jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env, 
                       jthread thread);</pre>
</td>
</tr>
<tr>
<td align="right">  9</td><td><a href="#GetThreadInfo">thread 정보의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env, 
                       jthread thread, 
                       jvmtiThreadInfo* info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  10</td><td><a href="#GetOwnedMonitorInfo">소유 모니터 정보의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env, 
                       jthread thread, 
                       jint* owned_monitor_count_ptr, 
                       jobject** owned_monitors_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  11</td><td><a href="#GetCurrentContendedMonitor">현재 경합 하고 있는 모니터의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env, 
                       jthread thread, 
                       jobject* monitor_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  12</td><td><a href="#RunAgentThread">에이전트 thread의 실행</a> </td><td>
<pre>jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env, 
                       jthread thread, 
                       jvmtiStartFunction proc, 
                       const void* arg, 
                       jint priority);</pre>
</td>
</tr>
<tr>
<td align="right">  13</td><td><a href="#GetTopThreadGroups">톱 레벨의 thread 그룹의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env, 
                       jint* group_count_ptr, 
                       jthreadGroup** groups_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  14</td><td><a href="#GetThreadGroupInfo">thread 그룹 정보의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env, 
                       jthreadGroup group, 
                       jvmtiThreadGroupInfo* info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  15</td><td><a href="#GetThreadGroupChildren">자 thread 그룹의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env, 
                       jthreadGroup group, 
                       jint* thread_count_ptr, 
                       jthread** threads_ptr, 
                       jint* group_count_ptr, 
                       jthreadGroup** groups_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  16</td><td><a href="#GetFrameCount">프레임 카운트의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env, 
                       jthread thread, 
                       jint* count_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  17</td><td><a href="#GetThreadState">thread 상태의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env, 
                       jthread thread, 
                       jint* thread_state_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  18</td><td><a href="#GetCurrentThread">현재의 thread의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env, 
                       jthread* thread_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  19</td><td><a href="#GetFrameLocation">프레임의 위치의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jmethodID* method_ptr, 
                       jlocation* location_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  20</td><td><a href="#NotifyFramePop">프레임의 팝의 통지</a> </td><td>
<pre>jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth);</pre>
</td>
</tr>
<tr>
<td align="right">  21</td><td><a href="#GetLocalObject">국소 변수의 취득 - 객체형</a> </td><td>
<pre>jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jobject* value_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  22</td><td><a href="#GetLocalInt">국소 변수의 취득 - 정수형</a> </td><td>
<pre>jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jint* value_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  23</td><td><a href="#GetLocalLong">국소 변수의 취득 - 장 정수형</a> </td><td>
<pre>jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jlong* value_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  24</td><td><a href="#GetLocalFloat">국소 변수의 취득 - 부동 소수점수(실수)형</a> </td><td>
<pre>jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jfloat* value_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  25</td><td><a href="#GetLocalDouble">국소 변수의 취득 - 배정밀도 부동 소수점수(실수)형</a> </td><td>
<pre>jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jdouble* value_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  26</td><td><a href="#SetLocalObject">국소 변수의 설정 - 객체형</a> </td><td>
<pre>jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jobject value);</pre>
</td>
</tr>
<tr>
<td align="right">  27</td><td><a href="#SetLocalInt">국소 변수의 설정 - 정수형</a> </td><td>
<pre>jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jint value);</pre>
</td>
</tr>
<tr>
<td align="right">  28</td><td><a href="#SetLocalLong">국소 변수의 설정 - 장 정수형</a> </td><td>
<pre>jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jlong value);</pre>
</td>
</tr>
<tr>
<td align="right">  29</td><td><a href="#SetLocalFloat">국소 변수의 설정 - 부동 소수점수(실수)형</a> </td><td>
<pre>jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jfloat value);</pre>
</td>
</tr>
<tr>
<td align="right">  30</td><td><a href="#SetLocalDouble">국소 변수의 설정 - 배정밀도 부동 소수점수(실수)형</a> </td><td>
<pre>jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jdouble value);</pre>
</td>
</tr>
<tr>
<td align="right">  31</td><td><a href="#CreateRawMonitor">raw 모니터의 작성</a> </td><td>
<pre>jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env, 
                       const char* name, 
                       jrawMonitorID* monitor_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  32</td><td><a href="#DestroyRawMonitor">raw 모니터의 파기</a> </td><td>
<pre>jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env, 
                       jrawMonitorID monitor);</pre>
</td>
</tr>
<tr>
<td align="right">  33</td><td><a href="#RawMonitorEnter">raw 모니터의 개시</a> </td><td>
<pre>jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env, 
                       jrawMonitorID monitor);</pre>
</td>
</tr>
<tr>
<td align="right">  34</td><td><a href="#RawMonitorExit">raw 모니터의 종료</a> </td><td>
<pre>jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env, 
                       jrawMonitorID monitor);</pre>
</td>
</tr>
<tr>
<td align="right">  35</td><td><a href="#RawMonitorWait">raw 모니터의 대기</a> </td><td>
<pre>jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env, 
                       jrawMonitorID monitor, 
                       jlong millis);</pre>
</td>
</tr>
<tr>
<td align="right">  36</td><td><a href="#RawMonitorNotify">raw 모니터의 통지</a> </td><td>
<pre>jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env, 
                       jrawMonitorID monitor);</pre>
</td>
</tr>
<tr>
<td align="right">  37</td><td><a href="#RawMonitorNotifyAll">raw 모니터의 통지 (모두)</a> </td><td>
<pre>jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env, 
                       jrawMonitorID monitor);</pre>
</td>
</tr>
<tr>
<td align="right">  38</td><td><a href="#SetBreakpoint">breakpoint의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env, 
                       jmethodID method, 
                       jlocation location);</pre>
</td>
</tr>
<tr>
<td align="right">  39</td><td><a href="#ClearBreakpoint">breakpoint의 해제</a> </td><td>
<pre>jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env, 
                       jmethodID method, 
                       jlocation location);</pre>
</td>
</tr>
<tr>
<td align="right">  40</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved40;</pre>
</td>
</tr>
<tr>
<td align="right">  41</td><td><a href="#SetFieldAccessWatch">필드 액세스의 감시의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field);</pre>
</td>
</tr>
<tr>
<td align="right">  42</td><td><a href="#ClearFieldAccessWatch">필드 액세스의 감시의 해제</a> </td><td>
<pre>jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field);</pre>
</td>
</tr>
<tr>
<td align="right">  43</td><td><a href="#SetFieldModificationWatch">필드 변경의 감시의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field);</pre>
</td>
</tr>
<tr>
<td align="right">  44</td><td><a href="#ClearFieldModificationWatch">필드 변경의 감시의 해제</a> </td><td>
<pre>jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field);</pre>
</td>
</tr>
<tr>
<td align="right">  45</td><td><a href="#IsModifiableClass">변경 가능 클래스인가 어떤가의 검사</a> </td><td>
<pre>jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env, 
                       jclass klass, 
                       jboolean* is_modifiable_class_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  46</td><td><a href="#Allocate">Allocate</a> </td><td>
<pre>jvmtiError (JNICALL *Allocate) (jvmtiEnv* env, 
                       jlong size, 
                       unsigned char** mem_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  47</td><td><a href="#Deallocate">Deallocate</a> </td><td>
<pre>jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env, 
                       unsigned char* mem);</pre>
</td>
</tr>
<tr>
<td align="right">  48</td><td><a href="#GetClassSignature">클래스의 시그니챠의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env, 
                       jclass klass, 
                       char** signature_ptr, 
                       char** generic_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  49</td><td><a href="#GetClassStatus">클래스의 상태의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* status_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  50</td><td><a href="#GetSourceFileName">원시 파일명의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env, 
                       jclass klass, 
                       char** source_name_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  51</td><td><a href="#GetClassModifiers">클래스의 수식자의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* modifiers_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  52</td><td><a href="#GetClassMethods">클래스의 메소드의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* method_count_ptr, 
                       jmethodID** methods_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  53</td><td><a href="#GetClassFields">클래스의 필드의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* field_count_ptr, 
                       jfieldID** fields_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  54</td><td><a href="#GetImplementedInterfaces">구현된 인터페이스의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* interface_count_ptr, 
                       jclass** interfaces_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  55</td><td><a href="#IsInterface">인터페이스인가 어떤가의 검사</a> </td><td>
<pre>jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env, 
                       jclass klass, 
                       jboolean* is_interface_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  56</td><td><a href="#IsArrayClass">배열 클래스인가 어떤가의 검사</a> </td><td>
<pre>jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env, 
                       jclass klass, 
                       jboolean* is_array_class_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  57</td><td><a href="#GetClassLoader">클래스 로더의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env, 
                       jclass klass, 
                       jobject* classloader_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  58</td><td><a href="#GetObjectHashCode">객체의 해시 코드의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env, 
                       jobject object, 
                       jint* hash_code_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  59</td><td><a href="#GetObjectMonitorUsage">객체의 모니터의 이용 정보를 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env, 
                       jobject object, 
                       jvmtiMonitorUsage* info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  60</td><td><a href="#GetFieldName">필드의 이름과 시그니챠의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field, 
                       char** name_ptr, 
                       char** signature_ptr, 
                       char** generic_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  61</td><td><a href="#GetFieldDeclaringClass">필드의 선언 클래스의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field, 
                       jclass* declaring_class_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  62</td><td><a href="#GetFieldModifiers">필드의 수식자의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field, 
                       jint* modifiers_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  63</td><td><a href="#IsFieldSynthetic">합성 필드인가 어떤가의 검사</a> </td><td>
<pre>jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field, 
                       jboolean* is_synthetic_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  64</td><td><a href="#GetMethodName">메소드의 이름과 시그니챠의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env, 
                       jmethodID method, 
                       char** name_ptr, 
                       char** signature_ptr, 
                       char** generic_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  65</td><td><a href="#GetMethodDeclaringClass">메소드의 선언 클래스의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env, 
                       jmethodID method, 
                       jclass* declaring_class_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  66</td><td><a href="#GetMethodModifiers">메소드의 수식자의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env, 
                       jmethodID method, 
                       jint* modifiers_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  67</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved67;</pre>
</td>
</tr>
<tr>
<td align="right">  68</td><td><a href="#GetMaxLocals">국소 변수의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env, 
                       jmethodID method, 
                       jint* max_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  69</td><td><a href="#GetArgumentsSize">인수의 사이즈의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env, 
                       jmethodID method, 
                       jint* size_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  70</td><td><a href="#GetLineNumberTable">행 번호 테이블의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env, 
                       jmethodID method, 
                       jint* entry_count_ptr, 
                       jvmtiLineNumberEntry** table_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  71</td><td><a href="#GetMethodLocation">메소드의 배치 위치의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env, 
                       jmethodID method, 
                       jlocation* start_location_ptr, 
                       jlocation* end_location_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  72</td><td><a href="#GetLocalVariableTable">국소 변수 테이블의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env, 
                       jmethodID method, 
                       jint* entry_count_ptr, 
                       jvmtiLocalVariableEntry** table_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  73</td><td><a href="#SetNativeMethodPrefix">네이티브 메소드 접두사의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env, 
                       const char* prefix);</pre>
</td>
</tr>
<tr>
<td align="right">  74</td><td><a href="#SetNativeMethodPrefixes">복수의 네이티브 메소드 접두사의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env, 
                       jint prefix_count, 
                       char** prefixes);</pre>
</td>
</tr>
<tr>
<td align="right">  75</td><td><a href="#GetBytecodes">바이트 코드의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env, 
                       jmethodID method, 
                       jint* bytecode_count_ptr, 
                       unsigned char** bytecodes_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  76</td><td><a href="#IsMethodNative">네이티브 메소드인가 어떤가의 검사</a> </td><td>
<pre>jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env, 
                       jmethodID method, 
                       jboolean* is_native_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  77</td><td><a href="#IsMethodSynthetic">합성 메소드인가 어떤가의 검사</a> </td><td>
<pre>jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env, 
                       jmethodID method, 
                       jboolean* is_synthetic_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  78</td><td><a href="#GetLoadedClasses">로드가 끝난 클래스의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env, 
                       jint* class_count_ptr, 
                       jclass** classes_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  79</td><td><a href="#GetClassLoaderClasses">클래스 로더 클래스의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env, 
                       jobject initiating_loader, 
                       jint* class_count_ptr, 
                       jclass** classes_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  80</td><td><a href="#PopFrame">프레임의 팝</a> </td><td>
<pre>jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env, 
                       jthread thread);</pre>
</td>
</tr>
<tr>
<td align="right">  81</td><td><a href="#ForceEarlyReturnObject">조기 복귀의 강제 - 객체형</a> </td><td>
<pre>jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env, 
                       jthread thread, 
                       jobject value);</pre>
</td>
</tr>
<tr>
<td align="right">  82</td><td><a href="#ForceEarlyReturnInt">조기 복귀의 강제 - 정수형</a> </td><td>
<pre>jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env, 
                       jthread thread, 
                       jint value);</pre>
</td>
</tr>
<tr>
<td align="right">  83</td><td><a href="#ForceEarlyReturnLong">조기 복귀의 강제 - 장 정수형</a> </td><td>
<pre>jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env, 
                       jthread thread, 
                       jlong value);</pre>
</td>
</tr>
<tr>
<td align="right">  84</td><td><a href="#ForceEarlyReturnFloat">조기 복귀의 강제 - 부동 소수점수(실수)형</a> </td><td>
<pre>jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env, 
                       jthread thread, 
                       jfloat value);</pre>
</td>
</tr>
<tr>
<td align="right">  85</td><td><a href="#ForceEarlyReturnDouble">조기 복귀의 강제 - 배정밀도 부동 소수점수(실수)형</a> </td><td>
<pre>jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env, 
                       jthread thread, 
                       jdouble value);</pre>
</td>
</tr>
<tr>
<td align="right">  86</td><td><a href="#ForceEarlyReturnVoid">조기 복귀의 강제 - void 형</a> </td><td>
<pre>jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env, 
                       jthread thread);</pre>
</td>
</tr>
<tr>
<td align="right">  87</td><td><a href="#RedefineClasses">클래스의 재정의</a> </td><td>
<pre>jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env, 
                       jint class_count, 
                       const jvmtiClassDefinition* class_definitions);</pre>
</td>
</tr>
<tr>
<td align="right">  88</td><td><a href="#GetVersionNumber">버젼 번호의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env, 
                       jint* version_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  89</td><td><a href="#GetCapabilities">기능의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env, 
                       jvmtiCapabilities* capabilities_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  90</td><td><a href="#GetSourceDebugExtension">소스 디버그 확장 기능의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env, 
                       jclass klass, 
                       char** source_debug_extension_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  91</td><td><a href="#IsMethodObsolete">폐기된 메소드인가 어떤가의 검사</a> </td><td>
<pre>jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env, 
                       jmethodID method, 
                       jboolean* is_obsolete_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  92</td><td><a href="#SuspendThreadList">threaded list의 중단</a> </td><td>
<pre>jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env, 
                       jint request_count, 
                       const jthread* request_list, 
                       jvmtiError* results);</pre>
</td>
</tr>
<tr>
<td align="right">  93</td><td><a href="#ResumeThreadList">threaded list의 재개</a> </td><td>
<pre>jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env, 
                       jint request_count, 
                       const jthread* request_list, 
                       jvmtiError* results);</pre>
</td>
</tr>
<tr>
<td align="right">  94</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved94;</pre>
</td>
</tr>
<tr>
<td align="right">  95</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved95;</pre>
</td>
</tr>
<tr>
<td align="right">  96</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved96;</pre>
</td>
</tr>
<tr>
<td align="right">  97</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved97;</pre>
</td>
</tr>
<tr>
<td align="right">  98</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved98;</pre>
</td>
</tr>
<tr>
<td align="right">  99</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved99;</pre>
</td>
</tr>
<tr>
<td align="right">  100</td><td><a href="#GetAllStackTraces">모든 스택 트레이스의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env, 
                       jint max_frame_count, 
                       jvmtiStackInfo** stack_info_ptr, 
                       jint* thread_count_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  101</td><td><a href="#GetThreadListStackTraces">threaded list의 스택 트레이스의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env, 
                       jint thread_count, 
                       const jthread* thread_list, 
                       jint max_frame_count, 
                       jvmtiStackInfo** stack_info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  102</td><td><a href="#GetThreadLocalStorage">thread 로컬인 기억 영역의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env, 
                       jthread thread, 
                       void** data_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  103</td><td><a href="#SetThreadLocalStorage">thread 로컬인 기억 영역의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env, 
                       jthread thread, 
                       const void* data);</pre>
</td>
</tr>
<tr>
<td align="right">  104</td><td><a href="#GetStackTrace">스택 트레이스의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env, 
                       jthread thread, 
                       jint start_depth, 
                       jint max_frame_count, 
                       jvmtiFrameInfo* frame_buffer, 
                       jint* count_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  105</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved105;</pre>
</td>
</tr>
<tr>
<td align="right">  106</td><td><a href="#GetTag">태그의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetTag) (jvmtiEnv* env, 
                       jobject object, 
                       jlong* tag_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  107</td><td><a href="#SetTag">태그의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetTag) (jvmtiEnv* env, 
                       jobject object, 
                       jlong tag);</pre>
</td>
</tr>
<tr>
<td align="right">  108</td><td><a href="#ForceGarbageCollection">가베지 컬렉션의 강제</a> </td><td>
<pre>jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);</pre>
</td>
</tr>
<tr>
<td align="right">  109</td><td><a href="#IterateOverObjectsReachableFromObject">객체로부터 도달 가능한 객체의 반복</a> </td><td>
<pre>jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env, 
                       jobject object, 
                       jvmtiObjectReferenceCallback object_reference_callback, 
                       const void* user_data);</pre>
</td>
</tr>
<tr>
<td align="right">  110</td><td><a href="#IterateOverReachableObjects">도달 가능한 객체의 반복</a> </td><td>
<pre>jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env, 
                       jvmtiHeapRootCallback heap_root_callback, 
                       jvmtiStackReferenceCallback stack_ref_callback, 
                       jvmtiObjectReferenceCallback object_ref_callback, 
                       const void* user_data);</pre>
</td>
</tr>
<tr>
<td align="right">  111</td><td><a href="#IterateOverHeap">heap의 반복</a> </td><td>
<pre>jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env, 
                       jvmtiHeapObjectFilter object_filter, 
                       jvmtiHeapObjectCallback heap_object_callback, 
                       const void* user_data);</pre>
</td>
</tr>
<tr>
<td align="right">  112</td><td><a href="#IterateOverInstancesOfClass">클래스의 인스턴스의 반복</a> </td><td>
<pre>jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env, 
                       jclass klass, 
                       jvmtiHeapObjectFilter object_filter, 
                       jvmtiHeapObjectCallback heap_object_callback, 
                       const void* user_data);</pre>
</td>
</tr>
<tr>
<td align="right">  113</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved113;</pre>
</td>
</tr>
<tr>
<td align="right">  114</td><td><a href="#GetObjectsWithTags">태그를 사용한 객체의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env, 
                       jint tag_count, 
                       const jlong* tags, 
                       jint* count_ptr, 
                       jobject** object_result_ptr, 
                       jlong** tag_result_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  115</td><td><a href="#FollowReferences">참조의 추적</a> </td><td>
<pre>jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env, 
                       jint heap_filter, 
                       jclass klass, 
                       jobject initial_object, 
                       const jvmtiHeapCallbacks* callbacks, 
                       const void* user_data);</pre>
</td>
</tr>
<tr>
<td align="right">  116</td><td><a href="#IterateThroughHeap">heap내에서의 반복해</a> </td><td>
<pre>jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env, 
                       jint heap_filter, 
                       jclass klass, 
                       const jvmtiHeapCallbacks* callbacks, 
                       const void* user_data);</pre>
</td>
</tr>
<tr>
<td align="right">  117</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved117;</pre>
</td>
</tr>
<tr>
<td align="right">  118</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved118;</pre>
</td>
</tr>
<tr>
<td align="right">  119</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved119;</pre>
</td>
</tr>
<tr>
<td align="right">  120</td><td><a href="#SetJNIFunctionTable">JNI 함수 테이블의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env, 
                       const jniNativeInterface* function_table);</pre>
</td>
</tr>
<tr>
<td align="right">  121</td><td><a href="#GetJNIFunctionTable">JNI 함수 테이블의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env, 
                       jniNativeInterface** function_table);</pre>
</td>
</tr>
<tr>
<td align="right">  122</td><td><a href="#SetEventCallbacks">이벤트 콜백의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env, 
                       const jvmtiEventCallbacks* callbacks, 
                       jint size_of_callbacks);</pre>
</td>
</tr>
<tr>
<td align="right">  123</td><td><a href="#GenerateEvents">이벤트의 생성</a> </td><td>
<pre>jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env, 
                       jvmtiEvent event_type);</pre>
</td>
</tr>
<tr>
<td align="right">  124</td><td><a href="#GetExtensionFunctions">확장 함수의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env, 
                       jint* extension_count_ptr, 
                       jvmtiExtensionFunctionInfo** extensions);</pre>
</td>
</tr>
<tr>
<td align="right">  125</td><td><a href="#GetExtensionEvents">확장 이벤트의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env, 
                       jint* extension_count_ptr, 
                       jvmtiExtensionEventInfo** extensions);</pre>
</td>
</tr>
<tr>
<td align="right">  126</td><td><a href="#SetExtensionEventCallback">확장 이벤트 콜백의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env, 
                       jint extension_event_index, 
                       jvmtiExtensionEvent callback);</pre>
</td>
</tr>
<tr>
<td align="right">  127</td><td><a href="#DisposeEnvironment">환경의 파기</a> </td><td>
<pre>jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);</pre>
</td>
</tr>
<tr>
<td align="right">  128</td><td><a href="#GetErrorName">에러명의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env, 
                       jvmtiError error, 
                       char** name_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  129</td><td><a href="#GetJLocationFormat">JLocation 형식의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env, 
                       jvmtiJlocationFormat* format_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  130</td><td><a href="#GetSystemProperties">시스템 프로퍼티의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env, 
                       jint* count_ptr, 
                       char*** property_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  131</td><td><a href="#GetSystemProperty">시스템 프로퍼티의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env, 
                       const char* property, 
                       char** value_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  132</td><td><a href="#SetSystemProperty">시스템 프로퍼티의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env, 
                       const char* property, 
                       const char* value);</pre>
</td>
</tr>
<tr>
<td align="right">  133</td><td><a href="#GetPhase">단계의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env, 
                       jvmtiPhase* phase_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  134</td><td><a href="#GetCurrentThreadCpuTimerInfo">현재의 thread의 CPU 타이머 정보를 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env, 
                       jvmtiTimerInfo* info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  135</td><td><a href="#GetCurrentThreadCpuTime">현재의 thread의 CPU 시간을 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env, 
                       jlong* nanos_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  136</td><td><a href="#GetThreadCpuTimerInfo">thread의 CPU 타이머 정보를 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env, 
                       jvmtiTimerInfo* info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  137</td><td><a href="#GetThreadCpuTime">thread의 CPU 시간을 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env, 
                       jthread thread, 
                       jlong* nanos_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  138</td><td><a href="#GetTimerInfo">타이머 정보의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env, 
                       jvmtiTimerInfo* info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  139</td><td><a href="#GetTime">시간의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetTime) (jvmtiEnv* env, 
                       jlong* nanos_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  140</td><td><a href="#GetPotentialCapabilities">잠재적인 권한의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env, 
                       jvmtiCapabilities* capabilities_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  141</td><td><i>예약이 끝난 상태</i></td><td>
<pre>void *reserved141;</pre>
</td>
</tr>
<tr>
<td align="right">  142</td><td><a href="#AddCapabilities">권한의 추가</a> </td><td>
<pre>jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env, 
                       const jvmtiCapabilities* capabilities_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  143</td><td><a href="#RelinquishCapabilities">권한의 방폐</a> </td><td>
<pre>jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env, 
                       const jvmtiCapabilities* capabilities_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  144</td><td><a href="#GetAvailableProcessors">사용 가능한 프로세서의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env, 
                       jint* processor_count_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  145</td><td><a href="#GetClassVersionNumbers">클래스 버젼 번호의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* minor_version_ptr, 
                       jint* major_version_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  146</td><td><a href="#GetConstantPool">정수 풀의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* constant_pool_count_ptr, 
                       jint* constant_pool_byte_count_ptr, 
                       unsigned char** constant_pool_bytes_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  147</td><td><a href="#GetEnvironmentLocalStorage">환경 로컬 기억 영역의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env, 
                       void** data_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  148</td><td><a href="#SetEnvironmentLocalStorage">환경 로컬 기억 영역의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env, 
                       const void* data);</pre>
</td>
</tr>
<tr>
<td align="right">  149</td><td><a href="#AddToBootstrapClassLoaderSearch">bootstrap 클래스 로더 검색의 추가</a> </td><td>
<pre>jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env, 
                       const char* segment);</pre>
</td>
</tr>
<tr>
<td align="right">  150</td><td><a href="#SetVerboseFlag">장황 플래그의 설정</a> </td><td>
<pre>jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env, 
                       jvmtiVerboseFlag flag, 
                       jboolean value);</pre>
</td>
</tr>
<tr>
<td align="right">  151</td><td><a href="#AddToSystemClassLoaderSearch">시스템 클래스 로더 검색의 추가</a> </td><td>
<pre>jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env, 
                       const char* segment);</pre>
</td>
</tr>
<tr>
<td align="right">  152</td><td><a href="#RetransformClasses">클래스의 재변환</a> </td><td>
<pre>jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env, 
                       jint class_count, 
                       const jclass* classes);</pre>
</td>
</tr>
<tr>
<td align="right">  153</td><td><a href="#GetOwnedMonitorStackDepthInfo">소유 모니터 스택 깊이 정보의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env, 
                       jthread thread, 
                       jint* monitor_info_count_ptr, 
                       jvmtiMonitorStackDepthInfo** monitor_info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  154</td><td><a href="#GetObjectSize">객체 사이즈의 취득</a> </td><td>
<pre>jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env, 
                       jobject object, 
                       jlong* size_ptr);</pre>
</td>
</tr>
</table>
<p></p>
<p id="EventSection"></p>
<p></p>
<hr noshade="noshade" size="3">
<h2>이벤트</h2>
<h4 id="eventIntro">이벤트의 처리</h4>
에이전트는, 응용 프로그램내에서 발생하는 많은 이벤트에 대한 통지를 받을 수가 있습니다.
    <p></p>
이벤트를 처리하려면 ,<a href="#SetEventCallbacks"><code>SetEventCallbacks</code></a>  를 사용해 콜백 함수세트를 지정합니다. 이벤트 마다, 대응하는 콜백 함수가 불려 갑니다. 콜백 함수의 인수는, 이벤트에 관한 추가 정보를 제공합니다.  
    <p></p>
콜백 함수는 일반적으로, 어플리케이션 thread내로부터 불려 갑니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 구현이 이벤트를 큐에 넣는 것은, 결코 없습니다. 이것은, 이벤트의 콜백 함수를 주의 깊게 기술할 필요가 있는 것을 의미하고 있습니다. 이후에, 일반적인 가이드 라인을 설명합니다. 한층 더 자세한 제안에 대해서는, 개개의 이벤트의 설명을 참조해 주세요.
    <p></p>
    
<ul type="disc">
      
<li>이벤트 콜백 함수의 실행중에 throw 된 예외는, 현재의 어플리케이션 thread내에서 현재 보류중의 예외를 덧쓰기 가능하게 됩니다. 따라서, 예외를 생성할 가능성이 있는 JNI 호출을 이벤트 콜백 함수로부터 실행하는 경우는, 보류중의 예외를 보존하도록(듯이) 조심하지 않으면 되지 않습니다.
      </li>
      
<li>이벤트 콜백 함수는, 재입 가능하지 않으면 안됩니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 구현은, 이벤트를 큐에 넣지 않습니다. 에이전트가 복수의 이벤트를 한 번에 1 개(살)씩 처리할 필요가 있는 경우는, 이벤트 콜백 함수의 내부에서 raw 모니터를 사용하면(자), 이벤트의 처리를 직렬화할 수 있습니다.
      </li>
      
<li>JNI 의 FindClass 함수를 실행해 클래스를 로드하는 이벤트 콜백 함수에 대해서는, FindClass 가 현재의 네이티브 메소드에 관련짓고 된 클래스 로더를 찾아내는 것에 주의할 필요가 있습니다. 클래스의 로드를 목적으로 하는 경우, 콜백에의 파라미터로서 JNI 환경을 포함한 이벤트 콜백은, 그것이 네이티브 호출인것 같이 다루어집니다. 이 경우, 그 네이티브 메소드는 이벤트 thread의 현재의 프레임의 클래스내에 존재합니다.
      </li>
    
</ul>
    
<p></p>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 이벤트안에는, JNI 참조를 사용해 객체를 식별하는 것이 있습니다. JVM<small style="font-size: xx-small">&nbsp;</small>TI 이벤트내의 모든 참조는, JNI 로컬 참조로, 이벤트 콜백 함수로부터 복귀하면(자) 무효가 됩니다. 기술되어 있지 않은 경우, 이벤트 콜백내에서 송신된 포인터에 의해 참조되는 메모리는, 이벤트 콜백의 종료후는 참조할 수 없습니다.
    <p></p>
기술되어 있지 않은 경우, 이벤트는, 그 이벤트를 일으킨 thread에 전달됩니다. 이벤트는, 발생과 동시에 송신됩니다. 각 이벤트의 스펙에는, 이 이벤트를 송신할 수 있을<a href="#GetPhase">단계</a>에 대한 기술이 포함되어 있습니다. 이벤트를 송신할 수 있을 단계 이외의 단계에서 이벤트를 트리거해도, 이벤트는 송신되지 않습니다.  
    <p></p>
이벤트의 실행 상태가, 이벤트의 생성원thread에 의해 변경될 것은 없습니다.  예를 들어, thread가 이벤트에 의해 중단될 것은 없습니다. 이벤트를 중단시킬 필요가 있는 에이전트는,<a href="#SuspendThread"><code>SuspendThread</code></a>  를 사용해 명시적으로 thread를 중단시키지 않으면 안됩니다.
    <p></p>
복수의 환경에서 유효하게 되어 있는 이벤트는, 이러한 환경이 작성된 순서에, 각 에이전트에 송신됩니다.
<h4 id="enablingevents">이벤트의 유효화</h4>
모든 이벤트는, 초기 단계에서는 무효가 되어 있습니다. 이벤트를 수신하려면 , 다음과 같이 합니다.
      <ul type="disc">
	
<li>
	  이벤트가 권한을 필요로 하는 경우,<a href="#AddCapabilities"><code>AddCapabilities</code></a>  을 사용해 그 권한을 추가할 필요가 있다.
	</li>
	
<li>
	  <a href="#SetEventCallbacks"><code>SetEventCallbacks</code></a>  를 사용해, 이벤트의 콜백을 설정할 필요가 있다.
	</li>
	
<li>
	  <a href="#SetEventNotificationMode"><code>SetEventNotificationMode</code></a>  를 사용해, 이벤트를 유효하게 할 필요가 있다.  
	</li>
      
</ul>
  
<h4 id="eventorder">같은 위치에서 발생하는 복수의 이벤트</h4>
많은 상황으로, 1 개의 thread내의 같은 위치에서 복수의 이벤트가 발생할 가능성이 있습니다. 그러한 상황에서는, 이 마디로 설명하는 순서로, 이벤트 콜백에 의해 모든 이벤트가 리포트됩니다.
    <p></p>
현재 위치가 메소드의 엔트리 포인트인 경우는, 동일 thread내의 현재 위치에서 발생한 것 외의 모든 이벤트보다 전에,<a href="#MethodEntry"><code>MethodEntry</code></a>  이벤트가 리포트됩니다.
    <p></p>
현재 위치에서 예외의 캐치가 검출되었을 경우 (catch 절의 선두의 경우인가, 미처리의 예외를 해제한 네이티브 메소드가 복귀한 위치의 경우)는, 동일 thread내의 현재 위치에서 발생한 것 외의 모든 이벤트보다 전에,<code>exceptionCatch</code> 이벤트가 리포트됩니다.
    <p></p>
<code>singleStep</code> 이벤트 또는 <code>breakpoint</code> 이벤트가 현재 위치에서 트리거되는 경우, 그 이벤트는, 현재 위치의 코드가 실행되기 직전에 발생하는 것이라고 정의되고 있습니다. 이러한 이벤트는, 동일 thread내의 현재 위치에 있는 코드의 실행에 의해 트리거되는 어느 이벤트 (특히,<code>exception</code>,<code>fieldAccess</code>, 및 <code>fieldModification</code>)보다 전에 리포트됩니다. 스텝 이벤트와 breakpoint 이벤트의 양쪽 모두가 동일한 thread 및 장소에서 트리거되었을 경우는, 스텝 이벤트가 breakpoint 이벤트보다 전에 리포트됩니다.
    <p></p>
현재 위치가 메소드의 종료 포인트 (즉, 호출 측에 복귀하기 전의 마지막 위치)인 경우,<a href="#MethodExit"><code>MethodExit</code></a>  이벤트 및 <a href="#FramePop"><code>FramePop</code></a>  이벤트 (요구되고 있는 경우)는, 동일 thread내의 현재 위치에서 발생하는 것 외의 모든 이벤트의 후에 리포트됩니다. 이것들 2 개의 이벤트에 대해서는, 리포트되는 순서는 특히 지정되고 있지 않습니다.
    <p></p>
같은 위치에서 발생하는 이벤트는, 같은 thread내의 같은 위치에서의 에이전트에 의한 처리중에 트리거되는 일이 있습니다. 그 종의 이벤트 (타입 <i>y</i>)가, 타입 <i>x</i> 의 이벤트의 처리중에 트리거되었다고 합시다. 전술의 설명에 있는 순서에 의하면 <i>x</i> 는 <i>y</i> 보다 전에 리포트된다고 하는 경우는, 같은 위치에서 발생한 이벤트 <i>y</i> 가, 현재의 thread 및 위치에 도착해 리포트됩니다. 반대로,<i>x</i> 가 <i>y</i> 보다 전에 리포트되지 않는다고 하는 경우는, 이벤트 <i>y</i> 는, 현재의 thread 및 위치에 도착해 리포트되지 않습니다. 예를 들어,<a href="#SingleStep"><code>SingleStep</code></a>  의 처리중에 현재 위치에 breakpoint가 설정되었을 경우는, thread가 현재 위치를 떠나기 전에, 그 breakpoint가 리포트됩니다.
<p></p>이하의 이벤트는, 다른 이벤트와 같은 위치에서 발생했다고 보이는 일이 없습니다.
    <ul type="disc">
      
<li>
<a href="#VMStart"><code>VMStart</code></a> 
</li>
      
<li>
<a href="#VMInit"><code>VMInit</code></a> 
</li>
      
<li>
<a href="#VMDeath"><code>VMDeath</code></a> 
</li>
      
<li>
<a href="#ThreadStart"><code>ThreadStart</code></a> 
</li>
      
<li>
<a href="#ThreadEnd"><code>ThreadEnd</code></a> 
</li>
      
<li>
<a href="#ClassLoad"><code>ClassLoad</code></a> 
</li>
      
<li>
<a href="#ClassPrepare"><code>ClassPrepare</code></a> 
</li>
    
</ul>
  
<h4 id="jvmtiEventCallbacks">이벤트 콜백</h4>
이하의 이벤트 콜백 구조체에서는, 이벤트의 핸들러 함수를 지정할 수 있습니다. 이것은,<a href="#SetEventCallbacks"><code>SetEventCallbacks</code></a>  함수로 설정됩니다.  
  <blockquote>
<pre>
typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
    jvmtiEventThreadStart ThreadStart;
    jvmtiEventThreadEnd ThreadEnd;
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
    jvmtiEventClassLoad ClassLoad;
    jvmtiEventClassPrepare ClassPrepare;
    jvmtiEventVMStart VMStart;
    jvmtiEventException Exception;
    jvmtiEventExceptionCatch ExceptionCatch;
    jvmtiEventSingleStep SingleStep;
    jvmtiEventFramePop FramePop;
    jvmtiEventBreakpoint Breakpoint;
    jvmtiEventFieldAccess FieldAccess;
    jvmtiEventFieldModification FieldModification;
    jvmtiEventMethodEntry MethodEntry;
    jvmtiEventMethodExit MethodExit;
    jvmtiEventNativeMethodBind NativeMethodBind;
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
    jvmtiEventDataDumpRequest DataDumpRequest;
    jvmtiEventReserved reserved72;
    jvmtiEventMonitorWait MonitorWait;
    jvmtiEventMonitorWaited MonitorWaited;
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
    jvmtiEventReserved reserved77;
    jvmtiEventReserved reserved78;
    jvmtiEventReserved reserved79;
    jvmtiEventResourceExhausted ResourceExhausted;
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
    jvmtiEventObjectFree ObjectFree;
    jvmtiEventVMObjectAlloc VMObjectAlloc;
} jvmtiEventCallbacks;
</pre>
</blockquote>
<p></p>
<hr noshade="noshade" width="100%" size="1">
<h3 id="EventIndex">이벤트의 색인</h3>
<ul>
<li>
<a href="#Breakpoint"><b>breakpoint</b></a> 
</li>
<li>
<a href="#ClassFileLoadHook"><b>클래스 파일 로드 훅</b></a> 
</li>
<li>
<a href="#ClassLoad"><b>클래스의 로드</b></a> 
</li>
<li>
<a href="#ClassPrepare"><b>클래스의 준비</b></a> 
</li>
<li>
<a href="#CompiledMethodLoad"><b>컴파일이 끝난 메소드의 로드</b></a> 
</li>
<li>
<a href="#CompiledMethodUnload"><b>컴파일이 끝난 메소드의 언로드</b></a> 
</li>
<li>
<a href="#DataDumpRequest"><b>데이터 덤프 요구</b></a> 
</li>
<li>
<a href="#DynamicCodeGenerated"><b>동적 코드 생성</b></a> 
</li>
<li>
<a href="#Exception"><b>예외</b></a> 
</li>
<li>
<a href="#ExceptionCatch"><b>예외 캐치</b></a> 
</li>
<li>
<a href="#FieldAccess"><b>필드 액세스</b></a> 
</li>
<li>
<a href="#FieldModification"><b>필드의 변경</b></a> 
</li>
<li>
<a href="#FramePop"><b>프레임의 팝</b></a> 
</li>
<li>
<a href="#GarbageCollectionFinish"><b>가베지 컬렉션의 완료</b></a> 
</li>
<li>
<a href="#GarbageCollectionStart"><b>가베지 컬렉션의 개시</b></a> 
</li>
<li>
<a href="#MethodEntry"><b>메소드 엔트리</b></a> 
</li>
<li>
<a href="#MethodExit"><b>메소드 종료</b></a> 
</li>
<li>
<a href="#MonitorContendedEnter"><b>경합 하는 모니터 개시</b></a> 
</li>
<li>
<a href="#MonitorContendedEntered"><b>경합 하는 모니터 개시가 끝난 상태</b></a> 
</li>
<li>
<a href="#MonitorWait"><b>모니터 대기</b></a> 
</li>
<li>
<a href="#MonitorWaited"><b>모니터 대기 종료</b></a> 
</li>
<li>
<a href="#NativeMethodBind"><b>네이티브 메소드의 바인드</b></a> 
</li>
<li>
<a href="#ObjectFree"><b>객체의 해제</b></a> 
</li>
<li>
<a href="#ResourceExhausted"><b>자원 부족</b></a> 
</li>
<li>
<a href="#SingleStep"><b>스텝 실행</b></a> 
</li>
<li>
<a href="#ThreadEnd"><b>thread의 종료</b></a> 
</li>
<li>
<a href="#ThreadStart"><b>thread의 개시</b></a> 
</li>
<li>
<a href="#VMDeath"><b>VM 종료 이벤트</b></a> 
</li>
<li>
<a href="#VMInit"><b>VM 초기화 이벤트</b></a> 
</li>
<li>
<a href="#VMObjectAlloc"><b>VM 객체 할당</b></a> 
</li>
<li>
<a href="#VMStart"><b>VM 개시 이벤트</b></a> 
</li>
</ul>
<p id="SingleStep"></p>
<hr noshade="noshade" size="3">
<h2>스텝 실행</h2>
<p></p>
<blockquote>
<pre>void JNICALL
SingleStep(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)</pre>
</blockquote>
스텝 실행 이벤트를 이용하면(자), 에이전트는, VM 로 가능한 최소의 단위로 thread의 실행을 추적할 수 있습니다. 스텝 실행 이벤트는, thread가 새로운 위치에 이를 때마다 생성됩니다. 일반적으로, 스텝 실행 이벤트는,<a href="http://java.sun.com/docs/books/vmspec/">「Java 가상 머신 스펙」</a>에 정의되고 있도록(듯이),1 개의 VM 명령이 완료한 것을 나타냅니다. <i></i>다만, 위치의 정의가 다른 구현도 있습니다. 어쨌든,<code>method</code> 및 <code>location</code> 파라미터에 의해 현재의 위치를 일의에 식별할 수 있기 (위해)때문에, 이 정보가 있으면 원시 파일과 행 번호에의 매핑이 가능합니다.
      <p></p>
네이티브 메소드내로부터는, 스텝 실행 이벤트는 생성되지 않습니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_SINGLE_STEP</code></td><td>60</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_single_step_events"><code>can_generate_single_step_events</code></a> </td><td>
	  <a href="#SingleStep">스텝 실행 </a>이벤트를 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="SingleStep.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="SingleStep.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    새로운 명령을 실행하려고 하고 있는 thread
	  </td>
</tr>
<tr>
<td><code id="SingleStep.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    새로운 명령을 실행하려고 하고 있는 메소드
	  </td>
</tr>
<tr>
<td><code id="SingleStep.location">location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	  새로운 명령의 위치
	</td>
</tr>
</table>
<p id="Breakpoint"></p>
<hr noshade="noshade" size="3">
<h2>breakpoint</h2>
<p></p>
<blockquote>
<pre>void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)</pre>
</blockquote>
breakpoint 이벤트는,<a href="#SetBreakpoint"><code>SetBreakpoint</code></a>  를 사용해 breakpoint로서 지정된 위치에 thread가 달한 시점에서 생성됩니다. <code>method</code> 및 <code>location</code> 파라미터에 의해 현재의 위치를 일의에 식별할 수 있기 (위해)때문에, 이 정보가 있으면 원시 파일과 행 번호에의 매핑이 가능합니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_BREAKPOINT</code></td><td>62</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_breakpoint_events"><code>can_generate_breakpoint_events</code></a> </td><td>
	  <a href="#Breakpoint"><code>Breakpoint</code></a>  이벤트를<a href="#SetBreakpoint">설정</a>해, 취득할 수가 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="Breakpoint.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="Breakpoint.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    breakpoint에 이른 thread
	  </td>
</tr>
<tr>
<td><code id="Breakpoint.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    breakpoint에 이른 메소드
	  </td>
</tr>
<tr>
<td><code id="Breakpoint.location">location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	  breakpoint의 위치
	</td>
</tr>
</table>
<p id="FieldAccess"></p>
<hr noshade="noshade" size="3">
<h2>필드 액세스</h2>
<p></p>
<blockquote>
<pre>void JNICALL
FieldAccess(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field)</pre>
</blockquote>
필드 액세스 이벤트는,<a href="#SetFieldAccessWatch"><code>SetFieldAccessWatch</code></a>  를 사용해 시계 포인트로서 지정된 필드에 thread가 액세스 한 시점에서 생성됩니다. <code>method</code> 및 <code>location</code> 파라미터에 의해 현재의 위치를 일의에 식별할 수 있기 (위해)때문에, 이 정보가 있으면 원시 파일과 행 번호에의 매핑이 가능합니다.  
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_FIELD_ACCESS</code></td><td>63</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_access_events"><code>can_generate_field_access_events</code></a> </td><td>
	  필드 액세스에 시계 포인트를 설정할 수 있는 - <a href="#SetFieldAccessWatch"><code>SetFieldAccessWatch</code></a> 
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="FieldAccess.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="FieldAccess.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    필드에 액세스 하는 thread
	  </td>
</tr>
<tr>
<td><code id="FieldAccess.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    액세스가 발생하고 있는 메소드
	  </td>
</tr>
<tr>
<td><code id="FieldAccess.location">location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	  액세스가 발생하고 있는 위치
	</td>
</tr>
<tr>
<td><code id="FieldAccess.field_klass">field_klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	    액세스 되는 필드의 클래스
	  </td>
</tr>
<tr>
<td><code id="FieldAccess.object">object</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	    필드가 인스턴스 필드의 경우는 액세스 되고 있는 필드를 가지는 객체, 그 이외의 경우는 <code>NULL</code>
	  </td>
</tr>
<tr>
<td><code id="FieldAccess.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a> </code></td><td>
	    액세스 되고 있는 필드
	  </td>
</tr>
</table>
<p id="FieldModification"></p>
<hr noshade="noshade" size="3">
<h2>필드의 변경</h2>
<p></p>
<blockquote>
<pre>void JNICALL
FieldModification(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field,
            char signature_type,
            jvalue new_value)</pre>
</blockquote>
필드의 변경 이벤트는,<a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a>  를 사용해 시계 포인트로서 지정된 필드를 thread가 변경한 시점에서 생성됩니다. <code>method</code> 및 <code>location</code> 파라미터에 의해 현재의 위치를 일의에 식별할 수 있기 (위해)때문에, 이 정보가 있으면 원시 파일과 행 번호에의 매핑이 가능합니다.  
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_FIELD_MODIFICATION</code></td><td>64</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_modification_events"><code>can_generate_field_modification_events</code></a> </td><td>
	  필드의 변경에 시계 포인트를 설정할 수 있는 - <a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a> 
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="FieldModification.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="FieldModification.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    필드를 변경하는 thread
	  </td>
</tr>
<tr>
<td><code id="FieldModification.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    변경이 발생하고 있는 메소드
	  </td>
</tr>
<tr>
<td><code id="FieldModification.location">location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	  변경이 발생하고 있는 위치
	</td>
</tr>
<tr>
<td><code id="FieldModification.field_klass">field_klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	    변경되고 있는 필드의 클래스
	  </td>
</tr>
<tr>
<td><code id="FieldModification.object">object</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	    필드가 인스턴스 필드의 경우는 변경되고 있는 필드를 가지는 객체, 그 이외의 경우는 <code>NULL</code>
	  </td>
</tr>
<tr>
<td><code id="FieldModification.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a> </code></td><td>
	    변경되고 있는 필드
	  </td>
</tr>
<tr>
<td><code id="FieldModification.signature_type">signature_type</code></td><td><code>char</code></td><td>
	  새로운 값의 시그니챠의 형태
	</td>
</tr>
<tr>
<td><code id="FieldModification.new_value">new_value</code></td><td><code><a href="#jvalue">jvalue</a> </code></td><td>
	  새로운 값
	</td>
</tr>
</table>
<p id="FramePop"></p>
<hr noshade="noshade" size="3">
<h2>프레임의 팝</h2>
<p></p>
<blockquote>
<pre>void JNICALL
FramePop(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception)</pre>
</blockquote>
프레임 팝 이벤트는,<a href="#NotifyFramePop"><code>NotifyFramePop</code></a>  의 호출로 지정된 단일의 프레임내의 단일의 메소드로부터 나오는 시점에서 생성됩니다 이것은, 귀가 명령의 실행에 의해 종료되었는지, 호출측에게로의 예외의 throw에 의해 종료되었을 경우, true 가 됩니다 (<a href="#FramePop.was_popped_by_exception"><code>was_popped_by_exception</code></a>  를 참조). 다만,<a href="#PopFrame"><code>PopFrame</code></a>  함수에 의한 프레임의 팝은 리포트되지 않습니다.
      <p></p>
<a href="#GetFrameLocation"><code>GetFrameLocation</code></a>  에 의해 리포트되는 위치는, 복귀하려고 하고 있는 메소드내의 복귀 직전의 실행 가능 위치를 식별합니다.  
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_FRAME_POP</code></td><td>61</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_frame_pop_events"><code>can_generate_frame_pop_events</code></a> </td><td>
	  <a href="#FramePop"><code>FramePop</code></a>  이벤트를<a href="#NotifyFramePop">설정</a>해, 취득할 수가 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="FramePop.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="FramePop.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    프레임을 팝 하는 thread
	  </td>
</tr>
<tr>
<td><code id="FramePop.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    팝 되는 메소드
	  </td>
</tr>
<tr>
<td><code id="FramePop.was_popped_by_exception">was_popped_by_exception</code></td><td><code><a href="#jboolean">jboolean</a> </code></td><td>
	  프레임이 예외의 throw에 의해 팝 되었을 경우는 true. 메소드가 돌아와 명령에 의해 종료했을 경우는 false.
	</td>
</tr>
</table>
<p id="MethodEntry"></p>
<hr noshade="noshade" size="3">
<h2>메소드 엔트리</h2>
<p></p>
<blockquote>
<pre>void JNICALL
MethodEntry(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method)</pre>
</blockquote>
메소드 엔트리 이벤트는, Java 프로그램 언어 메소드 (네이티브 메소드를 포함한다)에 들어가는 시점에서 생성됩니다.
      <p></p>
<a href="#GetFrameLocation"><code>GetFrameLocation</code></a>  에 의해 리포트되는 위치는, 메소드내의 초기 실행 가능 위치를 식별합니다.  
      <p></p>
많은 플랫폼에서는, 메소드 엔트리 이벤트 또는 메소드 종료 이벤트를 유효하게 하면(자), 퍼포먼스가 큰폭으로 저하합니다. 따라서, 프로 파일링 등, 퍼포먼스를 중시하는 처리에서의 사용은 추천하지 않습니다. 이러한 경우에는,<a href="#bci">바이트코드Instrumentation</a>을 사용해야 합니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_METHOD_ENTRY</code></td><td>65</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_method_entry_events"><code>can_generate_method_entry_events</code></a> </td><td>
	  메소드의 입력시에 메소드 입력 이벤트를 생성할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="MethodEntry.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="MethodEntry.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    메소드를 입력하는 thread
	  </td>
</tr>
<tr>
<td><code id="MethodEntry.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    입력되는 메소드
	  </td>
</tr>
</table>
<p id="MethodExit"></p>
<hr noshade="noshade" size="3">
<h2>메소드 종료</h2>
<p></p>
<blockquote>
<pre>void JNICALL
MethodExit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception,
            jvalue return_value)</pre>
</blockquote>
메소드 종료 이벤트는, Java 프로그램 언어 메소드 및 네이티브 메소드로부터 종료하는 시점에서 생성됩니다. 이것은, 귀가 명령의 실행에 의해 종료되었는지, 호출측에게로의 예외의 throw에 의해 종료되었을 경우, true 가 됩니다 (<a href="#MethodExit.was_popped_by_exception"><code>was_popped_by_exception</code></a>  를 참조).
      <p></p>
<code>method</code> 필드는, 들어가는 메소드 또는 나오는 메소드를 일의에 식별합니다. <code>frame</code> 필드는, 메소드의 스택 프레임에의 액세스를 제공합니다.
      <p></p>
<a href="#GetFrameLocation"><code>GetFrameLocation</code></a>  에 의해 리포트되는 위치는, 복귀하려고 하고 있는 메소드내의 복귀 직전의 실행 가능 위치를 식별합니다.  
      <p></p>
많은 플랫폼에서는, 메소드 엔트리 이벤트 또는 메소드 종료 이벤트를 유효하게 하면(자), 퍼포먼스가 큰폭으로 저하합니다. 따라서, 프로 파일링 등, 퍼포먼스를 중시하는 처리에서의 사용은 추천하지 않습니다. 이러한 경우에는,<a href="#bci">바이트코드Instrumentation</a>을 사용해야 합니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_METHOD_EXIT</code></td><td>66</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_method_exit_events"><code>can_generate_method_exit_events</code></a> </td><td>
	  메소드의 종료시에 메소드 종료 이벤트를 생성할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="MethodExit.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="MethodExit.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    메소드를 종료하는 thread
	  </td>
</tr>
<tr>
<td><code id="MethodExit.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    종료되는 메소드
	  </td>
</tr>
<tr>
<td><code id="MethodExit.was_popped_by_exception">was_popped_by_exception</code></td><td><code><a href="#jboolean">jboolean</a> </code></td><td>
	  프레임이 예외의 throw에 의해 팝 되었을 경우는 true. 메소드가 돌아와 명령에 의해 종료했을 경우는 false.
	</td>
</tr>
<tr>
<td><code id="MethodExit.return_value">return_value</code></td><td><code><a href="#jvalue">jvalue</a> </code></td><td>
	  종료되는 메소드의 반환값. <a href="#MethodExit.was_popped_by_exception"><code>was_popped_by_exception</code></a>  가 true 의 경우, 미정도리로, 사용 해서는 안된다.
	</td>
</tr>
</table>
<p id="NativeMethodBind"></p>
<hr noshade="noshade" size="3">
<h2>네이티브 메소드의 바인드</h2>
<p></p>
<blockquote>
<pre>void JNICALL
NativeMethodBind(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            void* address,
            void** new_address_ptr)</pre>
</blockquote>
네이티브메소드바인드이벤트는, VM 가 Java 프로그램 언어의 네이티브 메소드를, 이 네이티브 메소드를 구현하는 함수의 주소에 바인드 한 시점에서 송신됩니다. 이 처리는, 네이티브 메소드가 처음 불려 갔을 때와 JNI 함수 <code>RegisterNatives</code> 가 불려 갔을 때에 발생합니다. 이 이벤트에 의해, 바인드를 에이전트 고유의 프록시 함수에 리다이렉트(redirect) 할 수가 있습니다. 이 이벤트는, 네이티브 메소드가 바인드 해제되고 있을 때는 송신할 수 없습니다. 일반적으로, 이 프록시 함수는, 특정의 메소드에 고유하지 않으면 안됩니다. 또는 일반적인 케이스를 취급하는 경우는, 자동적으로 생성된 어셈블리 코드가 아니면 안됩니다. 일반적으로, 명령 코드의 실행 후는, 원의 바인딩 주소의 함수가 불려 갑니다. 원의 바인딩은 복원 가능합니다. 또, 리다이렉트(redirect)는, JNI 함수 <code>RegisterNatives</code> 의 사용에 의해 변경됩니다. 초기 단계안에 일부의 이벤트는 송신되는 경우가 있습니다.  JNI 및 대부분의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 는 이 시점에서 사용할 수가 없습니다만, 메소드 및 주소는 보존해 나중에 사용할 수 있겠습니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
초기 단계, 개시 단계, 및 라이브 단계에서 송신된다
</td><td><code>JVMTI_EVENT_NATIVE_METHOD_BIND</code></td><td>67</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_native_method_bind_events"><code>can_generate_native_method_bind_events</code></a> </td><td>
	  네이티브 메소드가 구현에 바인드 되고 있을 때 이벤트를 생성할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="NativeMethodBind.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경은, 초기<a href="#GetPhase">단계</a>안에 송신되면(자) <code>NULL</code> 가 된다.
          </td>
</tr>
<tr>
<td><code id="NativeMethodBind.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    바인드를 요구하는 thread
	  </td>
</tr>
<tr>
<td><code id="NativeMethodBind.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    바인드 되는 네이티브 메소드
	  </td>
</tr>
<tr>
<td><code id="NativeMethodBind.address">address</code></td><td><code>void *</code></td><td>
	  VM 의 바인드처의 주소 (네이티브 메소드의 구현 주소)
	</td>
</tr>
<tr>
<td><code id="NativeMethodBind.new_address_ptr">new_address_ptr</code></td><td><code>void**</code></td><td>
	  참조 주소가 변경되었을 경우 (즉,<code>*new_address_ptr</code> 가 설정되었을 경우), 대신에, 제공된 주소에의 바인드를 한다.
	</td>
</tr>
</table>
<p id="Exception"></p>
<hr noshade="noshade" size="3">
<h2>예외</h2>
<p></p>
<blockquote>
<pre>void JNICALL
Exception(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception,
            jmethodID catch_method,
            jlocation catch_location)</pre>
</blockquote>
예외 이벤트는, Java 프로그램 언어 메소드내에서 예외가 최초로 검출된 시점에서 생성됩니다. 여기서, 「예외」는 임의의 <code>java.lang.Throwable</code> 를 의미합니다. 예외는, Java 프로그램 언어 메소드에 의해 throw 되는 경우와 네이티브 메소드에 의해 throw 되는 경우가 있습니다. 네이티브 메소드에 의해 throw 되는 경우는, 그 예외가 Java 프로그램 언어 메소드에 의해 최초로 인식될 때까지, 이 이벤트는 생성되지 않습니다. 예외가 네이티브 메소드내에서 생성되어 해제되었을 경우 (즉, Java 프로그램 언어 코드로부터는 인식되지 않는 경우)는, 예외 이벤트는 생성되지 않습니다.
      <p></p>
<code>method</code> 및 <code>location</code> 파라미터에 의해 현재의 위치 (예외가 검출된 위치)를 일의에 식별할 수 있기 (위해)때문에, 이 정보가 있으면 원시 파일과 행 번호에의 매핑이 가능합니다. <code>exception</code> 필드는, throw 된 예외 객체를 인식합니다. <code>catch_method</code> 및 <code>catch_location</code> 는, throw 된 예외를 처리하는 catch 절의 위치를 식별합니다 (그러한 마디가 존재하는 경우). 그러한 catch 절이 없는 경우, 그러한 각 필드는 0 으로 설정됩니다. thread가 이 catch 절에 도달한다고 하는 보증은 없습니다. 호출 스택상에서 예외 throw의 위치와 catch 절의 사이에 네이티브 메소드가 있는 경우, 그러한 네이티브 메소드의 어느 쪽인가에 따라 예외가 리셋 될 가능성이 있기 때문입니다. 같이 캐치 되지 않으면 리포트된 예외 (<code>catch_klass</code> 등. 0 으로 설정)은, 실제로는 native code에 의해 캐치 됩니다. 에이전트는, 이러한 발생을,<a href="#ExceptionCatch"><code>ExceptionCatch</code></a>  이벤트를 감시하는 것에 의해 체크합니다. finally 절은, 캐치/재throw로서 구현되는 점에 주의해 주세요. 이 때문에, 이것들은 캐치의 위치에서 리포트됩니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_EXCEPTION</code></td><td>58</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_exception_events"><code>can_generate_exception_events</code></a> </td><td>
	  <a href="#Exception">throw 된 예외</a>와<a href="#ExceptionCatch">예외 캐치 </a>이벤트를 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="Exception.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="Exception.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    예외를 생성하는 thread
	  </td>
</tr>
<tr>
<td><code id="Exception.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    예외를 생성하는 메소드
	  </td>
</tr>
<tr>
<td><code id="Exception.location">location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	  예외가 발생한 위치
	</td>
</tr>
<tr>
<td><code id="Exception.exception">exception</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	    throw 되는 예외
	  </td>
</tr>
<tr>
<td><code id="Exception.catch_method">catch_method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    예외를 캐치 하는 메소드. 기존의 캐치가 없는 경우는 <code>NULL</code>
	  </td>
</tr>
<tr>
<td><code id="Exception.catch_location">catch_location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	  예외를 캐치 하는 메소드. 기존의 캐치가 없는 경우는 제로
	</td>
</tr>
</table>
<p id="ExceptionCatch"></p>
<hr noshade="noshade" size="3">
<h2>예외 캐치</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ExceptionCatch(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception)</pre>
</blockquote>
예외 캐치 이벤트는, throw 된 예외가 캐치 된 시점에서 생성됩니다. 여기서, 「예외」는 임의의 <code>java.lang.Throwable</code> 를 의미합니다. 예외가 Java 프로그램 언어 메소드내에서 캐치 되었을 경우는, catch 절에 도달한 시점에서 이 이벤트가 생성됩니다. 예외가 네이티브 메소드내에서 캐치 되었을 경우는, Java 프로그램 언어 메소드에 제어가 돌아온 직후에 이 이벤트가 생성됩니다. 예외 캐치 이벤트는, Java 프로그램 언어 메소드내에서 throw가 검출된 예외에 대해서 생성됩니다. finally 절은, 캐치/재throw로서 구현되는 점에 주의해 주세요. 이 때문에, 이것들은 예외 캐치 이벤트를 생성합니다.
      <p></p>
<code>method</code> 및 <code>location</code> 파라미터에 의해 현재의 위치를 일의에 식별할 수 있기 (위해)때문에, 이 정보가 있으면 원시 파일과 행 번호에의 매핑이 가능합니다. Java 프로그램 언어 메소드내에서 캐치 된 예외의 경우는,<code>exception</code> 객체가 예외 객체를 식별합니다. 네이티브 메소드내에서 캐치 된 예외는, 예외의 캐치가 리포트된 시점에서 입수 가능하다고는 할 수 없기 때문에,<code>exception</code> 필드는 <code>NULL</code> 로 설정됩니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_EXCEPTION_CATCH</code></td><td>59</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION_CATCH, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_exception_events"><code>can_generate_exception_events</code></a> </td><td>
	  <a href="#Exception">throw 된 예외</a>와<a href="#ExceptionCatch">예외 캐치 </a>이벤트를 취득할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ExceptionCatch.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="ExceptionCatch.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    예외를 캐치 하는 thread
	  </td>
</tr>
<tr>
<td><code id="ExceptionCatch.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    예외를 캐치 하는 메소드
	  </td>
</tr>
<tr>
<td><code id="ExceptionCatch.location">location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	  예외가 캐치 되는 위치
	</td>
</tr>
<tr>
<td><code id="ExceptionCatch.exception">exception</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	    캐치 되는 예외
	  </td>
</tr>
</table>
<p id="ThreadStart"></p>
<hr noshade="noshade" size="3">
<h2>thread의 개시</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)</pre>
</blockquote>
thread 개시 이벤트는, 새로운 thread에 의해, thread의 초기 메소드가 실행되기 전에, 생성됩니다.  
      <p></p>
thread 개시 이벤트가 생성되기 전에,<a href="#GetAllThreads"><code>GetAllThreads</code></a>  에 의해 반환되는 배열에, 그 thread가 포함되어 있을 가능성이 있습니다. 또, thread 개시 이벤트의 전에, 그 외의 이벤트가 thread상에 생성될 가능성이 있습니다.
      <p></p>
이벤트는 새롭게 개시된 <a href="#ThreadStart.thread"><code>thread</code></a>  에 송신됩니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 단계와 라이브 단계에서 송신된다
</td><td><code>JVMTI_EVENT_THREAD_START</code></td><td>52</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ThreadStart.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="ThreadStart.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    개시하는 thread
	  </td>
</tr>
</table>
<p id="ThreadEnd"></p>
<hr noshade="noshade" size="3">
<h2>thread의 종료</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)</pre>
</blockquote>
thread 종료 이벤트는, 정지하려고 하고 있는 thread에 의해, thread의 초기 메소드의 실행 완료 후에, 생성됩니다.  
      <p></p>
thread 종료 이벤트가 생성된 뒤,<a href="#GetAllThreads"><code>GetAllThreads</code></a>  에 의해 반환되는 배열에, 그 thread가 포함되어 있을 가능성이 있습니다. thread 종료 이벤트의 뒤, thread상에 이벤트는 생성되지 않습니다.
      <p></p>
이벤트는 종료하는 <a href="#ThreadEnd.thread"><code>thread</code></a>  에 송신됩니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 단계와 라이브 단계에서 송신된다
</td><td><code>JVMTI_EVENT_THREAD_END</code></td><td>53</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ThreadEnd.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="ThreadEnd.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    종료하는 thread
	  </td>
</tr>
</table>
<p id="ClassLoad"></p>
<hr noshade="noshade" size="3">
<h2>클래스의 로드</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ClassLoad(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)</pre>
</blockquote>
클래스 로드 이벤트는, 클래스가 최초로 로드 된 시점에서 생성됩니다. 특정의 thread에 의해 클래스 로드 이벤트가 생성되는 순서는, 그 thread내에서 클래스가 로드 되는 순서와 일치하는 것이 보증되고 있습니다. 배열 클래스의 작성에서는, 클래스 로드 이벤트는 생성되지 않습니다. 프리미티브(primitive) 클래스 (java.lang.Integer.TYPE 등)의 작성에서는, 클래스 로드 이벤트는 생성되지 않습니다.
      <p></p>
이 이벤트는, 클래스의 로드의 빠른 단계에서 송신됩니다. 이 때문에, 클래스는 신중하게 사용할 필요가 있습니다. 예를 들어, 메소드나 필드가 아직 로드 되지 않고, 메소드, 필드, 서브 클래스가 조회되어 있지 않은 경우, 올바른 결과는 얻을 수 있지 않습니다. 「Java 언어 스펙」의 「Loading of Classes and Interfaces」를 참조해 주세요. 대부분의 경우,<a href="#ClassPrepare"><code>ClassPrepare</code></a>  가 유효합니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 단계와 라이브 단계에서 송신된다
</td><td><code>JVMTI_EVENT_CLASS_LOAD</code></td><td>55</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ClassLoad.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="ClassLoad.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    클래스를 로드하는 thread
	  </td>
</tr>
<tr>
<td><code id="ClassLoad.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	    로드 되는 클래스
	  </td>
</tr>
</table>
<p id="ClassPrepare"></p>
<hr noshade="noshade" size="3">
<h2>클래스의 준비</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ClassPrepare(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)</pre>
</blockquote>
클래스 준비 이벤트는, 클래스의 준비가 완료한 시점에서 생성됩니다. 이 시점에서는, 클래스의 필드, 메소드, 및 구현된 인터페이스가 이용 가능합니다만, 클래스의 코드는 아직 아무것도 실행되고 있지 않습니다. 배열 클래스는, 필드나 메소드를 가지는 것이 없기 때문에, 배열 클래스에 도착해 클래스 준비 이벤트가 생성될 것은 없습니다. 프리미티브(primitive) 클래스 (예를 들어,<code>java.lang.Integer.TYPE</code>)에 대해서도, 클래스 준비 이벤트는 생성되지 않습니다.  
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 단계와 라이브 단계에서 송신된다
</td><td><code>JVMTI_EVENT_CLASS_PREPARE</code></td><td>56</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ClassPrepare.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="ClassPrepare.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    클래스 준비 이벤트를 생성하는 thread
	  </td>
</tr>
<tr>
<td><code id="ClassPrepare.klass">klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	    준비되는 클래스
	  </td>
</tr>
</table>
<p id="ClassFileLoadHook"></p>
<hr noshade="noshade" size="3">
<h2>클래스 파일 로드 훅</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ClassFileLoadHook(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jclass class_being_redefined,
            jobject loader,
            const char* name,
            jobject protection_domain,
            jint class_data_len,
            const unsigned char* class_data,
            jint* new_class_data_len,
            unsigned char** new_class_data)</pre>
</blockquote>
이 이벤트는, VM 가 클래스 파일 데이터를 취득했을 때, 그 클래스의 메모리 내부 표현을 구축하기 전의 시점에서 송신됩니다. 또, 이 이벤트는, 임의의 JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경내로부터 불려 간 <a href="#RetransformClasses"><code>RetransformClasses</code></a>  함수 또는 <a href="#RedefineClasses"><code>RedefineClasses</code></a>  함수에 의해 클래스가 변경 되려고 하고 있을 때도 송신됩니다. 에이전트는, VM 에 의해 송신된 기존의 클래스 파일 데이터에, 프로 파일링/디버그 훅을 계측 할 수가 있습니다. 사용 방법에 대해서는,<a href="#bci">바이트코드Instrumentation</a>의 설명을 참조해 주세요.
      <p></p>
이 이벤트는, VM 의 초기화전 (초기<a href="#GetPhase">단계</a>)에 송신될 가능성이 있습니다. 이 시점에서는, VM 자원은 작성되지 않습니다. 함수 (예를 들어 ROMized classes)와의 호환성이 없는 클래스에 대해서는, 이 이벤트는 생성되지 않습니다.
    <p></p>
에이전트는, 메모리 할당 함수 <a href="#Allocate"><code>Allocate</code></a>  를 사용해, 수정한 클래스 파일 데이터의 버퍼용의 영역을 할당할 필요가 있습니다. 새로운 클래스 파일 데이터의 버퍼를 해제하는 처리는, VM 에 의해,<a href="#Deallocate"><code>Deallocate</code></a>  를 사용해 실행되기 때문입니다. <a href="#Allocate"><code>Allocate</code></a>  는 초기 단계안에 허가됩니다.
    <p></p>
에이전트는, 클래스 파일을 변경하는 경우, 새롭게 구현된 클래스 파일 데이터 버퍼를 포인트 하도록(듯이) <code>new_class_data</code> 를 설정해, 이 호출로부터 돌아오기 전에,<code>new_class_data_len</code> 에 그 버퍼의 길이를 설정할 필요가 있습니다. 변경이 불필요한 경우, 에이전트는 <code>new_class_data</code> 를 설정하지 않습니다. 복수의 에이전트가 이 이벤트를 유효하게 하고 있는 경우, 결과는 체인이 됩니다. 즉,<code>new_class_data</code> 가 설정되어 있는 경우는, 이것이 다음의 에이전트의 <code>class_data</code> 가 됩니다.
    <p></p>
이 이벤트가 각 환경에 송신되는 차례는, 다른 이벤트의 경우와는 다릅니다. 이 이벤트는 다음의 차례로 환경에 송신됩니다.
    <ul type="disc">
      
<li>
<a href="#jvmtiCapabilities.can_retransform_classes">재변환 불가능한 </a>환경 (작성된 차례)
      </li>
      
<li>
<a href="#jvmtiCapabilities.can_retransform_classes">재변환 가능한 </a>환경 (작성된 차례)
      </li>
    
</ul>
이 이벤트가 <a href="#RetransformClasses"><code>RetransformClasses</code></a>  에 의해 기동되었을 경우,<a href="#jvmtiCapabilities.can_retransform_classes">재변환 가능한 </a>환경에만 이 이벤트가 송신됩니다.
  <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
초기 단계, 개시 단계, 및 라이브 단계에서 송신된다
</td><td><code>JVMTI_EVENT_CLASS_FILE_LOAD_HOOK</code></td><td>54</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
임의의 기능
        </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_all_class_hook_events"><code>can_generate_all_class_hook_events</code></a> </td><td>
	  로드 된 모든 클래스에 대해서, ClassFileLoadHook 이벤트를 생성할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경 초기<a href="#GetPhase">단계</a>안에 송신되었을 경우는 <code>NULL</code> 가 된다.
          </td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.class_being_redefined">class_being_redefined</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	  <a href="#RedefineClasses">재정의 </a>또는<a href="#RetransformClasses">재변환</a>되는 클래스. 클래스의 로드에 의해 송신되었을 경우는 <code>NULL</code>.
	</td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.loader">loader</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	    클래스를 로드하는 클래스 로더. bootstrap 클래스 로더의 경우는 <code>NULL</code>.
	  </td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.name">name</code></td><td><code>const char*</code></td><td>
VM 내부 수식명으로서 로드 되는 클래스명 ("java/util/List" 등). <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다. 주:클래스가 이름 <code>NULL</code> 로 정의되었는지 이름을 지정하지 않고 정의되었을 경우,<code>name</code> 는 <code>NULL</code> 가 된다.
	</td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.protection_domain">protection_domain</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	  클래스의 <code>ProtectionDomain</code>.
	</td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.class_data_len">class_data_len</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	  현재의 클래스 파일 데이터의 버퍼의 길이.
	</td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.class_data">class_data</code></td><td><code>const unsigned char*</code></td><td>
	  현재의 클래스 파일 데이터의 버퍼의 포인터.
	</td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.new_class_data_len">new_class_data_len</code></td><td><code><a href="#jint">jint</a> *</code></td><td>
	  새로운 클래스 파일 데이터의 버퍼의 길이의 포인터.
	</td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.new_class_data">new_class_data</code></td><td><code>unsigned char**</code></td><td>
	  구현이 끝난 클래스 파일 데이터의 버퍼의 포인터에의 포인터.
	</td>
</tr>
</table>
<p id="VMStart"></p>
<hr noshade="noshade" size="3">
<h2>VM 개시 이벤트</h2>
<p></p>
<blockquote>
<pre>void JNICALL
VMStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)</pre>
</blockquote>
VM 초기화 이벤트는, VM 의 개시를 나타냅니다. 이 시점에서 JNI 는 라이브입니다만, VM 는 아직 완전하게 초기화되고 있지 않습니다. 이 이벤트가 생성된 뒤는, 에이전트는 임의의 JNI 함수를 자유롭게 호출할 수가 있습니다. 이 이벤트는, 개시 단계의 개시를 나타냅니다. 개시 단계에서 허가된 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수를 호출할 수가 있습니다.
      <p></p>
VM 의 기동에 실패했을 경우, 이 이벤트는 송신되지 않습니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
개시 단계와 라이브 단계에서 송신된다
</td><td><code>JVMTI_EVENT_VM_START</code></td><td>57</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="VMStart.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
</table>
<p id="VMInit"></p>
<hr noshade="noshade" size="3">
<h2>VM 초기화 이벤트</h2>
<p></p>
<blockquote>
<pre>void JNICALL
VMInit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)</pre>
</blockquote>
VM 초기화 이벤트는, VM 의 초기화의 완료를 나타냅니다. 이 이벤트가 생성된 뒤는, 에이전트는 임의의 JNI 또는 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수를 자유롭게 호출할 수가 있습니다. VM 초기화 이벤트는, 그 전에 다른 이벤트가 생성되거나 다른 이벤트와 동시에 생성 되거나 하는 일이 있습니다. 그 중에서 VM 초기화 이벤트의 전의 생성되는 이벤트에 대해서는, VM 의 초기화가 아직 완료하고 있지 않았기 때문에, 특별히 주의해 처리할 필요가 있습니다. 메인 어플리케이션 thread의 thread 개시 이벤트는, VM 초기화 이벤트의 핸들러가 복귀할 때까지는 발생하지 않는 것이 보증되고 있습니다.
      <p></p>
VM 의 기동에 실패했을 경우, 이 이벤트는 송신되지 않습니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_VM_INIT</code></td><td>50</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="VMInit.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="VMInit.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    초기 thread
	  </td>
</tr>
</table>
<p id="VMDeath"></p>
<hr noshade="noshade" size="3">
<h2>VM 종료 이벤트</h2>
<p></p>
<blockquote>
<pre>void JNICALL
VMDeath(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)</pre>
</blockquote>
VM 종료 이벤트는, VM 의 종료를 에이전트에 통지합니다. VMDeath 이벤트의 뒤는, 이벤트는 발생하지 않습니다.
      <p></p>
VM 의 기동에 실패했을 경우, 이 이벤트는 송신되지 않습니다. 이러한 경우,<a href="#onunload">Agent_OnUnload</a>  는 불려 가는 점에 주의해 주세요.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_VM_DEATH</code></td><td>51</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="VMDeath.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
</table>
<p id="CompiledMethodLoad"></p>
<hr noshade="noshade" size="3">
<h2>컴파일이 끝난 메소드의 로드</h2>
<p></p>
<blockquote>
<pre>typedef struct {
    const void* start_address;
    jlocation location;
} jvmtiAddrLocationMap;</pre>
<pre>void JNICALL
CompiledMethodLoad(jvmtiEnv *jvmti_env,
            jmethodID method,
            jint code_size,
            const void* code_addr,
            jint map_length,
            const jvmtiAddrLocationMap* map,
            const void* compile_info)</pre>
</blockquote>
메소드가 VM 에 의해 컴파일 되어 메모리내에 로드 되는 시점에서 송신됩니다. 언로드되었을 경우,<a href="#CompiledMethodUnload"><code>CompiledMethodUnload</code></a>  이벤트가 송신됩니다. 이동했을 경우, 새로운 <code>CompiledMethodLoad</code> 이벤트에 이어,<a href="#CompiledMethodUnload"><code>CompiledMethodUnload</code></a>  이벤트가 송신됩니다. 단일의 메소드가 복수의 형식에서 컴파일 되어 이 이벤트가 그 형식 마다 송신되는 점에 주의해 주세요. 또, 복수의 메소드가 단일의 주소 범위에 인 라인 되어 이 이벤트가 각 메소드 마다 송신되는 점에도 주의해 주세요.
      <p></p>
이러한 이벤트는, 최초의 발생뒤,<a href="#GenerateEvents"><code>GenerateEvents</code></a>  에 의해 송신할 수가 있습니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_COMPILED_METHOD_LOAD</code></td><td>68</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p id="jvmtiAddrLocationMap"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiAddrLocationMap</code> - 위치 엔트리의 네이티브 주소</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
필드
        </td><td>
형
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="jvmtiAddrLocationMap.start_address">start_address</code></td><td><code>const void*</code></td><td>
	  위치에 대응하는 코드의 개시 네이티브 주소
	</td>
</tr>
<tr>
<td><code id="jvmtiAddrLocationMap.location">location</code></td><td><code><a href="#jlocation">jlocation</a> </code></td><td>
	  대응하는 위치. 위치의 의미에 대해서는,<a href="#GetJLocationFormat"><code>GetJLocationFormat</code></a>  를 참조.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_compiled_method_load_events"><code>can_generate_compiled_method_load_events</code></a> </td><td>
	  메소드의 컴파일시 또는 언로드시에 이벤트를 생성할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="CompiledMethodLoad.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    컴파일 및 로드 되고 있는 메소드
	  </td>
</tr>
<tr>
<td><code id="CompiledMethodLoad.code_size">code_size</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	  컴파일 된 코드의 사이즈
	</td>
</tr>
<tr>
<td><code id="CompiledMethodLoad.code_addr">code_addr</code></td><td><code>const void*</code></td><td>
	  컴파일 된 메소드 코드가 로드 되는 주소
	</td>
</tr>
<tr>
<td><code id="CompiledMethodLoad.map_length">map_length</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	  주소 맵내의 <a href="#jvmtiAddrLocationMap"><code>jvmtiAddrLocationMap</code></a>  엔트리의 수. 매핑 정보가 제공되지 않는 경우는 제로.
	</td>
</tr>
<tr>
<td><code id="CompiledMethodLoad.map">map</code></td><td><code>const <a href="#jvmtiAddrLocationMap">jvmtiAddrLocationMap</a> *</code></td><td>
	  네이티브 주소와 위치의 매핑. 각 엔트리의 네이티브 주소 범위는,<a href="#jvmtiAddrLocationMap.start_address"><code>start_address</code></a>  로부터 다음의 엔트리의 <code>start_address-1</code> 까지. 매핑 정보가 제공되지 않는 경우는 <code>NULL</code>.
	</td>
</tr>
<tr>
<td><code id="CompiledMethodLoad.compile_info">compile_info</code></td><td><code>const void*</code></td><td>
	  VM 고유의 컴파일 정보. 참조되는 컴파일 정보는, VM 에 의해 관리되어 수집을 위해서(때문에) 에이전트에 의존하고 있어서는 안 된다. 이 정보의 내용과 수명은, VM 구현에 의해 정의된다.
	</td>
</tr>
</table>
<p id="CompiledMethodUnload"></p>
<hr noshade="noshade" size="3">
<h2>컴파일이 끝난 메소드의 언로드</h2>
<p></p>
<blockquote>
<pre>void JNICALL
CompiledMethodUnload(jvmtiEnv *jvmti_env,
            jmethodID method,
            const void* code_addr)</pre>
</blockquote>
컴파일 된 메소드가 메모리로부터 언로드되는 시점에서 송신됩니다. 이 이벤트는, 언로드를 실행한 thread상에 송신되지 않는 것이 있습니다. 이 이벤트는, 언로드의 발생 후에 송신되는 경우가 있습니다. 그러나, 새롭게 생성된 컴파일이 끝난 메소드에 의해 메모리가 재사용되기 전에 송신됩니다. 이 이벤트는, 클래스의 언로드 후에 송신될 가능성이 있습니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_COMPILED_METHOD_UNLOAD</code></td><td>69</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_UNLOAD, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_compiled_method_load_events"><code>can_generate_compiled_method_load_events</code></a> </td><td>
	  메소드의 컴파일시 또는 언로드시에 이벤트를 생성할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="CompiledMethodUnload.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a> </code></td><td>
	    언로드되는, 컴파일 된 메소드. 언로드되는, 컴파일 된 메소드 컴파일 된 메소드를 식별하는 목적 밖에 가지지 않는다. 클래스는 언로드되기 (위해)때문에, 메소드를 이후의 JNI 또는 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수의 인수로서 사용할 수 없다.
	  </td>
</tr>
<tr>
<td><code id="CompiledMethodUnload.code_addr">code_addr</code></td><td><code>const void*</code></td><td>
	  컴파일 된 메소드 코드가 로드 된 주소. 컴파일 된 메소드를 식별하는 목적 밖에 가지지 않는다.  공간은 재생되고 있을 가능성이 있다.
	</td>
</tr>
</table>
<p id="DynamicCodeGenerated"></p>
<hr noshade="noshade" size="3">
<h2>동적 코드 생성</h2>
<p></p>
<blockquote>
<pre>void JNICALL
DynamicCodeGenerated(jvmtiEnv *jvmti_env,
            const char* name,
            const void* address,
            jint length)</pre>
</blockquote>
가상 머신의 컴퍼넌트가 동적으로 생성될 때 송신됩니다. 이것은, 컴파일 되는 Java 프로그램 언어 코드에는 대응하지 않습니다 (<a href="#CompiledMethodLoad"><code>CompiledMethodLoad</code></a>  를 참조). 이것은 native code전용이 아닙니다.  예를 들어, 생성되는 interpreter는, 커멘드행 옵션에 따라서 다릅니다.
      <p></p>
이 이벤트에는, 제어 기능은 없습니다. VM 는, 이러한 이벤트를 생성할 수 없는 경우, 아무것도 송신하지 않습니다.
      <p></p>
이러한 이벤트는, 최초의 발생뒤,<a href="#GenerateEvents"><code>GenerateEvents</code></a>  에 의해 송신할 수가 있습니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
초기 단계, 개시 단계, 및 라이브 단계에서 송신된다
</td><td><code>JVMTI_EVENT_DYNAMIC_CODE_GENERATED</code></td><td>70</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="DynamicCodeGenerated.name">name</code></td><td><code>const char*</code></td><td>
	  코드의 이름. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다. 최종 사용자에의 표시용. 이름은 일의가 아니어도 좋다.
	</td>
</tr>
<tr>
<td><code id="DynamicCodeGenerated.address">address</code></td><td><code>const void*</code></td><td>
	  코드의 네이티브 주소
	</td>
</tr>
<tr>
<td><code id="DynamicCodeGenerated.length">length</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	  코드의 길이 (바이트 단위)
	</td>
</tr>
</table>
<p id="DataDumpRequest"></p>
<hr noshade="noshade" size="3">
<h2>데이터 덤프 요구</h2>
<p></p>
<blockquote>
<pre>void JNICALL
DataDumpRequest(jvmtiEnv *jvmti_env)</pre>
</blockquote>
VM 에 의해 송신되어 에이전트에 데이터를 덤프 하도록(듯이) 요구합니다. 이것은 단지 시사하고 있는 것만으로 있어, 에이전트는 이 이벤트에 반드시 반응할 필요는 없습니다. 이것은, 사용자로부터의 커멘드행 시그널을 처리하는 경우에 편리합니다. 예를 들어, JDK 의 경우, Win32 상에서는 Ctrl+Break 키, Solaris 상에서는 Ctrl+\ 키로, 이 이벤트는 VM 로부터 에이전트에 송신됩니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_DATA_DUMP_REQUEST</code></td><td>71</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_DATA_DUMP_REQUEST, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
</table>
<p id="MonitorContendedEnter"></p>
<hr noshade="noshade" size="3">
<h2>경합 하는 모니터 개시</h2>
<p></p>
<blockquote>
<pre>void JNICALL
MonitorContendedEnter(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)</pre>
</blockquote>
thread가 Java 프로그램 언어 모니터에 들어가려고 했을 때, 그 모니터가 벌써 다른 thread에 의해 획득되고 있는 경우에 송신됩니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_MONITOR_CONTENDED_ENTER</code></td><td>75</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_monitor_events"><code>can_generate_monitor_events</code></a> </td><td>
	  모니터의 사용율에 관한 이벤트를 생성할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="MonitorContendedEnter.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="MonitorContendedEnter.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    모니터에 들어가려고 하는 thread의 JNI 로컬 참조
	  </td>
</tr>
<tr>
<td><code id="MonitorContendedEnter.object">object</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	    모니터의 JNI 로컬 참조
	  </td>
</tr>
</table>
<p id="MonitorContendedEntered"></p>
<hr noshade="noshade" size="3">
<h2>경합 하는 모니터 개시가 끝난 상태</h2>
<p></p>
<blockquote>
<pre>void JNICALL
MonitorContendedEntered(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)</pre>
</blockquote>
다른 thread가 Java 프로그램 언어 모니터를 해제하는 것을 기다린 후에, thread가 그 Java 모니터에 들어갈 때 송신됩니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_MONITOR_CONTENDED_ENTERED</code></td><td>76</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_monitor_events"><code>can_generate_monitor_events</code></a> </td><td>
	  모니터의 사용율에 관한 이벤트를 생성할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="MonitorContendedEntered.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="MonitorContendedEntered.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    모니터에 들어가는 thread의 JNI 로컬 참조
	  </td>
</tr>
<tr>
<td><code id="MonitorContendedEntered.object">object</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	    모니터의 JNI 로컬 참조
	  </td>
</tr>
</table>
<p id="MonitorWait"></p>
<hr noshade="noshade" size="3">
<h2>모니터 대기</h2>
<p></p>
<blockquote>
<pre>void JNICALL
MonitorWait(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jlong timeout)</pre>
</blockquote>
thread가 객체를 대기하려고 하고 있을 때 송신됩니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_MONITOR_WAIT</code></td><td>73</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_monitor_events"><code>can_generate_monitor_events</code></a> </td><td>
	  모니터의 사용율에 관한 이벤트를 생성할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="MonitorWait.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="MonitorWait.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    대기하려고 하는 thread의 JNI 로컬 참조
	  </td>
</tr>
<tr>
<td><code id="MonitorWait.object">object</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	    모니터의 JNI 로컬 참조
	  </td>
</tr>
<tr>
<td><code id="MonitorWait.timeout">timeout</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	  thread가 대기하는 시간 (단위는 밀리 세컨드).
	</td>
</tr>
</table>
<p id="MonitorWaited"></p>
<hr noshade="noshade" size="3">
<h2>모니터 대기 종료</h2>
<p></p>
<blockquote>
<pre>void JNICALL
MonitorWaited(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jboolean timed_out)</pre>
</blockquote>
thread가 객체의 대기를 종료할 경우에 송신됩니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_MONITOR_WAITED</code></td><td>74</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_monitor_events"><code>can_generate_monitor_events</code></a> </td><td>
	  모니터의 사용율에 관한 이벤트를 생성할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="MonitorWaited.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="MonitorWaited.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    대기를 종료한 thread의 JNI 로컬 참조
	  </td>
</tr>
<tr>
<td><code id="MonitorWaited.object">object</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	    모니터의 JNI 로컬 참조
	  </td>
</tr>
<tr>
<td><code id="MonitorWaited.timed_out">timed_out</code></td><td><code><a href="#jboolean">jboolean</a> </code></td><td>
	  모니터가 타임 아웃이 되었을 경우 true
	</td>
</tr>
</table>
<p id="ResourceExhausted"></p>
<hr noshade="noshade" size="3">
<h2>자원 부족</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ResourceExhausted(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jint flags,
            const void* reserved,
            const char* description)</pre>
</blockquote>
실행중의 어플리케이션이 필요로 하는 VM 자원이 다 써 버려졌을 때에 송신됩니다. 임의의 권한에 의해 필요하게 되는 것을 제외하면, 부족을 보고하는 자원 세트는 구현에 의존합니다.
      <p></p>
다음의 비트 플래그는, 자원 부족의 프로퍼티을 정의합니다.
      <blockquote>
<a name="jvmtiResourceExhaustionFlags"></a> 
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">자원 부족 플래그</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
정수
        </td><td>
치
        </td><td>
설명
        </td>
</tr>
<tr>
<td><code id="JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR">JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR</code></td><td align="right">0x0001</td><td>
이 이벤트가 반환된 뒤, VM 는 <code>java.lang.OutOfMemoryError</code> 를 throw 한다.
        </td>
</tr>
<tr>
<td><code id="JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP">JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP</code></td><td align="right">0x0002</td><td>
	  VM 가, Java<sup style="font-size: xx-small">TM</sup> 플랫폼의 「heap」로부터 메모리를 할당할 수가 없었다. <i></i>「heap」란, 모든 클래스 인스턴스 및 배열의 메모리의 할당원이 되는 실행시 데이터 영역이다. <i></i>
        </td>
</tr>
<tr>
<td><code id="JVMTI_RESOURCE_EXHAUSTED_THREADS">JVMTI_RESOURCE_EXHAUSTED_THREADS</code></td><td align="right">0x0004</td><td>
	  VM 가 thread를 작성할 수 없었다.
        </td>
</tr>
</table>
</blockquote>
    
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_RESOURCE_EXHAUSTED</code></td><td>80</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_RESOURCE_EXHAUSTED, NULL)</code></td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>필요한 기능</b></td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
임의의 기능
        </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_resource_exhaustion_heap_events"><code>can_generate_resource_exhaustion_heap_events</code></a> </td><td>
VM 가<a href="#JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP">heap</a>로부터 메모리의 할당을 실시할 수 없는 경우에, 이벤트를 생성할 수 있다.
      </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_resource_exhaustion_threads_events"><code>can_generate_resource_exhaustion_threads_events</code></a> </td><td>
VM 가<a href="#JVMTI_RESOURCE_EXHAUSTED_THREADS">thread를 작성</a>할 수 없는 경우에 이벤트를 생성할 수 있다.
      </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ResourceExhausted.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
          </td>
</tr>
<tr>
<td><code id="ResourceExhausted.flags">flags</code></td><td><code><a href="#jint">jint</a> </code></td><td>
	  <a href="#jvmtiResourceExhaustionFlags">자원 부족 플래그</a>로 지정되는, 자원 부족의 프로퍼티을 정의하는 플래그.
	  </td>
</tr>
<tr>
<td><code id="ResourceExhausted.reserved">reserved</code></td><td><code>const void*</code></td><td>
	  예약이 끝난 상태.
	</td>
</tr>
<tr>
<td><code id="ResourceExhausted.description">description</code></td><td><code>const char*</code></td><td>
	  자원 부족의 설명. <a href="#mUTF">수정 UTF-8</a>  캐릭터 라인으로서 encode 된다.
	</td>
</tr>
</table>
<p id="VMObjectAlloc"></p>
<hr noshade="noshade" size="3">
<h2>VM 객체 할당</h2>
<p></p>
<blockquote>
<pre>void JNICALL
VMObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)</pre>
</blockquote>
메소드에 의해, 가상 머신이 Java 프로그램 언어 코드에 대해서 가시의 객체를 할당해 그 외의 구현 기구가 이 할당을 검출할 수 없는 경우에 송신됩니다. 일반적으로, 객체 할당은, 할당하는 메소드의 바이트 코드를 구현하는 것에 의해 검출됩니다. JNI 함수 호출에 의해, native code로 생성된 객체 할당은,<a href="#jniIntercept">JNI 함수의 차단</a>에 의해 검출됩니다. 바이트 코드에 관련지을 수 있지 않고, 네이티브가 아닌 메소드는, VM 에 의해 직접 실행됩니다. 이 이벤트는, 이러한 메소드에 의해 송신됩니다. 가상 머신이, 이러한 메소드의 일부 또는 모두에 대해서 바이트 코드를 구현할 수 없는 경우, 이 이벤트가 송신되는 일이 있습니다.
      <p></p>
다음에, 이 이벤트가 송신되는 전형적인 사례를 나타냅니다.
      <ul type="disc">
        
<li>리플렉션 -- 예를 들어,<code>java.lang.Class.newInstance()</code>
</li>
        
<li>바이트 코드로 나타내지지 않은 메소드 -- 예를 들어, VM 인트린시크스와 J2ME 프리로드크라스</li>
      
</ul>
다음의 경우, 이 이벤트는 생성되지 않습니다.
      <ul type="disc">
        
<li>바이트 코드에 의한 할당 -- 예를 들어,<code>new</code> 및 <code>newarray</code> VM 명령</li>
        
<li>JNI 함수 호출에 의한 할당 -- 예를 들어,<code>AllocObject</code>
</li>
        
<li>VM 초기화중의 할당</li>
        
<li>VM 내부 객체</li>
      
</ul>
    
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_VM_OBJECT_ALLOC</code></td><td>84</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_vm_object_alloc_events"><code>can_generate_vm_object_alloc_events</code></a> </td><td>
	  객체의 VM 할당해에 관한 이벤트를 생성할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="VMObjectAlloc.jni_env">jni_env</code></td><td><code><a href="#JNIEnv">JNIEnv</a>  *</code></td><td>
이벤트의 현재의 thread의 JNI 환경
	  </td>
</tr>
<tr>
<td><code id="VMObjectAlloc.thread">thread</code></td><td><code><a href="#jthread">jthread</a> </code></td><td>
	    객체를 할당하는 thread
	  </td>
</tr>
<tr>
<td><code id="VMObjectAlloc.object">object</code></td><td><code><a href="#jobject">jobject</a> </code></td><td>
	    할당할 수 있었던 객체의 JNI 로컬 참조
	  </td>
</tr>
<tr>
<td><code id="VMObjectAlloc.object_klass">object_klass</code></td><td><code><a href="#jclass">jclass</a> </code></td><td>
	    객체의 클래스의 JNI 로컬 참조
	  </td>
</tr>
<tr>
<td><code id="VMObjectAlloc.size">size</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	    객체의 사이즈 (바이트 단위). <a href="#GetObjectSize"><code>GetObjectSize</code></a>  를 참조
	</td>
</tr>
</table>
<p id="ObjectFree"></p>
<hr noshade="noshade" size="3">
<h2>객체의 해제</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ObjectFree(jvmtiEnv *jvmti_env,
            jlong tag)</pre>
</blockquote>
객체의 해제 이벤트는, 가비지 컬렉터가 객체를 해제한 시점에서 송신됩니다. 이벤트는, 태그 첨부 객체의 경우에게만 송신됩니다 (<a href="#Heap">「heap 함수」</a>를 참조).
      <p></p>
이벤트 핸들러는, 특별히 사용이 허가되고 있는 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수 이외의 함수 및 JNI 함수를 사용할 수 없습니다 (raw 모니터 함수, 메모리 관리 함수, 환경 로컬 기억 영역 함수를 참조).
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_OBJECT_FREE</code></td><td>83</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_object_free_events"><code>can_generate_object_free_events</code></a> </td><td>
	  가비지 컬렉터가 객체를 해제할 경우에 이벤트를 생성할 수 있다.
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
<tr>
<td><code id="ObjectFree.tag">tag</code></td><td><code><a href="#jlong">jlong</a> </code></td><td>
	  해제되는 객체의 태그
	</td>
</tr>
</table>
<p id="GarbageCollectionStart"></p>
<hr noshade="noshade" size="3">
<h2>가베지 컬렉션의 개시</h2>
<p></p>
<blockquote>
<pre>void JNICALL
GarbageCollectionStart(jvmtiEnv *jvmti_env)</pre>
</blockquote>
가베지 컬렉션의 개시 이벤트는, 가베지 컬렉션의 전사이클이 개시되었을 때 송신됩니다. 처리를 정지하는 (stop-the-world) 컬렉션, 즉 모든 thread가 Java 가상 머신의 상태의 변경을 종료하고 있는 동안에 수집되는 컬렉션만이 리포트됩니다. 이 때문에, 수집가에 따라서는, 이러한 이벤트를 생성하지 않습니다. 이 이벤트는, VM 가 아직 정지하고 있는 동안에 송신되므로, 이벤트 핸들러는, 특별히 사용이 허가되고 있는 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수 이외의 함수 및 JNI 함수를 사용할 수 없습니다 (raw 모니터 함수, 메모리 관리 함수, 환경 로컬 기억 영역 함수를 참조).
      <p></p>
이 이벤트는, 항상 <a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>  와 일치하는 페어 (어느 쪽의 이벤트도 유효로 간주해진다)로서 송신되어 이러한 사이에, 가베지 컬렉션 이벤트는 발생하지 않습니다.
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_GARBAGE_COLLECTION_START</code></td><td>81</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_garbage_collection_events"><code>can_generate_garbage_collection_events</code></a> </td><td>
	  가베지 컬렉션의 개시 또는 종료시에 이벤트를 생성할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
</table>
<p id="GarbageCollectionFinish"></p>
<hr noshade="noshade" size="3">
<h2>가베지 컬렉션의 완료</h2>
<p></p>
<blockquote>
<pre>void JNICALL
GarbageCollectionFinish(jvmtiEnv *jvmti_env)</pre>
</blockquote>
가베지 컬렉션의 종료 이벤트는, 가베지 컬렉션의 전사이클이 종료했을 때 송신됩니다. 이 이벤트는, VM 가 아직 정지하고 있는 동안에 송신되므로, 이벤트 핸들러는, 특별히 사용이 허가되고 있는 JVM<small style="font-size: xx-small">&nbsp;</small>TI 함수 이외의 함수 및 JNI 함수를 사용할 수 없습니다 (raw 모니터 함수, 메모리 관리 함수, 환경 로컬 기억 영역 함수를 참조).
      <p></p>
일부의 에이전트는, 허가되어 있지 않은 JVM<small style="font-size: xx-small">&nbsp;</small>TI 또는 JNI 함수를 사용할 필요가 있는, 가베지 컬렉션 후의 조작을 실시할 필요가 있습니다. 그러한 경우, raw 모니터로 대기하는 에이전트 thread를 작성할 수 있어 가베지 컬렉션의 종료 이벤트에서는, 단지 raw 모니터에 통지합니다.
      <p></p>
이 이벤트는, 항상 <a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>  와 일치하는 페어 (어느 쪽의 이벤트도 유효로 간주해진다)로서 송신됩니다.
      
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">단계</a> </td><td><a href="#jvmtiEvent">이벤트형</a> </td><td><a href="#jvmtiEvent">번호</a> </td><td><a href="#enablingevents">유효화</a> </td><td><a href="#ChangeHistory">도입된 버젼</a> </td>
</tr>
<tr>
<td>
라이브 단계에서 밖에 송신되지 않는다
</td><td><code>JVMTI_EVENT_GARBAGE_COLLECTION_FINISH</code></td><td>82</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a> (JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
권한
      </td>
</tr>
<tr>
<td colspan="2"><b>임의의 기능:</b> 모든 가상 머신에 구현해서는 안 된다.  
            
이 이벤트를 사용하기 위해서는, 다음의 권한 (<a href="#GetCapabilities"><code>GetCapabilities</code></a>  로부터 반환된다)이 true 가 아니면 안된다.
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
권한
          </td><td>
효과
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_garbage_collection_events"><code>can_generate_garbage_collection_events</code></a> </td><td>
	  가베지 컬렉션의 개시 또는 종료시에 이벤트를 생성할 수 있다
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
파라미터
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
이름
      </td><td>
형
      </td><td>
설명
      </td>
</tr>
</table>
<p id="ConstantIndex"></p>
<p></p>
<hr noshade="noshade" size="3">
<h2>
정수의 색인
      </h2>
<blockquote>
<a href="#JVMTI_CLASS_STATUS_ARRAY"><code>JVMTI_CLASS_STATUS_ARRAY</code></a>  <br> <a href="#JVMTI_CLASS_STATUS_ERROR"><code>JVMTI_CLASS_STATUS_ERROR</code></a>  <br> <a href="#JVMTI_CLASS_STATUS_INITIALIZED"><code>JVMTI_CLASS_STATUS_INITIALIZED</code></a>  <br> <a href="#JVMTI_CLASS_STATUS_PREPARED"><code>JVMTI_CLASS_STATUS_PREPARED</code></a>  <br> <a href="#JVMTI_CLASS_STATUS_PRIMITIVE"><code>JVMTI_CLASS_STATUS_PRIMITIVE</code></a>  <br> <a href="#JVMTI_CLASS_STATUS_VERIFIED"><code>JVMTI_CLASS_STATUS_VERIFIED</code></a>  <br> <a href="#JVMTI_DISABLE"><code>JVMTI_DISABLE</code></a>  <br> <a href="#JVMTI_ENABLE"><code>JVMTI_ENABLE</code></a>  <br> <a href="#JVMTI_HEAP_FILTER_CLASS_TAGGED"><code>JVMTI_HEAP_FILTER_CLASS_TAGGED</code></a>  <br> <a href="#JVMTI_HEAP_FILTER_CLASS_UNTAGGED"><code>JVMTI_HEAP_FILTER_CLASS_UNTAGGED</code></a>  <br> <a href="#JVMTI_HEAP_FILTER_TAGGED"><code>JVMTI_HEAP_FILTER_TAGGED</code></a>  <br> <a href="#JVMTI_HEAP_FILTER_UNTAGGED"><code>JVMTI_HEAP_FILTER_UNTAGGED</code></a>  <br> <a href="#JVMTI_HEAP_OBJECT_EITHER"><code>JVMTI_HEAP_OBJECT_EITHER</code></a>  <br> <a href="#JVMTI_HEAP_OBJECT_TAGGED"><code>JVMTI_HEAP_OBJECT_TAGGED</code></a>  <br> <a href="#JVMTI_HEAP_OBJECT_UNTAGGED"><code>JVMTI_HEAP_OBJECT_UNTAGGED</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT"><code>JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_CLASS"><code>JVMTI_HEAP_REFERENCE_CLASS</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_CLASS_LOADER"><code>JVMTI_HEAP_REFERENCE_CLASS_LOADER</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_CONSTANT_POOL"><code>JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_FIELD"><code>JVMTI_HEAP_REFERENCE_FIELD</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_INTERFACE"><code>JVMTI_HEAP_REFERENCE_INTERFACE</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_JNI_GLOBAL"><code>JVMTI_HEAP_REFERENCE_JNI_GLOBAL</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_JNI_LOCAL"><code>JVMTI_HEAP_REFERENCE_JNI_LOCAL</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_MONITOR"><code>JVMTI_HEAP_REFERENCE_MONITOR</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_OTHER"><code>JVMTI_HEAP_REFERENCE_OTHER</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN"><code>JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_SIGNERS"><code>JVMTI_HEAP_REFERENCE_SIGNERS</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_STACK_LOCAL"><code>JVMTI_HEAP_REFERENCE_STACK_LOCAL</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_STATIC_FIELD"><code>JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_SUPERCLASS"><code>JVMTI_HEAP_REFERENCE_SUPERCLASS</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_SYSTEM_CLASS"><code>JVMTI_HEAP_REFERENCE_SYSTEM_CLASS</code></a>  <br> <a href="#JVMTI_HEAP_REFERENCE_THREAD"><code>JVMTI_HEAP_REFERENCE_THREAD</code></a>  <br> <a href="#JVMTI_HEAP_ROOT_JNI_GLOBAL"><code>JVMTI_HEAP_ROOT_JNI_GLOBAL</code></a>  <br> <a href="#JVMTI_HEAP_ROOT_JNI_LOCAL"><code>JVMTI_HEAP_ROOT_JNI_LOCAL</code></a>  <br> <a href="#JVMTI_HEAP_ROOT_MONITOR"><code>JVMTI_HEAP_ROOT_MONITOR</code></a>  <br> <a href="#JVMTI_HEAP_ROOT_OTHER"><code>JVMTI_HEAP_ROOT_OTHER</code></a>  <br> <a href="#JVMTI_HEAP_ROOT_STACK_LOCAL"><code>JVMTI_HEAP_ROOT_STACK_LOCAL</code></a>  <br> <a href="#JVMTI_HEAP_ROOT_SYSTEM_CLASS"><code>JVMTI_HEAP_ROOT_SYSTEM_CLASS</code></a>  <br> <a href="#JVMTI_HEAP_ROOT_THREAD"><code>JVMTI_HEAP_ROOT_THREAD</code></a>  <br> <a href="#JVMTI_ITERATION_ABORT"><code>JVMTI_ITERATION_ABORT</code></a>  <br> <a href="#JVMTI_ITERATION_CONTINUE"><code>JVMTI_ITERATION_CONTINUE</code></a>  <br> <a href="#JVMTI_ITERATION_IGNORE"><code>JVMTI_ITERATION_IGNORE</code></a>  <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED"><code>JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED</code></a>  <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_MASK"><code>JVMTI_JAVA_LANG_THREAD_STATE_MASK</code></a>  <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_NEW"><code>JVMTI_JAVA_LANG_THREAD_STATE_NEW</code></a>  <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE"><code>JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE</code></a>  <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED"><code>JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED</code></a>  <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING"><code>JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING</code></a>  <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_WAITING"><code>JVMTI_JAVA_LANG_THREAD_STATE_WAITING</code></a>  <br> <a href="#JVMTI_JLOCATION_JVMBCI"><code>JVMTI_JLOCATION_JVMBCI</code></a>  <br> <a href="#JVMTI_JLOCATION_MACHINEPC"><code>JVMTI_JLOCATION_MACHINEPC</code></a>  <br> <a href="#JVMTI_JLOCATION_OTHER"><code>JVMTI_JLOCATION_OTHER</code></a>  <br> <a href="#JVMTI_KIND_ALLOC_ALLOC_BUF"><code>JVMTI_KIND_ALLOC_ALLOC_BUF</code></a>  <br> <a href="#JVMTI_KIND_ALLOC_BUF"><code>JVMTI_KIND_ALLOC_BUF</code></a>  <br> <a href="#JVMTI_KIND_IN"><code>JVMTI_KIND_IN</code></a>  <br> <a href="#JVMTI_KIND_IN_BUF"><code>JVMTI_KIND_IN_BUF</code></a>  <br> <a href="#JVMTI_KIND_IN_PTR"><code>JVMTI_KIND_IN_PTR</code></a>  <br> <a href="#JVMTI_KIND_OUT"><code>JVMTI_KIND_OUT</code></a>  <br> <a href="#JVMTI_KIND_OUT_BUF"><code>JVMTI_KIND_OUT_BUF</code></a>  <br> <a href="#JVMTI_PHASE_DEAD"><code>JVMTI_PHASE_DEAD</code></a>  <br> <a href="#JVMTI_PHASE_LIVE"><code>JVMTI_PHASE_LIVE</code></a>  <br> <a href="#JVMTI_PHASE_ONLOAD"><code>JVMTI_PHASE_ONLOAD</code></a>  <br> <a href="#JVMTI_PHASE_PRIMORDIAL"><code>JVMTI_PHASE_PRIMORDIAL</code></a>  <br> <a href="#JVMTI_PHASE_START"><code>JVMTI_PHASE_START</code></a>  <br> <a href="#JVMTI_PRIMITIVE_TYPE_BOOLEAN"><code>JVMTI_PRIMITIVE_TYPE_BOOLEAN</code></a>  <br> <a href="#JVMTI_PRIMITIVE_TYPE_BYTE"><code>JVMTI_PRIMITIVE_TYPE_BYTE</code></a>  <br> <a href="#JVMTI_PRIMITIVE_TYPE_CHAR"><code>JVMTI_PRIMITIVE_TYPE_CHAR</code></a>  <br> <a href="#JVMTI_PRIMITIVE_TYPE_DOUBLE"><code>JVMTI_PRIMITIVE_TYPE_DOUBLE</code></a>  <br> <a href="#JVMTI_PRIMITIVE_TYPE_FLOAT"><code>JVMTI_PRIMITIVE_TYPE_FLOAT</code></a>  <br> <a href="#JVMTI_PRIMITIVE_TYPE_INT"><code>JVMTI_PRIMITIVE_TYPE_INT</code></a>  <br> <a href="#JVMTI_PRIMITIVE_TYPE_LONG"><code>JVMTI_PRIMITIVE_TYPE_LONG</code></a>  <br> <a href="#JVMTI_PRIMITIVE_TYPE_SHORT"><code>JVMTI_PRIMITIVE_TYPE_SHORT</code></a>  <br> <a href="#JVMTI_REFERENCE_ARRAY_ELEMENT"><code>JVMTI_REFERENCE_ARRAY_ELEMENT</code></a>  <br> <a href="#JVMTI_REFERENCE_CLASS"><code>JVMTI_REFERENCE_CLASS</code></a>  <br> <a href="#JVMTI_REFERENCE_CLASS_LOADER"><code>JVMTI_REFERENCE_CLASS_LOADER</code></a>  <br> <a href="#JVMTI_REFERENCE_CONSTANT_POOL"><code>JVMTI_REFERENCE_CONSTANT_POOL</code></a>  <br> <a href="#JVMTI_REFERENCE_FIELD"><code>JVMTI_REFERENCE_FIELD</code></a>  <br> <a href="#JVMTI_REFERENCE_INTERFACE"><code>JVMTI_REFERENCE_INTERFACE</code></a>  <br> <a href="#JVMTI_REFERENCE_PROTECTION_DOMAIN"><code>JVMTI_REFERENCE_PROTECTION_DOMAIN</code></a>  <br> <a href="#JVMTI_REFERENCE_SIGNERS"><code>JVMTI_REFERENCE_SIGNERS</code></a>  <br> <a href="#JVMTI_REFERENCE_STATIC_FIELD"><code>JVMTI_REFERENCE_STATIC_FIELD</code></a>  <br> <a href="#JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP"><code>JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP</code></a>  <br> <a href="#JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR"><code>JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR</code></a>  <br> <a href="#JVMTI_RESOURCE_EXHAUSTED_THREADS"><code>JVMTI_RESOURCE_EXHAUSTED_THREADS</code></a>  <br> <a href="#JVMTI_THREAD_MAX_PRIORITY"><code>JVMTI_THREAD_MAX_PRIORITY</code></a>  <br> <a href="#JVMTI_THREAD_MIN_PRIORITY"><code>JVMTI_THREAD_MIN_PRIORITY</code></a>  <br> <a href="#JVMTI_THREAD_NORM_PRIORITY"><code>JVMTI_THREAD_NORM_PRIORITY</code></a>  <br> <a href="#JVMTI_THREAD_STATE_ALIVE"><code>JVMTI_THREAD_STATE_ALIVE</code></a>  <br> <a href="#JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER"><code>JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER</code></a>  <br> <a href="#JVMTI_THREAD_STATE_IN_NATIVE"><code>JVMTI_THREAD_STATE_IN_NATIVE</code></a>  <br> <a href="#JVMTI_THREAD_STATE_IN_OBJECT_WAIT"><code>JVMTI_THREAD_STATE_IN_OBJECT_WAIT</code></a>  <br> <a href="#JVMTI_THREAD_STATE_INTERRUPTED"><code>JVMTI_THREAD_STATE_INTERRUPTED</code></a>  <br> <a href="#JVMTI_THREAD_STATE_PARKED"><code>JVMTI_THREAD_STATE_PARKED</code></a>  <br> <a href="#JVMTI_THREAD_STATE_RUNNABLE"><code>JVMTI_THREAD_STATE_RUNNABLE</code></a>  <br> <a href="#JVMTI_THREAD_STATE_SLEEPING"><code>JVMTI_THREAD_STATE_SLEEPING</code></a>  <br> <a href="#JVMTI_THREAD_STATE_SUSPENDED"><code>JVMTI_THREAD_STATE_SUSPENDED</code></a>  <br> <a href="#JVMTI_THREAD_STATE_TERMINATED"><code>JVMTI_THREAD_STATE_TERMINATED</code></a>  <br> <a href="#JVMTI_THREAD_STATE_VENDOR_1"><code>JVMTI_THREAD_STATE_VENDOR_1</code></a>  <br> <a href="#JVMTI_THREAD_STATE_VENDOR_2"><code>JVMTI_THREAD_STATE_VENDOR_2</code></a>  <br> <a href="#JVMTI_THREAD_STATE_VENDOR_3"><code>JVMTI_THREAD_STATE_VENDOR_3</code></a>  <br> <a href="#JVMTI_THREAD_STATE_WAITING"><code>JVMTI_THREAD_STATE_WAITING</code></a>  <br> <a href="#JVMTI_THREAD_STATE_WAITING_INDEFINITELY"><code>JVMTI_THREAD_STATE_WAITING_INDEFINITELY</code></a>  <br> <a href="#JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT"><code>JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</code></a>  <br> <a href="#JVMTI_TIMER_ELAPSED"><code>JVMTI_TIMER_ELAPSED</code></a>  <br> <a href="#JVMTI_TIMER_TOTAL_CPU"><code>JVMTI_TIMER_TOTAL_CPU</code></a>  <br> <a href="#JVMTI_TIMER_USER_CPU"><code>JVMTI_TIMER_USER_CPU</code></a>  <br> <a href="#JVMTI_TYPE_CCHAR"><code>JVMTI_TYPE_CCHAR</code></a>  <br> <a href="#JVMTI_TYPE_CVOID"><code>JVMTI_TYPE_CVOID</code></a>  <br> <a href="#JVMTI_TYPE_JBOOLEAN"><code>JVMTI_TYPE_JBOOLEAN</code></a>  <br> <a href="#JVMTI_TYPE_JBYTE"><code>JVMTI_TYPE_JBYTE</code></a>  <br> <a href="#JVMTI_TYPE_JCHAR"><code>JVMTI_TYPE_JCHAR</code></a>  <br> <a href="#JVMTI_TYPE_JCLASS"><code>JVMTI_TYPE_JCLASS</code></a>  <br> <a href="#JVMTI_TYPE_JDOUBLE"><code>JVMTI_TYPE_JDOUBLE</code></a>  <br> <a href="#JVMTI_TYPE_JFIELDID"><code>JVMTI_TYPE_JFIELDID</code></a>  <br> <a href="#JVMTI_TYPE_JFLOAT"><code>JVMTI_TYPE_JFLOAT</code></a>  <br> <a href="#JVMTI_TYPE_JINT"><code>JVMTI_TYPE_JINT</code></a>  <br> <a href="#JVMTI_TYPE_JLONG"><code>JVMTI_TYPE_JLONG</code></a>  <br> <a href="#JVMTI_TYPE_JMETHODID"><code>JVMTI_TYPE_JMETHODID</code></a>  <br> <a href="#JVMTI_TYPE_JNIENV"><code>JVMTI_TYPE_JNIENV</code></a>  <br> <a href="#JVMTI_TYPE_JOBJECT"><code>JVMTI_TYPE_JOBJECT</code></a>  <br> <a href="#JVMTI_TYPE_JSHORT"><code>JVMTI_TYPE_JSHORT</code></a>  <br> <a href="#JVMTI_TYPE_JTHREAD"><code>JVMTI_TYPE_JTHREAD</code></a>  <br> <a href="#JVMTI_TYPE_JVALUE"><code>JVMTI_TYPE_JVALUE</code></a>  <br> <a href="#JVMTI_VERBOSE_CLASS"><code>JVMTI_VERBOSE_CLASS</code></a>  <br> <a href="#JVMTI_VERBOSE_GC"><code>JVMTI_VERBOSE_GC</code></a>  <br> <a href="#JVMTI_VERBOSE_JNI"><code>JVMTI_VERBOSE_JNI</code></a>  <br> <a href="#JVMTI_VERBOSE_OTHER"><code>JVMTI_VERBOSE_OTHER</code></a>  <br> <a href="#JVMTI_VERSION_INTERFACE_JNI"><code>JVMTI_VERSION_INTERFACE_JNI</code></a>  <br> <a href="#JVMTI_VERSION_INTERFACE_JVMTI"><code>JVMTI_VERSION_INTERFACE_JVMTI</code></a>  <br> <a href="#JVMTI_VERSION_MASK_INTERFACE_TYPE"><code>JVMTI_VERSION_MASK_INTERFACE_TYPE</code></a>  <br> <a href="#JVMTI_VERSION_MASK_MAJOR"><code>JVMTI_VERSION_MASK_MAJOR</code></a>  <br> <a href="#JVMTI_VERSION_MASK_MICRO"><code>JVMTI_VERSION_MASK_MICRO</code></a>  <br> <a href="#JVMTI_VERSION_MASK_MINOR"><code>JVMTI_VERSION_MASK_MINOR</code></a>  <br> <a href="#JVMTI_VERSION_SHIFT_MAJOR"><code>JVMTI_VERSION_SHIFT_MAJOR</code></a>  <br> <a href="#JVMTI_VERSION_SHIFT_MICRO"><code>JVMTI_VERSION_SHIFT_MICRO</code></a>  <br> <a href="#JVMTI_VERSION_SHIFT_MINOR"><code>JVMTI_VERSION_SHIFT_MINOR</code></a>  <br> <a href="#JVMTI_VISIT_ABORT"><code>JVMTI_VISIT_ABORT</code></a>  <br> <a href="#JVMTI_VISIT_OBJECTS"><code>JVMTI_VISIT_OBJECTS</code></a>  <br>
</blockquote>
<p id="ChangeHistory"></p>
<p></p>
<hr noshade="noshade" size="3">
<h2>변경 이력</h2>
최종 갱신일:06/08/06 22:33:32<br> 파일의 버젼:@(#) jvmti.xml 1.202<br> 버젼: 1.1. 102<p></p>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 스펙은 발전중의 문서이며, 메이저, 마이너, 마이크로의 각 버젼 번호를 가집니다. 자원판의 스펙은, 메이저 버젼과 마이너 버젼에 의해 일의에 식별됩니다. 이 스펙에 포함되는 함수, 이벤트, 및 권한에는, 「도입된 버젼」치가 나타나고 있습니다. 이것은, 그러한 기능이 도입된 메이저 버젼과 마이너 버젼입니다. VM 가 구현하고 있는 스펙의 버젼을 실행시에 가져오려면 ,<a href="#GetVersionNumber"><code>GetVersionNumber</code></a>  함수를 사용합니다.
  <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><b>버젼</b> <br> <b>일자</b></td><td><b>변경점</b></td>
</tr>
<tr>
<td>2002 년 11 월 14 일</td><td>
XML 문서에 변환
  </td>
</tr>
<tr>
<td>2002 년 11 월 14 일</td><td>
heap 덤프 함수의 기술에 잘못이 있었기 때문에, 일시적으로 내용을 삭제
  </td>
</tr>
<tr>
<td>2002 년 11 월 18 일</td><td>
자세한 throughput를 추가
  </td>
</tr>
<tr>
<td>2002 년 11 월 18 일</td><td>
JVMTI_THREAD_STATUS_RUNNING 를 JVMTI_THREAD_STATUS_RUNNABLE 로 변경
  </td>
</tr>
<tr>
<td>2002 년 11 월 19 일</td><td>
AsyncGetStackTrace 를 추가
  </td>
</tr>
<tr>
<td>2002 년 11 월 19 일</td><td>
GetStackTrace 의 반환값 jframeID 를 추가
  </td>
</tr>
<tr>
<td>2002 년 11 월 19 일</td><td>
GetCurrentFrame 함수와 GetCallingFrame 함수의 기술에 GetStackTrace 와 중복되는 점이 있었기 때문에, 일시적으로 내용을 삭제
  </td>
</tr>
<tr>
<td>2002 년 11 월 19 일</td><td>
중복 한 ClearAllBreakpoints 를 삭제
  </td>
</tr>
<tr>
<td>2002 년 11 월 19 일</td><td>
GetSystemProperties 를 추가
  </td>
</tr>
<tr>
<td>2002 년 11 월 19 일</td><td>
thread 로컬인 기억 영역 함수가 jthread 를 사용하도록(듯이) 변경
  </td>
</tr>
<tr>
<td>2002 년 11 월 20 일</td><td>
GetJLocationFormat 를 추가
  </td>
</tr>
<tr>
<td>2002 년 11 월 22 일</td><td>
이벤트와 개요의 텍스트를 추가
  </td>
</tr>
<tr>
<td>2002 년 11 월 22 일</td><td>
형태와 정수의 정의의 크로스 레퍼런스를 추가
  </td>
</tr>
<tr>
<td>2002 년 11 월 24 일</td><td>
DTD 를 추가
  </td>
</tr>
<tr>
<td>2002 년 11 월 24 일</td><td>
권한 함수의 섹션을 추가
  </td>
</tr>
<tr>
<td>2002 년 11 월 29 일</td><td>
각 함수 및 이벤트에 권한을 할당
  </td>
</tr>
<tr>
<td>2002 년 11 월 29 일</td><td>
<a href="#jniIntercept">JNI 차단 함수</a>를 추가
  </td>
</tr>
<tr>
<td>2002 년 11 월 30 일</td><td>
SetEventNotificationMode 권한을 자동 생성
  </td>
</tr>
<tr>
<td>2002 년 11 월 30 일</td><td>
<a href="#VMObjectAlloc"><code>VMObjectAlloc</code></a>  이벤트를 추가
  </td>
</tr>
<tr>
<td>2002 년 11 월 30 일</td><td>
<a href="#DynamicCodeGenerated"><code>DynamicCodeGenerated</code></a>  이벤트를 추가
  </td>
</tr>
<tr>
<td>2002 년 11 월 30 일</td><td>
선언의 정수를 추가
  </td>
</tr>
<tr>
<td>2002 년 11 월 30 일</td><td>
메소드의 종료와 프레임 팝이 예외를 송신하도록(듯이) 변경
  </td>
</tr>
<tr>
<td>2002 년 12 월 1 일</td><td>
ForceGarbageCollection 를 추가
  </td>
</tr>
<tr>
<td>2002 년 12 월 2 일</td><td>
Xrun 섹션의 개정: GetStackTrace 의 설명을 알기 쉽게 변경해, 예를 추가. 폭의 문제를 수정. 「에이전트」를 모순 없게 사용
  </td>
</tr>
<tr>
<td>2002 년 12 월 8 일</td><td>
이전의 개요 정보를 삭제,<a href="#environments">「JVM<small style="font-size: xx-small">&nbsp;</small>TI 환경」</a>섹션을 추가
  </td>
</tr>
<tr>
<td>2002 년 12 월 8 일</td><td>
<a href="#DisposeEnvironment"><code>DisposeEnvironment</code></a>  를 추가
  </td>
</tr>
<tr>
<td>2002 년 12 월 9 일</td><td>
다수의 세세한 갱신
  </td>
</tr>
<tr>
<td>2002 년 12 월 15 일</td><td>
heap 프로 파일링 함수를 추가:주석의 취득/설정, 라이브 객체/heap의 반복 처리. heap 프로 파일링 함수의 플레이스홀더-를 추가:heap 루트. heap 프로 파일링 이벤트를 추가:객체의 해제. heap 프로 파일링 이벤트를 재설계 :VM 객체 할당. heap 프로 파일링 이벤트의 플레이스홀더-를 추가:가베지 컬렉션의 개시/종료. 네이티브메소드바인드이벤트를 추가
  </td>
</tr>
<tr>
<td>2002 년 12 월 19 일</td><td>
함수의 중단/재개의 설명을 개정. jvmdi 태그 첨부의 원의 정보를 추가. 그 외의 수정
  </td>
</tr>
<tr>
<td>2002 년 12 월 24 일</td><td>
형태에 시멘틱스를 추가
  </td>
</tr>
<tr>
<td>2002 년 12 월 27 일</td><td>
로컬 참조의 섹션을 추가. 형태로부터 파라미터의 설명을 자동 생성
  </td>
</tr>
<tr>
<td>2002 년 12 월 28 일</td><td>
RunAgentThread 가 threadStart 를 송신하는 것을 문서화
  </td>
</tr>
<tr>
<td>2002 년 12 월 29 일</td><td>
중복 한 로컬 참조와 할당 해제의 경고를 삭제. GetRawMonitorName 를 할당하고가 끝난 버퍼에 변환. GenerateEvents 를 추가
  </td>
</tr>
<tr>
<td>2002 년 12 월 30 일</td><td>
raw 모니터를 형태로 변경해, 이름을 jrawMonitorID 으로 변경
  </td>
</tr>
<tr>
<td>2003 년 1 월 1 일</td><td>
원의 정보를 추가. JVMDI 의 문제의 참조를 정리. Deallocate 의 경고가 자동 생성되게 되었으므로 삭제
  </td>
</tr>
<tr>
<td>2003 년 1 월 2 일</td><td>
jthread 의 표현의 문제를 수정
  </td>
</tr>
<tr>
<td>2003 년 1 월 3 일</td><td>
권한을 64 비트에 버퍼 아웃 (자동 처리)
  </td>
</tr>
<tr>
<td>2003 년 1 월 4 일</td><td>
열거의 정수를 열거형으로 변경. 파라미터는 열거형. 형태의 섹션을 정리해, 색인을 작성. 남아 있는 데이터 참조 엔티티를 콜백으로 치환
  </td>
</tr>
<tr>
<td>2003 년 1 월 7 일</td><td>
GenerateEvents 의 설명을 수정. 보다 많은 내부 시멘틱스를 유효화
  </td>
</tr>
<tr>
<td>2003 년 1 월 9 일</td><td>
이전의 GetSystemProperties 를, 고정 정보는 아니고 할당할 수 있었던 정보를 사용하는 2 개의 함수로 치환. SetSystemProperty 를 추가. 보다 많은 내부 시멘틱스를 유효화
  </td>
</tr>
<tr>
<td>2003 년 1 월 12 일</td><td>
SetEventNotificationMode 의 말미에 가변 인수를 추가
  </td>
</tr>
<tr>
<td>2003 년 1 월 20 일</td><td>
할당 사이즈가 jlong 인 것을 반영하도록(듯이) 스펙을 수정
  </td>
</tr>
<tr>
<td>2003 년 1 월 22 일</td><td>
RunAgentThread 의 인수로서 NULL 를 허가
  </td>
</tr>
<tr>
<td>2003 년 1 월 22 일</td><td>
표준 명명 규칙 Removed AsyncGetStackTrace 의 이름을 수정
  </td>
</tr>
<tr>
<td>2003 년 1 월 29 일</td><td>
jthread 를 사용하기 위해(때문에) GetThread 를 삭제
  </td>
</tr>
<tr>
<td>2003 년 1 월 31 일</td><td>
GetMethodName 와 같게 NULL 를 허가하도록(듯이) GetFieldName 를 변경
  </td>
</tr>
<tr>
<td><b>v40</b> <br> 2003 년 2 월 29 일</td><td>
개요의 텍스트를 고쳐 써, 기동, 환경, 및 바이트코드Instrumentation에 관한 섹션을 추가. EG 디스커션에 따라 커멘드행 인수를 변경. 권한의 섹션에 개요 정보를 추가. 확장 기구의 카테고리와 함수를 추가. SuspendAllThreads 의 삭제를 지정 (설명을 개정). IterateOverLiveObjects 의 이름을 IterateOverReachableObjects 로 변경해, 이 변경에 응해 텍스트도 변경. IterateOverHeap 의 설명을 개정. CompiledMethodLoad 의 설명을 개정. 함수 호출의 필요 조건에 대해 검토. SetAllocationHooks 의 설명을 개정. 「해결 예정」으로서 문제를 추가. 그 외
  </td>
</tr>
<tr>
<td><b>v41</b> <br> 2003 년 3 월 6 일</td><td>
GetOwnedMonitorInfo 의 호출로부터 구조체를 삭제. 대부분의 에러 정보를 자동 생성, 자필의 에러 정보를 삭제.  권한의 사용에 관한 설명을 개정 (빈 상태(empty)의 초기 세트). jint 파라미터의 최소치를 추가. 권한 can_access_thread_local_storage 를 삭제. 에러 JVMTI_ERROR_NOT_IMPLEMENTED 의 이름을 JVMTI_ERROR_MUST_POSSESS_CAPABILITY 로 변경.  *NOT_IMPLEMENTED 에 대해서도와 같이  변경. 설명을 수정
  </td>
</tr>
<tr>
<td><b>v42</b> <br> 2003 년 3 월 8 일</td><td>
GetClassSignature 의 이름을 GetClassName 로 변경. IterateOverClassObjects 의 이름을 IterateOverInstancesOfClass 로 변경. GetMaxStack 를 삭제 (오퍼랜드 스택은 JVM<small style="font-size: xx-small">&nbsp;</small>TI 에서는 사용되지 않는다). 설명을 수정:기동 시간의 정의, PopFrame 로부터의 네이티브 프레임 팝의 삭제, 그 외의 개정
  </td>
</tr>
<tr>
<td><b>v43</b> <br> 2003 년 3 월 8 일</td><td>
세세한 편집상의 문제를 수정
  </td>
</tr>
<tr>
<td><b>v44</b> <br> 2003 년 3 월 10 일</td><td>
단계의 정보를 추가. 이벤트 번호를 재맵 (컴팩트화)
  </td>
</tr>
<tr>
<td><b>v45</b> <br> 2003 년 3 월 11 일</td><td>
단계의 정보를 한층 더 추가 - 모두 허가. raw 모니터의 조회 및 이벤트를 삭제. 설명의 세세한 수정
  </td>
</tr>
<tr>
<td><b>v46</b> <br> 2003 년 3 월 12 일</td><td>
GetPhase 를 추가. 문서 전체로 「단계」를 사용. GetRawMonitorName 를 삭제. GetObjectMonitors 를 삭제
  </td>
</tr>
<tr>
<td><b>v47</b> <br> 2003 년 3 월 12 일</td><td>
링크, XML, 스펠링에 의한 수정. 콜백 구조체를 자동 생성
  </td>
</tr>
<tr>
<td><b>v48</b> <br> 2003 년 3 월 13 일</td><td>
1 문자의 XML 를 수정
  </td>
</tr>
<tr>
<td><b>v49</b> <br> 2003 년 3 월 13 일</td><td>
이벤트 파라미터명으로 대응하도록(듯이) 함수 파라미터명을 변경 (fooBarBaz 를 foo_bar_baz 로 변경)
  </td>
</tr>
<tr>
<td><b>v50</b> <br> 2003 년 3 월 14 일</td><td>
망가진 링크를 수정. thread 마커를 수정
  </td>
</tr>
<tr>
<td><b>v51</b> <br> 2003 년 3 월 14 일</td><td>
컴파일러의 문제를 회피하기 위해(때문에), 128 보다 작아지도록(듯이) 정수를 변경
  </td>
</tr>
<tr>
<td><b>v52</b> <br> 2003 년 3 월 23 일</td><td>
권한에 대해 전면적으로 다시 봐. GetStackTrace 를 GetStackTrace 과 GetStackFrames 에 분할
  </td>
</tr>
<tr>
<td><b>v54</b> <br> 2003 년 4 월 8 일</td><td>
프레임의 참조에, jframeID 는 아니고 깊이를 사용. 부적절하게 된 GetCurrentFrame, GetCallerFrame, 및 GetStackFrames 를 삭제. 이벤트로부터 프레임 인수를 삭제
  </td>
</tr>
<tr>
<td><b>v55</b> <br> 2003 년 4 월 9 일</td><td>
테스트에 의해, 버퍼를 사용하는 편이 효율이 좋다고 알았기 때문에, GetObjectWithAnnotation 를 삭제. GetObjectsWithAnnotations 에 annotation_count 를 추가
  </td>
</tr>
<tr>
<td><b>v56</b> <br> 2003 년 4 월 10 일</td><td>
GetObjectsWithAnnotations 에 삽입된 애매한 기술을 삭제
  </td>
</tr>
<tr>
<td><b>v58</b> <br> 2003 년 4 월 13 일</td><td>
메소드의 jclass/jmethodID 표현을 jmethodID 로 치환. 모든 이벤트의 제 1 인수로서 JvmtiEnv* 를 건네준다. 올바르지 않은 개소로부터 JNIEnv* 를 삭제. can_access_frames 를 can_access_local_variables 로 치환. 순수한 스택 액세스로부터 삭제. can_get_synthetic_attribute 를 사용, 설명을 수정. 제로 쵸하이열의 할당을 해제하도록 설명을 개정. RelinquishCapabilities 의 설명을 개정. JVMTI_ERROR_VM_DEAD 를 JVMTI_ERROR_WRONG_PHASE 에 일반화해 설명
  </td>
</tr>
<tr>
<td><b>v59</b> <br> 2003 년 4 월 27 일</td><td>
OBSOLETE_METHOD_ID 의 불필요한 간접 참조를 삭제
  </td>
</tr>
<tr>
<td><b>v60</b> <br> 2003 년 5 월 4 일</td><td>
OnLoad 시의 DestroyRawMonitor 를 허가
  </td>
</tr>
<tr>
<td><b>v61</b> <br> 2003 년 5 월 7 일</td><td>
DestroyRawMonitor 에 모니터의 소유자가 아닌 경우에 반환되는 에러를 추가
  </td>
</tr>
<tr>
<td><b>v62</b> <br> 2003 년 5 월 13 일</td><td>
raw 모니터의 시멘틱스를 개정. <code>GetThreadStatus</code> 의 플래그를 변경. <code>GetClassLoader</code> 는, bootstrap 클래스 로더의 경우 NULL 를 돌려준다. <code>GetClassName</code> 의 문제를 추가. 국소 변수 시그니챠를 정의. <code>GetObjectsWithAnnotations</code> 의 주석 배열내의 제로를 금지. <code>GetObjectsWithAnnotations</code> 의 스펙을 삭제. <code>SetAllocationHooks</code> 를 삭제. <code>SuspendAllThreads</code> 를 삭제
  </td>
</tr>
<tr>
<td><b>v63</b> <br> 2003 년 5 월 14 일</td><td>
데이터형 <code>jvmtiEventCallbacks</code> 를 정의. 제로장의 할당은 NULL 를 돌려준다. SetAllocationHooks 는 JVMDI 에서는 보관 유지되지만 JVM<small style="font-size: xx-small">&nbsp;</small>TI 로부터는 삭제. JVMTI_THREAD_STATUS_FLAG_INTERRUPTED 를 추가
  </td>
</tr>
<tr>
<td><b>v64</b> <br> 2003 년 5 월 15 일</td><td>
리뷰에 의해 표현을 변경
  </td>
</tr>
<tr>
<td><b>v65</b> <br> 2003 년 5 월 15 일</td><td>
최초의 알파판. jmethodID 와 jfieldID 를 일의로 변경.  jclass 는 사용하지 않는다
  </td>
</tr>
<tr>
<td><b>v66</b> <br> 2003 년 5 월 27 일</td><td>
세세한 XSLT 에러를 수정
  </td>
</tr>
<tr>
<td><b>v67</b> <br> 2003 년 6 월 13 일</td><td>
jfieldID 의 일의화를 취소해 (jmethodID 는 그대로)
  </td>
</tr>
<tr>
<td><b>v68</b> <br> 2003 년 6 월 17 일</td><td>
6 월 11 일의 Expert Group 미팅에 의한 변경 -- heap 함수의 재검토:싱글 콜백, GetHeapRoots 의 삭제, 도달 가능한 반복자의 추가, 「주석」의 이름을 「태그」로 변경. 대부분의 함수로, NULL thread 파라미터는 현재의 thread. 타이머를 추가. ForceExit 를 삭제. GetEnvironmentLocalStorage 를 추가. 장황 플래그 및 이벤트를 추가. AddToBootstrapClassLoaderSearch 를 추가. ClassFileLoadHook 를 갱신
  </td>
</tr>
<tr>
<td><b>v69</b> <br> 2003 년 6 월 18 일</td><td>
문제점의 섹션을 개정. GetClassName 의 이름을 GetClassSignature 에 되돌려, 설명을 수정. GetClassSignature, GetFieldSignature, GetMethodSignature, 및 GetLocalVariableTable 에 총칭 시그니챠를 추가. EstimateCostOfCapabilities 를 삭제. 시스템 프로퍼티 함수가 시스템 프로퍼티의 VM 뷰로 동작하는 것을 명시. Agent_OnLoad 의 설명을 개정. 이벤트의 JNIEnv* 로부터 정수를 삭제. 메타데이타아크세사를 추가
  </td>
</tr>
<tr>
<td><b>v70</b> <br> 2003 년 6 월 18 일</td><td>
GetStackTrace 에 start_depth 를 추가. 시스템 프로퍼티을 새로운 카테고리에 이동. GetObjectSize 를 추가. 커멘드행 플래그로부터 X 를 삭제. XML, HTML, 스펠링에 의한 수정
  </td>
</tr>
<tr>
<td><b>v71</b> <br> 2003 년 6 월 19 일</td><td>
JVMTI_HEAP_ROOT_THREAD 를 6 에 수정. 각설명이 함수명에 일치하도록(듯이) 변경. 애매한 표현을 수정
  </td>
</tr>
<tr>
<td><b>v72</b> <br> 2003 년 6 월 26 일</td><td>
SetThreadLocalStorage 와 SetEnvironmentLocalStorage 에서는, 값을 NULL 로 설정할 수 없으면 안 된다. NotifyFramePop, GetFrameLocationm, 및 프레임에 대해 기술할 필요가 있는 모든 국소 변수의 조작을 수정. 전체에 걸쳐서, 문법을 수정해, 설명을 명료화할 필요가 있다. 대문자와 소문자의 구별, 구두점을 일치시킬 필요가 있다. 마이크로 버젼 번호와 메이저, 마이너, 및 마이크로 버젼 번호에 액세스 하는 마스크가 필요. 에러 코드 리스트에, 구현에 의해 반환되는 에러 코드를 나타낼 필요가 있다. 커멘드행 프로퍼티을 프로퍼티 함수내에서 가시로 할 필요가 있다. 현재의 thread로부터의 팝을 금지. 팝 할 수 없을 때, 구현이 불투명한 프레임 에러를 돌려주는 것을 허가. NativeMethodBind 이벤트는, 어느 단계에서도 송신할 수 없으면 안 된다. DynamicCodeGenerated 이벤트는, 어느 단계에서도 송신할 수 없으면 안 된다. VMInit 의 전에, 다음의 함수의 실행이 허가되지 않으면 안 되는 :Set/GetEnvironmentLocalStorage GetMethodDeclaringClass GetClassSignature GetClassModifiers IsInterface IsArrayClass GetMethodName GetMethodModifiers GetMaxLocals GetArgumentsSize GetLineNumberTable GetMethodLocation IsMethodNative IsMethodSynthetic. XSL 에 대한 그 외의 변경:인수의 설명으로, 포인터의 전은 아니고 뒤로 asterisk를 표시할 필요가 있다. NotifyFramePop, GetFrameLocationm, 및 그 외의 국소 변수의 조작에 NO_MORE_FRAMES 에러를 추가할 필요가 있다. 활동 상태가 아닌 thread는, 무효인 thread와는 다른 에러를 돌려줄 필요가 있다
  </td>
</tr>
<tr>
<td><b>v73</b> <br> 2003 년 7 월 7 일</td><td>
VerboseOutput 이벤트가 메세지 파라미터를 검출하지 않았다. 세세한 수정
  </td>
</tr>
<tr>
<td><b>v74</b> <br> 2003 년 7 월 14 일</td><td>
Technical Publications Department 에 의한 수정. thread 로컬 및 환경 로컬인 기억 영역에 NULL 를 설정하는 것을 허가
  </td>
</tr>
<tr>
<td><b>v75</b> <br> 2003 년 7 월 23 일</td><td>
overload 된 JVM_OnLoad 대신에 새로운 Agent_OnLoad 를 사용. 콜백에 JNICALL 를 추가 (XSL). 이벤트와 콜백의 양쪽 모두에 대해 JNICALL 의 요건을 문서화 (XSL). RedefineClasses 를 메소드와 속성에 한정. VerboseOutput 이벤트를 삭제. VMObjectAlloc:이벤트 송신시에 제한해, 메소드 파라미터를 삭제. Tech Pubs 의 편집 후, 거의 완성
  </td>
</tr>
<tr>
<td><b>v76</b> <br> 2003 년 7 월 24 일</td><td>
ClassFileLoadHook 이벤트가 재정의의 불형은 아니고 클래스를 송신하도록(듯이) 변경
  </td>
</tr>
<tr>
<td><b>v77</b> <br> 2003 년 7 월 24 일</td><td>
XML 파일. 텍스트의 세세한 부분의 개정과 수정
  </td>
</tr>
<tr>
<td><b>v78</b> <br> 2003 년 7 월 24 일</td><td>
JVM<small style="font-size: xx-small">&nbsp;</small>TI 로부터 GetExceptionHandlerTable 와 GetThrownExceptions 를 삭제. 스택 프레임이 JVM 스펙의 프레임인 것을 명기. can_get_source_info 를 can_get_source_file_name, can_get_line_numbers, 및 can_get_source_debug_extension 에 분할. PopFrame 는 네이티브 호출 메소드를 가질 수가 없다. GetClassloaderClasses 로부터 정확하지 않은 기술을 삭제 (http://java.sun.com/docs/books/vmspec/2nd-edition/html/ConstantPool.doc.html#79383 를 참조)
  </td>
</tr>
<tr>
<td><b>v79</b> <br> 2003 년 7 월 24 일</td><td>
XML 및 텍스트를 수정. 스택 프레임의 설명을 스택 프레임 카테고리에 이동
  </td>
</tr>
<tr>
<td><b>v80</b> <br> 2003 년 7 월 26 일</td><td>
GetClassloaderClasses 에 NULL (bootstrap loader)를 허가. 클래스로부터의 참조에 새로운 heap 참조의 종류를 추가. 타이머 정보의 구조체와 쿼리함수를 추가. AvailableProcessors 를 추가. GetOtherThreadCpuTime 의 이름을 GetThreadCpuTime 로 변경. SetEventNotification 모드에 JVMTI_ERROR_INVALID_THREAD 와 JVMTI_ERROR_THREAD_NOT_ALIVE 를 명시적으로 추가. VM_INIT 이벤트에 초기 thread를 추가. AddToBootstrapClassLoaderSearch 로부터 플랫폼의 가정 조건을 삭제
  </td>
</tr>
<tr>
<td><b>v81</b> <br> 2003 년 7 월 26 일</td><td>
리뷰에 의해, 문법과 표현을 변경
  </td>
</tr>
<tr>
<td><b>v82</b> <br> 2003 년 7 월 27 일</td><td>
리뷰에 의해, 문법과 표현을 한층 더 변경. Agent_OnUnload 를 추가
  </td>
</tr>
<tr>
<td><b>v83</b> <br> 2003 년 7 월 28 일</td><td>
Agent_OnUnload 의 귀가형을 void 로 변경
  </td>
</tr>
<tr>
<td><b>v84</b> <br> 2003 년 7 월 28 일</td><td>
JVMTI_REFERENCE_ARRAY 의 이름을 JVMTI_REFERENCE_ARRAY_ELEMENT 로 변경
  </td>
</tr>
<tr>
<td><b>v85</b> <br> 2003 년 7 월 28 일</td><td>
AvailableProcessors()의 java.lang.Runtime.availableProcessors()의 표현을 차용. 이벤트 ID 가 제로가 되지 않는 것을 보증.  해결된 문제를 삭제. 리뷰에 의해, 타이머 정보 함수의 이름을 변경, 설명을 추가
  </td>
</tr>
<tr>
<td><b>v86</b> <br> 2003 년 7 월 29 일</td><td>
XML 로 제어되는 구현에 대해서, 스펙에 영향이 없는 변경을 추가 :SetThreadLocalStorage 는 VM 모드로 실행할 필요가 있다
  </td>
</tr>
<tr>
<td><b>0.1. 87</b> <br> 2003 년 8 월 5 일</td><td>
GetErrorName 를 추가. jvmtiExtensionEvent 에 가변 인수의 경고를 추가. jvmtiExtensionEvent 의 jvmtiEnv* 로부터 정수를 삭제. 사용되지 않는 can_get_exception_info 기능을 삭제. jvmtiStartFunction 에 jvmtiEnv* 와 JNIEnv* 를 건네준다. jvmtiExtensionFunctionInfo.func 의 선언형을 수정. 확장 함수는 에러 코드를 돌려준다. 버젼 번호부 방식을 신규화
  </td>
</tr>
<tr>
<td><b>0.2. 88</b> <br> 2003 년 8 월 5 일</td><td>
ClassUnload 이벤트를 삭제
  </td>
</tr>
<tr>
<td><b>0.2. 89</b> <br> 2003 년 8 월 8 일</td><td>
heap 참조 반복자의 콜백은, 출력 객체 참조의 무시를 허가하는 열거형을 돌려준다. JNIEnv 를 확장 이벤트/확장 함수의 파라미터형으로서 허가
  </td>
</tr>
<tr>
<td><b>0.2. 90</b> <br> 2003 년 8 월 15 일</td><td>
타입 미스를 수정
  </td>
</tr>
<tr>
<td><b>0.2. 91</b> <br> 2003 년 9 월 2 일</td><td>
모든 메타데이타 함수를 삭제:GetClassMetadata, GetFieldMetadata, 및 GetMethodMetadata
  </td>
</tr>
<tr>
<td><b>0.2. 92</b> <br> 2003 년 10 월 1 일</td><td>
함수 Allocate 에 마크 뒤따라라. Deallocate, RawMonitor*, SetEnvironmentLocalStorage, 및 GetEnvironmentLocalStorage 를 heap 콜백 및 GC 이벤트내에서 안전하게 사용할 수 있는 것으로 한다
  </td>
</tr>
<tr>
<td><b>0.2. 93</b> <br> 2003 년 11 월 24 일</td><td>
heap 반복 함수 및 콜백에 파스스르가 불투명한 사용자 데이터 포인터를 추가. CompiledMethodUnload 이벤트로, 코드 주소를 송신한다. GarbageCollectionOccurred 이벤트를 추가. 정수 풀 참조의 종류를 추가. 함수 CreateRawMonitor 및 DestroyRawMonitor 를 heap 콜백 및 GC 이벤트내에서 안전하게 사용할 수 있는 것으로 한다. 설명을 개정:VMDeath, GetCurrentThreadCpuTimerInfo, GetThreadCpuTimerInfo, IterateOverReachableObjects, IterateOverObjectsReachableFromObject, GetTime, 및 JVMTI_ERROR_NULL_POINTER. 결핍 하고 있던 에러를 추가 :GenerateEvents 및 AddToBootstrapClassLoaderSearch. ClassFileLoadHook 이름 파라미터의 설명을 수정. heap 콜백 및 GC/ObjectFree 이벤트내에서, 명시적으로 허가된 함수 밖에 호출할 수 없게 지정. 콜백중, GetCurrentThreadCpuTimerInfo, GetCurrentThreadCpuTime, GetTimerInfo, 및 GetTime 를 허가. OnLoad 단계에서의 SetTag/GetTag 의 호출을 허가. SetEventNotificationMode 에 추가:올바르지 않은 thread 레벨에서의 제어를 시행했을 경우의 에러. jvmtiExceptionHandlerEntry 를 삭제. 스택의 네이티브 메소드의 처리를 수정 -- GetFrameLocation 의 location_ptr 파라미터, GetFrameLocation, jvmtiFrameInfo.location, 및 jlocation 로부터 JVMTI_ERROR_OPAQUE_FRAME 를 삭제. sleeve시에 MonitorWaited 이벤트가 송신되도록(듯이), 타입 미스를 삭제 (JVMPI 로부터
  </td>
</tr>
<tr>
<td><b>0.2. 94</b> <br> 2003 년 11 월 25 일</td><td>
설명의 개정과 타입 미스의 수정
  </td>
</tr>
<tr>
<td><b>0.2. 95</b> <br> 2003 년 12 월 3 일</td><td>
heap 반복자에서의 NULL user_data 를 허가
  </td>
</tr>
<tr>
<td><b>0.2. 97</b> <br> 2004 년 1 월 28 일</td><td>
GetThreadState 를 추가해, GetThreadStatus 를 비추천으로 한다
  </td>
</tr>
<tr>
<td><b>0.2. 98</b> <br> 2004 년 1 월 29 일</td><td>
INVALID_SLOT 및 TYPE_MISMATCH 에러는 옵션으로 하지 않으면 안 된다
  </td>
</tr>
<tr>
<td><b>0.2. 102</b> <br> 2004 년 2 월 12 일</td><td>
MonitorContendedExit 를 삭제. JNIEnv 파라미터를 VMObjectAlloc 에 추가. heap 콜백의 class_tag 및 referrer_index 파라미터를 명시적으로 정의
  </td>
</tr>
<tr>
<td><b>0.2. 103</b> <br> 2004 년 2 월 16 일</td><td>
JAVA_TOOL_OPTIONS 의 문서화
  </td>
</tr>
<tr>
<td><b>0.2. 105</b> <br> 2004 년 2 월 17 일</td><td>
개시 단계를 초기 단계와 개시 단계와에 분할. 함수나 이벤트의 VMStart 이벤트 변경 단계 관련을 추가
  </td>
</tr>
<tr>
<td><b>0.3. 6</b> <br> 2004 년 2 월 18 일</td><td>
비추천이 되어 있던 GetThreadStatus 를 삭제 마이너 버젼을 올려 마이크로 버젼으로부터 100 을 뺀다
  </td>
</tr>
<tr>
<td><b>0.3. 7</b> <br> 2004 년 2 월 18 일</td><td>
타이머의 나노초치가 부호없이 있는 것을 문서화. 네이티브 메소드 관련에 대해 명확하게 텍스트화
  </td>
</tr>
<tr>
<td><b>0.3. 8</b> <br> 2004 년 2 월 19 일</td><td>
타입 미스를 수정. 삭제한 비추천의 GetThreadStatus 를 삭제
  </td>
</tr>
<tr>
<td><b>0.3. 9</b> <br> 2004 년 2 월 23 일</td><td>
중단한 thread로 NotifyFramePop 를 실행해야 한다
  </td>
</tr>
<tr>
<td><b>0.3. 10</b> <br> 2004 년 2 월 24 일</td><td>
일부의 클래스를 변경할 수 없게, 권한 (<a href="#jvmtiCapabilities.can_redefine_any_class"><code>can_redefine_any_class</code></a>  및 <a href="#jvmtiCapabilities.can_generate_all_class_hook_events"><code>can_generate_all_class_hook_events</code></a> ) 및 에러 (<a href="#JVMTI_ERROR_UNMODIFIABLE_CLASS"><code>JVMTI_ERROR_UNMODIFIABLE_CLASS</code></a> )를 추가
  </td>
</tr>
<tr>
<td><b>0.3. 11</b> <br> 2004 년 2 월 28 일</td><td>
JVMTI_ERROR_MUST_POSSESS_CAPABILITY 를 SetEventNotificationMode 에 추가
  </td>
</tr>
<tr>
<td><b>0.3. 12</b> <br> 2004 년 3 월 8 일</td><td>
CompiledMethodUnload 를 명확하게 해, 클래스의 언로드 후에 이벤트가 포스트되는 경우가 있는 것을 명시
  </td>
</tr>
<tr>
<td><b>0.3. 13</b> <br> 2004 년 3 월 5 일</td><td>
VMObjectAlloc 의 size 파라미터를 jlong 로 변경해, GetObjectSize 에 맞춘다
  </td>
</tr>
<tr>
<td><b>0.3. 14</b> <br> 2004 년 3 월 13 일</td><td>
JNI FindClass 함수를 이벤트 콜백 함수로 사용하기 위한 가이드 라인을 추가
  </td>
</tr>
<tr>
<td><b>0.3. 15</b> <br> 2004 년 3 월 15 일</td><td>
GetAllStackTraces 및 GetThreadListStackTraces 를 추가
  </td>
</tr>
<tr>
<td><b>0.3. 16</b> <br> 2004 년 3 월 19 일</td><td>
ClassLoad 및 ClassPrepare 이벤트는, 개시 단계안에 포스트할 수 있다
  </td>
</tr>
<tr>
<td><b>0.3. 17</b> <br> 2004 년 3 월 25 일</td><td>
JVMTI_ERROR_NATIVE_METHOD 를 GetLineNumberTable, GetLocalVariableTable, GetMaxLocals, GetArgumentsSize, GetMethodLocation, GetBytecodes 에 추가
  </td>
</tr>
<tr>
<td><b>0.3. 18</b> <br> 2004 년 3 월 29 일</td><td>
타이머 정보 구조체의 타이머의 종류를 돌려준다
  </td>
</tr>
<tr>
<td><b>0.3. 19</b> <br> 2004 년 3 월 31 일</td><td>
스펙의 명확화 :JVMTI_THREAD_STATE_IN_NATIVE 에는 JNI 또는 JVM<small style="font-size: xx-small">&nbsp;</small>TI 를 포함하지 않는다. ForceGarbageCollection 는 파이나라이자를 실행하지 않는다. 스펙의 문맥은 Java 플랫폼. 이전의 Instrumentation을 경고
  </td>
</tr>
<tr>
<td><b>0.3. 20</b> <br> 2004 년 4 월 1 일</td><td>
상기로 명확화한 개소의 개선, 및 Agent_OnLoad 가 돌려준 에러로 VM 가 종료된다
  </td>
</tr>
<tr>
<td><b>0.3. 21</b> <br> 2004 년 4 월 1 일</td><td>
배열 클래스의 작성에서는, 클래스 로드 이벤트는 생성되지 않는다
  </td>
</tr>
<tr>
<td><b>0.3. 22</b> <br> 2004 년 4 월 7 일</td><td>
thread 상태의 계층을 보다 java.lang.Thread.State 에 갖춘다
  </td>
</tr>
<tr>
<td><b>0.3. 23</b> <br> 2004 년 4 월 12 일</td><td>
thread 상태에 대해 명확하게 했다
  </td>
</tr>
<tr>
<td><b>0.3. 24</b> <br> 2004 년 4 월 19 일</td><td>
에이전트에 의해 실행할 수 있기 (위해)때문에, GarbageCollectionOccurred 이벤트를 삭제
  </td>
</tr>
<tr>
<td><b>0.3. 25</b> <br> 2004 년 4 월 22 일</td><td>
「커멘드행 옵션」을 정의
  </td>
</tr>
<tr>
<td><b>0.3. 26</b> <br> 2004 년 4 월 29 일</td><td>
바이트코드Instrumentation의 의도된 사용 방법을 기술. 확장 이벤트의 제 1 파라미터의 설명을 수정
  </td>
</tr>
<tr>
<td><b>0.3. 27</b> <br> 2004 년 4 월 30 일</td><td>
설명의 개정과 타입 미스의 수정
  </td>
</tr>
<tr>
<td><b>0.3. 28</b> <br> 2004 년 5 월 18 일</td><td>
DataDumpRequest 이벤트를 삭제
  </td>
</tr>
<tr>
<td><b>0.3. 29</b> <br> 2004 년 5 월 18 일</td><td>
제로 타임 아웃의 RawMonitorWait 를 명확화. RunAgentThread 의 뒤의 thread 상태를 명확화
  </td>
</tr>
<tr>
<td><b>0.3. 30</b> <br> 2004 년 5 월 24 일</td><td>
클린 업:잘못한 링크나 낡은 링크의 수정 등
  </td>
</tr>
<tr>
<td><b>0.3. 31</b> <br> 2004 년 5 월 30 일</td><td>
이하를 포함한 명확화:모든 캐릭터 라인이 수정 UTF-8. 에이전트 thread의 가시성. 폐지 메소드 버젼의 의미. thread 호출 heap의 콜백
  </td>
</tr>
<tr>
<td><b>1.0. 32</b> <br> 2004 년 6 월 1 일</td><td>
major.minor 버젼 번호를 "1.0" 으로 변경
  </td>
</tr>
<tr>
<td><b>1.0. 33</b> <br> 2004 년 6 월 2 일</td><td>
ForceGarbageCollection 와 ObjectFree 의 상호작용을 명확화
  </td>
</tr>
<tr>
<td><b>1.0. 34</b> <br> 2004 년 6 월 6 일</td><td>
AddToBootstrapClassLoaderSearch 와 SetSystemProperty 를 OnLoad 국면에만 제한
  </td>
</tr>
<tr>
<td><b>1.0. 35</b> <br> 2004 년 6 월 11일</td><td>
SetTag 의 타입 미스를 수정
  </td>
</tr>
<tr>
<td><b>1.0. 36</b> <br> 2004 년 6 월 18 일</td><td>
상표를 수정. GetThreadState 의 사용법의 예에 파라미터를 추가
  </td>
</tr>
<tr>
<td><b>1.0. 37</b> <br> 2004 년 8 월 4 일</td><td>
저작권의 갱신
  </td>
</tr>
<tr>
<td><b>1.0. 38</b> <br> 2004 년 11 월 5 일</td><td>
결핍 하고 있던 함수 테이블 레이아웃을 추가. 결핍 하고 있던, 함수의 C++ 멤버 함수 형식의 설명을 추가. CFLH 의 이름이 NULL 가 될 가능성이 있는 것을 명확화. J2SE<sup style="font-size: xx-small">TM</sup> 5.0 의 일부로서 릴리스
  </td>
</tr>
<tr>
<td><b>1.1. 47</b> <br> 2005 년 4 월 24 일</td><td>
major.minor 버젼 번호를 "1.1" 으로 변경. ForceEarlyReturn* 함수군을 추가. GetOwnedMonitorStackDepthInfo 함수를 추가. GetCurrentThread 함수를 추가. 버젼 마커 「도입된 버젼」을 추가. AddToSystemClassLoaderSearch 를 추가. AddToBootstrapClassLoaderSearch 의 라이브 단계에서의 사용을 허가. IterateOverHeap 및 IterateOverInstancesOfClass 함수의 heap_object_callback 파라미터의 기술에 포함되어 있던 역사적인 불요 정보를 정리. 이 파라미터에서의 NULL 의 사용을 금지. 명확화, 수정, 및 일관성의 향상 :PopFrame 에서의 현재의 thread, 불투명한 프레임, 불충분한 수의 프레임에 관한 표현. 「최상정도」는 아니고 「현재의 프레임」을 일관해 사용. GetLocal* 및 SetLocal* 에서의 JVMTI_ERROR_TYPE_MISMATCH 에러를 명확화하기 위해(때문에), 그것들을 ForceEarlyReturn* 에서의 기술과 호환성이 있는 것으로 변경. 그 외가 많은 명확화와 표현의 클린 업
  </td>
</tr>
<tr>
<td><b>1.1. 48</b> <br> 2005 년 4 월 25 일</td><td>
GetConstantPool 의 추가. VM 스펙의 제 1 판에의 참조를 제 2 판에의 참조로 전환하고
  </td>
</tr>
<tr>
<td><b>1.1. 49</b> <br> 2005 년 4 월 26 일</td><td>
GetConstantPool 에서의 마이너/메이저 버젼의 차례를 명확화
  </td>
</tr>
<tr>
<td><b>1.1. 50</b> <br> 2005 년 4 월 26 일</td><td>
SetNativeMethodPrefix 와 SetNativeMethodPrefixes 의 추가. GetOwnedMonitorStackDepthInfo 를 위치 153 에 재할인 기대. 「클래스 로더 검색」을 독립한 문서 카테고리로서 분리. XML 소스내의 너무 긴 행을 처리
  </td>
</tr>
<tr>
<td><b>1.1. 51</b> <br> 2005 년 4 월 29 일</td><td>
라이브 단계에서의 에이전트의 기동을 허가. 에이전트의 배치에 관한 단락을 추가  
  </td>
</tr>
<tr>
<td><b>1.1. 52</b> <br> 2005 년 4 월 30 일</td><td>
SetNativeMethodPrefix(es)에 스펙의 설명을 추가. GetConstantPool 의 조건의 정의를 개선  
  </td>
</tr>
<tr>
<td><b>1.1. 53</b> <br> 2005 년 4 월 30 일</td><td>
GetConstantPool 로부터 GetClassVersionNumber 함수를 분리. VM 스펙에의 참조를 클린 업  
  </td>
</tr>
<tr>
<td><b>1.1. 54</b> <br> 2005 년 5 월 1 일</td><td>
SetNativeMethodPrefix(es)의 사용을 임의의 단계에서 허가. GetConstantPool 에의 재정의의 영향에 관한 설명을 추가  
  </td>
</tr>
<tr>
<td><b>1.1. 56</b> <br> 2005 년 5 월 2 일</td><td>
SetNativeMethodPrefix(es)에 관한 다양한 명확화
  </td>
</tr>
<tr>
<td><b>1.1. 57</b> <br> 2005 년 5 월 2 일</td><td>
결핍 하고 있던 퍼포먼스 경고를 메소드 엔트리 이벤트에 추가
  </td>
</tr>
<tr>
<td><b>1.1. 58</b> <br> 2005 년 5 월 5 일</td><td>
내부적인 JVMDI 지원를 삭제
  </td>
</tr>
<tr>
<td><b>1.1. 59</b> <br> 2005 년 5 월 8 일</td><td>
<a href="#RetransformClasses"><code>RetransformClasses</code></a>  를 추가. 바이트코드Instrumentation의 문서를 재편. <a href="#IsMethodObsolete"><code>IsMethodObsolete</code></a>  가 can_redefine_classes 권한을 필요로 하지 않는다고 하는 기술로 변경
  </td>
</tr>
<tr>
<td><b>1.1. 63</b> <br> 2005 년 5 월 11 일</td><td>
재변환의 명확화
  </td>
</tr>
<tr>
<td><b>1.1. 64</b> <br> 2005 년 5 월 11 일</td><td>
리뷰에 근거하는 재변환의 명확화. 클래스 로드 유효시의 「재변환 가능 (불가능)」를 고정
  </td>
</tr>
<tr>
<td><b>1.1. 67</b> <br> 2005 년 6 월 4 일</td><td>
프리미티브(primitive)치의 보고를 지원해, 참조측의 태그 설정을 가능하게 해, 보다 강력한 필터링 기능을 갖춘, 새로운 heap 기능을 추가:FollowReferences, IterateThroughHeap, 및 그것들에 관련하는 콜백, 구조체, 열거, 및 정수
  </td>
</tr>
<tr>
<td><b>1.1. 68</b> <br> 2005 년 6 월 4 일</td><td>
명확화
  </td>
</tr>
<tr>
<td><b>1.1. 69</b> <br> 2005 년 6 월 6 일</td><td>
FollowReferences, IterateThroughHeap:콜백을 구조 체내에 배치, 결핍 하고 있던 에러 코드를 추가, 비짓트 제어 플래그의 비트를 저감
  </td>
</tr>
<tr>
<td><b>1.1. 70</b> <br> 2005 년 6 월 14 일</td><td>
신heap 기능에 관한 추가 작업:리뷰에 근거하는 스펙의 정리
  </td>
</tr>
<tr>
<td><b>1.1. 71</b> <br> 2005 년 6 월 15 일</td><td>
신heap 기능에 관한 추가 작업:구heap 섹션의 이름을 「heap (1.0)」로 변경
  </td>
</tr>
<tr>
<td><b>1.1. 72</b> <br> 2005 년 6 월 21 일</td><td>
타입 미스를 수정.
  </td>
</tr>
<tr>
<td><b>1.1. 73</b> <br> 2005 년 6 월 27 일</td><td>
참조측 정보 구조체를 공용체로 변경
  </td>
</tr>
<tr>
<td><b>1.1. 74</b> <br> 2005 년 9 월 9 일</td><td>
신규 heap 함수군:결핍 하고 있던 참조의 종류 「슈퍼 클래스」를 추가. 필드 인덱스의 계산에 단일의 방식을 사용. 낡아진 구조체 베이스 참조측 정보에의 참조를 삭제
  </td>
</tr>
<tr>
<td><b>1.1. 75</b> <br> 2005 년 9 월 12 일</td><td>
FollowReferences 중에, 그다지 중요하지 않은 java.lang.Object 슈퍼 클래스상에서 콜백을 발생시키지 않다
  </td>
</tr>
<tr>
<td><b>1.1. 76</b> <br> 2005 년 9 월 13 일</td><td>
캐릭터 라인 프리미티브(primitive) 콜백으로, 길이를 Unicode 장으로 변경. 배열 프리미티브(primitive) 콜백과 캐릭터 라인 프리미티브(primitive) 콜백으로, 값을 「const」로 변경. JNI 함수 테이블의 설정시의 컴파일러의 잠재적인 영향에 대한 주를 추가
  </td>
</tr>
<tr>
<td><b>1.1. 77</b> <br> 2005 년 9 월 13 일</td><td>
GetClassVersionNumbers()와 GetConstantPool()는, 배열 또는 프리미티브(primitive) 클래스의 경우에 에러를 돌려주도록(듯이) 한다.
  </td>
</tr>
<tr>
<td><b>1.1. 78</b> <br> 2005 년 9 월 14 일</td><td>
문법에 관한 수정
  </td>
</tr>
<tr>
<td><b>1.1. 79</b> <br> 2005 년 9 월 26 일</td><td>
IsModifiableClass 쿼리를 추가
  </td>
</tr>
<tr>
<td><b>1.1. 81</b> <br> 2006 년 2 월 9 일</td><td>
jvmtiHeapReferenceCallback 에 referrer_class_tag 파라미터를 추가
  </td>
</tr>
<tr>
<td><b>1.1. 82</b> <br> 2006 년 2 월 13 일</td><td>
문서의 수정 :can_redefine_any_class 에 재변환이 포함되도록(듯이) 갱신. 예외 이벤트가 모든 Throwable 를 커버하는 것을 명확화. GetStackTrace 로, start_depth 가 제로의 경우, 너무 큰 start_depth 의 테스트를 하지 않는다. 프리미티브(primitive) 필드 콜백으로 보고되는 필드에 도착해 명확화 -- static 와 인스턴스. 이해하기 어려운 heap의 형태의 이름을, 콜백명도 포함해 수정. thread 기동 메소드로, 스택의 깊이에 일관성이 있는 사용을 요구. JVM<small style="font-size: xx-small">&nbsp;</small>TI 의 메모리 관리가 다른 시스템과 비호환인 것을 말한 주를 추가
  </td>
</tr>
<tr>
<td><b>1.1. 85</b> <br> 2006 년 2 월 14 일</td><td>
타입 미스의 수정, 이름의 변경
  </td>
</tr>
<tr>
<td><b>1.1. 86</b> <br> 2006 년 3 월 13 일</td><td>
jmethodID 와 jfieldID 가 보존 가능한 것을 명확화. 「클래스의 인스턴스의 반복」에 서브 클래스가 포함되는 것을 명확화
  </td>
</tr>
<tr>
<td><b>1.1. 87</b> <br> 2006 년 3 월 14 일</td><td>
표현의 수정
  </td>
</tr>
<tr>
<td><b>1.1. 88</b> <br> 2006 년 3 월 16 일</td><td>
객체 참조 콜백내의 static 필드의 referrer_index 가, 레퍼런스 구현 ( 및 그 외의 기존의 모든 구현)에 일치하도록(듯이) 변경. 즉, 인스턴스 필드의 정의에 일치하도록(듯이) 변경. GetThreadListStackTraces 로, 리스트내의 무효인 thread를 커버하기 위해서 JVMTI_ERROR_INVALID_THREAD 를 추가함과 함께, 기동되어 있지 않은 thread로부터는 빈 상태(empty)의 스택이 반환되는 것을 규정
  </td>
</tr>
<tr>
<td><b>1.1. 89</b> <br> 2006 년 3 월 17 일</td><td>
타입 미스
  </td>
</tr>
<tr>
<td><b>1.1. 90</b> <br> 2006 년 3 월 25 일</td><td>
타입 미스
  </td>
</tr>
<tr>
<td><b>1.1. 91</b> <br> 2006 년 4 월 6 일</td><td>
AddToBootstrapClassLoaderSearch 와 AddToSystemClassLoaderSearch 에 관한 제한을 삭제
  </td>
</tr>
<tr>
<td><b>1.1. 93</b> <br> 2006 년 5 월 1 일</td><td>
스택 깊이를 결정할 수 없는 구현의 모니터 스택의 깊이에 대해서 -1 를 돌려주도록(듯이) 스펙을 변경 
  </td>
</tr>
<tr>
<td><b>1.1. 94</b> <br> 2006 년 5 월 3 일</td><td>
IBM 의 Alan Pratt 씨에 따라 읽기 쉬움과 정확함을 높이기 위한 수정을 실시. FollowReferences 로 보고되는 객체의 관계를 기재
  </td>
</tr>
<tr>
<td><b>1.1. 95</b> <br> 2006 년 5 월 5 일</td><td>
FollowReferences 로 보고되는 객체의 관계를 명확화
  </td>
</tr>
<tr>
<td><b>1.1. 98</b> <br> 2006 년 6 월 28 일</td><td>
DisposeEnvironment 의 명확화, 경고를 추가. SetLocalXXX 에서의 타입 미스를 수정 ( 「retrieve」 => 「set」). 네이티브 메소드 접두사의 사용중은, 그 접두사의 설정 상태를 유지할 필요가 있는 것을 명확화. 에이전트 마다 엄밀하게 1 개의 Agent_OnXXX 가 불려 가는 것을 명확화. 라이브러리의 로드는 기동에 의존하지 않는 것을 명확화. Agent_OnUnload 스펙내에서의 Agent_OnLoad 에의 애매한 참조를 삭제
  </td>
</tr>
<tr>
<td><b>1.1. 99</b> <br> 2006 년 7 월 31 일</td><td>
함수와 예외와의 상호작용을 명확화. 필드 인덱스의 명확화와 구체적인 예의 추가. 이해하기 어려운 「즉 (That is)」의 문장을, MonitorWait 및 MonitorWaited 이벤트로부터 삭제. Java 6 을 포인트 하도록(듯이) 링크를 갱신
  </td>
</tr>
<tr>
<td><b>1.1. 102</b> <br> 2006 년 8 월 6 일</td><td>
ResourceExhausted 이벤트를 추가
  </td>
</tr>
</table>
</body>
</html>
